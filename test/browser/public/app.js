(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Caret = exports.CARET = void 0;
const views = require("./wml/caret");
const wml_1 = require("@quenk/wml");
const util_1 = require("../../util");
///classNames:begin
exports.CARET = 'ww-caret';
/**
 * Caret
 */
class Caret extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new views.Main(this);
        this.values = {
            root: {
                id: (this.attrs && this.attrs.id) ? this.attrs.id : '',
                className: (0, util_1.concat)(exports.CARET, (this.attrs && this.attrs.className) ?
                    this.attrs.className : '')
            }
        };
    }
}
exports.Caret = Caret;

},{"../../util":147,"./wml/caret":2,"@quenk/wml":157}],2:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('span', { 'id': __context.values.root.id, 'class': __context.values.root.className }, []);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],3:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Close = exports.CLOSE = void 0;
const views = require("./wml/close");
const wml_1 = require("@quenk/wml");
const util_1 = require("../../util");
///classNames:begin
exports.CLOSE = 'ww-close';
/**
 * Close
 */
class Close extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new views.Main(this);
        this.values = {
            id: (this.attrs && this.attrs.id) ?
                this.attrs.id : '',
            className: (0, util_1.concat)(exports.CLOSE, (this.attrs && this.attrs.className) ?
                this.attrs.className : ''),
            onClick: (this.attrs && this.attrs.onClick) ?
                this.attrs.onClick : () => { }
        };
    }
}
exports.Close = Close;

},{"../../util":147,"./wml/close":4,"@quenk/wml":157}],4:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('span', { 'id': __context.values.id, 'class': __context.values.className, 'onclick': __context.values.onClick }, [
                __document.createTextNode('×')
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],5:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Embed = exports.EMBED = void 0;
const wml_1 = require("@quenk/wml");
const util_1 = require("../../util");
const __1 = require("../../");
const embed_1 = require("./wml/embed");
///classNames:begin
exports.EMBED = 'ww-embed';
/**
 * Embed
 */
class Embed extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new embed_1.Main(this);
        this.values = {
            wml: {
                id: 'embed'
            },
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.EMBED, (0, __1.getClassName)(this.attrs)),
        };
    }
}
exports.Embed = Embed;

},{"../../":108,"../../util":147,"./wml/embed":6,"@quenk/wml":157}],6:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { 'id': __context.values.id, 'class': __context.values.className }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Link = exports.LinkClickedEvent = exports.LINK = void 0;
const wml = require("@quenk/wml");
const document = require("@quenk/wml/lib/dom");
const views = require("./views");
const util_1 = require("../../util");
const active_1 = require("../state/active");
const disabled_1 = require("../state/disabled");
///classNames:begin
/**
 * LINK
 */
exports.LINK = 'ww-link';
/**
 * LinkClickedEvent indicates an Link has been clicked.
 */
class LinkClickedEvent {
    constructor(name, href) {
        this.name = name;
        this.href = href;
    }
}
exports.LinkClickedEvent = LinkClickedEvent;
/**
 * Link generates an <a> element.
 */
class Link extends wml.Component {
    constructor() {
        super(...arguments);
        this.view = (this.attrs && this.attrs.disabled) ?
            new views.DisabledLinkView(this) :
            new views.LinkView(this);
        /**
         * name assigned to this Link.
         */
        this.name = (this.attrs && this.attrs.name) ?
            this.attrs.name : '';
        /**
         * title assigned to this Link.
         */
        this.title = (this.attrs && this.attrs.title) ?
            this.attrs.title : '';
        /**
         * href assigned to this Link
         */
        this.href = (this.attrs && this.attrs.href) ?
            this.attrs.href : '';
        this.values = {
            id: (this.attrs && this.attrs.id) ?
                this.attrs.id : '',
            disabled: (this.attrs && this.attrs.disabled) ?
                this.attrs.disabled : null,
            className: (0, util_1.concat)(exports.LINK, (this.attrs && this.attrs.className) ?
                this.attrs.className : '', (this.attrs && this.attrs.active) ?
                active_1.ACTIVE : '', (this.attrs && this.attrs.disabled) ?
                disabled_1.DISABLED : '', (this.attrs && this.attrs.disabled) ?
                `-ww-disabled` : ''),
            title: (this.attrs && this.attrs.title) ?
                this.attrs.title : null,
            name: (this.attrs && this.attrs.name) ?
                this.attrs.name : null,
            href: (this.attrs && this.attrs.href) ?
                this.attrs.href : '#',
            active: (this.attrs && this.attrs.active) ?
                this.attrs.active : false,
            //TODO: move to dom lib
            content: (this.attrs && this.attrs.text) ?
                [document.createTextNode(this.attrs.text)] :
                this.children,
            clicked: (e) => {
                if (this.attrs && !this.attrs.disabled) {
                    let { name, href, onClick } = this.attrs;
                    if (!href)
                        e.preventDefault();
                    if (onClick)
                        onClick(new LinkClickedEvent(name, href));
                }
            }
        };
    }
    /**
      * activate this nav list Item.
      */
    activate() {
        let m = (0, util_1.getById)(this.view, this.values.id);
        if (m.isJust()) {
            let e = m.get();
            e.classList.remove(active_1.ACTIVE);
            e.classList.add(active_1.ACTIVE);
        }
        return this;
    }
    /**
     * deactivate this nav list item.
     */
    deactivate() {
        let m = (0, util_1.getById)(this.view, this.values.id);
        if (m.isJust())
            m.get().classList.remove(active_1.ACTIVE);
        return this;
    }
}
exports.Link = Link;

},{"../../util":147,"../state/active":17,"../state/disabled":18,"./views":8,"@quenk/wml":157,"@quenk/wml/lib/dom":156}],8:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LinkView = exports.DisabledLinkView = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class DisabledLinkView {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('span', { 'id': __context.values.id, 'class': __context.values.className, 'href': __context.values.href, 'title': __context.values.title, 'onclick': __context.values.clicked }, [
                ...(__context.values.content)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.DisabledLinkView = DisabledLinkView;
;
class LinkView {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('a', { 'id': __context.values.id, 'class': __context.values.className, 'href': __context.values.href, 'title': __context.values.title, 'onclick': __context.values.clicked }, [
                ...(__context.values.content)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.LinkView = LinkView;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],9:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Description = exports.Media = exports.MediaDescription = exports.MEDIA_DESCRIPTION_DESCRIPTION = exports.MEDIA_DESCRIPTION_MEDIA = exports.MEDIA_DESCRIPTION = void 0;
const views = require("./wml/media-description");
const wml_1 = require("@quenk/wml");
const util_1 = require("../../util");
const __1 = require("../../");
///classNames:begin
exports.MEDIA_DESCRIPTION = 'ww-media-description';
exports.MEDIA_DESCRIPTION_MEDIA = 'ww-media-description__media';
exports.MEDIA_DESCRIPTION_DESCRIPTION = 'ww-media-description__description';
/**
 * MediaDescription
 */
class MediaDescription extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new views.MediaDescription(this);
        this.values = {
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.MEDIA_DESCRIPTION, (0, __1.getClassName)(this.attrs))
        };
    }
}
exports.MediaDescription = MediaDescription;
/**
 * Media
 */
class Media extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new views.Media(this);
        this.values = {
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.MEDIA_DESCRIPTION_MEDIA, (0, __1.getClassName)(this.attrs))
        };
    }
}
exports.Media = Media;
/**
 * Description
 */
class Description extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new views.Description(this);
        this.values = {
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.MEDIA_DESCRIPTION_DESCRIPTION, (0, __1.getClassName)(this.attrs))
        };
    }
}
exports.Description = Description;

},{"../../":108,"../../util":147,"./wml/media-description":10,"@quenk/wml":157}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Description = exports.Media = exports.MediaDescription = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class MediaDescription {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { 'id': __context.values.id, 'class': __context.values.className }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.MediaDescription = MediaDescription;
;
class Media {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { 'id': __context.values.id, 'class': __context.values.className }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Media = Media;
;
class Description {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { 'id': __context.values.id, 'class': __context.values.className }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Description = Description;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],11:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MenuIcon = exports.MENU_ICON_DASH = exports.MENU_ICON = void 0;
const views = require("./wml/menu-icon");
const wml_1 = require("@quenk/wml");
const util_1 = require("../../util");
///classNames:begin
exports.MENU_ICON = 'ww-menu-icon';
exports.MENU_ICON_DASH = 'ww-menu-icon__dash';
/**
 * MenuIcon provides a css implement icon normally used
 * to toggle a side menu.
 */
class MenuIcon extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new views.Main(this);
        this.values = {
            root: {
                id: (this.attrs && this.attrs.id) ?
                    this.attrs.id : '',
                className: (0, util_1.concat)(exports.MENU_ICON, (this.attrs && this.attrs.id) ?
                    this.attrs.id : '')
            },
            dash: {
                id: 'dash',
                class: exports.MENU_ICON_DASH
            }
        };
    }
}
exports.MenuIcon = MenuIcon;

},{"../../util":147,"./wml/menu-icon":12,"@quenk/wml":157}],12:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('span', { 'id': __context.values.root.id, 'class': __context.values.root.className }, [
                __this.node('span', { 'class': __context.values.dash.class }, []),
                __this.node('span', { 'class': __context.values.dash.class }, []),
                __this.node('span', { 'class': __context.values.dash.class }, [])
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],13:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBlockClassName = exports.BOTTOM = exports.MIDDLE = exports.HORIZONTAL = exports.RIGHT = exports.LEFT = exports.JUSTIFIED = exports.CLEARFIX = exports.BLOCK = exports.POSITIONED = exports.PUSHABLE = exports.VERTICAL = void 0;
///classNames:begin
/**
 * VERTICAL indicates an element is vertical rendererd.
 */
exports.VERTICAL = '-vertical';
/**
 * PUSHABLE indicates an element supports being pushed
 * and can have styles added to it around the concept.
 */
exports.PUSHABLE = '-pushable';
/**
 * POSITIONED indicates an element is positioned and responds
 * to the left,right etc. properties.
 */
exports.POSITIONED = '-positioned';
/**
 * BLOCK indicates an element should be block displayed.
 */
exports.BLOCK = '-block';
/**
 * CLEARFIX hack.
 */
exports.CLEARFIX = '-clearfix';
/**
 * JUSTIFIED content.
 */
exports.JUSTIFIED = '-justified';
/**
 * LEFT indicates content floated or positioned to the left.
 */
exports.LEFT = '-left';
/**
 * RIGHT indicates content floated or positioned to the right.
 */
exports.RIGHT = '-right';
/**
 * HORIZONTAL indicates a horizontal alignment.
 */
exports.HORIZONTAL = '-horizontal';
exports.MIDDLE = '-middle';
exports.BOTTOM = '-bottom';
///classNames:end
/**
 * getBlockClassName provides the __BLOCK__ class name if the attribute
 * value is set to true.
 */
const getBlockClassName = (attrs) => attrs.block === true ? exports.BLOCK : '';
exports.getBlockClassName = getBlockClassName;

},{}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Overlay = exports.OVERLAY = void 0;
const wml_1 = require("@quenk/wml");
const util_1 = require("../../util");
const __1 = require("../../");
const overlay_1 = require("./wml/overlay");
///classNames:begin
exports.OVERLAY = 'ww-overlay';
/**
 * Overlay
 */
class Overlay extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new overlay_1.Main(this);
        this.values = {
            wml: {
                id: 'root'
            },
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.OVERLAY, (0, __1.getClassName)(this.attrs)),
            onclick: () => {
                if (this.attrs && this.attrs.onClick)
                    this.attrs.onClick();
            }
        };
    }
    /**
     * close the overlay.
     */
    close() {
        let mO = (0, util_1.getById)(this.view, this.values.wml.id);
        if (mO.isJust()) {
            let n = mO.get();
            if (n.parentNode)
                n.parentNode.removeChild(n);
        }
    }
}
exports.Overlay = Overlay;

},{"../../":108,"../../util":147,"./wml/overlay":15,"@quenk/wml":157}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { wml: { 'id': __context.values.wml.id }, 'id': __context.values.id, 'class': __context.values.className, 'onclick': __context.values.onclick }, []);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],16:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSizeClassName = exports.Size = exports.EXTRA_LARGE = exports.LARGE = exports.MEDIUM = exports.SMALL = exports.EXTRA_SMALL = void 0;
///classNames:begin
exports.EXTRA_SMALL = '-extra-small';
exports.SMALL = '-small';
exports.MEDIUM = '-medium';
exports.LARGE = '-large';
exports.EXTRA_LARGE = '-extra-large';
///classNames:end
/**
 * Size
 */
var Size;
(function (Size) {
    Size["ExtraSmall"] = "extra-small";
    Size["Small"] = "small";
    Size["Medium"] = "medium";
    Size["Large"] = "large";
    Size["ExtraLarge"] = "extra-large";
})(Size = exports.Size || (exports.Size = {}));
/**
 * getSizeClassName
 */
const getSizeClassName = (s) => {
    if (s === Size.ExtraSmall)
        return exports.EXTRA_SMALL;
    else if (s === Size.Small)
        return exports.SMALL;
    else if (s === Size.Medium)
        return exports.MEDIUM;
    else if (s === Size.Large)
        return exports.LARGE;
    else if (s === Size.ExtraLarge)
        return exports.EXTRA_LARGE;
    return '';
};
exports.getSizeClassName = getSizeClassName;

},{}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isActive = exports.deactivate = exports.activate = exports.ACTIVE = void 0;
const util_1 = require("../../util");
///classNames:begin
/**
 * ACTIVE
 */
exports.ACTIVE = '-active';
/**
 * activate helper.
 *
 * Adds the ACTIVE class.
 */
const activate = (view, id) => (0, util_1.getById)(view, id)
    .map((e) => {
    e.classList.remove(exports.ACTIVE);
    e.classList.add(exports.ACTIVE);
});
exports.activate = activate;
/**
 * deactivate helper.
 *
 * Removes the ACTIVE class.
 */
const deactivate = (view, id) => (0, util_1.getById)(view, id)
    .map((e) => e.classList.remove(exports.ACTIVE));
exports.deactivate = deactivate;
/**
 * isActive helpder
 *
 * Queries whether the ACTIVE class is present.
 */
const isActive = (view, id) => (0, util_1.getById)(view, id)
    .map((e) => e.classList.contains(exports.ACTIVE))
    .orJust(() => false)
    .get();
exports.isActive = isActive;

},{"../../util":147}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DISABLED = void 0;
///classNames:begin
/**
 * DISABLED
 */
exports.DISABLED = '-disabled';
///classNames:end

},{}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toggle = exports.show = exports.hide = exports.isHidden = exports.HIDDEN = void 0;
const util_1 = require("../../util");
///classNames:begin
/**
 * HIDDEN means an element should not be visible but not removed
 * from the DOM.
 */
exports.HIDDEN = '-ww-hidden';
/**
 * isHidden helper.
 *
 * Retrieves an HTMLElement by id and checks whether
 * it has the hidden class attached.
 */
const isHidden = (view, id) => {
    let m = view.findById(id);
    if (m.isNothing()) {
        (0, util_1.warnMissing)(view, id);
        return true;
    }
    else {
        return m.get().classList.contains(exports.HIDDEN);
    }
};
exports.isHidden = isHidden;
/**
 * hide helper.
 *
 * Attempts to add HIDDEN to the target elements class name.
 */
const hide = (view, id) => {
    let m = view.findById(id);
    if (m.isNothing()) {
        return (0, util_1.warnMissing)(view, id);
    }
    else {
        let e = m.get();
        e.classList.remove(exports.HIDDEN);
        e.classList.add(exports.HIDDEN);
    }
};
exports.hide = hide;
/**
 * show helper.
 *
 * Attempts to remove the HIDDEN class name from the target element.
 */
const show = (view, id) => {
    let m = view.findById(id);
    if (m.isNothing()) {
        return (0, util_1.warnMissing)(view, id);
    }
    else {
        m.get().classList.remove(exports.HIDDEN);
    }
};
exports.show = show;
/**
 * toggle helper.
 *
 * Attempts to toggle the HIDDEN class name from the target element
 * classList.
 */
const toggle = (view, id) => {
    let m = view.findById(id);
    if (m.isNothing()) {
        return (0, util_1.warnMissing)(view, id);
    }
    else {
        m.get().classList.toggle(exports.HIDDEN);
    }
};
exports.toggle = toggle;

},{"../../util":147}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getStyleClassName = exports.styles = exports.Style = exports.OUTLINE = exports.ERROR = exports.WARNING = exports.INFO = exports.SUCCESS = exports.PRIMARY = exports.DEFAULT = void 0;
///classNames:begin
/**
 * DEFAULT style.
 */
exports.DEFAULT = '-default';
/**
 * PRIMARY style.
 */
exports.PRIMARY = '-primary';
/**
 * SUCCESS style.
 */
exports.SUCCESS = '-success';
/**
 * INFO style.
 */
exports.INFO = '-info';
/**
 * WARNING style.
 */
exports.WARNING = '-warning';
/**
 * ERROR style.
 */
exports.ERROR = '-error';
/**
 * OUTLINE style.
 */
exports.OUTLINE = '-outline';
///classNames:end
/**
 * Style enum.
 */
var Style;
(function (Style) {
    Style["Default"] = "default";
    Style["Primary"] = "primary";
    Style["Success"] = "success";
    Style["Info"] = "info";
    Style["Warning"] = "warning";
    Style["Error"] = "error";
})(Style = exports.Style || (exports.Style = {}));
exports.styles = [
    Style.Default,
    Style.Success,
    Style.Info,
    Style.Warning,
    Style.Error
];
/**
 * getStyleClassName
 */
const getStyleClassName = (s) => {
    switch (s) {
        case Style.Default:
            return exports.DEFAULT;
        case Style.Primary:
            return exports.PRIMARY;
        case Style.Success:
            return exports.SUCCESS;
        case Style.Info:
            return exports.INFO;
        case Style.Warning:
            return exports.WARNING;
        case Style.Error:
            return exports.ERROR;
    }
    return exports.DEFAULT;
};
exports.getStyleClassName = getStyleClassName;

},{}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tag = exports.TAG = exports.Style = void 0;
const dom_1 = require("@quenk/wml/lib/dom");
const wml_1 = require("@quenk/wml");
const style_1 = require("../../content/style");
Object.defineProperty(exports, "Style", { enumerable: true, get: function () { return style_1.Style; } });
const util_1 = require("../../util");
const __1 = require("../../");
const tag_1 = require("./wml/tag");
///classNames:begin
exports.TAG = 'ww-tag';
/**
 * Tag
 */
class Tag extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new tag_1.Main(this);
        this.values = {
            wml: {
                id: 'tag'
            },
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.TAG, (0, __1.getClassName)(this.attrs), (this.attrs && this.attrs.style) ?
                (0, style_1.getStyleClassName)(this.attrs.style) :
                style_1.DEFAULT),
            onclick: (_) => {
                if (this.attrs && this.attrs.onClick)
                    this.attrs.onClick();
            },
            content: (this.attrs && this.attrs.text) ?
                [(0, dom_1.text)(this.attrs.text)] : this.children
        };
    }
}
exports.Tag = Tag;

},{"../../":108,"../../content/style":20,"../../util":147,"./wml/tag":22,"@quenk/wml":157,"@quenk/wml/lib/dom":156}],22:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('span', { wml: { 'id': __context.values.wml.id }, 'id': __context.values.id, 'class': __context.values.className, 'onclick': __context.values.onclick }, [
                ...(__context.values.content)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Caption = exports.Thumbnail = exports.THUMBNAIL_CAPTION = exports.THUMBNAIL = void 0;
const views = require("./wml/thumbnail");
const wml_1 = require("@quenk/wml");
const util_1 = require("../../util");
const __1 = require("../../");
///classNames:begin
exports.THUMBNAIL = 'ww-thumbnail';
exports.THUMBNAIL_CAPTION = 'ww-thumbnail__caption';
/**
 * Thumbnail
 */
class Thumbnail extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = (this.attrs && this.attrs.href) ?
            new views.Anchor(this) : new views.Thumbnail(this);
        this.values = {
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.THUMBNAIL, (0, __1.getClassName)(this.attrs)),
            href: (this.attrs && this.attrs.href) ?
                this.attrs.href : '',
            onclick: (e) => {
                if (this.attrs && this.attrs.onClick) {
                    e.preventDefault();
                    this.attrs.onClick();
                }
            }
        };
    }
}
exports.Thumbnail = Thumbnail;
/**
 * Caption
 */
class Caption extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new views.Caption(this);
        this.values = {
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.THUMBNAIL_CAPTION, (0, __1.getClassName)(this.attrs))
        };
    }
}
exports.Caption = Caption;

},{"../../":108,"../../util":147,"./wml/thumbnail":24,"@quenk/wml":157}],24:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Caption = exports.Anchor = exports.Thumbnail = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Thumbnail {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { 'id': __context.values.id, 'class': __context.values.className, 'onclick': __context.values.onclick }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Thumbnail = Thumbnail;
;
class Anchor {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('a', { 'id': __context.values.id, 'class': __context.values.className, 'href': __context.values.href, 'onclick': __context.values.onclick }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Anchor = Anchor;
;
class Caption {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { 'id': __context.values.id, 'class': __context.values.className }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Caption = Caption;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],25:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ButtonGroup = exports.BUTTON_GROUP_COMPAT = exports.BUTTON_GROUP_BUTTON = exports.BUTTON_GROUP = void 0;
const views = require("./wml/button-group");
const wml_1 = require("@quenk/wml");
const util_1 = require("../../util");
const toolbar_1 = require("../toolbar");
const __1 = require("../../");
///classNames:begin
exports.BUTTON_GROUP = 'ww-button-group';
exports.BUTTON_GROUP_BUTTON = 'ww-button-group__button';
exports.BUTTON_GROUP_COMPAT = 'ww-button-group-compat';
/**
 * ButtonGroup groups multiple buttons into one element.
 */
class ButtonGroup extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new views.Main(this);
        this.values = {
            root: {
                id: (0, __1.getId)(this.attrs),
                className: (0, util_1.concat)(exports.BUTTON_GROUP, toolbar_1.TOOLBAR_COMPAT, (0, __1.getClassName)(this.attrs))
            }
        };
    }
}
exports.ButtonGroup = ButtonGroup;

},{"../../":108,"../../util":147,"../toolbar":87,"./wml/button-group":26,"@quenk/wml":157}],26:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { 'id': __context.values.root.id, 'class': __context.values.root.className }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],27:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiButtonSelect = exports.ButtonSelect = exports.MultiButtonSection = exports.ButtonSection = exports.ButtonSelectValues = exports.ButtonChangedEvent = exports.BUTTON_SELECT_OPTION = exports.BUTTON_SELECT = void 0;
const util_1 = require("../../util");
const __1 = require("../../");
const __2 = require("../");
const button_select_1 = require("./wml/button-select");
///className:begin
exports.BUTTON_SELECT = 'ww-button-select';
exports.BUTTON_SELECT_OPTION = 'ww-button-select__option';
/**
 * ButtonChangedEvent
 */
class ButtonChangedEvent extends __2.Event {
}
exports.ButtonChangedEvent = ButtonChangedEvent;
/**
 * @private
 */
class ButtonSelectValues {
    constructor(ref, button) {
        this.ref = ref;
        this.button = button;
        this.id = (0, __1.getId)(this.ref.attrs);
        this.className = (0, util_1.concat)(exports.BUTTON_SELECT, (0, __1.getClassName)(this.ref.attrs));
    }
}
exports.ButtonSelectValues = ButtonSelectValues;
/**
 * @private
 */
class ButtonSection {
    constructor(ref, onClick) {
        this.ref = ref;
        this.onClick = onClick;
        this.current = getCurrent(this.ref.attrs);
        this.selected = [];
        this.options = (this.ref.attrs && this.ref.attrs.options) ?
            this.ref.attrs.options : [];
        this.isActive = (n) => this.ref.values.button.current === n;
        this.getClassNames = (n) => (0, util_1.concat)(exports.BUTTON_SELECT_OPTION, this.ref.values.button.options[n].className);
    }
}
exports.ButtonSection = ButtonSection;
/**
 * @private
 */
class MultiButtonSection extends ButtonSection {
    constructor(ref, onClick) {
        super(ref, onClick);
        this.ref = ref;
        this.onClick = onClick;
        this.selected = getSelected(this.ref);
        this.isActive = (n) => this.ref.values.button.selected.indexOf(n) > -1;
    }
}
exports.MultiButtonSection = MultiButtonSection;
/**
 * ButtonSelect
 */
class ButtonSelect extends __2.AbstractControl {
    constructor() {
        super(...arguments);
        this.view = new button_select_1.ButtonSelectView(this);
        this.values = new ButtonSelectValues(this, new ButtonSection(this, (idx) => {
            this.values.button.current = idx;
            if ((this.attrs && this.attrs.onChange))
                this.attrs.onChange(new ButtonChangedEvent(this.attrs.name, this.values.button.options[idx].value));
            this.view.invalidate();
        }));
    }
}
exports.ButtonSelect = ButtonSelect;
/**
 * MultiButtonSelect
 */
class MultiButtonSelect extends __2.AbstractControl {
    constructor() {
        super(...arguments);
        this.view = new button_select_1.ButtonSelectView(this);
        this.values = new ButtonSelectValues(this, new MultiButtonSection(this, (n) => {
            let selected = this.values.button.selected;
            let pos = selected.indexOf(n);
            if (pos > -1)
                selected.splice(pos, 1);
            else
                selected.push(n);
            if (this.attrs && this.attrs.onChange)
                this.attrs.onChange(new ButtonChangedEvent(this.attrs.name, selected.map(n => this.values.button.options[n].value)));
            this.view.invalidate();
        }));
    }
}
exports.MultiButtonSelect = MultiButtonSelect;
const getCurrent = (attrs) => {
    if ((attrs != null) &&
        (attrs.value != null) &&
        (attrs.options != null)) {
        return attrs.options.reduce((p, c, k) => c.value ===
            attrs.value ? k : p, -1);
    }
    return -1;
};
const getSelected = (that) => {
    if (that.attrs &&
        that.attrs &&
        that.attrs.value &&
        that.attrs.options) {
        let { value, options } = that.attrs;
        return value.map(v => options.reduce((p, c, i) => (p > -1) ? p : (c.value === v) ? i : p, -1));
    }
    else {
        return [];
    }
};

},{"../":54,"../../":108,"../../util":147,"./wml/button-select":28}],28:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ButtonSelectView = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const button_group_1 = require("../../button-group");
;
const button_1 = require("../../button");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
;
class ButtonSelectView {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new button_group_1.ButtonGroup({ 'id': __context.values.id, 'className': __context.values.className }, [
                ...__forIn(__context.values.button.options, (opt, idx, _$$all) => ([
                    __this.widget(new button_1.Button({ 'className': __context.values.button.getClassNames(idx), 'active': __context.values.button.isActive(idx), 'onClick': () => __context.values.button.onClick(idx), 'text': opt.text }, []), { 'className': __context.values.button.getClassNames(idx), 'active': __context.values.button.isActive(idx), 'onClick': () => __context.values.button.onClick(idx), 'text': opt.text })
                ]), () => ([]))
            ]), { 'id': __context.values.id, 'className': __context.values.className });
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.ButtonSelectView = ButtonSelectView;

},{"../../button":29,"../../button-group":25,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],29:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Button = exports.ButtonClickedEvent = exports.BUTTON = exports.Style = void 0;
const views = require("./wml/button");
const dom_1 = require("@quenk/wml/lib/dom");
const toolbar_1 = require("../toolbar");
const active_1 = require("../../content/state/active");
const orientation_1 = require("../../content/orientation");
const style_1 = require("../../content/style");
Object.defineProperty(exports, "Style", { enumerable: true, get: function () { return style_1.Style; } });
const size_1 = require("../../content/size");
const util_1 = require("../../util");
const __1 = require("../../");
const __2 = require("../");
///classNames:begin
exports.BUTTON = 'ww-button';
;
/**
 * ButtonClickedEvent
 */
class ButtonClickedEvent extends __2.Event {
}
exports.ButtonClickedEvent = ButtonClickedEvent;
/**
 * Button is an improvement over HTMLButtionElement
 */
class Button extends __2.AbstractControl {
    constructor() {
        super(...arguments);
        this.view = (this.attrs && this.attrs.anchor) ?
            new views.AnchorView(this) : new views.ButtonView(this);
        this.values = {
            button: {
                wml: {
                    id: 'button'
                },
                id: (0, __1.getId)(this.attrs),
                className: (0, util_1.concat)(exports.BUTTON, (0, __1.getClassName)(this.attrs), toolbar_1.TOOLBAR_COMPAT, (this.attrs && this.attrs.style) ?
                    (0, style_1.getStyleClassName)(this.attrs.style) :
                    style_1.DEFAULT, (this.attrs && this.attrs.size) ?
                    (0, size_1.getSizeClassName)(this.attrs.size) : '', (this.attrs && this.attrs.outline) ?
                    style_1.OUTLINE : '', (this.attrs && this.attrs.block) ?
                    orientation_1.BLOCK : '', (this.attrs && this.attrs.active) ?
                    active_1.ACTIVE : ''),
                type: (this.attrs && this.attrs.type) ?
                    this.attrs.type : 'button',
                name: (this.attrs && this.attrs.name) ? this.attrs.name : '',
                disabled: (this.attrs && this.attrs.disabled) ? true : null,
                anchor: (this.attrs && this.attrs.anchor) ?
                    this.attrs.anchor : false,
                onclick: (e) => {
                    e.preventDefault();
                    this.attrs &&
                        this.attrs.onClick &&
                        this.attrs.onClick(new ButtonClickedEvent((this.attrs && this.attrs.name) ?
                            this.attrs.name : '', this.attrs.value));
                },
                content: () => (this.attrs && this.attrs.text) ?
                    [(0, dom_1.text)(this.attrs.text)] : this.children
            }
        };
    }
    /**
     * disable this button.
     */
    disable() {
        (0, util_1.getById)(this.view, this.values.button.wml.id)
            .map((b) => b.setAttribute('disabled', 'disabled'));
    }
    /**
     * enable this button.
     */
    enable() {
        (0, util_1.getById)(this.view, this.values.button.wml.id)
            .map((b) => b.removeAttribute('disabled'));
    }
    /**
     * toggle the disabled state of this button.
     */
    toggle() {
        (0, util_1.getById)(this.view, this.values.button.wml.id)
            .map((b) => b.hasAttribute('disabled') ?
            this.enable() : this.disable());
    }
}
exports.Button = Button;

},{"../":54,"../../":108,"../../content/orientation":13,"../../content/size":16,"../../content/state/active":17,"../../content/style":20,"../../util":147,"../toolbar":87,"./wml/button":30,"@quenk/wml/lib/dom":156}],30:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnchorView = exports.ButtonView = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class ButtonView {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('button', { wml: { 'id': __context.values.button.wml.id }, 'id': __context.values.button.id, 'type': __context.values.button.type, 'name': __context.values.button.name, 'disabled': __context.values.button.disabled, 'class': __context.values.button.className, 'onclick': __context.values.button.onclick }, [
                ...(__context.values.button.content())
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.ButtonView = ButtonView;
;
class AnchorView {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('a', { wml: { 'id': __context.values.button.wml.id }, 'id': __context.values.button.id, 'type': __context.values.button.type, 'href': '#', 'name': __context.values.button.name, 'disabled': __context.values.button.disabled, 'class': __context.values.button.className, 'onclick': __context.values.button.onclick }, [
                ...(__context.values.button.content())
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.AnchorView = AnchorView;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],31:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Checkbox = exports.CheckChangedEvent = exports.CHECKBOX = void 0;
const checkbox_1 = require("./wml/checkbox");
const util_1 = require("../../util");
const __1 = require("../");
const __2 = require("../../");
///classNames:begin
exports.CHECKBOX = 'ww-checkbox';
/**
 * CheckChangedEvent signals the user has changed the checkbox state.
 */
class CheckChangedEvent extends __1.Event {
}
exports.CheckChangedEvent = CheckChangedEvent;
/**
 * Checkbox control.
 *
 * This is an alternative to the native checkbox that can be styled.
 */
class Checkbox extends __1.AbstractControl {
    constructor() {
        super(...arguments);
        this.view = new checkbox_1.Main(this);
        this.values = {
            root: {
                id: (0, __2.getId)(this.attrs),
                className: (0, util_1.concat)(exports.CHECKBOX, (0, __2.getClassName)(this.attrs))
            },
            input: {
                name: (0, __1.getName)(this.attrs),
                value: (this.attrs && this.attrs.value) ?
                    this.attrs.value : null,
                onChange: () => {
                    this.values.input.value = (!this.values.input.value) || null;
                    if (this.attrs && this.attrs.onChange)
                        this.attrs.onChange(new CheckChangedEvent(this.values.input.name, this.values.input.value || false));
                }
            }
        };
    }
}
exports.Checkbox = Checkbox;

},{"../":54,"../../":108,"../../util":147,"./wml/checkbox":32}],32:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('span', { 'id': __context.values.root.id, 'class': __context.values.root.className }, [
                __this.node('label', {}, [
                    __this.node('input', { 'type': 'checkbox', 'name': __context.values.input.name, 'checked': __context.values.input.value, 'onchange': __context.values.input.onChange }, []),
                    ...(__context.children)
                ])
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],33:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CloseButton = exports.CLOSE_BUTTON = void 0;
const wml_1 = require("@quenk/wml");
const util_1 = require("../../util");
const __1 = require("../../");
const close_button_1 = require("./wml/close-button");
///classNames:begin
exports.CLOSE_BUTTON = 'ww-close-button';
;
/**
 * CloseButton used to display the "x" on dialogs etc.
 */
class CloseButton extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new close_button_1.Main(this);
        this.values = {
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.CLOSE_BUTTON, (0, __1.getClassName)(this.attrs)),
            wml: {
                id: 'close-button'
            },
            onclick: () => {
                if (this.attrs && this.attrs.onClick)
                    this.attrs.onClick();
            }
        };
    }
}
exports.CloseButton = CloseButton;

},{"../../":108,"../../util":147,"./wml/close-button":34,"@quenk/wml":157}],34:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const close_1 = require("../../../content/close");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('button', { 'id': __context.values.id, 'class': __context.values.className, 'onclick': __context.values.onclick }, [
                __this.widget(new close_1.Close({}, []), {})
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../content/close":3,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],35:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DateField = exports.DateChangedEvent = exports.Format = exports.usFormats = exports.commonFormats = exports.iso8601Formats = exports.YESTERDAY = exports.NOW = exports.TODAY = exports.DELAY = exports.VALUE_FORMAT = exports.DEFAULT_INPUT_DISPLAY = exports.DEFAULT_INPUT_PLACEHOLDER = exports.DEFAULT_INPUT_FORMAT = exports.DATE_FIELD_INPUT = exports.DATE_FIELD = void 0;
const views = require("./wml/date-field");
const moment = require("moment");
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const util_1 = require("../../util");
const feedback_1 = require("../feedback");
const form_1 = require("../form");
const __1 = require("../../");
const __2 = require("../");
const orientation_1 = require("../../content/orientation");
///classNames:begin
exports.DATE_FIELD = 'ww-date-field';
exports.DATE_FIELD_INPUT = 'ww-date-field__input';
///classNames:end
exports.DEFAULT_INPUT_FORMAT = moment.ISO_8601;
exports.DEFAULT_INPUT_PLACEHOLDER = 'YYYY-MM-DD';
exports.DEFAULT_INPUT_DISPLAY = 'YYYY-MM-DD';
exports.VALUE_FORMAT = 'YYYY-MM-DD';
exports.DELAY = 200;
exports.TODAY = 'today';
exports.NOW = 'now';
exports.YESTERDAY = 'yesterday';
exports.iso8601Formats = [
    'YYYY-MM-DD',
    'YYYY-MM-D',
    'YYYY-M-DD',
    'YYYY-M-D',
    'YY-MM-DD',
    'YY-MM-D',
    'YY-M-DD',
    'YY-M-D',
    'YYYY/MM/DD',
    'YYYY/MM/D',
    'YYYY/M/DD',
    'YYYY/M/D',
    'YY/MM/DD',
    'YY/MM/D',
    'YY/M/DD',
    'YY/M/D',
    'YYYY MM DD',
    'YYYY MM D',
    'YYYY M DD',
    'YYYY M D',
    'YY MM DD',
    'YY MM D',
    'YY M DD',
    'YY M D',
    'YYYYMMDD',
    'YYYYMMD',
    'YYYYMDD',
    'YYYYMD',
    'YYMMDD',
    'YYMMD',
    'YYMDD',
    'YYMD',
];
exports.commonFormats = [
    'DD-MM-YYYY',
    'D-MM-YYYY',
    'DD-M-YYYY',
    'D-M-YYYY',
    'DD-MM-YY',
    'D-MM-YY',
    'DD-M-YY',
    'D-M-YY',
    'DD/MM/YYYY',
    'D/MM/YYYY',
    'DD/M/YYYY',
    'D/M/YYYY',
    'DD/MM/YY',
    'D/MM/YY',
    'DD/M/YY',
    'D/M/YY',
    'DD MM YYYY',
    'D MM YYYY',
    'DD M YYYY',
    'D M YYYY',
    'DD MM YY',
    'D MM YY',
    'DD M YY',
    'D M YY',
    'DDMMYYYY',
    'DMMYYYY',
    'DDMYYYY',
    'DMYYYY',
    'DDMMYY',
    'DMMYY',
    'DDMYY',
    'DMYY',
];
exports.usFormats = [
    'MM-DD-YYYY',
    'MM-D-YYYY',
    'M-DD-YYYY',
    'M-D-YYYY',
    'MM-DD-YY',
    'MM-D-YY',
    'M-DD-YY',
    'M-D-YY',
    'MM/DD/YYYY',
    'MM/D/YYYY',
    'M/DD/YYYY',
    'M/D/YYYY',
    'MM/DD/YY',
    'MM/D/YY',
    'M/DD/YY',
    'M/D/YY',
    'MM DD YYYY',
    'MM D YYYY',
    'M DD YYYY',
    'M D YYYY',
    'MM DD YY',
    'MM D YY',
    'M DD YY',
    'M D YY',
    'MMDDYYYY',
    'MMDYYYY',
    'MDDYYYY',
    'MDYYYY',
    'MMDDYY',
    'MMDYY',
    'MDDYY',
    'MDYY',
];
/**
 * Format is used to determine what format input should be parsed as.
 */
var Format;
(function (Format) {
    Format[Format["ISO8601"] = 1] = "ISO8601";
    Format[Format["COMMON"] = 2] = "COMMON";
    Format[Format["USA"] = 3] = "USA";
})(Format = exports.Format || (exports.Format = {}));
/**
 * DateChangedEvent is generated when a valid date has been entered.
 *
 * The value is a truncated ISO8601 string consisting of the date part alone.
 */
class DateChangedEvent extends __2.Event {
}
exports.DateChangedEvent = DateChangedEvent;
/**
 * DateField provides a text field for entering dates.
 *
 * It will only fire change events when the date input matches one
 * of the 3 format sets (ISO8601,Common,US).
 *
 * If the user removes focus and the entry is not valid, it will be ignored
 * and no change event will be fired. Once a valid date has been entered,
 * the value displayed can be formated using the format specified in the
 * "display" attribute. This does not affect the actual value provided
 * to onChange handlers.
 */
class DateField extends form_1.AbstractFormControl {
    constructor() {
        super(...arguments);
        this.view = new views.Main(this);
        this.values = {
            root: {
                wml: { id: 'root' },
                id: (0, __1.getId)(this.attrs),
                className: (0, util_1.concat)(exports.DATE_FIELD, (0, __1.getClassName)(this.attrs), (0, orientation_1.getBlockClassName)(this.attrs), (0, feedback_1.getValidityClassName)(this.attrs)),
            },
            control: {
                wml: { id: 'input' },
                id: (0, __1.getId)(this.attrs)
            },
            label: {
                id: (this.attrs && this.attrs.name) || '',
                text: (this.attrs && this.attrs.label) || ''
            },
            messages: {
                wml: {
                    id: 'messages'
                },
                text: (0, feedback_1.getMessage)(this.attrs)
            },
            input: {
                wml: { id: 'input' },
                className: exports.DATE_FIELD_INPUT,
                name: (0, __2.getName)(this.attrs),
                format: getFormat(this.attrs),
                placeholder: getPlaceholder(this.attrs),
                display: getDisplay(this.attrs),
                moment: ((this.attrs && this.attrs.value) ?
                    (0, maybe_1.just)(parseDate(getValue(this.attrs), getFormat(this.attrs))) :
                    (0, maybe_1.nothing)()),
                value: () => (this.values.input.moment.isJust() &&
                    this.values.input.moment.get().isValid()) ?
                    this.values.input.moment.get().format(this.values.input.display) : '',
                disabled: (this.attrs && this.attrs.disabled === true) ?
                    true : null,
                onfocus: (e) => {
                    e.target.select();
                },
                oninput: (e) => {
                    e.target.oninput = null;
                    this.values.input.onkeyup(e);
                },
                onkeyup: (0, util_1.debounce)((e) => {
                    let value = e.target.value;
                    if (value === '') {
                        this.values.input.moment = (0, maybe_1.nothing)();
                        this.fireChange();
                    }
                    else {
                        let m = parseDate(value, this.values.input.format);
                        if (m.isValid()) {
                            this.values.input.moment = (0, maybe_1.just)(m);
                            this.fireChange();
                        }
                    }
                }, exports.DELAY),
                onblur: () => {
                    this.view.invalidate();
                }
            }
        };
    }
    /**
     * @private
     */
    fireChange() {
        if (this.attrs && this.attrs.onChange) {
            let name = this.attrs.name || '';
            if (this.values.input.moment.isJust()) {
                let m = this.values.input.moment.get();
                if (m.isValid())
                    this.attrs.onChange(new DateChangedEvent(name, m.format(exports.VALUE_FORMAT)));
            }
            else {
                this.attrs.onChange(new DateChangedEvent(name, undefined));
            }
        }
    }
    setMessage(msg) {
        this.values.messages.text = msg;
        (0, form_1.setMessage)(this.view, this.values.messages.wml.id, msg);
        return this;
    }
    removeMessage() {
        this.values.messages.text = '';
        (0, form_1.removeMessage)(this.view, this.values.messages.wml.id);
        return this;
    }
}
exports.DateField = DateField;
const parseDate = (d, formats) => {
    let str = d.toLowerCase();
    if ((str === exports.TODAY) || (str === exports.NOW)) {
        return moment.utc();
    }
    else if (str === exports.YESTERDAY) {
        return moment.utc().subtract(1, 'd');
    }
    else {
        return moment.utc(d, [...formats, moment.ISO_8601], true);
    }
};
const getValue = (attrs) => (attrs && attrs.value) ? attrs.value : '';
const getFormat = (attrs) => {
    if (attrs && attrs.format) {
        switch (attrs.format) {
            case 2:
                return exports.commonFormats;
            case 3:
                return exports.usFormats;
            default:
                break;
        }
    }
    return exports.iso8601Formats;
};
const getPlaceholder = (attrs) => {
    if (attrs && attrs.placeholder)
        return attrs.placeholder;
    if (attrs && attrs.format) {
        switch (attrs.format) {
            case 2:
                return 'DD-MM-YYYY';
            case 3:
                return 'MM-DD-YYYY';
            default:
                return 'YYYY-MM-DD';
        }
    }
    return 'YYYY-MM-DD';
};
const getDisplay = (attrs) => (attrs && attrs.display) ? attrs.display : exports.DEFAULT_INPUT_DISPLAY;

},{"../":54,"../../":108,"../../content/orientation":13,"../../util":147,"../feedback":45,"../form":51,"./wml/date-field":36,"@quenk/noni/lib/data/maybe":151,"moment":158}],36:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const label_1 = require("../../label");
;
const help_1 = require("../../help");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { 'id': __context.values.root.id, 'class': __context.values.root.className }, [
                __this.widget(new label_1.Label({ 'for': __context.values.root.id, 'text': __context.values.label.text }, []), { 'for': __context.values.root.id, 'text': __context.values.label.text }),
                __this.node('input', { wml: { 'id': __context.values.input.wml.id }, 'name': __context.values.input.wml.id, 'onfocus': __context.values.input.onfocus, 'oninput': __context.values.input.oninput, 'onkeyup': __context.values.input.onkeyup, 'onblur': __context.values.input.onblur, 'value': __context.values.input.value(), 'disabled': __context.values.input.disabled, 'class': __context.values.input.className, 'placeholder': __context.values.input.placeholder }, []),
                __this.widget(new help_1.Help({ wml: { 'id': __context.values.messages.wml.id }, 'text': __context.values.messages.text }, []), { wml: { 'id': __context.values.messages.wml.id }, 'text': __context.values.messages.text })
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../help":52,"../../label":57,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],37:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DisplayField = exports.DISPLAY_FIELD_CONTENT = exports.DISPLAY_FIELD = exports.Style = void 0;
const wml_1 = require("@quenk/wml");
const toolbar_1 = require("../toolbar");
const orientation_1 = require("../../content/orientation");
const disabled_1 = require("../../content/state/disabled");
const style_1 = require("../../content/style");
Object.defineProperty(exports, "Style", { enumerable: true, get: function () { return style_1.Style; } });
const size_1 = require("../../content/size");
const util_1 = require("../../util");
const __1 = require("../../");
const display_field_1 = require("./wml/display-field");
///classNames:begin
exports.DISPLAY_FIELD = 'ww-display-field';
exports.DISPLAY_FIELD_CONTENT = 'ww-display-field__content';
;
/**
 * DisplayField is used to display a value in a text field like box.
 */
class DisplayField extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new display_field_1.Main(this);
        this.values = {
            wml: {
                id: 'display'
            },
            id: (0, __1.getId)(this.attrs),
            disabled: (this.attrs && this.attrs.disabled) ?
                this.attrs.disabled : false,
            className: (0, util_1.concat)(exports.DISPLAY_FIELD, (0, __1.getClassName)(this.attrs), toolbar_1.TOOLBAR_COMPAT, (this.attrs && this.attrs.style) ?
                (0, style_1.getStyleClassName)(this.attrs.style) :
                style_1.DEFAULT, (this.attrs && this.attrs.size) ?
                (0, size_1.getSizeClassName)(this.attrs.size) : '', (this.attrs && this.attrs.block) ?
                orientation_1.BLOCK : '', (this.attrs && this.attrs.disabled) ?
                disabled_1.DISABLED : ''),
            onclick: (e) => {
                e.stopPropagation(); //prevent a bug when used with ResultsMenu
                if (this.attrs &&
                    this.attrs.onClick &&
                    (!this.values.disabled))
                    this.attrs.onClick();
            },
            content: {
                className: exports.DISPLAY_FIELD_CONTENT
            }
        };
    }
}
exports.DisplayField = DisplayField;

},{"../../":108,"../../content/orientation":13,"../../content/size":16,"../../content/state/disabled":18,"../../content/style":20,"../../util":147,"../toolbar":87,"./wml/display-field":38,"@quenk/wml":157}],38:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { 'id': __context.values.id, 'class': __context.values.className, 'onclick': __context.values.onclick }, [
                __this.node('div', { 'class': __context.values.content.className }, [
                    ...(__context.children)
                ])
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],39:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DropDown = exports.DROP_DOWN_CONTENT = exports.DROP_DOWN_TOGGLE = exports.DROP_DOWN = void 0;
const views = require("./wml/drop-down");
const hidden = require("../../content/state/hidden");
const style = require("../../content/style");
const wml_1 = require("@quenk/wml");
const button_group_1 = require("../button-group");
const util_1 = require("../../util");
const __1 = require("../../");
///classNames:begin
exports.DROP_DOWN = 'ww-drop-down-menu';
exports.DROP_DOWN_TOGGLE = 'ww-drop-down-menu__toggle';
exports.DROP_DOWN_CONTENT = 'ww-drop-down__content';
/**
 * DropDown provides a component for displaying a pop up menu.
 *
 *    +--------+
 *    |  Menu  |
 *    +--------+
 *    +-------------------------+
 *    |                         |
 *    | ----------------------- |
 *    |                         |
 *    | ----------------------- |
 *    |                         |
 *    | ----------------------- |
 *    |                         |
 *    +-------------------------+
 */
class DropDown extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new views.Main(this);
        this.values = {
            root: {
                wml: {
                    id: 'root'
                },
                id: (0, __1.getId)(this.attrs),
                className: (0, util_1.concat)(exports.DROP_DOWN, button_group_1.BUTTON_GROUP_COMPAT, (0, __1.getClassName)(this.attrs))
            },
            button: {
                text: (this.attrs && this.attrs.buttonText) ?
                    this.attrs.buttonText : '',
                anchor: (this.attrs && this.attrs.anchor) ?
                    this.attrs.anchor : false,
                className: (0, util_1.concat)(exports.DROP_DOWN_TOGGLE, style.DEFAULT, (this.attrs && this.attrs.buttonClassName) ?
                    this.attrs.buttonClassName : ''),
                disabled: (this.attrs && this.attrs.disabled) ?
                    this.attrs.disabled : undefined,
                template: () => (this.attrs && this.attrs.buttonTemplate) ?
                    this.attrs.buttonTemplate(this) : new views.ButtonView(this),
                onClick: () => {
                    let mayRoot = (0, util_1.getById)(this.view, this.values.root.wml.id);
                    if (mayRoot.isJust()) {
                        let e = mayRoot.get();
                        if (this.values.content.autoClose) {
                            let hide = this.values.content.hide;
                            //intercept clicks on button and content sections
                            for (let i = 0; i < e.children.length; i++) {
                                //prevent doubling up handlers.
                                e.children[i]
                                    .removeEventListener('click', hide);
                                e.children[i].addEventListener('click', hide);
                            }
                        }
                        this.toggle();
                        window.addEventListener('click', this);
                    }
                }
            },
            content: {
                wml: {
                    id: 'content'
                },
                className: (0, util_1.concat)(exports.DROP_DOWN_CONTENT, hidden.HIDDEN),
                autoClose: (this.attrs && this.attrs.autoClose === false) ?
                    false : true,
                render: () => this.children,
                hide: () => this.hide()
            }
        };
    }
    isHidden() {
        return hidden.isHidden(this.view, this.values.content.wml.id);
    }
    hide() {
        hidden.hide(this.view, this.values.content.wml.id);
        return this;
    }
    show() {
        hidden.show(this.view, this.values.content.wml.id);
        return this;
    }
    toggle() {
        hidden.toggle(this.view, this.values.content.wml.id);
        return this;
    }
    handleEvent(e) {
        (0, util_1.getById)(this.view, this.values.root.wml.id)
            .map((root) => {
            if (!document.body.contains(root))
                document.removeEventListener('click', this);
            if ((!root.contains(e.target)))
                this.hide();
        });
    }
}
exports.DropDown = DropDown;

},{"../../":108,"../../content/state/hidden":19,"../../content/style":20,"../../util":147,"../button-group":25,"./wml/drop-down":40,"@quenk/wml":157}],40:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = exports.ButtonView = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const button_1 = require("../../button");
;
const caret_1 = require("../../../content/caret");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class ButtonView {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new button_1.Button({ 'className': __context.values.button.className, 'anchor': __context.values.button.anchor, 'disabled': __context.values.button.disabled, 'onClick': __context.values.button.onClick }, [
                text((__context.values.button.text + ' ')),
                __this.widget(new caret_1.Caret({}, []), {})
            ]), { 'className': __context.values.button.className, 'anchor': __context.values.button.anchor, 'disabled': __context.values.button.disabled, 'onClick': __context.values.button.onClick });
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.ButtonView = ButtonView;
;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { wml: { 'id': __context.values.root.wml.id }, 'class': __context.values.root.className }, [
                __this.registerView(__context.values.button.template()).render(),
                __this.node('div', { wml: { 'id': __context.values.content.wml.id }, 'class': __context.values.content.className }, [
                    ...(__context.values.content.render())
                ])
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../content/caret":1,"../../button":29,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],41:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DropListField = exports.DROP_LIST_FIELD = exports.ItemChangedEvent = void 0;
const util_1 = require("../../util");
const feedback_1 = require("../feedback");
const select_1 = require("../select");
Object.defineProperty(exports, "ItemChangedEvent", { enumerable: true, get: function () { return select_1.ItemChangedEvent; } });
const form_1 = require("../form");
const __1 = require("../../");
const __2 = require("../");
const drop_list_field_1 = require("./wml/drop-list-field");
///classNames:begin
exports.DROP_LIST_FIELD = 'ww-drop-list-field';
/**
 * DropListField
 */
class DropListField extends form_1.AbstractFormControl {
    constructor() {
        super(...arguments);
        this.view = new drop_list_field_1.Main(this);
        this.values = {
            root: {
                wml: {
                    id: 'root'
                },
                id: (0, __1.getId)(this.attrs),
                className: (0, util_1.concat)(exports.DROP_LIST_FIELD, (0, __1.getClassName)(this.attrs), (0, feedback_1.getValidityClassName)(this.attrs))
            },
            messages: {
                wml: {
                    id: 'message'
                },
                text: (0, feedback_1.getMessage)(this.attrs)
            },
            label: {
                id: (0, __2.getName)(this.attrs),
                text: (0, form_1.getLabel)(this.attrs)
            },
            control: {
                wml: {
                    id: 'control'
                },
                name: (0, __2.getName)(this.attrs),
                className: (0, feedback_1.getValidityClassName)(this.attrs),
                block: true,
                placeholder: (this.attrs && this.attrs.placeholder),
                disabled: (this.attrs && this.attrs.disabled),
                value: (this.attrs && this.attrs.value),
                options: (this.attrs && this.attrs.options) ?
                    this.attrs.options : [],
                stringifier: this.attrs && this.attrs.stringifier,
                itemTemplate: (this.attrs && this.attrs.itemTemplate) ?
                    this.attrs.itemTemplate : undefined,
                noItemsTemplate: (this.attrs && this.attrs.noItemsTemplate) ?
                    this.attrs.noItemsTemplate : undefined,
                onSelect: (e) => {
                    if (this.attrs && this.attrs.onChange)
                        this.attrs.onChange(new select_1.ItemChangedEvent(e.name, e.value));
                },
            }
        };
    }
    setMessage(msg) {
        getHelp(this).map(h => h.setMessage(msg));
        return this;
    }
    removeMessage() {
        getHelp(this).map(h => h.removeMessage());
        return this;
    }
}
exports.DropListField = DropListField;
const getHelp = (t) => (0, util_1.getById)(t.view, t.values.messages.wml.id);

},{"../":54,"../../":108,"../../util":147,"../feedback":45,"../form":51,"../select":71,"./wml/drop-list-field":42}],42:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const label_1 = require("../../label");
;
const help_1 = require("../../help");
;
const drop_list_1 = require("../../drop-list");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { wml: { 'id': __context.values.root.wml.id }, 'id': __context.values.root.id, 'class': __context.values.root.className }, [
                __this.widget(new label_1.Label({ 'for': __context.values.root.id, 'text': __context.values.label.text }, []), { 'for': __context.values.root.id, 'text': __context.values.label.text }),
                __this.widget(new drop_list_1.DropList({ 'className': __context.values.control.className, 'name': __context.values.control.name, 'placeholder': __context.values.control.placeholder, 'disabled': __context.values.control.disabled, 'block': __context.values.control.block, 'value': __context.values.control.value, 'options': __context.values.control.options, 'onSelect': __context.values.control.onSelect, 'noItemsTemplate': __context.values.control.noItemsTemplate, 'itemTemplate': __context.values.control.itemTemplate, 'stringifier': __context.values.control.stringifier }, []), { 'className': __context.values.control.className, 'name': __context.values.control.name, 'placeholder': __context.values.control.placeholder, 'disabled': __context.values.control.disabled, 'block': __context.values.control.block, 'value': __context.values.control.value, 'options': __context.values.control.options, 'onSelect': __context.values.control.onSelect, 'noItemsTemplate': __context.values.control.noItemsTemplate, 'itemTemplate': __context.values.control.itemTemplate, 'stringifier': __context.values.control.stringifier }),
                __this.widget(new help_1.Help({ wml: { 'id': __context.values.messages.wml.id }, 'text': __context.values.messages.text }, []), { wml: { 'id': __context.values.messages.wml.id }, 'text': __context.values.messages.text })
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../drop-list":43,"../../help":52,"../../label":57,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],43:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DropList = exports.DROP_LIST = exports.ItemSelectedEvent = void 0;
const views = require("./wml/drop-list");
const util_1 = require("../../util");
const size_1 = require("../../content/size");
const orientation_1 = require("../../content/orientation");
const results_menu_1 = require("../results-menu");
Object.defineProperty(exports, "ItemSelectedEvent", { enumerable: true, get: function () { return results_menu_1.ItemSelectedEvent; } });
const search_1 = require("../search");
const __1 = require("../../");
const __2 = require("../");
///classNames:begin
exports.DROP_LIST = 'ww-drop-list';
/**
 * DropList provides a control for making a selection from a list of choices.
 */
class DropList extends __2.AbstractControl {
    constructor() {
        super(...arguments);
        this.view = new views.Main(this);
        this.values = {
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.DROP_LIST, (0, __1.getClassName)(this.attrs), (this.attrs && this.attrs.size) ?
                (0, size_1.getSizeClassName)(this.attrs.size) : '', (this.attrs && this.attrs.block) ?
                orientation_1.BLOCK : ''),
            name: (0, __2.getName)(this.attrs),
            value: (this.attrs && this.attrs.value),
            control: {
                wml: {
                    id: 'drop-list'
                }
            },
            messages: {
                wml: {
                    id: 'messages'
                }
            },
            display: {
                disabled: (this.attrs && this.attrs.disabled),
                placeholder: () => {
                    if (this.attrs) {
                        if (this.attrs.options && this.values.value)
                            return getCurrent(this.attrs.options, this.values.value);
                        return this.attrs.placeholder || 'Select one';
                    }
                },
                onClick: () => {
                    this.toggle();
                }
            },
            menu: {
                wml: {
                    id: 'menu'
                },
                name: (this.attrs && this.attrs.name) ?
                    this.attrs.name : '',
                block: (this.attrs && this.attrs.block) ?
                    this.attrs.block : false,
                hidden: true,
                results: (this.attrs && this.attrs.options) ?
                    this.attrs.options : [],
                onSelect: (e) => {
                    if (this.attrs && this.attrs.onSelect)
                        this.attrs.onSelect(new results_menu_1.ItemSelectedEvent(e.name, e.value.value));
                    this.values.value = e.value.value;
                    this.view.invalidate();
                },
                itemTemplate: (this.attrs && this.attrs.itemTemplate) ?
                    this.attrs.itemTemplate : undefined,
                noItemsTemplate: (this.attrs && this.attrs.noItemsTemplate) ?
                    this.attrs.noItemsTemplate : undefined,
                stringifier: (this.attrs && this.attrs.stringifier) ?
                    this.attrs.stringifier : (v) => v.label
            }
        };
    }
    /**
     * update changes the options available in the list.
     *
     * The view will be invalidated.
     */
    update(options) {
        this.values.menu.results = options;
        this.view.invalidate();
        return this;
    }
    /**
     * open the results menu.
     */
    open() {
        (0, search_1.openMenu)(this.view, this.values.menu.wml.id);
        return this;
    }
    /**
     * close the results menu.
     */
    close() {
        (0, search_1.closeMenu)(this.view, this.values.menu.wml.id);
        return this;
    }
    /**
     * toggle the results menu.
     */
    toggle() {
        (0, search_1.toggleMenu)(this.view, this.values.menu.wml.id);
        return this;
    }
}
exports.DropList = DropList;
const getCurrent = (opts, value, text = 'Select one') => opts.reduce((p, c) => c.value === value ? c.label : p, text);

},{"../":54,"../../":108,"../../content/orientation":13,"../../content/size":16,"../../util":147,"../results-menu":67,"../search":69,"./wml/drop-list":44}],44:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const caret_1 = require("../../../content/caret");
;
const results_menu_1 = require("../../results-menu");
;
const display_field_1 = require("../../display-field");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { 'id': __context.values.id, 'class': __context.values.className }, [
                __this.widget(new display_field_1.DisplayField({ 'onClick': __context.values.display.onClick, 'disabled': __context.values.display.disabled }, [
                    text(__context.values.display.placeholder()),
                    __this.widget(new caret_1.Caret({}, []), {})
                ]), { 'onClick': __context.values.display.onClick, 'disabled': __context.values.display.disabled }),
                __this.widget(new results_menu_1.ResultsMenu({ wml: { 'id': __context.values.menu.wml.id }, 'block': __context.values.menu.block, 'name': __context.values.menu.name, 'hidden': __context.values.menu.hidden, 'results': __context.values.menu.results, 'onSelect': __context.values.menu.onSelect, 'noItemsTemplate': __context.values.menu.noItemsTemplate, 'itemTemplate': __context.values.menu.itemTemplate, 'stringifier': __context.values.menu.stringifier }, []), { wml: { 'id': __context.values.menu.wml.id }, 'block': __context.values.menu.block, 'name': __context.values.menu.name, 'hidden': __context.values.menu.hidden, 'results': __context.values.menu.results, 'onSelect': __context.values.menu.onSelect, 'noItemsTemplate': __context.values.menu.noItemsTemplate, 'itemTemplate': __context.values.menu.itemTemplate, 'stringifier': __context.values.menu.stringifier })
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../content/caret":1,"../../display-field":37,"../../results-menu":67,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],45:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validationState2ClassName = exports.getMessage = exports.getValidityClassName = exports.getValidationState = exports.removeValidationState = exports.setValidationState = exports.removeMessage = exports.setMessage = exports.AbstractFeedbackControl = exports.ValidationState = void 0;
const style = require("../content/style");
const document = require("@quenk/wml/lib/dom");
const util_1 = require("../util");
const control_1 = require("../control");
/**
 * ValidationState
 */
var ValidationState;
(function (ValidationState) {
    ValidationState["Neutral"] = "neutral";
    ValidationState["Error"] = "error";
    ValidationState["Success"] = "success";
    ValidationState["Warning"] = "warning";
})(ValidationState = exports.ValidationState || (exports.ValidationState = {}));
/**
 * AbstractFeedbackControl
 *
 * Provides a default implementaion of the interface methods.
 */
class AbstractFeedbackControl extends control_1.AbstractControl {
    setMessage(msg) {
        (0, exports.setMessage)(this.view, this.values.messages.wml.id, msg);
        return this;
    }
    removeMessage() {
        (0, exports.removeMessage)(this.view, this.values.messages.wml.id);
        return this;
    }
    setValidationState(state) {
        (0, exports.setValidationState)(this.view, this.values.control.wml.id, state);
        return this;
    }
    removeValidationState() {
        (0, exports.removeValidationState)(this.view, this.values.control.wml.id);
        return this;
    }
    getValidationState() {
        return (0, exports.getValidationState)(this.view, this.values.control.wml.id);
    }
}
exports.AbstractFeedbackControl = AbstractFeedbackControl;
/**
 * setMessage helper.
 */
const setMessage = (view, id, msg) => (0, util_1.getById)(view, id)
    .map(messages => {
    let node = document.createTextNode(msg);
    while (messages.lastChild)
        messages.removeChild(messages.lastChild);
    messages.appendChild(node);
});
exports.setMessage = setMessage;
/**
 * removeMessage
 */
const removeMessage = (view, id) => (0, util_1.getById)(view, id)
    .map(messages => {
    while (messages.lastChild)
        messages.removeChild(messages.lastChild);
});
exports.removeMessage = removeMessage;
/**
 * setValidationState helper.
 */
const setValidationState = (view, id, state) => {
    (0, exports.removeValidationState)(view, id);
    if (state !== ValidationState.Neutral)
        (0, util_1.getById)(view, id)
            .map(e => e.classList.add((0, exports.validationState2ClassName)(state)));
};
exports.setValidationState = setValidationState;
/**
 * removeValidationState helper.
 */
const removeValidationState = (view, id) => {
    (0, util_1.getById)(view, id)
        .map((h) => {
        h.classList.remove(style.SUCCESS);
        h.classList.remove(style.ERROR);
        h.classList.remove(style.WARNING);
    });
};
exports.removeValidationState = removeValidationState;
/**
 * getValidationState calculates the ValidationState of an HTMLElement
 * (identified by id) by analysing its class list.
 */
const getValidationState = (view, id) => (0, util_1.getById)(view, id)
    .map(h => {
    if (h.classList.contains(style.SUCCESS))
        return ValidationState.Success;
    else if (h.classList.contains(style.WARNING))
        return ValidationState.Warning;
    else if (h.classList.contains(style.ERROR))
        return ValidationState.Error;
    else
        return ValidationState.Neutral;
})
    .get();
exports.getValidationState = getValidationState;
/**
 * getValidityClassName provides the applicable style class by checking
 * the validity properties of FeedbackControAttrs.
 */
const getValidityClassName = (attrs) => {
    if (attrs) {
        if (attrs.error && (attrs.error != ''))
            return style.ERROR;
        if (attrs.warning && (attrs.warning != ''))
            return style.WARNING;
        if (attrs.success && (attrs.success != ''))
            return style.SUCCESS;
    }
    return '';
};
exports.getValidityClassName = getValidityClassName;
/**
 * getMessage
 */
const getMessage = (attrs) => {
    if (attrs) {
        if (attrs.error && (attrs.error != ''))
            return attrs.error;
        if (attrs.warning && (attrs.warning != ''))
            return attrs.warning;
        if (attrs.success && (attrs.success != ''))
            return attrs.success;
        if (attrs.message && (attrs.message != ''))
            return attrs.message;
    }
    return '';
};
exports.getMessage = getMessage;
/**
 * validationState2ClassName transforms a ValidationState into
 * the corresponding class name (if any).
 */
const validationState2ClassName = (state) => {
    if (state === ValidationState.Success)
        return style.SUCCESS;
    else if (state === ValidationState.Warning)
        return style.WARNING;
    else if (state === ValidationState.Error)
        return style.ERROR;
    else
        return '';
};
exports.validationState2ClassName = validationState2ClassName;

},{"../content/style":20,"../control":54,"../util":147,"@quenk/wml/lib/dom":156}],46:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.list2Array = exports.FileInput = exports.FileChangedEvent = exports.FILE_INPUT = void 0;
const util_1 = require("../../util");
const __1 = require("../../");
const __2 = require("../");
const file_input_1 = require("./wml/file-input");
///classNames:begin
exports.FILE_INPUT = 'ww-file-input';
/**
 * FileChangedEvent is fired when
 */
class FileChangedEvent extends __2.Event {
}
exports.FileChangedEvent = FileChangedEvent;
/**
 * FileInput provides a surface for file selection.
 *
 * It supports drag and drop of the files as input.
 */
class FileInput extends __2.AbstractControl {
    constructor() {
        super(...arguments);
        this.view = new file_input_1.FileInputView(this);
        this.values = {
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.FILE_INPUT, (0, __1.getClassName)(this.attrs)),
            name: (0, __2.getName)(this.attrs),
            accept: (this.attrs && this.attrs.accept) ?
                this.attrs.accept : '',
            multiple: (this.attrs && this.attrs.multiple) ?
                this.attrs.multiple : undefined,
            change: (e) => {
                let input = e.target;
                if ((input.files != null) &&
                    (input.files.length > 0) &&
                    this.attrs &&
                    this.attrs.onChange) {
                    this.attrs.onChange(new FileChangedEvent(input.name, (0, exports.list2Array)(input.files)));
                }
            }
        };
    }
}
exports.FileInput = FileInput;
/**
 * list2Array converts a FileList into a plain array of files.
 */
const list2Array = (list) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret[i] = list[i];
    return ret;
};
exports.list2Array = list2Array;

},{"../":54,"../../":108,"../../util":147,"./wml/file-input":47}],47:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileInputView = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class FileInputView {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('input', { 'id': __context.values.id, 'class': __context.values.className, 'name': __context.values.name, 'type': 'file', 'accept': __context.values.accept, 'onchange': __context.values.change, 'multiple': __context.values.multiple }, []);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.FileInputView = FileInputView;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],48:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileUploadSurface = exports.FILE_UPLOAD_SURFACE_TEXT = exports.FILE_UPLOAD_SURFACE_INPUT = exports.FILE_UPLOAD_SURFACE = exports.INSTRUCTION_TEXT = exports.FileChangedEvent = void 0;
const util_1 = require("../../util");
const file_input_1 = require("../file-input");
Object.defineProperty(exports, "FileChangedEvent", { enumerable: true, get: function () { return file_input_1.FileChangedEvent; } });
const __1 = require("../../");
const __2 = require("../");
const file_upload_surface_1 = require("./wml/file-upload-surface");
exports.INSTRUCTION_TEXT = 'Choose a file';
///classNames:begin
exports.FILE_UPLOAD_SURFACE = 'ww-file-upload-surface';
exports.FILE_UPLOAD_SURFACE_INPUT = 'ww-file-upload-surface__input';
exports.FILE_UPLOAD_SURFACE_TEXT = 'ww-file-upload-surface__text';
/**
 * FileUploadSurface provides a surface for file selection.
 *
 * It supports drag and drop of the files as input.
 */
class FileUploadSurface extends __2.AbstractControl {
    constructor() {
        super(...arguments);
        this.view = new file_upload_surface_1.FileUploadSurfaceView(this);
        this.values = {
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.FILE_UPLOAD_SURFACE, (0, __1.getClassName)(this.attrs)),
            stop: (e) => {
                e.stopPropagation();
                e.preventDefault();
            },
            drop: (e) => {
                e.stopPropagation();
                e.preventDefault();
                let name = (this.attrs && this.attrs.name) ?
                    this.attrs.name : '';
                if (e.dataTransfer && e.dataTransfer.files.length > 0)
                    this.values.input.onChange(new file_input_1.FileChangedEvent(name, (0, file_input_1.list2Array)(e.dataTransfer.files)));
            },
            input: {
                className: exports.FILE_UPLOAD_SURFACE_INPUT,
                name: (0, __2.getName)(this.attrs),
                accept: (this.attrs && this.attrs.accept) ?
                    this.attrs.accept : '',
                multiple: (this.attrs && this.attrs.multiple) ?
                    this.attrs.multiple : undefined,
                onChange: (e) => {
                    this.values.text.value = e.value[0].name;
                    if (this.attrs && this.attrs.onChange)
                        this.attrs.onChange(e);
                    this.view.invalidate();
                }
            },
            text: {
                className: exports.FILE_UPLOAD_SURFACE_TEXT,
                value: (this.attrs && this.attrs.text) ?
                    this.attrs.text : exports.INSTRUCTION_TEXT
            }
        };
    }
}
exports.FileUploadSurface = FileUploadSurface;

},{"../":54,"../../":108,"../../util":147,"../file-input":46,"./wml/file-upload-surface":49}],49:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileUploadSurfaceView = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const file_input_1 = require("../../file-input");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class FileUploadSurfaceView {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { 'id': __context.values.id, 'class': __context.values.className, 'ondragenter': __context.values.stop, 'ondragover': __context.values.stop, 'ondrop': __context.values.drop }, [
                __this.widget(new file_input_1.FileInput({ 'className': __context.values.input.className, 'name': __context.values.input.name, 'accept': __context.values.input.accept, 'multiple': __context.values.input.multiple, 'onChange': __context.values.input.onChange }, []), { 'className': __context.values.input.className, 'name': __context.values.input.name, 'accept': __context.values.input.accept, 'multiple': __context.values.input.multiple, 'onChange': __context.values.input.onChange }),
                __this.node('div', { 'class': __context.values.text.className }, [
                    __this.node('h3', {}, [
                        text(__context.values.text.value)
                    ])
                ])
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.FileUploadSurfaceView = FileUploadSurfaceView;

},{"../../file-input":46,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],50:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.focus = exports.FocusLostEvent = exports.FocusGainedEvent = void 0;
const util_1 = require("../util");
/**
 * FocusGainedEvent
 */
class FocusGainedEvent {
    constructor(name) {
        this.name = name;
    }
}
exports.FocusGainedEvent = FocusGainedEvent;
/**
 * FocusLostEvent
 */
class FocusLostEvent {
    constructor(name) {
        this.name = name;
    }
}
exports.FocusLostEvent = FocusLostEvent;
/**
 * focus DOM helper.
 */
const focus = (view, id) => {
    (0, util_1.getById)(view, id)
        .map(e => e.focus());
};
exports.focus = focus;

},{"../util":147}],51:[function(require,module,exports){
"use strict";
/**
 * The form module deals with controls specifically for accepting user input.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeMessage = exports.setMessage = exports.getLabel = exports.AbstractFormControl = void 0;
const util_1 = require("../util");
const feedback_1 = require("./feedback");
/**
 * AbstractFormControl provides a base implementation of a
 * FormControl.
 */
class AbstractFormControl extends feedback_1.AbstractFeedbackControl {
}
exports.AbstractFormControl = AbstractFormControl;
/**
 * getLabel extracts the label value from FromControlAttrs.
 */
const getLabel = (attrs) => (attrs && attrs.label) ? attrs.label : '';
exports.getLabel = getLabel;
/**
 * setMessage helper.
 *
 * Sets the message on the Help widget.
 */
const setMessage = (view, id, msg) => {
    (0, util_1.getById)(view, id).map(h => { h.setMessage(msg); });
};
exports.setMessage = setMessage;
/**
 * removeMessage helper.
 *
 * Removes the message from the Help widget.
 */
const removeMessage = (view, id) => {
    (0, util_1.getById)(view, id).map(h => { h.removeMessage(); });
};
exports.removeMessage = removeMessage;

},{"../util":147,"./feedback":45}],52:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Help = exports.HELP = void 0;
const document = require("@quenk/wml/lib/dom");
const wml_1 = require("@quenk/wml");
const util_1 = require("../../util");
const feedback_1 = require("../feedback");
const __1 = require("../../");
const help_1 = require("./wml/help");
///classNames:begin
exports.HELP = 'ww-help';
/**
 * Help
 */
class Help extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new help_1.Main(this);
        this.values = {
            help: {
                wml: {
                    id: 'help'
                },
                id: (this.attrs && this.attrs.id) ?
                    this.attrs.id : '',
                className: (0, util_1.concat)(exports.HELP, (0, __1.getClassName)(this.attrs)),
                text: (this.attrs && this.attrs.text) ?
                    [document.createTextNode(this.attrs.text)] : this.children
            }
        };
    }
    setMessage(msg) {
        (0, feedback_1.setMessage)(this.view, this.values.help.wml.id, msg);
        return this;
    }
    removeMessage() {
        (0, feedback_1.removeMessage)(this.view, this.values.help.wml.id);
        return this;
    }
}
exports.Help = Help;

},{"../../":108,"../../util":147,"../feedback":45,"./wml/help":53,"@quenk/wml":157,"@quenk/wml/lib/dom":156}],53:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('span', { wml: { 'id': __context.values.help.wml.id }, 'id': __context.values.help.id, 'class': __context.values.help.className }, [
                ...(__context.values.help.text)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],54:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getValue = exports.getDisabled = exports.getName = exports.AbstractControl = exports.Event = void 0;
/**
 * This module provides the parent interfaces for most of the
 * widgets considered 'controls'.
 *
 * Controls allow users to manipulate the state of an application
 * by interacting with widgets on screen. In simpler terms,
 * they are the widgets that accept user input or trigger
 * reactions when the user manipulates them.
 *
 * Generally, we use a streaming based workflow, that is
 * as the user preforms a supported action and event is generated
 * each and every time and some handler is applied to the event.
 */
/** @imports */
const wml_1 = require("@quenk/wml");
const maybe_1 = require("@quenk/noni/lib/data/maybe");
/**
 * Event is the parent class of all events generated by controls.
 */
class Event {
    constructor(name, value) {
        this.name = name;
        this.value = value;
    }
}
exports.Event = Event;
/**
 * AbstractControl implements the methods of the Control interface.
 */
class AbstractControl extends wml_1.Component {
}
exports.AbstractControl = AbstractControl;
/**
 * getName
 */
const getName = (attrs) => (attrs && attrs.name) ? attrs.name : '';
exports.getName = getName;
/**
 * getDisabled
 */
const getDisabled = (attrs) => (attrs && attrs.disabled) ? attrs.disabled : undefined;
exports.getDisabled = getDisabled;
/**
 * getValue
 */
const getValue = (attrs) => (attrs && attrs.value) ? (0, maybe_1.just)(attrs.value) : (0, maybe_1.nothing)();
exports.getValue = getValue;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml":157}],55:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddOn = exports.InputGroup = exports.INPUT_GROUP_BUTTON_ADDON = exports.INPUT_GROUP_ADDON = exports.INPUT_GROUP = void 0;
const wml_1 = require("@quenk/wml");
const util_1 = require("../../util");
const __1 = require("../../");
const input_group_1 = require("./wml/input-group");
///classNames:begin
exports.INPUT_GROUP = 'ww-input-group';
exports.INPUT_GROUP_ADDON = 'ww-input-group__addon';
exports.INPUT_GROUP_BUTTON_ADDON = 'ww-input-group__button-addon';
/**
 * InputGroup allows an input to be wrapped together with other controls to
 * appear as one.
 *
 * This is useful for creating inputs that may have related fields that should
 * be modified when changed. For example, entering an amount and currency in the
 * same place.
 *
 *  +--------------------------------+
 *  | TTD ^ | 5000.00                |
 *  +--------------------------------+
 */
class InputGroup extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new input_group_1.InputGroupView(this);
        this.values = {
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.INPUT_GROUP, (0, __1.getClassName)(this.attrs)),
        };
    }
}
exports.InputGroup = InputGroup;
/**
 * AddOn is used to attach the extra text or control to the input.
 */
class AddOn extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new input_group_1.AddOnView(this);
        this.values = {
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(this.attrs.button ?
                exports.INPUT_GROUP_BUTTON_ADDON :
                exports.INPUT_GROUP_ADDON, (0, __1.getClassName)(this.attrs)),
        };
    }
}
exports.AddOn = AddOn;

},{"../../":108,"../../util":147,"./wml/input-group":56,"@quenk/wml":157}],56:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddOnView = exports.InputGroupView = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class InputGroupView {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { 'id': __context.values.id, 'class': __context.values.className }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.InputGroupView = InputGroupView;
;
class AddOnView {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { 'id': __context.values.id, 'class': __context.values.className }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.AddOnView = AddOnView;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],57:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Label = exports.LABEL = void 0;
const document = require("@quenk/wml/lib/dom");
const wml_1 = require("@quenk/wml");
const util_1 = require("../../util");
const __1 = require("../../");
const label_1 = require("./wml/label");
///classNames:begin
exports.LABEL = 'ww-label';
/**
 * Label
 */
class Label extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new label_1.Main(this);
        this.values = {
            label: {
                className: (0, util_1.concat)(exports.LABEL, (0, __1.getClassName)(this.attrs)),
                for: (this.attrs && this.attrs.for) ?
                    this.attrs.for : '',
                text: (this.attrs && this.attrs.text) ?
                    [document.createTextNode(this.attrs.text)] : this.children
            }
        };
    }
}
exports.Label = Label;

},{"../../":108,"../../util":147,"./wml/label":58,"@quenk/wml":157,"@quenk/wml/lib/dom":156}],58:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('label', { 'for': __context.values.label.for, 'class': __context.values.label.className }, [
                ...(__context.values.label.text)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],59:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiSelect = exports.ItemsChangedEvent = exports.DEFAULT_FONT_INCREMENT = exports.DEFAULT_INPUT_WIDTH = exports.MULTI_SELECT_TAG = exports.MULTI_SELECT_INPUT = exports.MULTI_SELECT_CONTENT = exports.MULTI_SELECT = exports.TermChangedEvent = void 0;
const views = require("./wml/multi-select");
const orientation_1 = require("../../content/orientation");
const form_1 = require("../form");
const search_1 = require("../search");
Object.defineProperty(exports, "TermChangedEvent", { enumerable: true, get: function () { return search_1.TermChangedEvent; } });
const util_1 = require("../../util");
const __1 = require("../../");
const __2 = require("../");
const feedback_1 = require("../feedback");
const active_1 = require("../../content/state/active");
const disabled_1 = require("../../content/state/disabled");
///classNames:begin
exports.MULTI_SELECT = 'ww-multi-select';
exports.MULTI_SELECT_CONTENT = 'ww-multi-select__content';
exports.MULTI_SELECT_INPUT = 'ww-multi-select__input';
exports.MULTI_SELECT_TAG = 'ww-multi-select__tag';
///classNames:end
exports.DEFAULT_INPUT_WIDTH = 50;
exports.DEFAULT_FONT_INCREMENT = 7;
/**
 * ItemsChangedEvent
 */
class ItemsChangedEvent extends __2.Event {
}
exports.ItemsChangedEvent = ItemsChangedEvent;
/**
 * MultiSelect
 */
class MultiSelect extends form_1.AbstractFormControl {
    constructor() {
        super(...arguments);
        this.view = new views.Main(this);
        this.values = {
            root: {
                wml: {
                    id: 'root'
                },
                disabled: (this.attrs && this.attrs.disabled) ?
                    this.attrs.disabled : false,
                id: (0, __1.getId)(this.attrs),
                className: (0, util_1.concat)(exports.MULTI_SELECT, (0, __1.getClassName)(this.attrs), (0, feedback_1.getValidityClassName)(this.attrs), (0, orientation_1.getBlockClassName)(this.attrs), (this.attrs && this.attrs.disabled) ?
                    disabled_1.DISABLED : '')
            },
            control: {
                wml: {
                    id: 'root'
                }
            },
            label: {
                wml: {
                    id: 'label'
                },
                text: (0, form_1.getLabel)(this.attrs)
            },
            search: {
                wml: {
                    id: 'search'
                },
                block: this.attrs && this.attrs.block || undefined,
                itemTemplate: (this.attrs && this.attrs.itemTemplate) ?
                    this.attrs.itemTemplate : undefined,
                noItemsTemplate: (this.attrs && this.attrs.noItemsTemplate) ?
                    this.attrs.noItemsTemplate : undefined,
                onSearch: (evt) => {
                    if (this.attrs && this.attrs.onSearch)
                        this.attrs.onSearch(evt);
                },
                onSelect: ({ value }) => {
                    this.push(value);
                    this.fireChange();
                    this.redraw();
                }
            },
            messages: {
                wml: {
                    id: 'message'
                },
                text: (0, feedback_1.getMessage)(this.attrs)
            },
            content: {
                className: exports.MULTI_SELECT_CONTENT,
                onfocus: () => this.focus()
            },
            tags: {
                className: (0, util_1.concat)(exports.MULTI_SELECT_TAG, (0, feedback_1.getValidityClassName)(this.attrs)),
                value: (this.attrs && this.attrs.value) ?
                    this.attrs.value : [],
                disabled: (this.attrs && this.attrs.disabled) ?
                    this.attrs.disabled : false,
                has: () => this.values.tags.value.length > 0,
                getText: (this.attrs && this.attrs.stringifier) ?
                    this.attrs.stringifier : (v) => String(v),
                onDismiss: (e) => {
                    let idx = Number(e.name);
                    this.values.tags.value.splice(idx, 1);
                    this.fireChange();
                    this.redraw();
                }
            },
            input: {
                wml: {
                    id: 'input'
                },
                className: exports.MULTI_SELECT_INPUT,
                name: (0, __2.getName)(this.attrs),
                inputWidth: (this.attrs && this.attrs.inputWidth) ?
                    this.attrs.inputWidth : exports.DEFAULT_INPUT_WIDTH,
                fontIncrement: (this.attrs && this.attrs.fontIncrement) ?
                    this.attrs.fontIncrement : exports.DEFAULT_FONT_INCREMENT,
                disabled: (this.attrs && this.attrs.disabled) ?
                    this.attrs.disabled : undefined,
                onSearch: (e) => {
                    if (!this.values.root.disabled) {
                        this.grow(e.value.length + 1);
                        if (this.attrs && this.attrs.onSearch)
                            this.attrs.onSearch(e);
                    }
                }
            },
            menu: {
                wml: { id: 'menu' },
                name: (0, __2.getName)(this.attrs),
                block: true,
                onSelect: (e) => {
                    this.close();
                    this.values.tags.value.push(e.value);
                    this.fireChange();
                    this.redraw();
                },
                itemTemplate: (this.attrs && this.attrs.itemTemplate) ?
                    this.attrs.itemTemplate : undefined,
                noItemsTemplate: (this.attrs && this.attrs.noItemsTemplate) ?
                    this.attrs.noItemsTemplate : undefined,
                stringifier: (this.attrs && this.attrs.stringifier) ?
                    this.attrs.stringifier : undefined
            }
        };
    }
    /**
     * @private
     */
    fireChange() {
        if (this.attrs && this.attrs.onChange)
            this.attrs.onChange(new ItemsChangedEvent((0, __2.getName)(this.attrs), this.values.tags.value.slice()));
    }
    /**
     * @private
     */
    grow(n) {
        let mInput = (0, util_1.getById)(this.view, this.values.input.wml.id);
        if (mInput.isNothing())
            return;
        let i = mInput.get();
        let mDom = (0, util_1.getById)(i.view, i.values.wml.id);
        if (mDom.isNothing())
            return;
        let dom = mDom.get();
        dom.style.width = `${n * this.values.input.fontIncrement}px`;
    }
    /**
     * @private
     */
    redraw() {
        this.view.invalidate();
        this.focus();
        return this;
    }
    setMessage(msg) {
        (0, form_1.setMessage)(this.view, this.values.messages.wml.id, msg);
        return this;
    }
    removeMessage() {
        (0, form_1.removeMessage)(this.view, this.values.messages.wml.id);
        return this;
    }
    update(results) {
        (0, search_1.updateMenu)(this.view, this.values.menu.wml.id, results);
        return this;
    }
    open() {
        (0, search_1.openMenu)(this.view, this.values.menu.wml.id);
        return this;
    }
    close() {
        (0, search_1.closeMenu)(this.view, this.values.menu.wml.id);
        return this;
    }
    focus() {
        getInput(this).map(i => i.focus());
        getRoot(this).map(e => e.classList.add(active_1.ACTIVE));
        return this;
    }
    /**
     * push a value onto the end of the internal stack.
     */
    push(value) {
        this.values.tags.value.push(value);
        this.fireChange();
        return this;
    }
}
exports.MultiSelect = MultiSelect;
const getInput = (m) => (0, util_1.getById)(m.view, m.values.input.wml.id);
const getRoot = (m) => (0, util_1.getById)(m.view, m.values.root.wml.id);

},{"../":54,"../../":108,"../../content/orientation":13,"../../content/state/active":17,"../../content/state/disabled":18,"../../util":147,"../feedback":45,"../form":51,"../search":69,"./wml/multi-select":60}],60:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const label_1 = require("../../label");
;
const help_1 = require("../../help");
;
const tag_1 = require("../../tag");
;
const search_1 = require("../../search");
;
const results_menu_1 = require("../../results-menu");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { 'id': __context.values.root.id, 'class': __context.values.root.className }, [
                __this.widget(new label_1.Label({ 'for': __context.values.root.id, 'text': __context.values.label.text }, []), { 'for': __context.values.root.id, 'text': __context.values.label.text }),
                __this.node('div', { 'onclick': __context.values.content.onfocus, 'class': __context.values.content.className }, [
                    ...((__context.values.tags.has()) ?
                        (() => ([
                            ...__forIn(__context.values.tags.value, (value, idx, _$$all) => ([
                                __this.widget(new tag_1.Tag({ 'name': String(idx), 'text': __context.values.tags.getText(value), 'disabled': __context.values.tags.disabled, 'className': __context.values.tags.className, 'onDismiss': __context.values.tags.onDismiss }, []), { 'name': String(idx), 'text': __context.values.tags.getText(value), 'disabled': __context.values.tags.disabled, 'className': __context.values.tags.className, 'onDismiss': __context.values.tags.onDismiss })
                            ]), () => ([]))
                        ]))() :
                        (() => ([
                            text('')
                        ]))()),
                    __this.widget(new search_1.Input({ wml: { 'id': __context.values.input.wml.id }, 'className': __context.values.input.className, 'name': __context.values.input.name, 'disabled': __context.values.input.disabled, 'onSearch': __context.values.input.onSearch }, []), { wml: { 'id': __context.values.input.wml.id }, 'className': __context.values.input.className, 'name': __context.values.input.name, 'disabled': __context.values.input.disabled, 'onSearch': __context.values.input.onSearch })
                ]),
                __this.widget(new results_menu_1.ResultsMenu({ wml: { 'id': __context.values.menu.wml.id }, 'block': __context.values.menu.block, 'hidden': true, 'onSelect': __context.values.menu.onSelect, 'noItemsTemplate': __context.values.menu.noItemsTemplate, 'itemTemplate': __context.values.menu.itemTemplate, 'stringifier': __context.values.menu.stringifier }, []), { wml: { 'id': __context.values.menu.wml.id }, 'block': __context.values.menu.block, 'hidden': true, 'onSelect': __context.values.menu.onSelect, 'noItemsTemplate': __context.values.menu.noItemsTemplate, 'itemTemplate': __context.values.menu.itemTemplate, 'stringifier': __context.values.menu.stringifier }),
                __this.widget(new help_1.Help({ wml: { 'id': __context.values.messages.wml.id }, 'text': __context.values.messages.text }, []), { wml: { 'id': __context.values.messages.wml.id }, 'text': __context.values.messages.text })
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../help":52,"../../label":57,"../../results-menu":67,"../../search":69,"../../tag":81,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],61:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Pager = exports.PageSelectedEvent = exports.PAGER_NEXT = exports.PAGER_PREVIOUS = exports.PAGER = void 0;
const wml_1 = require("@quenk/wml");
const util_1 = require("../../util");
const __1 = require("../../");
const __2 = require("../");
const views_1 = require("./views");
///classNames:begin
exports.PAGER = 'ww-pager';
exports.PAGER_PREVIOUS = 'ww-pager__first';
exports.PAGER_NEXT = 'ww-pager__next';
///classNames:end
const PREVIOUS_TEXT = '← Previous';
const NEXT_TEXT = 'Next →';
/**
 * PageSelectedEvent indicates the user has clicked on a control to display
 * a different page in a result set.
 *
 * The value of this event is the page number that was selected.
 */
class PageSelectedEvent extends __2.Event {
}
exports.PageSelectedEvent = PageSelectedEvent;
/**
 * Pager provides a control for step backwards or forwards through paginated
 * data.
 */
class Pager extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new views_1.PagerView(this);
        this.values = {
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.PAGER, this.attrs.className),
            current: this.attrs.current || 1,
            total: this.attrs.total || 0,
            previous: {
                className: exports.PAGER_PREVIOUS,
                isDisabled: () => (this.values.current <= 1) ||
                    (this.values.total === 0),
                text: this.attrs.previousText || PREVIOUS_TEXT,
                onClick: () => {
                    this.values.current = this.values.current - 1;
                    this.fire();
                }
            },
            next: {
                className: exports.PAGER_NEXT,
                text: this.attrs.nextText || NEXT_TEXT,
                isDisabled: () => this.values.current >= this.values.total,
                onClick: () => {
                    this.values.current = this.values.current + 1;
                    this.fire();
                }
            },
        };
    }
    /**
     * @private
     */
    fire() {
        this.view.invalidate();
        if (this.attrs.onChange)
            this.attrs.onChange(new PageSelectedEvent(this.attrs.name || '', this.values.current));
    }
}
exports.Pager = Pager;

},{"../":54,"../../":108,"../../util":147,"./views":62,"@quenk/wml":157}],62:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PagerView = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const link_1 = require("../../content/link");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class PagerView {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('nav', { 'id': __context.values.id, 'class': __context.values.className }, [
                __this.node('ul', {}, [
                    __this.node('li', { 'class': __context.values.previous.className }, [
                        __this.widget(new link_1.Link({ 'className': '-ww-no-decoration', 'text': __context.values.previous.text, 'disabled': __context.values.previous.isDisabled(), 'onClick': __context.values.previous.onClick }, []), { 'className': '-ww-no-decoration', 'text': __context.values.previous.text, 'disabled': __context.values.previous.isDisabled(), 'onClick': __context.values.previous.onClick })
                    ]),
                    ...(__context.children),
                    __this.node('li', { 'class': __context.values.next.className }, [
                        __this.widget(new link_1.Link({ 'className': '-ww-no-decoration', 'text': __context.values.next.text, 'disabled': __context.values.next.isDisabled(), 'onClick': __context.values.next.onClick }, []), { 'className': '-ww-no-decoration', 'text': __context.values.next.text, 'disabled': __context.values.next.isDisabled(), 'onClick': __context.values.next.onClick })
                    ])
                ])
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.PagerView = PagerView;

},{"../../content/link":7,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],63:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Paginator = exports.PositionViewContext = exports.PageChangedEvent = exports.PAGINATOR_LAST = exports.PAGINATOR_NEXT = exports.PAGINATOR_POSITION = exports.PAGINATOR_PREVIOUS = exports.PAGINATOR_FIRST = exports.PAGINATOR = void 0;
const wml_1 = require("@quenk/wml");
const timer_1 = require("@quenk/noni/lib/control/timer");
const disabled_1 = require("../../content/state/disabled");
const util_1 = require("../../util");
const __1 = require("../../");
const __2 = require("../");
const paginator_1 = require("./wml/paginator");
///classNames:begin
exports.PAGINATOR = 'ww-paginator';
exports.PAGINATOR_FIRST = 'ww-paginator__first';
exports.PAGINATOR_PREVIOUS = 'ww-paginator__previous';
exports.PAGINATOR_POSITION = 'ww-paginator__position';
exports.PAGINATOR_NEXT = 'ww-paginator__next';
exports.PAGINATOR_LAST = 'ww-paginator__last';
/**
 * PageChangedEvent indicating the current page has been changed.
 */
class PageChangedEvent extends __2.Event {
}
exports.PageChangedEvent = PageChangedEvent;
/**
 * PositionViewContext contains the info needed to render the positon part of
 * the paginator.
 */
class PositionViewContext {
    constructor(className, current, total, onChange) {
        this.className = className;
        this.current = current;
        this.total = total;
        this.onChange = onChange;
    }
}
exports.PositionViewContext = PositionViewContext;
/**
 * Paginator provides a control for navigating paged data, results, view etc.
 */
class Paginator extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new paginator_1.PaginatorView(this);
        this.values = {
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.PAGINATOR, (0, __1.getClassName)(this.attrs)),
            current: {
                value: (this.attrs && this.attrs.current) ?
                    this.attrs.current : 1,
            },
            total: (this.attrs && this.attrs.total) ?
                this.attrs.total : 1,
            first: {
                className: exports.PAGINATOR_FIRST,
                isDisabled: () => (this.values.current.value <= 1),
                onclick: (e) => {
                    e.preventDefault();
                    this.values.current.value = 1;
                    this.fire();
                }
            },
            previous: {
                className: exports.PAGINATOR_PREVIOUS,
                isDisabled: () => (this.values.current.value <= 1),
                onclick: (e) => {
                    e.preventDefault();
                    this.values.current.value = this.values.current.value - 1;
                    this.fire();
                }
            },
            position: {
                className: exports.PAGINATOR_POSITION,
                view: () => {
                    let ctx = new PositionViewContext(this.values.position.className, this.values.current.value, this.values.total, (0, timer_1.debounce)((e) => {
                        let n = Number(e.value);
                        if ((n > 0) && (n <= this.values.total)) {
                            this.values.current.value = n;
                            this.fire();
                        }
                    }, 5000));
                    return ((this.attrs && this.attrs.positionView) ?
                        this.attrs.positionView(ctx) :
                        new paginator_1.PositionView(ctx)).render();
                }
            },
            next: {
                className: exports.PAGINATOR_NEXT,
                isDisabled: () => (this.values.current.value >= this.values.total),
                onclick: (e) => {
                    e.preventDefault();
                    this.values.current.value = this.values.current.value + 1;
                    this.fire();
                }
            },
            last: {
                className: exports.PAGINATOR_LAST,
                isDisabled: () => (this.values.current.value >= this.values.total),
                onclick: (e) => {
                    e.preventDefault();
                    this.values.current.value = this.values.total;
                    this.fire();
                }
            },
            disabled: {
                className: disabled_1.DISABLED
            }
        };
    }
    /**
     * @private
     */
    fire() {
        if (this.attrs && this.attrs.onChange)
            this.attrs.onChange(new PageChangedEvent(this.attrs.name || '', this.values.current.value));
        this.view.invalidate();
    }
}
exports.Paginator = Paginator;

},{"../":54,"../../":108,"../../content/state/disabled":18,"../../util":147,"./wml/paginator":64,"@quenk/noni/lib/control/timer":148,"@quenk/wml":157}],64:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PaginatorView = exports.PositionView = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const text_input_1 = require("../../text-input");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class PositionView {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('li', { 'class': __context.className }, [
                __this.node('span', {}, [
                    __document.createTextNode('Page '),
                    __this.widget(new text_input_1.TextInput({ 'type': 'number', 'match': '[0-9]', 'value': String(__context.current), 'onChange': __context.onChange }, []), { 'type': 'number', 'match': '[0-9]', 'value': String(__context.current), 'onChange': __context.onChange }),
                    __document.createTextNode(' of '),
                    text(__context.total)
                ])
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.PositionView = PositionView;
;
class PaginatorView {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('ul', { 'id': __context.values.id, 'class': __context.values.className }, [
                __this.node('li', { 'class': __context.values.first.className }, [
                    ...((__context.values.first.isDisabled()) ?
                        (() => ([
                            __this.node('span', { 'class': __context.values.disabled.className }, [])
                        ]))() :
                        (() => ([
                            __this.node('a', { 'href': '#', 'onclick': __context.values.first.onclick }, [])
                        ]))())
                ]),
                __this.node('li', { 'class': __context.values.previous.className }, [
                    ...((__context.values.previous.isDisabled()) ?
                        (() => ([
                            __this.node('span', { 'class': __context.values.disabled.className }, [])
                        ]))() :
                        (() => ([
                            __this.node('a', { 'href': '#', 'onclick': __context.values.previous.onclick }, [])
                        ]))())
                ]),
                __context.values.position.view(),
                __this.node('li', { 'class': __context.values.next.className }, [
                    ...((__context.values.next.isDisabled()) ?
                        (() => ([
                            __this.node('span', { 'class': __context.values.disabled.className }, [])
                        ]))() :
                        (() => ([
                            __this.node('a', { 'href': '#', 'onclick': __context.values.next.onclick }, [])
                        ]))())
                ]),
                __this.node('li', { 'class': __context.values.last.className }, [
                    ...((__context.values.last.isDisabled()) ?
                        (() => ([
                            __this.node('span', { 'class': __context.values.disabled.className }, [])
                        ]))() :
                        (() => ([
                            __this.node('a', { 'href': '#', 'onclick': __context.values.last.onclick }, [])
                        ]))())
                ])
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.PaginatorView = PaginatorView;

},{"../../text-input":85,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],65:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RangedPager = exports.RANGED_PAGER_PAGE = exports.RANGED_PAGER = void 0;
const wml_1 = require("@quenk/wml");
const array_1 = require("@quenk/noni/lib/data/array");
const active_1 = require("../../content/state/active");
const util_1 = require("../../util");
const __1 = require("../../");
const pager_1 = require("../pager");
const views_1 = require("./views");
///classNames:begin
exports.RANGED_PAGER = 'ww-ranged-pager';
exports.RANGED_PAGER_PAGE = 'ww-ranged-pager__page';
/**
 * RangedPager provides a variant of the [[Pager]] control that provides
 * additional buttons for selecting specific pages.
 */
class RangedPager extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new views_1.RangedPagerView(this);
        this.values = {
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.RANGED_PAGER, this.attrs.className),
            current: this.attrs.current || 1,
            total: this.attrs.total || 1,
            pages: paginate(this.attrs.max || this.attrs.total || 1, this.attrs.total || 1, this.attrs.current || 1),
            onChange: (e) => {
                this.values.current = e.value;
                this.fire();
            },
            page: {
                getClassName: (i) => (0, util_1.concat)(exports.RANGED_PAGER_PAGE, (i === this.values.current) ? active_1.ACTIVE : ''),
                onClick: (i) => {
                    this.values.current = i;
                    this.fire();
                }
            },
        };
    }
    /**
     * @private
     */
    fire() {
        // XXX: There is a bug in wml that prevents invalidating a view whose
        // root is another wml widget. This view will not have a parent element 
        // so we must invalidate the Pager view.
        (0, util_1.getById)(this.view, "pager").map(w => w.view.invalidate());
        if (this.attrs.onChange)
            this.attrs.onChange(new pager_1.PageSelectedEvent(this.attrs.name || '', this.values.current));
    }
}
exports.RangedPager = RangedPager;
const paginate = (max, total, current) => {
    let allPages = (0, array_1.make)(total, i => i + 1);
    if (allPages.length <= max)
        return allPages;
    // The total distance from the current to end in both direction accouting
    // for the fact that the start, current and end pages must be present. This
    // is the real number of spaces we have for pages.
    let totalAllowed = max - 3;
    let distanceOneWay = Math.floor(totalAllowed / 2);
    //Calculate the distance from current -> start we will allow. When the 
    //number of spaces available is not even, we give the extra page to start.
    let startDistance = distanceOneWay + (totalAllowed % 2);
    let distanceFromStart = current - 1;
    // The remaining number of pages once all the pages from current back to
    // start have been filled. This can be negative indicating start-current
    // will not fit in distanceOneWay.
    let startRemainder = startDistance - distanceFromStart;
    //Calculate the distance from current -> end we will allow. Anything leftover
    //from  startDistance is added here.
    let endDistance = (startRemainder > 0) ?
        distanceOneWay + startRemainder :
        distanceOneWay;
    let distanceFromEnd = total - current;
    let endRemainder = endDistance - distanceFromEnd;
    // If we have a remainder here, we can give it back to current -> start.
    if (endRemainder > 0)
        startDistance = startDistance + endRemainder;
    return allPages.map(page => {
        if (((page < current) && (page != 1)) &&
            ((current - page) >= startDistance))
            return 0;
        if (((page > current) && (page != total)) &&
            ((page - current) >= endDistance))
            return 0;
        return page;
    }).filter((page, idx, list) => ((list[idx - 1] === 0) && (page === 0)) ? false : true);
};

},{"../../":108,"../../content/state/active":17,"../../util":147,"../pager":61,"./views":66,"@quenk/noni/lib/data/array":149,"@quenk/wml":157}],66:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RangedPagerView = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const link_1 = require("../../content/link");
;
const pager_1 = require("../pager");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class RangedPagerView {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new pager_1.Pager({ wml: { 'id': 'pager' }, 'id': __context.values.id, 'className': __context.values.className, 'current': __context.values.current, 'total': __context.values.total, 'onChange': __context.values.onChange }, [
                ...__forIn(__context.values.pages, (idx, _$$i, _$$all) => ([
                    __this.node('li', { 'class': __context.values.page.getClassName(idx) }, [
                        ...(((idx === 0)) ?
                            (() => ([
                                __this.widget(new link_1.Link({ 'className': '-ww-no-decoration', 'disabled': true, 'text': '…' }, []), { 'className': '-ww-no-decoration', 'disabled': true, 'text': '…' })
                            ]))() :
                            (() => ([
                                __this.widget(new link_1.Link({ 'className': '-ww-no-decoration', 'text': String(idx), 'onClick': () => __context.values.page.onClick(idx) }, []), { 'className': '-ww-no-decoration', 'text': String(idx), 'onClick': () => __context.values.page.onClick(idx) })
                            ]))())
                    ])
                ]), () => ([]))
            ]), { wml: { 'id': 'pager' }, 'id': __context.values.id, 'className': __context.values.className, 'current': __context.values.current, 'total': __context.values.total, 'onChange': __context.values.onChange });
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.RangedPagerView = RangedPagerView;

},{"../../content/link":7,"../pager":61,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],67:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResultsMenu = exports.ItemSelectedEvent = exports.RESULTS_MENU = void 0;
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const wml_1 = require("@quenk/wml");
const __1 = require("../../");
const util_1 = require("../../util");
const __2 = require("../");
const results_menu_1 = require("./wml/results-menu");
///classNames:begin
exports.RESULTS_MENU = 'ww-results-menu';
/**
 * ItemSelectedEvent
 */
class ItemSelectedEvent extends __2.Event {
}
exports.ItemSelectedEvent = ItemSelectedEvent;
/**
 * ResultsMenu used to display results in select styled controls.
 */
class ResultsMenu extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new results_menu_1.Main(this);
        this.values = {
            wml: {
                id: 'menu'
            },
            tree: (0, maybe_1.nothing)(),
            results: (this.attrs && this.attrs.results) ?
                this.attrs.results : [],
            name: (this.attrs && this.attrs.name) ?
                this.attrs.name : '',
            className: (0, util_1.concat)(exports.RESULTS_MENU, (0, __1.getClassName)(this.attrs)),
            block: (this.attrs && this.attrs.block) ?
                this.attrs.block : false,
            hidden: (this.attrs && this.attrs.hidden) ?
                this.attrs.hidden : false,
            item: {
                stringifier: (this.attrs && this.attrs.stringifier) ?
                    this.attrs.stringifier : (v) => Object.toString.call(v),
                click: (index) => {
                    if (this.attrs && this.attrs.onSelect)
                        this.attrs.onSelect(new ItemSelectedEvent(this.attrs && this.attrs.name || '', this.values.results[index]));
                },
                template: (result, index) => (this.attrs && this.attrs.itemTemplate) ?
                    this.attrs.itemTemplate(result, index, this) :
                    new results_menu_1.ItemTemplateView({
                        option: this.values.item.stringifier(result)
                    }),
                noItemsTemplate: () => (this.attrs && this.attrs.noItemsTemplate) ?
                    this.attrs.noItemsTemplate : new results_menu_1.NoItemsTemplateView({}),
            }
        };
    }
    open() {
        (0, util_1.getById)(this.view, this.values.wml.id)
            .map((m) => m.show());
        this.values.hidden = false;
        if (this.attrs && this.attrs.onOpen)
            this.attrs.onOpen();
        return this;
    }
    close() {
        (0, util_1.getById)(this.view, this.values.wml.id)
            .map((m) => m.hide());
        this.values.hidden = true;
        if (this.attrs && this.attrs.onClose)
            this.attrs.onClose();
        return this;
    }
    toggle() {
        (0, util_1.getById)(this.view, this.values.wml.id)
            .map((m) => m.toggle());
        this.values.hidden = !this.values.hidden;
        if (this.values.hidden === true &&
            this.attrs &&
            this.attrs.onClose)
            this.attrs.onClose();
        else if (this.values.hidden === false &&
            this.attrs &&
            this.attrs.onOpen)
            this.attrs.onOpen();
        return this;
    }
    handleEvent(e) {
        if (this.values.tree.isJust()) {
            let root = this.values.tree.get();
            if (!document.body.contains(root))
                document.removeEventListener('click', this);
            if ((!root.contains(e.target)))
                this.close();
        }
    }
    /**
     * update will cause the menu to be displayed.
     */
    update(results) {
        this.values.results = results;
        this.values.hidden = false;
        this.view.invalidate();
        return this;
    }
    render() {
        this.values.tree = (0, maybe_1.just)(this.view.render());
        window.removeEventListener('click', this);
        window.addEventListener('click', this);
        return this.values.tree.get();
    }
}
exports.ResultsMenu = ResultsMenu;

},{"../":54,"../../":108,"../../util":147,"./wml/results-menu":68,"@quenk/noni/lib/data/maybe":151,"@quenk/wml":157}],68:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = exports.NoItemsTemplateView = exports.ItemTemplateView = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const link_1 = require("../../../content/link");
;
const menu_1 = require("../../../menu/menu");
;
const item_1 = require("../../../menu/item");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
;
class ItemTemplateView {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('span', {}, [
                text(__context.option)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.ItemTemplateView = ItemTemplateView;
;
class NoItemsTemplateView {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('b', {}, [
                __document.createTextNode('No results to display.')
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.NoItemsTemplateView = NoItemsTemplateView;
;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new menu_1.Menu({ wml: { 'id': __context.values.wml.id }, 'className': __context.values.className, 'block': __context.values.block, 'hidden': __context.values.hidden }, [
                ...__forIn(__context.values.results, (result, index, _$$all) => ([
                    __this.widget(new item_1.Item({ 'name': ('' + index) }, [
                        __this.widget(new link_1.Link({ 'onClick': () => __context.values.item.click(index) }, [
                            __this.registerView(__context.values.item.template(result, index)).render()
                        ]), { 'onClick': () => __context.values.item.click(index) })
                    ]), { 'name': ('' + index) })
                ]), () => ([
                    __this.registerView(__context.values.item.noItemsTemplate()).render()
                ]))
            ]), { wml: { 'id': __context.values.wml.id }, 'className': __context.values.className, 'block': __context.values.block, 'hidden': __context.values.hidden });
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../content/link":7,"../../../menu/item":140,"../../../menu/menu":142,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],69:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toggleMenu = exports.closeMenu = exports.openMenu = exports.updateMenu = exports.Search = exports.Input = exports.EscapeEvent = exports.FocusLostEvent = exports.FocusGainedEvent = exports.TermChangedEvent = exports.SEARCH_INPUT = exports.SEARCH = exports.ESCAPE = exports.ItemSelectedEvent = void 0;
const views = require("./wml/search");
const timer_1 = require("@quenk/noni/lib/control/timer");
const orientation_1 = require("../../content/orientation");
const util_1 = require("../../util");
const results_menu_1 = require("../results-menu");
Object.defineProperty(exports, "ItemSelectedEvent", { enumerable: true, get: function () { return results_menu_1.ItemSelectedEvent; } });
const __1 = require("../../");
const __2 = require("../");
/**
 * ESCAPE key code.
 */
exports.ESCAPE = 27;
///classNames:begin
exports.SEARCH = 'ww-search';
exports.SEARCH_INPUT = 'ww-search__input';
/**
 * TermChangedEvent signals the search term has changed.
 */
class TermChangedEvent extends __2.Event {
}
exports.TermChangedEvent = TermChangedEvent;
/**
 * FocusGainedEvent signals the user as given focus to the control.
 */
class FocusGainedEvent {
    constructor(name) {
        this.name = name;
    }
}
exports.FocusGainedEvent = FocusGainedEvent;
/**
 * FocusLostEvent signals the user has removed focus from the control.
 */
class FocusLostEvent {
    constructor(name) {
        this.name = name;
    }
}
exports.FocusLostEvent = FocusLostEvent;
/**
 * EscapeEvent signals the user has pressed the escape key while typing.
 */
class EscapeEvent {
    constructor(name) {
        this.name = name;
    }
}
exports.EscapeEvent = EscapeEvent;
/**
 * Input provides the input part of a Search control.
 *
 * This is here mostly for code re-use.
 */
class Input extends __2.AbstractControl {
    constructor() {
        super(...arguments);
        this.view = new views.InputView(this);
        this.values = {
            wml: { id: 'root' },
            className: (0, util_1.concat)(exports.SEARCH_INPUT, (0, __1.getClassName)(this.attrs)),
            placeholder: (this.attrs && this.attrs.placeholder) ?
                this.attrs.placeholder : '',
            readOnly: (this.attrs && this.attrs.readOnly) || undefined,
            disabled: (this.attrs && this.attrs.disabled) || undefined,
            autocomplete: 'do not enable please',
            autofocus: (this.attrs && this.attrs.autofocus) ?
                true : undefined,
            size: String((this.attrs && this.attrs.size) ?
                this.attrs.size : 20),
            value: (this.attrs && this.attrs.value) ?
                this.attrs.value : '',
            onfocus: (e) => {
                let target = e.target;
                if (this.attrs && this.attrs.onFocus)
                    this.attrs.onFocus(new FocusGainedEvent(this.attrs && this.attrs.name || ''));
                target.value = target.value;
            },
            onkeyup: (e) => {
                if (e.keyCode === exports.ESCAPE) {
                    if (this.attrs && this.attrs.onEscape)
                        this.attrs.onEscape(new EscapeEvent(this.attrs.name || ''));
                }
                else {
                    this.fireSearch(e);
                }
            },
            oninput: (e) => {
                //For compatability reasons
                e.target.oninput = null;
                this.values.onkeyup(e);
            },
            onblur: () => {
                if (this.attrs && this.attrs.onBlur)
                    this.attrs.onBlur(new FocusLostEvent(this.attrs && this.attrs.name || ''));
            }
        };
    }
    fireSearch(e) {
        if (this.attrs && this.attrs.onSearch) {
            let name = '' + this.attrs.name;
            let value = e.target.value;
            this.attrs.onSearch(new TermChangedEvent(name, value));
        }
    }
    rendered() {
        if (this.values.autofocus === true)
            this.focus();
    }
    /**
     * focus steals user focus to the Input.
     */
    focus() {
        (0, timer_1.tick)(() => getInput(this).map(i => i.focus()));
        return this;
    }
    /**
     * setSize sets the size of the input.
     */
    setSize(n) {
        this.values.size = String(n);
        getInput(this).map(i => i.setAttribute('size', String(n)));
        return this;
    }
    /**
     * getSize returns the size of the (internally tracked) size
     * of the Input.
     */
    getSize() {
        return Number(this.values.size);
    }
}
exports.Input = Input;
/**
 * Search provides an input that can be used in the ui for a search engine.
 */
class Search extends __2.AbstractControl {
    constructor() {
        super(...arguments);
        this.view = new views.Main(this);
        this.values = {
            root: {
                wml: {
                    id: 'root'
                },
                id: (0, __1.getId)(this.attrs),
                className: (0, util_1.concat)(exports.SEARCH, (0, __1.getClassName)(this.attrs), (0, orientation_1.getBlockClassName)(this.attrs))
            },
            input: {
                wml: {
                    id: 'input'
                },
                name: (0, __2.getName)(this.attrs),
                placeholder: (this.attrs && this.attrs.placeholder) ?
                    this.attrs.placeholder : '',
                autofocus: (this.attrs && this.attrs.autofocus) ?
                    true : undefined,
                readOnly: (this.attrs && this.attrs.readOnly) || undefined,
                disabled: (this.attrs && this.attrs.disabled) || undefined,
                value: (this.attrs && this.attrs.term) ?
                    this.attrs.term :
                    (this.attrs &&
                        this.attrs.stringifier &&
                        this.attrs.value) ?
                        this.attrs.stringifier(this.attrs.value) : '',
                onFocus: this.attrs && this.attrs.onFocus || undefined,
                onSearch: (this.attrs && this.attrs.onSearch) ?
                    this.attrs.onSearch : undefined,
                onEscape: () => this.close(),
                onBlur: (this.attrs && this.attrs.onBlur) ?
                    this.attrs.onBlur : undefined
            },
            menu: {
                wml: {
                    id: 'menu'
                },
                name: (this.attrs && this.attrs.name) ?
                    this.attrs.name : '',
                block: (this.attrs && this.attrs.block) ?
                    this.attrs.block : false,
                onSelect: (e) => {
                    this.close();
                    if (this.attrs && this.attrs.onSelect)
                        this.attrs.onSelect(e);
                },
                itemTemplate: (this.attrs && this.attrs.itemTemplate) ?
                    this.attrs.itemTemplate : undefined,
                noItemsTemplate: (this.attrs && this.attrs.noItemsTemplate) ?
                    this.attrs.noItemsTemplate : undefined,
                stringifier: (this.attrs && this.attrs.stringifier) ?
                    this.attrs.stringifier : undefined
            }
        };
    }
    set(value) {
        (0, util_1.getById)(this.view, this.values.root.wml.id)
            .map((e) => { e.value = value; });
        return this;
    }
    /**
     * focus gives focus to the input.
     */
    focus() {
        (0, util_1.getById)(this.view, this.values.input.wml.id)
            .map(i => i.focus());
        return this;
    }
    /**
     * update the Select with new item options to
     * present to the user.
     */
    update(results) {
        (0, exports.updateMenu)(this.view, this.values.menu.wml.id, results);
        return this;
    }
    /**
     * open the results menu.
     */
    open() {
        (0, exports.openMenu)(this.view, this.values.menu.wml.id);
        return this;
    }
    /**
     * close the results menu.
     */
    close() {
        (0, exports.closeMenu)(this.view, this.values.menu.wml.id);
        return this;
    }
}
exports.Search = Search;
const getInput = (i) => (0, util_1.getById)(i.view, i.values.wml.id);
/**
 * updateMenu will cause the menu to be displayed with new items.
 */
const updateMenu = (view, id, results) => {
    let mMenu = (0, util_1.getById)(view, id);
    if (mMenu.isJust())
        mMenu.get().update(results);
};
exports.updateMenu = updateMenu;
/**
 * openMenu will cause the menu to be displayed with whatever contents
 * were previously set.
 */
const openMenu = (view, id) => {
    (0, util_1.getById)(view, id)
        .map((m) => m.open());
};
exports.openMenu = openMenu;
/**
 * closeMenu will cause the menu to no longer be displayed.
 */
const closeMenu = (view, id) => {
    (0, util_1.getById)(view, id)
        .map((m) => m.close());
};
exports.closeMenu = closeMenu;
/**
 * toggleMenu
 */
const toggleMenu = (view, id) => {
    (0, util_1.getById)(view, id)
        .map((m) => m.toggle());
};
exports.toggleMenu = toggleMenu;

},{"../":54,"../../":108,"../../content/orientation":13,"../../util":147,"../results-menu":67,"./wml/search":70,"@quenk/noni/lib/control/timer":148}],70:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = exports.InputView = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const results_menu_1 = require("../../results-menu");
;
const __1 = require("../");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class InputView {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('input', { wml: { 'id': __context.values.wml.id }, 'class': __context.values.className, 'onkeyup': __context.values.onkeyup, 'oninput': __context.values.oninput, 'onfocus': __context.values.onfocus, 'onblur': __context.values.onblur, 'autofocus': __context.values.autofocus, 'autocomplete': __context.values.autocomplete, 'size': __context.values.size, 'placeholder': __context.values.placeholder, 'readOnly': __context.values.readOnly, 'disabled': __context.values.disabled, 'value': __context.values.value }, []);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.InputView = InputView;
;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { wml: { 'id': __context.values.root.wml.id }, 'id': __context.values.root.id, 'class': __context.values.root.className }, [
                __this.widget(new __1.Input({ wml: { 'id': __context.values.input.wml.id }, 'name': __context.values.input.name, 'autofocus': __context.values.input.autofocus, 'onFocus': __context.values.input.onFocus, 'onSearch': __context.values.input.onSearch, 'onEscape': __context.values.input.onEscape, 'onBlur': __context.values.input.onBlur, 'placeholder': __context.values.input.placeholder, 'readOnly': __context.values.input.readOnly, 'disabled': __context.values.input.disabled, 'value': __context.values.input.value }, []), { wml: { 'id': __context.values.input.wml.id }, 'name': __context.values.input.name, 'autofocus': __context.values.input.autofocus, 'onFocus': __context.values.input.onFocus, 'onSearch': __context.values.input.onSearch, 'onEscape': __context.values.input.onEscape, 'onBlur': __context.values.input.onBlur, 'placeholder': __context.values.input.placeholder, 'readOnly': __context.values.input.readOnly, 'disabled': __context.values.input.disabled, 'value': __context.values.input.value }),
                __this.widget(new results_menu_1.ResultsMenu({ wml: { 'id': __context.values.menu.wml.id }, 'hidden': true, 'block': __context.values.menu.block, 'onSelect': __context.values.menu.onSelect, 'noItemsTemplate': __context.values.menu.noItemsTemplate, 'itemTemplate': __context.values.menu.itemTemplate, 'stringifier': __context.values.menu.stringifier }, []), { wml: { 'id': __context.values.menu.wml.id }, 'hidden': true, 'block': __context.values.menu.block, 'onSelect': __context.values.menu.onSelect, 'noItemsTemplate': __context.values.menu.noItemsTemplate, 'itemTemplate': __context.values.menu.itemTemplate, 'stringifier': __context.values.menu.stringifier })
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../":69,"../../results-menu":67,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],71:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.update = exports.close = exports.open = exports.Select = exports.SearchSection = exports.InputSection = exports.LabelSection = exports.MessagesSection = exports.ControlSection = exports.RootSection = exports.ItemUnsetEvent = exports.ItemChangedEvent = exports.SELECT = exports.ItemSelectedEvent = exports.TermChangedEvent = void 0;
const views = require("./wml/select");
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const orientation_1 = require("../../content/orientation");
const util_1 = require("../../util");
const feedback_1 = require("../feedback");
const form_1 = require("../form");
const __1 = require("../../");
const __2 = require("../");
const search_1 = require("../search");
Object.defineProperty(exports, "TermChangedEvent", { enumerable: true, get: function () { return search_1.TermChangedEvent; } });
Object.defineProperty(exports, "ItemSelectedEvent", { enumerable: true, get: function () { return search_1.ItemSelectedEvent; } });
///classNames:begin
exports.SELECT = 'ww-select';
/**
 * ItemChangedEvent
 */
class ItemChangedEvent extends __2.Event {
}
exports.ItemChangedEvent = ItemChangedEvent;
/**
 * ItemUnsetEvent
 */
class ItemUnsetEvent extends __2.Event {
    constructor(name) {
        super(name, undefined);
        this.name = name;
    }
}
exports.ItemUnsetEvent = ItemUnsetEvent;
/**
 * RootSection
 */
class RootSection {
    constructor(attrs) {
        this.attrs = attrs;
        this.wml = { id: 'root' };
        this.id = (0, __1.getId)(this.attrs);
        this.className = (0, util_1.concat)(exports.SELECT, (0, __1.getClassName)(this.attrs), (0, feedback_1.getValidityClassName)(this.attrs), (0, orientation_1.getBlockClassName)(this.attrs));
    }
}
exports.RootSection = RootSection;
/**
 * ControlSection
 */
class ControlSection {
    constructor() {
        this.wml = { id: 'root' };
    }
}
exports.ControlSection = ControlSection;
/**
 * MessagesSection
 */
class MessagesSection {
    constructor(attrs) {
        this.attrs = attrs;
        this.wml = { id: 'message' };
        this.text = (0, feedback_1.getMessage)(this.attrs);
    }
}
exports.MessagesSection = MessagesSection;
/**
 * LabelSection
 */
class LabelSection {
    constructor(attrs) {
        this.attrs = attrs;
        this.id = (0, __2.getName)(this.attrs);
        this.text = (0, form_1.getLabel)(this.attrs);
    }
}
exports.LabelSection = LabelSection;
/**
 * InputSection
 */
class InputSection {
    constructor(attrs) {
        this.attrs = attrs;
        this.wml = { id: 'input' };
    }
}
exports.InputSection = InputSection;
/**
 * SearchSection
 */
class SearchSection {
    constructor(attrs, close, onSelect) {
        this.attrs = attrs;
        this.close = close;
        this.onSelect = onSelect;
        this.wml = { id: 'search' };
        this.name = (0, __2.getName)(this.attrs);
        this.className = (this.attrs && this.attrs.inputClassName) ?
            this.attrs.inputClassName : '';
        this.placeholder = (this.attrs && this.attrs.placeholder) ?
            this.attrs.placeholder : '';
        this.block = (this.attrs && this.attrs.block) ?
            this.attrs.block : false;
        this.value = (this.attrs && this.attrs.value) ?
            this.attrs.value : undefined;
        this.readOnly = (this.attrs && this.attrs.readOnly);
        this.disabled = (this.attrs && this.attrs.disabled);
        this.itemTemplate = (this.attrs && this.attrs.itemTemplate) ?
            this.attrs.itemTemplate : undefined;
        this.noItemsTemplate = (this.attrs && this.attrs.noItemsTemplate) ?
            this.attrs.noItemsTemplate : undefined;
        this.stringifier = (this.attrs && this.attrs.stringifier) ?
            this.attrs.stringifier : undefined;
        this.onSearch = (this.attrs && this.attrs.onSearch) ?
            this.attrs.onSearch : () => { };
    }
}
exports.SearchSection = SearchSection;
/**
 * Select provides an control for selecting an item from a
 * list.
 */
class Select extends form_1.AbstractFormControl {
    constructor() {
        super(...arguments);
        this.view = new views.Main(this);
        this.values = {
            root: new RootSection(this.attrs),
            control: new ControlSection(),
            messages: new MessagesSection(this.attrs),
            label: new LabelSection(this.attrs),
            input: new InputSection(this.attrs),
            search: new SearchSection(this.attrs, () => this.close(), (e) => {
                this.close();
                this.values.tag.value = (0, maybe_1.just)(e.value);
                if (this.attrs && this.attrs.onChange)
                    this.attrs.onChange(new ItemChangedEvent('' + this.attrs.name, e.value));
                this.view.invalidate();
            }),
            tag: {
                className: (0, feedback_1.getValidityClassName)(this.attrs),
                value: ((this.attrs &&
                    (this.attrs.value != undefined)) ?
                    (0, maybe_1.just)(this.attrs.value) : (0, maybe_1.nothing)()),
                disabled: (this.attrs && this.attrs.disabled) ?
                    this.attrs.disabled : false,
                isSet: () => this.values.tag.value.isJust(),
                getText: () => {
                    if (this.attrs && this.attrs.stringifier)
                        return this.attrs.stringifier(this.values.tag.value.get());
                    return '';
                },
                dismiss: () => {
                    this.values.tag.value = (0, maybe_1.nothing)();
                    if (this.attrs && this.attrs.onUnset)
                        this.attrs.onUnset(new ItemUnsetEvent(this.attrs.name + ''));
                    this.view.invalidate();
                }
            }
        };
    }
    open() {
        (0, exports.open)(this.view, this.values.search.wml.id);
        return this;
    }
    close() {
        (0, exports.close)(this.view, this.values.search.wml.id);
        return this;
    }
    setMessage(msg) {
        this.values.messages.text = msg;
        (0, form_1.setMessage)(this.view, this.values.messages.wml.id, msg);
        return this;
    }
    removeMessage() {
        this.values.messages.text = '';
        (0, form_1.removeMessage)(this.view, this.values.messages.wml.id);
        return this;
    }
    /**
     * update the Select with new item options to
     * present to the user.
     */
    update(results) {
        (0, exports.update)(this.view, this.values.search.wml.id, results);
        return this;
    }
}
exports.Select = Select;
/**
 * open helper.
 *
 * Invokes the open method on the Search widget.
 */
const open = (view, id) => {
    (0, util_1.getById)(view, id)
        .map((m) => m.open());
};
exports.open = open;
/**
 * close helper.
 *
 * Invokes the close method on the Search widget.
 */
const close = (view, id) => {
    (0, util_1.getById)(view, id)
        .map((m) => m.close());
};
exports.close = close;
/**
 * update helper.
 *
 * Invokes the update method on the Search widget.
 */
const update = (view, id, results) => {
    let mSearch = (0, util_1.getById)(view, id);
    if (mSearch.isJust())
        mSearch.get().update(results);
};
exports.update = update;

},{"../":54,"../../":108,"../../content/orientation":13,"../../util":147,"../feedback":45,"../form":51,"../search":69,"./wml/select":72,"@quenk/noni/lib/data/maybe":151}],72:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const search_1 = require("../../search");
;
const label_1 = require("../../label");
;
const help_1 = require("../../help");
;
const tag_1 = require("../../tag");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { 'id': __context.values.root.id, 'class': __context.values.root.className }, [
                __this.widget(new label_1.Label({ 'for': __context.values.root.id, 'text': __context.values.label.text }, []), { 'for': __context.values.root.id, 'text': __context.values.label.text }),
                ...((__context.values.tag.isSet()) ?
                    (() => ([
                        __this.widget(new tag_1.Tag({ 'text': __context.values.tag.getText(), 'className': __context.values.tag.className, 'disabled': __context.values.tag.disabled, 'onDismiss': __context.values.tag.dismiss }, []), { 'text': __context.values.tag.getText(), 'className': __context.values.tag.className, 'disabled': __context.values.tag.disabled, 'onDismiss': __context.values.tag.dismiss })
                    ]))() :
                    (() => ([
                        __this.widget(new search_1.Search({ wml: { 'id': __context.values.search.wml.id }, 'name': __context.values.search.name, 'className': __context.values.search.className, 'block': __context.values.search.block, 'placeholder': __context.values.search.placeholder, 'readOnly': __context.values.search.readOnly, 'disabled': __context.values.search.disabled, 'itemTemplate': __context.values.search.itemTemplate, 'noItemsTemplate': __context.values.search.noItemsTemplate, 'stringifier': __context.values.search.stringifier, 'onSearch': __context.values.search.onSearch, 'onSelect': __context.values.search.onSelect }, []), { wml: { 'id': __context.values.search.wml.id }, 'name': __context.values.search.name, 'className': __context.values.search.className, 'block': __context.values.search.block, 'placeholder': __context.values.search.placeholder, 'readOnly': __context.values.search.readOnly, 'disabled': __context.values.search.disabled, 'itemTemplate': __context.values.search.itemTemplate, 'noItemsTemplate': __context.values.search.noItemsTemplate, 'stringifier': __context.values.search.stringifier, 'onSearch': __context.values.search.onSearch, 'onSelect': __context.values.search.onSelect })
                    ]))()),
                __this.widget(new help_1.Help({ wml: { 'id': __context.values.messages.wml.id }, 'text': __context.values.messages.text }, []), { wml: { 'id': __context.values.messages.wml.id }, 'text': __context.values.messages.text })
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../help":52,"../../label":57,"../../search":69,"../../tag":81,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],73:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StackSelect = exports.ItemsChangedEvent = exports.STACK_SELECT = exports.TermChangedEvent = void 0;
const views = require("./wml/stack-select");
const orientation_1 = require("../../content/orientation");
const form_1 = require("../form");
const search_1 = require("../search");
Object.defineProperty(exports, "TermChangedEvent", { enumerable: true, get: function () { return search_1.TermChangedEvent; } });
const select_1 = require("../select");
const util_1 = require("../../util");
const __1 = require("../../");
const __2 = require("../");
const feedback_1 = require("../feedback");
///classNames:begin
exports.STACK_SELECT = 'ww-stack-select';
/**
 * ItemsChangedEvent
 */
class ItemsChangedEvent extends __2.Event {
}
exports.ItemsChangedEvent = ItemsChangedEvent;
/**
 * StackSelect provides a control for allowing a user to select
 * multiple items from a list.
 *
 * It use a stack to display the selected items.
 *
 *     +=========================+
 *     |  <select>               |
 *     +=========================+
 *     +-------------------------+
 *     |   <item>              x |
 *     +-------------------------+
 *     +-------------------------+
 *     |   <item>              x |
 *     +-------------------------+
 *     +-------------------------+
 *     |   <item>              x |
 *     +-------------------------+
 */
class StackSelect extends form_1.AbstractFormControl {
    constructor() {
        super(...arguments);
        this.view = new views.Main(this);
        this.values = {
            root: {
                wml: {
                    id: 'root'
                },
                id: (0, __1.getId)(this.attrs),
                className: (0, util_1.concat)(exports.STACK_SELECT, (0, __1.getClassName)(this.attrs), (0, feedback_1.getValidityClassName)(this.attrs), (this.attrs && this.attrs.block) ? orientation_1.BLOCK : ''),
                dir: (this.attrs && this.attrs.dir) ?
                    this.attrs.dir : 1
            },
            control: {
                wml: {
                    id: 'root'
                }
            },
            label: {
                wml: {
                    id: 'label'
                },
                text: (0, form_1.getLabel)(this.attrs)
            },
            search: {
                wml: {
                    id: 'search'
                },
                name: (this.attrs && this.attrs.name) ?
                    this.attrs.name : '',
                value: undefined,
                block: true,
                disabled: (this.attrs && this.attrs.disabled) ?
                    this.attrs.disabled : false,
                placeholder: (this.attrs && this.attrs.placeholder) || '',
                onSearch: (evt) => {
                    if (this.attrs && this.attrs.onSearch)
                        this.attrs.onSearch(evt);
                },
                onSelect: ({ value }) => this.push(value)
            },
            messages: {
                wml: {
                    id: 'message'
                },
                text: (0, feedback_1.getMessage)(this.attrs)
            },
            stack: {
                wml: {
                    id: 'stack'
                },
                name: (0, __2.getName)(this.attrs),
                disabled: (this.attrs && this.attrs.disabled) ?
                    this.attrs.disabled : false,
                value: (this.attrs && this.attrs.value) ?
                    this.attrs.value : [],
                decorator: (this.attrs && this.attrs.stringifier) ?
                    this.attrs.stringifier : (v) => String(v),
                onChange: (e) => {
                    if (this.attrs && this.attrs.onChange)
                        this.attrs.onChange(e);
                }
            }
        };
    }
    setMessage(msg) {
        (0, form_1.setMessage)(this.view, this.values.messages.wml.id, msg);
        return this;
    }
    removeMessage() {
        (0, form_1.removeMessage)(this.view, this.values.messages.wml.id);
        return this;
    }
    /**
     * update the list of available options displayed to the user.
     */
    update(list) {
        (0, select_1.update)(this.view, this.values.search.wml.id, list);
        return this;
    }
    /**
     * push a value onto the stack.
     */
    push(v) {
        this
            .view
            .findById(this.values.stack.wml.id)
            .map(s => s.push(v));
        return this;
    }
}
exports.StackSelect = StackSelect;

},{"../":54,"../../":108,"../../content/orientation":13,"../../util":147,"../feedback":45,"../form":51,"../search":69,"../select":71,"./wml/stack-select":74}],74:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const search_1 = require("../../search");
;
const stack_1 = require("../../stack");
;
const label_1 = require("../../label");
;
const help_1 = require("../../help");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { 'id': __context.values.root.id, 'class': __context.values.root.className }, [
                ...(((__context.values.root.dir === -1)) ?
                    (() => ([
                        __this.widget(new label_1.Label({ 'for': __context.values.root.id, 'text': __context.values.label.text }, []), { 'for': __context.values.root.id, 'text': __context.values.label.text }),
                        __this.widget(new search_1.Search({ wml: { 'id': __context.values.search.wml.id }, 'name': __context.values.search.name, 'value': __context.values.search.value, 'block': __context.values.search.block, 'disabled': __context.values.search.disabled, 'stringifier': __context.values.stack.decorator, 'placeholder': __context.values.search.placeholder, 'onSearch': __context.values.search.onSearch, 'onSelect': __context.values.search.onSelect }, []), { wml: { 'id': __context.values.search.wml.id }, 'name': __context.values.search.name, 'value': __context.values.search.value, 'block': __context.values.search.block, 'disabled': __context.values.search.disabled, 'stringifier': __context.values.stack.decorator, 'placeholder': __context.values.search.placeholder, 'onSearch': __context.values.search.onSearch, 'onSelect': __context.values.search.onSelect }),
                        __this.widget(new stack_1.Stack({ wml: { 'id': __context.values.stack.wml.id }, 'name': __context.values.stack.name, 'value': __context.values.stack.value, 'disabled': __context.values.stack.disabled, 'decorator': __context.values.stack.decorator, 'onChange': __context.values.stack.onChange }, []), { wml: { 'id': __context.values.stack.wml.id }, 'name': __context.values.stack.name, 'value': __context.values.stack.value, 'disabled': __context.values.stack.disabled, 'decorator': __context.values.stack.decorator, 'onChange': __context.values.stack.onChange }),
                        __this.widget(new help_1.Help({ wml: { 'id': __context.values.messages.wml.id }, 'text': __context.values.messages.text }, []), { wml: { 'id': __context.values.messages.wml.id }, 'text': __context.values.messages.text })
                    ]))() :
                    (() => ([
                        __this.widget(new label_1.Label({ 'for': __context.values.root.id, 'text': __context.values.label.text }, []), { 'for': __context.values.root.id, 'text': __context.values.label.text }),
                        __this.widget(new stack_1.Stack({ wml: { 'id': __context.values.stack.wml.id }, 'name': __context.values.stack.name, 'value': __context.values.stack.value, 'decorator': __context.values.stack.decorator, 'onChange': __context.values.stack.onChange }, []), { wml: { 'id': __context.values.stack.wml.id }, 'name': __context.values.stack.name, 'value': __context.values.stack.value, 'decorator': __context.values.stack.decorator, 'onChange': __context.values.stack.onChange }),
                        __this.widget(new search_1.Search({ wml: { 'id': __context.values.search.wml.id }, 'name': __context.values.search.name, 'value': __context.values.search.value, 'block': __context.values.search.block, 'stringifier': __context.values.stack.decorator, 'onSearch': __context.values.search.onSearch, 'onSelect': __context.values.search.onSelect }, []), { wml: { 'id': __context.values.search.wml.id }, 'name': __context.values.search.name, 'value': __context.values.search.value, 'block': __context.values.search.block, 'stringifier': __context.values.stack.decorator, 'onSearch': __context.values.search.onSearch, 'onSelect': __context.values.search.onSelect }),
                        __this.widget(new help_1.Help({ wml: { 'id': __context.values.messages.wml.id }, 'text': __context.values.messages.text }, []), { wml: { 'id': __context.values.messages.wml.id }, 'text': __context.values.messages.text })
                    ]))())
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../help":52,"../../label":57,"../../search":69,"../../stack":75,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],75:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Stack = exports.StackChangedEvent = exports.STACK_CLOSE_BUTTON = exports.STACK_ELEMENT_CONTENT = exports.STACK_ELEMENT = exports.STACK = void 0;
const views = require("./wml/stack");
const dom_1 = require("@quenk/wml/lib/dom");
const util_1 = require("../../util");
const __1 = require("../../");
const __2 = require("../");
///classNames:begin
exports.STACK = 'ww-stack';
exports.STACK_ELEMENT = 'ww-stack__element';
exports.STACK_ELEMENT_CONTENT = 'ww-stack__element__content';
exports.STACK_CLOSE_BUTTON = 'ww-stack__button';
/**
 * StackChangedEvent is generated when the user removes an item from the stack.
 */
class StackChangedEvent extends __2.Event {
}
exports.StackChangedEvent = StackChangedEvent;
/**
 * Stack displays a list of items that can be modified
 * by releasing one or more at a time.
 */
class Stack extends __2.AbstractControl {
    constructor() {
        super(...arguments);
        this.view = new views.Main(this);
        this.values = {
            root: {
                id: (0, __1.getId)(this.attrs),
                className: (0, util_1.concat)(exports.STACK, (0, __1.getClassName)(this.attrs)),
                disabled: (this.attrs && this.attrs.disabled) ?
                    this.attrs.disabled : false,
                value: (this.attrs && this.attrs.value) ?
                    this.attrs.value : [],
                fire: () => {
                    if (!this.values.root.disabled) {
                        if (this.attrs && this.attrs.onChange)
                            this.attrs.onChange(new StackChangedEvent(this.attrs.name, this.values.root.value.slice()));
                        this.view.invalidate();
                    }
                }
            },
            element: {
                className: exports.STACK_ELEMENT,
                template: (v, idx) => (this.attrs && this.attrs.elementTemplate) ?
                    this.attrs.elementTemplate(this)(v)(idx)(this.view) :
                    views.content(this, v, idx)(this.view),
                content: {
                    className: exports.STACK_ELEMENT_CONTENT
                },
                close: (index) => () => {
                    this.values.root.value.splice(Number(index), 1);
                    this.values.root.fire();
                },
                decorator: (v) => (0, dom_1.text)((this.attrs && this.attrs.decorator) ?
                    this.attrs.decorator(v) : v + '')
            },
            close: {
                className: exports.STACK_CLOSE_BUTTON
            }
        };
    }
    /**
     * push a new member onto the stack.
     */
    push(value) {
        this.values.root.value.push(value);
        this.values.root.fire();
        return this;
    }
}
exports.Stack = Stack;

},{"../":54,"../../":108,"../../util":147,"./wml/stack":76,"@quenk/wml/lib/dom":156}],76:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = exports.content = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
const content = (s, v, _) => (__this) => {
    return [
        __this.node('div', { 'class': s.values.element.content.className }, [
            s.values.element.decorator(v)
        ])
    ];
};
exports.content = content;
;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('ul', { 'id': __context.values.root.id, 'class': __context.values.root.className }, [
                ...__forIn(__context.values.root.value, (v, index, _$$all) => ([
                    __this.node('li', { 'class': __context.values.element.className }, [
                        ...(__context.values.element.template(v, index)),
                        ...(((__context.values.root.disabled === false)) ?
                            (() => ([
                                __this.node('button', { 'class': __context.values.close.className, 'onclick': __context.values.element.close(index) }, [
                                    __document.createTextNode('×')
                                ])
                            ]))() :
                            (() => ([]))())
                    ])
                ]), () => ([]))
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],77:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Switch = exports.SwitchChangedEvent = exports.SWITCH_SLIDER = exports.SWITCH = void 0;
const util_1 = require("../../util");
const __1 = require("../../");
const __2 = require("../");
const switch_1 = require("./wml/switch");
///classNames:begin
exports.SWITCH = 'ww-switch';
exports.SWITCH_SLIDER = 'ww-switch__slider';
/**
 * SwitchChangedEvent signals the user has changed the switch.
 */
class SwitchChangedEvent extends __2.Event {
}
exports.SwitchChangedEvent = SwitchChangedEvent;
/**
 * Switch allows the user to select between one or two values.
 */
class Switch extends __2.AbstractControl {
    constructor() {
        super(...arguments);
        this.view = new switch_1.Main(this);
        this.values = {
            root: {
                id: (0, __1.getId)(this.attrs),
                className: (0, util_1.concat)(exports.SWITCH, (0, __1.getClassName)(this.attrs))
            },
            slider: {
                className: exports.SWITCH_SLIDER
            },
            input: {
                name: (0, __2.getName)(this.attrs),
                value: (this.attrs && this.attrs.value) ?
                    this.attrs.value : false,
                checked: () => this.values.input.value ? true : undefined,
                disabled: (0, __2.getDisabled)(this.attrs),
                onChange: () => {
                    this.values.input.value = (!this.values.input.value);
                    if ((this.attrs && this.attrs.onChange))
                        this.attrs.onChange(new SwitchChangedEvent(this.values.input.name, this.values.input.value));
                }
            }
        };
    }
}
exports.Switch = Switch;

},{"../":54,"../../":108,"../../util":147,"./wml/switch":78}],78:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('label', { 'id': __context.values.root.id, 'class': __context.values.root.className }, [
                __this.node('input', { 'type': 'checkbox', 'name': __context.values.input.name, 'checked': __context.values.input.checked(), 'disabled': __context.values.input.disabled, 'onchange': __context.values.input.onChange }, []),
                __this.node('div', { 'class': __context.values.slider.className }, [])
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],79:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TabBar = exports.Tab = exports.TabClickedEvent = exports.TAB_BAR = exports.TAB = void 0;
const views = require("./wml/tab-bar");
const dom_1 = require("@quenk/wml/lib/dom");
const wml_1 = require("@quenk/wml");
const active_1 = require("../../content/state/active");
const orientation_1 = require("../../content/orientation");
const util_1 = require("../../util");
const __1 = require("../../");
const __2 = require("../");
///classNames:begin
/**
 * TAB
 */
exports.TAB = 'ww-tab';
/**
 * TAB_BAR
 */
exports.TAB_BAR = 'ww-tab-bar';
/**
 * TabClickedEvent is fired when a user clicks on a tab.
 *
 * It contains information about the tab that was clicked.
 */
class TabClickedEvent extends __2.Event {
    constructor(name) {
        super(name, name);
        this.name = name;
    }
}
exports.TabClickedEvent = TabClickedEvent;
/**
 * Tab provides a single tab item.
 *
 * When a tab is clicked, it attempts to remove the active class from
 * it's siblings and apply it to itself. Therefore the sibling of a
 * tab should always be a Tab.
 */
class Tab extends __2.AbstractControl {
    constructor() {
        super(...arguments);
        this.view = new views.Tab(this);
        this.values = {
            root: {
                wml: {
                    id: 'root'
                },
                id: (0, __1.getId)(this.attrs),
                className: (0, util_1.concat)(exports.TAB, (0, __1.getClassName)(this.attrs), (this.attrs && this.attrs.active) ? active_1.ACTIVE : ''),
            },
            a: {
                wml: {
                    id: 'link'
                },
                content: (this.attrs && this.attrs.text) ?
                    [(0, dom_1.text)(this.attrs.text)] : this.children,
                clicked: (e) => {
                    e.preventDefault();
                    let maybeRoot = (0, util_1.getById)(this.view, this.values.root.wml.id);
                    if (maybeRoot.isNothing())
                        return;
                    let root = maybeRoot.get();
                    let parent = root.parentNode;
                    let sibs = parent.children;
                    for (var i = 0; i < sibs.length; i++)
                        sibs[i].classList.remove(active_1.ACTIVE);
                    root.classList.add(active_1.ACTIVE);
                    if (this.attrs && this.attrs.onClick)
                        this.attrs.onClick(new TabClickedEvent(`${this.attrs.name}`));
                }
            }
        };
    }
    /**
     * click this Tab
     */
    click() {
        (0, util_1.getById)(this.view, this.values.root.wml.id)
            .map(e => e.click());
        return this;
    }
}
exports.Tab = Tab;
/**
 * TabBar acts as a parent container for a group of Tab.
 *
 * Use it to create a tabbed navigation or view for main layout,
 * sub views or forms etc.
 */
class TabBar extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new views.TabBar(this);
        this.values = {
            root: {
                id: (0, __1.getId)(this.attrs),
                className: (0, util_1.concat)(exports.TAB_BAR, (0, __1.getClassName)(this.attrs), (this.attrs && this.attrs.justify) ? orientation_1.JUSTIFIED : '')
            }
        };
    }
}
exports.TabBar = TabBar;

},{"../":54,"../../":108,"../../content/orientation":13,"../../content/state/active":17,"../../util":147,"./wml/tab-bar":80,"@quenk/wml":157,"@quenk/wml/lib/dom":156}],80:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tab = exports.TabBar = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class TabBar {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('ul', { 'id': __context.values.root.id, 'class': __context.values.root.className }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.TabBar = TabBar;
;
class Tab {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('li', { wml: { 'id': __context.values.root.wml.id }, 'id': __context.values.root.id, 'class': __context.values.root.className }, [
                __this.node('a', { wml: { 'id': __context.values.a.wml.id }, 'href': '#', 'onclick': __context.values.a.clicked }, [
                    ...(__context.values.a.content)
                ])
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Tab = Tab;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],81:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tag = exports.DismissEvent = exports.TAG_CONTROL_DISMISS = exports.TAG_CONTROL_TEXT = exports.TAG_CONTROL = void 0;
const style_1 = require("../../content/style");
const util_1 = require("../../util");
const __1 = require("../../");
const __2 = require("../");
const tag_1 = require("./wml/tag");
///classNames:begin
exports.TAG_CONTROL = 'ww-tag-control';
exports.TAG_CONTROL_TEXT = 'ww-tag-control__text';
exports.TAG_CONTROL_DISMISS = 'ww-tag-control__dismiss';
/**
 * DismissEvent is generated when the close button us clicked.
 */
class DismissEvent extends __2.Event {
    constructor(name) {
        super(name, undefined);
        this.name = name;
    }
}
exports.DismissEvent = DismissEvent;
/**
 * Tag displays some text in a dismissable tag.
 *
 * The difference between this Tag and the one from the content
 * module is that this one is primarily meant to be used as a control
 * or as part of a more complicated control.
 */
class Tag extends __2.AbstractControl {
    constructor() {
        super(...arguments);
        this.view = new tag_1.Main(this);
        this.values = {
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.TAG_CONTROL, (0, __1.getClassName)(this.attrs)),
            style: (this.attrs && this.attrs.style) ?
                this.attrs.style : style_1.Style.Default,
            disabled: (this.attrs && this.attrs.disabled) ?
                this.attrs.disabled : false,
            text: {
                className: exports.TAG_CONTROL_TEXT,
                value: (this.attrs && this.attrs.text) ?
                    this.attrs.text : undefined,
            },
            dismiss: {
                className: exports.TAG_CONTROL_DISMISS,
                onClick: () => {
                    if (this.attrs && this.attrs.onDismiss)
                        this.attrs.onDismiss(new DismissEvent(this.attrs && this.attrs.name || ''));
                }
            }
        };
    }
}
exports.Tag = Tag;

},{"../":54,"../../":108,"../../content/style":20,"../../util":147,"./wml/tag":82}],82:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const t = require("../../../content/tag");
;
const close_1 = require("../../../content/close");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new t.Tag({ 'id': __context.values.id, 'className': __context.values.className, 'style': __context.values.style }, [
                ...(((__context.values.text.value !== '')) ?
                    (() => ([
                        __this.node('span', { 'class': __context.values.text.className }, [
                            text(__context.values.text.value)
                        ])
                    ]))() :
                    (() => ([
                        text('')
                    ]))()),
                ...(__context.children),
                ...(((__context.values.disabled !== true)) ?
                    (() => ([
                        __this.widget(new close_1.Close({ 'className': __context.values.dismiss.className, 'onClick': __context.values.dismiss.onClick }, []), { 'className': __context.values.dismiss.className, 'onClick': __context.values.dismiss.onClick })
                    ]))() :
                    (() => ([]))())
            ]), { 'id': __context.values.id, 'className': __context.values.className, 'style': __context.values.style });
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../content/close":3,"../../../content/tag":21,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],83:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextField = exports.TEXT_FIELD = exports.TextChangedEvent = void 0;
const views = require("./wml/text-field");
const record_1 = require("@quenk/noni/lib/data/record");
const util_1 = require("../../util");
const feedback_1 = require("../feedback");
const form_1 = require("../form");
const text_input_1 = require("../text-input");
Object.defineProperty(exports, "TextChangedEvent", { enumerable: true, get: function () { return text_input_1.TextChangedEvent; } });
const __1 = require("../../");
const __2 = require("../");
///classNames:begin
exports.TEXT_FIELD = 'ww-text-field';
/**
 * TextField provides a wrapped native text input control.
 */
class TextField extends form_1.AbstractFormControl {
    constructor() {
        super(...arguments);
        this.view = new views.Main(this);
        this.values = {
            root: {
                wml: {
                    id: 'root'
                },
                className: (0, util_1.concat)(exports.TEXT_FIELD, (0, __1.getClassName)(this.attrs), (0, feedback_1.getValidityClassName)(this.attrs))
            },
            messages: {
                wml: {
                    id: 'message'
                },
                text: (0, feedback_1.getMessage)(this.attrs)
            },
            label: {
                id: (0, __2.getName)(this.attrs),
                text: (0, form_1.getLabel)(this.attrs)
            },
            control: {
                wml: {
                    id: 'root'
                },
                attrs: (0, record_1.merge)(this.attrs.html || {}, {
                    id: (0, __1.getId)(this.attrs),
                    name: (0, __2.getName)(this.attrs),
                    type: (this.attrs && this.attrs.type) ?
                        this.attrs.type : 'text',
                    min: (this.attrs && this.attrs.min) ?
                        this.attrs.min : undefined,
                    max: (this.attrs && this.attrs.max) ?
                        this.attrs.max : undefined,
                    focus: (this.attrs && this.attrs.focus) ?
                        this.attrs.focus : undefined,
                    placeholder: (this.attrs && this.attrs.placeholder) ?
                        this.attrs.placeholder : '',
                    match: (this.attrs && this.attrs.match) ?
                        this.attrs.match : undefined,
                    length: (this.attrs && this.attrs.length) ?
                        this.attrs.length : undefined,
                    value: (this.attrs && this.attrs.value) ?
                        this.attrs.value : '',
                    disabled: (this.attrs && this.attrs.disabled) ? true : undefined,
                    readOnly: (this.attrs && this.attrs.readOnly) ?
                        true : undefined,
                    rows: (this.attrs && this.attrs.rows) ?
                        this.attrs.rows : 1,
                    oninput: (this.attrs && this.attrs.onChange) ?
                        oninput(this) : () => { },
                    onChange: (this.attrs && this.attrs.onChange) ?
                        this.attrs.onChange : () => { }
                })
            }
        };
    }
    setMessage(msg) {
        getHelp(this).map(h => h.setMessage(msg));
        return this;
    }
    removeMessage() {
        getHelp(this).map(h => h.removeMessage());
        return this;
    }
}
exports.TextField = TextField;
const getHelp = (t) => (0, util_1.getById)(t.view, t.values.messages.wml.id);
const oninput = (f) => (e) => {
    if (f.attrs && f.attrs && f.attrs.onChange)
        f.attrs.onChange(new text_input_1.TextChangedEvent((f.attrs && f.attrs.name) ?
            f.attrs.name : '', e.target.value));
};

},{"../":54,"../../":108,"../../util":147,"../feedback":45,"../form":51,"../text-input":85,"./wml/text-field":84,"@quenk/noni/lib/data/record":152}],84:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const label_1 = require("../../label");
;
const help_1 = require("../../help");
;
const text_input_1 = require("../../text-input");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { wml: { 'id': __context.values.root.wml.id }, 'class': __context.values.root.className }, [
                __this.widget(new label_1.Label({ 'for': __context.values.control.attrs.id, 'text': __context.values.label.text }, []), { 'for': __context.values.control.attrs.id, 'text': __context.values.label.text }),
                __this.widget(new text_input_1.TextInput(__context.values.control.attrs, []), __context.values.control.attrs),
                __this.widget(new help_1.Help({ wml: { 'id': __context.values.messages.wml.id }, 'text': __context.values.messages.text }, []), { wml: { 'id': __context.values.messages.wml.id }, 'text': __context.values.messages.text })
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../help":52,"../../label":57,"../../text-input":85,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],85:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextInput = exports.TextChangedEvent = exports.TEXT_INPUT = void 0;
const views = require("./wml/text-input");
const timer_1 = require("@quenk/noni/lib/control/timer");
const record_1 = require("@quenk/noni/lib/data/record");
const util_1 = require("../../util");
const orientation_1 = require("../../content/orientation");
const size_1 = require("../../content/size");
const focus_1 = require("../focus");
const __1 = require("../../");
const __2 = require("../");
///classNames:begin
exports.TEXT_INPUT = 'ww-text-input';
/**
 * TextChangedEvent
 */
class TextChangedEvent extends __2.Event {
}
exports.TextChangedEvent = TextChangedEvent;
/**
 * TextInput provides some extra styling to the native input.
 */
class TextInput extends __2.AbstractControl {
    constructor() {
        super(...arguments);
        this.view = (this.attrs && this.attrs.rows && this.attrs.rows > 1) ?
            new views.Textarea(this) : new views.Input(this);
        this.length = (this.attrs && this.attrs.length) ?
            this.attrs.length : Infinity;
        this.values = {
            control: {
                wml: {
                    id: 'root'
                }
            },
            attrs: (0, record_1.merge)((this.attrs && this.attrs.html) || {}, {
                id: (0, __1.getId)(this.attrs),
                class: (0, util_1.concat)(exports.TEXT_INPUT, (0, __1.getClassName)(this.attrs), (this.attrs && this.attrs.size) ?
                    (0, size_1.getSizeClassName)(this.attrs.size) : '', (this.attrs && this.attrs.block) ?
                    orientation_1.BLOCK : ''),
                name: (0, __2.getName)(this.attrs),
                type: (this.attrs && this.attrs.type) ?
                    this.attrs.type : 'text',
                min: (this.attrs && this.attrs.min) ?
                    String(this.attrs.min) : null,
                max: (this.attrs && this.attrs.max) ?
                    String(this.attrs.max) : null,
                match: new RegExp((this.attrs && this.attrs.match) ?
                    this.attrs.match : '.'),
                placeholder: (this.attrs && this.attrs.placeholder) ?
                    this.attrs.placeholder : '',
                value: (this.attrs && this.attrs.value) ?
                    this.attrs.value : '',
                rows: String((this.attrs && this.attrs.rows) ?
                    this.attrs.rows : 1),
                disabled: (this.attrs && this.attrs.disabled === true) ?
                    true : null,
                readOnly: (this.attrs && this.attrs.readOnly === true) ?
                    true : null,
                onkeydown: (e) => {
                    if (e.key.length === 1) {
                        let value = e.target.value || '';
                        if ((!this.values.attrs.match.test(e.key)) ||
                            (value.length > this.length))
                            e.preventDefault();
                    }
                },
                oninput: dispatchInput(this),
                autofocus: (this.attrs && this.attrs.focus) ? true : undefined,
                onfocus: () => {
                    if (this.attrs && this.attrs.onFocusGained)
                        this.attrs.onFocusGained(new focus_1.FocusGainedEvent((0, __2.getName)(this.attrs)));
                },
                onblur: () => {
                    if (this.attrs && this.attrs.onFocusLost)
                        this.attrs.onFocusLost(new focus_1.FocusLostEvent((0, __2.getName)(this.attrs)));
                }
            })
        };
    }
    rendered() {
        if (this.values.attrs.autofocus === true)
            this.focus();
    }
    focus() {
        return (0, timer_1.tick)(() => (0, focus_1.focus)(this.view, this.values.control.wml.id));
    }
}
exports.TextInput = TextInput;
/**
 * dispatchInput when the user inputs some text.
 */
const dispatchInput = (i) => (e) => {
    if (i.attrs && i.attrs.onChange)
        i.attrs.onChange(new TextChangedEvent((i.attrs && i.attrs.name) ?
            i.attrs.name : '', e.target.value));
};

},{"../":54,"../../":108,"../../content/orientation":13,"../../content/size":16,"../../util":147,"../focus":50,"./wml/text-input":86,"@quenk/noni/lib/control/timer":148,"@quenk/noni/lib/data/record":152}],86:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Input = exports.Textarea = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const document = require("@quenk/wml/lib/dom");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Textarea {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('textarea', __context.values.attrs, [
                document.createTextNode(__context.values.attrs.value)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Textarea = Textarea;
;
class Input {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('input', __context.values.attrs, []);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Input = Input;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],87:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Toolbar = exports.TOOLBAR_COMPAT = exports.TOOLBAR = void 0;
const views = require("./wml/toolbar");
const wml_1 = require("@quenk/wml");
const util_1 = require("../../util");
const __1 = require("../../");
///classNames:begin
exports.TOOLBAR = 'ww-toolbar';
exports.TOOLBAR_COMPAT = '-toolbar-compat';
/**
 * Toolbar provides a widget for grouping related controls into a
 * single row.
 */
class Toolbar extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new views.Main(this);
        this.values = {
            root: {
                id: (0, __1.getId)(this.attrs),
                className: (0, util_1.concat)(exports.TOOLBAR, (0, __1.getClassName)(this.attrs))
            }
        };
    }
}
exports.Toolbar = Toolbar;

},{"../../":108,"../../util":147,"./wml/toolbar":88,"@quenk/wml":157}],88:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { 'id': __context.values.root.id, 'class': __context.values.root.className }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],89:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Typeahead = exports.TYPEAHEAD = exports.ItemSelectedEvent = exports.TextChangedEvent = exports.TermChangedEvent = void 0;
const views = require("./wml/typeahead");
const util_1 = require("../../util");
const form_1 = require("../form");
const search_1 = require("../search");
Object.defineProperty(exports, "TermChangedEvent", { enumerable: true, get: function () { return search_1.TermChangedEvent; } });
const text_field_1 = require("../text-field");
Object.defineProperty(exports, "TextChangedEvent", { enumerable: true, get: function () { return text_field_1.TextChangedEvent; } });
const select_1 = require("../select");
Object.defineProperty(exports, "ItemSelectedEvent", { enumerable: true, get: function () { return select_1.ItemSelectedEvent; } });
///classNames:begin
exports.TYPEAHEAD = 'ww-typeahead';
/**
 * Typeahead provides an text input field that can suggests values
 * as the user types.
 */
class Typeahead extends form_1.AbstractFormControl {
    constructor() {
        super(...arguments);
        this.view = new views.Main(this);
        this.values = {
            root: new select_1.RootSection(this.attrs),
            control: new select_1.ControlSection(),
            messages: new select_1.MessagesSection(this.attrs),
            label: new select_1.LabelSection(this.attrs),
            search: new select_1.SearchSection(this.attrs, () => this.close(), (e) => {
                this.close();
                let mSearch = (0, util_1.getById)(this.view, this.values.search.wml.id);
                if (mSearch.isJust()) {
                    let s = mSearch.get();
                    let str = (this.values.search.stringifier) ?
                        this.values.search.stringifier(e.value) : e.value + '';
                    s.set(str);
                    if (this.attrs && this.attrs.onChange)
                        this.attrs.onChange(new text_field_1.TextChangedEvent('' + this.attrs.name, str));
                }
            })
        };
    }
    open() {
        (0, select_1.open)(this.view, this.values.search.wml.id);
        return this;
    }
    close() {
        (0, select_1.close)(this.view, this.values.search.wml.id);
        return this;
    }
    setMessage(msg) {
        this.values.messages.text = msg;
        (0, form_1.setMessage)(this.view, this.values.messages.wml.id, msg);
        return this;
    }
    removeMessage() {
        this.values.messages.text = '';
        (0, form_1.removeMessage)(this.view, this.values.messages.wml.id);
        return this;
    }
    update(results) {
        (0, select_1.update)(this.view, this.values.search.wml.id, results);
        return this;
    }
}
exports.Typeahead = Typeahead;

},{"../../util":147,"../form":51,"../search":69,"../select":71,"../text-field":83,"./wml/typeahead":90}],90:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const search_1 = require("../../search");
;
const label_1 = require("../../label");
;
const help_1 = require("../../help");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { 'id': __context.values.root.id, 'class': __context.values.root.className }, [
                __this.widget(new label_1.Label({ 'for': __context.values.root.id, 'text': __context.values.label.text }, []), { 'for': __context.values.root.id, 'text': __context.values.label.text }),
                __this.widget(new search_1.Search({ wml: { 'id': __context.values.search.wml.id }, 'name': __context.values.search.name, 'className': __context.values.search.className, 'block': __context.values.search.block, 'disabled': __context.values.search.disabled, 'placeholder': __context.values.search.placeholder, 'readOnly': __context.values.search.readOnly, 'itemTemplate': __context.values.search.itemTemplate, 'noItemsTemplate': __context.values.search.noItemsTemplate, 'stringifier': __context.values.search.stringifier, 'onSearch': __context.values.search.onSearch, 'onSelect': __context.values.search.onSelect }, []), { wml: { 'id': __context.values.search.wml.id }, 'name': __context.values.search.name, 'className': __context.values.search.className, 'block': __context.values.search.block, 'disabled': __context.values.search.disabled, 'placeholder': __context.values.search.placeholder, 'readOnly': __context.values.search.readOnly, 'itemTemplate': __context.values.search.itemTemplate, 'noItemsTemplate': __context.values.search.noItemsTemplate, 'stringifier': __context.values.search.stringifier, 'onSearch': __context.values.search.onSearch, 'onSelect': __context.values.search.onSelect }),
                __this.widget(new help_1.Help({ wml: { 'id': __context.values.messages.wml.id }, 'text': __context.values.messages.text }, []), { wml: { 'id': __context.values.messages.wml.id }, 'text': __context.values.messages.text })
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../help":52,"../../label":57,"../../search":69,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],91:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PropertyList = exports.DataCtx = exports.PROPERTY_LIST = void 0;
const wml_1 = require("@quenk/wml");
const path_1 = require("@quenk/noni/lib/data/record/path");
const util_1 = require("../../util");
const __1 = require("../../");
const property_list_1 = require("./wml/property-list");
///classNames:begin
exports.PROPERTY_LIST = 'ww-property-list';
/**
 * DataCtx
 */
class DataCtx {
    constructor(data, name, value, format) {
        this.data = data;
        this.name = name;
        this.value = value;
        this.format = format;
    }
}
exports.DataCtx = DataCtx;
/**
 * PropertyList generates a description list using the properties of
 * an object.
 */
class PropertyList extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new property_list_1.PropertyListView(this);
        this.values = {
            root: {
                className: (0, util_1.concat)(exports.PROPERTY_LIST, (0, __1.getClassName)(this.attrs))
            },
            fields: ((this.attrs && this.attrs.fields) ?
                this.attrs.fields : []),
            data: {
                value: ((this.attrs && this.attrs.data) ?
                    this.attrs.data : {}),
                get: (f) => {
                    let mData = (0, path_1.get)(f.name, this.values.data.value);
                    if (mData.isNothing())
                        return new property_list_1.NothingView({}).render();
                    let d = mData.get();
                    let fmt = (f.format) ? f.format : (c) => '' + c;
                    let ctx = new DataCtx(d, f.name, this.values.data.value, fmt);
                    if (f.dataFragment)
                        return f.dataFragment(ctx).render();
                    else
                        return new property_list_1.DataView(ctx).render();
                }
            }
        };
    }
    /**
     * setData to be displayed.
     */
    setData(data) {
        this.values.data.value = data;
        this.view.invalidate();
        return this;
    }
}
exports.PropertyList = PropertyList;

},{"../../":108,"../../util":147,"./wml/property-list":92,"@quenk/noni/lib/data/record/path":153,"@quenk/wml":157}],92:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PropertyListView = exports.DataView = exports.NothingView = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
;
const description_list_1 = require("../../../layout/description-list");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class NothingView {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new description_list_1.Data({}, []), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.NothingView = NothingView;
;
class DataView {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new description_list_1.Data({}, [
                text(__context.format(__context.data))
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.DataView = DataView;
;
class PropertyListView {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new description_list_1.DescriptionList({ 'className': __context.values.root.className }, [
                ...__forIn(__context.values.fields, (field, _$$i, _$$all) => ([
                    __this.widget(new description_list_1.Title({}, [
                        text(field.heading)
                    ]), {}),
                    __context.values.data.get(field)
                ]), () => ([]))
            ]), { 'className': __context.values.root.className });
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.PropertyListView = PropertyListView;

},{"../../../layout/description-list":113,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],93:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sortById = exports.SortRequest = void 0;
const path_1 = require("@quenk/noni/lib/data/record/path");
const sort_1 = require("@quenk/noni/lib/data/array/sort");
/**
 * SortRequest contains the info needed to preform a sort.
 */
class SortRequest {
    constructor(column, data, key) {
        this.column = column;
        this.data = data;
        this.key = key;
    }
}
exports.SortRequest = SortRequest;
/**
 * sortById sorts a dataset by a column using the columns id.
 *
 * Data is only sorted by one column at a time.
 */
const sortById = (cols, key, data, id) => {
    let spec = cols[id];
    let [current, original] = data;
    if (spec === undefined)
        return [current, key];
    if (!spec.sort)
        return [current, key];
    if (key[0] === id) {
        return [current.reverse(), [key[0], key[1] * -1]];
    }
    else {
        let strategy = getSortStrategy(spec.sort);
        let alias = spec.alias ? spec.alias : spec.name;
        return [doSort(original.slice(), strategy, alias), [id, -1]];
    }
};
exports.sortById = sortById;
const getSortStrategy = (s) => {
    if (typeof s === 'function')
        return s;
    if (s === 'date')
        return sort_1.date;
    if (s === 'number')
        return sort_1.number;
    if (s === 'string')
        return sort_1.string;
    return sort_1.natural;
};
const doSort = (data, s, alias) => data.sort((a, b) => s(getAny(alias, a), getAny(alias, b)));
const getAny = (path, src) => (0, path_1.getDefault)(path, src, undefined);

},{"@quenk/noni/lib/data/array/sort":150,"@quenk/noni/lib/data/record/path":153}],94:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataChangedEvent = exports.CellClickedEvent = exports.HeadingClickedEvent = void 0;
/**
 * HeadingClickedEvent is triggered when the user clicks on
 * one of the column headings.
 */
class HeadingClickedEvent {
    constructor(column) {
        this.column = column;
    }
}
exports.HeadingClickedEvent = HeadingClickedEvent;
/**
 * CellClickedEvent triggered when a cell is clicked on.
 */
class CellClickedEvent {
    constructor(column, row) {
        this.column = column;
        this.row = row;
    }
}
exports.CellClickedEvent = CellClickedEvent;
/**
 * DataChangedEvent generated when the internal representation of the data
 * changes.
 */
class DataChangedEvent {
    constructor(name, data, key) {
        this.name = name;
        this.data = data;
        this.key = key;
    }
}
exports.DataChangedEvent = DataChangedEvent;

},{}],95:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataTable = exports.NewCellContext = exports.NewBodyContext = exports.NewHeadingContext = exports.NewHeadContext = exports.DESC = exports.ASC = exports.DATA_TABLE_CELL = exports.DATA_TABLE_BODY = exports.DATA_TABLE_HEADING = exports.DATA_TABLE_HEAD = exports.DATA_TABLE = exports.HeadingClickedEvent = exports.CellClickedEvent = exports.DataChangedEvent = exports.SortRequest = void 0;
const views = require("./wml/table");
const wml_1 = require("@quenk/wml");
const array_1 = require("@quenk/noni/lib/data/array");
const path_1 = require("@quenk/noni/lib/data/record/path");
const util_1 = require("../../util");
const __1 = require("../../");
const sort_1 = require("./column/sort");
Object.defineProperty(exports, "SortRequest", { enumerable: true, get: function () { return sort_1.SortRequest; } });
const event_1 = require("./event");
Object.defineProperty(exports, "DataChangedEvent", { enumerable: true, get: function () { return event_1.DataChangedEvent; } });
Object.defineProperty(exports, "CellClickedEvent", { enumerable: true, get: function () { return event_1.CellClickedEvent; } });
Object.defineProperty(exports, "HeadingClickedEvent", { enumerable: true, get: function () { return event_1.HeadingClickedEvent; } });
const range_1 = require("./range");
///classNames:begin
exports.DATA_TABLE = 'ww-data-table';
exports.DATA_TABLE_HEAD = 'ww-data-table__head';
exports.DATA_TABLE_HEADING = 'ww-data-table__heading';
exports.DATA_TABLE_BODY = 'ww-data-table__body';
exports.DATA_TABLE_CELL = 'ww-data-table__cell';
exports.ASC = '-asc';
exports.DESC = '-desc';
/**
 * NewHeadContext
 */
class NewHeadContext {
    constructor(table) {
        this.table = table;
        this.className = (0, util_1.concat)(exports.DATA_TABLE_HEAD, (this.table.attrs && this.table.attrs.headClassName || ''));
        this.columns = this.table.values.columns;
        this.data = this.table.values.dataset[0];
        this.heading = (c, i) => getHeadingView(this.table, new NewHeadingContext(this.table, this, c, i), c).render();
    }
}
exports.NewHeadContext = NewHeadContext;
/**
 * NewHeadingContext
 */
class NewHeadingContext {
    constructor(table, headContext, column, index) {
        this.table = table;
        this.headContext = headContext;
        this.column = column;
        this.index = index;
        this.className = (0, util_1.concat)(exports.DATA_TABLE_HEADING, (this.table.attrs && this.table.attrs.headingClassName || ''), this.column.headingClassName, getSortClassName(this.table.values.sortKey, this.index));
        this.onclick = (_) => {
            if (this.column.sort)
                this.table.values.sort(this.index);
            if (this.column.onHeadingClicked)
                this.column.onHeadingClicked(new event_1.HeadingClickedEvent(this.index));
            if (this.table.attrs && this.table.attrs.onHeadingClicked)
                this.table.attrs.onHeadingClicked(new event_1.HeadingClickedEvent(this.index));
        };
    }
}
exports.NewHeadingContext = NewHeadingContext;
/**
 * NewBodyContext
 */
class NewBodyContext {
    constructor(table) {
        this.table = table;
        this.className = (0, util_1.concat)(exports.DATA_TABLE_BODY, (this.table.attrs && this.table.attrs.bodyClassName || ''));
        this.columns = this.table.values.columns;
        this.data = this.table.values.dataset[0];
        this.cell = (c, id, row) => getCellView(this.table, new NewCellContext(this.table, this, c, id, row), c).render();
    }
}
exports.NewBodyContext = NewBodyContext;
/**
 * NewCellContext
 */
class NewCellContext {
    constructor(table, bodyContext, spec, column, row) {
        this.table = table;
        this.bodyContext = bodyContext;
        this.spec = spec;
        this.column = column;
        this.row = row;
        this.id = cellId(this.column, this.row);
        this.className = (0, util_1.concat)(exports.DATA_TABLE_CELL, (this.table.attrs && this.table.attrs.cellClassName || ''), this.spec.cellClassName, getSortClassName(this.table.values.sortKey, this.column));
        this.value = (0, path_1.unsafeGet)(this.spec.name, this.table.values.dataset[0][this.row]);
        this.datum = this.table.values.dataset[0][this.row];
        this.format = this.spec.format ?
            this.spec.format :
            (c) => String(c == null ? '' : c);
        this.onclick = () => {
            if (this.spec.onCellClicked)
                this.spec.onCellClicked(new event_1.CellClickedEvent(this.column, this.row));
            if (this.table.attrs && this.table.attrs.onCellClicked)
                this.table.attrs.onCellClicked(new event_1.CellClickedEvent(this.column, this.row));
        };
    }
}
exports.NewCellContext = NewCellContext;
/**
 * DataTable can be used for displaying sortable
 * tabular data.
 */
class DataTable extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new views.Main(this);
        this.theadView = new views.EmptyView({});
        this.tbodyView = new views.EmptyView({});
        this.values = {
            wml: { id: 'table' },
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.DATA_TABLE, (0, __1.getClassName)(this.attrs)),
            name: (this.attrs && this.attrs.name || ''),
            sortable: (this.attrs && (this.attrs.sortable != null)) ?
                this.attrs.sortable : true,
            sortKey: ((this.attrs && this.attrs.sortKey) ?
                this.attrs.sortKey : [-1, 1]),
            sort: (col) => {
                if (this.values.sortable)
                    this.sort(col);
            },
            dataset: ((this.attrs && this.attrs.data) ?
                [this.attrs.data.slice(), this.attrs.data.slice()] :
                [[], []]),
            columns: (this.attrs && this.attrs.columns) ?
                this.attrs.columns : [],
            thead: () => {
                this.theadView = getHeadView(this, new NewHeadContext(this));
                return this.theadView.render();
            },
            tbody: () => {
                this.tbodyView = getBodyView(this, new NewBodyContext(this));
                return this.tbodyView.render();
            }
        };
    }
    /**
     * @private
     */
    fireChange() {
        if (this.attrs && this.attrs.onChange)
            this.attrs.onChange(new event_1.DataChangedEvent(this.values.name, this.values.dataset[0].slice(), this.values.sortKey.slice()));
    }
    /**
     * update the data displayed with a new data.
     */
    update(data) {
        this.values.dataset = [data.slice(), data.slice()];
        this.view.invalidate();
        this.fireChange();
        return this;
    }
    /**
     * updateWithSortKey is like update but will set the sort key as well.
     */
    updateWithSortKey(data, key) {
        this.values.sortKey = key;
        this.update(data);
        return this;
    }
    /**
     * sort the table data by the column id specified.
     *
     * The data can only be sorted by one column at a time and that column
     * must specify the "sort" key.
     *
     * This method causes a repaint.
     */
    sort(id) {
        let { sortKey, dataset } = this.values;
        let del = getSortDelegate(this);
        let [data, key] = del(new sort_1.SortRequest(id, dataset[1], sortKey));
        this.values.dataset[0] = data;
        this.values.sortKey = key;
        this.view.invalidate();
        this.fireChange();
        return this;
    }
    /**
     * getRow returns a Range of HTMLTableCellElements for the row
     * that matches the provided id.
     *
     * If no rows are found by that id, the Range will be empty.
     * In order for this method to work the body view MUST include
     * the wml:id on each <tr> element that represents a row of data.
     */
    getRow(row) {
        let mTr = (0, util_1.getById)(this.tbodyView, `${row}`);
        if (mTr.isNothing())
            return new range_1.RangeInstance([]);
        let tr = mTr.get();
        return new range_1.RangeInstance((0, array_1.make)(tr.cells.length, (n) => tr.cells[n]));
    }
    /**
     * getCell provides a Range containing a cell located at the
     * intersection of the column and row.
     */
    getCell(column, row) {
        let cells = this.getRow(row).cells;
        if (!cells[column])
            return new range_1.RangeInstance([]);
        return new range_1.RangeInstance([cells[column]]);
    }
}
exports.DataTable = DataTable;
const getHeadView = (table, ctx) => (table.attrs && table.attrs.headFragment) ?
    table.attrs.headFragment(ctx) : new views.HeadView(ctx);
const getHeadingView = (table, ctx, c) => c.headingFragment ? c.headingFragment(ctx) :
    (table.attrs && table.attrs.headingFragment) ?
        table.attrs.headingFragment(ctx) : new views.HeadingView(ctx);
const getBodyView = (table, ctx) => (table.attrs && table.attrs.bodyFragment) ?
    table.attrs.bodyFragment(ctx) :
    new views.BodyView(ctx);
const getCellView = (table, ctx, c) => c.cellFragment ? c.cellFragment(ctx) :
    (table.attrs && table.attrs.cellFragment) ?
        table.attrs.cellFragment(ctx) :
        new views.CellView(ctx);
const getSortDelegate = (table) => (table.attrs && table.attrs.sortDelegate) ?
    table.attrs.sortDelegate :
    (r) => (0, sort_1.sortById)(table.values.columns, r.key, [table.values.dataset[0], r.data], r.column);
const getSortClassName = (key, index) => (key[0] === index) ? (key[1] === 1) ? exports.ASC : exports.DESC : '';
const cellId = (column, row) => `${column},${row}`;

},{"../../":108,"../../util":147,"./column/sort":93,"./event":94,"./range":96,"./wml/table":97,"@quenk/noni/lib/data/array":149,"@quenk/noni/lib/data/record/path":153,"@quenk/wml":157}],96:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RangeInstance = void 0;
/**
 * RangeInstance
 */
class RangeInstance {
    constructor(cells) {
        this.cells = cells;
    }
}
exports.RangeInstance = RangeInstance;

},{}],97:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = exports.CellView = exports.BodyView = exports.HeadingView = exports.HeadView = exports.EmptyView = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
;
const table_1 = require("../../../layout/table");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class EmptyView {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', {}, []);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.EmptyView = EmptyView;
;
class HeadView {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('thead', { 'class': __context.className }, [
                __this.node('tr', {}, [
                    ...__forIn(__context.columns, (col, idx, _$$all) => ([
                        __context.heading(col, idx)
                    ]), () => ([]))
                ])
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.HeadView = HeadView;
;
class HeadingView {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('th', { 'class': __context.className, 'onclick': __context.onclick }, [
                text(__context.column.heading)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.HeadingView = HeadingView;
;
class BodyView {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('tbody', { 'class': __context.className }, [
                ...__forIn(__context.data, (_, row, _$$all) => ([
                    __this.node('tr', { wml: { 'id': String(row) } }, [
                        ...__forIn(__context.columns, (col, idx, _$$all) => ([
                            __context.cell(col, idx, row)
                        ]), () => ([]))
                    ])
                ]), () => ([]))
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.BodyView = BodyView;
;
class CellView {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('td', { wml: { 'id': __context.id }, 'class': __context.className, 'onclick': __context.onclick }, [
                text(__context.format(__context.value))
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.CellView = CellView;
;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new table_1.TableLayout({ wml: { 'id': __context.values.wml.id }, 'id': __context.values.id, 'className': __context.values.className }, [
                __context.values.thead(),
                __context.values.tbody()
            ]), { wml: { 'id': __context.values.wml.id }, 'id': __context.values.id, 'className': __context.values.className });
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../layout/table":132,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],98:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Alert = exports.ALERT = exports.Style = void 0;
const dom_1 = require("@quenk/wml/lib/dom");
const wml_1 = require("@quenk/wml");
const style_1 = require("../../content/style");
Object.defineProperty(exports, "Style", { enumerable: true, get: function () { return style_1.Style; } });
const util_1 = require("../../util");
const __1 = require("../../");
const alert_1 = require("./wml/alert");
///classNames:begin
exports.ALERT = 'ww-alert';
/**
 * Alert is used for displaying important messages to users.
 */
class Alert extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new alert_1.Main(this);
        this.values = {
            wml: {
                id: 'alert'
            },
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.ALERT, (0, __1.getClassName)(this.attrs), (this.attrs && this.attrs.style) ?
                (0, style_1.getStyleClassName)(this.attrs.style) :
                style_1.DEFAULT),
            closable: (this.attrs && this.attrs.closable) ?
                this.attrs.closable : false,
            content: (this.attrs && this.attrs.text) ?
                [(0, dom_1.text)(this.attrs.text)] : this.children
        };
    }
    /**
     * close the alert.
     */
    close() {
        let mRoot = (0, util_1.getById)(this.view, this.values.wml.id);
        if (mRoot.isJust()) {
            let root = mRoot.get();
            if (root.parentNode)
                root.parentNode.removeChild(root);
        }
    }
}
exports.Alert = Alert;

},{"../../":108,"../../content/style":20,"../../util":147,"./wml/alert":99,"@quenk/wml":157,"@quenk/wml/lib/dom":156}],99:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const close_1 = require("../../../content/close");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { wml: { 'id': __context.values.wml.id }, 'id': __context.values.id, 'class': __context.values.className }, [
                ...(__context.values.content),
                ...((__context.values.closable) ?
                    (() => ([
                        __this.widget(new close_1.Close({ 'onClick': () => __context.close() }, []), { 'onClick': () => __context.close() })
                    ]))() :
                    (() => ([
                        text('')
                    ]))())
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../content/close":3,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],100:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Confirm = exports.Primary = exports.CONFIRM_YES = exports.CONFIRM_NO = exports.CONFIRM = void 0;
const wml_1 = require("@quenk/wml");
const util_1 = require("../../util");
const __1 = require("../../");
const prompt_1 = require("../prompt");
const confirm_1 = require("./wml/confirm");
///classNames:begin
exports.CONFIRM = 'ww-confirm';
exports.CONFIRM_NO = 'ww-confirm__no';
exports.CONFIRM_YES = 'ww-prompt__yes';
///classNames:end
/**
 * Primary indicates whether the yes or no button should be highlighted.
 */
var Primary;
(function (Primary) {
    Primary["No"] = "no";
    Primary["Yes"] = "yes";
})(Primary = exports.Primary || (exports.Primary = {}));
/**
 * Confirm displays a dialog for confirming an action.
 */
class Confirm extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new confirm_1.Main(this);
        this.values = {
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.CONFIRM, (0, __1.getClassName)(this.attrs)),
            wml: {
                id: 'modal'
            },
            header: {
                title: (this.attrs && this.attrs.title) ?
                    this.attrs.title : ''
            },
            footer: {
                no: {
                    text: (this.attrs && this.attrs.noText) ?
                        this.attrs.noText : 'No',
                    className: (0, util_1.concat)(exports.CONFIRM_NO, (this.attrs &&
                        this.attrs.primary &&
                        this.attrs.primary === Primary.No) ? '-primary' : ''),
                    onClick: () => {
                        if (this.attrs && this.attrs.onNo)
                            this.attrs.onNo();
                        this.close();
                    }
                },
                yes: {
                    text: (this.attrs && this.attrs.yesText) ?
                        this.attrs.yesText : 'Yes',
                    wml: {
                        id: 'yes'
                    },
                    className: (0, util_1.concat)(exports.CONFIRM_YES, (this.attrs &&
                        this.attrs.primary &&
                        this.attrs.primary === Primary.No) ? '' : '-primary'),
                    onClick: () => {
                        if (this.attrs && this.attrs.onYes)
                            this.attrs.onYes();
                        this.close();
                    }
                }
            }
        };
    }
    close() {
        (0, prompt_1.close)(this.view, this.values.wml.id);
        return this;
    }
}
exports.Confirm = Confirm;

},{"../../":108,"../../util":147,"../prompt":106,"./wml/confirm":101,"@quenk/wml":157}],101:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const button_1 = require("../../../control/button");
;
const close_button_1 = require("../../../control/close-button");
;
const modal_1 = require("../../modal");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new modal_1.Modal({ wml: { 'id': __context.values.wml.id }, 'className': __context.values.className }, [
                __this.widget(new modal_1.ModalHeader({}, [
                    __this.widget(new close_button_1.CloseButton({ 'onClick': __context.values.footer.no.onClick }, []), { 'onClick': __context.values.footer.no.onClick }),
                    text(__context.values.header.title)
                ]), {}),
                __this.widget(new modal_1.ModalBody({}, [
                    ...(__context.children)
                ]), {}),
                __this.widget(new modal_1.ModalFooter({}, [
                    __this.widget(new button_1.Button({ 'text': __context.values.footer.no.text, 'className': __context.values.footer.no.className, 'onClick': __context.values.footer.no.onClick }, []), { 'text': __context.values.footer.no.text, 'className': __context.values.footer.no.className, 'onClick': __context.values.footer.no.onClick }),
                    __this.widget(new button_1.Button({ 'text': __context.values.footer.yes.text, 'className': __context.values.footer.yes.className, 'onClick': __context.values.footer.yes.onClick }, []), { 'text': __context.values.footer.yes.text, 'className': __context.values.footer.yes.className, 'onClick': __context.values.footer.yes.onClick })
                ]), {})
            ]), { wml: { 'id': __context.values.wml.id }, 'className': __context.values.className });
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../control/button":29,"../../../control/close-button":33,"../../modal":104,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],102:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Inform = exports.INFORM_OK = exports.INFORM = void 0;
const wml_1 = require("@quenk/wml");
const util_1 = require("../../util");
const __1 = require("../../");
const prompt_1 = require("../prompt");
const inform_1 = require("./wml/inform");
///classNames:begin
exports.INFORM = 'ww-inform';
exports.INFORM_OK = 'ww-inform__ok';
/**
 * Inform displays a message to the user.
 */
class Inform extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new inform_1.Main(this);
        this.values = {
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.INFORM, (0, __1.getClassName)(this.attrs)),
            wml: {
                id: 'modal'
            },
            header: {
                title: (this.attrs && this.attrs.title) ?
                    this.attrs.title : ''
            },
            footer: {
                ok: {
                    text: (this.attrs && this.attrs.buttonText) ?
                        this.attrs.buttonText : 'Ok',
                    wml: {
                        id: 'ok'
                    },
                    className: (0, util_1.concat)(exports.INFORM_OK, '-primary'),
                    onClick: () => {
                        if (this.attrs && this.attrs.onClose)
                            this.attrs.onClose();
                        this.close();
                    }
                }
            }
        };
    }
    close() {
        (0, prompt_1.close)(this.view, this.values.wml.id);
        return this;
    }
}
exports.Inform = Inform;

},{"../../":108,"../../util":147,"../prompt":106,"./wml/inform":103,"@quenk/wml":157}],103:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const button_1 = require("../../../control/button");
;
const close_button_1 = require("../../../control/close-button");
;
const modal_1 = require("../../modal");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new modal_1.Modal({ wml: { 'id': __context.values.wml.id }, 'className': __context.values.className }, [
                __this.widget(new modal_1.ModalHeader({}, [
                    __this.widget(new close_button_1.CloseButton({ 'onClick': __context.values.footer.ok.onClick }, []), { 'onClick': __context.values.footer.ok.onClick }),
                    text(__context.values.header.title)
                ]), {}),
                __this.widget(new modal_1.ModalBody({}, [
                    ...(__context.children)
                ]), {}),
                __this.widget(new modal_1.ModalFooter({}, [
                    __this.widget(new button_1.Button({ 'text': __context.values.footer.ok.text, 'className': __context.values.footer.ok.className, 'onClick': __context.values.footer.ok.onClick }, []), { 'text': __context.values.footer.ok.text, 'className': __context.values.footer.ok.className, 'onClick': __context.values.footer.ok.onClick })
                ]), {})
            ]), { wml: { 'id': __context.values.wml.id }, 'className': __context.values.className });
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../control/button":29,"../../../control/close-button":33,"../../modal":104,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],104:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModalFooter = exports.ModalBody = exports.ModalHeader = exports.Modal = exports.MODAL_FOOTER = exports.MODAL_BODY = exports.MODAL_HEADER = exports.MODAL_CONTENT = exports.MODAL_POSITION = exports.MODAL = void 0;
const views = require("./wml/modal");
const wml_1 = require("@quenk/wml");
const util_1 = require("../../util");
const __1 = require("../../");
const layout_1 = require("../../layout");
///classNames:begin
exports.MODAL = 'ww-modal';
exports.MODAL_POSITION = 'ww-modal__position';
exports.MODAL_CONTENT = 'ww-modal__content';
exports.MODAL_HEADER = 'ww-modal__header';
exports.MODAL_BODY = 'ww-modal__body';
exports.MODAL_FOOTER = 'ww-modal__footer';
/**
 * Modal
 */
class Modal extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new views.Modal(this);
        this.values = {
            wml: {
                id: 'root'
            },
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.MODAL, (0, __1.getClassName)(this.attrs)),
            content: {
                className: exports.MODAL_CONTENT
            },
            position: {
                className: exports.MODAL_POSITION
            }
        };
    }
    /**
     * close the modal.
     */
    close() {
        let mO = (0, util_1.getById)(this.view, this.values.wml.id);
        if (mO.isJust()) {
            let n = mO.get();
            if (n.parentNode)
                n.parentNode.removeChild(n);
        }
    }
}
exports.Modal = Modal;
/**
 * ModalHeader
 */
class ModalHeader extends layout_1.AbstractLayout {
    constructor() {
        super(...arguments);
        this.view = new views.ModalHeader(this);
        this.values = {
            wml: {
                id: 'root'
            },
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.MODAL_HEADER, (0, __1.getClassName)(this.attrs)),
            content: { wml: { id: 'root' } }
        };
    }
}
exports.ModalHeader = ModalHeader;
/**
 * ModalBodyAttrs
 */
class ModalBody extends layout_1.AbstractLayout {
    constructor() {
        super(...arguments);
        this.view = new views.ModalBody(this);
        this.values = {
            wml: {
                id: 'root'
            },
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.MODAL_BODY, (0, __1.getClassName)(this.attrs)),
            content: { wml: { id: 'root' } }
        };
    }
}
exports.ModalBody = ModalBody;
/**
 * ModalFooter
 */
class ModalFooter extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new views.ModalFooter(this);
        this.values = {
            wml: {
                id: 'root'
            },
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.MODAL_FOOTER, (0, __1.getClassName)(this.attrs)),
            content: { wml: { id: 'root' } }
        };
    }
}
exports.ModalFooter = ModalFooter;

},{"../../":108,"../../layout":121,"../../util":147,"./wml/modal":105,"@quenk/wml":157}],105:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModalFooter = exports.ModalBody = exports.ModalHeader = exports.Modal = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Modal {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { wml: { 'id': __context.values.wml.id }, 'id': __context.values.id, 'class': __context.values.className }, [
                __this.node('div', { 'class': __context.values.position.className }, [
                    __this.node('div', { 'class': __context.values.content.className }, [
                        ...(__context.children)
                    ])
                ])
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Modal = Modal;
;
class ModalHeader {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { wml: { 'id': __context.values.wml.id }, 'id': __context.values.id, 'class': __context.values.className }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.ModalHeader = ModalHeader;
;
class ModalBody {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { wml: { 'id': __context.values.wml.id }, 'id': __context.values.id, 'class': __context.values.className }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.ModalBody = ModalBody;
;
class ModalFooter {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { wml: { 'id': __context.values.wml.id }, 'id': __context.values.id, 'class': __context.values.className }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.ModalFooter = ModalFooter;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],106:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.close = exports.Prompt = exports.PROMPT_SAVE = exports.PROMPT_CLOSE = exports.PROMPT = void 0;
const wml_1 = require("@quenk/wml");
const util_1 = require("../../util");
const __1 = require("../../");
const prompt_1 = require("./wml/prompt");
///classNames:begin
exports.PROMPT = 'ww-prompt';
exports.PROMPT_CLOSE = 'ww-prompt__close';
exports.PROMPT_SAVE = 'ww-prompt__save';
/**
 * Prompt displays a dialog to the user suitable for collecting data
 * input.
 */
class Prompt extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new prompt_1.Main(this);
        this.values = {
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.PROMPT, (0, __1.getClassName)(this.attrs)),
            wml: {
                id: 'modal'
            },
            header: {
                title: (this.attrs && this.attrs.title) ?
                    this.attrs.title : ''
            },
            footer: {
                close: {
                    text: (this.attrs && this.attrs.closeText) ?
                        this.attrs.closeText : 'Close',
                    className: exports.PROMPT_CLOSE,
                    onClick: () => {
                        if (this.attrs && this.attrs.onCancel)
                            this.attrs.onCancel();
                        this.close();
                    }
                },
                save: {
                    text: (this.attrs && this.attrs.saveText) ?
                        this.attrs.saveText : 'Save',
                    wml: {
                        id: 'save'
                    },
                    className: (0, util_1.concat)('-primary', exports.PROMPT_SAVE),
                    disabled: (this.attrs && this.attrs.disabled) ?
                        true : false,
                    onClick: () => {
                        if (this.attrs && this.attrs.onSave)
                            this.attrs.onSave();
                        this.close();
                    }
                }
            }
        };
    }
    close() {
        (0, exports.close)(this.view, this.values.wml.id);
        return this;
    }
    /**
     * enable saving.
     */
    enable() {
        getSave(this).map(b => b.enable());
        return this;
    }
    /**
     * disable saving.
     */
    disable() {
        getSave(this).map(b => b.disable());
        return this;
    }
}
exports.Prompt = Prompt;
const getSave = (p) => (0, util_1.getById)(p.view, p.values.footer.save.wml.id);
/**
 * close the Modal in a view.
 */
const close = (view, id) => (0, util_1.getById)(view, id).map(m => m.close());
exports.close = close;

},{"../../":108,"../../util":147,"./wml/prompt":107,"@quenk/wml":157}],107:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const button_1 = require("../../../control/button");
;
const close_button_1 = require("../../../control/close-button");
;
const modal_1 = require("../../modal");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new modal_1.Modal({ wml: { 'id': __context.values.wml.id }, 'className': __context.values.className }, [
                __this.widget(new modal_1.ModalHeader({}, [
                    __this.widget(new close_button_1.CloseButton({ 'onClick': __context.values.footer.close.onClick }, []), { 'onClick': __context.values.footer.close.onClick }),
                    text(__context.values.header.title)
                ]), {}),
                __this.widget(new modal_1.ModalBody({}, [
                    ...(__context.children)
                ]), {}),
                __this.widget(new modal_1.ModalFooter({}, [
                    __this.widget(new button_1.Button({ 'text': __context.values.footer.close.text, 'className': __context.values.footer.close.className, 'onClick': __context.values.footer.close.onClick }, []), { 'text': __context.values.footer.close.text, 'className': __context.values.footer.close.className, 'onClick': __context.values.footer.close.onClick }),
                    __this.widget(new button_1.Button({ 'text': __context.values.footer.save.text, 'className': __context.values.footer.save.className, 'disabled': __context.values.footer.save.disabled, 'onClick': __context.values.footer.save.onClick }, []), { 'text': __context.values.footer.save.text, 'className': __context.values.footer.save.className, 'disabled': __context.values.footer.save.disabled, 'onClick': __context.values.footer.save.onClick })
                ]), {})
            ]), { wml: { 'id': __context.values.wml.id }, 'className': __context.values.className });
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../control/button":29,"../../../control/close-button":33,"../../modal":104,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],108:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getClassName = exports.getId = void 0;
/**
 * getId from a widget's passed attributes.
 */
const getId = (attrs) => attrs.id ? attrs.id : '';
exports.getId = getId;
/**
 * getClassName from a widget's passed attributes.
 *
 * Returns an empty string if the element has not className attribute.
 */
const getClassName = (attrs) => attrs.className || '';
exports.getClassName = getClassName;

},{}],109:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActionBar = exports.ACTION_BAR_CONTENT = exports.ACTION_BAR = void 0;
const orientation = require("../../content/orientation");
const __1 = require("../..");
const util_1 = require("../../util");
const __2 = require("../");
const action_bar_1 = require("./wml/action-bar");
///classNames:begin
/**
 * ACTION_BAR class name. for the ActionBar root.
 */
exports.ACTION_BAR = 'ww-action-bar';
/**
 * ACTION_BAR_CONTENT class name.
 */
exports.ACTION_BAR_CONTENT = 'ww-action-bar__content';
/**
 * ActionBar provides a bar across the screen that can be
 * used as a toolbar, navigation menu or something simillar.
 */
class ActionBar extends __2.AbstractLayout {
    constructor() {
        super(...arguments);
        this.view = new action_bar_1.Main(this);
        this.values = {
            root: {
                wml: {
                    id: 'root',
                },
                id: (this.attrs && this.attrs.id) ?
                    this.attrs.id : '',
                className: (0, util_1.concat)(exports.ACTION_BAR, __2.LAYOUT, orientation.POSITIONED, (0, __1.getClassName)(this.attrs))
            },
            content: {
                wml: {
                    id: 'content'
                },
                class: exports.ACTION_BAR_CONTENT
            }
        };
    }
}
exports.ActionBar = ActionBar;

},{"../":121,"../..":108,"../../content/orientation":13,"../../util":147,"./wml/action-bar":110}],110:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { wml: { 'id': __context.values.root.wml.id }, 'id': __context.values.root.id, 'class': __context.values.root.className }, [
                __this.node('div', { wml: { 'id': __context.values.content.wml.id }, 'class': __context.values.content.class }, [
                    ...(__context.children)
                ])
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],111:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Callout = exports.CALLOUT = exports.Style = void 0;
const wml_1 = require("@quenk/wml");
const style_1 = require("../../content/style");
Object.defineProperty(exports, "Style", { enumerable: true, get: function () { return style_1.Style; } });
const util_1 = require("../../util");
const __1 = require("../../");
const callout_1 = require("./wml/callout");
///classNames:begin
exports.CALLOUT = 'ww-callout';
/**
 * Callout
 */
class Callout extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new callout_1.Main(this);
        this.values = {
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.CALLOUT, (0, __1.getClassName)(this.attrs), (this.attrs && this.attrs.style) ?
                (0, style_1.getStyleClassName)(this.attrs.style) :
                style_1.DEFAULT)
        };
    }
}
exports.Callout = Callout;

},{"../../":108,"../../content/style":20,"../../util":147,"./wml/callout":112,"@quenk/wml":157}],112:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { 'class': __context.values.className }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],113:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Data = exports.Title = exports.DescriptionList = exports.DESCRIPTION_LIST_DATA = exports.DESCRIPTION_LIST_TITLE = exports.DESCRIPTION_LIST = void 0;
const views = require("./wml/description-list");
const wml_1 = require("@quenk/wml");
const orientation_1 = require("../../content/orientation");
const util_1 = require("../../util");
const __1 = require("../../");
///classNames:begin
exports.DESCRIPTION_LIST = 'ww-description-list';
exports.DESCRIPTION_LIST_TITLE = 'ww-description-list__title';
exports.DESCRIPTION_LIST_DATA = 'ww-description-list__data';
/**
 * DescriptionList layout.
 */
class DescriptionList extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new views.DescriptionList(this);
        this.values = {
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.DESCRIPTION_LIST, (0, __1.getClassName)(this.attrs), (this.attrs && this.attrs.horizontal) ? orientation_1.HORIZONTAL : '')
        };
    }
}
exports.DescriptionList = DescriptionList;
/**
 * Title
 */
class Title extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new views.Title(this);
        this.values = {
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.DESCRIPTION_LIST_TITLE, (0, __1.getClassName)(this.attrs))
        };
    }
}
exports.Title = Title;
/**
 * Data
 */
class Data extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new views.Data(this);
        this.values = {
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.DESCRIPTION_LIST_DATA, (0, __1.getClassName)(this.attrs))
        };
    }
}
exports.Data = Data;

},{"../../":108,"../../content/orientation":13,"../../util":147,"./wml/description-list":114,"@quenk/wml":157}],114:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Data = exports.Title = exports.DescriptionList = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class DescriptionList {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('dl', { 'id': __context.values.id, 'class': __context.values.className }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.DescriptionList = DescriptionList;
;
class Title {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('dt', { 'id': __context.values.id, 'class': __context.values.className }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Title = Title;
;
class Data {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('dd', { 'id': __context.values.id, 'class': __context.values.className }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Data = Data;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],115:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DrawerLayout = exports.DRAWER_LAYOUT_CONTENT = exports.DRAWER_LAYOUT = void 0;
const wml_1 = require("@quenk/wml");
const array_1 = require("@quenk/noni/lib/data/array");
const util_1 = require("../../util");
const __1 = require("../");
const view_1 = require("./view");
///classNames:begin
exports.DRAWER_LAYOUT = 'ww-drawer-layout';
exports.DRAWER_LAYOUT_CONTENT = 'ww-drawer-layout__content';
/**
 * DrawerLayout provides a 2 column layout for an application where the first
 * column is an optionally displayed menu "drawer" and the second used for
 * regular application content.
 *
 * Methods exists to open or close the drawer as well as replace the content
 * displayed in the second column as desired.
  */
class DrawerLayout extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new view_1.DrawerLayoutView(this);
        this.values = {
            wml: { id: 'layout' },
            id: this.attrs.id,
            className: (0, util_1.concat)(exports.DRAWER_LAYOUT, __1.LAYOUT, this.attrs.className),
            content: {
                wml: { id: 'content' },
                className: (0, util_1.concat)(exports.DRAWER_LAYOUT_CONTENT, __1.LAYOUT),
                content: getContent(this.children, this.attrs.drawer),
                persist: (this.attrs.persist || '').split(',').filter(id => id)
            },
            drawer: {
                wml: { id: 'drawer' },
                hidden: !this.attrs.open,
                content: getDrawer(this.children, this.attrs.drawer)
            }
        };
    }
    get _drawer() {
        return (0, util_1.getById)(this.view, this.values.drawer.wml.id).get();
    }
    get _content() {
        let content = (0, util_1.getById)(this.view, this.values.content.wml.id).get();
        if (this.attrs.content)
            return content.querySelector(`#${this.attrs.content}`);
        else
            return content;
    }
    /**
     * isOpen indicates whether the drawer part of the layout is open.
     */
    isOpen() {
        return !this._drawer.isHidden();
    }
    /**
     * open the drawer part of the layout.
     */
    open() {
        this._drawer.show();
    }
    /**
     * close the drawer part of the layout.
     */
    close() {
        this._drawer.hide();
    }
    /**
     * toggle the state of the drawer part of the layout.
     */
    toggle() {
        if (this.isOpen())
            this.close();
        else
            this.open();
    }
    setContent(frag) {
        this.removeContent();
        let content = this._content;
        frag.forEach(child => content.appendChild(child));
        return this;
    }
    removeContent() {
        let content = this._content;
        for (let i = 0; i < content.children.length; i++) {
            let child = content.children[i];
            if (!(0, array_1.contains)(this.values.content.persist, child.id))
                content.removeChild(child);
        }
        return this;
    }
}
exports.DrawerLayout = DrawerLayout;
const getDrawer = (children, id) => (0, array_1.find)(children, (el) => el.id === id)
    .map((el) => [el])
    .orJust(() => [])
    .get();
const getContent = (children, id) => children.filter(child => child.id !== id);

},{"../":121,"../../util":147,"./view":116,"@quenk/noni/lib/data/array":149,"@quenk/wml":157}],116:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DrawerLayoutView = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const drawer_1 = require("../../menu/drawer");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class DrawerLayoutView {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { wml: { 'id': __context.values.wml.id }, 'id': __context.values.id, 'class': __context.values.className }, [
                __this.widget(new drawer_1.Drawer({ wml: { 'id': __context.values.drawer.wml.id }, 'hidden': __context.values.drawer.hidden }, [
                    ...(__context.values.drawer.content)
                ]), { wml: { 'id': __context.values.drawer.wml.id }, 'hidden': __context.values.drawer.hidden }),
                __this.node('div', { wml: { 'id': __context.values.content.wml.id }, 'class': __context.values.content.className }, [
                    ...(__context.values.content.content)
                ])
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.DrawerLayoutView = DrawerLayoutView;

},{"../../menu/drawer":136,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],117:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Column = exports.Row = exports.GridLayout = exports.GRID_LAYOUT_COLUMN = exports.GRID_LAYOUT_ROW = exports.GRID_LAYOUT = void 0;
const views = require("./wml/grid");
const util_1 = require("../../util");
const __1 = require("../");
///classNames:begin
exports.GRID_LAYOUT = 'ww-grid-layout';
exports.GRID_LAYOUT_ROW = 'ww-grid-layout__row';
exports.GRID_LAYOUT_COLUMN = 'ww-grid-layout__column';
;
/**
 * GridLayout
 */
class GridLayout extends __1.AbstractLayout {
    constructor() {
        super(...arguments);
        this.view = new views.GridLayout(this);
        this.values = {
            content: {
                id: this.attrs && this.attrs.id,
                wml: {
                    id: 'root',
                },
                className: () => {
                    let c = (this.attrs && this.attrs.className) ?
                        this.attrs.className : '';
                    return (0, util_1.concat)(exports.GRID_LAYOUT, __1.LAYOUT, c);
                }
            }
        };
    }
}
exports.GridLayout = GridLayout;
/**
 * Row
 */
class Row extends __1.AbstractLayout {
    constructor() {
        super(...arguments);
        this.view = new views.Row(this);
        this.values = {
            content: {
                id: this.attrs && this.attrs.id,
                wml: {
                    id: 'row',
                },
                className: () => {
                    let c = (this.attrs && this.attrs.className) ?
                        this.attrs.className : '';
                    return (0, util_1.concat)(exports.GRID_LAYOUT_ROW, c);
                }
            }
        };
    }
}
exports.Row = Row;
/**
 * Column
 */
class Column extends __1.AbstractLayout {
    constructor() {
        super(...arguments);
        this.view = new views.Column(this);
        this.values = {
            content: {
                id: this.attrs && this.attrs.id,
                wml: {
                    id: 'column'
                },
                className: () => {
                    if (this.attrs != null) {
                        return (0, util_1.concat)(exports.GRID_LAYOUT_COLUMN, this.attrs.span ?
                            `-span${this.attrs.span}` :
                            '-span12', this.attrs.offset ?
                            `-offset${this.attrs.offset}` :
                            '', this.attrs.className);
                    }
                    else {
                        return (0, util_1.concat)(exports.GRID_LAYOUT_COLUMN, '-span12');
                    }
                }
            }
        };
    }
}
exports.Column = Column;

},{"../":121,"../../util":147,"./wml/grid":118}],118:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Column = exports.Row = exports.GridLayout = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class GridLayout {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { wml: { 'id': __context.values.content.wml.id }, 'id': __context.values.content.id, 'class': __context.values.content.className() }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.GridLayout = GridLayout;
;
class Row {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { wml: { 'id': __context.values.content.wml.id }, 'id': __context.values.content.id, 'class': __context.values.content.className() }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Row = Row;
;
class Column {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { wml: { 'id': __context.values.content.wml.id }, 'id': __context.values.content.id, 'class': __context.values.content.className() }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Column = Column;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],119:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HorizontalLayout = exports.HorizontalLayoutOrientation = exports.HORIZONTAL_LAYOUT = void 0;
const wml = require("@quenk/wml");
const views = require("./wml/horizontal");
const orientation_1 = require("../../content/orientation");
const util_1 = require("../../util");
const __1 = require("../../");
///classNames:begin
exports.HORIZONTAL_LAYOUT = 'ww-horizontal-layout';
///classNames:end
/**
 * HorizontalLayoutOrientation
 */
var HorizontalLayoutOrientation;
(function (HorizontalLayoutOrientation) {
    HorizontalLayoutOrientation["Left"] = "left";
    HorizontalLayoutOrientation["Right"] = "right";
})(HorizontalLayoutOrientation = exports.HorizontalLayoutOrientation || (exports.HorizontalLayoutOrientation = {}));
/**
 * HorizontalLayout uses the css flexbox to provide a container
 * where all items are laid out in a single row.
 */
class HorizontalLayout extends wml.Component {
    constructor() {
        super(...arguments);
        this.view = new views.Main(this);
        this.values = {
            root: {
                id: (this.attrs && this.attrs.id) ? this.attrs.id : '',
                className: (0, util_1.concat)(exports.HORIZONTAL_LAYOUT, (0, __1.getClassName)(this.attrs), getOrientation(this.attrs))
            }
        };
    }
}
exports.HorizontalLayout = HorizontalLayout;
const getOrientation = (attrs) => (attrs && attrs.orientation) ?
    attrs.orientation === HorizontalLayoutOrientation.Right ?
        orientation_1.RIGHT : orientation_1.LEFT : '';

},{"../../":108,"../../content/orientation":13,"../../util":147,"./wml/horizontal":120,"@quenk/wml":157}],120:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { 'class': __context.values.root.className }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],121:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.doRemoveContent = exports.doSetContent = exports.AbstractLayout = exports.LAYOUT = void 0;
const wml_1 = require("@quenk/wml");
const util_1 = require("../util");
///classNames:begin
exports.LAYOUT = '-layout';
/**
 * AbstractLayout provides an implementation of Layout.
 */
class AbstractLayout extends wml_1.Component {
    setContent(c) {
        (0, exports.doSetContent)(this.view, this.values.content.wml.id, c);
        return this;
    }
    removeContent() {
        (0, exports.doRemoveContent)(this.view, this.values.content.wml.id);
        return this;
    }
}
exports.AbstractLayout = AbstractLayout;
/**
 * doSetContent on a Node found in a view.
 */
const doSetContent = (view, id, content) => {
    let maybeRoot = view.findById(id);
    if (maybeRoot.isNothing())
        return (0, util_1.warnMissing)(view, id);
    let n = maybeRoot.get();
    while (n.firstChild)
        n.removeChild(n.firstChild);
    content = Array.isArray(content) ? content : [content];
    for (let i = 0; i < content.length; i++)
        n.appendChild(content[i]);
};
exports.doSetContent = doSetContent;
/**
 * doRemoveContent from a View.
 */
const doRemoveContent = (view, id) => {
    let maybeNode = view.findById(id);
    if (maybeNode.isNothing())
        return (0, util_1.warnMissing)(view, id);
    let n = maybeNode.get();
    while (n.firstChild)
        n.removeChild(n.firstChild);
};
exports.doRemoveContent = doRemoveContent;

},{"../util":147,"@quenk/wml":157}],122:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ListLayout = exports.ListLayoutItem = exports.LIST_LAYOUT_ITEM = exports.LIST_LAYOUT = void 0;
const views = require("./wml/list");
const util_1 = require("../../util");
const active_1 = require("../../content/state/active");
const __1 = require("../");
///classNames:begin
exports.LIST_LAYOUT = 'ww-list-layout';
exports.LIST_LAYOUT_ITEM = 'ww-list-layout__item';
/**
 * ListLayoutItem
 */
class ListLayoutItem extends __1.AbstractLayout {
    constructor() {
        super(...arguments);
        this.view = new views.ListLayoutItem(this);
        this.values = {
            content: {
                wml: {
                    id: 'item'
                },
                id: (this.attrs && this.attrs.id) ? this.attrs.id : '',
                className: (0, util_1.concat)(exports.LIST_LAYOUT_ITEM, (this.attrs && this.attrs.active) ? active_1.ACTIVE : ''),
                name: (this.attrs && this.attrs.name) ? this.attrs.name : '',
                onclick: () => {
                    if (this.attrs && this.attrs.onClick)
                        this.attrs.onClick(this.attrs &&
                            this.attrs.name || '');
                }
            }
        };
    }
    isActive() {
        return (0, active_1.isActive)(this.view, this.values.content.wml.id);
    }
    activate() {
        (0, active_1.activate)(this.view, this.values.content.wml.id);
        return this;
    }
    deactivate() {
        (0, active_1.deactivate)(this.view, this.values.content.wml.id);
        return this;
    }
    toggleActive() {
        if (this.isActive())
            this.deactivate();
        else
            this.activate();
        return this;
    }
}
exports.ListLayoutItem = ListLayoutItem;
/**
 * ListLayout is used to create a vertical list of content.
 *
 * Children must be ListGroupItems.
 */
class ListLayout extends __1.AbstractLayout {
    constructor() {
        super(...arguments);
        this.view = new views.ListLayout(this);
        this.values = {
            content: {
                wml: {
                    id: 'list'
                },
                id: this.attrs && this.attrs.id,
                className: (0, util_1.concat)(exports.LIST_LAYOUT, __1.LAYOUT, (this.attrs && this.attrs.className) ?
                    this.attrs.className : '')
            }
        };
    }
}
exports.ListLayout = ListLayout;

},{"../":121,"../../content/state/active":17,"../../util":147,"./wml/list":123}],123:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ListLayout = exports.ListLayoutItem = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class ListLayoutItem {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('li', { wml: { 'id': __context.values.content.wml.id }, 'id': __context.values.content.id, 'class': __context.values.content.className, 'onclick': __context.values.content.onclick }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.ListLayoutItem = ListLayoutItem;
;
class ListLayout {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('ul', { wml: { 'id': __context.values.content.wml.id }, 'id': __context.values.content.id, 'class': __context.values.content.className }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.ListLayout = ListLayout;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],124:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MainLayout = exports.MAIN_LAYOUT = void 0;
const views = require("./wml/main");
const util_1 = require("../../util");
const __1 = require("../");
///classNames:begin
exports.MAIN_LAYOUT = 'ww-main-layout';
/**
 * MainLayout provides a container for the main content of an application.
 */
class MainLayout extends __1.AbstractLayout {
    constructor() {
        super(...arguments);
        this.view = new views.Main(this);
        this.values = {
            content: {
                wml: {
                    id: 'main'
                },
                id: (this.attrs && this.attrs) ? this.attrs.id : '',
                className: (0, util_1.concat)(exports.MAIN_LAYOUT, __1.LAYOUT, (this.attrs && this.attrs) ?
                    this.attrs.className : '')
            }
        };
    }
}
exports.MainLayout = MainLayout;

},{"../":121,"../../util":147,"./wml/main":125}],125:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { wml: { 'id': __context.values.content.wml.id }, 'id': __context.values.content.id, 'class': __context.values.content.className }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],126:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MeterBar = exports.Meter = exports.METER_BAR = exports.METER = void 0;
const views = require("./wml/meter");
const wml_1 = require("@quenk/wml");
const util_1 = require("../../util");
const __1 = require("../../");
///classNames:begin
exports.METER = 'ww-meter';
exports.METER_BAR = 'ww-meter__bar';
/**
 * Meter
 */
class Meter extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new views.Meter(this);
        this.values = {
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.METER, (0, __1.getClassName)(this.attrs))
        };
    }
}
exports.Meter = Meter;
/**
 * MeterBar
 */
class MeterBar extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new views.MeterBar(this);
        this.values = {
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.METER_BAR, (0, __1.getClassName)(this.attrs)),
            value: (this.attrs && this.attrs.value) ?
                this.attrs.value : 0,
            color: (this.attrs && this.attrs.color) ?
                this.attrs.color : '',
            style: () => {
                let list = [];
                if (this.values.color)
                    list.push(`background-color:${this.values.color}`);
                if (this.values.value)
                    list.push(`width:${this.values.value}%`);
                return list.join(';');
            }
        };
    }
    /**
     * setValue sets the value of the MeterBar.
     */
    setValue(value) {
        this.values.value = value;
        this.view.invalidate();
        return this;
    }
    /**
     * increase the value by the specified amount.
     */
    increase(value) {
        this.values.value = this.values.value + value;
        this.view.invalidate();
        return this;
    }
    /**
     * decrease the value by the specified amount.
     */
    decrease(value) {
        this.values.value = this.values.value - value;
        this.view.invalidate();
        return this;
    }
    /**
     * setColor of the MeterBar.
     */
    setColor(color) {
        this.values.color = color;
        this.view.invalidate();
        return this;
    }
}
exports.MeterBar = MeterBar;

},{"../../":108,"../../util":147,"./wml/meter":127,"@quenk/wml":157}],127:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MeterBar = exports.Meter = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Meter {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { 'id': __context.values.id, 'class': __context.values.className }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Meter = Meter;
;
class MeterBar {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { 'id': __context.values.id, 'class': __context.values.className, 'style': __context.values.style() }, []);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.MeterBar = MeterBar;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],128:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PanelFooter = exports.PanelBody = exports.PanelHeader = exports.Panel = exports.PANEL_FOOTER = exports.PANEL_BODY = exports.PANEL_HEADER = exports.PANEL = void 0;
const style = require("../../content/style");
const views = require("./wml/panel");
const util_1 = require("../../util");
const __1 = require("..");
///classNames:begin
/**
 * PANEL wrapper class.
 */
exports.PANEL = 'ww-panel';
/**
 * PANEL_HEADER class name.
 */
exports.PANEL_HEADER = 'ww-panel__header';
/**
 * PANEL_BODY class name.
 */
exports.PANEL_BODY = 'ww-panel__body';
/**
 * PANEL_FOOTER class name.
 */
exports.PANEL_FOOTER = 'ww-panel__footer';
/**
 * Panel provides a rectangular container for visually seperating
 * content by context.
 */
class Panel extends __1.AbstractLayout {
    constructor() {
        super(...arguments);
        this.view = new views.Panel(this);
        /**
         * values
         */
        this.values = {
            /**
             * root values.
             */
            content: {
                id: this.attrs && this.attrs.id,
                wml: {
                    id: 'panel',
                },
                className: (0, util_1.concat)(exports.PANEL, __1.LAYOUT, (this.attrs && this.attrs.style) ?
                    `-${this.attrs.style}` : style.DEFAULT, this.attrs && this.attrs.className ?
                    this.attrs.className : '')
            }
        };
    }
}
exports.Panel = Panel;
/**
 * PanelHeader
 */
class PanelHeader extends __1.AbstractLayout {
    constructor() {
        super(...arguments);
        this.view = new views.PanelHeader(this);
        /**
         * values
         */
        this.values = {
            content: {
                wml: {
                    id: 'header'
                },
                id: this.attrs && this.attrs.id,
                className: (0, util_1.concat)(exports.PANEL_HEADER, __1.LAYOUT, this.attrs && this.attrs.className ?
                    this.attrs.className : '')
            }
        };
    }
}
exports.PanelHeader = PanelHeader;
/**
 * PanelBody
 */
class PanelBody extends __1.AbstractLayout {
    constructor() {
        super(...arguments);
        this.view = new views.PanelBody(this);
        /**
         * values
         */
        this.values = {
            content: {
                wml: {
                    id: 'body'
                },
                id: this.attrs && this.attrs.id,
                className: (0, util_1.concat)(exports.PANEL_BODY, __1.LAYOUT, this.attrs && this.attrs.className ?
                    this.attrs.className : '')
            }
        };
    }
}
exports.PanelBody = PanelBody;
/**
 * PanelFooter
 */
class PanelFooter extends __1.AbstractLayout {
    constructor() {
        super(...arguments);
        this.view = new views.PanelFooter(this);
        /**
         * values
         */
        this.values = {
            content: {
                wml: {
                    id: 'footer'
                },
                id: this.attrs && this.attrs.id,
                className: (0, util_1.concat)(exports.PANEL_FOOTER, __1.LAYOUT, this.attrs && this.attrs.className ?
                    this.attrs.className : '')
            }
        };
    }
}
exports.PanelFooter = PanelFooter;

},{"..":121,"../../content/style":20,"../../util":147,"./wml/panel":129}],129:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PanelFooter = exports.PanelBody = exports.PanelHeader = exports.Panel = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Panel {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { wml: { 'id': __context.values.content.id }, 'class': __context.values.content.className }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Panel = Panel;
;
class PanelHeader {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { wml: { 'id': __context.values.content.id }, 'class': __context.values.content.className }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.PanelHeader = PanelHeader;
;
class PanelBody {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { wml: { 'id': __context.values.content.id }, 'class': __context.values.content.className }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.PanelBody = PanelBody;
;
class PanelFooter {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { wml: { 'id': __context.values.content.id }, 'class': __context.values.content.className }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.PanelFooter = PanelFooter;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],130:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TabLayout = exports.TAB_LAYOUT = void 0;
const views = require("./wml/tab");
const wml_1 = require("@quenk/wml");
const dom_1 = require("@quenk/wml/lib/dom");
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const util_1 = require("../../util");
const __1 = require("../../");
const __2 = require("../");
///classNames:begin
exports.TAB_LAYOUT = 'ww-tab-layout';
/**
 * TabLayout provides a layout whose displayed content can be changed via tabs.
 *
 * ----------------------------------------------------------------------------
 * |                                                                          |
 * | Tab1  |  Tab2  | Tab2                                                    |
 * |                                                                          |
 * ----------------------------------------------------------------------------
 * |                                                                          |
 * |                                                                          |
 * |                             <Content>                                    |
 * |                                                                          |
 * |                                                                          |
 * |                                                                          |
 * |                                                                          |
 * |__________________________________________________________________________|
 */
class TabLayout extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new views.Main(this);
        this.values = {
            root: {
                id: (0, __1.getId)(this.attrs),
                className: (0, util_1.concat)(exports.TAB_LAYOUT, __2.LAYOUT, (0, __1.getClassName)(this.attrs)),
                content: () => {
                    if ((this.attrs && this.attrs.active)) {
                        let maybeActive = (0, maybe_1.fromNullable)(this.values.tabs.data[this.attrs.active]);
                        if (maybeActive.isJust())
                            return maybeActive
                                .get()
                                .contentFun(this)(this.view);
                    }
                    return this.children;
                }
            },
            tabs: {
                current: (this.attrs && this.attrs.active) ?
                    this.attrs.active : '',
                data: (this.attrs && this.attrs.tabs) ?
                    this.attrs.tabs : {},
                content: (t) => {
                    if (t.tabFun)
                        return t.tabFun(this)(this.view);
                    if (t.text)
                        return [(0, dom_1.text)(t.text)];
                    return [];
                },
                onClick: (e) => {
                    if (this.values.tabs.current !== e.name)
                        this.values.tabs.current = e.name;
                    let tab = (0, maybe_1.fromNullable)(this.values.tabs.data[e.name]).get();
                    this.values.root.content = () => tab.contentFun(this)(this.view);
                    this.view.invalidate();
                }
            }
        };
    }
    setContent(c) {
        this.values.root.content = () => c;
        this.view.invalidate();
        return this;
    }
    removeContent() {
        this.values.root.content = () => [];
        this.view.invalidate();
        return this;
    }
}
exports.TabLayout = TabLayout;

},{"../":121,"../../":108,"../../util":147,"./wml/tab":131,"@quenk/noni/lib/data/maybe":151,"@quenk/wml":157,"@quenk/wml/lib/dom":156}],131:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const tab_bar_1 = require("../../../control/tab-bar");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { 'id': __context.values.root.id, 'class': __context.values.root.className }, [
                __this.widget(new tab_bar_1.TabBar({}, [
                    ...__forOf(__context.values.tabs.data, (tab, name, _$$all) => ([
                        __this.widget(new tab_bar_1.Tab({ 'name': name, 'active': (__context.values.tabs.current === name), 'onClick': __context.values.tabs.onClick }, [
                            ...(__context.values.tabs.content(tab))
                        ]), { 'name': name, 'active': (__context.values.tabs.current === name), 'onClick': __context.values.tabs.onClick })
                    ]), () => ([]))
                ]), {}),
                ...(__context.values.root.content())
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../control/tab-bar":79,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],132:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TableLayout = exports.TableWindow = exports.TableCell = exports.TableHeading = exports.TableRow = exports.TableFooter = exports.TableBody = exports.TableHeader = exports.HOVERABLE = exports.ALTERNATE = exports.COMPACT = exports.BORDERED = exports.TABLE_WINDOW = exports.TABLE_LAYOUT = exports.TABLE_CELL = exports.TABLE_HEADING = exports.TABLE_ROW = exports.TABLE_FOOTER = exports.TABLE_BODY = exports.TABLE_HEADER = void 0;
const views = require("./wml/table");
const wml_1 = require("@quenk/wml");
const util_1 = require("../../util");
const __1 = require("../../");
///classNames:begin
exports.TABLE_HEADER = 'ww-table-layout__header';
exports.TABLE_BODY = 'ww-table-layout__body';
exports.TABLE_FOOTER = 'ww-table-layout__footer';
exports.TABLE_ROW = 'ww-table-layout__row';
exports.TABLE_HEADING = 'ww-table-layout _heading';
exports.TABLE_CELL = 'ww-table-layout__cell';
exports.TABLE_LAYOUT = 'ww-table-layout';
exports.TABLE_WINDOW = 'ww-table-window';
exports.BORDERED = '-bordered';
exports.COMPACT = '-compact';
exports.ALTERNATE = '-alternate';
exports.HOVERABLE = '-hoverable';
/**
 * TableHeader (<thead>)
 */
class TableHeader extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new views.TableHeader(this);
        this.values = {
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.TABLE_HEADER, (0, __1.getClassName)(this.attrs))
        };
    }
}
exports.TableHeader = TableHeader;
/**
 * TableBody
 */
class TableBody extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new views.TableBody(this);
        this.values = {
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.TABLE_BODY, (0, __1.getClassName)(this.attrs))
        };
    }
}
exports.TableBody = TableBody;
/**
 * TableFooter
 */
class TableFooter extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new views.TableFooter(this);
        this.values = {
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.TABLE_FOOTER, (0, __1.getClassName)(this.attrs))
        };
    }
}
exports.TableFooter = TableFooter;
/**
 * TableRow
 */
class TableRow extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new views.TableRow(this);
        this.values = {
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.TABLE_ROW, (0, __1.getClassName)(this.attrs)),
            onclick: (this.attrs && this.attrs.onclick) ?
                this.attrs.onclick : undefined
        };
    }
}
exports.TableRow = TableRow;
/**
 * TableHeading
 */
class TableHeading extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new views.TableHeading(this);
        this.values = {
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.TABLE_HEADING, (0, __1.getClassName)(this.attrs)),
            onclick: (this.attrs && this.attrs.onclick) ?
                this.attrs.onclick : undefined
        };
    }
}
exports.TableHeading = TableHeading;
/**
 * TableCell
 */
class TableCell extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new views.TableCell(this);
        this.values = {
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.TABLE_CELL, (0, __1.getClassName)(this.attrs)),
            colspan: (this.attrs && this.attrs.colspan) ?
                this.attrs.colspan : 1,
            rowspan: (this.attrs && this.attrs.rowspan) ?
                this.attrs.rowspan : 1,
            onclick: (this.attrs && this.attrs.onclick) ?
                this.attrs.onclick : undefined
        };
    }
}
exports.TableCell = TableCell;
/**
 * TableWindow allows a TableLayout to be scrolled on smaller screens.
 */
class TableWindow extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new views.TableWindow(this);
        this.values = {
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.TABLE_WINDOW, (0, __1.getClassName)(this.attrs))
        };
    }
}
exports.TableWindow = TableWindow;
/**
 * TableLayout provides a <table> based layout.
 */
class TableLayout extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new views.TableLayout(this);
        this.values = {
            wml: {
                id: 'table'
            },
            id: (0, __1.getId)(this.attrs),
            className: (0, util_1.concat)(exports.TABLE_LAYOUT, (0, __1.getClassName)(this.attrs), (this.attrs && this.attrs.alternate) ? exports.ALTERNATE : '', (this.attrs && this.attrs.bordered) ? exports.BORDERED : '', (this.attrs && this.attrs.compact) ? exports.COMPACT : '', (this.attrs && this.attrs.hoverable) ? exports.HOVERABLE : ''),
        };
    }
}
exports.TableLayout = TableLayout;

},{"../../":108,"../../util":147,"./wml/table":133,"@quenk/wml":157}],133:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TableLayout = exports.TableWindow = exports.TableCell = exports.TableHeading = exports.TableRow = exports.TableFooter = exports.TableBody = exports.TableHeader = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class TableHeader {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('thead', { 'id': __context.values.id, 'class': __context.values.className }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.TableHeader = TableHeader;
;
class TableBody {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('tbody', { 'id': __context.values.id, 'class': __context.values.className }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.TableBody = TableBody;
;
class TableFooter {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('tfoot', { 'id': __context.values.id, 'class': __context.values.className }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.TableFooter = TableFooter;
;
class TableRow {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('tr', { 'id': __context.values.id, 'class': __context.values.className, 'onclick': __context.values.onclick }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.TableRow = TableRow;
;
class TableHeading {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('th', { 'id': __context.values.id, 'class': __context.values.className, 'onclick': __context.values.onclick }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.TableHeading = TableHeading;
;
class TableCell {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('td', { 'id': __context.values.id, 'class': __context.values.className, 'colspan': String(__context.values.colspan), 'rowspan': String(__context.values.rowspan), 'onclick': __context.values.onclick }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.TableCell = TableCell;
;
class TableWindow {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { 'id': __context.values.id, 'class': __context.values.className }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.TableWindow = TableWindow;
;
class TableLayout {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('table', { 'id': __context.values.id, 'class': __context.values.className }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.TableLayout = TableLayout;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],134:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Well = exports.WELL = void 0;
const util_1 = require("../../util");
const __1 = require("..");
const well_1 = require("./wml/well");
///classNames:begin
exports.WELL = 'ww-well';
/**
 * Well provides a rectangular container for visually seperating
 * content by context.
 */
class Well extends __1.AbstractLayout {
    constructor() {
        super(...arguments);
        this.view = new well_1.WellView(this);
        this.values = {
            /**
             * root values.
             */
            content: {
                id: this.attrs && this.attrs.id,
                wml: {
                    id: 'well',
                },
                className: (0, util_1.concat)(exports.WELL, __1.LAYOUT, this.attrs && this.attrs.className ?
                    this.attrs.className : '')
            }
        };
    }
}
exports.Well = Well;

},{"..":121,"../../util":147,"./wml/well":135}],135:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WellView = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class WellView {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { wml: { 'id': __context.values.content.id }, 'class': __context.values.content.className }, [
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.WellView = WellView;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],136:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Drawer = exports.DRAWER_CONTENT = exports.DRAWER = void 0;
const hidden_1 = require("../../content/state/hidden");
const layout_1 = require("../../layout");
const util_1 = require("../../util");
const drawer_1 = require("./wml/drawer");
///classNames:begin
exports.DRAWER = 'ww-drawer';
exports.DRAWER_CONTENT = 'ww-drawer__content';
/**
 * Drawer provides a widget for displaying navigation and other sidebar content.
 *
 * It's api allows for toggling between hidden and shown states as well as
 * querying the current state.
 *
 * This widget's style intentionally gives it a high z-index so that it appears
 * in-front  of other content. Adjust the respective style variables to change.
 */
class Drawer extends layout_1.AbstractLayout {
    constructor() {
        super(...arguments);
        this.view = new drawer_1.Main(this);
        this.values = {
            root: {
                id: this.attrs && this.attrs.id,
                className: (0, util_1.concat)(exports.DRAWER, (this.attrs && this.attrs.hidden) ?
                    hidden_1.HIDDEN : ''),
                wml: {
                    id: 'root'
                }
            },
            content: {
                wml: {
                    id: 'content'
                },
                className: exports.DRAWER_CONTENT,
                value: (this.attrs && this.attrs.content) ?
                    this.attrs.content : this.children
            }
        };
    }
    isHidden() {
        return (0, hidden_1.isHidden)(this.view, this.values.root.wml.id);
    }
    hide() {
        (0, hidden_1.hide)(this.view, this.values.root.wml.id);
        return this;
    }
    show() {
        (0, hidden_1.show)(this.view, this.values.root.wml.id);
        return this;
    }
    toggle() {
        (0, hidden_1.toggle)(this.view, this.values.root.wml.id);
        return this;
    }
}
exports.Drawer = Drawer;

},{"../../content/state/hidden":19,"../../layout":121,"../../util":147,"./wml/drawer":137}],137:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('div', { wml: { 'id': __context.values.root.wml.id }, 'id': __context.values.root.id, 'class': __context.values.root.className }, [
                __this.node('div', { wml: { 'id': __context.values.content.wml.id }, 'class': __context.values.content.className }, [
                    ...(__context.values.content.value)
                ])
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],138:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MenuHeader = exports.MENU_HEADER = void 0;
const wml = require("@quenk/wml");
const document = require("@quenk/wml/lib/dom");
const views = require("./wml/header");
const util_1 = require("../../util");
///classNames:begin
/**
 * MENU_HEADER
 */
exports.MENU_HEADER = 'ww-menu-header';
/**
 * MenuHeader can be used to display non-clickable heading text in a nav menu.
 */
class MenuHeader extends wml.Component {
    constructor() {
        super(...arguments);
        this.view = new views.Main(this);
        this.values = {
            span: {
                id: (this.attrs && this.attrs.id) ? this.attrs.id : '',
                className: (0, util_1.concat)(exports.MENU_HEADER, (this.attrs && this.attrs.className) ?
                    this.attrs.className : '')
            },
            text: (this.attrs && this.attrs.text) ?
                [document.createTextNode(this.attrs.text)] : this.children
        };
    }
}
exports.MenuHeader = MenuHeader;

},{"../../util":147,"./wml/header":139,"@quenk/wml":157,"@quenk/wml/lib/dom":156}],139:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('span', { 'id': __context.values.span.id, 'class': __context.values.span.className }, [
                ...(__context.values.text)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],140:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Item = exports.Divider = exports.ItemClickedEvent = exports.DIVIDER = exports.ITEM = void 0;
const wml = require("@quenk/wml");
const document = require("@quenk/wml/lib/dom");
const views = require("./wml/item");
const active_1 = require("../../content/state/active");
const active_2 = require("../../content/state/active");
const util_1 = require("../../util");
///classNames:begin
exports.ITEM = 'ww-menu-item';
exports.DIVIDER = 'ww-menu-divider';
/**
 * ItemClickedEvent is fired when the user clicks on an item in
 * a nav list.
 */
class ItemClickedEvent {
    constructor(name) {
        this.name = name;
    }
}
exports.ItemClickedEvent = ItemClickedEvent;
/**
 * Divider is used to add a horizontal line in place of an item to siginify a
 * new section.
 */
class Divider extends wml.Component {
    constructor() {
        super(...arguments);
        this.view = new views.DividerView(this);
        this.values = {
            className: exports.DIVIDER
        };
    }
}
exports.Divider = Divider;
/**
 * Item wraps content in a navigation list.
 *
 * Items should not have any siblings that are not other Items.
 */
class Item extends wml.Component {
    constructor() {
        super(...arguments);
        this.view = new views.Main(this);
        this.values = {
            root: {
                wml: {
                    id: 'root'
                },
                id: (this.attrs && this.attrs.id) ? this.attrs.id : '',
                className: (0, util_1.concat)(exports.ITEM, (this.attrs && this.attrs.active) ? active_2.ACTIVE : ''),
                content: {
                    render: () => {
                        if (this.attrs && this.attrs.text)
                            return [document.createTextNode(this.attrs.text)];
                        else
                            return this.children;
                    }
                }
            }
        };
    }
    activate() {
        (0, active_1.activate)(this.view, this.values.root.wml.id);
        return this;
    }
    deactivate() {
        (0, active_1.deactivate)(this.view, this.values.root.wml.id);
        return this;
    }
}
exports.Item = Item;

},{"../../content/state/active":17,"../../util":147,"./wml/item":141,"@quenk/wml":157,"@quenk/wml/lib/dom":156}],141:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = exports.DividerView = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class DividerView {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('li', { 'class': __context.values.className }, []);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.DividerView = DividerView;
;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('li', { wml: { 'id': __context.values.root.wml.id }, 'id': __context.values.root.id, 'class': __context.values.root.className }, [
                ...(__context.values.root.content.render())
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],142:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Menu = exports.HeaderItem = exports.CONTENT_MODE = exports.NAV_MODE = exports.MENU_HEADER_ITEM = exports.MENU = void 0;
const hidden = require("../../content/state/hidden");
const headerViews = require("./wml/header");
const wml_1 = require("@quenk/wml");
const dom_1 = require("@quenk/wml/lib/dom");
const util_1 = require("../../util");
const orientation_1 = require("../../content/orientation");
const __1 = require("../../");
const menu_1 = require("./wml/menu");
///classNames:begin
exports.MENU = 'ww-menu';
exports.MENU_HEADER_ITEM = 'ww-menu__header-item';
///classNames:end
exports.NAV_MODE = 'nav';
exports.CONTENT_MODE = 'content';
/**
 * HeaderItem
 */
class HeaderItem extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new headerViews.Main(this);
        this.values = {
            root: {
                className: (0, util_1.concat)(exports.MENU_HEADER_ITEM, (0, __1.getClassName)(this.attrs)),
                content: (this.attrs && this.attrs.text) ?
                    [(0, dom_1.text)(this.attrs.text)] : this.children
            }
        };
    }
}
exports.HeaderItem = HeaderItem;
/**
 * Menu provides a DOM container for rendering
 * a dropdown style menu.
 */
class Menu extends wml_1.Component {
    constructor() {
        super(...arguments);
        this.view = new menu_1.Main(this);
        this.values = {
            root: {
                wml: {
                    id: 'root'
                },
                id: (0, __1.getId)(this.attrs),
                className: (0, util_1.concat)(exports.MENU, (0, __1.getClassName)(this.attrs), (this.attrs && this.attrs.hidden) ? hidden.HIDDEN : '', (this.attrs && this.attrs.block) ? orientation_1.BLOCK : '')
            },
            menu: {
                id: 'menu'
            },
            content: () => this.children
        };
    }
    isHidden() {
        return hidden.isHidden(this.view, this.values.root.wml.id);
    }
    hide() {
        hidden.hide(this.view, this.values.root.wml.id);
        return this;
    }
    show() {
        hidden.show(this.view, this.values.root.wml.id);
        return this;
    }
    toggle() {
        hidden.toggle(this.view, this.values.root.wml.id);
        return this;
    }
    setContent(content) {
        this.values.content = () => content;
        this.view.invalidate();
        this.show();
        return this;
    }
}
exports.Menu = Menu;

},{"../../":108,"../../content/orientation":13,"../../content/state/hidden":19,"../../util":147,"./wml/header":143,"./wml/menu":144,"@quenk/wml":157,"@quenk/wml/lib/dom":156}],143:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('li', { 'class': __context.values.root.className }, [
                ...(__context.values.root.content)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],144:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('ul', { wml: { 'id': __context.values.root.wml.id }, 'id': __context.values.root.id, 'class': __context.values.root.className }, [
                ...(__context.values.content())
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],145:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NavMenu = exports.NAV_MENU = exports.Link = exports.Item = void 0;
const wml = require("@quenk/wml");
const util = require("../../util");
const record_1 = require("@quenk/noni/lib/data/record");
const type_1 = require("@quenk/noni/lib/data/type");
const orientation_1 = require("../../content/orientation");
const view_1 = require("./view");
var item_1 = require("../item");
Object.defineProperty(exports, "Item", { enumerable: true, get: function () { return item_1.Item; } });
var link_1 = require("../../content/link");
Object.defineProperty(exports, "Link", { enumerable: true, get: function () { return link_1.Link; } });
///classNames:begin
exports.NAV_MENU = 'ww-nav-menu';
/**
 * NavMenu groups one or more navigational items together to form a menu.
 *
 * Items may be declared directly as child elements of this widgets or specified
 * via attributes for dynamic creation.
 */
class NavMenu extends wml.Component {
    constructor() {
        super(...arguments);
        this.view = new view_1.NavMenuView(this);
        this.values = {
            id: this.attrs.id,
            className: util.concat(exports.NAV_MENU, this.attrs.className, this.attrs.vertical ? orientation_1.VERTICAL : ''),
            items: expand(this.attrs.items)
        };
    }
}
exports.NavMenu = NavMenu;
const expand = (spec = []) => {
    let list = Array.isArray(spec) ? spec : [spec];
    return list.reduce((expanded, item) => {
        if ((0, type_1.isString)(item)) {
            return [...expanded, { type: 'header', text: item }];
        }
        else if ((0, type_1.isObject)(item)) {
            return [
                ...expanded,
                ...(0, record_1.mapTo)(item, (val, text) => {
                    if ((0, type_1.isFunction)(val))
                        return { type: 'link', name: text, text, onClick: val };
                    else if ((0, type_1.isObject)(val))
                        return (0, record_1.merge)({ type: 'link', name: text, text }, val);
                    else
                        return {
                            type: 'link',
                            name: text,
                            text,
                            href: String(val)
                        };
                })
            ];
        }
        else if (Array.isArray(item)) {
            return [...expanded, { type: 'menu', items: item }];
        }
        else {
            return expanded;
        }
    }, []);
};

},{"../../content/link":7,"../../content/orientation":13,"../../util":147,"../item":140,"./view":146,"@quenk/noni/lib/data/record":152,"@quenk/noni/lib/data/type":154,"@quenk/wml":157}],146:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NavMenuView = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const item_1 = require("../item");
;
const header_1 = require("../header");
;
const link_1 = require("../../content/link");
;
const _1 = require(".");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class NavMenuView {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('ul', { 'id': __context.values.id, 'class': __context.values.className }, [
                ...__forIn(__context.values.items, (item, _$$i, _$$all) => ([
                    __this.widget(new item_1.Item({}, [
                        ...(((item['type'] === 'header')) ?
                            (() => ([
                                __this.widget(new header_1.MenuHeader(item, []), item)
                            ]))() :
                            (() => ([...(((item['type'] === 'link')) ?
                                    (() => ([
                                        __this.widget(new link_1.Link(item, []), item)
                                    ]))() :
                                    (() => ([...(((item['type'] === 'menu')) ?
                                            (() => ([
                                                __this.widget(new _1.NavMenu(item, []), item)
                                            ]))() :
                                            (() => ([]))())]))())]))())
                    ]), {})
                ]), () => ([])),
                ...(__context.children)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.NavMenuView = NavMenuView;

},{".":145,"../../content/link":7,"../header":138,"../item":140,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],147:[function(require,module,exports){
"use strict";
/**
 * This module provides utility functions and constants used
 * through out the wml-widgets module.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.debounce = exports.replaceContent = exports.noop = exports.concat = exports.combine = exports.warnMissing = exports.getById = void 0;
/**
 * getById retreives an WMLElement from a view by its id.
 *
 * If the WMLElement is not found a warning is logged to console.
 */
const getById = (view, id) => {
    let m = view.findById(id);
    if (m.isNothing()) {
        (0, exports.warnMissing)(view, id);
    }
    return m;
};
exports.getById = getById;
/**
 * warn via console that an element is missing.
 */
const warnMissing = (view, id) => {
    console.warn('The view ', view, ` does not have an id "${id}"!`);
};
exports.warnMissing = warnMissing;
/**
 * combine the members of an array into one string.
 */
const combine = (str, joiner = ' ') => str.filter(s => ((s != null) || s != '')).join(joiner);
exports.combine = combine;
/**
 * concat joins various strings together to form an html class attribute value.
 *
 * Removes empty strings, null and undefined values.
 */
const concat = (...str) => str.filter(s => ((s == null) || (s == '')) ? false : true)
    .map(s => s.trim()).join(' ');
exports.concat = concat;
/**
 * noop
 */
const noop = () => { };
exports.noop = noop;
/**
 * replaceContent
 */
const replaceContent = (r, node) => {
    while (node.lastChild)
        node.removeChild(node.lastChild);
    node.appendChild(r.render());
};
exports.replaceContent = replaceContent;
/**
 * debounce a function so that it is only called once after
 * a period of time.
 */
const debounce = (f, delay) => {
    let timer = -1;
    return delay === 0 ? f : (a) => {
        if (timer === -1) {
            timer = window.setTimeout(() => f(a), delay);
        }
        else {
            clearTimeout(timer);
            timer = window.setTimeout(() => f(a), delay);
        }
    };
};
exports.debounce = debounce;

},{}],148:[function(require,module,exports){
(function (process){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.throttle = exports.debounce = exports.tick = void 0;
/**
 * tick runs a function in the "next tick" using process.nextTick in node
 * or setTimeout(f, 0) elsewhere.
 */
const tick = (f) => (typeof window == 'undefined') ?
    setTimeout(f, 0) :
    process.nextTick(f);
exports.tick = tick;
/**
 * debounce delays the application of a function until the specified time
 * has passed.
 *
 * If multiple attempts to apply the function have occured, then each attempt
 * will restart the delay process. The function will only ever be applied once
 * after the delay, using the value of the final attempt for application.
 */
const debounce = (f, delay) => {
    let id = -1;
    return (a) => {
        if (id === -1) {
            id = setTimeout(() => f(a), delay);
        }
        else {
            clearTimeout(id);
            id = setTimeout(() => f(a), delay);
        }
    };
};
exports.debounce = debounce;
/**
 * throttle limits the application of a function to occur only one within the
 * specified duration.
 *
 * The first application will execute immediately subsequent applications
 * will be ignored until the duration has passed.
 */
const throttle = (f, duration) => {
    let wait = false;
    return (a) => {
        if (wait === false) {
            f(a);
            wait = true;
            setTimeout(() => wait = false, duration);
        }
    };
};
exports.throttle = throttle;

}).call(this)}).call(this,require('_process'))

},{"_process":159}],149:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.find = exports.compact = exports.flatten = exports.combine = exports.make = exports.removeAt = exports.remove = exports.dedupe = exports.distribute = exports.group = exports.partition = exports.concat = exports.flatMap = exports.map = exports.contains = exports.empty = exports.tail = exports.head = void 0;
/**
 * The array module provides helper functions
 * for working with JS arrays.
 */
const record_1 = require("../record");
const math_1 = require("../../math");
const maybe_1 = require("../maybe");
/**
 * head returns the item at index 0 of an array
 */
const head = (list) => list[0];
exports.head = head;
/**
 * tail returns the last item in an array
 */
const tail = (list) => list[list.length - 1];
exports.tail = tail;
/**
 * empty indicates whether an array is empty or not.
 */
const empty = (list) => (list.length === 0);
exports.empty = empty;
/**
 * contains indicates whether an element exists in an array.
 */
const contains = (list, a) => (list.indexOf(a) > -1);
exports.contains = contains;
/**
 * map is a curried version of the Array#map method.
 */
const map = (list) => (f) => list.map(f);
exports.map = map;
/**
 * flatMap allows a function to produce a combined set of arrays from a map
 * operation over each member of a list.
 */
const flatMap = (list, f) => list.reduce((p, c, i) => p.concat(f(c, i, list)), []);
exports.flatMap = flatMap;
/**
 * concat concatenates elements to the end of an array without flattening
 * if any of the elements are an array.
 *
 * This function also ignores null and undefined.
 */
const concat = (list, ...items) => [...list, ...items.filter(item => item != null)];
exports.concat = concat;
/**
 * partition an array into two using a partitioning function.
 *
 * The first array contains values that return true and the second false.
 */
const partition = (list, f) => (0, exports.empty)(list) ?
    [[], []] :
    list.reduce(([yes, no], c, i) => (f(c, i, list) ?
        [(0, exports.concat)(yes, c), no] :
        [yes, (0, exports.concat)(no, c)]), [[], []]);
exports.partition = partition;
/**
 * group the elements of an array into a Record where each property
 * is an array of elements assigned to it's property name.
 */
const group = (list, f) => list.reduce((p, c, i) => {
    let g = f(c, i, list);
    return (0, record_1.merge)(p, {
        [g]: Array.isArray(p[g]) ?
            (0, exports.concat)(p[g], c) : [c]
    });
}, {});
exports.group = group;
/**
 * distribute breaks an array into an array of equally (approximate) sized
 * smaller arrays.
 */
const distribute = (list, size) => {
    let r = list.reduce((p, c, i) => (0, math_1.isMultipleOf)(size, i + 1) ?
        [(0, exports.concat)(p[0], (0, exports.concat)(p[1], c)), []] :
        [p[0], (0, exports.concat)(p[1], c)], [[], []]);
    return (r[1].length === 0) ? r[0] : (0, exports.concat)(r[0], r[1]);
};
exports.distribute = distribute;
/**
 * dedupe an array by filtering out elements
 * that appear twice.
 */
const dedupe = (list) => list.filter((e, i, l) => l.indexOf(e) === i);
exports.dedupe = dedupe;
/**
 * remove an element from an array returning a new copy with the element
 * removed.
 */
const remove = (list, target) => {
    let idx = list.indexOf(target);
    if (idx === -1) {
        return list.slice();
    }
    else {
        let a = list.slice();
        a.splice(idx, 1);
        return a;
    }
};
exports.remove = remove;
/**
 * removeAt removes an element at the specified index returning a copy
 * of the original array with the element removed.
 */
const removeAt = (list, idx) => {
    if ((list.length > idx) && (idx > -1)) {
        let a = list.slice();
        a.splice(idx, 1);
        return a;
    }
    else {
        return list.slice();
    }
};
exports.removeAt = removeAt;
/**
 * make an array of elements of a given size using a function to provide
 * each element.
 *
 * The function receives the index number for each step.
 */
const make = (size, f) => {
    let a = new Array(size);
    for (let i = 0; i < size; i++)
        a[i] = f(i);
    return a;
};
exports.make = make;
/**
 * combine a list of of lists into one list.
 */
const combine = (list) => list.reduce((p, c) => p.concat(c), []);
exports.combine = combine;
/**
 * flatten a list of items that may be multi-dimensional.
 *
 * This function may not be stack safe.
 */
const flatten = (list) => list.reduce((p, c) => p.concat(Array.isArray(c) ? (0, exports.flatten)(c) : c), []);
exports.flatten = flatten;
/**
 * compact removes any occurences of null or undefined in the list.
 */
const compact = (list) => list.filter(v => (v != null));
exports.compact = compact;
/**
 * find searches an array for the first element that passes the test implemented
 * in the provided [[FindFund]].
 */
const find = (list, cb) => {
    for (let i = 0; i < list.length; i++)
        if (cb(list[i]))
            return (0, maybe_1.just)(list[i]);
    return (0, maybe_1.nothing)();
};
exports.find = find;

},{"../../math":155,"../maybe":151,"../record":152}],150:[function(require,module,exports){
"use strict";
/**
 * Useful functions for sorting data in an array.
 *
 * The functions are expected to be passed to Array#sort.
 * Defaults to ascending order unless specified otherwise.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.natural = exports.number = exports.string = exports.date = void 0;
/**
 * date sorts two strings representing dates.
 *
 * The dates are passed to the date constructor.
 */
const date = (a, b) => {
    let na = new Date(a).getTime();
    let nb = new Date(b).getTime();
    return na > nb ? -1 : na < nb ? 1 : 0;
};
exports.date = date;
/**
 * string sorts two strings by first lower casing them.
 */
const string = (a, b) => {
    let la = String(a).replace(/\s+/, '').toLowerCase();
    let lb = String(b).replace(/\s+/, '').toLowerCase();
    return (la > lb) ? -1 : (la < lb) ? 1 : 0;
};
exports.string = string;
/**
 * number sort
 */
const number = (a, b) => {
    let na = parseFloat(a);
    let nb = parseFloat(b);
    na = (isNaN(a)) ? -Infinity : a;
    nb = (isNaN(b)) ? -Infinity : b;
    return (na > nb) ? -1 : (na < nb) ? 1 : 0;
};
exports.number = number;
/**
 * natural sort impelmentation.
 */
const natural = (a = '', b = '') => {
    var reA = /[^a-zA-Z]/g;
    var reN = /[^0-9]/g;
    var aInt = parseInt(a, 10);
    var bInt = parseInt(b, 10);
    if (isNaN(aInt) && isNaN(bInt)) {
        var aA = String(a).replace(reA, '');
        var bA = String(b).replace(reA, '');
        if (aA === bA) {
            var aN = parseInt(String(a).replace(reN, ''), 10);
            var bN = parseInt(String(b).replace(reN, ''), 10);
            return aN === bN ? 0 : aN > bN ? -1 : 1;
        }
        else {
            return aA > bA ? -1 : 1;
        }
    }
    else if (isNaN(aInt)) { //A is not an Int
        return -1; //to make alphanumeric sort first return -1 here
    }
    else if (isNaN(bInt)) { //B is not an Int
        return 1; //to make alphanumeric sort first return 1 here
    }
    else {
        return aInt > bInt ? -1 : 1;
    }
};
exports.natural = natural;

},{}],151:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromNaN = exports.fromNumber = exports.fromBoolean = exports.fromString = exports.fromObject = exports.fromArray = exports.fromNullable = exports.just = exports.nothing = exports.of = exports.Just = exports.Nothing = void 0;
/**
 * Nothing represents the absence of a usable value.
 */
class Nothing {
    /**
     * map simply returns a Nothing<A>
     */
    map(_) {
        return new Nothing();
    }
    /**
     * ap allows for a function wrapped in a Just to apply
     * to value present in this Just.
     */
    ap(_) {
        return new Nothing();
    }
    /**
     * of wraps a value in a Just.
     */
    of(a) {
        return new Just(a);
    }
    /**
     * chain simply returns a Nothing<A>.
     */
    chain(_) {
        return new Nothing();
    }
    /**
     * alt will prefer whatever Maybe instance provided.
     */
    alt(a) {
        return a;
    }
    /**
     * empty provides a default Maybe.
     * Maybe.empty() = new Nothing()
     */
    empty() {
        return new Nothing();
    }
    /**
     * extend returns a Nothing<A>.
     */
    extend(_) {
        return new Nothing();
    }
    /**
     * eq returns true if compared to another Nothing instance.
     */
    eq(m) {
        return m instanceof Nothing;
    }
    /**
     * orJust converts a Nothing<A> to a Just
     * using the value from the provided function.
     */
    orJust(f) {
        return new Just(f());
    }
    /**
     * orElse allows an alternative Maybe value
     * to be provided since this one is Nothing<A>.
     */
    orElse(f) {
        return f();
    }
    isNothing() {
        return true;
    }
    isJust() {
        return false;
    }
    /**
     * get throws an error because there
     * is nothing here to get.
     */
    get() {
        throw new TypeError('Cannot get a value from Nothing!');
    }
}
exports.Nothing = Nothing;
/**
 * Just represents the presence of a usable value.
 */
class Just {
    constructor(value) {
        this.value = value;
    }
    /**
     * map over the value present in the Just.
     */
    map(f) {
        return new Just(f(this.value));
    }
    /**
     * ap allows for a function wrapped in a Just to apply
     * to value present in this Just.
     */
    ap(mb) {
        return mb.map(f => f(this.value));
    }
    /**
     * of wraps a value in a Just.
     */
    of(a) {
        return new Just(a);
    }
    /**
     * chain allows the sequencing of functions that return a Maybe.
     */
    chain(f) {
        return f(this.value);
    }
    /**
     * alt will prefer the first Just encountered (this).
     */
    alt(_) {
        return this;
    }
    /**
     * empty provides a default Maybe.
     * Maybe.empty() = new Nothing()
     */
    empty() {
        return new Nothing();
    }
    /**
     * extend allows sequencing of Maybes with
     * functions that unwrap into non Maybe types.
     */
    extend(f) {
        return new Just(f(this));
    }
    /**
     * eq tests the value of two Justs.
     */
    eq(m) {
        return ((m instanceof Just) && (m.value === this.value));
    }
    /**
     * orJust returns this Just.
     */
    orJust(_) {
        return this;
    }
    /**
     * orElse returns this Just
     */
    orElse(_) {
        return this;
    }
    isNothing() {
        return false;
    }
    isJust() {
        return true;
    }
    /**
     * get the value of this Just.
     */
    get() {
        return this.value;
    }
}
exports.Just = Just;
/**
 * of
 */
const of = (a) => new Just(a);
exports.of = of;
/**
 * nothing convenience constructor
 */
const nothing = () => new Nothing();
exports.nothing = nothing;
/**
 * just convenience constructor
 */
const just = (a) => new Just(a);
exports.just = just;
/**
 * fromNullable constructs a Maybe from a value that may be null.
 */
const fromNullable = (a) => a == null ?
    new Nothing() : new Just(a);
exports.fromNullable = fromNullable;
/**
 * fromArray checks an array to see if it's empty
 *
 * Returns [[Nothing]] if it is, [[Just]] otherwise.
 */
const fromArray = (a) => (a.length === 0) ? new Nothing() : new Just(a);
exports.fromArray = fromArray;
/**
 * fromObject uses Object.keys to turn see if an object
 * has any own properties.
 */
const fromObject = (o) => Object.keys(o).length === 0 ? new Nothing() : new Just(o);
exports.fromObject = fromObject;
/**
 * fromString constructs Nothing<A> if the string is empty or Just<A> otherwise.
 */
const fromString = (s) => (s === '') ? new Nothing() : new Just(s);
exports.fromString = fromString;
/**
 * fromBoolean constructs Nothing if b is false, Just<A> otherwise
 */
const fromBoolean = (b) => (b === false) ? new Nothing() : new Just(b);
exports.fromBoolean = fromBoolean;
/**
 * fromNumber constructs Nothing if n is 0 Just<A> otherwise.
 */
const fromNumber = (n) => (n === 0) ? new Nothing() : new Just(n);
exports.fromNumber = fromNumber;
/**
 * fromNaN constructs Nothing if a value is not a number or
 * Just<A> otherwise.
 */
const fromNaN = (n) => isNaN(n) ? new Nothing() : new Just(n);
exports.fromNaN = fromNaN;

},{}],152:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pickValue = exports.pickKey = exports.make = exports.rcompact = exports.compact = exports.isBadKey = exports.set = exports.every = exports.some = exports.empty = exports.count = exports.clone = exports.hasKey = exports.values = exports.group = exports.partition = exports.exclude = exports.rmerge5 = exports.rmerge4 = exports.rmerge3 = exports.rmerge = exports.merge5 = exports.merge4 = exports.merge3 = exports.merge = exports.filter = exports.reduce = exports.forEach = exports.mapTo = exports.map = exports.keys = exports.isRecord = exports.assign = exports.badKeys = void 0;
/**
 * The record module provides functions for treating ES objects as records.
 *
 * Some of the functions provided here are not type safe and may result in
 * runtime errors if not used carefully.
 */
const array_1 = require("../array");
const type_1 = require("../type");
const maybe_1 = require("../maybe");
/**
 * badKeys is a list of keys we don't want to copy around between objects.
 *
 * Mostly due to prototype pollution but who knows what other keys may become
 * a problem as the language matures.
 */
exports.badKeys = ['__proto__'];
/**
 * assign is an Object.assign polyfill.
 *
 * It is used internally and should probably not be used directly elsewhere.
 */
function assign(target, ..._varArgs) {
    let to = Object(target);
    for (let index = 1; index < arguments.length; index++) {
        let nextSource = arguments[index];
        if (nextSource != null)
            for (let nextKey in nextSource)
                // Avoid bugs when hasOwnProperty is shadowed
                if (Object.prototype.hasOwnProperty.call(nextSource, nextKey))
                    (0, exports.set)(to, nextKey, nextSource[nextKey]);
    }
    return to;
}
exports.assign = assign;
/**
 * isRecord tests whether a value is a record.
 *
 * To be a Record, a value must be an object and:
 * 1. must not be null
 * 2. must not be an Array
 * 2. must not be an instance of Date
 * 3. must not be an instance of RegExp
 */
const isRecord = (value) => (typeof value === 'object') &&
    (value != null) &&
    (!Array.isArray(value)) &&
    (!(value instanceof Date)) &&
    (!(value instanceof RegExp));
exports.isRecord = isRecord;
/**
 * keys is an Object.keys shortcut.
 */
const keys = (obj) => Object.keys(obj);
exports.keys = keys;
/**
 * map over a Record's properties producing a new record.
 *
 * The order of keys processed is not guaranteed.
 */
const map = (rec, f) => (0, exports.keys)(rec)
    .reduce((p, k) => (0, exports.merge)(p, (0, exports.set)({}, k, f(rec[k], k, rec))), {});
exports.map = map;
/**
 * mapTo an array the properties of the provided Record.
 *
 * The elements of the array are the result of applying the function provided
 * to each property. The order of elements is not guaranteed.
 */
const mapTo = (rec, f) => (0, exports.keys)(rec).map(k => f(rec[k], k, rec));
exports.mapTo = mapTo;
/**
 * forEach is similar to map only the result of each function call is not kept.
 *
 * The order of keys processed is not guaranteed.
 */
const forEach = (rec, f) => (0, exports.keys)(rec).forEach(k => f(rec[k], k, rec));
exports.forEach = forEach;
/**
 * reduce a Record's keys to a single value.
 *
 * The initial value (accum) must be supplied to avoid errors when
 * there are no properties on the Record. The order of keys processed is
 * not guaranteed.
 */
const reduce = (rec, accum, f) => (0, exports.keys)(rec).reduce((p, k) => f(p, rec[k], k), accum);
exports.reduce = reduce;
/**
 * filter the keys of a Record using a filter function.
 */
const filter = (rec, f) => (0, exports.keys)(rec)
    .reduce((p, k) => f(rec[k], k, rec) ?
    (0, exports.merge)(p, (0, exports.set)({}, k, rec[k])) : p, {});
exports.filter = filter;
/**
 * merge two objects (shallow) into one new object.
 *
 * The return value's type is the product of the two objects provided.
 */
const merge = (left, right) => assign({}, left, right);
exports.merge = merge;
/**
 * merge3
 */
const merge3 = (a, b, c) => assign({}, a, b, c);
exports.merge3 = merge3;
/**
 * merge4
 */
const merge4 = (a, b, c, d) => assign({}, a, b, c, d);
exports.merge4 = merge4;
/**
 * merge5
 */
const merge5 = (a, b, c, d, e) => assign({}, a, b, c, d, e);
exports.merge5 = merge5;
/**
 * rmerge merges 2 records recursively.
 *
 * This function may violate type safety.
 */
const rmerge = (left, right) => (0, exports.reduce)(right, left, deepMerge);
exports.rmerge = rmerge;
/**
 * rmerge3
 */
const rmerge3 = (r, s, t) => [s, t]
    .reduce((p, c) => (0, exports.reduce)(c, (p), deepMerge), r);
exports.rmerge3 = rmerge3;
/**
 * rmerge4
 */
const rmerge4 = (r, s, t, u) => [s, t, u]
    .reduce((p, c) => (0, exports.reduce)(c, (p), deepMerge), r);
exports.rmerge4 = rmerge4;
/**
 * rmerge5
 */
const rmerge5 = (r, s, t, u, v) => [s, t, u, v]
    .reduce((p, c) => (0, exports.reduce)(c, (p), deepMerge), r);
exports.rmerge5 = rmerge5;
const deepMerge = (pre, curr, key) => (0, exports.isRecord)(curr) ?
    (0, exports.merge)(pre, (0, exports.set)({}, key, (0, exports.isRecord)(pre[key]) ?
        (0, exports.rmerge)(pre[key], curr) :
        (0, exports.merge)({}, curr))) :
    (0, exports.merge)(pre, (0, exports.set)({}, key, curr));
/**
 * exclude removes the specified properties from a Record.
 */
const exclude = (rec, keys) => {
    let list = Array.isArray(keys) ? keys : [keys];
    return (0, exports.reduce)(rec, {}, (p, c, k) => list.indexOf(k) > -1 ? p : (0, exports.merge)(p, (0, exports.set)({}, k, c)));
};
exports.exclude = exclude;
/**
 * partition a Record into two sub-records using a PartitionFunc function.
 *
 * This function produces an array where the first element is a Record
 * of values that return true and the second, false.
 */
const partition = (r, f) => (0, exports.reduce)(r, [{}, {}], ([yes, no], c, k) => f(c, k, r) ?
    [(0, exports.merge)(yes, (0, exports.set)({}, k, c)), no] :
    [yes, (0, exports.merge)(no, (0, exports.set)({}, k, c))]);
exports.partition = partition;
/**
 * group the properties of a Record into another Record using a GroupFunc
 * function.
 */
const group = (rec, f) => (0, exports.reduce)(rec, {}, (prev, curr, key) => {
    let category = f(curr, key, rec);
    let value = (0, exports.isRecord)(prev[category]) ?
        (0, exports.merge)(prev[category], (0, exports.set)({}, key, curr)) :
        (0, exports.set)({}, key, curr);
    return (0, exports.merge)(prev, (0, exports.set)({}, category, value));
});
exports.group = group;
/**
 * values returns a shallow array of the values of a record.
 */
const values = (r) => (0, exports.reduce)(r, [], (p, c) => (0, array_1.concat)(p, c));
exports.values = values;
/**
 * hasKey indicates whether a Record has a given key.
 */
const hasKey = (r, key) => Object.hasOwnProperty.call(r, key);
exports.hasKey = hasKey;
/**
 * clone a Record.
 *
 * Breaks references and deep clones arrays.
 * This function should only be used on Records or objects that
 * are not class instances. This function may violate type safety.
 */
const clone = (r) => (0, exports.reduce)(r, {}, (p, c, k) => { (0, exports.set)(p, k, _clone(c)); return p; });
exports.clone = clone;
const _clone = (a) => {
    if ((0, type_1.isArray)(a))
        return a.map(_clone);
    else if ((0, exports.isRecord)(a))
        return (0, exports.clone)(a);
    else
        return a;
};
/**
 * count how many properties exist on the record.
 */
const count = (r) => (0, exports.keys)(r).length;
exports.count = count;
/**
 * empty tests whether the object has any properties or not.
 */
const empty = (r) => (0, exports.count)(r) === 0;
exports.empty = empty;
/**
 * some tests whether at least one property of a Record passes the
 * test implemented by the provided function.
 */
const some = (o, f) => (0, exports.keys)(o).some(k => f(o[k], k, o));
exports.some = some;
/**
 * every tests whether each property of a Record passes the
 * test implemented by the provided function.
 */
const every = (o, f) => (0, exports.keys)(o).every(k => f(o[k], k, o));
exports.every = every;
/**
 * set the value of a key on a Record ignoring problematic keys.
 *
 * This function exists to avoid unintentionally setting problem keys such
 * as __proto__ on an object.
 *
 * Even though this function mutates the provided record, it should be used
 * as though it does not.
 *
 * Don't:
 * set(obj, key, value);
 *
 * Do:
 * obj = set(obj, key, value);
 */
const set = (r, k, value) => {
    if (!(0, exports.isBadKey)(k))
        r[k] = value;
    return r;
};
exports.set = set;
/**
 * isBadKey tests whether a key is problematic (Like __proto__).
 */
const isBadKey = (key) => exports.badKeys.indexOf(key) !== -1;
exports.isBadKey = isBadKey;
/**
 * compact a Record by removing any properties that == null.
 */
const compact = (rec) => {
    let result = {};
    for (let key in rec)
        if (rec.hasOwnProperty(key))
            if (rec[key] != null)
                result = (0, exports.set)(result, key, rec[key]);
    return result;
};
exports.compact = compact;
/**
 * rcompact recursively compacts a Record.
 */
const rcompact = (rec) => (0, exports.compact)((0, exports.map)(rec, val => (0, exports.isRecord)(val) ? (0, exports.rcompact)(val) : val));
exports.rcompact = rcompact;
/**
 * make creates a new instance of a Record optionally using the provided
 * value as an initializer.
 *
 * This function is intended to assist with curbing prototype pollution by
 * configuring a setter for __proto__ that ignores changes.
 */
const make = (init = {}) => {
    let rec = {};
    Object.defineProperty(rec, '__proto__', {
        configurable: false,
        enumerable: false,
        set() { }
    });
    for (let key in init)
        if (init.hasOwnProperty(key))
            rec[key] = init[key];
    return rec;
};
exports.make = make;
/**
 * pickKey selects the value of the first property in a Record that passes the
 * provided test.
 */
const pickKey = (rec, test) => (0, exports.reduce)(rec, (0, maybe_1.nothing)(), (p, c, k) => p.isJust() ? p : test(c, k, rec) ? (0, maybe_1.just)(k) : p);
exports.pickKey = pickKey;
/**
 * pickValue selects the value of the first property in a Record that passes the
 * provided test.
 */
const pickValue = (rec, test) => (0, exports.reduce)(rec, (0, maybe_1.nothing)(), (p, c, k) => p.isJust() ? p : test(c, k, rec) ? (0, maybe_1.just)(c) : p);
exports.pickValue = pickValue;

},{"../array":149,"../maybe":151,"../type":154}],153:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.project = exports.unflatten = exports.flatten = exports.unescapeRecord = exports.escapeRecord = exports.unescape = exports.escape = exports.set = exports.getString = exports.getDefault = exports.get = exports.unsafeGet = exports.tokenize = void 0;
/**
 * This module provides a syntax and associated functions for
 * getting and setting values on ES objects easily.
 *
 * Given a path, a value can either be retrieved or set on an object.
 *
 * The path syntax follows typical ES dot notation, bracket notation or a mixture
 * of both.
 *
 * Note that quotes are not used when describing a path via bracket notation.
 *
 * If you need to use a dot or square brackets in your paths, prefix them with
 * the "\" (backslash) character.
 */
/** imports **/
const maybe_1 = require("../maybe");
const _1 = require("./");
const TOKEN_DOT = '.';
const TOKEN_BRACKET_LEFT = '[';
const TOKEN_BRACKET_RIGHT = ']';
const TOKEN_ESCAPE = '\\';
/**
 * tokenize a path into a list of sequential property names.
 */
const tokenize = (str) => {
    let i = 0;
    let buf = '';
    let curr = '';
    let next = '';
    let tokens = [];
    while (i < str.length) {
        curr = str[i];
        next = str[i + 1];
        if (curr === TOKEN_ESCAPE) {
            //escape sequence
            buf = `${buf}${next}`;
            i++;
        }
        else if (curr === TOKEN_DOT) {
            if (buf !== '')
                tokens.push(buf); //recognize a path and push a new token
            buf = '';
        }
        else if ((curr === TOKEN_BRACKET_LEFT) &&
            next === TOKEN_BRACKET_RIGHT) {
            //intercept empty bracket paths
            i++;
        }
        else if (curr === TOKEN_BRACKET_LEFT) {
            let bracketBuf = '';
            let firstDot = -1;
            let firstDotBuf = '';
            i++;
            while (true) {
                //everything between brackets is treated as a path
                //if no closing bracket is found, we back track to the first dot
                //if there is no dot the whole buffer is treated as a path
                curr = str[i];
                next = str[i + 1];
                if ((curr === TOKEN_BRACKET_RIGHT) &&
                    (next === TOKEN_BRACKET_RIGHT)) {
                    //escaped right bracket
                    bracketBuf = `${bracketBuf}${TOKEN_BRACKET_RIGHT}`;
                    i++;
                }
                else if (curr === TOKEN_BRACKET_RIGHT) {
                    //successfully tokenized the path
                    if (buf !== '')
                        tokens.push(buf); //save the previous path
                    tokens.push(bracketBuf); //save the current path
                    buf = '';
                    break;
                }
                else if (curr == null) {
                    //no closing bracket found and we ran out of string to search
                    if (firstDot !== -1) {
                        //backtrack to the first dot encountered
                        i = firstDot;
                        //save the paths so far
                        tokens.push(`${buf}${TOKEN_BRACKET_LEFT}${firstDotBuf}`);
                        buf = '';
                        break;
                    }
                    else {
                        //else if no dots were found treat the current buffer
                        // and rest of the string as part of one path.
                        buf = `${buf}${TOKEN_BRACKET_LEFT}${bracketBuf}`;
                        break;
                    }
                }
                if ((curr === TOKEN_DOT) && (firstDot === -1)) {
                    //take note of the location and tokens between 
                    //the opening bracket and first dot.
                    //If there is no closing bracket, we use this info to
                    //lex properly.
                    firstDot = i;
                    firstDotBuf = bracketBuf;
                }
                bracketBuf = `${bracketBuf}${curr}`;
                i++;
            }
        }
        else {
            buf = `${buf}${curr}`;
        }
        i++;
    }
    if ((buf.length > 0))
        tokens.push(buf);
    return tokens;
};
exports.tokenize = tokenize;
/**
 * unsafeGet retrieves a value at the specified path
 * on any ES object.
 *
 * This function does not check if getting the value succeeded or not.
 */
const unsafeGet = (path, src) => {
    if (src == null)
        return undefined;
    let toks = (0, exports.tokenize)(path);
    let head = src[toks.shift()];
    return toks.reduce((p, c) => (p == null) ? p : p[c], head);
};
exports.unsafeGet = unsafeGet;
/**
 * get a value from a Record given its path safely.
 */
const get = (path, src) => (0, maybe_1.fromNullable)((0, exports.unsafeGet)(path, src));
exports.get = get;
/**
 * getDefault is like get but takes a default value to return if
 * the path is not found.
 */
const getDefault = (path, src, def) => (0, exports.get)(path, src).orJust(() => def).get();
exports.getDefault = getDefault;
/**
 * getString casts the resulting value to a string.
 *
 * An empty string is provided if the path is not found.
 */
const getString = (path, src) => (0, exports.get)(path, src).map(v => String(v)).orJust(() => '').get();
exports.getString = getString;
/**
 * set sets a value on an object given a path.
 */
const set = (p, v, r) => {
    let toks = (0, exports.tokenize)(p);
    return _set(r, v, toks);
};
exports.set = set;
const _set = (r, value, toks) => {
    let o;
    if (toks.length === 0)
        return value;
    o = (0, _1.isRecord)(r) ? (0, _1.clone)(r) : {};
    o = (0, _1.set)(o, toks[0], _set(o[toks[0]], value, toks.slice(1)));
    return o;
};
/**
 * escape a path so that occurences of dots are not interpreted as paths.
 *
 * This function escapes dots and dots only.
 */
const escape = (p) => {
    let i = 0;
    let buf = '';
    let curr = '';
    while (i < p.length) {
        curr = p[i];
        if ((curr === TOKEN_ESCAPE) || (curr === TOKEN_DOT))
            buf = `${buf}${TOKEN_ESCAPE}${curr}`;
        else
            buf = `${buf}${curr}`;
        i++;
    }
    return buf;
};
exports.escape = escape;
/**
 * unescape a path that has been previously escaped.
 */
const unescape = (p) => {
    let i = 0;
    let curr = '';
    let next = '';
    let buf = '';
    while (i < p.length) {
        curr = p[i];
        next = p[i + 1];
        if (curr === TOKEN_ESCAPE) {
            buf = `${buf}${next}`;
            i++;
        }
        else {
            buf = `${buf}${curr}`;
        }
        i++;
    }
    return buf;
};
exports.unescape = unescape;
/**
 * escapeRecord escapes each property of a record recursively.
 */
const escapeRecord = (r) => (0, _1.reduce)(r, {}, (p, c, k) => {
    if (typeof c === 'object')
        p = (0, _1.set)(p, (0, exports.escape)(k), (0, exports.escapeRecord)(c));
    else
        p = (0, _1.set)(p, (0, exports.escape)(k), c);
    return p;
});
exports.escapeRecord = escapeRecord;
/**
 * unescapeRecord unescapes each property of a record recursively.
 */
const unescapeRecord = (r) => (0, _1.reduce)(r, {}, (p, c, k) => {
    if ((0, _1.isRecord)(c))
        p = (0, _1.set)(p, (0, exports.unescape)(k), (0, exports.unescapeRecord)(c));
    else
        p = (0, _1.set)(p, (0, exports.unescape)(k), c);
    return p;
});
exports.unescapeRecord = unescapeRecord;
/**
 * flatten an object into a Record where each key is a path to a non-complex
 * value or array.
 *
 * If any of the paths contain dots, they will be escaped.
 */
const flatten = (r) => (flatImpl('')({})(r));
exports.flatten = flatten;
const flatImpl = (pfix) => (prev) => (r) => (0, _1.reduce)(r, prev, (p, c, k) => (0, _1.isRecord)(c) ?
    (flatImpl(prefix(pfix, k))(p)(c)) :
    (0, _1.merge)(p, (0, _1.set)({}, prefix(pfix, k), c)));
const prefix = (pfix, key) => (pfix === '') ?
    (0, exports.escape)(key) : `${pfix}.${(0, exports.escape)(key)}`;
/**
 * unflatten a flattened Record so that any nested paths are expanded
 * to their full representation.
 */
const unflatten = (r) => (0, _1.reduce)(r, {}, (p, c, k) => (0, exports.set)(k, c, p));
exports.unflatten = unflatten;
/**
 * project a Record according to the field specification given.
 *
 * Only properties that appear in the spec and set to true will be retained.
 * This function may violate type safety and may leave undefined holes in the
 * result.
 */
const project = (spec, rec) => (0, _1.reduce)(spec, {}, (p, c, k) => (c === true) ? (0, exports.set)(k, (0, exports.unsafeGet)(k, rec), p) : p);
exports.project = project;

},{"../maybe":151,"./":152}],154:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toString = exports.show = exports.test = exports.is = exports.isPrim = exports.isFunction = exports.isBoolean = exports.isNumber = exports.isString = exports.isArray = exports.isObject = exports.Any = void 0;
const prims = ['string', 'number', 'boolean'];
/**
 * Any is a class used to represent typescript's "any" type.
 */
class Any {
}
exports.Any = Any;
/**
 * isObject test.
 *
 * Does not consider an Array an object.
 */
const isObject = (value) => (typeof value === 'object') && (!(0, exports.isArray)(value));
exports.isObject = isObject;
/**
 * isArray test.
 */
exports.isArray = Array.isArray;
/**
 * isString test.
 */
const isString = (value) => typeof value === 'string';
exports.isString = isString;
/**
 * isNumber test.
 */
const isNumber = (value) => (typeof value === 'number') && (!isNaN(value));
exports.isNumber = isNumber;
/**
 * isBoolean test.
 */
const isBoolean = (value) => typeof value === 'boolean';
exports.isBoolean = isBoolean;
/**
 * isFunction test.
 */
const isFunction = (value) => typeof value === 'function';
exports.isFunction = isFunction;
/**
 * isPrim test.
 */
const isPrim = (value) => !((0, exports.isObject)(value) ||
    (0, exports.isArray)(value) ||
    (0, exports.isFunction)(value));
exports.isPrim = isPrim;
/**
 * is performs a typeof of check on a type.
 */
const is = (expected) => (value) => typeof (value) === expected;
exports.is = is;
/**
 * test whether a value conforms to some pattern.
 *
 * This function is made available mainly for a crude pattern matching
 * machinery that works as followss:
 * string   -> Matches on the value of the string.
 * number   -> Matches on the value of the number.
 * boolean  -> Matches on the value of the boolean.
 * object   -> Each key of the object is matched on the value, all must match.
 * function -> Treated as a constructor and results in an instanceof check or
 *             for String,Number and Boolean, this uses the typeof check. If
 *             the function is RegExp then we uses the RegExp.test function
 *             instead.
 */
const test = (value, t) => {
    if ((prims.indexOf(typeof t) > -1) && (value === t))
        return true;
    else if ((typeof t === 'function') &&
        (((t === String) && (typeof value === 'string')) ||
            ((t === Number) && (typeof value === 'number')) ||
            ((t === Boolean) && (typeof value === 'boolean')) ||
            ((t === Array) && (Array.isArray(value))) ||
            (t === Any) ||
            (value instanceof t)))
        return true;
    else if ((t instanceof RegExp) &&
        ((typeof value === 'string') &&
            t.test(value)))
        return true;
    else if ((typeof t === 'object') && (typeof value === 'object'))
        return Object
            .keys(t)
            .every(k => Object.hasOwnProperty.call(value, k) ?
            (0, exports.test)(value[k], t[k]) : false);
    return false;
};
exports.test = test;
/**
 * show the type of a value.
 *
 * Note: This may crash if the value is an
 * object literal with recursive references.
 */
const show = (value) => {
    if (typeof value === 'object') {
        if (Array.isArray(value))
            return `[${value.map(exports.show)}];`;
        else if (value.constructor !== Object)
            return (value.constructor.name ||
                value.constructor);
        else
            return JSON.stringify(value);
    }
    else {
        return '' + value;
    }
};
exports.show = show;
/**
 * toString casts a value to a string.
 *
 * If the value is null or undefined an empty string is returned instead of
 * the default.
 */
const toString = (val) => (val == null) ? '' : String(val);
exports.toString = toString;

},{}],155:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.round = exports.isMultipleOf = void 0;
/**
 * isMultipleOf tests whether the Integer 'y' is a multiple of x.
 */
const isMultipleOf = (x, y) => ((y % x) === 0);
exports.isMultipleOf = isMultipleOf;
/**
 * round a number "x" to "n" places (n defaults to 0 places).
 *
 * This uses the Math.round(x * n) / n method however we take into
 * consideration the Math.round(1.005 * 100) / 100 === 1 issue by use of an
 * offset:
 *
 * sign * (round((abs(x) * 10^n) + (1 / 10^n+1)) / 10^n)
 *
 * Where:
 *
 * sign is the sign of x
 * round is Math.round
 * abs is Math.abs
 * (1 / 10^n+1) is the offset.
 *
 * The offset is only used if n is more than zero. The absolute value of x
 * is used in the calculation to avoid JavaScript idiosyncracies when rounding
 * 0.5:
 * (Math.round((1.005 * 100)+0.001) / 100) === 1.01
 *
 * whereas
 * (Math.round((-1.005 * 100)+0.001) / 100) === -1
 *
 * See the description [here]( https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round)
 * for more details.
 *
 */
const round = (x, n = 0) => {
    let exp = Math.pow(10, n);
    let sign = x >= 0 ? 1 : -1;
    let offset = (n > 0) ? (1 / (Math.pow(10, n + 1))) : 0;
    return sign * (Math.round((Math.abs(x) * exp) + offset) / exp);
};
exports.round = round;

},{}],156:[function(require,module,exports){
(function (global){(function (){
"use strict";
/**
 * This module provides functions used in templates to generate supported DOM
 * nodes.
 *
 * The idea here is to provide an abstraction over DOM construction so
 * we can detect whether we are in a browser or elsewhere and adjust to
 * suite.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createElement = exports.unsafe = exports.text = exports.createUnsafeNode = exports.createTextNode = exports.escapeHTML = exports.escapeAttrValue = exports.escapeAttrs = exports.isBrowser = exports.WMLDOMElement = exports.WMLDOMText = exports.WMLDOMNode = exports.WMLNodeList = void 0;
const record_1 = require("@quenk/noni/lib/data/record");
const type_1 = require("@quenk/noni/lib/data/type");
// Declared so isBrowser works on node.js.
let window = global;
let document = global.document;
const DOCTYPE = '<!DOCTYPE html>';
const ATTR_ESC_MAP = {
    '&': '\\u0026',
    '>': '\\u003e',
    '<': '\\u003c',
    '"': '\\u0022',
    '=': '\\u003d',
    '\u005c': '\\u005c',
    '\u2028': '\\u2028',
    '\u2029': '\\u2029'
};
const attrsEscRegex = new RegExp(`[${(0, record_1.mapTo)(ATTR_ESC_MAP, (_, k) => k)}]`, 'g');
const HTML_ENT_MAP = {
    '"': '&quot;',
    '&': '&amp;',
    '\'': '&apos;',
    '<': '&lt;',
    '>': '&gt;'
};
const htmlEscRegex = new RegExp(`[${(0, record_1.mapTo)(HTML_ENT_MAP, (_, k) => k)}]`, 'g');
const voidElements = [
    'area',
    'base',
    'br',
    'col',
    'command',
    'embed',
    'hr',
    'img',
    'input',
    'keygen',
    'link',
    'meta',
    'param',
    'source',
    'track',
    'wbr'
];
/**
 * WMLNodeList implementation.
 * @private
 */
class WMLNodeList {
    constructor() {
        this.length = 0;
    }
    item() {
        return null;
    }
    forEach() { }
}
exports.WMLNodeList = WMLNodeList;
/**
 * WMLDOMNode implements the properties and methods of the DOM Node interface to
 * allow a fake DOM to be built in server side code.
 *
 * Most of the methods and properties cannot be relied on and should not be
 * used.
 */
class WMLDOMNode {
    constructor(nodeName, nodeType) {
        this.nodeName = nodeName;
        this.nodeType = nodeType;
        this.ATTRIBUTE_NODE = -1;
        this.CDATA_SECTION_NODE = -1;
        this.COMMENT_NODE = -1;
        this.DOCUMENT_FRAGMENT_NODE = -1;
        this.DOCUMENT_NODE = -1;
        this.DOCUMENT_POSITION_CONTAINED_BY = -1;
        this.DOCUMENT_POSITION_CONTAINS = -1;
        this.DOCUMENT_POSITION_DISCONNECTED = -1;
        this.DOCUMENT_POSITION_FOLLOWING = -1;
        this.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = -1;
        this.DOCUMENT_POSITION_PRECEDING = -1;
        this.DOCUMENT_TYPE_NODE = -1;
        this.ELEMENT_NODE = -1;
        this.ENTITY_NODE = -1;
        this.ENTITY_REFERENCE_NODE = -1;
        this.NOTATION_NODE = -1;
        this.PROCESSING_INSTRUCTION_NODE = -1;
        this.TEXT_NODE = -1;
        this.baseURI = '';
        this.childNodes = new WMLNodeList();
        this.firstChild = null;
        this.isConnected = false;
        this.lastChild = null;
        this.namespaceURI = null;
        this.nextSibling = null;
        this.nodeValue = null;
        this.ownerDocument = null;
        this.parentElement = null;
        this.parentNode = null;
        this.previousSibling = null;
    }
    get textContent() {
        return '';
    }
    addEventListener() { }
    dispatchEvent() {
        return false;
    }
    removeEventListener() { }
    appendChild(newChild) {
        return newChild;
    }
    cloneNode() {
        return this;
    }
    compareDocumentPosition() {
        return 0;
    }
    contains() {
        return false;
    }
    getRootNode() {
        return this;
    }
    hasChildNodes() {
        return false;
    }
    insertBefore(newChild) {
        return newChild;
    }
    isDefaultNamespace() {
        return false;
    }
    isEqualNode() {
        return false;
    }
    isSameNode() {
        return false;
    }
    lookupNamespaceURI() {
        return null;
    }
    lookupPrefix() {
        return null;
    }
    normalize() { }
    remove() { }
    before() { }
    after() { }
    replaceWith() { }
    removeChild(oldChild) {
        return oldChild;
    }
    replaceChild(_, oldChild) {
        return oldChild;
    }
}
exports.WMLDOMNode = WMLDOMNode;
/**
 * WMLDOMText is used to represent Text nodes on the server side.
 * @private
 */
class WMLDOMText extends WMLDOMNode {
    constructor(value, escape = true) {
        super('#text', -1);
        this.value = value;
        this.escape = escape;
    }
    get textContent() {
        return this.escape ? (0, exports.escapeHTML)(this.value) : this.value;
    }
}
exports.WMLDOMText = WMLDOMText;
/**
 * WMLDOMElement is used to represent Element nodes on the server side.
 * @private
 */
class WMLDOMElement extends WMLDOMNode {
    constructor(tag, attrs, children = []) {
        super(tag, -1);
        this.tag = tag;
        this.attrs = attrs;
        this.children = children;
    }
    get innerHTML() {
        return this.children.map(c => (c.nodeName === '#text') ?
            c.textContent :
            c.outerHTML).join('');
    }
    get outerHTML() {
        let { tag } = this;
        let content = this.innerHTML;
        let attrs = (0, record_1.mapTo)((0, exports.escapeAttrs)(this.attrs), (value, name) => !value ?
            name : `${name}="${value}"`).join(' ');
        attrs = (attrs.trim() != '') ? ` ${attrs}` : '';
        let open = `<${tag}${attrs}>`;
        if (tag === "html")
            open = `${DOCTYPE}${open}`;
        return (voidElements.indexOf(tag) > -1) ?
            open : `${open}${content}</${tag}>`;
    }
    setAttribute(key, value) {
        this.attrs[key] = value;
    }
    appendChild(newChild) {
        this.children.push(newChild);
        return newChild;
    }
}
exports.WMLDOMElement = WMLDOMElement;
/**
 * isBrowser is set to true if we detect a window and document global variable.
 */
exports.isBrowser = ((window != null) && (document != null));
/**
 * escapeAttrs escapes each key value pair of a WMLDOMAttrs.
 */
const escapeAttrs = (attrs) => (0, record_1.map)(attrs, value => (0, type_1.isFunction)(value) ? value :
    (value instanceof WMLDOMText) ? value.textContent :
        (0, exports.escapeAttrValue)(String(value)));
exports.escapeAttrs = escapeAttrs;
/**
 * escapeAttrValue for safe browser display.
 */
const escapeAttrValue = (value) => value.replace(attrsEscRegex, hit => ATTR_ESC_MAP[hit]);
exports.escapeAttrValue = escapeAttrValue;
/**
 * escapeHTML for safe browser display.
 */
const escapeHTML = (value) => value.replace(htmlEscRegex, hit => HTML_ENT_MAP[hit]);
exports.escapeHTML = escapeHTML;
/**
 * createTextNode wrapper.
 */
const createTextNode = (txt) => {
    let str = String((txt == null) ? '' : txt);
    return exports.isBrowser ? document.createTextNode(str) : new WMLDOMText(str);
};
exports.createTextNode = createTextNode;
exports.text = exports.createTextNode;
/**
 * createUnsafeNode allows raw strings to be output without escaping.
 *
 * THIS MUST ONLY BE USED IF YOU ARE 100% SURE THE STRING IS SAFE TO OUTPUT!
 */
const createUnsafeNode = (txt) => {
    let str = String((txt == null) ? '' : txt);
    return exports.isBrowser ? createBrowserUnsafeNode(str) : new WMLDOMText(str, false);
};
exports.createUnsafeNode = createUnsafeNode;
exports.unsafe = exports.createUnsafeNode;
const createBrowserUnsafeNode = (html) => {
    let tmpl = document.createElement('template');
    tmpl.innerHTML = html;
    return tmpl.content;
};
/**
 * createElement wrapper.
 */
const createElement = (tag, attrs = {}, children = []) => {
    if (!exports.isBrowser) {
        // XXX: The whole Element interface is not implemented but on server
        // side we are only interested in setAttribute.
        return new WMLDOMElement(tag, attrs, children);
    }
    else {
        let e = document.createElement(tag);
        (0, record_1.forEach)(attrs, (value, key) => {
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                // prevent setting things like disabled=""
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    e.appendChild(document.createTextNode('' + c));
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        return e;
    }
};
exports.createElement = createElement;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"@quenk/noni/lib/data/record":152,"@quenk/noni/lib/data/type":154}],157:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderAsNode = exports.Component = void 0;
/**
 * Component is an abstract Widget implementation
 * that can be used instead of manually implementing the whole interface.
 */
class Component {
    /**
     * @param {A} attrs is the attributes this Component excepts.
     * @param {Content[]} children is an array of content for Component.
     */
    constructor(attrs, children) {
        this.attrs = attrs;
        this.children = children;
    }
    rendered() { }
    removed() { }
    render() { return this.view.render(); }
}
exports.Component = Component;
;
/**
 * renderAsNode content from a Renderable.
 *
 * This function unsafely assumes the Renderable always returns DOM content.
 */
const renderAsNode = (r) => r.render();
exports.renderAsNode = renderAsNode;

},{}],158:[function(require,module,exports){
//! moment.js
//! version : 2.29.4
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

    var hookCallback;

    function hooks() {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback(callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return (
            input instanceof Array ||
            Object.prototype.toString.call(input) === '[object Array]'
        );
    }

    function isObject(input) {
        // IE8 will treat undefined and null as object if it wasn't for
        // input != null
        return (
            input != null &&
            Object.prototype.toString.call(input) === '[object Object]'
        );
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
            return Object.getOwnPropertyNames(obj).length === 0;
        } else {
            var k;
            for (k in obj) {
                if (hasOwnProp(obj, k)) {
                    return false;
                }
            }
            return true;
        }
    }

    function isUndefined(input) {
        return input === void 0;
    }

    function isNumber(input) {
        return (
            typeof input === 'number' ||
            Object.prototype.toString.call(input) === '[object Number]'
        );
    }

    function isDate(input) {
        return (
            input instanceof Date ||
            Object.prototype.toString.call(input) === '[object Date]'
        );
    }

    function map(arr, fn) {
        var res = [],
            i,
            arrLen = arr.length;
        for (i = 0; i < arrLen; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function createUTC(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidEra: null,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false,
            parsedDateParts: [],
            era: null,
            meridiem: null,
            rfc2822: false,
            weekdayMismatch: false,
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this),
                len = t.length >>> 0,
                i;

            for (i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m),
                parsedParts = some.call(flags.parsedDateParts, function (i) {
                    return i != null;
                }),
                isNowValid =
                    !isNaN(m._d.getTime()) &&
                    flags.overflow < 0 &&
                    !flags.empty &&
                    !flags.invalidEra &&
                    !flags.invalidMonth &&
                    !flags.invalidWeekday &&
                    !flags.weekdayMismatch &&
                    !flags.nullInput &&
                    !flags.invalidFormat &&
                    !flags.userInvalidated &&
                    (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                isNowValid =
                    isNowValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }

            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            } else {
                return isNowValid;
            }
        }
        return m._isValid;
    }

    function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        } else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = (hooks.momentProperties = []),
        updateInProgress = false;

    function copyConfig(to, from) {
        var i,
            prop,
            val,
            momentPropertiesLen = momentProperties.length;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentPropertiesLen > 0) {
            for (i = 0; i < momentPropertiesLen; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment(obj) {
        return (
            obj instanceof Moment || (obj != null && obj._isAMomentObject != null)
        );
    }

    function warn(msg) {
        if (
            hooks.suppressDeprecationWarnings === false &&
            typeof console !== 'undefined' &&
            console.warn
        ) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [],
                    arg,
                    i,
                    key,
                    argLen = arguments.length;
                for (i = 0; i < argLen; i++) {
                    arg = '';
                    if (typeof arguments[i] === 'object') {
                        arg += '\n[' + i + '] ';
                        for (key in arguments[0]) {
                            if (hasOwnProp(arguments[0], key)) {
                                arg += key + ': ' + arguments[0][key] + ', ';
                            }
                        }
                        arg = arg.slice(0, -2); // Remove trailing comma and space
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(
                    msg +
                        '\nArguments: ' +
                        Array.prototype.slice.call(args).join('') +
                        '\n' +
                        new Error().stack
                );
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
        return (
            (typeof Function !== 'undefined' && input instanceof Function) ||
            Object.prototype.toString.call(input) === '[object Function]'
        );
    }

    function set(config) {
        var prop, i;
        for (i in config) {
            if (hasOwnProp(config, i)) {
                prop = config[i];
                if (isFunction(prop)) {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
        // TODO: Remove "ordinalParse" fallback in next major release.
        this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                '|' +
                /\d{1,2}/.source
        );
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig),
            prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (
                hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])
            ) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i,
                res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var defaultCalendar = {
        sameDay: '[Today at] LT',
        nextDay: '[Tomorrow at] LT',
        nextWeek: 'dddd [at] LT',
        lastDay: '[Yesterday at] LT',
        lastWeek: '[Last] dddd [at] LT',
        sameElse: 'L',
    };

    function calendar(key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (
            (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +
            absNumber
        );
    }

    var formattingTokens =
            /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
        formatFunctions = {},
        formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken(token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(
                    func.apply(this, arguments),
                    token
                );
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens),
            i,
            length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '',
                i;
            for (i = 0; i < length; i++) {
                output += isFunction(array[i])
                    ? array[i].call(mom, format)
                    : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] =
            formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(
                localFormattingTokens,
                replaceLongDateFormatTokens
            );
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var defaultLongDateFormat = {
        LTS: 'h:mm:ss A',
        LT: 'h:mm A',
        L: 'MM/DD/YYYY',
        LL: 'MMMM D, YYYY',
        LLL: 'MMMM D, YYYY h:mm A',
        LLLL: 'dddd, MMMM D, YYYY h:mm A',
    };

    function longDateFormat(key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper
            .match(formattingTokens)
            .map(function (tok) {
                if (
                    tok === 'MMMM' ||
                    tok === 'MM' ||
                    tok === 'DD' ||
                    tok === 'dddd'
                ) {
                    return tok.slice(1);
                }
                return tok;
            })
            .join('');

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate() {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d',
        defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal(number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future: 'in %s',
        past: '%s ago',
        s: 'a few seconds',
        ss: '%d seconds',
        m: 'a minute',
        mm: '%d minutes',
        h: 'an hour',
        hh: '%d hours',
        d: 'a day',
        dd: '%d days',
        w: 'a week',
        ww: '%d weeks',
        M: 'a month',
        MM: '%d months',
        y: 'a year',
        yy: '%d years',
    };

    function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output)
            ? output(number, withoutSuffix, string, isFuture)
            : output.replace(/%d/i, number);
    }

    function pastFuture(diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string'
            ? aliases[units] || aliases[units.toLowerCase()]
            : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
        var units = [],
            u;
        for (u in unitsObj) {
            if (hasOwnProp(unitsObj, u)) {
                units.push({ unit: u, priority: priorities[u] });
            }
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    function absFloor(number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    function makeGetSet(unit, keepTime) {
        return function (value) {
            if (value != null) {
                set$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get(this, unit);
            }
        };
    }

    function get(mom, unit) {
        return mom.isValid()
            ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]()
            : NaN;
    }

    function set$1(mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
            if (
                unit === 'FullYear' &&
                isLeapYear(mom.year()) &&
                mom.month() === 1 &&
                mom.date() === 29
            ) {
                value = toInt(value);
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](
                    value,
                    mom.month(),
                    daysInMonth(value, mom.month())
                );
            } else {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
            }
        }
    }

    // MOMENTS

    function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }

    function stringSet(units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units),
                i,
                prioritizedLen = prioritized.length;
            for (i = 0; i < prioritizedLen; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    var match1 = /\d/, //       0 - 9
        match2 = /\d\d/, //      00 - 99
        match3 = /\d{3}/, //     000 - 999
        match4 = /\d{4}/, //    0000 - 9999
        match6 = /[+-]?\d{6}/, // -999999 - 999999
        match1to2 = /\d\d?/, //       0 - 99
        match3to4 = /\d\d\d\d?/, //     999 - 9999
        match5to6 = /\d\d\d\d\d\d?/, //   99999 - 999999
        match1to3 = /\d{1,3}/, //       0 - 999
        match1to4 = /\d{1,4}/, //       0 - 9999
        match1to6 = /[+-]?\d{1,6}/, // -999999 - 999999
        matchUnsigned = /\d+/, //       0 - inf
        matchSigned = /[+-]?\d+/, //    -inf - inf
        matchOffset = /Z|[+-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
        matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, // +00 -00 +00:00 -00:00 +0000 -0000 or Z
        matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
        // any word (or two) characters or numbers including two/three word month in arabic.
        // includes scottish gaelic two word and hyphenated months
        matchWord =
            /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
        regexes;

    regexes = {};

    function addRegexToken(token, regex, strictRegex) {
        regexes[token] = isFunction(regex)
            ? regex
            : function (isStrict, localeData) {
                  return isStrict && strictRegex ? strictRegex : regex;
              };
    }

    function getParseRegexForToken(token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(
            s
                .replace('\\', '')
                .replace(
                    /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
                    function (matched, p1, p2, p3, p4) {
                        return p1 || p2 || p3 || p4;
                    }
                )
        );
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken(token, callback) {
        var i,
            func = callback,
            tokenLen;
        if (typeof token === 'string') {
            token = [token];
        }
        if (isNumber(callback)) {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        tokenLen = token.length;
        for (i = 0; i < tokenLen; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken(token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,
        WEEK = 7,
        WEEKDAY = 8;

    function mod(n, x) {
        return ((n % x) + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
            return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1
            ? isLeapYear(year)
                ? 29
                : 28
            : 31 - ((modMonth % 7) % 2);
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PRIORITY

    addUnitPriority('month', 8);

    // PARSING

    addRegexToken('M', match1to2);
    addRegexToken('MM', match1to2, match2);
    addRegexToken('MMM', function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var defaultLocaleMonths =
            'January_February_March_April_May_June_July_August_September_October_November_December'.split(
                '_'
            ),
        defaultLocaleMonthsShort =
            'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
        defaultMonthsShortRegex = matchWord,
        defaultMonthsRegex = matchWord;

    function localeMonths(m, format) {
        if (!m) {
            return isArray(this._months)
                ? this._months
                : this._months['standalone'];
        }
        return isArray(this._months)
            ? this._months[m.month()]
            : this._months[
                  (this._months.isFormat || MONTHS_IN_FORMAT).test(format)
                      ? 'format'
                      : 'standalone'
              ][m.month()];
    }

    function localeMonthsShort(m, format) {
        if (!m) {
            return isArray(this._monthsShort)
                ? this._monthsShort
                : this._monthsShort['standalone'];
        }
        return isArray(this._monthsShort)
            ? this._monthsShort[m.month()]
            : this._monthsShort[
                  MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'
              ][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
        var i,
            ii,
            mom,
            llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(
                    mom,
                    ''
                ).toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse(monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp(
                    '^' + this.months(mom, '').replace('.', '') + '$',
                    'i'
                );
                this._shortMonthsParse[i] = new RegExp(
                    '^' + this.monthsShort(mom, '').replace('.', '') + '$',
                    'i'
                );
            }
            if (!strict && !this._monthsParse[i]) {
                regex =
                    '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (
                strict &&
                format === 'MMMM' &&
                this._longMonthsParse[i].test(monthName)
            ) {
                return i;
            } else if (
                strict &&
                format === 'MMM' &&
                this._shortMonthsParse[i].test(monthName)
            ) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth(mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (!isNumber(value)) {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth(value) {
        if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
        } else {
            return get(this, 'Month');
        }
    }

    function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
    }

    function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict
                ? this._monthsShortStrictRegex
                : this._monthsShortRegex;
        }
    }

    function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict
                ? this._monthsStrictRegex
                : this._monthsRegex;
        }
    }

    function computeMonthsParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp(
            '^(' + longPieces.join('|') + ')',
            'i'
        );
        this._monthsShortStrictRegex = new RegExp(
            '^(' + shortPieces.join('|') + ')',
            'i'
        );
    }

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? zeroFill(y, 4) : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY', 4], 0, 'year');
    addFormatToken(0, ['YYYYY', 5], 0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PRIORITIES

    addUnitPriority('year', 1);

    // PARSING

    addRegexToken('Y', matchSigned);
    addRegexToken('YY', match1to2, match2);
    addRegexToken('YYYY', match1to4, match4);
    addRegexToken('YYYYY', match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] =
            input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    // HOOKS

    hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear() {
        return isLeapYear(this.year());
    }

    function createDate(y, m, d, h, M, s, ms) {
        // can't just apply() to create a date:
        // https://stackoverflow.com/q/181348
        var date;
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
                date.setFullYear(y);
            }
        } else {
            date = new Date(y, m, d, h, M, s, ms);
        }

        return date;
    }

    function createUTCDate(y) {
        var date, args;
        // the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            args = Array.prototype.slice.call(arguments);
            // preserve leap years using a full 400 year cycle, then reset
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
                date.setUTCFullYear(y);
            }
        } else {
            date = new Date(Date.UTC.apply(null, arguments));
        }

        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear,
            resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear,
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek,
            resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear,
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);

    // PARSING

    addRegexToken('w', match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W', match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(
        ['w', 'ww', 'W', 'WW'],
        function (input, week, config, token) {
            week[token.substr(0, 1)] = toInt(input);
        }
    );

    // HELPERS

    // LOCALES

    function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow: 0, // Sunday is the first day of the week.
        doy: 6, // The week that contains Jan 6th is the first week of the year.
    };

    function localeFirstDayOfWeek() {
        return this._week.dow;
    }

    function localeFirstDayOfYear() {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PRIORITY
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);

    // PARSING

    addRegexToken('d', match1to2);
    addRegexToken('e', match1to2);
    addRegexToken('E', match1to2);
    addRegexToken('dd', function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd', function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd', function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES
    function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
    }

    var defaultLocaleWeekdays =
            'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        defaultWeekdaysRegex = matchWord,
        defaultWeekdaysShortRegex = matchWord,
        defaultWeekdaysMinRegex = matchWord;

    function localeWeekdays(m, format) {
        var weekdays = isArray(this._weekdays)
            ? this._weekdays
            : this._weekdays[
                  m && m !== true && this._weekdays.isFormat.test(format)
                      ? 'format'
                      : 'standalone'
              ];
        return m === true
            ? shiftWeekdays(weekdays, this._week.dow)
            : m
            ? weekdays[m.day()]
            : weekdays;
    }

    function localeWeekdaysShort(m) {
        return m === true
            ? shiftWeekdays(this._weekdaysShort, this._week.dow)
            : m
            ? this._weekdaysShort[m.day()]
            : this._weekdaysShort;
    }

    function localeWeekdaysMin(m) {
        return m === true
            ? shiftWeekdays(this._weekdaysMin, this._week.dow)
            : m
            ? this._weekdaysMin[m.day()]
            : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
        var i,
            ii,
            mom,
            llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(
                    mom,
                    ''
                ).toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(
                    mom,
                    ''
                ).toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse(weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdays(mom, '').replace('.', '\\.?') + '$',
                    'i'
                );
                this._shortWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$',
                    'i'
                );
                this._minWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$',
                    'i'
                );
            }
            if (!this._weekdaysParse[i]) {
                regex =
                    '^' +
                    this.weekdays(mom, '') +
                    '|^' +
                    this.weekdaysShort(mom, '') +
                    '|^' +
                    this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (
                strict &&
                format === 'dddd' &&
                this._fullWeekdaysParse[i].test(weekdayName)
            ) {
                return i;
            } else if (
                strict &&
                format === 'ddd' &&
                this._shortWeekdaysParse[i].test(weekdayName)
            ) {
                return i;
            } else if (
                strict &&
                format === 'dd' &&
                this._minWeekdaysParse[i].test(weekdayName)
            ) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict
                ? this._weekdaysStrictRegex
                : this._weekdaysRegex;
        }
    }

    function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict
                ? this._weekdaysShortStrictRegex
                : this._weekdaysShortRegex;
        }
    }

    function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict
                ? this._weekdaysMinStrictRegex
                : this._weekdaysMinRegex;
        }
    }

    function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [],
            shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom,
            minp,
            shortp,
            longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);
            minp = regexEscape(this.weekdaysMin(mom, ''));
            shortp = regexEscape(this.weekdaysShort(mom, ''));
            longp = regexEscape(this.weekdays(mom, ''));
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp(
            '^(' + longPieces.join('|') + ')',
            'i'
        );
        this._weekdaysShortStrictRegex = new RegExp(
            '^(' + shortPieces.join('|') + ')',
            'i'
        );
        this._weekdaysMinStrictRegex = new RegExp(
            '^(' + minPieces.join('|') + ')',
            'i'
        );
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return (
            '' +
            hFormat.apply(this) +
            zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2)
        );
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return (
            '' +
            this.hours() +
            zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2)
        );
    });

    function meridiem(token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(
                this.hours(),
                this.minutes(),
                lowercase
            );
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PRIORITY
    addUnitPriority('hour', 13);

    // PARSING

    function matchMeridiem(isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a', matchMeridiem);
    addRegexToken('A', matchMeridiem);
    addRegexToken('H', match1to2);
    addRegexToken('h', match1to2);
    addRegexToken('k', match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4,
            pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4,
            pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM(input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return (input + '').toLowerCase().charAt(0) === 'p';
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
        // Setting the hour should keep the time, because the user explicitly
        // specified which hour they want. So trying to maintain the same hour (in
        // a new timezone) makes sense. Adding/subtracting hours does not follow
        // this rule.
        getSetHour = makeGetSet('Hours', true);

    function localeMeridiem(hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse,
    };

    // internal storage for locale config files
    var locales = {},
        localeFamilies = {},
        globalLocale;

    function commonPrefix(arr1, arr2) {
        var i,
            minl = Math.min(arr1.length, arr2.length);
        for (i = 0; i < minl; i += 1) {
            if (arr1[i] !== arr2[i]) {
                return i;
            }
        }
        return minl;
    }

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0,
            j,
            next,
            locale,
            split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (
                    next &&
                    next.length >= j &&
                    commonPrefix(split, next) >= j - 1
                ) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return globalLocale;
    }

    function isLocaleNameSane(name) {
        // Prevent names that look like filesystem paths, i.e contain '/' or '\'
        return name.match('^[^/\\\\]*$') != null;
    }

    function loadLocale(name) {
        var oldLocale = null,
            aliasedRequire;
        // TODO: Find a better way to register and load all the locales in Node
        if (
            locales[name] === undefined &&
            typeof module !== 'undefined' &&
            module &&
            module.exports &&
            isLocaleNameSane(name)
        ) {
            try {
                oldLocale = globalLocale._abbr;
                aliasedRequire = require;
                aliasedRequire('./locale/' + name);
                getSetGlobalLocale(oldLocale);
            } catch (e) {
                // mark as not found to avoid repeating expensive file require call causing high CPU
                // when trying to find en-US, en_US, en-us for every format call
                locales[name] = null; // null means not found
            }
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = getLocale(key);
            } else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            } else {
                if (typeof console !== 'undefined' && console.warn) {
                    //warn user if arguments are passed but the locale could not be set
                    console.warn(
                        'Locale ' + key + ' not found. Did you forget to load it?'
                    );
                }
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale(name, config) {
        if (config !== null) {
            var locale,
                parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple(
                    'defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.'
                );
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    locale = loadLocale(config.parentLocale);
                    if (locale != null) {
                        parentConfig = locale._config;
                    } else {
                        if (!localeFamilies[config.parentLocale]) {
                            localeFamilies[config.parentLocale] = [];
                        }
                        localeFamilies[config.parentLocale].push({
                            name: name,
                            config: config,
                        });
                        return null;
                    }
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            if (localeFamilies[name]) {
                localeFamilies[name].forEach(function (x) {
                    defineLocale(x.name, x.config);
                });
            }

            // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won't end up with the child locale set.
            getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale,
                tmpLocale,
                parentConfig = baseConfig;

            if (locales[name] != null && locales[name].parentLocale != null) {
                // Update existing child locale in-place to avoid memory-leaks
                locales[name].set(mergeConfigs(locales[name]._config, config));
            } else {
                // MERGE
                tmpLocale = loadLocale(name);
                if (tmpLocale != null) {
                    parentConfig = tmpLocale._config;
                }
                config = mergeConfigs(parentConfig, config);
                if (tmpLocale == null) {
                    // updateLocale is called for creating a new locale
                    // Set abbr so it will have a name (getters return
                    // undefined otherwise).
                    config.abbr = name;
                }
                locale = new Locale(config);
                locale.parentLocale = locales[name];
                locales[name] = locale;
            }

            // backwards compat for now: also set the locale
            getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                    if (name === getSetGlobalLocale()) {
                        getSetGlobalLocale(name);
                    }
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function getLocale(key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function listLocales() {
        return keys(locales);
    }

    function checkOverflow(m) {
        var overflow,
            a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH] < 0 || a[MONTH] > 11
                    ? MONTH
                    : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH])
                    ? DATE
                    : a[HOUR] < 0 ||
                      a[HOUR] > 24 ||
                      (a[HOUR] === 24 &&
                          (a[MINUTE] !== 0 ||
                              a[SECOND] !== 0 ||
                              a[MILLISECOND] !== 0))
                    ? HOUR
                    : a[MINUTE] < 0 || a[MINUTE] > 59
                    ? MINUTE
                    : a[SECOND] < 0 || a[SECOND] > 59
                    ? SECOND
                    : a[MILLISECOND] < 0 || a[MILLISECOND] > 999
                    ? MILLISECOND
                    : -1;

            if (
                getParsingFlags(m)._overflowDayOfYear &&
                (overflow < YEAR || overflow > DATE)
            ) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex =
            /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        basicIsoRegex =
            /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
        isoDates = [
            ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
            ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
            ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
            ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
            ['YYYY-DDD', /\d{4}-\d{3}/],
            ['YYYY-MM', /\d{4}-\d\d/, false],
            ['YYYYYYMMDD', /[+-]\d{10}/],
            ['YYYYMMDD', /\d{8}/],
            ['GGGG[W]WWE', /\d{4}W\d{3}/],
            ['GGGG[W]WW', /\d{4}W\d{2}/, false],
            ['YYYYDDD', /\d{7}/],
            ['YYYYMM', /\d{6}/, false],
            ['YYYY', /\d{4}/, false],
        ],
        // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
            ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
            ['HH:mm:ss', /\d\d:\d\d:\d\d/],
            ['HH:mm', /\d\d:\d\d/],
            ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
            ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
            ['HHmmss', /\d\d\d\d\d\d/],
            ['HHmm', /\d\d\d\d/],
            ['HH', /\d\d/],
        ],
        aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
        // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
        rfc2822 =
            /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
        obsOffsets = {
            UT: 0,
            GMT: 0,
            EDT: -4 * 60,
            EST: -5 * 60,
            CDT: -5 * 60,
            CST: -6 * 60,
            MDT: -6 * 60,
            MST: -7 * 60,
            PDT: -7 * 60,
            PST: -8 * 60,
        };

    // date from iso format
    function configFromISO(config) {
        var i,
            l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime,
            dateFormat,
            timeFormat,
            tzFormat,
            isoDatesLen = isoDates.length,
            isoTimesLen = isoTimes.length;

        if (match) {
            getParsingFlags(config).iso = true;
            for (i = 0, l = isoDatesLen; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimesLen; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    function extractFromRFC2822Strings(
        yearStr,
        monthStr,
        dayStr,
        hourStr,
        minuteStr,
        secondStr
    ) {
        var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10),
        ];

        if (secondStr) {
            result.push(parseInt(secondStr, 10));
        }

        return result;
    }

    function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
            return 2000 + year;
        } else if (year <= 999) {
            return 1900 + year;
        }
        return year;
    }

    function preprocessRFC2822(s) {
        // Remove comments and folding whitespace and replace multiple-spaces with a single space
        return s
            .replace(/\([^()]*\)|[\n\t]/g, ' ')
            .replace(/(\s\s+)/g, ' ')
            .replace(/^\s\s*/, '')
            .replace(/\s\s*$/, '');
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
            // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                weekdayActual = new Date(
                    parsedInput[0],
                    parsedInput[1],
                    parsedInput[2]
                ).getDay();
            if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
            }
        }
        return true;
    }

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
            return obsOffsets[obsOffset];
        } else if (militaryOffset) {
            // the only allowed military tz is Z
            return 0;
        } else {
            var hm = parseInt(numOffset, 10),
                m = hm % 100,
                h = (hm - m) / 100;
            return h * 60 + m;
        }
    }

    // date and time from ref 2822 format
    function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)),
            parsedArray;
        if (match) {
            parsedArray = extractFromRFC2822Strings(
                match[4],
                match[3],
                match[2],
                match[5],
                match[6],
                match[7]
            );
            if (!checkWeekday(match[1], parsedArray, config)) {
                return;
            }

            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);

            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

            getParsingFlags(config).rfc2822 = true;
        } else {
            config._isValid = false;
        }
    }

    // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        configFromRFC2822(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        if (config._strict) {
            config._isValid = false;
        } else {
            // Final attempt, use Input Fallback
            hooks.createFromInputFallback(config);
        }
    }

    hooks.createFromInputFallback = deprecate(
        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
            'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
            'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            return [
                nowValue.getUTCFullYear(),
                nowValue.getUTCMonth(),
                nowValue.getUTCDate(),
            ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray(config) {
        var i,
            date,
            input = [],
            currentDate,
            expectedWeekday,
            yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (
                config._dayOfYear > daysInYear(yearToUse) ||
                config._dayOfYear === 0
            ) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] =
                config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (
            config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0
        ) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(
            null,
            input
        );
        expectedWeekday = config._useUTC
            ? config._d.getUTCDay()
            : config._d.getDay();

        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }

        // check for mismatching day of week
        if (
            config._w &&
            typeof config._w.d !== 'undefined' &&
            config._w.d !== expectedWeekday
        ) {
            getParsingFlags(config).weekdayMismatch = true;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(
                w.GG,
                config._a[YEAR],
                weekOfYear(createLocal(), 1, 4).year
            );
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            curWeek = weekOfYear(createLocal(), dow, doy);

            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

            // Default to current week.
            week = defaults(w.w, curWeek.week);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from beginning of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to beginning of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // constant that refers to the ISO standard
    hooks.ISO_8601 = function () {};

    // constant that refers to the RFC 2822 form
    hooks.RFC_2822 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i,
            parsedInput,
            tokens,
            token,
            skipped,
            stringLength = string.length,
            totalParsedInputLength = 0,
            era,
            tokenLen;

        tokens =
            expandFormat(config._f, config._locale).match(formattingTokens) || [];
        tokenLen = tokens.length;
        for (i = 0; i < tokenLen; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) ||
                [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(
                    string.indexOf(parsedInput) + parsedInput.length
                );
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                } else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            } else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver =
            stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (
            config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0
        ) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(
            config._locale,
            config._a[HOUR],
            config._meridiem
        );

        // handle era
        era = getParsingFlags(config).era;
        if (era !== null) {
            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }

        configFromArray(config);
        checkOverflow(config);
    }

    function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,
            scoreToBeat,
            i,
            currentScore,
            validFormatFound,
            bestFormatIsValid = false,
            configfLen = config._f.length;

        if (configfLen === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < configfLen; i++) {
            currentScore = 0;
            validFormatFound = false;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (isValid(tempConfig)) {
                validFormatFound = true;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (!bestFormatIsValid) {
                if (
                    scoreToBeat == null ||
                    currentScore < scoreToBeat ||
                    validFormatFound
                ) {
                    scoreToBeat = currentScore;
                    bestMoment = tempConfig;
                    if (validFormatFound) {
                        bestFormatIsValid = true;
                    }
                }
            } else {
                if (currentScore < scoreToBeat) {
                    scoreToBeat = currentScore;
                    bestMoment = tempConfig;
                }
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i),
            dayOrDate = i.day === undefined ? i.date : i.day;
        config._a = map(
            [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
            function (obj) {
                return obj && parseInt(obj, 10);
            }
        );

        configFromArray(config);
    }

    function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig(config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return createInvalid({ nullInput: true });
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
            config._d = input;
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else {
            configFromInput(config);
        }

        if (!isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
            config._d = new Date(hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (isObject(input)) {
            configFromObject(config);
        } else if (isNumber(input)) {
            // from milliseconds
            config._d = new Date(input);
        } else {
            hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC(input, format, locale, strict, isUTC) {
        var c = {};

        if (format === true || format === false) {
            strict = format;
            format = undefined;
        }

        if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
        }

        if (
            (isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)
        ) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function createLocal(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
            'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
            function () {
                var other = createLocal.apply(null, arguments);
                if (this.isValid() && other.isValid()) {
                    return other < this ? this : other;
                } else {
                    return createInvalid();
                }
            }
        ),
        prototypeMax = deprecate(
            'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
            function () {
                var other = createLocal.apply(null, arguments);
                if (this.isValid() && other.isValid()) {
                    return other > this ? this : other;
                } else {
                    return createInvalid();
                }
            }
        );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min() {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max() {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +new Date();
    };

    var ordering = [
        'year',
        'quarter',
        'month',
        'week',
        'day',
        'hour',
        'minute',
        'second',
        'millisecond',
    ];

    function isDurationValid(m) {
        var key,
            unitHasDecimal = false,
            i,
            orderLen = ordering.length;
        for (key in m) {
            if (
                hasOwnProp(m, key) &&
                !(
                    indexOf.call(ordering, key) !== -1 &&
                    (m[key] == null || !isNaN(m[key]))
                )
            ) {
                return false;
            }
        }

        for (i = 0; i < orderLen; ++i) {
            if (m[ordering[i]]) {
                if (unitHasDecimal) {
                    return false; // only allow non-integers for smallest unit
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                    unitHasDecimal = true;
                }
            }
        }

        return true;
    }

    function isValid$1() {
        return this._isValid;
    }

    function createInvalid$1() {
        return createDuration(NaN);
    }

    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        this._isValid = isDurationValid(normalizedInput);

        // representation for dateAddRemove
        this._milliseconds =
            +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days + weeks * 7;
        // It is impossible to translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months + quarters * 3 + years * 12;

        this._data = {};

        this._locale = getLocale();

        this._bubble();
    }

    function isDuration(obj) {
        return obj instanceof Duration;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if (
                (dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))
            ) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    // FORMATTING

    function offset(token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset(),
                sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return (
                sign +
                zeroFill(~~(offset / 60), 2) +
                separator +
                zeroFill(~~offset % 60, 2)
            );
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z', matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher),
            chunk,
            parts,
            minutes;

        if (matches === null) {
            return null;
        }

        chunk = matches[matches.length - 1] || [];
        parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        minutes = +(parts[1] * 60) + toInt(parts[2]);

        return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff =
                (isMoment(input) || isDate(input)
                    ? input.valueOf()
                    : createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
        } else {
            return createLocal(input).local();
        }
    }

    function getDateOffset(m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset());
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                    return this;
                }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    addSubtract(
                        this,
                        createDuration(input - offset, 'm'),
                        1,
                        false
                    );
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone(input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset() {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
                this.utcOffset(tZone);
            } else {
                this.utcOffset(0, true);
            }
        }
        return this;
    }

    function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime() {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {},
            other;

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted =
                this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal() {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        // and further modified to allow for strings containing both week and day
        isoRegex =
            /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration(input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months,
            };
        } else if (isNumber(input) || !isNaN(+input)) {
            duration = {};
            if (key) {
                duration[key] = +input;
            } else {
                duration.milliseconds = +input;
            }
        } else if ((match = aspNetRegex.exec(input))) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign, // the millisecond decimal point is included in the match
            };
        } else if ((match = isoRegex.exec(input))) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
                y: parseIso(match[2], sign),
                M: parseIso(match[3], sign),
                w: parseIso(match[4], sign),
                d: parseIso(match[5], sign),
                h: parseIso(match[6], sign),
                m: parseIso(match[7], sign),
                s: parseIso(match[8], sign),
            };
        } else if (duration == null) {
            // checks for null or undefined
            duration = {};
        } else if (
            typeof duration === 'object' &&
            ('from' in duration || 'to' in duration)
        ) {
            diffRes = momentsDifference(
                createLocal(duration.from),
                createLocal(duration.to)
            );

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        if (isDuration(input) && hasOwnProp(input, '_isValid')) {
            ret._isValid = input._isValid;
        }

        return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso(inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {};

        res.months =
            other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +base.clone().add(res.months, 'M');

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return { milliseconds: 0, months: 0 };
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(
                    name,
                    'moment().' +
                        name +
                        '(period, number) is deprecated. Please use moment().' +
                        name +
                        '(number, period). ' +
                        'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.'
                );
                tmp = val;
                val = period;
                period = tmp;
            }

            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
        };
    }

    function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
        }
        if (days) {
            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
        }
        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
            hooks.updateOffset(mom, days || months);
        }
    }

    var add = createAdder(1, 'add'),
        subtract = createAdder(-1, 'subtract');

    function isString(input) {
        return typeof input === 'string' || input instanceof String;
    }

    // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined
    function isMomentInput(input) {
        return (
            isMoment(input) ||
            isDate(input) ||
            isString(input) ||
            isNumber(input) ||
            isNumberOrStringArray(input) ||
            isMomentInputObject(input) ||
            input === null ||
            input === undefined
        );
    }

    function isMomentInputObject(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input),
            propertyTest = false,
            properties = [
                'years',
                'year',
                'y',
                'months',
                'month',
                'M',
                'days',
                'day',
                'd',
                'dates',
                'date',
                'D',
                'hours',
                'hour',
                'h',
                'minutes',
                'minute',
                'm',
                'seconds',
                'second',
                's',
                'milliseconds',
                'millisecond',
                'ms',
            ],
            i,
            property,
            propertyLen = properties.length;

        for (i = 0; i < propertyLen; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
        }

        return objectTest && propertyTest;
    }

    function isNumberOrStringArray(input) {
        var arrayTest = isArray(input),
            dataTypeTest = false;
        if (arrayTest) {
            dataTypeTest =
                input.filter(function (item) {
                    return !isNumber(item) && isString(input);
                }).length === 0;
        }
        return arrayTest && dataTypeTest;
    }

    function isCalendarSpec(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input),
            propertyTest = false,
            properties = [
                'sameDay',
                'nextDay',
                'lastDay',
                'nextWeek',
                'lastWeek',
                'sameElse',
            ],
            i,
            property;

        for (i = 0; i < properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
        }

        return objectTest && propertyTest;
    }

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6
            ? 'sameElse'
            : diff < -1
            ? 'lastWeek'
            : diff < 0
            ? 'lastDay'
            : diff < 1
            ? 'sameDay'
            : diff < 2
            ? 'nextDay'
            : diff < 7
            ? 'nextWeek'
            : 'sameElse';
    }

    function calendar$1(time, formats) {
        // Support for single parameter, formats only overload to the calendar function
        if (arguments.length === 1) {
            if (!arguments[0]) {
                time = undefined;
                formats = undefined;
            } else if (isMomentInput(arguments[0])) {
                time = arguments[0];
                formats = undefined;
            } else if (isCalendarSpec(arguments[0])) {
                formats = arguments[0];
                time = undefined;
            }
        }
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = hooks.calendarFormat(this, sod) || 'sameElse',
            output =
                formats &&
                (isFunction(formats[format])
                    ? formats[format].call(this, now)
                    : formats[format]);

        return this.format(
            output || this.localeData().calendar(format, this, createLocal(now))
        );
    }

    function clone() {
        return new Moment(this);
    }

    function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween(from, to, units, inclusivity) {
        var localFrom = isMoment(from) ? from : createLocal(from),
            localTo = isMoment(to) ? to : createLocal(to);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
        }
        inclusivity = inclusivity || '()';
        return (
            (inclusivity[0] === '('
                ? this.isAfter(localFrom, units)
                : !this.isBefore(localFrom, units)) &&
            (inclusivity[1] === ')'
                ? this.isBefore(localTo, units)
                : !this.isAfter(localTo, units))
        );
    }

    function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return (
                this.clone().startOf(units).valueOf() <= inputMs &&
                inputMs <= this.clone().endOf(units).valueOf()
            );
        }
    }

    function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
    }

    function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
    }

    function diff(input, units, asFloat) {
        var that, zoneDelta, output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        switch (units) {
            case 'year':
                output = monthDiff(this, that) / 12;
                break;
            case 'month':
                output = monthDiff(this, that);
                break;
            case 'quarter':
                output = monthDiff(this, that) / 3;
                break;
            case 'second':
                output = (this - that) / 1e3;
                break; // 1000
            case 'minute':
                output = (this - that) / 6e4;
                break; // 1000 * 60
            case 'hour':
                output = (this - that) / 36e5;
                break; // 1000 * 60 * 60
            case 'day':
                output = (this - that - zoneDelta) / 864e5;
                break; // 1000 * 60 * 60 * 24, negate dst
            case 'week':
                output = (this - that - zoneDelta) / 6048e5;
                break; // 1000 * 60 * 60 * 24 * 7, negate dst
            default:
                output = this - that;
        }

        return asFloat ? output : absFloor(output);
    }

    function monthDiff(a, b) {
        if (a.date() < b.date()) {
            // end-of-month calculations work correct when the start month has more
            // days than the end month.
            return -monthDiff(b, a);
        }
        // difference in months
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2,
            adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString() {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
        if (!this.isValid()) {
            return null;
        }
        var utc = keepOffset !== true,
            m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(
                m,
                utc
                    ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]'
                    : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ'
            );
        }
        if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            if (utc) {
                return this.toDate().toISOString();
            } else {
                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000)
                    .toISOString()
                    .replace('Z', formatMoment(m, 'Z'));
            }
        }
        return formatMoment(
            m,
            utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ'
        );
    }

    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */
    function inspect() {
        if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
        }
        var func = 'moment',
            zone = '',
            prefix,
            year,
            datetime,
            suffix;
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
        }
        prefix = '[' + func + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
        datetime = '-MM-DD[T]HH:mm:ss.SSS';
        suffix = zone + '[")]';

        return this.format(prefix + year + datetime + suffix);
    }

    function format(inputString) {
        if (!inputString) {
            inputString = this.isUtc()
                ? hooks.defaultFormatUtc
                : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from(time, withoutSuffix) {
        if (
            this.isValid() &&
            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
        ) {
            return createDuration({ to: this, from: time })
                .locale(this.locale())
                .humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }

    function to(time, withoutSuffix) {
        if (
            this.isValid() &&
            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
        ) {
            return createDuration({ from: this, to: time })
                .locale(this.locale())
                .humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale(key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData() {
        return this._locale;
    }

    var MS_PER_SECOND = 1000,
        MS_PER_MINUTE = 60 * MS_PER_SECOND,
        MS_PER_HOUR = 60 * MS_PER_MINUTE,
        MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

    // actual modulo - handles negative numbers (for dates before 1970):
    function mod$1(dividend, divisor) {
        return ((dividend % divisor) + divisor) % divisor;
    }

    function localStartOfDate(y, m, d) {
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return new Date(y, m, d).valueOf();
        }
    }

    function utcStartOfDate(y, m, d) {
        // Date.UTC remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return Date.UTC(y, m, d);
        }
    }

    function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year(), 0, 1);
                break;
            case 'quarter':
                time = startOfDate(
                    this.year(),
                    this.month() - (this.month() % 3),
                    1
                );
                break;
            case 'month':
                time = startOfDate(this.year(), this.month(), 1);
                break;
            case 'week':
                time = startOfDate(
                    this.year(),
                    this.month(),
                    this.date() - this.weekday()
                );
                break;
            case 'isoWeek':
                time = startOfDate(
                    this.year(),
                    this.month(),
                    this.date() - (this.isoWeekday() - 1)
                );
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date());
                break;
            case 'hour':
                time = this._d.valueOf();
                time -= mod$1(
                    time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                    MS_PER_HOUR
                );
                break;
            case 'minute':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_MINUTE);
                break;
            case 'second':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_SECOND);
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year() + 1, 0, 1) - 1;
                break;
            case 'quarter':
                time =
                    startOfDate(
                        this.year(),
                        this.month() - (this.month() % 3) + 3,
                        1
                    ) - 1;
                break;
            case 'month':
                time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                break;
            case 'week':
                time =
                    startOfDate(
                        this.year(),
                        this.month(),
                        this.date() - this.weekday() + 7
                    ) - 1;
                break;
            case 'isoWeek':
                time =
                    startOfDate(
                        this.year(),
                        this.month(),
                        this.date() - (this.isoWeekday() - 1) + 7
                    ) - 1;
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                break;
            case 'hour':
                time = this._d.valueOf();
                time +=
                    MS_PER_HOUR -
                    mod$1(
                        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                        MS_PER_HOUR
                    ) -
                    1;
                break;
            case 'minute':
                time = this._d.valueOf();
                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                break;
            case 'second':
                time = this._d.valueOf();
                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 60000;
    }

    function unix() {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate() {
        return new Date(this.valueOf());
    }

    function toArray() {
        var m = this;
        return [
            m.year(),
            m.month(),
            m.date(),
            m.hour(),
            m.minute(),
            m.second(),
            m.millisecond(),
        ];
    }

    function toObject() {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds(),
        };
    }

    function toJSON() {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2() {
        return isValid(this);
    }

    function parsingFlags() {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt() {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict,
        };
    }

    addFormatToken('N', 0, 0, 'eraAbbr');
    addFormatToken('NN', 0, 0, 'eraAbbr');
    addFormatToken('NNN', 0, 0, 'eraAbbr');
    addFormatToken('NNNN', 0, 0, 'eraName');
    addFormatToken('NNNNN', 0, 0, 'eraNarrow');

    addFormatToken('y', ['y', 1], 'yo', 'eraYear');
    addFormatToken('y', ['yy', 2], 0, 'eraYear');
    addFormatToken('y', ['yyy', 3], 0, 'eraYear');
    addFormatToken('y', ['yyyy', 4], 0, 'eraYear');

    addRegexToken('N', matchEraAbbr);
    addRegexToken('NN', matchEraAbbr);
    addRegexToken('NNN', matchEraAbbr);
    addRegexToken('NNNN', matchEraName);
    addRegexToken('NNNNN', matchEraNarrow);

    addParseToken(
        ['N', 'NN', 'NNN', 'NNNN', 'NNNNN'],
        function (input, array, config, token) {
            var era = config._locale.erasParse(input, token, config._strict);
            if (era) {
                getParsingFlags(config).era = era;
            } else {
                getParsingFlags(config).invalidEra = input;
            }
        }
    );

    addRegexToken('y', matchUnsigned);
    addRegexToken('yy', matchUnsigned);
    addRegexToken('yyy', matchUnsigned);
    addRegexToken('yyyy', matchUnsigned);
    addRegexToken('yo', matchEraYearOrdinal);

    addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
    addParseToken(['yo'], function (input, array, config, token) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
            match = input.match(config._locale._eraYearOrdinalRegex);
        }

        if (config._locale.eraYearOrdinalParse) {
            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
            array[YEAR] = parseInt(input, 10);
        }
    });

    function localeEras(m, format) {
        var i,
            l,
            date,
            eras = this._eras || getLocale('en')._eras;
        for (i = 0, l = eras.length; i < l; ++i) {
            switch (typeof eras[i].since) {
                case 'string':
                    // truncate time
                    date = hooks(eras[i].since).startOf('day');
                    eras[i].since = date.valueOf();
                    break;
            }

            switch (typeof eras[i].until) {
                case 'undefined':
                    eras[i].until = +Infinity;
                    break;
                case 'string':
                    // truncate time
                    date = hooks(eras[i].until).startOf('day').valueOf();
                    eras[i].until = date.valueOf();
                    break;
            }
        }
        return eras;
    }

    function localeErasParse(eraName, format, strict) {
        var i,
            l,
            eras = this.eras(),
            name,
            abbr,
            narrow;
        eraName = eraName.toUpperCase();

        for (i = 0, l = eras.length; i < l; ++i) {
            name = eras[i].name.toUpperCase();
            abbr = eras[i].abbr.toUpperCase();
            narrow = eras[i].narrow.toUpperCase();

            if (strict) {
                switch (format) {
                    case 'N':
                    case 'NN':
                    case 'NNN':
                        if (abbr === eraName) {
                            return eras[i];
                        }
                        break;

                    case 'NNNN':
                        if (name === eraName) {
                            return eras[i];
                        }
                        break;

                    case 'NNNNN':
                        if (narrow === eraName) {
                            return eras[i];
                        }
                        break;
                }
            } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
                return eras[i];
            }
        }
    }

    function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? +1 : -1;
        if (year === undefined) {
            return hooks(era.since).year();
        } else {
            return hooks(era.since).year() + (year - era.offset) * dir;
        }
    }

    function getEraName() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].name;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].name;
            }
        }

        return '';
    }

    function getEraNarrow() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].narrow;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].narrow;
            }
        }

        return '';
    }

    function getEraAbbr() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].abbr;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].abbr;
            }
        }

        return '';
    }

    function getEraYear() {
        var i,
            l,
            dir,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            dir = eras[i].since <= eras[i].until ? +1 : -1;

            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (
                (eras[i].since <= val && val <= eras[i].until) ||
                (eras[i].until <= val && val <= eras[i].since)
            ) {
                return (
                    (this.year() - hooks(eras[i].since).year()) * dir +
                    eras[i].offset
                );
            }
        }

        return this.year();
    }

    function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, '_erasNameRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
    }

    function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, '_erasAbbrRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
    }

    function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, '_erasNarrowRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
    }

    function matchEraAbbr(isStrict, locale) {
        return locale.erasAbbrRegex(isStrict);
    }

    function matchEraName(isStrict, locale) {
        return locale.erasNameRegex(isStrict);
    }

    function matchEraNarrow(isStrict, locale) {
        return locale.erasNarrowRegex(isStrict);
    }

    function matchEraYearOrdinal(isStrict, locale) {
        return locale._eraYearOrdinalRegex || matchUnsigned;
    }

    function computeErasParse() {
        var abbrPieces = [],
            namePieces = [],
            narrowPieces = [],
            mixedPieces = [],
            i,
            l,
            eras = this.eras();

        for (i = 0, l = eras.length; i < l; ++i) {
            namePieces.push(regexEscape(eras[i].name));
            abbrPieces.push(regexEscape(eras[i].abbr));
            narrowPieces.push(regexEscape(eras[i].narrow));

            mixedPieces.push(regexEscape(eras[i].name));
            mixedPieces.push(regexEscape(eras[i].abbr));
            mixedPieces.push(regexEscape(eras[i].narrow));
        }

        this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
        this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
        this._erasNarrowRegex = new RegExp(
            '^(' + narrowPieces.join('|') + ')',
            'i'
        );
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken(token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg', 'weekYear');
    addWeekYearFormatToken('ggggg', 'weekYear');
    addWeekYearFormatToken('GGGG', 'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);

    // PARSING

    addRegexToken('G', matchSigned);
    addRegexToken('g', matchSigned);
    addRegexToken('GG', match1to2, match2);
    addRegexToken('gg', match1to2, match2);
    addRegexToken('GGGG', match1to4, match4);
    addRegexToken('gggg', match1to4, match4);
    addRegexToken('GGGGG', match1to6, match6);
    addRegexToken('ggggg', match1to6, match6);

    addWeekParseToken(
        ['gggg', 'ggggg', 'GGGG', 'GGGGG'],
        function (input, week, config, token) {
            week[token.substr(0, 2)] = toInt(input);
        }
    );

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(
            this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy
        );
    }

    function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(
            this,
            input,
            this.isoWeek(),
            this.isoWeekday(),
            1,
            4
        );
    }

    function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
    }

    function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
    }

    function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PRIORITY

    addUnitPriority('quarter', 7);

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter(input) {
        return input == null
            ? Math.ceil((this.month() + 1) / 3)
            : this.month((input - 1) * 3 + (this.month() % 3));
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PRIORITY
    addUnitPriority('date', 9);

    // PARSING

    addRegexToken('D', match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        // TODO: Remove "ordinalParse" fallback in next major release.
        return isStrict
            ? locale._dayOfMonthOrdinalParse || locale._ordinalParse
            : locale._dayOfMonthOrdinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PRIORITY
    addUnitPriority('dayOfYear', 4);

    // PARSING

    addRegexToken('DDD', match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear(input) {
        var dayOfYear =
            Math.round(
                (this.clone().startOf('day') - this.clone().startOf('year')) / 864e5
            ) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PRIORITY

    addUnitPriority('minute', 14);

    // PARSING

    addRegexToken('m', match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PRIORITY

    addUnitPriority('second', 15);

    // PARSING

    addRegexToken('s', match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });

    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PRIORITY

    addUnitPriority('millisecond', 16);

    // PARSING

    addRegexToken('S', match1to3, match1);
    addRegexToken('SS', match1to3, match2);
    addRegexToken('SSS', match1to3, match3);

    var token, getSetMillisecond;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }

    getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z', 0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr() {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName() {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto = Moment.prototype;

    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    if (typeof Symbol !== 'undefined' && Symbol.for != null) {
        proto[Symbol.for('nodejs.util.inspect.custom')] = function () {
            return 'Moment<' + this.format() + '>';
        };
    }
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.eraName = getEraName;
    proto.eraNarrow = getEraNarrow;
    proto.eraAbbr = getEraAbbr;
    proto.eraYear = getEraYear;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.weeksInWeekYear = getWeeksInWeekYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate(
        'dates accessor is deprecated. Use date instead.',
        getSetDayOfMonth
    );
    proto.months = deprecate(
        'months accessor is deprecated. Use month instead',
        getSetMonth
    );
    proto.years = deprecate(
        'years accessor is deprecated. Use year instead',
        getSetYear
    );
    proto.zone = deprecate(
        'moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',
        getSetZone
    );
    proto.isDSTShifted = deprecate(
        'isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',
        isDaylightSavingTimeShifted
    );

    function createUnix(input) {
        return createLocal(input * 1000);
    }

    function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat(string) {
        return string;
    }

    var proto$1 = Locale.prototype;

    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set;
    proto$1.eras = localeEras;
    proto$1.erasParse = localeErasParse;
    proto$1.erasConvertYear = localeErasConvertYear;
    proto$1.erasAbbrRegex = erasAbbrRegex;
    proto$1.erasNameRegex = erasNameRegex;
    proto$1.erasNarrowRegex = erasNarrowRegex;

    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;

    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;

    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;

    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1(format, index, field, setter) {
        var locale = getLocale(),
            utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl(format, index, field) {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return get$1(format, index, field, 'month');
        }

        var i,
            out = [];
        for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl(localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0,
            i,
            out = [];

        if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
        }

        for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function listMonths(format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort(format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
        eras: [
            {
                since: '0001-01-01',
                until: +Infinity,
                offset: 1,
                name: 'Anno Domini',
                narrow: 'AD',
                abbr: 'AD',
            },
            {
                since: '0000-12-31',
                until: -Infinity,
                offset: 1,
                name: 'Before Christ',
                narrow: 'BC',
                abbr: 'BC',
            },
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function (number) {
            var b = number % 10,
                output =
                    toInt((number % 100) / 10) === 1
                        ? 'th'
                        : b === 1
                        ? 'st'
                        : b === 2
                        ? 'nd'
                        : b === 3
                        ? 'rd'
                        : 'th';
            return number + output;
        },
    });

    // Side effect imports

    hooks.lang = deprecate(
        'moment.lang is deprecated. Use moment.locale instead.',
        getSetGlobalLocale
    );
    hooks.langData = deprecate(
        'moment.langData is deprecated. Use moment.localeData instead.',
        getLocale
    );

    var mathAbs = Math.abs;

    function abs() {
        var data = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);

        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);

        return this;
    }

    function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
    }

    function absCeil(number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble() {
        var milliseconds = this._milliseconds,
            days = this._days,
            months = this._months,
            data = this._data,
            seconds,
            minutes,
            hours,
            years,
            monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (
            !(
                (milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0)
            )
        ) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds = absFloor(milliseconds / 1000);
        data.seconds = seconds % 60;

        minutes = absFloor(seconds / 60);
        data.minutes = minutes % 60;

        hours = absFloor(minutes / 60);
        data.hours = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days = days;
        data.months = months;
        data.years = years;

        return this;
    }

    function daysToMonths(days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return (days * 4800) / 146097;
    }

    function monthsToDays(months) {
        // the reverse of daysToMonths
        return (months * 146097) / 4800;
    }

    function as(units) {
        if (!this.isValid()) {
            return NaN;
        }
        var days,
            months,
            milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'quarter' || units === 'year') {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            switch (units) {
                case 'month':
                    return months;
                case 'quarter':
                    return months / 3;
                case 'year':
                    return months / 12;
            }
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week':
                    return days / 7 + milliseconds / 6048e5;
                case 'day':
                    return days + milliseconds / 864e5;
                case 'hour':
                    return days * 24 + milliseconds / 36e5;
                case 'minute':
                    return days * 1440 + milliseconds / 6e4;
                case 'second':
                    return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond':
                    return Math.floor(days * 864e5) + milliseconds;
                default:
                    throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function valueOf$1() {
        if (!this.isValid()) {
            return NaN;
        }
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs(alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms'),
        asSeconds = makeAs('s'),
        asMinutes = makeAs('m'),
        asHours = makeAs('h'),
        asDays = makeAs('d'),
        asWeeks = makeAs('w'),
        asMonths = makeAs('M'),
        asQuarters = makeAs('Q'),
        asYears = makeAs('y');

    function clone$1() {
        return createDuration(this);
    }

    function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
        return function () {
            return this.isValid() ? this._data[name] : NaN;
        };
    }

    var milliseconds = makeGetter('milliseconds'),
        seconds = makeGetter('seconds'),
        minutes = makeGetter('minutes'),
        hours = makeGetter('hours'),
        days = makeGetter('days'),
        months = makeGetter('months'),
        years = makeGetter('years');

    function weeks() {
        return absFloor(this.days() / 7);
    }

    var round = Math.round,
        thresholds = {
            ss: 44, // a few seconds to seconds
            s: 45, // seconds to minute
            m: 45, // minutes to hour
            h: 22, // hours to day
            d: 26, // days to month/week
            w: null, // weeks to month
            M: 11, // months to year
        };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
        var duration = createDuration(posNegDuration).abs(),
            seconds = round(duration.as('s')),
            minutes = round(duration.as('m')),
            hours = round(duration.as('h')),
            days = round(duration.as('d')),
            months = round(duration.as('M')),
            weeks = round(duration.as('w')),
            years = round(duration.as('y')),
            a =
                (seconds <= thresholds.ss && ['s', seconds]) ||
                (seconds < thresholds.s && ['ss', seconds]) ||
                (minutes <= 1 && ['m']) ||
                (minutes < thresholds.m && ['mm', minutes]) ||
                (hours <= 1 && ['h']) ||
                (hours < thresholds.h && ['hh', hours]) ||
                (days <= 1 && ['d']) ||
                (days < thresholds.d && ['dd', days]);

        if (thresholds.w != null) {
            a =
                a ||
                (weeks <= 1 && ['w']) ||
                (weeks < thresholds.w && ['ww', weeks]);
        }
        a = a ||
            (months <= 1 && ['M']) ||
            (months < thresholds.M && ['MM', months]) ||
            (years <= 1 && ['y']) || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof roundingFunction === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === 's') {
            thresholds.ss = limit - 1;
        }
        return true;
    }

    function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var withSuffix = false,
            th = thresholds,
            locale,
            output;

        if (typeof argWithSuffix === 'object') {
            argThresholds = argWithSuffix;
            argWithSuffix = false;
        }
        if (typeof argWithSuffix === 'boolean') {
            withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === 'object') {
            th = Object.assign({}, thresholds, argThresholds);
            if (argThresholds.s != null && argThresholds.ss == null) {
                th.ss = argThresholds.s - 1;
            }
        }

        locale = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
        return (x > 0) - (x < 0) || +x;
    }

    function toISOString$1() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var seconds = abs$1(this._milliseconds) / 1000,
            days = abs$1(this._days),
            months = abs$1(this._months),
            minutes,
            hours,
            years,
            s,
            total = this.asSeconds(),
            totalSign,
            ymSign,
            daysSign,
            hmsSign;

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes = absFloor(seconds / 60);
        hours = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';

        totalSign = total < 0 ? '-' : '';
        ymSign = sign(this._months) !== sign(total) ? '-' : '';
        daysSign = sign(this._days) !== sign(total) ? '-' : '';
        hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

        return (
            totalSign +
            'P' +
            (years ? ymSign + years + 'Y' : '') +
            (months ? ymSign + months + 'M' : '') +
            (days ? daysSign + days + 'D' : '') +
            (hours || minutes || seconds ? 'T' : '') +
            (hours ? hmsSign + hours + 'H' : '') +
            (minutes ? hmsSign + minutes + 'M' : '') +
            (seconds ? hmsSign + s + 'S' : '')
        );
    }

    var proto$2 = Duration.prototype;

    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;

    proto$2.toIsoString = deprecate(
        'toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',
        toISOString$1
    );
    proto$2.lang = lang;

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    //! moment.js

    hooks.version = '2.29.4';

    setHookCallback(createLocal);

    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto;

    // currently HTML5 input type only supports 24-hour formats
    hooks.HTML5_FMT = {
        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm', // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss', // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS', // <input type="datetime-local" step="0.001" />
        DATE: 'YYYY-MM-DD', // <input type="date" />
        TIME: 'HH:mm', // <input type="time" />
        TIME_SECONDS: 'HH:mm:ss', // <input type="time" step="1" />
        TIME_MS: 'HH:mm:ss.SSS', // <input type="time" step="0.001" />
        WEEK: 'GGGG-[W]WW', // <input type="week" />
        MONTH: 'YYYY-MM', // <input type="month" />
    };

    return hooks;

})));

},{}],159:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],160:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.App = void 0;
const record_1 = require("@quenk/noni/lib/data/record");
const link_1 = require("../../../lib/content/link");
const util_1 = require("../../../lib/util");
const app_1 = require("./wml/app");
const pages_1 = require("./pages");
const pages2Pages = () => {
    let tmp = (0, record_1.group)(pages_1.pages, (_, k) => k.split('_')[0]);
    for (let sec in tmp)
        if (tmp.hasOwnProperty(sec)) {
            let newSec = {};
            for (let name in tmp[sec])
                if (tmp[sec].hasOwnProperty(name)) {
                    newSec[name.split('_')[1]] = tmp[sec][name];
                }
            tmp[sec] = newSec;
        }
    return tmp;
};
const pages2Modules = () => {
    return (0, record_1.reduce)(pages_1.pages, {}, (p, c, k) => {
        p[k.split('_')[1]] = c;
        return p;
    });
};
/**
 * App displaying all the wml widgets.
 */
class App {
    constructor(root) {
        this.root = root;
        this.view = new app_1.Main(this);
        this.content = [];
        this.page = '';
        this.pages = pages2Pages();
        this.modules = pages2Modules();
        this.values = {
            id: {
                layout: 'layout'
            }
        };
        /**
         * navigate is called when the user clicks on a
         * navigation link.
         */
        this.navigate = ({ name }) => {
            this.page = name;
            if (this.modules.hasOwnProperty(name)) {
                (0, util_1.getById)(this.view, this.values.id.layout)
                    .map((d) => d.setContent([this.modules[name].view.render()]));
            }
        };
        /**
         * toggleDrawer
         */
        this.toggleDrawer = () => {
            (0, util_1.getById)(this.view, this.values.id.layout)
                .map((d) => d.toggle());
        };
    }
    /**
     * run the application.
     */
    run() {
        let { root } = this;
        while (root.lastChild)
            root.removeChild(root.lastChild);
        root.appendChild(this.view.render());
        let path = window.location.hash.split('#')[1];
        path = path ? path.split('/').join('') : '';
        this.navigate(new link_1.LinkClickedEvent(path, path));
    }
    static main(root) {
        return new App(root);
    }
}
exports.App = App;
App.main(document.getElementById('app')).run();

},{"../../../lib/content/link":7,"../../../lib/util":147,"./pages":265,"./wml/app":268,"@quenk/noni/lib/data/record":152}],161:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.results = void 0;
exports.results = [
    { label: 'Asus', value: 'Asus' },
    { label: 'MSI', value: 'MSI' },
    { label: 'Gigabyte', value: 'Gigabyte' },
    { label: 'Gigas', value: 'Gigas' },
    { label: 'AsusTek', value: 'AsusTek' },
    { label: 'Asusuga', value: 'Asusuga' },
    { label: 'Qualcomm', value: 'Qualcomm' },
    { label: 'Qualitative', value: 'Qualitatve' },
    { label: 'Kirpalani\'s', value: 'Kirpalani\'s' },
    { label: 'Asunder', value: 'Asunder' }
];

},{}],162:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbedPage = void 0;
const views = require("./wml/embed");
class EmbedPage {
    constructor() {
        this.view = new views.Main(this);
        this.values = {
            jojo: 'https://www.youtube.com/embed/1bbr5tMuSnc',
            win: 'https://www.youtube.com/embed/itgSyPxfqoE',
            max: 'https://www.youtube.com/embed/9rrzQSbk9hI',
            allow: 'accelerometer; autoplay; encrypted-media; gyroscope; ' +
                'picture-in-picture'
        };
    }
}
exports.EmbedPage = EmbedPage;
exports.default = new EmbedPage();

},{"./wml/embed":163}],163:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const grid_1 = require("../../../../../../lib/layout/grid");
;
const embed_1 = require("../../../../../../lib/content/embed");
;
const demo_1 = require("../../../widgets/demo");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.node('h1', {}, [
                    __document.createTextNode('Embed')
                ]),
                __this.widget(new grid_1.GridLayout({}, [
                    __this.widget(new grid_1.Row({}, [
                        __this.widget(new grid_1.Column({ 'span': 4 }, [
                            __this.widget(new embed_1.Embed({ 'className': '-aspect-ratio-16x9' }, [
                                __this.node('iframe', { 'src': __context.values.jojo, 'allow': __context.values.allow }, [])
                            ]), { 'className': '-aspect-ratio-16x9' })
                        ]), { 'span': 4 }),
                        __this.widget(new grid_1.Column({ 'span': 4 }, [
                            __this.widget(new embed_1.Embed({ 'className': '-aspect-ratio-4x3' }, [
                                __this.node('iframe', { 'src': __context.values.win, 'allow': __context.values.allow }, [])
                            ]), { 'className': '-aspect-ratio-4x3' })
                        ]), { 'span': 4 }),
                        __this.widget(new grid_1.Column({ 'span': 4 }, [
                            __this.widget(new embed_1.Embed({ 'className': '-aspect-ratio-16x9' }, [
                                __this.node('iframe', { 'src': __context.values.max, 'allow': __context.values.allow }, [])
                            ]), { 'className': '-aspect-ratio-16x9' })
                        ]), { 'span': 4 })
                    ]), {})
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/content/embed":5,"../../../../../../lib/layout/grid":117,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],164:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LinkPage = void 0;
const views = require("./views");
class LinkPage {
    constructor() {
        this.view = new views.Main(this);
        this.values = {
            onClick: () => alert('You clicked me?')
        };
    }
}
exports.LinkPage = LinkPage;
exports.default = new LinkPage();

},{"./views":165}],165:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const link_1 = require("../../../../../lib/content/link");
;
const demo_1 = require("../../widgets/demo");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.node('h1', {}, [
                    __document.createTextNode('Links')
                ]),
                __this.node('p', {}, [
                    __document.createTextNode('This is a '),
                    __this.widget(new link_1.Link({ 'href': '#link' }, [
                        __document.createTextNode('link')
                    ]), { 'href': '#link' }),
                    __document.createTextNode('.')
                ]),
                __this.node('p', {}, [
                    __document.createTextNode('This is a '),
                    __this.widget(new link_1.Link({ 'href': '#disabled', 'disabled': true }, [
                        __document.createTextNode('disabled')
                    ]), { 'href': '#disabled', 'disabled': true }),
                    __document.createTextNode(' link.')
                ]),
                __this.node('p', {}, [
                    __document.createTextNode('Links can also '),
                    __this.widget(new link_1.Link({ 'text': 'specify' }, []), { 'text': 'specify' }),
                    __document.createTextNode(' contents a the text attribute')
                ]),
                __this.node('p', {}, [
                    __document.createTextNode('Links can also have '),
                    __this.widget(new link_1.Link({ 'onClick': __context.values.onClick, 'text': 'handlers' }, []), { 'onClick': __context.values.onClick, 'text': 'handlers' })
                ]),
                __this.node('p', {}, [
                    __document.createTextNode('Disabled link '),
                    __this.widget(new link_1.Link({ 'onClick': __context.values.onClick, 'disabled': true, 'text': 'handlers' }, []), { 'onClick': __context.values.onClick, 'disabled': true, 'text': 'handlers' }),
                    __document.createTextNode('\u000a     do nothing. \u000a  ')
                ]),
                __this.node('p', {}, [
                    __document.createTextNode('You can remove the underline using the \u000a     '),
                    __this.widget(new link_1.Link({ 'text': '-ww-no-decoration', 'className': '-ww-no-decoration' }, []), { 'text': '-ww-no-decoration', 'className': '-ww-no-decoration' }),
                    __document.createTextNode(' modifier.\u000a  ')
                ])
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../lib/content/link":7,"../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],166:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MediaDescriptionPage = void 0;
const views = require("./wml/media-description");
class MediaDescriptionPage {
    constructor() {
        this.view = new views.Main(this);
        this.values = {};
    }
}
exports.MediaDescriptionPage = MediaDescriptionPage;
exports.default = new MediaDescriptionPage();

},{"./wml/media-description":167}],167:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const media_description_1 = require("../../../../../../lib/content/media-description");
;
const demo_1 = require("../../../widgets/demo");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.node('h1', {}, [
                    __document.createTextNode('Media Description')
                ]),
                __this.widget(new media_description_1.MediaDescription({}, [
                    __this.widget(new media_description_1.Media({}, [
                        __this.node('img', { 'alt': 'placeholder', 'src': 'https://via.placeholder.com/140x100' }, [])
                    ]), {}),
                    __this.widget(new media_description_1.Description({}, [
                        __this.node('h4', {}, [
                            __document.createTextNode('Description')
                        ]),
                        __this.node('p', {}, [
                            __document.createTextNode('Located at the side related to the image on the left.')
                        ])
                    ]), {})
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/content/media-description":9,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],168:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OverlayPage = void 0;
const views = require("./wml/overlay");
class OverlayPage {
    constructor() {
        this.view = new views.Main(this);
        this.values = {
            onClick: () => {
                let mO = this.view.findById('overlay');
                if (mO.isJust())
                    mO.get().close();
            }
        };
    }
}
exports.OverlayPage = OverlayPage;
exports.default = new OverlayPage();

},{"./wml/overlay":169}],169:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const overlay_1 = require("../../../../../../lib/content/overlay");
;
const demo_1 = require("../../../widgets/demo");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.node('h1', {}, [
                    __document.createTextNode('Overlay')
                ]),
                __this.widget(new overlay_1.Overlay({ wml: { 'id': 'overlay' }, 'onClick': __context.values.onClick }, []), { wml: { 'id': 'overlay' }, 'onClick': __context.values.onClick })
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/content/overlay":14,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],170:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TagPage = void 0;
const views = require("./wml/tag");
const style_1 = require("../../../../../lib/content/style");
class TagPage {
    constructor() {
        this.view = new views.Main(this);
        this.values = {
            capitalize: (s) => `${s[0].toUpperCase()}${s.slice(1)}`,
            styles: [
                style_1.Style.Default,
                style_1.Style.Primary,
                style_1.Style.Success,
                style_1.Style.Info,
                style_1.Style.Warning,
                style_1.Style.Error
            ]
        };
    }
}
exports.TagPage = TagPage;
exports.default = new TagPage();

},{"../../../../../lib/content/style":20,"./wml/tag":171}],171:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const tag_1 = require("../../../../../../lib/content/tag");
;
const demo_1 = require("../../../widgets/demo");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.widget(new demo_1.Demo({}, [
                    __this.node('h1', {}, [
                        __document.createTextNode('Tag')
                    ]),
                    __this.node('p', {}, [
                        __this.node('h2', {}, [
                            __document.createTextNode('Styles')
                        ]),
                        ...__forIn(__context.values.styles, (v, _$$i, _$$all) => ([
                            __this.widget(new tag_1.Tag({ 'style': v, 'text': __context.values.capitalize(v) }, []), { 'style': v, 'text': __context.values.capitalize(v) })
                        ]), () => ([]))
                    ])
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/content/tag":21,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],172:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ThumbnailPage = void 0;
const views = require("./wml/thumbnail");
class ThumbnailPage {
    constructor() {
        this.view = new views.Main(this);
        this.values = {
            onClick: () => alert('You clicked it!')
        };
    }
}
exports.ThumbnailPage = ThumbnailPage;
exports.default = new ThumbnailPage();

},{"./wml/thumbnail":173}],173:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const thumbnail_1 = require("../../../../../../lib/content/thumbnail");
;
const grid_1 = require("../../../../../../lib/layout/grid");
;
const demo_1 = require("../../../widgets/demo");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.node('h1', {}, [
                    __document.createTextNode('Thumbnail')
                ]),
                __this.widget(new grid_1.GridLayout({}, [
                    __this.widget(new grid_1.Row({}, [
                        __this.widget(new grid_1.Column({ 'span': 4 }, [
                            __this.widget(new thumbnail_1.Thumbnail({}, [
                                __this.node('img', { 'alt': 'placeholder', 'src': 'https://via.placeholder.com/171x180', 'style': 'width:100%;height:100%;display:block' }, [])
                            ]), {})
                        ]), { 'span': 4 }),
                        __this.widget(new grid_1.Column({ 'span': 4 }, [
                            __this.widget(new thumbnail_1.Thumbnail({ 'onClick': __context.values.onClick }, [
                                __this.node('img', { 'alt': 'placeholder', 'src': 'https://via.placeholder.com/171x180', 'style': 'width:100%;height:100%;display:block' }, [])
                            ]), { 'onClick': __context.values.onClick })
                        ]), { 'span': 4 }),
                        __this.widget(new grid_1.Column({ 'span': 4 }, [
                            __this.widget(new thumbnail_1.Thumbnail({ 'href': '#' }, [
                                __this.node('img', { 'alt': 'placeholder', 'src': 'https://via.placeholder.com/171x180', 'style': 'width:100%;height:100%;display:block' }, [])
                            ]), { 'href': '#' })
                        ]), { 'span': 4 })
                    ]), {}),
                    __this.widget(new grid_1.Row({}, [
                        __this.widget(new grid_1.Column({ 'span': 4 }, [
                            __this.widget(new thumbnail_1.Thumbnail({}, [
                                __this.node('img', { 'alt': 'placeholder', 'src': 'https://via.placeholder.com/171x180', 'style': 'width:100%;height:100%;display:block' }, []),
                                __this.widget(new thumbnail_1.Caption({}, [
                                    __this.node('h4', {}, [
                                        __document.createTextNode('Caption')
                                    ]),
                                    __this.node('p', {}, [
                                        __document.createTextNode('Describes the thumbnail in minor detail.')
                                    ])
                                ]), {})
                            ]), {})
                        ]), { 'span': 4 }),
                        __this.widget(new grid_1.Column({ 'span': 4 }, [
                            __this.widget(new thumbnail_1.Thumbnail({ 'onClick': __context.values.onClick }, [
                                __this.node('img', { 'alt': 'placeholder', 'src': 'https://via.placeholder.com/171x180', 'style': 'width:100%;height:100%;display:block' }, []),
                                __this.widget(new thumbnail_1.Caption({}, [
                                    __this.node('h4', {}, [
                                        __document.createTextNode('Caption')
                                    ]),
                                    __this.node('p', {}, [
                                        __document.createTextNode('Describes the thumbnail in minor detail.')
                                    ])
                                ]), {})
                            ]), { 'onClick': __context.values.onClick })
                        ]), { 'span': 4 }),
                        __this.widget(new grid_1.Column({ 'span': 4 }, [
                            __this.widget(new thumbnail_1.Thumbnail({ 'href': '#' }, [
                                __this.node('img', { 'alt': 'placeholder', 'src': 'https://via.placeholder.com/171x180', 'style': 'width:100%;height:100%;display:block' }, []),
                                __this.widget(new thumbnail_1.Caption({}, [
                                    __this.node('h4', {}, [
                                        __document.createTextNode('Caption')
                                    ]),
                                    __this.node('p', {}, [
                                        __document.createTextNode('Describes the thumbnail in minor detail.')
                                    ])
                                ]), {})
                            ]), { 'href': '#' })
                        ]), { 'span': 4 })
                    ]), {})
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/content/thumbnail":23,"../../../../../../lib/layout/grid":117,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],174:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ButtonGroupPage = void 0;
const views = require("./wml/button-group");
class ButtonGroupPage {
    constructor() {
        this.view = new views.Main(this);
    }
}
exports.ButtonGroupPage = ButtonGroupPage;
exports.default = new ButtonGroupPage();

},{"./wml/button-group":175}],175:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const demo_1 = require("../../../widgets/demo");
;
const button_1 = require("../../../../../../lib/control/button");
;
const button_group_1 = require("../../../../../../lib/control/button-group");
;
const drop_down_1 = require("../../../../../../lib/control/drop-down");
;
const menu_1 = require("../../../../../../lib/menu/menu");
;
const item_1 = require("../../../../../../lib/menu/item");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.node('p', {}, [
                    __this.widget(new button_group_1.ButtonGroup({}, [
                        __this.widget(new button_1.Button({ 'text': 'one' }, []), { 'text': 'one' }),
                        __this.widget(new button_1.Button({ 'text': 'two', 'active': true }, []), { 'text': 'two', 'active': true }),
                        __this.widget(new button_1.Button({ 'text': 'four' }, []), { 'text': 'four' })
                    ]), {})
                ]),
                __this.node('p', {}, [
                    __this.widget(new button_group_1.ButtonGroup({}, [
                        __this.widget(new button_1.Button({ 'text': 'one' }, []), { 'text': 'one' }),
                        __this.widget(new button_1.Button({ 'text': 'two' }, []), { 'text': 'two' }),
                        __this.widget(new button_1.Button({ 'text': 'four' }, []), { 'text': 'four' })
                    ]), {})
                ]),
                __this.node('p', {}, [
                    __this.widget(new button_group_1.ButtonGroup({}, [
                        __this.widget(new button_1.Button({ 'text': 'one' }, []), { 'text': 'one' })
                    ]), {})
                ]),
                __this.node('p', {}, [
                    __this.widget(new button_group_1.ButtonGroup({}, [
                        __this.widget(new button_1.Button({ 'text': 'one' }, []), { 'text': 'one' }),
                        __this.widget(new drop_down_1.DropDown({ 'buttonText': 'two' }, [
                            __this.widget(new menu_1.Menu({}, [
                                __this.widget(new item_1.Item({}, [
                                    __this.node('a', { 'href': '#' }, [
                                        __document.createTextNode('Link')
                                    ])
                                ]), {}),
                                __this.widget(new item_1.Item({}, [
                                    __this.node('a', { 'href': '#' }, [
                                        __document.createTextNode('Link')
                                    ])
                                ]), {}),
                                __this.widget(new item_1.Item({}, [
                                    __this.node('a', { 'href': '#' }, [
                                        __document.createTextNode('Link')
                                    ])
                                ]), {})
                            ]), {})
                        ]), { 'buttonText': 'two' }),
                        __this.widget(new button_1.Button({ 'text': 'three' }, []), { 'text': 'three' })
                    ]), {})
                ])
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/control/button":29,"../../../../../../lib/control/button-group":25,"../../../../../../lib/control/drop-down":39,"../../../../../../lib/menu/item":140,"../../../../../../lib/menu/menu":142,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],176:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ButtonSelectPage = void 0;
const views = require("./wml/button-select");
class ButtonSelectPage {
    constructor() {
        this.view = new views.Main(this);
        this.values = {
            options: [
                { text: 'Asus', value: 'Asus' },
                { text: 'MSI', value: 'MSI' },
                { text: 'Gigabyte', value: 'Gigabyte' }
            ],
            value: 'MSI',
            values: ['MSI']
        };
        this.onChange = ({ value, name }) => {
            this
                .view
                .findById(`${name}-content`)
                .map((e) => {
                while (e.lastChild)
                    e.removeChild(e.lastChild);
                e.appendChild(document.createTextNode(String(value)));
            });
        };
        this.onChangeMulti = ({ value, name }) => {
            this
                .view
                .findById(`${name}-content`)
                .map((e) => {
                while (e.lastChild)
                    e.removeChild(e.lastChild);
                e.appendChild(document.createTextNode(String(value)));
            });
        };
    }
}
exports.ButtonSelectPage = ButtonSelectPage;
exports.default = new ButtonSelectPage();

},{"./wml/button-select":177}],177:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const demo_1 = require("../../../widgets/demo");
;
const button_select_1 = require("../../../../../../lib/control/button-select");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.widget(new demo_1.Demo({}, [
                    __this.node('p', {}, [
                        __document.createTextNode('You selected: '),
                        __this.node('b', { wml: { 'id': 'select-content' } }, [
                            __document.createTextNode('(None)')
                        ]),
                        __document.createTextNode('.')
                    ]),
                    __this.node('p', {}, [
                        __this.widget(new button_select_1.ButtonSelect({ wml: { 'id': 'select' }, 'name': 'select', 'options': __context.values.options, 'value': __context.values.value, 'onChange': __context.onChange }, []), { wml: { 'id': 'select' }, 'name': 'select', 'options': __context.values.options, 'value': __context.values.value, 'onChange': __context.onChange })
                    ])
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('p', {}, [
                        __document.createTextNode('You can also use MultiButtonSelect instead: '),
                        __this.node('b', { wml: { 'id': 'multi-content' } }, [
                            __document.createTextNode('(None)')
                        ]),
                        __document.createTextNode('.')
                    ]),
                    __this.node('p', {}, [
                        __this.widget(new button_select_1.MultiButtonSelect({ wml: { 'id': 'multi' }, 'name': 'multi', 'options': __context.values.options, 'value': __context.values.values, 'onChange': __context.onChangeMulti }, []), { wml: { 'id': 'multi' }, 'name': 'multi', 'options': __context.values.options, 'value': __context.values.values, 'onChange': __context.onChangeMulti })
                    ])
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/control/button-select":27,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],178:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ButtonPage = void 0;
const views = require("./wml/button");
const style_1 = require("../../../../../lib/content/style");
const size_1 = require("../../../../../lib/content/size");
class ButtonPage {
    constructor() {
        this.view = new views.Main(this);
        this.values = {
            capitalize: (s) => `${s[0].toUpperCase()}${s.slice(1)}`,
            styles: [
                style_1.Style.Default,
                style_1.Style.Primary,
                style_1.Style.Success,
                style_1.Style.Info,
                style_1.Style.Warning,
                style_1.Style.Error
            ],
            sizes: [
                size_1.Size.ExtraSmall,
                size_1.Size.Small,
                size_1.Size.Medium,
                size_1.Size.Large,
                size_1.Size.ExtraLarge
            ]
        };
    }
}
exports.ButtonPage = ButtonPage;
exports.default = new ButtonPage();

},{"../../../../../lib/content/size":16,"../../../../../lib/content/style":20,"./wml/button":179}],179:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const demo_1 = require("../../../widgets/demo");
;
const button_1 = require("../../../../../../lib/control/button");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.widget(new demo_1.Demo({}, [
                    __this.node('h1', {}, [
                        __document.createTextNode('Buttons')
                    ]),
                    __this.node('p', {}, [
                        __this.node('h2', {}, [
                            __document.createTextNode('Style')
                        ]),
                        ...__forIn(__context.values.styles, (v, _$$i, _$$all) => ([
                            __this.widget(new button_1.Button({ 'name': v, 'style': v, 'text': __context.values.capitalize(v) }, []), { 'name': v, 'style': v, 'text': __context.values.capitalize(v) })
                        ]), () => ([]))
                    ])
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('h2', {}, [
                        __document.createTextNode('Outline')
                    ]),
                    ...__forIn(__context.values.styles, (style, _$$i, _$$all) => ([
                        __this.widget(new button_1.Button({ 'style': style, 'outline': true, 'text': __context.values.capitalize(style) }, []), { 'style': style, 'outline': true, 'text': __context.values.capitalize(style) })
                    ]), () => ([]))
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('p', {}, [
                        __this.node('h2', {}, [
                            __document.createTextNode('Active')
                        ]),
                        ...__forIn(__context.values.styles, (v, _$$i, _$$all) => ([
                            __this.widget(new button_1.Button({ 'name': v, 'active': true, 'style': v, 'text': __context.values.capitalize(v) }, []), { 'name': v, 'active': true, 'style': v, 'text': __context.values.capitalize(v) })
                        ]), () => ([]))
                    ])
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('p', {}, [
                        __this.node('h2', {}, [
                            __document.createTextNode('Disabled')
                        ]),
                        ...__forIn(__context.values.styles, (v, _$$i, _$$all) => ([
                            __this.widget(new button_1.Button({ 'name': v, 'disabled': true, 'style': v, 'text': __context.values.capitalize(v) }, []), { 'name': v, 'disabled': true, 'style': v, 'text': __context.values.capitalize(v) })
                        ]), () => ([]))
                    ])
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('h2', {}, [
                        __document.createTextNode('Size')
                    ]),
                    ...__forIn(__context.values.styles, (style, _$$i, _$$all) => ([
                        __this.node('p', {}, [
                            ...__forIn(__context.values.sizes, (size, _$$i, _$$all) => ([
                                __this.widget(new button_1.Button({ 'name': size, 'style': style, 'size': size, 'text': __context.values.capitalize(size) }, []), { 'name': size, 'style': style, 'size': size, 'text': __context.values.capitalize(size) })
                            ]), () => ([]))
                        ])
                    ]), () => ([]))
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('h2', {}, [
                        __document.createTextNode('Block')
                    ]),
                    ...__forIn(__context.values.styles, (style, _$$i, _$$all) => ([
                        __this.widget(new button_1.Button({ 'style': style, 'block': true, 'text': __context.values.capitalize(style) }, []), { 'style': style, 'block': true, 'text': __context.values.capitalize(style) })
                    ]), () => ([]))
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/control/button":29,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],180:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CheckboxPage = void 0;
const views = require("./wml/checkbox");
class CheckboxPage {
    constructor() {
        this.view = new views.Main(this);
        this.value = true;
        this.onChange = ({ value }) => {
            this.view.findById('content')
                .map((e) => {
                while (e.firstChild)
                    e.removeChild(e.firstChild);
                e.appendChild(document.createTextNode(value === true ?
                    'on' :
                    (value === false ? 'off' : 'error')));
            });
        };
    }
}
exports.CheckboxPage = CheckboxPage;
exports.default = new CheckboxPage();

},{"./wml/checkbox":181}],181:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const demo_1 = require("../../../widgets/demo");
;
const checkbox_1 = require("../../../../../../lib/control/checkbox");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.node('p', {}, [
                    __document.createTextNode('The checkbox is '),
                    __this.node('b', { wml: { 'id': 'content' } }, [
                        __document.createTextNode('untouched')
                    ]),
                    __document.createTextNode('.')
                ]),
                __this.node('p', {}, [
                    __this.widget(new checkbox_1.Checkbox({ 'name': 'checkbox', 'onChange': __context.onChange }, []), { 'name': 'checkbox', 'onChange': __context.onChange })
                ])
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/control/checkbox":31,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],182:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.onChange = exports.DateFieldPage = void 0;
const views = require("./wml/date-field");
const date_field_1 = require("../../../../../lib/control/date-field");
const util_1 = require("../../../../../lib/util");
class DateFieldPage {
    constructor() {
        this.view = new views.Main(this);
        this.values = {
            formats: {
                iso: {
                    id: 'iso',
                    name: 'iso',
                    label: 'ISO8601',
                    format: date_field_1.Format.ISO8601,
                    message: 'ISO8601 date',
                    onChange: (0, exports.onChange)(this)
                },
                common: {
                    id: 'common',
                    name: 'common',
                    label: 'Comon',
                    format: date_field_1.Format.COMMON,
                    message: 'Common date',
                    onChange: (0, exports.onChange)(this)
                },
                us: {
                    id: 'us',
                    name: 'us',
                    label: 'US',
                    format: date_field_1.Format.USA,
                    message: 'US date',
                    onChange: (0, exports.onChange)(this)
                }
            },
            states: {
                success: {
                    id: 'success',
                    name: 'success',
                    label: 'Success',
                    success: 'Success date',
                    warning: undefined,
                    error: undefined,
                    block: false,
                    onChange: (0, exports.onChange)(this)
                },
                warning: {
                    id: 'warning',
                    name: 'warning',
                    label: 'Warning',
                    success: undefined,
                    warning: 'Warning date',
                    error: undefined,
                    block: false,
                    onChange: (0, exports.onChange)(this)
                },
                error: {
                    id: 'error',
                    name: 'error',
                    label: 'Error',
                    success: undefined,
                    warning: undefined,
                    error: 'Error date',
                    block: false,
                    onChange: (0, exports.onChange)(this)
                },
                block: {
                    id: 'block',
                    name: 'block',
                    label: 'Block',
                    success: undefined,
                    warning: undefined,
                    error: undefined,
                    block: true,
                    onChange: (0, exports.onChange)(this)
                },
            }
        };
    }
}
exports.DateFieldPage = DateFieldPage;
const onChange = (d) => ({ name, value }) => {
    let mDate = (0, util_1.getById)(d.view, name);
    if (mDate.isJust()) {
        let d = mDate.get();
        d.setMessage(`The date is ${value}.`);
    }
};
exports.onChange = onChange;
exports.default = new DateFieldPage();

},{"../../../../../lib/control/date-field":35,"../../../../../lib/util":147,"./wml/date-field":183}],183:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const demo_1 = require("../../../widgets/demo");
;
const date_field_1 = require("../../../../../../lib/control/date-field");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                ...__forOf(__context.values.formats, (spec, _$$k, _$$all) => ([
                    __this.widget(new demo_1.Demo({}, [
                        __this.node('p', {}, [
                            __this.widget(new date_field_1.DateField({ wml: { 'id': spec.id }, 'name': spec.name, 'label': spec.label, 'format': spec.format, 'message': spec.message, 'onChange': spec.onChange }, []), { wml: { 'id': spec.id }, 'name': spec.name, 'label': spec.label, 'format': spec.format, 'message': spec.message, 'onChange': spec.onChange })
                        ])
                    ]), {})
                ]), () => ([])),
                ...__forOf(__context.values.states, (spec, _$$k, _$$all) => ([
                    __this.widget(new demo_1.Demo({}, [
                        __this.node('p', {}, [
                            __this.widget(new date_field_1.DateField({ wml: { 'id': spec.id }, 'name': spec.name, 'label': spec.label, 'success': spec.success, 'warning': spec.warning, 'error': spec.error, 'block': spec.block, 'onChange': spec.onChange }, []), { wml: { 'id': spec.id }, 'name': spec.name, 'label': spec.label, 'success': spec.success, 'warning': spec.warning, 'error': spec.error, 'block': spec.block, 'onChange': spec.onChange })
                        ])
                    ]), {})
                ]), () => ([]))
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/control/date-field":35,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],184:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DisplayFieldPage = void 0;
const views = require("./wml/display-field");
const style_1 = require("../../../../../lib/content/style");
const getStyles = () => [
    style_1.Style.Default,
    style_1.Style.Primary,
    style_1.Style.Success,
    style_1.Style.Info,
    style_1.Style.Warning,
    style_1.Style.Error
];
class DisplayFieldPage {
    constructor() {
        this.view = new views.Main(this);
        this.values = {
            capitalize: (s) => `${s[0].toUpperCase()}${s.slice(1)}`,
            styles: getStyles()
        };
    }
}
exports.DisplayFieldPage = DisplayFieldPage;
exports.default = new DisplayFieldPage();

},{"../../../../../lib/content/style":20,"./wml/display-field":185}],185:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const display_field_1 = require("../../../../../../lib/control/display-field");
;
const demo_1 = require("../../../widgets/demo");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.widget(new demo_1.Demo({}, [
                    __this.widget(new display_field_1.DisplayField({}, [
                        __document.createTextNode(' It was a choice.')
                    ]), {})
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.widget(new display_field_1.DisplayField({ 'disabled': true }, [
                        __document.createTextNode('Disabled')
                    ]), { 'disabled': true })
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/control/display-field":37,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],186:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DropDownPage = void 0;
const views = require("./wml/drop-down");
class DropDownPage {
    constructor() {
        this.view = new views.Main(this);
        this.onClick = (msg) => (e) => {
            e.preventDefault();
            alert(msg);
        };
    }
}
exports.DropDownPage = DropDownPage;
exports.default = new DropDownPage();

},{"./wml/drop-down":187}],187:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const demo_1 = require("../../../widgets/demo");
;
const drop_down_1 = require("../../../../../../lib/control/drop-down");
;
const menu_1 = require("../../../../../../lib/menu/menu");
;
const item_1 = require("../../../../../../lib/menu/item");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.node('p', {}, [
                    __this.widget(new drop_down_1.DropDown({ 'buttonText': 'Click Me' }, [
                        __this.widget(new menu_1.Menu({}, [
                            __this.widget(new item_1.Item({}, [
                                __this.node('a', { 'href': '#', 'onclick': __context.onClick('You clicked one') }, [
                                    __document.createTextNode('One')
                                ])
                            ]), {}),
                            __this.widget(new item_1.Item({}, [
                                __this.node('a', { 'href': '#', 'onclick': __context.onClick('You clicked two') }, [
                                    __document.createTextNode('Two')
                                ])
                            ]), {}),
                            __this.widget(new item_1.Divider({}, []), {}),
                            __this.widget(new item_1.Item({}, [
                                __this.node('a', { 'href': '#', 'onclick': __context.onClick('You clicked three') }, [
                                    __document.createTextNode('Three')
                                ])
                            ]), {})
                        ]), {})
                    ]), { 'buttonText': 'Click Me' }),
                    __this.widget(new drop_down_1.DropDown({ 'buttonText': 'Me Too', 'autoClose': false }, [
                        __this.node('h1', {}, [
                            __document.createTextNode('Any flow content can go here!')
                        ])
                    ]), { 'buttonText': 'Me Too', 'autoClose': false }),
                    __this.widget(new drop_down_1.DropDown({ 'buttonText': 'Can\'t touch this!', 'disabled': true }, [
                        __this.node('p', {}, [
                            __document.createTextNode('You will never see this!')
                        ])
                    ]), { 'buttonText': 'Can\'t touch this!', 'disabled': true }),
                    __this.widget(new drop_down_1.DropDown({ 'buttonText': 'I am an anchor', 'anchor': true }, [
                        __this.node('b', {}, [
                            __document.createTextNode('Content')
                        ])
                    ]), { 'buttonText': 'I am an anchor', 'anchor': true })
                ])
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/control/drop-down":39,"../../../../../../lib/menu/item":140,"../../../../../../lib/menu/menu":142,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],188:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DropListFieldPage = void 0;
const views = require("./wml/drop-list-field");
const results_1 = require("../../fixtures/data/results");
const options = results_1.results;
class DropListFieldPage {
    constructor() {
        this.view = new views.Main(this);
        this.values = {
            normal: {
                id: 'normal',
                name: 'normal',
                label: 'Normal',
                options,
                value: results_1.results[2].value,
                onChange: doChange(this)
            },
            success: {
                id: 'success',
                name: 'success',
                label: 'Success',
                options,
                message: 'This has a success message.',
                onChange: doChange(this)
            },
            warning: {
                id: 'warning',
                name: 'warning',
                label: 'Warning',
                options,
                message: 'This has a warning message.',
                onChange: doChange(this)
            },
            error: {
                id: 'error',
                name: 'error',
                label: 'Error',
                options,
                message: 'This has a error message.',
                onChange: doChange(this)
            },
        };
    }
}
exports.DropListFieldPage = DropListFieldPage;
const doChange = (page) => ({ name, value }) => page
    .view
    .findById(name)
    .map(() => {
    alert(`Selected: ${name}=${value}`);
});
exports.default = new DropListFieldPage();

},{"../../fixtures/data/results":161,"./wml/drop-list-field":189}],189:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const demo_1 = require("../../../widgets/demo");
;
const drop_list_field_1 = require("../../../../../../lib/control/drop-list-field");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.widget(new demo_1.Demo({}, [
                    __this.node('b', {}, [
                        __document.createTextNode('Normal')
                    ]),
                    __this.node('p', {}, [
                        __this.widget(new drop_list_field_1.DropListField({ wml: { 'id': __context.values.normal.name }, 'name': __context.values.normal.name, 'value': __context.values.normal.value, 'options': __context.values.normal.options, 'onChange': __context.values.normal.onChange }, []), { wml: { 'id': __context.values.normal.name }, 'name': __context.values.normal.name, 'value': __context.values.normal.value, 'options': __context.values.normal.options, 'onChange': __context.values.normal.onChange })
                    ])
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('b', {}, [
                        __document.createTextNode('Success')
                    ]),
                    __this.node('p', {}, [
                        __this.widget(new drop_list_field_1.DropListField({ wml: { 'id': __context.values.success.id }, 'className': '-success', 'name': __context.values.success.name, 'options': __context.values.success.options, 'onChange': __context.values.success.onChange }, []), { wml: { 'id': __context.values.success.id }, 'className': '-success', 'name': __context.values.success.name, 'options': __context.values.success.options, 'onChange': __context.values.success.onChange })
                    ])
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('b', {}, [
                        __document.createTextNode('Warning')
                    ]),
                    __this.node('p', {}, [
                        __this.widget(new drop_list_field_1.DropListField({ wml: { 'id': __context.values.warning.id }, 'className': '-warning', 'name': __context.values.warning.name, 'options': __context.values.warning.options, 'onChange': __context.values.warning.onChange }, []), { wml: { 'id': __context.values.warning.id }, 'className': '-warning', 'name': __context.values.warning.name, 'options': __context.values.warning.options, 'onChange': __context.values.warning.onChange })
                    ])
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('b', {}, [
                        __document.createTextNode('Error')
                    ]),
                    __this.node('p', {}, [
                        __this.widget(new drop_list_field_1.DropListField({ wml: { 'id': __context.values.error.id }, 'className': '-error', 'name': __context.values.error.name, 'options': __context.values.error.options, 'onChange': __context.values.error.onChange }, []), { wml: { 'id': __context.values.error.id }, 'className': '-error', 'name': __context.values.error.name, 'options': __context.values.error.options, 'onChange': __context.values.error.onChange })
                    ])
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('b', {}, [
                        __document.createTextNode('Disabled')
                    ]),
                    __this.node('p', {}, [
                        __this.widget(new drop_list_field_1.DropListField({ 'name': __context.values.normal.name, 'value': __context.values.normal.value, 'options': __context.values.normal.options, 'disabled': true, 'onChange': __context.values.normal.onChange }, []), { 'name': __context.values.normal.name, 'value': __context.values.normal.value, 'options': __context.values.normal.options, 'disabled': true, 'onChange': __context.values.normal.onChange })
                    ])
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/control/drop-list-field":41,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],190:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DropListPage = void 0;
const views = require("./wml/drop-list");
const results_1 = require("../../fixtures/data/results");
const options = results_1.results;
class DropListPage {
    constructor() {
        this.view = new views.Main(this);
        this.values = {
            normal: {
                id: 'normal',
                name: 'normal',
                label: 'Normal',
                options,
                value: results_1.results[2].value,
                onSelect: doSelect(this)
            },
            block: {
                id: 'block',
                name: 'block',
                label: 'Block',
                options,
                onSelect: doSelect(this)
            },
            success: {
                id: 'success',
                name: 'success',
                label: 'Success',
                options,
                message: 'This has a success message.',
                onSelect: doSelect(this)
            },
            warning: {
                id: 'warning',
                name: 'warning',
                label: 'Warning',
                options,
                message: 'This has a warning message.',
                onSelect: doSelect(this)
            },
            error: {
                id: 'error',
                name: 'error',
                label: 'Error',
                options,
                message: 'This has a error message.',
                onSelect: doSelect(this)
            },
        };
    }
}
exports.DropListPage = DropListPage;
const doSelect = (page) => ({ name, value }) => page
    .view
    .findById(name)
    .map(() => {
    alert(`Selected: ${name}=${value}`);
});
exports.default = new DropListPage();

},{"../../fixtures/data/results":161,"./wml/drop-list":191}],191:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const demo_1 = require("../../../widgets/demo");
;
const drop_list_1 = require("../../../../../../lib/control/drop-list");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.widget(new demo_1.Demo({}, [
                    __this.node('b', {}, [
                        __document.createTextNode('Normal')
                    ]),
                    __this.node('p', {}, [
                        __this.widget(new drop_list_1.DropList({ wml: { 'id': __context.values.normal.name }, 'name': __context.values.normal.name, 'value': __context.values.normal.value, 'options': __context.values.normal.options, 'onSelect': __context.values.normal.onSelect }, []), { wml: { 'id': __context.values.normal.name }, 'name': __context.values.normal.name, 'value': __context.values.normal.value, 'options': __context.values.normal.options, 'onSelect': __context.values.normal.onSelect })
                    ])
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('b', {}, [
                        __document.createTextNode('Success')
                    ]),
                    __this.node('p', {}, [
                        __this.widget(new drop_list_1.DropList({ wml: { 'id': __context.values.success.id }, 'className': '-success', 'name': __context.values.success.name, 'options': __context.values.success.options, 'onSelect': __context.values.success.onSelect }, []), { wml: { 'id': __context.values.success.id }, 'className': '-success', 'name': __context.values.success.name, 'options': __context.values.success.options, 'onSelect': __context.values.success.onSelect })
                    ])
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('b', {}, [
                        __document.createTextNode('Warning')
                    ]),
                    __this.node('p', {}, [
                        __this.widget(new drop_list_1.DropList({ wml: { 'id': __context.values.warning.id }, 'className': '-warning', 'name': __context.values.warning.name, 'options': __context.values.warning.options, 'onSelect': __context.values.warning.onSelect }, []), { wml: { 'id': __context.values.warning.id }, 'className': '-warning', 'name': __context.values.warning.name, 'options': __context.values.warning.options, 'onSelect': __context.values.warning.onSelect })
                    ])
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('b', {}, [
                        __document.createTextNode('Error')
                    ]),
                    __this.node('p', {}, [
                        __this.widget(new drop_list_1.DropList({ wml: { 'id': __context.values.error.id }, 'className': '-error', 'name': __context.values.error.name, 'options': __context.values.error.options, 'onSelect': __context.values.error.onSelect }, []), { wml: { 'id': __context.values.error.id }, 'className': '-error', 'name': __context.values.error.name, 'options': __context.values.error.options, 'onSelect': __context.values.error.onSelect })
                    ])
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('p', {}, [
                        __this.node('b', {}, [
                            __document.createTextNode('Disabled')
                        ]),
                        __this.widget(new drop_list_1.DropList({ 'name': __context.values.normal.name, 'disabled': true, 'onSelect': __context.values.normal.onSelect }, []), { 'name': __context.values.normal.name, 'disabled': true, 'onSelect': __context.values.normal.onSelect })
                    ])
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('p', {}, [
                        __this.node('b', {}, [
                            __document.createTextNode('Block')
                        ]),
                        __this.widget(new drop_list_1.DropList({ wml: { 'id': __context.values.block.id }, 'className': '-block', 'name': __context.values.block.name, 'block': true, 'onSelect': __context.values.block.onSelect }, []), { wml: { 'id': __context.values.block.id }, 'className': '-block', 'name': __context.values.block.name, 'block': true, 'onSelect': __context.values.block.onSelect })
                    ])
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/control/drop-list":43,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],192:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileUploadSurfacePage = void 0;
const views = require("./wml/file-upload-surface");
class FileUploadSurfacePage {
    constructor() {
        this.view = new views.Main(this);
        this.values = {};
    }
}
exports.FileUploadSurfacePage = FileUploadSurfacePage;
exports.default = new FileUploadSurfacePage();

},{"./wml/file-upload-surface":193}],193:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const demo_1 = require("../../../widgets/demo");
;
const file_upload_surface_1 = require("../../../../../../lib/control/file-upload-surface");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.widget(new file_upload_surface_1.FileUploadSurface({}, []), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/control/file-upload-surface":48,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],194:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InputGroupPage = void 0;
const views = require("./wml/input-group");
const results_1 = require("../../fixtures/data/results");
class InputGroupPage {
    constructor() {
        this.view = new views.Main(this);
        this.values = {
            dropList: { options: results_1.results }
        };
    }
}
exports.InputGroupPage = InputGroupPage;
exports.default = new InputGroupPage();

},{"../../fixtures/data/results":161,"./wml/input-group":195}],195:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const text_input_1 = require("../../../../../../lib/control/text-input");
;
const input_group_1 = require("../../../../../../lib/control/input-group");
;
const checkbox_1 = require("../../../../../../lib/control/checkbox");
;
const button_1 = require("../../../../../../lib/control/button");
;
const drop_down_1 = require("../../../../../../lib/control/drop-down");
;
const drop_list_1 = require("../../../../../../lib/control/drop-list");
;
const menu_1 = require("../../../../../../lib/menu/menu");
;
const item_1 = require("../../../../../../lib/menu/item");
;
const demo_1 = require("../../../widgets/demo");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.widget(new demo_1.Demo({}, [
                    __this.node('p', {}, [
                        __this.widget(new input_group_1.InputGroup({}, [
                            __this.widget(new input_group_1.AddOn({}, [
                                __document.createTextNode('http')
                            ]), {}),
                            __this.widget(new text_input_1.TextInput({}, []), {})
                        ]), {})
                    ])
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('p', {}, [
                        __this.widget(new input_group_1.InputGroup({}, [
                            __this.widget(new text_input_1.TextInput({}, []), {}),
                            __this.widget(new input_group_1.AddOn({}, [
                                __document.createTextNode('.com')
                            ]), {})
                        ]), {})
                    ])
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('p', {}, [
                        __this.widget(new input_group_1.InputGroup({}, [
                            __this.widget(new input_group_1.AddOn({}, [
                                __this.widget(new checkbox_1.Checkbox({}, []), {})
                            ]), {}),
                            __this.widget(new text_input_1.TextInput({}, []), {})
                        ]), {})
                    ])
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('p', {}, [
                        __this.widget(new input_group_1.InputGroup({}, [
                            __this.widget(new text_input_1.TextInput({}, []), {}),
                            __this.widget(new input_group_1.AddOn({}, [
                                __this.widget(new checkbox_1.Checkbox({}, []), {})
                            ]), {})
                        ]), {})
                    ])
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('p', {}, [
                        __this.widget(new input_group_1.InputGroup({}, [
                            __this.widget(new input_group_1.AddOn({ 'button': true }, [
                                __this.widget(new button_1.Button({ 'text': 'Find' }, []), { 'text': 'Find' })
                            ]), { 'button': true }),
                            __this.widget(new text_input_1.TextInput({}, []), {})
                        ]), {})
                    ])
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('p', {}, [
                        __this.widget(new input_group_1.InputGroup({}, [
                            __this.widget(new text_input_1.TextInput({}, []), {}),
                            __this.widget(new input_group_1.AddOn({ 'button': true }, [
                                __this.widget(new button_1.Button({ 'text': 'Find' }, []), { 'text': 'Find' })
                            ]), { 'button': true })
                        ]), {})
                    ])
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('p', {}, [
                        __this.widget(new input_group_1.InputGroup({}, [
                            __this.widget(new input_group_1.AddOn({ 'button': true }, [
                                __this.widget(new drop_down_1.DropDown({ 'buttonText': 'Click Me' }, [
                                    __this.widget(new menu_1.Menu({}, [
                                        __this.widget(new item_1.Item({}, [
                                            __this.node('a', { 'href': '#' }, [
                                                __document.createTextNode('One')
                                            ])
                                        ]), {}),
                                        __this.widget(new item_1.Item({}, [
                                            __this.node('a', { 'href': '#' }, [
                                                __document.createTextNode('Two')
                                            ])
                                        ]), {}),
                                        __this.widget(new item_1.Item({}, [
                                            __this.node('a', { 'href': '#' }, [
                                                __document.createTextNode('Three')
                                            ])
                                        ]), {})
                                    ]), {})
                                ]), { 'buttonText': 'Click Me' })
                            ]), { 'button': true }),
                            __this.widget(new text_input_1.TextInput({}, []), {})
                        ]), {})
                    ])
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('p', {}, [
                        __this.widget(new input_group_1.InputGroup({}, [
                            __this.widget(new text_input_1.TextInput({}, []), {}),
                            __this.widget(new input_group_1.AddOn({ 'button': true }, [
                                __this.widget(new drop_down_1.DropDown({ 'buttonText': 'Click Me' }, [
                                    __this.widget(new menu_1.Menu({}, [
                                        __this.widget(new item_1.Item({}, [
                                            __this.node('a', { 'href': '#' }, [
                                                __document.createTextNode('One')
                                            ])
                                        ]), {}),
                                        __this.widget(new item_1.Item({}, [
                                            __this.node('a', { 'href': '#' }, [
                                                __document.createTextNode('Two')
                                            ])
                                        ]), {}),
                                        __this.widget(new item_1.Item({}, [
                                            __this.node('a', { 'href': '#' }, [
                                                __document.createTextNode('Three')
                                            ])
                                        ]), {})
                                    ]), {})
                                ]), { 'buttonText': 'Click Me' })
                            ]), { 'button': true })
                        ]), {})
                    ])
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('p', {}, [
                        __this.widget(new input_group_1.InputGroup({}, [
                            __this.widget(new input_group_1.AddOn({ 'button': true }, [
                                __this.widget(new drop_list_1.DropList({ 'options': __context.values.dropList.options }, []), { 'options': __context.values.dropList.options })
                            ]), { 'button': true }),
                            __this.widget(new text_input_1.TextInput({}, []), {})
                        ]), {})
                    ])
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/control/button":29,"../../../../../../lib/control/checkbox":31,"../../../../../../lib/control/drop-down":39,"../../../../../../lib/control/drop-list":43,"../../../../../../lib/control/input-group":55,"../../../../../../lib/control/text-input":85,"../../../../../../lib/menu/item":140,"../../../../../../lib/menu/menu":142,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],196:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiSelectPage = void 0;
const views = require("./wml/multi-select");
const results_1 = require("../../fixtures/data/results");
class MultiSelectPage {
    constructor() {
        this.view = new views.Main(this);
        this.values = {
            normal: {
                id: 'normal',
                name: 'normal',
                label: 'Normal',
                stringifier: (r) => r.value,
                onSearch: onSearch(this),
                onChange: onChange(this),
            },
            success: {
                id: 'success',
                name: 'success',
                label: 'Success',
                stringifier: (r) => r.value,
                message: 'This has a success message.',
                onSearch: onSearch(this),
                onChange: onChange(this),
            },
            warning: {
                id: 'warning',
                name: 'warning',
                label: 'Warning',
                stringifier: (r) => r.value,
                message: 'This has a warning message.',
                onSearch: onSearch(this),
                onChange: onChange(this),
            },
            error: {
                id: 'error',
                name: 'error',
                label: 'Error',
                stringifier: (r) => r.value,
                message: 'This has a error message.',
                onSearch: onSearch(this),
                onChange: onChange(this),
            },
            block: {
                id: 'block',
                name: 'block',
                label: 'Block',
                stringifier: (r) => r.value,
                onSearch: onSearch(this),
                onChange: onChange(this),
            },
            init: {
                id: 'init',
                name: 'init',
                label: 'Init',
                value: results_1.results,
                stringifier: (r) => r.value,
                onSearch: onSearch(this),
                onChange: onChange(this),
            }
        };
    }
}
exports.MultiSelectPage = MultiSelectPage;
const onSearch = (page) => ({ name, value }) => page
    .view
    .findById(name)
    .map((s) => {
    let hit = results_1.results.filter(c => c.value.toLowerCase().startsWith(value) ? true : false);
    s.update(hit);
});
const onChange = (page) => ({ name, value }) => page
    .view
    .findById(name)
    .map(t => {
    t.setMessage(`Count: ${value.length}`);
});
exports.default = new MultiSelectPage();

},{"../../fixtures/data/results":161,"./wml/multi-select":197}],197:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const demo_1 = require("../../../widgets/demo");
;
const multi_select_1 = require("../../../../../../lib/control/multi-select");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.widget(new demo_1.Demo({}, [
                    __this.widget(new multi_select_1.MultiSelect({ wml: { 'id': __context.values.normal.id }, 'name': __context.values.normal.name, 'label': __context.values.normal.label, 'stringifier': __context.values.normal.stringifier, 'onSearch': __context.values.normal.onSearch, 'onChange': __context.values.normal.onChange }, []), { wml: { 'id': __context.values.normal.id }, 'name': __context.values.normal.name, 'label': __context.values.normal.label, 'stringifier': __context.values.normal.stringifier, 'onSearch': __context.values.normal.onSearch, 'onChange': __context.values.normal.onChange })
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.widget(new multi_select_1.MultiSelect({ wml: { 'id': __context.values.success.id }, 'name': __context.values.success.name, 'label': __context.values.success.label, 'success': __context.values.success.message, 'stringifier': __context.values.success.stringifier, 'onSearch': __context.values.success.onSearch, 'onChange': __context.values.success.onChange }, []), { wml: { 'id': __context.values.success.id }, 'name': __context.values.success.name, 'label': __context.values.success.label, 'success': __context.values.success.message, 'stringifier': __context.values.success.stringifier, 'onSearch': __context.values.success.onSearch, 'onChange': __context.values.success.onChange })
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.widget(new multi_select_1.MultiSelect({ wml: { 'id': __context.values.warning.id }, 'name': __context.values.warning.name, 'label': __context.values.warning.label, 'warning': __context.values.warning.message, 'stringifier': __context.values.warning.stringifier, 'onSearch': __context.values.warning.onSearch, 'onChange': __context.values.warning.onChange }, []), { wml: { 'id': __context.values.warning.id }, 'name': __context.values.warning.name, 'label': __context.values.warning.label, 'warning': __context.values.warning.message, 'stringifier': __context.values.warning.stringifier, 'onSearch': __context.values.warning.onSearch, 'onChange': __context.values.warning.onChange })
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.widget(new multi_select_1.MultiSelect({ wml: { 'id': __context.values.error.id }, 'name': __context.values.error.name, 'label': __context.values.error.label, 'error': __context.values.error.message, 'stringifier': __context.values.error.stringifier, 'onSearch': __context.values.error.onSearch, 'onChange': __context.values.error.onChange }, []), { wml: { 'id': __context.values.error.id }, 'name': __context.values.error.name, 'label': __context.values.error.label, 'error': __context.values.error.message, 'stringifier': __context.values.error.stringifier, 'onSearch': __context.values.error.onSearch, 'onChange': __context.values.error.onChange })
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.widget(new multi_select_1.MultiSelect({ wml: { 'id': __context.values.block.id }, 'name': __context.values.block.name, 'label': __context.values.block.label, 'block': true, 'stringifier': __context.values.block.stringifier, 'onSearch': __context.values.block.onSearch, 'onChange': __context.values.block.onChange }, []), { wml: { 'id': __context.values.block.id }, 'name': __context.values.block.name, 'label': __context.values.block.label, 'block': true, 'stringifier': __context.values.block.stringifier, 'onSearch': __context.values.block.onSearch, 'onChange': __context.values.block.onChange })
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.widget(new multi_select_1.MultiSelect({ 'name': __context.values.normal.name, 'label': 'Disabled', 'disabled': true, 'onSearch': __context.values.normal.onSearch, 'onChange': __context.values.normal.onChange }, []), { 'name': __context.values.normal.name, 'label': 'Disabled', 'disabled': true, 'onSearch': __context.values.normal.onSearch, 'onChange': __context.values.normal.onChange })
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.widget(new multi_select_1.MultiSelect({ 'name': __context.values.init.name, 'label': 'Initialized', 'value': __context.values.init.value, 'stringifier': __context.values.init.stringifier, 'onSearch': __context.values.init.onSearch, 'onChange': __context.values.init.onChange }, []), { 'name': __context.values.init.name, 'label': 'Initialized', 'value': __context.values.init.value, 'stringifier': __context.values.init.stringifier, 'onSearch': __context.values.init.onSearch, 'onChange': __context.values.init.onChange })
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/control/multi-select":59,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],198:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PagerPage = void 0;
const views = require("./pager");
const scenes = [
    'Page 1',
    'Page 2',
    'Page 3',
    'Page 4',
    'Page 5',
    'Page 6',
    'Page 7',
    'Page 8',
    'Page 9',
    'Page 10'
];
class PagerPage {
    constructor() {
        this.view = new views.Main(this);
        this.values = {
            message: scenes[0],
            total: scenes.length,
            current: 1,
            onChange: (e) => {
                this.values.current = e.value;
                this.values.message = scenes[this.values.current - 1];
                this.view.invalidate();
            }
        };
    }
}
exports.PagerPage = PagerPage;
exports.default = new PagerPage();

},{"./pager":199}],199:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const grid_1 = require("../../../../../lib/layout/grid");
;
const demo_1 = require("../../widgets/demo");
;
const pager_1 = require("../../../../../lib/control/pager");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.widget(new grid_1.Row({}, [
                    __this.widget(new grid_1.Column({}, [
                        __this.node('p', {}, [
                            text(__context.values.message)
                        ])
                    ]), {})
                ]), {}),
                __this.widget(new grid_1.Row({}, [
                    __this.widget(new grid_1.Column({}, [
                        __this.widget(new pager_1.Pager({ 'total': __context.values.total, 'current': __context.values.current, 'onChange': __context.values.onChange }, []), { 'total': __context.values.total, 'current': __context.values.current, 'onChange': __context.values.onChange })
                    ]), {})
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../lib/control/pager":61,"../../../../../lib/layout/grid":117,"../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],200:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PaginatorPage = void 0;
const views = require("./wml/paginator");
const scenes = [
    'Page 1',
    'Page 2',
    'Page 3',
    'Page 4',
    'Page 5',
    'Page 6',
    'Page 7',
    'Page 8',
    'Page 9',
    'Page 10'
];
class PaginatorPage {
    constructor() {
        this.view = new views.Main(this);
        this.values = {
            message: scenes[0],
            current: 1,
            total: scenes.length,
            onChange: (e) => {
                this.values.message = scenes[e.value - 1];
                this.values.current = e.value;
                this.view.invalidate();
            }
        };
    }
}
exports.PaginatorPage = PaginatorPage;
exports.default = new PaginatorPage();

},{"./wml/paginator":201}],201:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const demo_1 = require("../../../widgets/demo");
;
const paginator_1 = require("../../../../../../lib/control/paginator");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.widget(new paginator_1.Paginator({ 'total': __context.values.total, 'current': __context.values.current, 'onChange': __context.values.onChange }, []), { 'total': __context.values.total, 'current': __context.values.current, 'onChange': __context.values.onChange }),
                __this.node('p', {}, [
                    text(__context.values.message)
                ])
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/control/paginator":63,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],202:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RangedPagerPage = void 0;
const views = require("./views");
const array_1 = require("@quenk/noni/lib/data/array");
const scenes = [
    'Page 1',
    'Page 2',
    'Page 3',
    'Page 4',
    'Page 5',
    'Page 6',
    'Page 7',
    'Page 8',
    'Page 9',
    'Page 10'
];
class RangedPagerPage {
    constructor() {
        this.view = new views.Main(this);
        this.values = {
            scenes: scenes,
            message: scenes[0],
            max: scenes.length,
            total: scenes.length,
            current: 1,
            onAttrChange: (e) => {
                this.values[e.name] = Number(e.value);
                if (e.name === 'total')
                    this.values.scenes = (0, array_1.make)(Number(e.value), i => `Page ${i}`);
            },
            onChange: (e) => {
                this.values.current = e.value;
                this.values.message = this.values.scenes[this.values.current - 1];
                this.view.invalidate();
            },
            reset: () => {
                this.view.invalidate();
            }
        };
    }
}
exports.RangedPagerPage = RangedPagerPage;
exports.default = new RangedPagerPage();

},{"./views":203,"@quenk/noni/lib/data/array":149}],203:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const grid_1 = require("../../../../../lib/layout/grid");
;
const text_input_1 = require("../../../../../lib/control/text-input");
;
const ranged_pager_1 = require("../../../../../lib/control/ranged-pager");
;
const button_1 = require("../../../../../lib/control/button");
;
const size_1 = require("../../../../../lib/content/size");
;
const demo_1 = require("../../widgets/demo");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.widget(new grid_1.Row({}, [
                    __this.widget(new grid_1.Column({}, [
                        __this.node('h3', {}, [
                            __document.createTextNode('Use the controls below to configure attributes.')
                        ]),
                        __this.node('p', {}, [
                            __document.createTextNode('\u000a        Max: \u000a        \u000a        '),
                            __this.widget(new text_input_1.TextInput({ 'size': size_1.Size.Small, 'name': 'max', 'value': String(__context.values.max), 'onChange': __context.values.onAttrChange }, []), { 'size': size_1.Size.Small, 'name': 'max', 'value': String(__context.values.max), 'onChange': __context.values.onAttrChange }),
                            __document.createTextNode('\u000a\u000a        Total:\u000a\u000a        '),
                            __this.widget(new text_input_1.TextInput({ 'size': size_1.Size.Small, 'name': 'total', 'value': String(__context.values.total), 'onChange': __context.values.onAttrChange }, []), { 'size': size_1.Size.Small, 'name': 'total', 'value': String(__context.values.total), 'onChange': __context.values.onAttrChange }),
                            __document.createTextNode('\u000a\u000a        Current:\u000a\u000a        '),
                            __this.widget(new text_input_1.TextInput({ 'size': size_1.Size.Small, 'name': 'current', 'value': String(__context.values.current), 'onChange': __context.values.onAttrChange }, []), { 'size': size_1.Size.Small, 'name': 'current', 'value': String(__context.values.current), 'onChange': __context.values.onAttrChange }),
                            __this.widget(new button_1.Button({ 'text': 'Go', 'onClick': __context.values.reset }, []), { 'text': 'Go', 'onClick': __context.values.reset })
                        ])
                    ]), {})
                ]), {}),
                __this.widget(new grid_1.Row({}, [
                    __this.widget(new grid_1.Column({}, [
                        __this.node('p', {}, [
                            text(__context.values.message)
                        ])
                    ]), {})
                ]), {}),
                __this.widget(new grid_1.Row({}, [
                    __this.widget(new grid_1.Column({}, [
                        __this.widget(new ranged_pager_1.RangedPager({ 'max': __context.values.max, 'total': __context.values.total, 'current': __context.values.current, 'onChange': __context.values.onChange }, []), { 'max': __context.values.max, 'total': __context.values.total, 'current': __context.values.current, 'onChange': __context.values.onChange })
                    ]), {})
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../lib/content/size":16,"../../../../../lib/control/button":29,"../../../../../lib/control/ranged-pager":65,"../../../../../lib/control/text-input":85,"../../../../../lib/layout/grid":117,"../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],204:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SearchPage = void 0;
const views = require("./wml/search");
const results_1 = require("../../fixtures/data/results");
class SearchPage {
    constructor() {
        this.view = new views.Main(this);
        this.values = {
            id: 'search',
            name: 'search',
            id2: 'search2',
            name2: 'search2',
            stringifier: (r) => r.value,
            onSearch: onSearch(this),
            onSelect: onSelect,
        };
    }
}
exports.SearchPage = SearchPage;
const onSearch = (page) => ({ name, value }) => page
    .view
    .findById(name)
    .map((s) => {
    let hit = results_1.results.filter(c => c.value.toLowerCase().startsWith(value.toLowerCase()) ? true : false);
    s.update(hit);
});
const onSelect = ({ value }) => alert(`Selected "${value.value}"`);
exports.default = new SearchPage();

},{"../../fixtures/data/results":161,"./wml/search":205}],205:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const demo_1 = require("../../../widgets/demo");
;
const search_1 = require("../../../../../../lib/control/search");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.widget(new demo_1.Demo({}, [
                    __this.node('p', {}, [
                        __this.widget(new search_1.Search({ wml: { 'id': __context.values.id }, 'name': __context.values.name, 'stringifier': __context.values.stringifier, 'onSearch': __context.values.onSearch, 'onSelect': __context.values.onSelect }, []), { wml: { 'id': __context.values.id }, 'name': __context.values.name, 'stringifier': __context.values.stringifier, 'onSearch': __context.values.onSearch, 'onSelect': __context.values.onSelect })
                    ])
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('p', {}, [
                        __this.widget(new search_1.Search({ wml: { 'id': __context.values.id2 }, 'name': __context.values.name2, 'block': true, 'stringifier': __context.values.stringifier, 'onSearch': __context.values.onSearch, 'onSelect': __context.values.onSelect }, []), { wml: { 'id': __context.values.id2 }, 'name': __context.values.name2, 'block': true, 'stringifier': __context.values.stringifier, 'onSearch': __context.values.onSearch, 'onSelect': __context.values.onSelect })
                    ])
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('h2', {}, [
                        __document.createTextNode(' Disabled ')
                    ]),
                    __this.node('p', {}, [
                        __this.widget(new search_1.Search({ 'disabled': true, 'stringifier': __context.values.stringifier, 'onSearch': __context.values.onSearch, 'onSelect': __context.values.onSelect }, []), { 'disabled': true, 'stringifier': __context.values.stringifier, 'onSearch': __context.values.onSearch, 'onSelect': __context.values.onSelect })
                    ])
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/control/search":69,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],206:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SelectPage = void 0;
const views = require("./wml/select");
const results_1 = require("../../fixtures/data/results");
class SelectPage {
    constructor() {
        this.view = new views.Main(this);
        this.values = {
            normal: {
                id: 'normal',
                name: 'normal',
                label: 'Normal',
                value: results_1.results[2],
                stringifier: (r) => r.value,
                onSearch: doSearch(this),
                onChange: doChange(this),
                onUnset: doUnset(this)
            },
            block: {
                id: 'block',
                name: 'block',
                label: 'Block',
                stringifier: (r) => r.value,
                onSearch: doSearch(this),
                onChange: doChange(this),
                onUnset: doUnset(this)
            },
            success: {
                id: 'success',
                name: 'success',
                label: 'Success',
                stringifier: (r) => r.value,
                message: 'This has a success message.',
                onSearch: doSearch(this),
                onChange: doChange(this),
                onUnset: doUnset(this)
            },
            warning: {
                id: 'warning',
                name: 'warning',
                label: 'Warning',
                stringifier: (r) => r.value,
                message: 'This has a warning message.',
                onSearch: doSearch(this),
                onChange: doChange(this),
                onUnset: doUnset(this)
            },
            error: {
                id: 'error',
                name: 'error',
                label: 'Error',
                stringifier: (r) => r.value,
                message: 'This has a error message.',
                onSearch: doSearch(this),
                onChange: doChange(this),
                onUnset: doUnset(this)
            },
        };
    }
}
exports.SelectPage = SelectPage;
const doSearch = (page) => ({ name, value }) => page
    .view
    .findById(name)
    .map((s) => {
    let hit = results_1.results.filter(c => c.value.toLowerCase().startsWith(value) ? true : false);
    s.update(hit);
});
const doChange = (page) => ({ name, value }) => page
    .view
    .findById(name)
    .map(t => {
    t.setMessage(`Selected: ${value.value}`);
});
const doUnset = (page) => ({ name }) => page
    .view
    .findById(name)
    .map(t => {
    t.setMessage('');
});
exports.default = new SelectPage();

},{"../../fixtures/data/results":161,"./wml/select":207}],207:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const demo_1 = require("../../../widgets/demo");
;
const select_1 = require("../../../../../../lib/control/select");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.widget(new demo_1.Demo({}, [
                    __this.widget(new select_1.Select({ wml: { 'id': __context.values.normal.id }, 'name': __context.values.normal.name, 'label': __context.values.normal.label, 'value': __context.values.normal.value, 'stringifier': __context.values.normal.stringifier, 'onSearch': __context.values.normal.onSearch, 'onChange': __context.values.normal.onChange }, []), { wml: { 'id': __context.values.normal.id }, 'name': __context.values.normal.name, 'label': __context.values.normal.label, 'value': __context.values.normal.value, 'stringifier': __context.values.normal.stringifier, 'onSearch': __context.values.normal.onSearch, 'onChange': __context.values.normal.onChange })
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.widget(new select_1.Select({ wml: { 'id': __context.values.success.id }, 'name': __context.values.success.name, 'label': __context.values.success.label, 'success': __context.values.success.message, 'stringifier': __context.values.success.stringifier, 'onSearch': __context.values.success.onSearch, 'onChange': __context.values.success.onChange }, []), { wml: { 'id': __context.values.success.id }, 'name': __context.values.success.name, 'label': __context.values.success.label, 'success': __context.values.success.message, 'stringifier': __context.values.success.stringifier, 'onSearch': __context.values.success.onSearch, 'onChange': __context.values.success.onChange })
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.widget(new select_1.Select({ wml: { 'id': __context.values.warning.id }, 'name': __context.values.warning.name, 'label': __context.values.warning.label, 'warning': __context.values.warning.message, 'stringifier': __context.values.warning.stringifier, 'onSearch': __context.values.warning.onSearch, 'onChange': __context.values.warning.onChange }, []), { wml: { 'id': __context.values.warning.id }, 'name': __context.values.warning.name, 'label': __context.values.warning.label, 'warning': __context.values.warning.message, 'stringifier': __context.values.warning.stringifier, 'onSearch': __context.values.warning.onSearch, 'onChange': __context.values.warning.onChange })
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.widget(new select_1.Select({ wml: { 'id': __context.values.error.id }, 'name': __context.values.error.name, 'label': __context.values.error.label, 'error': __context.values.error.message, 'stringifier': __context.values.error.stringifier, 'onSearch': __context.values.error.onSearch, 'onChange': __context.values.error.onChange }, []), { wml: { 'id': __context.values.error.id }, 'name': __context.values.error.name, 'label': __context.values.error.label, 'error': __context.values.error.message, 'stringifier': __context.values.error.stringifier, 'onSearch': __context.values.error.onSearch, 'onChange': __context.values.error.onChange })
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.widget(new select_1.Select({ wml: { 'id': __context.values.block.id }, 'name': __context.values.block.name, 'label': __context.values.block.label, 'block': true, 'stringifier': __context.values.block.stringifier, 'onSearch': __context.values.block.onSearch, 'onChange': __context.values.block.onChange }, []), { wml: { 'id': __context.values.block.id }, 'name': __context.values.block.name, 'label': __context.values.block.label, 'block': true, 'stringifier': __context.values.block.stringifier, 'onSearch': __context.values.block.onSearch, 'onChange': __context.values.block.onChange })
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.widget(new select_1.Select({ 'name': __context.values.normal.name, 'label': 'Disabled', 'disabled': true, 'stringifier': __context.values.normal.stringifier, 'onSearch': __context.values.normal.onSearch, 'onChange': __context.values.normal.onChange }, []), { 'name': __context.values.normal.name, 'label': 'Disabled', 'disabled': true, 'stringifier': __context.values.normal.stringifier, 'onSearch': __context.values.normal.onSearch, 'onChange': __context.values.normal.onChange })
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.widget(new select_1.Select({ 'name': __context.values.normal.name, 'label': 'Disabled with value', 'value': __context.values.normal.value, 'disabled': true, 'stringifier': __context.values.normal.stringifier, 'onSearch': __context.values.normal.onSearch, 'onChange': __context.values.normal.onChange }, []), { 'name': __context.values.normal.name, 'label': 'Disabled with value', 'value': __context.values.normal.value, 'disabled': true, 'stringifier': __context.values.normal.stringifier, 'onSearch': __context.values.normal.onSearch, 'onChange': __context.values.normal.onChange })
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/control/select":71,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],208:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StackSelectPage = void 0;
const views = require("./wml/stack-select");
const results_1 = require("../../fixtures/data/results");
class StackSelectPage {
    constructor() {
        this.view = new views.Main(this);
        this.values = {
            asc: {
                id: 'asc',
                name: 'asc',
                label: 'Ascending',
                value: results_1.results[2],
                stringifier: (r) => r.value,
                onSearch: onSearch(this),
                onChange: onChange(this),
            },
            desc: {
                id: 'desc',
                name: 'desc',
                label: 'Descending',
                stringifier: (r) => r.value,
                onSearch: onSearch(this),
                onChange: onChange(this),
            },
            success: {
                id: 'success',
                name: 'success',
                label: 'Success',
                stringifier: (r) => r.value,
                message: 'This has a success message.',
                onSearch: onSearch(this),
                onChange: onChange(this),
            },
            warning: {
                id: 'warning',
                name: 'warning',
                label: 'Warning',
                stringifier: (r) => r.value,
                message: 'This has a warning message.',
                onSearch: onSearch(this),
                onChange: onChange(this),
            },
            error: {
                id: 'error',
                name: 'error',
                label: 'Error',
                stringifier: (r) => r.value,
                message: 'This has a error message.',
                onSearch: onSearch(this),
                onChange: onChange(this),
            },
        };
    }
}
exports.StackSelectPage = StackSelectPage;
const onSearch = (page) => ({ name, value }) => page
    .view
    .findById(name)
    .map((s) => {
    let hit = results_1.results.filter(c => c.value.toLowerCase().startsWith(value) ? true : false);
    s.update(hit);
});
const onChange = (page) => ({ name, value }) => page
    .view
    .findById(name)
    .map(t => {
    t.setMessage(`Count: ${value.length}`);
});
exports.default = new StackSelectPage();

},{"../../fixtures/data/results":161,"./wml/stack-select":209}],209:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const demo_1 = require("../../../widgets/demo");
;
const stack_select_1 = require("../../../../../../lib/control/stack-select");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.widget(new demo_1.Demo({}, [
                    __this.widget(new stack_select_1.StackSelect({ wml: { 'id': __context.values.asc.id }, 'name': __context.values.asc.name, 'label': __context.values.asc.label, 'stringifier': __context.values.asc.stringifier, 'onSearch': __context.values.asc.onSearch, 'onChange': __context.values.asc.onChange }, []), { wml: { 'id': __context.values.asc.id }, 'name': __context.values.asc.name, 'label': __context.values.asc.label, 'stringifier': __context.values.asc.stringifier, 'onSearch': __context.values.asc.onSearch, 'onChange': __context.values.asc.onChange })
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.widget(new stack_select_1.StackSelect({ wml: { 'id': __context.values.desc.id }, 'name': __context.values.desc.name, 'label': __context.values.desc.label, 'dir': -1, 'stringifier': __context.values.desc.stringifier, 'onSearch': __context.values.desc.onSearch, 'onChange': __context.values.desc.onChange }, []), { wml: { 'id': __context.values.desc.id }, 'name': __context.values.desc.name, 'label': __context.values.desc.label, 'dir': -1, 'stringifier': __context.values.desc.stringifier, 'onSearch': __context.values.desc.onSearch, 'onChange': __context.values.desc.onChange })
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.widget(new stack_select_1.StackSelect({ wml: { 'id': __context.values.success.id }, 'name': __context.values.success.name, 'label': __context.values.success.label, 'success': __context.values.success.message, 'stringifier': __context.values.success.stringifier, 'onSearch': __context.values.success.onSearch, 'onChange': __context.values.success.onChange }, []), { wml: { 'id': __context.values.success.id }, 'name': __context.values.success.name, 'label': __context.values.success.label, 'success': __context.values.success.message, 'stringifier': __context.values.success.stringifier, 'onSearch': __context.values.success.onSearch, 'onChange': __context.values.success.onChange })
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.widget(new stack_select_1.StackSelect({ wml: { 'id': __context.values.warning.id }, 'name': __context.values.warning.name, 'label': __context.values.warning.label, 'warning': __context.values.warning.message, 'stringifier': __context.values.warning.stringifier, 'onSearch': __context.values.warning.onSearch, 'onChange': __context.values.warning.onChange }, []), { wml: { 'id': __context.values.warning.id }, 'name': __context.values.warning.name, 'label': __context.values.warning.label, 'warning': __context.values.warning.message, 'stringifier': __context.values.warning.stringifier, 'onSearch': __context.values.warning.onSearch, 'onChange': __context.values.warning.onChange })
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.widget(new stack_select_1.StackSelect({ wml: { 'id': __context.values.error.id }, 'name': __context.values.error.name, 'label': __context.values.error.label, 'error': __context.values.error.message, 'stringifier': __context.values.error.stringifier, 'onSearch': __context.values.error.onSearch, 'onChange': __context.values.error.onChange }, []), { wml: { 'id': __context.values.error.id }, 'name': __context.values.error.name, 'label': __context.values.error.label, 'error': __context.values.error.message, 'stringifier': __context.values.error.stringifier, 'onSearch': __context.values.error.onSearch, 'onChange': __context.values.error.onChange })
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.widget(new stack_select_1.StackSelect({ 'name': __context.values.asc.name, 'label': 'Disabled', 'disabled': true, 'stringifier': __context.values.asc.stringifier, 'onSearch': __context.values.asc.onSearch, 'onChange': __context.values.asc.onChange }, []), { 'name': __context.values.asc.name, 'label': 'Disabled', 'disabled': true, 'stringifier': __context.values.asc.stringifier, 'onSearch': __context.values.asc.onSearch, 'onChange': __context.values.asc.onChange })
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/control/stack-select":73,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],210:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StackPage = void 0;
const views = require("./wml/stack");
const _getValues = () => [
    { label: 'Asus', value: 'Asus' },
    { label: 'MSI', value: 'MSI' },
    { label: 'MSI', value: 'MSI' },
    { label: 'Gigabyte', value: 'Gigabyte' }
];
const _getText = (m) => document.createTextNode(m.map(({ label }) => label).join(','));
class StackPage {
    constructor() {
        this.view = new views.Main(this);
        this.values = {
            values: _getValues(),
            text: _getText(_getValues()),
            decorator: (m) => m.label
        };
        this.onChange = ({ value }) => {
            if (value.length === 0)
                this.values.values = _getValues();
            this.values.text = _getText(this.values.values);
            this.view.invalidate();
        };
    }
}
exports.StackPage = StackPage;
exports.default = new StackPage();

},{"./wml/stack":211}],211:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const demo_1 = require("../../../widgets/demo");
;
const stack_1 = require("../../../../../../lib/control/stack");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.node('p', {}, [
                    __document.createTextNode('Members: '),
                    __this.node('b', { wml: { 'id': 'selected' } }, [
                        __context.values.text
                    ]),
                    __document.createTextNode('.')
                ]),
                __this.node('p', {}, [
                    __this.widget(new stack_1.Stack({ 'name': 'stack', 'value': __context.values.values, 'decorator': __context.values.decorator, 'onChange': __context.onChange }, []), { 'name': 'stack', 'value': __context.values.values, 'decorator': __context.values.decorator, 'onChange': __context.onChange })
                ]),
                __this.node('p', {}, [
                    __document.createTextNode('Disabled')
                ]),
                __this.node('p', {}, [
                    __this.widget(new stack_1.Stack({ 'name': 'stack', 'value': __context.values.values, 'disabled': true, 'decorator': __context.values.decorator, 'onChange': __context.onChange }, []), { 'name': 'stack', 'value': __context.values.values, 'disabled': true, 'decorator': __context.values.decorator, 'onChange': __context.onChange })
                ])
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/control/stack":75,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],212:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SwitchPage = void 0;
const views = require("./wml/switch");
class SwitchPage {
    constructor() {
        this.view = new views.Main(this);
        this.value = true;
        this.onChange = ({ value }) => {
            this.view.findById('content')
                .map((e) => {
                while (e.firstChild)
                    e.removeChild(e.firstChild);
                e.appendChild(document.createTextNode(value === true ?
                    'on' :
                    (value === false ? 'off' : 'error')));
            });
        };
    }
}
exports.SwitchPage = SwitchPage;
exports.default = new SwitchPage();

},{"./wml/switch":213}],213:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const demo_1 = require("../../../widgets/demo");
;
const switch_1 = require("../../../../../../lib/control/switch");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.widget(new demo_1.Demo({}, [
                    __this.node('p', {}, [
                        __document.createTextNode('The switch is already set.')
                    ]),
                    __this.node('p', {}, [
                        __this.widget(new switch_1.Switch({ 'name': 'switch', 'value': true }, []), { 'name': 'switch', 'value': true })
                    ])
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('p', {}, [
                        __document.createTextNode('The switch is '),
                        __this.node('b', { wml: { 'id': 'content' } }, [
                            __document.createTextNode('untouched')
                        ]),
                        __document.createTextNode('.')
                    ]),
                    __this.node('p', {}, [
                        __this.widget(new switch_1.Switch({ 'name': 'switch', 'onChange': __context.onChange }, []), { 'name': 'switch', 'onChange': __context.onChange })
                    ])
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/control/switch":77,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],214:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TabBarPage = void 0;
const views = require("./wml/tab-bar");
class TabBarPage {
    constructor() {
        this.view = new views.Main(this);
        this.tab = 'First';
        this.content = document.createTextNode('First Tab');
        this.clicked = ({ name }) => {
            this.tab = name;
            this.content = document.createTextNode(`${name} Tab`);
            this.view.invalidate();
        };
    }
}
exports.TabBarPage = TabBarPage;
exports.default = new TabBarPage();

},{"./wml/tab-bar":215}],215:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const demo_1 = require("../../../widgets/demo");
;
const tab_bar_1 = require("../../../../../../lib/control/tab-bar");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.widget(new demo_1.Demo({}, [
                    __this.widget(new tab_bar_1.TabBar({}, [
                        __this.widget(new tab_bar_1.Tab({ 'active': (__context.tab === 'First'), 'text': 'First', 'name': 'First', 'onClick': __context.clicked }, []), { 'active': (__context.tab === 'First'), 'text': 'First', 'name': 'First', 'onClick': __context.clicked }),
                        __this.widget(new tab_bar_1.Tab({ 'active': (__context.tab === 'Second'), 'text': 'Second', 'name': 'Second', 'onClick': __context.clicked }, []), { 'active': (__context.tab === 'Second'), 'text': 'Second', 'name': 'Second', 'onClick': __context.clicked }),
                        __this.widget(new tab_bar_1.Tab({ 'active': (__context.tab === 'Third'), 'text': 'Third', 'name': 'Third', 'onClick': __context.clicked }, []), { 'active': (__context.tab === 'Third'), 'text': 'Third', 'name': 'Third', 'onClick': __context.clicked })
                    ]), {})
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.widget(new tab_bar_1.TabBar({ 'justify': true }, [
                        __this.widget(new tab_bar_1.Tab({ 'active': (__context.tab === 'First'), 'text': 'First', 'name': 'First', 'onClick': __context.clicked }, []), { 'active': (__context.tab === 'First'), 'text': 'First', 'name': 'First', 'onClick': __context.clicked }),
                        __this.widget(new tab_bar_1.Tab({ 'active': (__context.tab === 'Second'), 'text': 'Second', 'name': 'Second', 'onClick': __context.clicked }, []), { 'active': (__context.tab === 'Second'), 'text': 'Second', 'name': 'Second', 'onClick': __context.clicked }),
                        __this.widget(new tab_bar_1.Tab({ 'active': (__context.tab === 'Third'), 'text': 'Third', 'name': 'Third', 'onClick': __context.clicked }, []), { 'active': (__context.tab === 'Third'), 'text': 'Third', 'name': 'Third', 'onClick': __context.clicked })
                    ]), { 'justify': true })
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('p', { wml: { 'id': 'content' } }, [
                        __context.content
                    ])
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/control/tab-bar":79,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],216:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TagPage = void 0;
const views = require("./wml/tag");
const style_1 = require("../../../../../lib/content/style");
const getStyles = () => [
    style_1.Style.Default,
    style_1.Style.Primary,
    style_1.Style.Success,
    style_1.Style.Info,
    style_1.Style.Warning,
    style_1.Style.Error
];
class TagPage {
    constructor() {
        this.view = new views.Main(this);
        this.values = {
            capitalize: (s) => `${s[0].toUpperCase()}${s.slice(1)}`,
            styles: getStyles(),
            onDismiss: (e) => {
                let idx = this.values.styles.indexOf(e.name);
                if (idx > -1)
                    this.values.styles.splice(idx, 1);
                if (this.values.styles.length === 0)
                    this.values.styles = getStyles();
                this.view.invalidate();
            }
        };
    }
}
exports.TagPage = TagPage;
exports.default = new TagPage();

},{"../../../../../lib/content/style":20,"./wml/tag":217}],217:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const tag_1 = require("../../../../../../lib/control/tag");
;
const demo_1 = require("../../../widgets/demo");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.widget(new demo_1.Demo({}, [
                    __this.node('h1', {}, [
                        __document.createTextNode('Tag')
                    ]),
                    __this.node('p', {}, [
                        __this.node('h2', {}, [
                            __document.createTextNode('Styles')
                        ]),
                        ...__forIn(__context.values.styles, (v, _$$i, _$$all) => ([
                            __this.widget(new tag_1.Tag({ 'style': v, 'text': __context.values.capitalize(v), 'name': v, 'onDismiss': __context.values.onDismiss }, []), { 'style': v, 'text': __context.values.capitalize(v), 'name': v, 'onDismiss': __context.values.onDismiss })
                        ]), () => ([]))
                    ])
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/control/tag":81,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],218:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextFieldPage = void 0;
const views = require("./wml/text-field");
const feedback_1 = require("../../../../../lib/control/feedback");
class TextFieldPage {
    constructor() {
        this.id = 'text';
        this.view = new views.Main(this);
        this.onChange = ({ name, value }) => {
            let maybeField = this.view.findById(name);
            if (maybeField.isJust()) {
                let t = maybeField.get();
                switch (value) {
                    case 'neutral':
                        t.setValidationState(feedback_1.ValidationState.Neutral);
                        break;
                    case 'error':
                        t.setValidationState(feedback_1.ValidationState.Error);
                        break;
                    case 'success':
                        t.setValidationState(feedback_1.ValidationState.Success);
                        break;
                    case 'warning':
                        t.setValidationState(feedback_1.ValidationState.Warning);
                        break;
                    default:
                        break;
                }
                t.setMessage(`Message: ${value}`);
            }
        };
    }
}
exports.TextFieldPage = TextFieldPage;
exports.default = new TextFieldPage();

},{"../../../../../lib/control/feedback":45,"./wml/text-field":219}],219:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const demo_1 = require("../../../widgets/demo");
;
const text_field_1 = require("../../../../../../lib/control/text-field");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.widget(new demo_1.Demo({}, [
                    __this.node('p', {}, [
                        __document.createTextNode('The value of the input is:')
                    ]),
                    __this.node('p', {}, [
                        __this.node('b', { wml: { 'id': 'content' } }, [
                            __document.createTextNode('Nothing')
                        ])
                    ]),
                    __this.node('p', {}, [
                        __this.widget(new text_field_1.TextField({ wml: { 'id': 'text' }, 'name': 'text', 'message': 'This is the help message', 'focus': true, 'onChange': __context.onChange }, []), { wml: { 'id': 'text' }, 'name': 'text', 'message': 'This is the help message', 'focus': true, 'onChange': __context.onChange })
                    ])
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('p', {}, [
                        __this.node('strong', {}, [
                            __document.createTextNode('Success')
                        ])
                    ]),
                    __this.node('p', {}, [
                        __this.widget(new text_field_1.TextField({ wml: { 'id': 'success' }, 'name': 'success', 'label': 'This is a success label', 'success': 'This textfield has a success', 'onChange': __context.onChange }, []), { wml: { 'id': 'success' }, 'name': 'success', 'label': 'This is a success label', 'success': 'This textfield has a success', 'onChange': __context.onChange })
                    ])
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('p', {}, [
                        __this.node('strong', {}, [
                            __document.createTextNode('Warning')
                        ])
                    ]),
                    __this.node('p', {}, [
                        __this.widget(new text_field_1.TextField({ wml: { 'id': 'warning' }, 'name': 'warning', 'label': 'This is a warning label', 'warning': 'This textfield has a warning.', 'onChange': __context.onChange }, []), { wml: { 'id': 'warning' }, 'name': 'warning', 'label': 'This is a warning label', 'warning': 'This textfield has a warning.', 'onChange': __context.onChange })
                    ])
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('p', {}, [
                        __this.node('strong', {}, [
                            __document.createTextNode('Error')
                        ])
                    ]),
                    __this.node('p', {}, [
                        __this.widget(new text_field_1.TextField({ wml: { 'id': 'error' }, 'name': 'error', 'label': 'This is an error label', 'error': 'This textfield has an error.', 'onChange': __context.onChange }, []), { wml: { 'id': 'error' }, 'name': 'error', 'label': 'This is an error label', 'error': 'This textfield has an error.', 'onChange': __context.onChange })
                    ])
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('p', {}, [
                        __document.createTextNode('The one uses rows to render a text area:')
                    ]),
                    __this.node('p', {}, [
                        __this.widget(new text_field_1.TextField({ wml: { 'id': 'area' }, 'name': 'area', 'rows': 5, 'label': 'This is a textarea label', 'onChange': __context.onChange }, []), { wml: { 'id': 'area' }, 'name': 'area', 'rows': 5, 'label': 'This is a textarea label', 'onChange': __context.onChange })
                    ])
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/control/text-field":83,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],220:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextInputPage = void 0;
const views = require("./wml/text-input");
const size_1 = require("../../../../../lib/content/size");
class TextInputPage {
    constructor() {
        this.view = new views.Main(this);
        this.sizes = [
            size_1.Size.ExtraSmall,
            size_1.Size.Small,
            size_1.Size.Medium,
            size_1.Size.Large,
            size_1.Size.ExtraLarge
        ];
        this.content = () => document.createTextNode('this');
        this.onChange = ({ value }) => {
            this
                .view
                .findById('txt')
                .map(h => h.innerHTML = value);
        };
    }
}
exports.TextInputPage = TextInputPage;
exports.default = new TextInputPage();

},{"../../../../../lib/content/size":16,"./wml/text-input":221}],221:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const text_input_1 = require("../../../../../../lib/control/text-input");
;
const demo_1 = require("../../../widgets/demo");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.widget(new demo_1.Demo({}, [
                    __this.node('p', {}, [
                        __document.createTextNode('\u000a      This is a text input: \u000a      '),
                        __this.widget(new text_input_1.TextInput({ 'match': '[a-zA-Z]', 'length': 20, 'onChange': __context.onChange }, []), { 'match': '[a-zA-Z]', 'length': 20, 'onChange': __context.onChange }),
                        __document.createTextNode('.\u000a    ')
                    ]),
                    __this.node('p', {}, [
                        __document.createTextNode('As you type '),
                        __this.node('b', { wml: { 'id': 'txt' } }, [
                            __document.createTextNode('this')
                        ]),
                        __document.createTextNode(' changes, but only for letters. (20)')
                    ])
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    ...__forIn(__context.sizes, (v, _$$i, _$$all) => ([
                        __this.node('p', {}, [
                            __document.createTextNode('\u000a        Size '),
                            document.createTextNode((v + ' neutral: ')),
                            __this.widget(new text_input_1.TextInput({ 'onChange': __context.onChange, 'size': v }, []), { 'onChange': __context.onChange, 'size': v })
                        ]),
                        __this.node('p', {}, [
                            __document.createTextNode('\u000a        Size '),
                            document.createTextNode((v + ' error: ')),
                            __this.widget(new text_input_1.TextInput({ 'onChange': __context.onChange, 'size': v, 'className': '-error' }, []), { 'onChange': __context.onChange, 'size': v, 'className': '-error' })
                        ]),
                        __this.node('p', {}, [
                            __document.createTextNode('\u000a        Size '),
                            document.createTextNode((v + ' warning: ')),
                            __this.widget(new text_input_1.TextInput({ 'onChange': __context.onChange, 'size': v, 'className': '-warning' }, []), { 'onChange': __context.onChange, 'size': v, 'className': '-warning' })
                        ]),
                        __this.node('p', {}, [
                            __document.createTextNode('\u000a        Size '),
                            document.createTextNode((v + ' success: ')),
                            __this.widget(new text_input_1.TextInput({ 'onChange': __context.onChange, 'size': v, 'className': '-success' }, []), { 'onChange': __context.onChange, 'size': v, 'className': '-success' })
                        ])
                    ]), () => ([]))
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('p', {}, [
                        __document.createTextNode('\u000a      Block:\u000a      '),
                        __this.widget(new text_input_1.TextInput({ 'onChange': __context.onChange, 'block': true }, []), { 'onChange': __context.onChange, 'block': true })
                    ])
                ]), {}),
                __this.node('p', {}, [
                    __document.createTextNode(' Textarea: ')
                ]),
                __this.widget(new demo_1.Demo({}, [
                    ...__forIn(__context.sizes, (v, _$$i, _$$all) => ([
                        __this.node('p', {}, [
                            __document.createTextNode('\u000a        Size '),
                            document.createTextNode((v + ' neutral: ')),
                            __this.widget(new text_input_1.TextInput({ 'onChange': __context.onChange, 'rows': 5, 'size': v }, []), { 'onChange': __context.onChange, 'rows': 5, 'size': v })
                        ]),
                        __this.node('p', {}, [
                            __document.createTextNode('\u000a        Size '),
                            document.createTextNode((v + ' error: ')),
                            __this.widget(new text_input_1.TextInput({ 'onChange': __context.onChange, 'size': v, 'rows': 5, 'className': '-error' }, []), { 'onChange': __context.onChange, 'size': v, 'rows': 5, 'className': '-error' })
                        ]),
                        __this.node('p', {}, [
                            __document.createTextNode('\u000a        Size '),
                            document.createTextNode((v + ' warning: ')),
                            __this.widget(new text_input_1.TextInput({ 'onChange': __context.onChange, 'size': v, 'rows': 5, 'className': '-warning' }, []), { 'onChange': __context.onChange, 'size': v, 'rows': 5, 'className': '-warning' })
                        ]),
                        __this.node('p', {}, [
                            __document.createTextNode('\u000a        Size '),
                            document.createTextNode((v + ' success: ')),
                            __this.widget(new text_input_1.TextInput({ 'onChange': __context.onChange, 'size': v, 'rows': 5, 'className': '-success' }, []), { 'onChange': __context.onChange, 'size': v, 'rows': 5, 'className': '-success' })
                        ])
                    ]), () => ([]))
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('p', {}, [
                        __document.createTextNode('\u000a      Block:\u000a      '),
                        __this.widget(new text_input_1.TextInput({ 'onChange': __context.onChange, 'block': true, 'rows': 5 }, []), { 'onChange': __context.onChange, 'block': true, 'rows': 5 })
                    ])
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('p', {}, [
                        __document.createTextNode('\u000a      Autofocused:\u000a      '),
                        __this.widget(new text_input_1.TextInput({ 'onChange': __context.onChange, 'focus': true }, []), { 'onChange': __context.onChange, 'focus': true })
                    ])
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/control/text-input":85,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],222:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ToolbarPage = void 0;
const views = require("./wml/toolbar");
class ToolbarPage {
    constructor() {
        this.view = new views.Main(this);
    }
}
exports.ToolbarPage = ToolbarPage;
exports.default = new ToolbarPage();

},{"./wml/toolbar":223}],223:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const demo_1 = require("../../../widgets/demo");
;
const button_1 = require("../../../../../../lib/control/button");
;
const button_group_1 = require("../../../../../../lib/control/button-group");
;
const toolbar_1 = require("../../../../../../lib/control/toolbar");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.widget(new toolbar_1.Toolbar({}, [
                    __this.widget(new button_group_1.ButtonGroup({}, [
                        __this.widget(new button_1.Button({ 'text': 'one' }, []), { 'text': 'one' }),
                        __this.widget(new button_1.Button({ 'text': 'two' }, []), { 'text': 'two' }),
                        __this.widget(new button_1.Button({ 'text': 'three' }, []), { 'text': 'three' })
                    ]), {}),
                    __this.widget(new button_group_1.ButtonGroup({}, [
                        __this.widget(new button_1.Button({ 'text': 'four' }, []), { 'text': 'four' }),
                        __this.widget(new button_1.Button({ 'text': 'five', 'active': true }, []), { 'text': 'five', 'active': true }),
                        __this.widget(new button_1.Button({ 'text': 'six' }, []), { 'text': 'six' })
                    ]), {}),
                    __this.widget(new button_group_1.ButtonGroup({}, [
                        __this.widget(new button_1.Button({ 'text': 'seven' }, []), { 'text': 'seven' }),
                        __this.widget(new button_1.Button({ 'text': 'eight', 'active': true }, []), { 'text': 'eight', 'active': true }),
                        __this.widget(new button_1.Button({ 'text': '9' }, []), { 'text': '9' })
                    ]), {})
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/control/button":29,"../../../../../../lib/control/button-group":25,"../../../../../../lib/control/toolbar":87,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],224:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeaheadPage = void 0;
const views = require("./wml/typeahead");
const results = [
    { label: 'Asus', value: 'Asus' },
    { label: 'MSI', value: 'MSI' },
    { label: 'Gigabyte', value: 'Gigabyte' },
    { label: 'Gigas', value: 'Gigas' },
    { label: 'AsusTek', value: 'AsusTek' },
    { label: 'Asusuga', value: 'Asusuga' },
    { label: 'Qualcomm', value: 'Qualcomm' },
    { label: 'Qualitative', value: 'Qualitatve' },
    { label: 'Kirpalani\'s', value: 'Kirpalani\'s' },
    { label: 'Asunder', value: 'Asunder' }
];
class TypeaheadPage {
    constructor() {
        this.view = new views.Main(this);
        this.values = {
            normal: {
                id: 'normal',
                name: 'normal',
                label: 'Normal',
                value: 'Normal',
                stringifier: (r) => r.value,
                onSearch: doSearch(this),
                onChange: doChange(this)
            },
            block: {
                id: 'block',
                name: 'block',
                label: 'Block',
                stringifier: (r) => r.value,
                onSearch: doSearch(this),
                onChange: doChange(this)
            },
            success: {
                id: 'success',
                name: 'success',
                label: 'Success',
                stringifier: (r) => r.value,
                message: 'This has a success message.',
                onSearch: doSearch(this),
                onChange: doChange(this)
            },
            warning: {
                id: 'warning',
                name: 'warning',
                label: 'Warning',
                stringifier: (r) => r.value,
                message: 'This has a warning message.',
                onSearch: doSearch(this),
                onChange: doChange(this)
            },
            error: {
                id: 'error',
                name: 'error',
                label: 'Error',
                stringifier: (r) => r.value,
                message: 'This has a error message.',
                onSearch: doSearch(this),
                onChange: doChange(this)
            },
        };
    }
}
exports.TypeaheadPage = TypeaheadPage;
const doSearch = (page) => ({ name, value }) => page
    .view
    .findById(name)
    .map((s) => {
    let hit = results.filter(c => c.value.toLowerCase().startsWith(value) ? true : false);
    s.update(hit);
});
const doChange = (page) => ({ name, value }) => page
    .view
    .findById(name)
    .map(t => {
    t.setMessage(`Selected: ${value}`);
});
exports.default = new TypeaheadPage();

},{"./wml/typeahead":225}],225:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const demo_1 = require("../../../widgets/demo");
;
const typeahead_1 = require("../../../../../../lib/control/typeahead");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.widget(new demo_1.Demo({}, [
                    __this.widget(new typeahead_1.Typeahead({ wml: { 'id': __context.values.normal.id }, 'name': __context.values.normal.name, 'label': __context.values.normal.label, 'stringifier': __context.values.normal.stringifier, 'onSearch': __context.values.normal.onSearch, 'onChange': __context.values.normal.onChange }, []), { wml: { 'id': __context.values.normal.id }, 'name': __context.values.normal.name, 'label': __context.values.normal.label, 'stringifier': __context.values.normal.stringifier, 'onSearch': __context.values.normal.onSearch, 'onChange': __context.values.normal.onChange })
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.widget(new typeahead_1.Typeahead({ wml: { 'id': __context.values.success.id }, 'name': __context.values.success.name, 'label': __context.values.success.label, 'success': __context.values.success.message, 'stringifier': __context.values.success.stringifier, 'onSearch': __context.values.success.onSearch, 'onChange': __context.values.success.onChange }, []), { wml: { 'id': __context.values.success.id }, 'name': __context.values.success.name, 'label': __context.values.success.label, 'success': __context.values.success.message, 'stringifier': __context.values.success.stringifier, 'onSearch': __context.values.success.onSearch, 'onChange': __context.values.success.onChange })
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.widget(new typeahead_1.Typeahead({ wml: { 'id': __context.values.warning.id }, 'name': __context.values.warning.name, 'label': __context.values.warning.label, 'warning': __context.values.warning.message, 'stringifier': __context.values.warning.stringifier, 'onSearch': __context.values.warning.onSearch, 'onChange': __context.values.warning.onChange }, []), { wml: { 'id': __context.values.warning.id }, 'name': __context.values.warning.name, 'label': __context.values.warning.label, 'warning': __context.values.warning.message, 'stringifier': __context.values.warning.stringifier, 'onSearch': __context.values.warning.onSearch, 'onChange': __context.values.warning.onChange })
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.widget(new typeahead_1.Typeahead({ wml: { 'id': __context.values.error.id }, 'name': __context.values.error.name, 'label': __context.values.error.label, 'error': __context.values.error.message, 'stringifier': __context.values.error.stringifier, 'onSearch': __context.values.error.onSearch, 'onChange': __context.values.error.onChange }, []), { wml: { 'id': __context.values.error.id }, 'name': __context.values.error.name, 'label': __context.values.error.label, 'error': __context.values.error.message, 'stringifier': __context.values.error.stringifier, 'onSearch': __context.values.error.onSearch, 'onChange': __context.values.error.onChange })
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.widget(new typeahead_1.Typeahead({ wml: { 'id': __context.values.block.id }, 'name': __context.values.block.name, 'label': __context.values.block.label, 'block': true, 'stringifier': __context.values.block.stringifier, 'onSearch': __context.values.block.onSearch, 'onChange': __context.values.block.onChange }, []), { wml: { 'id': __context.values.block.id }, 'name': __context.values.block.name, 'label': __context.values.block.label, 'block': true, 'stringifier': __context.values.block.stringifier, 'onSearch': __context.values.block.onSearch, 'onChange': __context.values.block.onChange })
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.widget(new typeahead_1.Typeahead({ 'name': __context.values.normal.name, 'label': 'Disabled', 'disabled': true, 'stringifier': __context.values.normal.stringifier, 'onSearch': __context.values.normal.onSearch, 'onChange': __context.values.normal.onChange }, []), { 'name': __context.values.normal.name, 'label': 'Disabled', 'disabled': true, 'stringifier': __context.values.normal.stringifier, 'onSearch': __context.values.normal.onSearch, 'onChange': __context.values.normal.onChange })
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/control/typeahead":89,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],226:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.users = void 0;
exports.users = [
    {
        "_id": "59f1334ccc21ff728cf7f3ce",
        "index": 0,
        "guid": "fd94cd52-e7f1-44ab-a74f-05604eee46dd",
        "isActive": false,
        "balance": "$2,849.93",
        "picture": "http://placehold.it/32x32",
        "age": 34,
        "eyeColor": "green",
        "name": "Johns Lewis",
        "gender": "female",
        "company": "PROFLEX",
        "email": "johnslewis@proflex.com",
        "phone": "+1 (925) 409-3400",
        "address": "874 Grove Street, Edgewater, Georgia, 8112",
        "about": "Ex esse dolore et sint sint proident nostrud ut officia. Do nulla mollit dolore ut aute excepteur deserunt laboris ut proident. Ullamco est deserunt ex commodo veniam duis elit excepteur velit ullamco deserunt culpa do est.\r\n",
        "registered": "2015-02-22T10:25:32 +04:00",
        "latitude": 56.278862,
        "longitude": -79.459101,
        "tags": [
            "labore",
            "proident",
            "aliqua",
            "amet",
            "amet",
            "officia",
            "enim"
        ],
        "friends": [
            {
                "id": 0,
                "name": "Mason Noble"
            },
            {
                "id": 1,
                "name": "Coffey Mendez"
            },
            {
                "id": 2,
                "name": "Dionne Cole"
            }
        ],
        "greeting": "Hello, Johns Lewis! You have 5 unread messages.",
        "favoriteFruit": "banana"
    },
    {
        "_id": "59f1334c09dc1bcdc5732491",
        "index": 1,
        "guid": "33255995-0431-4271-9876-37eabc117a7b",
        "isActive": false,
        "balance": "$2,167.40",
        "picture": "http://placehold.it/32x32",
        "age": 23,
        "eyeColor": "blue",
        "name": "Williamson Gregory",
        "gender": "undefined",
        "company": "NETAGY",
        "email": "williamsongregory@netagy.com",
        "phone": "+1 (910) 462-3918",
        "address": "158 Sedgwick Street, Glasgow, Utah, 5498",
        "about": "Excepteur sit nisi et velit. Laboris minim id duis ad qui cupidatat. Est Lorem quis duis Lorem laboris velit laboris non excepteur et velit voluptate qui. Dolore qui anim exercitation veniam incididunt laboris labore. Id minim labore amet sunt excepteur tempor proident.\r\n",
        "registered": "2016-04-25T04:25:24 +04:00",
        "latitude": 54.457833,
        "longitude": 122.803765,
        "tags": [
            "tempor",
            "exercitation",
            "et",
            "elit",
            "ex",
            "cillum",
            "laboris"
        ],
        "friends": [
            {
                "id": 0,
                "name": "Navarro Reeves"
            },
            {
                "id": 1,
                "name": "Stanton Vincent"
            },
            {
                "id": 2,
                "name": "Alexis Guzman"
            }
        ],
        "greeting": "Hello, Williamson Gregory! You have 1 unread messages.",
        "favoriteFruit": "apple"
    },
    {
        "_id": "59f1334c9d799789bc494a3c",
        "index": 2,
        "guid": "158ffa5d-15da-4a9f-a1da-0a48b76b8226",
        "isActive": false,
        "balance": "$1,289.35",
        "picture": "http://placehold.it/32x32",
        "age": 33,
        "eyeColor": "green",
        "name": "Dalton House",
        "gender": "male",
        "company": "EYEWAX",
        "email": "daltonhouse@eyewax.com",
        "phone": "+1 (959) 550-2263",
        "address": "116 Howard Avenue, Rossmore, New York, 6302",
        "about": "Elit eu ipsum pariatur duis mollit ex quis. Amet nulla exercitation laboris minim fugiat tempor in aliqua nisi nostrud aute. Duis minim esse irure irure fugiat sit nulla et tempor nisi cillum proident id adipisicing. Eu elit magna Lorem irure labore. Aliquip id sint veniam adipisicing. Amet eiusmod mollit reprehenderit reprehenderit dolore.\r\n",
        "registered": "2017-02-28T08:53:00 +04:00",
        "latitude": -25.679774,
        "longitude": 29.374781,
        "tags": [
            "qui",
            "cillum",
            "anim",
            "irure",
            "non",
            "commodo",
            "deserunt"
        ],
        "friends": [
            {
                "id": 0,
                "name": "Carmela Wilcox"
            },
            {
                "id": 1,
                "name": "Elba Garza"
            },
            {
                "id": 2,
                "name": "Garrison Church"
            }
        ],
        "greeting": "Hello, Dalton House! You have 1 unread messages.",
        "favoriteFruit": "apple"
    },
    {
        "_id": "59f1334cd1518c3a44d69fff",
        "index": 3,
        "guid": "5109bc50-9a8e-4184-aba0-6740dc00b606",
        "isActive": true,
        "balance": "$3,891.83",
        "picture": "http://placehold.it/32x32",
        "age": 22,
        "eyeColor": "blue",
        "name": "Ray Wilkins",
        "gender": "male",
        "company": "EXPOSA",
        "email": "raywilkins@exposa.com",
        "phone": "+1 (812) 414-3258",
        "address": "837 Bedford Avenue, Harleigh, South Carolina, 2323",
        "about": "Est amet quis eu proident ipsum veniam sit. Irure labore ad consectetur ullamco sit ipsum proident. Ad pariatur irure nisi irure commodo aliquip nisi eu anim irure dolor dolor veniam quis.\r\n",
        "registered": "2015-09-17T04:52:42 +04:00",
        "latitude": 34.354801,
        "longitude": -168.303952,
        "tags": [
            "nisi",
            "laboris",
            "incididunt",
            "amet",
            "aute",
            "quis",
            "mollit"
        ],
        "friends": [
            {
                "id": 0,
                "name": "Olivia Russo"
            },
            {
                "id": 1,
                "name": "Rita Tyler"
            },
            {
                "id": 2,
                "name": "Lorie Walker"
            }
        ],
        "greeting": "Hello, Ray Wilkins! You have 1 unread messages.",
        "favoriteFruit": "strawberry"
    },
    {
        "_id": "59f1334c6901bda003e52fa6",
        "index": 4,
        "guid": "0ab33477-b152-4b12-af35-f5b9254d5c2a",
        "isActive": true,
        "balance": "$3,730.71",
        "picture": "http://placehold.it/32x32",
        "age": 27,
        "eyeColor": "brown",
        "name": "Madden Hatfield",
        "gender": "male",
        "company": "ZOGAK",
        "email": "maddenhatfield@zogak.com",
        "phone": "+1 (832) 552-2294",
        "address": "530 Clermont Avenue, Bethpage, Virgin Islands, 5607",
        "about": "Commodo tempor anim tempor deserunt laboris qui eu reprehenderit consequat. Non laborum ullamco qui proident. Est cupidatat do dolor excepteur est nostrud laborum. Eu excepteur ex commodo aliquip adipisicing excepteur. Et reprehenderit laboris reprehenderit aute ut excepteur deserunt nostrud velit. Ullamco est sit fugiat irure aliqua aliquip proident. Voluptate ad culpa dolor id enim tempor laborum.\r\n",
        "registered": "2016-04-10T03:37:17 +04:00",
        "latitude": 80.888876,
        "longitude": 117.84337,
        "tags": [
            "occaecat",
            "nisi",
            "est",
            "ad",
            "nostrud",
            "eu",
            "dolore"
        ],
        "friends": [
            {
                "id": 0,
                "name": "Vincent Gay"
            },
            {
                "id": 1,
                "name": "Rosario Forbes"
            },
            {
                "id": 2,
                "name": "Baxter Green"
            }
        ],
        "greeting": "Hello, Madden Hatfield! You have 4 unread messages.",
        "favoriteFruit": "banana"
    }
];

},{}],227:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataTablePage = void 0;
const table_1 = require("./wml/table");
const data_1 = require("./data");
const util_1 = require("../../../../../lib/util");
const columns = [
    { name: 'index', heading: '#', sort: 'yes' },
    { name: 'name', heading: 'Name', sort: 'yes' },
    { name: 'gender', heading: 'Gender', sort: 'yes' },
    { name: 'email', heading: 'Email', sort: 'yes' },
    { name: 'balance', heading: 'Balance', sort: 'yes' },
];
class DataTablePage {
    constructor() {
        this.view = new table_1.Main(this);
        this.values = {
            id: 'table',
            users: data_1.users,
            columns,
            onCellClicked: (e) => {
                let mDT = (0, util_1.getById)(this.view, this.values.id);
                if (mDT.isNothing())
                    return;
                let dt = mDT.get();
                dt.getCell(e.column, e.row).cells.forEach(c => {
                    c.style.backgroundColor = 'red';
                    c.style.color = '#fff';
                });
            }
        };
    }
}
exports.DataTablePage = DataTablePage;
exports.default = new DataTablePage();

},{"../../../../../lib/util":147,"./data":226,"./wml/table":228}],228:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const demo_1 = require("../../../widgets/demo");
;
const table_1 = require("../../../../../../lib/data/table");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.node('h3', {}, [
                    __document.createTextNode('Data Table')
                ]),
                __this.widget(new table_1.DataTable({ wml: { 'id': __context.values.id }, 'sortable': true, 'onCellClicked': __context.values.onCellClicked, 'data': __context.values.users, 'columns': __context.values.columns }, []), { wml: { 'id': __context.values.id }, 'sortable': true, 'onCellClicked': __context.values.onCellClicked, 'data': __context.values.users, 'columns': __context.values.columns })
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/data/table":95,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],229:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PropertyListPage = void 0;
const property_list_1 = require("./wml/property-list");
const data = {
    name: 'London Beta',
    age: '37',
    balance: '5000'
};
const money = (s) => `$${s}`;
const dataFragment = (c) => new property_list_1.BoldDataView(c);
const fields = [
    { name: 'name', heading: 'Name', dataFragment },
    { name: 'age', heading: 'age' },
    { name: 'balance', heading: 'Balance', format: money }
];
class PropertyListPage {
    constructor() {
        this.view = new property_list_1.Main(this);
        this.data = data;
        this.fields = fields;
    }
}
exports.PropertyListPage = PropertyListPage;
exports.default = new PropertyListPage();

},{"./wml/property-list":230}],230:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = exports.BoldDataView = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const property_list_1 = require("../../../../../../lib/data/property-list");
;
const demo_1 = require("../../../widgets/demo");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class BoldDataView {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.node('b', {}, [
                text(__context.data)
            ]);
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.BoldDataView = BoldDataView;
;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.widget(new demo_1.Demo({}, [
                    __this.widget(new property_list_1.PropertyList({ 'fields': __context.fields, 'data': __context.data }, []), { 'fields': __context.fields, 'data': __context.data })
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/data/property-list":91,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],231:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AlertPage = void 0;
const views = require("./wml/alert");
const style_1 = require("../../../../../lib/content/style");
class AlertPage {
    constructor() {
        this.view = new views.Main(this);
        this.values = {
            capitalize: (s) => `${s[0].toUpperCase()}${s.slice(1)}`,
            message: 'This is an alert',
            styles: [
                style_1.Style.Default,
                style_1.Style.Primary,
                style_1.Style.Success,
                style_1.Style.Info,
                style_1.Style.Warning,
                style_1.Style.Error
            ]
        };
    }
}
exports.AlertPage = AlertPage;
exports.default = new AlertPage();

},{"../../../../../lib/content/style":20,"./wml/alert":232}],232:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const alert_1 = require("../../../../../../lib/dialog/alert");
;
const demo_1 = require("../../../widgets/demo");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.widget(new demo_1.Demo({}, [
                    __this.node('h1', {}, [
                        __document.createTextNode('Alerts')
                    ]),
                    __this.node('p', {}, [
                        __this.node('h2', {}, [
                            __document.createTextNode('Styles')
                        ]),
                        ...__forIn(__context.values.styles, (v, _$$i, _$$all) => ([
                            __this.widget(new alert_1.Alert({ 'style': v, 'closable': true, 'text': __context.values.capitalize(v) }, []), { 'style': v, 'closable': true, 'text': __context.values.capitalize(v) })
                        ]), () => ([]))
                    ])
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/dialog/alert":98,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],233:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfirmPage = void 0;
const views = require("./wml/confirm");
class ConfirmPage {
    constructor() {
        this.view = new views.Main(this);
        this.v = new views.Open(this);
        this.values = {
            title: 'Confirm a message',
            message: 'Would you like to confirm this message?',
            onYes: () => {
                alert('Message confirmed!');
            },
            onNo: () => {
                alert('Message rejected!');
            },
            open: () => {
                document.body.appendChild(this.v.render());
            },
            close: () => {
                this.v.findById('open')
                    .map(m => m.close());
            }
        };
    }
}
exports.ConfirmPage = ConfirmPage;
exports.default = new ConfirmPage();

},{"./wml/confirm":234}],234:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Open = exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const confirm_1 = require("../../../../../../lib/dialog/confirm");
;
const demo_1 = require("../../../widgets/demo");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.node('h1', {}, [
                    __document.createTextNode('Confirm')
                ]),
                __this.node('p', {}, [
                    __this.node('button', { 'onclick': __context.values.open }, [
                        __document.createTextNode('Open')
                    ])
                ])
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;
;
class Open {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new confirm_1.Confirm({ wml: { 'id': 'open' }, 'title': __context.values.title, 'onNo': __context.values.onNo, 'onYes': __context.values.onYes }, [
                text(__context.values.message)
            ]), { wml: { 'id': 'open' }, 'title': __context.values.title, 'onNo': __context.values.onNo, 'onYes': __context.values.onYes });
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Open = Open;

},{"../../../../../../lib/dialog/confirm":100,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],235:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InformPage = void 0;
const views = require("./wml/inform");
class InformPage {
    constructor() {
        this.view = new views.Main(this);
        this.v = new views.Open(this);
        this.values = {
            title: 'Something happened',
            message: 'Zing! Something you happened!',
            onClose: () => {
                alert('Buh Bye');
            },
            open: () => {
                document.body.appendChild(this.v.render());
            },
            close: () => {
                this.v.findById('open')
                    .map(m => m.close());
            }
        };
    }
}
exports.InformPage = InformPage;
exports.default = new InformPage();

},{"./wml/inform":236}],236:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Open = exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const inform_1 = require("../../../../../../lib/dialog/inform");
;
const demo_1 = require("../../../widgets/demo");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.node('h1', {}, [
                    __document.createTextNode('Inform')
                ]),
                __this.node('p', {}, [
                    __this.node('button', { 'onclick': __context.values.open }, [
                        __document.createTextNode('Open')
                    ])
                ])
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;
;
class Open {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new inform_1.Inform({ wml: { 'id': 'open' }, 'title': __context.values.title, 'onClose': __context.values.onClose }, [
                text(__context.values.message)
            ]), { wml: { 'id': 'open' }, 'title': __context.values.title, 'onClose': __context.values.onClose });
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Open = Open;

},{"../../../../../../lib/dialog/inform":102,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],237:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModalPage = void 0;
const views = require("./wml/modal");
class ModalPage {
    constructor() {
        this.view = new views.Main(this);
        this.v = new views.Open(this);
        this.values = {
            open: () => {
                document.body.appendChild(this.v.render());
            },
            close: () => {
                this.v.findById('open')
                    .map(m => m.close());
            }
        };
    }
}
exports.ModalPage = ModalPage;
exports.default = new ModalPage();

},{"./wml/modal":238}],238:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Open = exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const modal_1 = require("../../../../../../lib/dialog/modal");
;
const demo_1 = require("../../../widgets/demo");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.node('h1', {}, [
                    __document.createTextNode('Modals')
                ]),
                __this.node('p', {}, [
                    __this.node('button', { 'onclick': __context.values.open }, [
                        __document.createTextNode('Open')
                    ])
                ])
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;
;
class Open {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new modal_1.Modal({ wml: { 'id': 'open' } }, [
                __this.widget(new modal_1.ModalHeader({}, [
                    __document.createTextNode('Open')
                ]), {}),
                __this.widget(new modal_1.ModalBody({}, [
                    __this.node('p', {}, [
                        __document.createTextNode('Click this '),
                        __this.node('button', { 'onclick': __context.values.close }, [
                            __document.createTextNode('button')
                        ]),
                        __document.createTextNode(' to close.')
                    ])
                ]), {}),
                __this.widget(new modal_1.ModalFooter({}, [
                    __this.node('button', { 'onclick': __context.values.close }, [
                        __document.createTextNode('cancel')
                    ])
                ]), {})
            ]), { wml: { 'id': 'open' } });
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Open = Open;

},{"../../../../../../lib/dialog/modal":104,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],239:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PromptPage = void 0;
const views = require("./wml/prompt");
class PromptPage {
    constructor() {
        this.view = new views.Main(this);
        this.v = new views.Open(this);
        this.values = {
            value: 'Click the button bellow to change this text.',
            title: 'Change the text',
            onChange: (e) => this.values.value = e.value,
            onSave: () => {
                this.view.invalidate();
            },
            onCancel: () => {
            },
            open: () => {
                document.body.appendChild(this.v.render());
            },
            close: () => {
                this.v.findById('open')
                    .map(m => m.close());
            }
        };
    }
}
exports.PromptPage = PromptPage;
exports.default = new PromptPage();

},{"./wml/prompt":240}],240:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Open = exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const text_field_1 = require("../../../../../../lib/control/text-field");
;
const prompt_1 = require("../../../../../../lib/dialog/prompt");
;
const demo_1 = require("../../../widgets/demo");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.node('h1', {}, [
                    __document.createTextNode('Prompt')
                ]),
                __this.node('p', {}, [
                    text(__context.values.value)
                ]),
                __this.node('p', {}, [
                    __this.node('button', { 'onclick': __context.values.open }, [
                        __document.createTextNode('Open')
                    ])
                ])
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;
;
class Open {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new prompt_1.Prompt({ wml: { 'id': 'open' }, 'title': __context.values.title, 'onSave': __context.values.onSave, 'onCancel': __context.values.onCancel }, [
                __this.widget(new text_field_1.TextField({ 'value': __context.values.value, 'onChange': __context.values.onChange }, []), { 'value': __context.values.value, 'onChange': __context.values.onChange })
            ]), { wml: { 'id': 'open' }, 'title': __context.values.title, 'onSave': __context.values.onSave, 'onCancel': __context.values.onCancel });
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Open = Open;

},{"../../../../../../lib/control/text-field":83,"../../../../../../lib/dialog/prompt":106,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],241:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CalloutPage = void 0;
const views = require("./wml/callout");
const style_1 = require("../../../../../lib/content/style");
class CalloutPage {
    constructor() {
        this.view = new views.Main(this);
        this.values = {
            capitalize: (s) => `${s[0].toUpperCase()}${s.slice(1)}`,
            styles: [
                style_1.Style.Default,
                style_1.Style.Primary,
                style_1.Style.Success,
                style_1.Style.Info,
                style_1.Style.Warning,
                style_1.Style.Error
            ]
        };
    }
}
exports.CalloutPage = CalloutPage;
exports.default = new CalloutPage();

},{"../../../../../lib/content/style":20,"./wml/callout":242}],242:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const callout_1 = require("../../../../../../lib/layout/callout");
;
const demo_1 = require("../../../widgets/demo");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.widget(new demo_1.Demo({}, [
                    __this.node('h1', {}, [
                        __document.createTextNode('Callout')
                    ]),
                    __this.node('p', {}, [
                        __this.node('h2', {}, [
                            __document.createTextNode('Styles')
                        ]),
                        ...__forIn(__context.values.styles, (v, _$$i, _$$all) => ([
                            __this.widget(new callout_1.Callout({ 'style': v }, [
                                __document.createTextNode('\u000a\u000a            This is a callout with style on display.\u000a\u000a          ')
                            ]), { 'style': v })
                        ]), () => ([]))
                    ])
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/layout/callout":111,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],243:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DescriptionListPage = void 0;
const description_list_1 = require("./wml/description-list");
class DescriptionListPage {
    constructor() {
        this.view = new description_list_1.Main(this);
    }
}
exports.DescriptionListPage = DescriptionListPage;
exports.default = new DescriptionListPage();

},{"./wml/description-list":244}],244:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const demo_1 = require("../../../widgets/demo");
;
const description_list_1 = require("../../../../../../lib/layout/description-list");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.widget(new demo_1.Demo({}, [
                    __this.widget(new description_list_1.DescriptionList({}, [
                        __this.widget(new description_list_1.Title({}, [
                            __document.createTextNode('Phone')
                        ]), {}),
                        __this.widget(new description_list_1.Data({}, [
                            __document.createTextNode('6385532')
                        ]), {}),
                        __this.widget(new description_list_1.Title({}, [
                            __document.createTextNode('Email')
                        ]), {}),
                        __this.widget(new description_list_1.Data({}, [
                            __document.createTextNode('hel@lo.com')
                        ]), {}),
                        __this.widget(new description_list_1.Title({}, [
                            __document.createTextNode('Website')
                        ]), {}),
                        __this.widget(new description_list_1.Data({}, [
                            __document.createTextNode('example.com')
                        ]), {})
                    ]), {})
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.widget(new description_list_1.DescriptionList({ 'horizontal': true }, [
                        __this.widget(new description_list_1.Title({}, [
                            __document.createTextNode('Phone')
                        ]), {}),
                        __this.widget(new description_list_1.Data({}, [
                            __document.createTextNode('6385532')
                        ]), {}),
                        __this.widget(new description_list_1.Title({}, [
                            __document.createTextNode('Email')
                        ]), {}),
                        __this.widget(new description_list_1.Data({}, [
                            __document.createTextNode('hel@lo.com')
                        ]), {}),
                        __this.widget(new description_list_1.Title({}, [
                            __document.createTextNode('Website')
                        ]), {}),
                        __this.widget(new description_list_1.Data({}, [
                            __document.createTextNode('example.com')
                        ]), {})
                    ]), { 'horizontal': true })
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/layout/description-list":113,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],245:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GridLayoutPage = void 0;
const views = require("./wml/grid");
class GridLayoutPage {
    constructor() {
        this.view = new views.Main(this);
        this.values = {
            root: {
                className: 'grid-layout-example'
            }
        };
    }
}
exports.GridLayoutPage = GridLayoutPage;
exports.default = new GridLayoutPage();

},{"./wml/grid":246}],246:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const grid_1 = require("../../../../../../lib/layout/grid");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new grid_1.GridLayout({ 'className': __context.values.root.className }, [
                __this.widget(new grid_1.Row({}, [
                    __this.widget(new grid_1.Column({ 'span': 1 }, [
                        __document.createTextNode('Span 1')
                    ]), { 'span': 1 }),
                    __this.widget(new grid_1.Column({ 'span': 1 }, [
                        __document.createTextNode('Span 1')
                    ]), { 'span': 1 }),
                    __this.widget(new grid_1.Column({ 'span': 1 }, [
                        __document.createTextNode('Span 1')
                    ]), { 'span': 1 }),
                    __this.widget(new grid_1.Column({ 'span': 1 }, [
                        __document.createTextNode('Span 1')
                    ]), { 'span': 1 }),
                    __this.widget(new grid_1.Column({ 'span': 1 }, [
                        __document.createTextNode('Span 1')
                    ]), { 'span': 1 }),
                    __this.widget(new grid_1.Column({ 'span': 1 }, [
                        __document.createTextNode('Span 1')
                    ]), { 'span': 1 }),
                    __this.widget(new grid_1.Column({ 'span': 1 }, [
                        __document.createTextNode('Span 1')
                    ]), { 'span': 1 }),
                    __this.widget(new grid_1.Column({ 'span': 1 }, [
                        __document.createTextNode('Span 1')
                    ]), { 'span': 1 }),
                    __this.widget(new grid_1.Column({ 'span': 1 }, [
                        __document.createTextNode('Span 1')
                    ]), { 'span': 1 }),
                    __this.widget(new grid_1.Column({ 'span': 1 }, [
                        __document.createTextNode('Span 1')
                    ]), { 'span': 1 }),
                    __this.widget(new grid_1.Column({ 'span': 1 }, [
                        __document.createTextNode('Span 1')
                    ]), { 'span': 1 }),
                    __this.widget(new grid_1.Column({ 'span': 1 }, [
                        __document.createTextNode('Span 1')
                    ]), { 'span': 1 })
                ]), {}),
                __this.widget(new grid_1.Row({}, [
                    __this.widget(new grid_1.Column({ 'span': 8 }, [
                        __document.createTextNode('Span 8')
                    ]), { 'span': 8 }),
                    __this.widget(new grid_1.Column({ 'span': 4 }, [
                        __document.createTextNode('Span 4')
                    ]), { 'span': 4 })
                ]), {}),
                __this.widget(new grid_1.Row({}, [
                    __this.widget(new grid_1.Column({ 'span': 4 }, [
                        __document.createTextNode('Span 4')
                    ]), { 'span': 4 }),
                    __this.widget(new grid_1.Column({ 'span': 4 }, [
                        __document.createTextNode('Span 4')
                    ]), { 'span': 4 }),
                    __this.widget(new grid_1.Column({ 'span': 4 }, [
                        __document.createTextNode('Span 4')
                    ]), { 'span': 4 })
                ]), {}),
                __this.widget(new grid_1.Row({}, [
                    __this.widget(new grid_1.Column({ 'span': 6 }, [
                        __document.createTextNode('Span 6')
                    ]), { 'span': 6 }),
                    __this.widget(new grid_1.Column({ 'span': 6 }, [
                        __document.createTextNode('Span 6')
                    ]), { 'span': 6 })
                ]), {}),
                __this.widget(new grid_1.Row({}, [
                    __this.widget(new grid_1.Column({ 'span': 6 }, [
                        __document.createTextNode('Span 6')
                    ]), { 'span': 6 }),
                    __this.widget(new grid_1.Column({ 'span': 6 }, [
                        __document.createTextNode('Span 6')
                    ]), { 'span': 6 }),
                    __this.widget(new grid_1.Column({ 'span': 6 }, [
                        __document.createTextNode('Span 6')
                    ]), { 'span': 6 }),
                    __this.widget(new grid_1.Column({ 'span': 6 }, [
                        __document.createTextNode('Span 6')
                    ]), { 'span': 6 })
                ]), {}),
                __this.widget(new grid_1.Row({}, [
                    __this.widget(new grid_1.Column({ 'span': 12 }, [
                        __document.createTextNode('Span 12')
                    ]), { 'span': 12 })
                ]), {})
            ]), { 'className': __context.values.root.className });
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/layout/grid":117,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],247:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HorizontalLayoutPage = void 0;
const views = require("./wml/horizontal");
class HorizontalLayoutPage {
    constructor() {
        this.view = new views.Main(this);
    }
}
exports.HorizontalLayoutPage = HorizontalLayoutPage;
exports.default = new HorizontalLayoutPage();

},{"./wml/horizontal":248}],248:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const demo_1 = require("../../../widgets/demo");
;
const horizontal_1 = require("../../../../../../lib/layout/horizontal");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.widget(new demo_1.Demo({}, [
                    __this.widget(new horizontal_1.HorizontalLayout({}, [
                        __this.node('textarea', {}, [
                            __document.createTextNode('Area 1')
                        ]),
                        __this.node('textarea', {}, [
                            __document.createTextNode('Area 2')
                        ]),
                        __this.node('textarea', {}, [
                            __document.createTextNode('Area 3')
                        ])
                    ]), {})
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.widget(new horizontal_1.HorizontalLayout({ 'orientation': horizontal_1.HorizontalLayoutOrientation.Left }, [
                        __document.createTextNode('\u000a      This is oriented to the left.\u000a    ')
                    ]), { 'orientation': horizontal_1.HorizontalLayoutOrientation.Left })
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.widget(new horizontal_1.HorizontalLayout({ 'orientation': horizontal_1.HorizontalLayoutOrientation.Right }, [
                        __document.createTextNode('\u000a      This is oriented to the right.\u000a    ')
                    ]), { 'orientation': horizontal_1.HorizontalLayoutOrientation.Right })
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/layout/horizontal":119,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],249:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ListLayoutPage = void 0;
const list_1 = require("./wml/list");
class ListLayoutPage {
    constructor() {
        this.view = new list_1.Main(this);
        this.items = {
            'This is the first item.': false,
            'This is the second item.': true,
            'This is the third item.': false
        };
        this.click = (key) => this
            .view
            .findById(key)
            .map(l => l.toggleActive())
            .orJust(() => alert(`Cannot find element by id "${key}"!`));
    }
}
exports.ListLayoutPage = ListLayoutPage;
exports.default = new ListLayoutPage();

},{"./wml/list":250}],250:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const demo_1 = require("../../../widgets/demo");
;
const list_1 = require("../../../../../../lib/layout/list");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.widget(new list_1.ListLayout({}, [
                    ...__forOf(__context.items, (yes, key, _$$all) => ([
                        __this.widget(new list_1.ListLayoutItem({ wml: { 'id': key }, 'name': key, 'active': yes, 'onClick': __context.click }, [
                            __this.node('p', {}, [
                                document.createTextNode(key)
                            ])
                        ]), { wml: { 'id': key }, 'name': key, 'active': yes, 'onClick': __context.click })
                    ]), () => ([]))
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/layout/list":122,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],251:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MeterPage = void 0;
const views = require("./wml/meter");
class MeterPage {
    constructor() {
        this.view = new views.Main(this);
        this.values = {
            message: 'This is an alert',
            bars: [
                { value: 10, color: 'red' },
                { value: 50, color: 'green' },
                { value: 40, color: 'blue' }
            ],
            inc: () => {
                let m = this.view.findById('single');
                if (m.isJust())
                    m.get().increase(10);
            },
            dec: () => {
                let m = this.view.findById('single');
                if (m.isJust())
                    m.get().decrease(10);
            }
        };
    }
}
exports.MeterPage = MeterPage;
exports.default = new MeterPage();

},{"./wml/meter":252}],252:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const meter_1 = require("../../../../../../lib/layout/meter");
;
const demo_1 = require("../../../widgets/demo");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.node('h1', {}, [
                    __document.createTextNode('Meter')
                ]),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('h2', {}, [
                        __document.createTextNode('Single')
                    ]),
                    __this.node('p', {}, [
                        __this.node('button', { 'onclick': __context.values.dec }, [
                            __document.createTextNode('-')
                        ]),
                        __this.node('button', { 'onclick': __context.values.inc }, [
                            __document.createTextNode('+')
                        ])
                    ]),
                    __this.widget(new meter_1.Meter({}, [
                        __this.widget(new meter_1.MeterBar({ wml: { 'id': 'single' }, 'value': 75, 'color': 'yellow' }, []), { wml: { 'id': 'single' }, 'value': 75, 'color': 'yellow' })
                    ]), {})
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('p', {}, [
                        __this.node('h2', {}, [
                            __document.createTextNode('Combined')
                        ]),
                        __this.widget(new meter_1.Meter({}, [
                            ...__forIn(__context.values.bars, (v, _$$i, _$$all) => ([
                                __this.widget(new meter_1.MeterBar({ 'value': v.value, 'color': v.color }, []), { 'value': v.value, 'color': v.color })
                            ]), () => ([]))
                        ]), {})
                    ])
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/layout/meter":126,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],253:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PanelPage = void 0;
const panel_1 = require("./wml/panel");
class PanelPage {
    constructor() {
        this.view = new panel_1.Main(this);
    }
}
exports.PanelPage = PanelPage;
exports.default = new PanelPage();

},{"./wml/panel":254}],254:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const grid_1 = require("../../../../../../lib/layout/grid");
;
const panel_1 = require("../../../../../../lib/layout/panel");
;
const style_1 = require("../../../../../../lib/content/style");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new grid_1.GridLayout({}, [
                ...__forIn(style_1.styles, (style, _$$i, _$$all) => ([
                    __this.widget(new grid_1.Row({}, [
                        __this.widget(new grid_1.Column({ 'span': 4 }, [
                            __this.widget(new panel_1.Panel({ 'style': style }, [
                                __this.widget(new panel_1.PanelBody({}, [
                                    __document.createTextNode('\u000a            PanelBody only.\u000a          ')
                                ]), {})
                            ]), { 'style': style })
                        ]), { 'span': 4 }),
                        __this.widget(new grid_1.Column({ 'span': 4 }, [
                            __this.widget(new panel_1.Panel({ 'style': style }, [
                                __this.widget(new panel_1.PanelHeader({}, [
                                    __document.createTextNode('\u000a            With PanelHeader\u000a          ')
                                ]), {}),
                                __this.widget(new panel_1.PanelBody({}, [
                                    __document.createTextNode('\u000a            Lorem impsum dilium net set.\u000a          ')
                                ]), {})
                            ]), { 'style': style })
                        ]), { 'span': 4 }),
                        __this.widget(new grid_1.Column({ 'span': 4 }, [
                            __this.widget(new panel_1.Panel({ 'style': style }, [
                                __this.widget(new panel_1.PanelHeader({}, [
                                    __document.createTextNode('With PanelFooter')
                                ]), {}),
                                __this.widget(new panel_1.PanelBody({}, [
                                    __document.createTextNode('Lorem impsum dilium net set.')
                                ]), {}),
                                __this.widget(new panel_1.PanelFooter({}, [
                                    __document.createTextNode('Meh foot.')
                                ]), {})
                            ]), { 'style': style })
                        ]), { 'span': 4 })
                    ]), {})
                ]), () => ([]))
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/content/style":20,"../../../../../../lib/layout/grid":117,"../../../../../../lib/layout/panel":128,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],255:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TabLayoutPage = void 0;
const views = require("./wml/tab");
class TabLayoutPage {
    constructor() {
        this.view = new views.Main(this);
        this.tabs = {
            first: {
                text: 'First',
                contentFun: views.firstTab
            },
            second: {
                text: 'Second',
                contentFun: views.secondTab
            },
            third: {
                text: 'Third',
                contentFun: views.thirdTab
            }
        };
    }
}
exports.TabLayoutPage = TabLayoutPage;
exports.default = new TabLayoutPage();

},{"./wml/tab":256}],256:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = exports.thirdTab = exports.secondTab = exports.firstTab = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const demo_1 = require("../../../widgets/demo");
;
const tab_1 = require("../../../../../../lib/layout/tab");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
const firstTab = (_) => (__this) => {
    return [
        __this.node('p', {}, [
            __document.createTextNode('Click a tab to change content.')
        ])
    ];
};
exports.firstTab = firstTab;
;
const secondTab = (_) => (__this) => {
    return [
        __this.node('p', {}, [
            __document.createTextNode('Second tab.')
        ])
    ];
};
exports.secondTab = secondTab;
;
const thirdTab = (_) => (__this) => {
    return [
        __this.node('p', {}, [
            __document.createTextNode('Third tab.')
        ])
    ];
};
exports.thirdTab = thirdTab;
;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.widget(new tab_1.TabLayout({ 'tabs': __context.tabs, 'active': 'first' }, [
                    __this.node('p', {}, [
                        __document.createTextNode('Click a tab to change content.')
                    ])
                ]), { 'tabs': __context.tabs, 'active': 'first' })
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/layout/tab":130,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],257:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TableLayoutPage = void 0;
const table_1 = require("./wml/table");
class TableLayoutPage {
    constructor() {
        this.view = new table_1.Main(this);
    }
}
exports.TableLayoutPage = TableLayoutPage;
exports.default = new TableLayoutPage();

},{"./wml/table":258}],258:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = exports.FooterView = exports.BodyView = exports.HeaderView = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const demo_1 = require("../../../widgets/demo");
;
const table_1 = require("../../../../../../lib/layout/table");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class HeaderView {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new table_1.TableHeader({}, [
                __this.widget(new table_1.TableRow({}, [
                    __this.widget(new table_1.TableHeading({}, [
                        __document.createTextNode('Name')
                    ]), {}),
                    __this.widget(new table_1.TableHeading({}, [
                        __document.createTextNode('Email')
                    ]), {}),
                    __this.widget(new table_1.TableHeading({}, [
                        __document.createTextNode('Balance')
                    ]), {}),
                    __this.widget(new table_1.TableHeading({}, [
                        __document.createTextNode('Username')
                    ]), {}),
                    __this.widget(new table_1.TableHeading({}, [
                        __document.createTextNode('Status')
                    ]), {})
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.HeaderView = HeaderView;
;
class BodyView {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new table_1.TableBody({}, [
                __this.widget(new table_1.TableRow({}, [
                    __this.widget(new table_1.TableCell({}, [
                        __document.createTextNode('Length Wise')
                    ]), {}),
                    __this.widget(new table_1.TableCell({}, [
                        __document.createTextNode('lw@theemailplace.com')
                    ]), {}),
                    __this.widget(new table_1.TableCell({}, [
                        __document.createTextNode('$5000')
                    ]), {}),
                    __this.widget(new table_1.TableCell({}, [
                        __document.createTextNode('lw')
                    ]), {}),
                    __this.widget(new table_1.TableCell({}, [
                        __document.createTextNode('Active')
                    ]), {})
                ]), {}),
                __this.widget(new table_1.TableRow({}, [
                    __this.widget(new table_1.TableCell({}, [
                        __document.createTextNode('First Chance')
                    ]), {}),
                    __this.widget(new table_1.TableCell({}, [
                        __document.createTextNode('fchacne@live.tt')
                    ]), {}),
                    __this.widget(new table_1.TableCell({}, [
                        __document.createTextNode('$1.00')
                    ]), {}),
                    __this.widget(new table_1.TableCell({}, [
                        __document.createTextNode('chance')
                    ]), {}),
                    __this.widget(new table_1.TableCell({}, [
                        __document.createTextNode('Inactive')
                    ]), {})
                ]), {}),
                __this.widget(new table_1.TableRow({}, [
                    __this.widget(new table_1.TableCell({}, [
                        __document.createTextNode('Du Pear')
                    ]), {}),
                    __this.widget(new table_1.TableCell({}, [
                        __document.createTextNode('dupear@gmail.com')
                    ]), {}),
                    __this.widget(new table_1.TableCell({}, [
                        __document.createTextNode('$10,000.00')
                    ]), {}),
                    __this.widget(new table_1.TableCell({}, [
                        __document.createTextNode('pearboy')
                    ]), {}),
                    __this.widget(new table_1.TableCell({}, [
                        __document.createTextNode('Active')
                    ]), {})
                ]), {}),
                __this.widget(new table_1.TableRow({}, [
                    __this.widget(new table_1.TableCell({ 'rowspan': 2, 'colspan': 5 }, [
                        __document.createTextNode('This spans 2 rows 5 columns.')
                    ]), { 'rowspan': 2, 'colspan': 5 })
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.BodyView = BodyView;
;
class FooterView {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new table_1.TableFooter({}, [
                __this.widget(new table_1.TableRow({}, [
                    __this.widget(new table_1.TableCell({}, [
                        __document.createTextNode('1')
                    ]), {}),
                    __this.widget(new table_1.TableCell({}, [
                        __document.createTextNode('2')
                    ]), {}),
                    __this.widget(new table_1.TableCell({}, [
                        __document.createTextNode('3')
                    ]), {}),
                    __this.widget(new table_1.TableCell({}, [
                        __document.createTextNode('4')
                    ]), {}),
                    __this.widget(new table_1.TableCell({}, [
                        __document.createTextNode('5')
                    ]), {})
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.FooterView = FooterView;
;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.widget(new demo_1.Demo({}, [
                    __this.node('h3', {}, [
                        __document.createTextNode('Normal')
                    ]),
                    __this.widget(new table_1.TableLayout({}, [
                        __this.registerView(new HeaderView(__context)).render(),
                        __this.registerView(new BodyView(__context)).render(),
                        __this.registerView(new FooterView(__context)).render()
                    ]), {})
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('h3', {}, [
                        __document.createTextNode(' Alternate')
                    ]),
                    __this.widget(new table_1.TableLayout({ 'alternate': true }, [
                        __this.registerView(new HeaderView(__context)).render(),
                        __this.registerView(new BodyView(__context)).render(),
                        __this.registerView(new FooterView(__context)).render()
                    ]), { 'alternate': true })
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('h3', {}, [
                        __document.createTextNode('Bordered')
                    ]),
                    __this.widget(new table_1.TableLayout({ 'bordered': true }, [
                        __this.registerView(new HeaderView(__context)).render(),
                        __this.registerView(new BodyView(__context)).render(),
                        __this.registerView(new FooterView(__context)).render()
                    ]), { 'bordered': true })
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('h3', {}, [
                        __document.createTextNode('Hoverable')
                    ]),
                    __this.widget(new table_1.TableLayout({ 'hoverable': true }, [
                        __this.registerView(new HeaderView(__context)).render(),
                        __this.registerView(new BodyView(__context)).render(),
                        __this.registerView(new FooterView(__context)).render()
                    ]), { 'hoverable': true })
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('h3', {}, [
                        __document.createTextNode('Compact')
                    ]),
                    __this.widget(new table_1.TableLayout({ 'compact': true }, [
                        __this.registerView(new HeaderView(__context)).render(),
                        __this.registerView(new BodyView(__context)).render(),
                        __this.registerView(new FooterView(__context)).render()
                    ]), { 'compact': true })
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.widget(new table_1.TableWindow({}, [
                        __this.widget(new table_1.TableLayout({}, [
                            __this.registerView(new HeaderView(__context)).render(),
                            __this.registerView(new BodyView(__context)).render(),
                            __this.registerView(new FooterView(__context)).render()
                        ]), {})
                    ]), {})
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/layout/table":132,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],259:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WellPage = void 0;
const views = require("./wml/well");
class WellPage {
    constructor() {
        this.view = new views.Main(this);
        this.values = {};
    }
}
exports.WellPage = WellPage;
exports.default = new WellPage();

},{"./wml/well":260}],260:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const well_1 = require("../../../../../../lib/layout/well");
;
const demo_1 = require("../../../widgets/demo");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.widget(new demo_1.Demo({}, [
                    __this.node('h1', {}, [
                        __document.createTextNode('Well')
                    ]),
                    __this.node('p', {}, [
                        __this.widget(new well_1.Well({}, [
                            __document.createTextNode('This is in a well.')
                        ]), {})
                    ]),
                    __this.node('p', {}, [
                        __this.widget(new well_1.Well({ 'className': '-small' }, [
                            __document.createTextNode('This is a small well.')
                        ]), { 'className': '-small' })
                    ]),
                    __this.node('p', {}, [
                        __this.widget(new well_1.Well({ 'className': '-large' }, [
                            __document.createTextNode('This is a small well.')
                        ]), { 'className': '-large' })
                    ])
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/layout/well":134,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],261:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MenuPage = void 0;
const menu_1 = require("./wml/menu");
class MenuPage {
    constructor() {
        this.view = new menu_1.Main(this);
    }
}
exports.MenuPage = MenuPage;
exports.default = new MenuPage();

},{"./wml/menu":262}],262:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const demo_1 = require("../../../widgets/demo");
;
const menu_1 = require("../../../../../../lib/menu/menu");
;
const item_1 = require("../../../../../../lib/menu/item");
;
const link_1 = require("../../../../../../lib/content/link");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.widget(new menu_1.Menu({}, [
                    __this.widget(new item_1.Item({}, [
                        __this.node('h6', {}, [
                            __document.createTextNode('Menu')
                        ])
                    ]), {}),
                    __this.widget(new item_1.Item({}, [
                        __this.widget(new link_1.Link({ 'disabled': true, 'text': 'Back' }, []), { 'disabled': true, 'text': 'Back' })
                    ]), {}),
                    __this.widget(new item_1.Item({}, [
                        __this.widget(new link_1.Link({ 'disabled': true, 'text': 'Refresh' }, []), { 'disabled': true, 'text': 'Refresh' })
                    ]), {}),
                    __this.widget(new item_1.Divider({}, []), {}),
                    __this.widget(new item_1.Item({}, [
                        __this.node('a', { 'href': '#/menu' }, [
                            __document.createTextNode('Quit')
                        ])
                    ]), {})
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/content/link":7,"../../../../../../lib/menu/item":140,"../../../../../../lib/menu/menu":142,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],263:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NavPage = void 0;
const nav_1 = require("./wml/nav");
class NavPage {
    constructor() {
        this.view = new nav_1.Main(this);
    }
}
exports.NavPage = NavPage;
exports.default = new NavPage();

},{"./wml/nav":264}],264:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const demo_1 = require("../../../widgets/demo");
;
const nav_1 = require("../../../../../../lib/menu/nav");
;
const item_1 = require("../../../../../../lib/menu/item");
;
const link_1 = require("../../../../../../lib/content/link");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new demo_1.Demo({}, [
                __this.widget(new demo_1.Demo({}, [
                    __this.node('h3', {}, [
                        __document.createTextNode('This is a horizontal nav.')
                    ]),
                    __this.widget(new nav_1.NavMenu({}, [
                        __this.widget(new item_1.Item({}, [
                            __this.widget(new link_1.Link({ 'text': 'Home' }, []), { 'text': 'Home' })
                        ]), {}),
                        __this.widget(new item_1.Item({}, [
                            __this.widget(new link_1.Link({ 'disabled': true, 'text': 'Users' }, []), { 'disabled': true, 'text': 'Users' })
                        ]), {}),
                        __this.widget(new item_1.Item({}, [
                            __this.widget(new link_1.Link({ 'text': 'Logout' }, []), { 'text': 'Logout' })
                        ]), {})
                    ]), {})
                ]), {}),
                __this.widget(new demo_1.Demo({}, [
                    __this.node('h3', {}, [
                        __document.createTextNode('This is a vertical nav.')
                    ]),
                    __this.widget(new nav_1.NavMenu({ 'vertical': true }, [
                        __this.widget(new item_1.Item({}, [
                            __this.widget(new link_1.Link({ 'text': 'Home' }, []), { 'text': 'Home' })
                        ]), {}),
                        __this.widget(new item_1.Item({}, [
                            __this.widget(new link_1.Link({ 'disabled': true, 'text': 'Users' }, []), { 'disabled': true, 'text': 'Users' })
                        ]), {}),
                        __this.widget(new item_1.Item({}, [
                            __this.widget(new link_1.Link({ 'text': 'Logout' }, []), { 'text': 'Logout' })
                        ]), {})
                    ]), { 'vertical': true })
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/content/link":7,"../../../../../../lib/menu/item":140,"../../../../../../lib/menu/nav":145,"../../../widgets/demo":266,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],265:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pages = void 0;
exports.pages = {
    'content_embed': require('./page/content_embed').default,
    'content_link': require('./page/content_link').default,
    'content_media-description': require('./page/content_media-description').default,
    'content_overlay': require('./page/content_overlay').default,
    'content_tag': require('./page/content_tag').default,
    'content_thumbnail': require('./page/content_thumbnail').default,
    'control_button': require('./page/control_button').default,
    'control_button-group': require('./page/control_button-group').default,
    'control_button-select': require('./page/control_button-select').default,
    'control_checkbox': require('./page/control_checkbox').default,
    'control_date-field': require('./page/control_date-field').default,
    'control_display-field': require('./page/control_display-field').default,
    'control_drop-down': require('./page/control_drop-down').default,
    'control_drop-list': require('./page/control_drop-list').default,
    'control_drop-list-field': require('./page/control_drop-list-field').default,
    'control_file-upload-surface': require('./page/control_file-upload-surface').default,
    'control_input-group': require('./page/control_input-group').default,
    'control_multi-select': require('./page/control_multi-select').default,
    'control_pager': require('./page/control_pager').default,
    'control_paginator': require('./page/control_paginator').default,
    'control_ranged-pager': require('./page/control_ranged-pager').default,
    'control_search': require('./page/control_search').default,
    'control_select': require('./page/control_select').default,
    'control_stack': require('./page/control_stack').default,
    'control_stack-select': require('./page/control_stack-select').default,
    'control_switch': require('./page/control_switch').default,
    'control_tab-bar': require('./page/control_tab-bar').default,
    'control_tag-control': require('./page/control_tag-control').default,
    'control_text-field': require('./page/control_text-field').default,
    'control_text-input': require('./page/control_text-input').default,
    'control_toolbar': require('./page/control_toolbar').default,
    'control_typeahead': require('./page/control_typeahead').default,
    'data_data-table': require('./page/data_data-table').default,
    'data_property-list': require('./page/data_property-list').default,
    'dialog_alert': require('./page/dialog_alert').default,
    'dialog_confirm': require('./page/dialog_confirm').default,
    'dialog_inform': require('./page/dialog_inform').default,
    'dialog_modal': require('./page/dialog_modal').default,
    'dialog_prompt': require('./page/dialog_prompt').default,
    'layout_callout': require('./page/layout_callout').default,
    'layout_description-list': require('./page/layout_description-list').default,
    'layout_grid': require('./page/layout_grid').default,
    'layout_horizontal': require('./page/layout_horizontal').default,
    'layout_list': require('./page/layout_list').default,
    'layout_meter': require('./page/layout_meter').default,
    'layout_panel': require('./page/layout_panel').default,
    'layout_tab': require('./page/layout_tab').default,
    'layout_table': require('./page/layout_table').default,
    'layout_well': require('./page/layout_well').default,
    'menu_menu': require('./page/menu_menu').default,
    'menu_nav': require('./page/menu_nav').default,
};

},{"./page/content_embed":162,"./page/content_link":164,"./page/content_media-description":166,"./page/content_overlay":168,"./page/content_tag":170,"./page/content_thumbnail":172,"./page/control_button":178,"./page/control_button-group":174,"./page/control_button-select":176,"./page/control_checkbox":180,"./page/control_date-field":182,"./page/control_display-field":184,"./page/control_drop-down":186,"./page/control_drop-list":190,"./page/control_drop-list-field":188,"./page/control_file-upload-surface":192,"./page/control_input-group":194,"./page/control_multi-select":196,"./page/control_pager":198,"./page/control_paginator":200,"./page/control_ranged-pager":202,"./page/control_search":204,"./page/control_select":206,"./page/control_stack":210,"./page/control_stack-select":208,"./page/control_switch":212,"./page/control_tab-bar":214,"./page/control_tag-control":216,"./page/control_text-field":218,"./page/control_text-input":220,"./page/control_toolbar":222,"./page/control_typeahead":224,"./page/data_data-table":227,"./page/data_property-list":229,"./page/dialog_alert":231,"./page/dialog_confirm":233,"./page/dialog_inform":235,"./page/dialog_modal":237,"./page/dialog_prompt":239,"./page/layout_callout":241,"./page/layout_description-list":243,"./page/layout_grid":245,"./page/layout_horizontal":247,"./page/layout_list":249,"./page/layout_meter":251,"./page/layout_panel":253,"./page/layout_tab":255,"./page/layout_table":257,"./page/layout_well":259,"./page/menu_menu":261,"./page/menu_nav":263}],266:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Demo = void 0;
const wml = require("@quenk/wml");
const views = require("./wml/demo");
class Demo extends wml.Component {
    constructor() {
        super(...arguments);
        this.view = new views.Main(this);
        this.values = {
            size: this.attrs.size,
            offset: this.attrs.offset
        };
    }
}
exports.Demo = Demo;

},{"./wml/demo":267,"@quenk/wml":157}],267:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const grid_1 = require("../../../../../../lib/layout/grid");
;
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new grid_1.GridLayout({}, [
                __this.widget(new grid_1.Row({}, [
                    __this.widget(new grid_1.Column({ 'span': __context.values.size }, [
                        ...(__context.children)
                    ]), { 'span': __context.values.size })
                ]), {})
            ]), {});
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../../../lib/layout/grid":117,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],268:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
const drawer_1 = require("../../../../lib/layout/drawer");
;
const action_bar_1 = require("../../../../lib/layout/action-bar");
;
const link_1 = require("../../../../lib/content/link");
;
const menu_icon_1 = require("../../../../lib/content/menu-icon");
;
const main_1 = require("../../../../lib/layout/main");
;
;
const navigation_1 = require("./navigation");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Main {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new drawer_1.DrawerLayout({ wml: { 'id': __context.values.id.layout }, 'drawer': 'nav', 'content': 'main', 'open': true }, [
                __this.registerView(new navigation_1.Navigation(__context)).render(),
                __this.widget(new action_bar_1.ActionBar({ 'id': 'appBar' }, [
                    __this.widget(new link_1.Link({ 'onClick': __context.toggleDrawer }, [
                        __this.widget(new menu_icon_1.MenuIcon({}, []), {})
                    ]), { 'onClick': __context.toggleDrawer })
                ]), { 'id': 'appBar' }),
                __this.widget(new main_1.MainLayout({ 'id': 'main' }, [
                    ...(__context.content)
                ]), { 'id': 'main' })
            ]), { wml: { 'id': __context.values.id.layout }, 'drawer': 'nav', 'content': 'main', 'open': true });
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Main = Main;

},{"../../../../lib/content/link":7,"../../../../lib/content/menu-icon":11,"../../../../lib/layout/action-bar":109,"../../../../lib/layout/drawer":115,"../../../../lib/layout/main":124,"./navigation":269,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}],269:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Navigation = void 0;
const __document = require("@quenk/wml/lib/dom");
//@ts-ignore: 6192
const maybe_1 = require("@quenk/noni/lib/data/maybe");
;
const nav_1 = require("../../../../lib/menu/nav");
;
const item_1 = require("../../../../lib/menu/item");
;
const header_1 = require("../../../../lib/menu/header");
;
const link_1 = require("../../../../lib/content/link");
//@ts-ignore:6192
const __if = (__expr, __conseq, __alt) => (__expr) ? __conseq() : __alt ? __alt() : [];
//@ts-ignore:6192
const __forIn = (list, f, alt) => {
    let ret = [];
    for (let i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
const __forOf = (o, f, alt) => {
    let ret = [];
    for (let key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
// @ts-ignore 6192
const text = __document.text;
// @ts-ignore 6192
const unsafe = __document.unsafe;
// @ts-ignore 6192
const isSet = (value) => value != null;
class Navigation {
    constructor(__context) {
        this.ids = {};
        this.groups = {};
        this.views = [];
        this.widgets = [];
        this.tree = __document.createElement('div');
        this.template = (__this) => {
            return __this.widget(new nav_1.NavMenu({ 'id': 'nav', 'vertical': true }, [
                __this.widget(new item_1.Item({}, [
                    __this.widget(new link_1.Link({ wml: { 'group': 'links' }, 'active': (__context.page === 'home'), 'name': 'home', 'href': '#', 'onClick': __context.navigate, 'text': 'Home' }, []), { wml: { 'group': 'links' }, 'active': (__context.page === 'home'), 'name': 'home', 'href': '#', 'onClick': __context.navigate, 'text': 'Home' })
                ]), {}),
                ...__forOf(__context.pages, (items, section, _$$all) => ([
                    __this.widget(new item_1.Item({}, [
                        __this.widget(new header_1.MenuHeader({ 'text': section }, []), { 'text': section }),
                        __this.widget(new nav_1.NavMenu({ 'vertical': true }, [
                            ...__forOf(items, (_, name, _$$all) => ([
                                __this.widget(new item_1.Item({}, [
                                    __this.widget(new link_1.Link({ wml: { 'group': 'links' }, 'name': name, 'href': ('#/' + name), 'onClick': __context.navigate, 'active': (__context.page === name), 'text': name }, []), { wml: { 'group': 'links' }, 'name': name, 'href': ('#/' + name), 'onClick': __context.navigate, 'active': (__context.page === name), 'text': name })
                                ]), {})
                            ]), () => ([]))
                        ]), { 'vertical': true })
                    ]), {})
                ]), () => ([]))
            ]), { 'id': 'nav', 'vertical': true });
        };
    }
    registerView(v) {
        this.views.push(v);
        return v;
    }
    register(e, attrs) {
        let attrsMap = attrs;
        if (attrsMap.wml) {
            let { id, group } = attrsMap.wml;
            if (id != null) {
                if (this.ids.hasOwnProperty(id))
                    throw new Error(`Duplicate id '${id}' detected!`);
                this.ids[id] = e;
            }
            if (group != null) {
                this.groups[group] = this.groups[group] || [];
                this.groups[group].push(e);
            }
        }
        return e;
    }
    node(tag, attrs, children) {
        let e = __document.createElement(tag);
        Object.keys(attrs).forEach(key => {
            let value = attrs[key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                //prevent setting things like disabled=''
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, '');
            }
            else if (!__document.isBrowser &&
                value instanceof __document.WMLDOMText) {
                e.setAttribute(key, value);
            }
        });
        children.forEach(c => {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    let tn = __document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError(`Can not adopt child ${c} of type ${typeof c}`);
            }
        });
        this.register(e, attrs);
        return e;
    }
    widget(w, attrs) {
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    }
    findById(id) {
        let mW = (0, maybe_1.fromNullable)(this.ids[id]);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findById(id), mW);
    }
    findByGroup(name) {
        let mGroup = (0, maybe_1.fromArray)(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
        return this.views.reduce((p, c) => p.isJust() ? p : c.findByGroup(name), mGroup);
    }
    invalidate() {
        let { tree } = this;
        let parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Missing DOM tree!');
        if (tree.parentNode == null)
            throw new Error('invalidate(): cannot invalidate this view, it has no parent node!');
        parent.replaceChild(this.render(), tree);
    }
    render() {
        this.ids = {};
        this.widgets.forEach(w => w.removed());
        this.widgets = [];
        this.views = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(w => w.rendered());
        return this.tree;
    }
}
exports.Navigation = Navigation;

},{"../../../../lib/content/link":7,"../../../../lib/menu/header":138,"../../../../lib/menu/item":140,"../../../../lib/menu/nav":145,"@quenk/noni/lib/data/maybe":151,"@quenk/wml/lib/dom":156}]},{},[160])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsaWIvY29udGVudC9jYXJldC9pbmRleC5qcyIsImxpYi9jb250ZW50L2NhcmV0L3dtbC9jYXJldC5qcyIsImxpYi9jb250ZW50L2Nsb3NlL2luZGV4LmpzIiwibGliL2NvbnRlbnQvY2xvc2Uvd21sL2Nsb3NlLmpzIiwibGliL2NvbnRlbnQvZW1iZWQvaW5kZXguanMiLCJsaWIvY29udGVudC9lbWJlZC93bWwvZW1iZWQuanMiLCJsaWIvY29udGVudC9saW5rL2luZGV4LmpzIiwibGliL2NvbnRlbnQvbGluay92aWV3cy5qcyIsImxpYi9jb250ZW50L21lZGlhLWRlc2NyaXB0aW9uL2luZGV4LmpzIiwibGliL2NvbnRlbnQvbWVkaWEtZGVzY3JpcHRpb24vd21sL21lZGlhLWRlc2NyaXB0aW9uLmpzIiwibGliL2NvbnRlbnQvbWVudS1pY29uL2luZGV4LmpzIiwibGliL2NvbnRlbnQvbWVudS1pY29uL3dtbC9tZW51LWljb24uanMiLCJsaWIvY29udGVudC9vcmllbnRhdGlvbi5qcyIsImxpYi9jb250ZW50L292ZXJsYXkvaW5kZXguanMiLCJsaWIvY29udGVudC9vdmVybGF5L3dtbC9vdmVybGF5LmpzIiwibGliL2NvbnRlbnQvc2l6ZS5qcyIsImxpYi9jb250ZW50L3N0YXRlL2FjdGl2ZS5qcyIsImxpYi9jb250ZW50L3N0YXRlL2Rpc2FibGVkLmpzIiwibGliL2NvbnRlbnQvc3RhdGUvaGlkZGVuLmpzIiwibGliL2NvbnRlbnQvc3R5bGUvaW5kZXguanMiLCJsaWIvY29udGVudC90YWcvaW5kZXguanMiLCJsaWIvY29udGVudC90YWcvd21sL3RhZy5qcyIsImxpYi9jb250ZW50L3RodW1ibmFpbC9pbmRleC5qcyIsImxpYi9jb250ZW50L3RodW1ibmFpbC93bWwvdGh1bWJuYWlsLmpzIiwibGliL2NvbnRyb2wvYnV0dG9uLWdyb3VwL2luZGV4LmpzIiwibGliL2NvbnRyb2wvYnV0dG9uLWdyb3VwL3dtbC9idXR0b24tZ3JvdXAuanMiLCJsaWIvY29udHJvbC9idXR0b24tc2VsZWN0L2luZGV4LmpzIiwibGliL2NvbnRyb2wvYnV0dG9uLXNlbGVjdC93bWwvYnV0dG9uLXNlbGVjdC5qcyIsImxpYi9jb250cm9sL2J1dHRvbi9pbmRleC5qcyIsImxpYi9jb250cm9sL2J1dHRvbi93bWwvYnV0dG9uLmpzIiwibGliL2NvbnRyb2wvY2hlY2tib3gvaW5kZXguanMiLCJsaWIvY29udHJvbC9jaGVja2JveC93bWwvY2hlY2tib3guanMiLCJsaWIvY29udHJvbC9jbG9zZS1idXR0b24vaW5kZXguanMiLCJsaWIvY29udHJvbC9jbG9zZS1idXR0b24vd21sL2Nsb3NlLWJ1dHRvbi5qcyIsImxpYi9jb250cm9sL2RhdGUtZmllbGQvaW5kZXguanMiLCJsaWIvY29udHJvbC9kYXRlLWZpZWxkL3dtbC9kYXRlLWZpZWxkLmpzIiwibGliL2NvbnRyb2wvZGlzcGxheS1maWVsZC9pbmRleC5qcyIsImxpYi9jb250cm9sL2Rpc3BsYXktZmllbGQvd21sL2Rpc3BsYXktZmllbGQuanMiLCJsaWIvY29udHJvbC9kcm9wLWRvd24vaW5kZXguanMiLCJsaWIvY29udHJvbC9kcm9wLWRvd24vd21sL2Ryb3AtZG93bi5qcyIsImxpYi9jb250cm9sL2Ryb3AtbGlzdC1maWVsZC9pbmRleC5qcyIsImxpYi9jb250cm9sL2Ryb3AtbGlzdC1maWVsZC93bWwvZHJvcC1saXN0LWZpZWxkLmpzIiwibGliL2NvbnRyb2wvZHJvcC1saXN0L2luZGV4LmpzIiwibGliL2NvbnRyb2wvZHJvcC1saXN0L3dtbC9kcm9wLWxpc3QuanMiLCJsaWIvY29udHJvbC9mZWVkYmFjay5qcyIsImxpYi9jb250cm9sL2ZpbGUtaW5wdXQvaW5kZXguanMiLCJsaWIvY29udHJvbC9maWxlLWlucHV0L3dtbC9maWxlLWlucHV0LmpzIiwibGliL2NvbnRyb2wvZmlsZS11cGxvYWQtc3VyZmFjZS9pbmRleC5qcyIsImxpYi9jb250cm9sL2ZpbGUtdXBsb2FkLXN1cmZhY2Uvd21sL2ZpbGUtdXBsb2FkLXN1cmZhY2UuanMiLCJsaWIvY29udHJvbC9mb2N1cy5qcyIsImxpYi9jb250cm9sL2Zvcm0uanMiLCJsaWIvY29udHJvbC9oZWxwL2luZGV4LmpzIiwibGliL2NvbnRyb2wvaGVscC93bWwvaGVscC5qcyIsImxpYi9jb250cm9sL2luZGV4LmpzIiwibGliL2NvbnRyb2wvaW5wdXQtZ3JvdXAvaW5kZXguanMiLCJsaWIvY29udHJvbC9pbnB1dC1ncm91cC93bWwvaW5wdXQtZ3JvdXAuanMiLCJsaWIvY29udHJvbC9sYWJlbC9pbmRleC5qcyIsImxpYi9jb250cm9sL2xhYmVsL3dtbC9sYWJlbC5qcyIsImxpYi9jb250cm9sL211bHRpLXNlbGVjdC9pbmRleC5qcyIsImxpYi9jb250cm9sL211bHRpLXNlbGVjdC93bWwvbXVsdGktc2VsZWN0LmpzIiwibGliL2NvbnRyb2wvcGFnZXIvaW5kZXguanMiLCJsaWIvY29udHJvbC9wYWdlci92aWV3cy5qcyIsImxpYi9jb250cm9sL3BhZ2luYXRvci9pbmRleC5qcyIsImxpYi9jb250cm9sL3BhZ2luYXRvci93bWwvcGFnaW5hdG9yLmpzIiwibGliL2NvbnRyb2wvcmFuZ2VkLXBhZ2VyL2luZGV4LmpzIiwibGliL2NvbnRyb2wvcmFuZ2VkLXBhZ2VyL3ZpZXdzLmpzIiwibGliL2NvbnRyb2wvcmVzdWx0cy1tZW51L2luZGV4LmpzIiwibGliL2NvbnRyb2wvcmVzdWx0cy1tZW51L3dtbC9yZXN1bHRzLW1lbnUuanMiLCJsaWIvY29udHJvbC9zZWFyY2gvaW5kZXguanMiLCJsaWIvY29udHJvbC9zZWFyY2gvd21sL3NlYXJjaC5qcyIsImxpYi9jb250cm9sL3NlbGVjdC9pbmRleC5qcyIsImxpYi9jb250cm9sL3NlbGVjdC93bWwvc2VsZWN0LmpzIiwibGliL2NvbnRyb2wvc3RhY2stc2VsZWN0L2luZGV4LmpzIiwibGliL2NvbnRyb2wvc3RhY2stc2VsZWN0L3dtbC9zdGFjay1zZWxlY3QuanMiLCJsaWIvY29udHJvbC9zdGFjay9pbmRleC5qcyIsImxpYi9jb250cm9sL3N0YWNrL3dtbC9zdGFjay5qcyIsImxpYi9jb250cm9sL3N3aXRjaC9pbmRleC5qcyIsImxpYi9jb250cm9sL3N3aXRjaC93bWwvc3dpdGNoLmpzIiwibGliL2NvbnRyb2wvdGFiLWJhci9pbmRleC5qcyIsImxpYi9jb250cm9sL3RhYi1iYXIvd21sL3RhYi1iYXIuanMiLCJsaWIvY29udHJvbC90YWcvaW5kZXguanMiLCJsaWIvY29udHJvbC90YWcvd21sL3RhZy5qcyIsImxpYi9jb250cm9sL3RleHQtZmllbGQvaW5kZXguanMiLCJsaWIvY29udHJvbC90ZXh0LWZpZWxkL3dtbC90ZXh0LWZpZWxkLmpzIiwibGliL2NvbnRyb2wvdGV4dC1pbnB1dC9pbmRleC5qcyIsImxpYi9jb250cm9sL3RleHQtaW5wdXQvd21sL3RleHQtaW5wdXQuanMiLCJsaWIvY29udHJvbC90b29sYmFyL2luZGV4LmpzIiwibGliL2NvbnRyb2wvdG9vbGJhci93bWwvdG9vbGJhci5qcyIsImxpYi9jb250cm9sL3R5cGVhaGVhZC9pbmRleC5qcyIsImxpYi9jb250cm9sL3R5cGVhaGVhZC93bWwvdHlwZWFoZWFkLmpzIiwibGliL2RhdGEvcHJvcGVydHktbGlzdC9pbmRleC5qcyIsImxpYi9kYXRhL3Byb3BlcnR5LWxpc3Qvd21sL3Byb3BlcnR5LWxpc3QuanMiLCJsaWIvZGF0YS90YWJsZS9jb2x1bW4vc29ydC5qcyIsImxpYi9kYXRhL3RhYmxlL2V2ZW50LmpzIiwibGliL2RhdGEvdGFibGUvaW5kZXguanMiLCJsaWIvZGF0YS90YWJsZS9yYW5nZS5qcyIsImxpYi9kYXRhL3RhYmxlL3dtbC90YWJsZS5qcyIsImxpYi9kaWFsb2cvYWxlcnQvaW5kZXguanMiLCJsaWIvZGlhbG9nL2FsZXJ0L3dtbC9hbGVydC5qcyIsImxpYi9kaWFsb2cvY29uZmlybS9pbmRleC5qcyIsImxpYi9kaWFsb2cvY29uZmlybS93bWwvY29uZmlybS5qcyIsImxpYi9kaWFsb2cvaW5mb3JtL2luZGV4LmpzIiwibGliL2RpYWxvZy9pbmZvcm0vd21sL2luZm9ybS5qcyIsImxpYi9kaWFsb2cvbW9kYWwvaW5kZXguanMiLCJsaWIvZGlhbG9nL21vZGFsL3dtbC9tb2RhbC5qcyIsImxpYi9kaWFsb2cvcHJvbXB0L2luZGV4LmpzIiwibGliL2RpYWxvZy9wcm9tcHQvd21sL3Byb21wdC5qcyIsImxpYi9pbmRleC5qcyIsImxpYi9sYXlvdXQvYWN0aW9uLWJhci9pbmRleC5qcyIsImxpYi9sYXlvdXQvYWN0aW9uLWJhci93bWwvYWN0aW9uLWJhci5qcyIsImxpYi9sYXlvdXQvY2FsbG91dC9pbmRleC5qcyIsImxpYi9sYXlvdXQvY2FsbG91dC93bWwvY2FsbG91dC5qcyIsImxpYi9sYXlvdXQvZGVzY3JpcHRpb24tbGlzdC9pbmRleC5qcyIsImxpYi9sYXlvdXQvZGVzY3JpcHRpb24tbGlzdC93bWwvZGVzY3JpcHRpb24tbGlzdC5qcyIsImxpYi9sYXlvdXQvZHJhd2VyL2luZGV4LmpzIiwibGliL2xheW91dC9kcmF3ZXIvdmlldy5qcyIsImxpYi9sYXlvdXQvZ3JpZC9pbmRleC5qcyIsImxpYi9sYXlvdXQvZ3JpZC93bWwvZ3JpZC5qcyIsImxpYi9sYXlvdXQvaG9yaXpvbnRhbC9pbmRleC5qcyIsImxpYi9sYXlvdXQvaG9yaXpvbnRhbC93bWwvaG9yaXpvbnRhbC5qcyIsImxpYi9sYXlvdXQvaW5kZXguanMiLCJsaWIvbGF5b3V0L2xpc3QvaW5kZXguanMiLCJsaWIvbGF5b3V0L2xpc3Qvd21sL2xpc3QuanMiLCJsaWIvbGF5b3V0L21haW4vaW5kZXguanMiLCJsaWIvbGF5b3V0L21haW4vd21sL21haW4uanMiLCJsaWIvbGF5b3V0L21ldGVyL2luZGV4LmpzIiwibGliL2xheW91dC9tZXRlci93bWwvbWV0ZXIuanMiLCJsaWIvbGF5b3V0L3BhbmVsL2luZGV4LmpzIiwibGliL2xheW91dC9wYW5lbC93bWwvcGFuZWwuanMiLCJsaWIvbGF5b3V0L3RhYi9pbmRleC5qcyIsImxpYi9sYXlvdXQvdGFiL3dtbC90YWIuanMiLCJsaWIvbGF5b3V0L3RhYmxlL2luZGV4LmpzIiwibGliL2xheW91dC90YWJsZS93bWwvdGFibGUuanMiLCJsaWIvbGF5b3V0L3dlbGwvaW5kZXguanMiLCJsaWIvbGF5b3V0L3dlbGwvd21sL3dlbGwuanMiLCJsaWIvbWVudS9kcmF3ZXIvaW5kZXguanMiLCJsaWIvbWVudS9kcmF3ZXIvd21sL2RyYXdlci5qcyIsImxpYi9tZW51L2hlYWRlci9pbmRleC5qcyIsImxpYi9tZW51L2hlYWRlci93bWwvaGVhZGVyLmpzIiwibGliL21lbnUvaXRlbS9pbmRleC5qcyIsImxpYi9tZW51L2l0ZW0vd21sL2l0ZW0uanMiLCJsaWIvbWVudS9tZW51L2luZGV4LmpzIiwibGliL21lbnUvbWVudS93bWwvaGVhZGVyLmpzIiwibGliL21lbnUvbWVudS93bWwvbWVudS5qcyIsImxpYi9tZW51L25hdi9pbmRleC5qcyIsImxpYi9tZW51L25hdi92aWV3LmpzIiwibGliL3V0aWwuanMiLCJub2RlX21vZHVsZXMvQHF1ZW5rL25vbmkvbGliL2NvbnRyb2wvdGltZXIuanMiLCJub2RlX21vZHVsZXMvQHF1ZW5rL25vbmkvbGliL2RhdGEvYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHF1ZW5rL25vbmkvbGliL2RhdGEvYXJyYXkvc29ydC5qcyIsIm5vZGVfbW9kdWxlcy9AcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZS5qcyIsIm5vZGVfbW9kdWxlcy9AcXVlbmsvbm9uaS9saWIvZGF0YS9yZWNvcmQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHF1ZW5rL25vbmkvbGliL2RhdGEvcmVjb3JkL3BhdGguanMiLCJub2RlX21vZHVsZXMvQHF1ZW5rL25vbmkvbGliL2RhdGEvdHlwZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AcXVlbmsvbm9uaS9saWIvbWF0aC5qcyIsIm5vZGVfbW9kdWxlcy9AcXVlbmsvd21sL2xpYi9kb20uanMiLCJub2RlX21vZHVsZXMvQHF1ZW5rL3dtbC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW9tZW50L21vbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9hcHAuanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9maXh0dXJlcy9kYXRhL3Jlc3VsdHMuanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRlbnRfZW1iZWQvaW5kZXguanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRlbnRfZW1iZWQvd21sL2VtYmVkLmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9jb250ZW50X2xpbmsvaW5kZXguanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRlbnRfbGluay92aWV3cy5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udGVudF9tZWRpYS1kZXNjcmlwdGlvbi9pbmRleC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udGVudF9tZWRpYS1kZXNjcmlwdGlvbi93bWwvbWVkaWEtZGVzY3JpcHRpb24uanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRlbnRfb3ZlcmxheS9pbmRleC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udGVudF9vdmVybGF5L3dtbC9vdmVybGF5LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9jb250ZW50X3RhZy9pbmRleC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udGVudF90YWcvd21sL3RhZy5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udGVudF90aHVtYm5haWwvaW5kZXguanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRlbnRfdGh1bWJuYWlsL3dtbC90aHVtYm5haWwuanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRyb2xfYnV0dG9uLWdyb3VwL2luZGV4LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9jb250cm9sX2J1dHRvbi1ncm91cC93bWwvYnV0dG9uLWdyb3VwLmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9jb250cm9sX2J1dHRvbi1zZWxlY3QvaW5kZXguanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRyb2xfYnV0dG9uLXNlbGVjdC93bWwvYnV0dG9uLXNlbGVjdC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udHJvbF9idXR0b24vaW5kZXguanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRyb2xfYnV0dG9uL3dtbC9idXR0b24uanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRyb2xfY2hlY2tib3gvaW5kZXguanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRyb2xfY2hlY2tib3gvd21sL2NoZWNrYm94LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9jb250cm9sX2RhdGUtZmllbGQvaW5kZXguanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRyb2xfZGF0ZS1maWVsZC93bWwvZGF0ZS1maWVsZC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udHJvbF9kaXNwbGF5LWZpZWxkL2luZGV4LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9jb250cm9sX2Rpc3BsYXktZmllbGQvd21sL2Rpc3BsYXktZmllbGQuanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRyb2xfZHJvcC1kb3duL2luZGV4LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9jb250cm9sX2Ryb3AtZG93bi93bWwvZHJvcC1kb3duLmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9jb250cm9sX2Ryb3AtbGlzdC1maWVsZC9pbmRleC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udHJvbF9kcm9wLWxpc3QtZmllbGQvd21sL2Ryb3AtbGlzdC1maWVsZC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udHJvbF9kcm9wLWxpc3QvaW5kZXguanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRyb2xfZHJvcC1saXN0L3dtbC9kcm9wLWxpc3QuanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRyb2xfZmlsZS11cGxvYWQtc3VyZmFjZS9pbmRleC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udHJvbF9maWxlLXVwbG9hZC1zdXJmYWNlL3dtbC9maWxlLXVwbG9hZC1zdXJmYWNlLmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9jb250cm9sX2lucHV0LWdyb3VwL2luZGV4LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9jb250cm9sX2lucHV0LWdyb3VwL3dtbC9pbnB1dC1ncm91cC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udHJvbF9tdWx0aS1zZWxlY3QvaW5kZXguanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRyb2xfbXVsdGktc2VsZWN0L3dtbC9tdWx0aS1zZWxlY3QuanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRyb2xfcGFnZXIvaW5kZXguanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRyb2xfcGFnZXIvcGFnZXIuanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRyb2xfcGFnaW5hdG9yL2luZGV4LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9jb250cm9sX3BhZ2luYXRvci93bWwvcGFnaW5hdG9yLmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9jb250cm9sX3JhbmdlZC1wYWdlci9pbmRleC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udHJvbF9yYW5nZWQtcGFnZXIvdmlld3MuanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRyb2xfc2VhcmNoL2luZGV4LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9jb250cm9sX3NlYXJjaC93bWwvc2VhcmNoLmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9jb250cm9sX3NlbGVjdC9pbmRleC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udHJvbF9zZWxlY3Qvd21sL3NlbGVjdC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udHJvbF9zdGFjay1zZWxlY3QvaW5kZXguanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRyb2xfc3RhY2stc2VsZWN0L3dtbC9zdGFjay1zZWxlY3QuanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRyb2xfc3RhY2svaW5kZXguanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRyb2xfc3RhY2svd21sL3N0YWNrLmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9jb250cm9sX3N3aXRjaC9pbmRleC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udHJvbF9zd2l0Y2gvd21sL3N3aXRjaC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udHJvbF90YWItYmFyL2luZGV4LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9jb250cm9sX3RhYi1iYXIvd21sL3RhYi1iYXIuanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRyb2xfdGFnLWNvbnRyb2wvaW5kZXguanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRyb2xfdGFnLWNvbnRyb2wvd21sL3RhZy5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udHJvbF90ZXh0LWZpZWxkL2luZGV4LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9jb250cm9sX3RleHQtZmllbGQvd21sL3RleHQtZmllbGQuanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRyb2xfdGV4dC1pbnB1dC9pbmRleC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udHJvbF90ZXh0LWlucHV0L3dtbC90ZXh0LWlucHV0LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9jb250cm9sX3Rvb2xiYXIvaW5kZXguanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRyb2xfdG9vbGJhci93bWwvdG9vbGJhci5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udHJvbF90eXBlYWhlYWQvaW5kZXguanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRyb2xfdHlwZWFoZWFkL3dtbC90eXBlYWhlYWQuanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2RhdGFfZGF0YS10YWJsZS9kYXRhLmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9kYXRhX2RhdGEtdGFibGUvaW5kZXguanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2RhdGFfZGF0YS10YWJsZS93bWwvdGFibGUuanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2RhdGFfcHJvcGVydHktbGlzdC9pbmRleC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvZGF0YV9wcm9wZXJ0eS1saXN0L3dtbC9wcm9wZXJ0eS1saXN0LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9kaWFsb2dfYWxlcnQvaW5kZXguanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2RpYWxvZ19hbGVydC93bWwvYWxlcnQuanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2RpYWxvZ19jb25maXJtL2luZGV4LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9kaWFsb2dfY29uZmlybS93bWwvY29uZmlybS5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvZGlhbG9nX2luZm9ybS9pbmRleC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvZGlhbG9nX2luZm9ybS93bWwvaW5mb3JtLmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9kaWFsb2dfbW9kYWwvaW5kZXguanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2RpYWxvZ19tb2RhbC93bWwvbW9kYWwuanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2RpYWxvZ19wcm9tcHQvaW5kZXguanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2RpYWxvZ19wcm9tcHQvd21sL3Byb21wdC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvbGF5b3V0X2NhbGxvdXQvaW5kZXguanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2xheW91dF9jYWxsb3V0L3dtbC9jYWxsb3V0LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9sYXlvdXRfZGVzY3JpcHRpb24tbGlzdC9pbmRleC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvbGF5b3V0X2Rlc2NyaXB0aW9uLWxpc3Qvd21sL2Rlc2NyaXB0aW9uLWxpc3QuanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2xheW91dF9ncmlkL2luZGV4LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9sYXlvdXRfZ3JpZC93bWwvZ3JpZC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvbGF5b3V0X2hvcml6b250YWwvaW5kZXguanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2xheW91dF9ob3Jpem9udGFsL3dtbC9ob3Jpem9udGFsLmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9sYXlvdXRfbGlzdC9pbmRleC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvbGF5b3V0X2xpc3Qvd21sL2xpc3QuanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2xheW91dF9tZXRlci9pbmRleC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvbGF5b3V0X21ldGVyL3dtbC9tZXRlci5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvbGF5b3V0X3BhbmVsL2luZGV4LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9sYXlvdXRfcGFuZWwvd21sL3BhbmVsLmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9sYXlvdXRfdGFiL2luZGV4LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9sYXlvdXRfdGFiL3dtbC90YWIuanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2xheW91dF90YWJsZS9pbmRleC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvbGF5b3V0X3RhYmxlL3dtbC90YWJsZS5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvbGF5b3V0X3dlbGwvaW5kZXguanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2xheW91dF93ZWxsL3dtbC93ZWxsLmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9tZW51X21lbnUvaW5kZXguanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL21lbnVfbWVudS93bWwvbWVudS5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvbWVudV9uYXYvaW5kZXguanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL21lbnVfbmF2L3dtbC9uYXYuanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlcy5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3dpZGdldHMvZGVtby9pbmRleC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3dpZGdldHMvZGVtby93bWwvZGVtby5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3dtbC9hcHAuanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC93bWwvbmF2aWdhdGlvbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeldBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0ckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25XQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25XQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwNEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyakxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNybUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2FyZXQgPSBleHBvcnRzLkNBUkVUID0gdm9pZCAwO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvY2FyZXRcIik7XG5jb25zdCB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLkNBUkVUID0gJ3d3LWNhcmV0Jztcbi8qKlxuICogQ2FyZXRcbiAqL1xuY2xhc3MgQ2FyZXQgZXh0ZW5kcyB3bWxfMS5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbih0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgaWQ6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuaWQpID8gdGhpcy5hdHRycy5pZCA6ICcnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogKDAsIHV0aWxfMS5jb25jYXQpKGV4cG9ydHMuQ0FSRVQsICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuY2xhc3NOYW1lKSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMuY2xhc3NOYW1lIDogJycpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5DYXJldCA9IENhcmV0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1haW4gPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnc3BhbicsIHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5yb290LmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NOYW1lIH0sIFtdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYXJldC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2xvc2UgPSBleHBvcnRzLkNMT1NFID0gdm9pZCAwO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvY2xvc2VcIik7XG5jb25zdCB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLkNMT1NFID0gJ3d3LWNsb3NlJztcbi8qKlxuICogQ2xvc2VcbiAqL1xuY2xhc3MgQ2xvc2UgZXh0ZW5kcyB3bWxfMS5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbih0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBpZDogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5pZCkgP1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMuaWQgOiAnJyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogKDAsIHV0aWxfMS5jb25jYXQpKGV4cG9ydHMuQ0xPU0UsICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuY2xhc3NOYW1lKSA/XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRycy5jbGFzc05hbWUgOiAnJyksXG4gICAgICAgICAgICBvbkNsaWNrOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLm9uQ2xpY2spID9cbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLm9uQ2xpY2sgOiAoKSA9PiB7IH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkNsb3NlID0gQ2xvc2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWFpbiA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9faWYgPSAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpID0+IChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0ID8gX19hbHQoKSA6IFtdO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9ySW4gPSAobGlzdCwgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2Zvck9mID0gKG8sIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHRleHQgPSBfX2RvY3VtZW50LnRleHQ7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHVuc2FmZSA9IF9fZG9jdW1lbnQudW5zYWZlO1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCBpc1NldCA9ICh2YWx1ZSkgPT4gdmFsdWUgIT0gbnVsbDtcbmNsYXNzIE1haW4ge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdzcGFuJywgeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmNsYXNzTmFtZSwgJ29uY2xpY2snOiBfX2NvbnRleHQudmFsdWVzLm9uQ2xpY2sgfSwgW1xuICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ8OXJylcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsb3NlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FbWJlZCA9IGV4cG9ydHMuRU1CRUQgPSB2b2lkIDA7XG5jb25zdCB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG5jb25zdCBfXzEgPSByZXF1aXJlKFwiLi4vLi4vXCIpO1xuY29uc3QgZW1iZWRfMSA9IHJlcXVpcmUoXCIuL3dtbC9lbWJlZFwiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuRU1CRUQgPSAnd3ctZW1iZWQnO1xuLyoqXG4gKiBFbWJlZFxuICovXG5jbGFzcyBFbWJlZCBleHRlbmRzIHdtbF8xLkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyBlbWJlZF8xLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdlbWJlZCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZDogKDAsIF9fMS5nZXRJZCkodGhpcy5hdHRycyksXG4gICAgICAgICAgICBjbGFzc05hbWU6ICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLkVNQkVELCAoMCwgX18xLmdldENsYXNzTmFtZSkodGhpcy5hdHRycykpLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuRW1iZWQgPSBFbWJlZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYWluID0gdm9pZCAwO1xuY29uc3QgX19kb2N1bWVudCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbmNvbnN0IG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ2RpdicsIHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jbGFzc05hbWUgfSwgW1xuICAgICAgICAgICAgICAgIC4uLihfX2NvbnRleHQuY2hpbGRyZW4pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbWJlZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGluayA9IGV4cG9ydHMuTGlua0NsaWNrZWRFdmVudCA9IGV4cG9ydHMuTElOSyA9IHZvaWQgMDtcbmNvbnN0IHdtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xuY29uc3QgZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi92aWV3c1wiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xuY29uc3QgYWN0aXZlXzEgPSByZXF1aXJlKFwiLi4vc3RhdGUvYWN0aXZlXCIpO1xuY29uc3QgZGlzYWJsZWRfMSA9IHJlcXVpcmUoXCIuLi9zdGF0ZS9kaXNhYmxlZFwiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbi8qKlxuICogTElOS1xuICovXG5leHBvcnRzLkxJTksgPSAnd3ctbGluayc7XG4vKipcbiAqIExpbmtDbGlja2VkRXZlbnQgaW5kaWNhdGVzIGFuIExpbmsgaGFzIGJlZW4gY2xpY2tlZC5cbiAqL1xuY2xhc3MgTGlua0NsaWNrZWRFdmVudCB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgaHJlZikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmhyZWYgPSBocmVmO1xuICAgIH1cbn1cbmV4cG9ydHMuTGlua0NsaWNrZWRFdmVudCA9IExpbmtDbGlja2VkRXZlbnQ7XG4vKipcbiAqIExpbmsgZ2VuZXJhdGVzIGFuIDxhPiBlbGVtZW50LlxuICovXG5jbGFzcyBMaW5rIGV4dGVuZHMgd21sLkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmlldyA9ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuZGlzYWJsZWQpID9cbiAgICAgICAgICAgIG5ldyB2aWV3cy5EaXNhYmxlZExpbmtWaWV3KHRoaXMpIDpcbiAgICAgICAgICAgIG5ldyB2aWV3cy5MaW5rVmlldyh0aGlzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG5hbWUgYXNzaWduZWQgdG8gdGhpcyBMaW5rLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5uYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmF0dHJzLm5hbWUgOiAnJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRpdGxlIGFzc2lnbmVkIHRvIHRoaXMgTGluay5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGl0bGUgPSAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLnRpdGxlKSA/XG4gICAgICAgICAgICB0aGlzLmF0dHJzLnRpdGxlIDogJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBocmVmIGFzc2lnbmVkIHRvIHRoaXMgTGlua1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ocmVmID0gKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5ocmVmKSA/XG4gICAgICAgICAgICB0aGlzLmF0dHJzLmhyZWYgOiAnJztcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBpZDogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5pZCkgP1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMuaWQgOiAnJyxcbiAgICAgICAgICAgIGRpc2FibGVkOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmRpc2FibGVkKSA/XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRycy5kaXNhYmxlZCA6IG51bGwsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLkxJTkssICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuY2xhc3NOYW1lKSA/XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRycy5jbGFzc05hbWUgOiAnJywgKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5hY3RpdmUpID9cbiAgICAgICAgICAgICAgICBhY3RpdmVfMS5BQ1RJVkUgOiAnJywgKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5kaXNhYmxlZCkgP1xuICAgICAgICAgICAgICAgIGRpc2FibGVkXzEuRElTQUJMRUQgOiAnJywgKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5kaXNhYmxlZCkgP1xuICAgICAgICAgICAgICAgIGAtd3ctZGlzYWJsZWRgIDogJycpLFxuICAgICAgICAgICAgdGl0bGU6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMudGl0bGUpID9cbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLnRpdGxlIDogbnVsbCxcbiAgICAgICAgICAgIG5hbWU6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMubmFtZSkgP1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMubmFtZSA6IG51bGwsXG4gICAgICAgICAgICBocmVmOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmhyZWYpID9cbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLmhyZWYgOiAnIycsXG4gICAgICAgICAgICBhY3RpdmU6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuYWN0aXZlKSA/XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRycy5hY3RpdmUgOiBmYWxzZSxcbiAgICAgICAgICAgIC8vVE9ETzogbW92ZSB0byBkb20gbGliXG4gICAgICAgICAgICBjb250ZW50OiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLnRleHQpID9cbiAgICAgICAgICAgICAgICBbZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5hdHRycy50ZXh0KV0gOlxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4sXG4gICAgICAgICAgICBjbGlja2VkOiAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJzICYmICF0aGlzLmF0dHJzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB7IG5hbWUsIGhyZWYsIG9uQ2xpY2sgfSA9IHRoaXMuYXR0cnM7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaHJlZilcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uQ2xpY2spXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrKG5ldyBMaW5rQ2xpY2tlZEV2ZW50KG5hbWUsIGhyZWYpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAgKiBhY3RpdmF0ZSB0aGlzIG5hdiBsaXN0IEl0ZW0uXG4gICAgICAqL1xuICAgIGFjdGl2YXRlKCkge1xuICAgICAgICBsZXQgbSA9ICgwLCB1dGlsXzEuZ2V0QnlJZCkodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5pZCk7XG4gICAgICAgIGlmIChtLmlzSnVzdCgpKSB7XG4gICAgICAgICAgICBsZXQgZSA9IG0uZ2V0KCk7XG4gICAgICAgICAgICBlLmNsYXNzTGlzdC5yZW1vdmUoYWN0aXZlXzEuQUNUSVZFKTtcbiAgICAgICAgICAgIGUuY2xhc3NMaXN0LmFkZChhY3RpdmVfMS5BQ1RJVkUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBkZWFjdGl2YXRlIHRoaXMgbmF2IGxpc3QgaXRlbS5cbiAgICAgKi9cbiAgICBkZWFjdGl2YXRlKCkge1xuICAgICAgICBsZXQgbSA9ICgwLCB1dGlsXzEuZ2V0QnlJZCkodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5pZCk7XG4gICAgICAgIGlmIChtLmlzSnVzdCgpKVxuICAgICAgICAgICAgbS5nZXQoKS5jbGFzc0xpc3QucmVtb3ZlKGFjdGl2ZV8xLkFDVElWRSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmV4cG9ydHMuTGluayA9IExpbms7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGlua1ZpZXcgPSBleHBvcnRzLkRpc2FibGVkTGlua1ZpZXcgPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBEaXNhYmxlZExpbmtWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnc3BhbicsIHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jbGFzc05hbWUsICdocmVmJzogX19jb250ZXh0LnZhbHVlcy5ocmVmLCAndGl0bGUnOiBfX2NvbnRleHQudmFsdWVzLnRpdGxlLCAnb25jbGljayc6IF9fY29udGV4dC52YWx1ZXMuY2xpY2tlZCB9LCBbXG4gICAgICAgICAgICAgICAgLi4uKF9fY29udGV4dC52YWx1ZXMuY29udGVudClcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5EaXNhYmxlZExpbmtWaWV3ID0gRGlzYWJsZWRMaW5rVmlldztcbjtcbmNsYXNzIExpbmtWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnYScsIHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jbGFzc05hbWUsICdocmVmJzogX19jb250ZXh0LnZhbHVlcy5ocmVmLCAndGl0bGUnOiBfX2NvbnRleHQudmFsdWVzLnRpdGxlLCAnb25jbGljayc6IF9fY29udGV4dC52YWx1ZXMuY2xpY2tlZCB9LCBbXG4gICAgICAgICAgICAgICAgLi4uKF9fY29udGV4dC52YWx1ZXMuY29udGVudClcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5MaW5rVmlldyA9IExpbmtWaWV3O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlld3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRlc2NyaXB0aW9uID0gZXhwb3J0cy5NZWRpYSA9IGV4cG9ydHMuTWVkaWFEZXNjcmlwdGlvbiA9IGV4cG9ydHMuTUVESUFfREVTQ1JJUFRJT05fREVTQ1JJUFRJT04gPSBleHBvcnRzLk1FRElBX0RFU0NSSVBUSU9OX01FRElBID0gZXhwb3J0cy5NRURJQV9ERVNDUklQVElPTiA9IHZvaWQgMDtcbmNvbnN0IHZpZXdzID0gcmVxdWlyZShcIi4vd21sL21lZGlhLWRlc2NyaXB0aW9uXCIpO1xuY29uc3Qgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xuY29uc3QgX18xID0gcmVxdWlyZShcIi4uLy4uL1wiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuTUVESUFfREVTQ1JJUFRJT04gPSAnd3ctbWVkaWEtZGVzY3JpcHRpb24nO1xuZXhwb3J0cy5NRURJQV9ERVNDUklQVElPTl9NRURJQSA9ICd3dy1tZWRpYS1kZXNjcmlwdGlvbl9fbWVkaWEnO1xuZXhwb3J0cy5NRURJQV9ERVNDUklQVElPTl9ERVNDUklQVElPTiA9ICd3dy1tZWRpYS1kZXNjcmlwdGlvbl9fZGVzY3JpcHRpb24nO1xuLyoqXG4gKiBNZWRpYURlc2NyaXB0aW9uXG4gKi9cbmNsYXNzIE1lZGlhRGVzY3JpcHRpb24gZXh0ZW5kcyB3bWxfMS5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuTWVkaWFEZXNjcmlwdGlvbih0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBpZDogKDAsIF9fMS5nZXRJZCkodGhpcy5hdHRycyksXG4gICAgICAgICAgICBjbGFzc05hbWU6ICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLk1FRElBX0RFU0NSSVBUSU9OLCAoMCwgX18xLmdldENsYXNzTmFtZSkodGhpcy5hdHRycykpXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5NZWRpYURlc2NyaXB0aW9uID0gTWVkaWFEZXNjcmlwdGlvbjtcbi8qKlxuICogTWVkaWFcbiAqL1xuY2xhc3MgTWVkaWEgZXh0ZW5kcyB3bWxfMS5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuTWVkaWEodGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6ICgwLCBfXzEuZ2V0SWQpKHRoaXMuYXR0cnMpLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAoMCwgdXRpbF8xLmNvbmNhdCkoZXhwb3J0cy5NRURJQV9ERVNDUklQVElPTl9NRURJQSwgKDAsIF9fMS5nZXRDbGFzc05hbWUpKHRoaXMuYXR0cnMpKVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuTWVkaWEgPSBNZWRpYTtcbi8qKlxuICogRGVzY3JpcHRpb25cbiAqL1xuY2xhc3MgRGVzY3JpcHRpb24gZXh0ZW5kcyB3bWxfMS5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuRGVzY3JpcHRpb24odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6ICgwLCBfXzEuZ2V0SWQpKHRoaXMuYXR0cnMpLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAoMCwgdXRpbF8xLmNvbmNhdCkoZXhwb3J0cy5NRURJQV9ERVNDUklQVElPTl9ERVNDUklQVElPTiwgKDAsIF9fMS5nZXRDbGFzc05hbWUpKHRoaXMuYXR0cnMpKVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuRGVzY3JpcHRpb24gPSBEZXNjcmlwdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EZXNjcmlwdGlvbiA9IGV4cG9ydHMuTWVkaWEgPSBleHBvcnRzLk1lZGlhRGVzY3JpcHRpb24gPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBNZWRpYURlc2NyaXB0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnZGl2JywgeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmNsYXNzTmFtZSB9LCBbXG4gICAgICAgICAgICAgICAgLi4uKF9fY29udGV4dC5jaGlsZHJlbilcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5NZWRpYURlc2NyaXB0aW9uID0gTWVkaWFEZXNjcmlwdGlvbjtcbjtcbmNsYXNzIE1lZGlhIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnZGl2JywgeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmNsYXNzTmFtZSB9LCBbXG4gICAgICAgICAgICAgICAgLi4uKF9fY29udGV4dC5jaGlsZHJlbilcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5NZWRpYSA9IE1lZGlhO1xuO1xuY2xhc3MgRGVzY3JpcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdkaXYnLCB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuY2xhc3NOYW1lIH0sIFtcbiAgICAgICAgICAgICAgICAuLi4oX19jb250ZXh0LmNoaWxkcmVuKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLkRlc2NyaXB0aW9uID0gRGVzY3JpcHRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZWRpYS1kZXNjcmlwdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWVudUljb24gPSBleHBvcnRzLk1FTlVfSUNPTl9EQVNIID0gZXhwb3J0cy5NRU5VX0lDT04gPSB2b2lkIDA7XG5jb25zdCB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9tZW51LWljb25cIik7XG5jb25zdCB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLk1FTlVfSUNPTiA9ICd3dy1tZW51LWljb24nO1xuZXhwb3J0cy5NRU5VX0lDT05fREFTSCA9ICd3dy1tZW51LWljb25fX2Rhc2gnO1xuLyoqXG4gKiBNZW51SWNvbiBwcm92aWRlcyBhIGNzcyBpbXBsZW1lbnQgaWNvbiBub3JtYWxseSB1c2VkXG4gKiB0byB0b2dnbGUgYSBzaWRlIG1lbnUuXG4gKi9cbmNsYXNzIE1lbnVJY29uIGV4dGVuZHMgd21sXzEuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgICAgIGlkOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmlkKSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMuaWQgOiAnJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLk1FTlVfSUNPTiwgKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5pZCkgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLmlkIDogJycpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGFzaDoge1xuICAgICAgICAgICAgICAgIGlkOiAnZGFzaCcsXG4gICAgICAgICAgICAgICAgY2xhc3M6IGV4cG9ydHMuTUVOVV9JQ09OX0RBU0hcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLk1lbnVJY29uID0gTWVudUljb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWFpbiA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9faWYgPSAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpID0+IChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0ID8gX19hbHQoKSA6IFtdO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9ySW4gPSAobGlzdCwgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2Zvck9mID0gKG8sIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHRleHQgPSBfX2RvY3VtZW50LnRleHQ7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHVuc2FmZSA9IF9fZG9jdW1lbnQudW5zYWZlO1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCBpc1NldCA9ICh2YWx1ZSkgPT4gdmFsdWUgIT0gbnVsbDtcbmNsYXNzIE1haW4ge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdzcGFuJywgeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMucm9vdC5jbGFzc05hbWUgfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdzcGFuJywgeyAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmRhc2guY2xhc3MgfSwgW10pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdzcGFuJywgeyAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmRhc2guY2xhc3MgfSwgW10pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdzcGFuJywgeyAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmRhc2guY2xhc3MgfSwgW10pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZW51LWljb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEJsb2NrQ2xhc3NOYW1lID0gZXhwb3J0cy5CT1RUT00gPSBleHBvcnRzLk1JRERMRSA9IGV4cG9ydHMuSE9SSVpPTlRBTCA9IGV4cG9ydHMuUklHSFQgPSBleHBvcnRzLkxFRlQgPSBleHBvcnRzLkpVU1RJRklFRCA9IGV4cG9ydHMuQ0xFQVJGSVggPSBleHBvcnRzLkJMT0NLID0gZXhwb3J0cy5QT1NJVElPTkVEID0gZXhwb3J0cy5QVVNIQUJMRSA9IGV4cG9ydHMuVkVSVElDQUwgPSB2b2lkIDA7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG4vKipcbiAqIFZFUlRJQ0FMIGluZGljYXRlcyBhbiBlbGVtZW50IGlzIHZlcnRpY2FsIHJlbmRlcmVyZC5cbiAqL1xuZXhwb3J0cy5WRVJUSUNBTCA9ICctdmVydGljYWwnO1xuLyoqXG4gKiBQVVNIQUJMRSBpbmRpY2F0ZXMgYW4gZWxlbWVudCBzdXBwb3J0cyBiZWluZyBwdXNoZWRcbiAqIGFuZCBjYW4gaGF2ZSBzdHlsZXMgYWRkZWQgdG8gaXQgYXJvdW5kIHRoZSBjb25jZXB0LlxuICovXG5leHBvcnRzLlBVU0hBQkxFID0gJy1wdXNoYWJsZSc7XG4vKipcbiAqIFBPU0lUSU9ORUQgaW5kaWNhdGVzIGFuIGVsZW1lbnQgaXMgcG9zaXRpb25lZCBhbmQgcmVzcG9uZHNcbiAqIHRvIHRoZSBsZWZ0LHJpZ2h0IGV0Yy4gcHJvcGVydGllcy5cbiAqL1xuZXhwb3J0cy5QT1NJVElPTkVEID0gJy1wb3NpdGlvbmVkJztcbi8qKlxuICogQkxPQ0sgaW5kaWNhdGVzIGFuIGVsZW1lbnQgc2hvdWxkIGJlIGJsb2NrIGRpc3BsYXllZC5cbiAqL1xuZXhwb3J0cy5CTE9DSyA9ICctYmxvY2snO1xuLyoqXG4gKiBDTEVBUkZJWCBoYWNrLlxuICovXG5leHBvcnRzLkNMRUFSRklYID0gJy1jbGVhcmZpeCc7XG4vKipcbiAqIEpVU1RJRklFRCBjb250ZW50LlxuICovXG5leHBvcnRzLkpVU1RJRklFRCA9ICctanVzdGlmaWVkJztcbi8qKlxuICogTEVGVCBpbmRpY2F0ZXMgY29udGVudCBmbG9hdGVkIG9yIHBvc2l0aW9uZWQgdG8gdGhlIGxlZnQuXG4gKi9cbmV4cG9ydHMuTEVGVCA9ICctbGVmdCc7XG4vKipcbiAqIFJJR0hUIGluZGljYXRlcyBjb250ZW50IGZsb2F0ZWQgb3IgcG9zaXRpb25lZCB0byB0aGUgcmlnaHQuXG4gKi9cbmV4cG9ydHMuUklHSFQgPSAnLXJpZ2h0Jztcbi8qKlxuICogSE9SSVpPTlRBTCBpbmRpY2F0ZXMgYSBob3Jpem9udGFsIGFsaWdubWVudC5cbiAqL1xuZXhwb3J0cy5IT1JJWk9OVEFMID0gJy1ob3Jpem9udGFsJztcbmV4cG9ydHMuTUlERExFID0gJy1taWRkbGUnO1xuZXhwb3J0cy5CT1RUT00gPSAnLWJvdHRvbSc7XG4vLy9jbGFzc05hbWVzOmVuZFxuLyoqXG4gKiBnZXRCbG9ja0NsYXNzTmFtZSBwcm92aWRlcyB0aGUgX19CTE9DS19fIGNsYXNzIG5hbWUgaWYgdGhlIGF0dHJpYnV0ZVxuICogdmFsdWUgaXMgc2V0IHRvIHRydWUuXG4gKi9cbmNvbnN0IGdldEJsb2NrQ2xhc3NOYW1lID0gKGF0dHJzKSA9PiBhdHRycy5ibG9jayA9PT0gdHJ1ZSA/IGV4cG9ydHMuQkxPQ0sgOiAnJztcbmV4cG9ydHMuZ2V0QmxvY2tDbGFzc05hbWUgPSBnZXRCbG9ja0NsYXNzTmFtZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9yaWVudGF0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5PdmVybGF5ID0gZXhwb3J0cy5PVkVSTEFZID0gdm9pZCAwO1xuY29uc3Qgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xuY29uc3QgX18xID0gcmVxdWlyZShcIi4uLy4uL1wiKTtcbmNvbnN0IG92ZXJsYXlfMSA9IHJlcXVpcmUoXCIuL3dtbC9vdmVybGF5XCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5PVkVSTEFZID0gJ3d3LW92ZXJsYXknO1xuLyoqXG4gKiBPdmVybGF5XG4gKi9cbmNsYXNzIE92ZXJsYXkgZXh0ZW5kcyB3bWxfMS5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgb3ZlcmxheV8xLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdyb290J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlkOiAoMCwgX18xLmdldElkKSh0aGlzLmF0dHJzKSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogKDAsIHV0aWxfMS5jb25jYXQpKGV4cG9ydHMuT1ZFUkxBWSwgKDAsIF9fMS5nZXRDbGFzc05hbWUpKHRoaXMuYXR0cnMpKSxcbiAgICAgICAgICAgIG9uY2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLm9uQ2xpY2spXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMub25DbGljaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjbG9zZSB0aGUgb3ZlcmxheS5cbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgbGV0IG1PID0gKDAsIHV0aWxfMS5nZXRCeUlkKSh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLndtbC5pZCk7XG4gICAgICAgIGlmIChtTy5pc0p1c3QoKSkge1xuICAgICAgICAgICAgbGV0IG4gPSBtTy5nZXQoKTtcbiAgICAgICAgICAgIGlmIChuLnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgbi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG4pO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5PdmVybGF5ID0gT3ZlcmxheTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYWluID0gdm9pZCAwO1xuY29uc3QgX19kb2N1bWVudCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbmNvbnN0IG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ2RpdicsIHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMud21sLmlkIH0sICdpZCc6IF9fY29udGV4dC52YWx1ZXMuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuY2xhc3NOYW1lLCAnb25jbGljayc6IF9fY29udGV4dC52YWx1ZXMub25jbGljayB9LCBbXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3ZlcmxheS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0U2l6ZUNsYXNzTmFtZSA9IGV4cG9ydHMuU2l6ZSA9IGV4cG9ydHMuRVhUUkFfTEFSR0UgPSBleHBvcnRzLkxBUkdFID0gZXhwb3J0cy5NRURJVU0gPSBleHBvcnRzLlNNQUxMID0gZXhwb3J0cy5FWFRSQV9TTUFMTCA9IHZvaWQgMDtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuRVhUUkFfU01BTEwgPSAnLWV4dHJhLXNtYWxsJztcbmV4cG9ydHMuU01BTEwgPSAnLXNtYWxsJztcbmV4cG9ydHMuTUVESVVNID0gJy1tZWRpdW0nO1xuZXhwb3J0cy5MQVJHRSA9ICctbGFyZ2UnO1xuZXhwb3J0cy5FWFRSQV9MQVJHRSA9ICctZXh0cmEtbGFyZ2UnO1xuLy8vY2xhc3NOYW1lczplbmRcbi8qKlxuICogU2l6ZVxuICovXG52YXIgU2l6ZTtcbihmdW5jdGlvbiAoU2l6ZSkge1xuICAgIFNpemVbXCJFeHRyYVNtYWxsXCJdID0gXCJleHRyYS1zbWFsbFwiO1xuICAgIFNpemVbXCJTbWFsbFwiXSA9IFwic21hbGxcIjtcbiAgICBTaXplW1wiTWVkaXVtXCJdID0gXCJtZWRpdW1cIjtcbiAgICBTaXplW1wiTGFyZ2VcIl0gPSBcImxhcmdlXCI7XG4gICAgU2l6ZVtcIkV4dHJhTGFyZ2VcIl0gPSBcImV4dHJhLWxhcmdlXCI7XG59KShTaXplID0gZXhwb3J0cy5TaXplIHx8IChleHBvcnRzLlNpemUgPSB7fSkpO1xuLyoqXG4gKiBnZXRTaXplQ2xhc3NOYW1lXG4gKi9cbmNvbnN0IGdldFNpemVDbGFzc05hbWUgPSAocykgPT4ge1xuICAgIGlmIChzID09PSBTaXplLkV4dHJhU21hbGwpXG4gICAgICAgIHJldHVybiBleHBvcnRzLkVYVFJBX1NNQUxMO1xuICAgIGVsc2UgaWYgKHMgPT09IFNpemUuU21hbGwpXG4gICAgICAgIHJldHVybiBleHBvcnRzLlNNQUxMO1xuICAgIGVsc2UgaWYgKHMgPT09IFNpemUuTWVkaXVtKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5NRURJVU07XG4gICAgZWxzZSBpZiAocyA9PT0gU2l6ZS5MYXJnZSlcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuTEFSR0U7XG4gICAgZWxzZSBpZiAocyA9PT0gU2l6ZS5FeHRyYUxhcmdlKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5FWFRSQV9MQVJHRTtcbiAgICByZXR1cm4gJyc7XG59O1xuZXhwb3J0cy5nZXRTaXplQ2xhc3NOYW1lID0gZ2V0U2l6ZUNsYXNzTmFtZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpemUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzQWN0aXZlID0gZXhwb3J0cy5kZWFjdGl2YXRlID0gZXhwb3J0cy5hY3RpdmF0ZSA9IGV4cG9ydHMuQUNUSVZFID0gdm9pZCAwO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG4vKipcbiAqIEFDVElWRVxuICovXG5leHBvcnRzLkFDVElWRSA9ICctYWN0aXZlJztcbi8qKlxuICogYWN0aXZhdGUgaGVscGVyLlxuICpcbiAqIEFkZHMgdGhlIEFDVElWRSBjbGFzcy5cbiAqL1xuY29uc3QgYWN0aXZhdGUgPSAodmlldywgaWQpID0+ICgwLCB1dGlsXzEuZ2V0QnlJZCkodmlldywgaWQpXG4gICAgLm1hcCgoZSkgPT4ge1xuICAgIGUuY2xhc3NMaXN0LnJlbW92ZShleHBvcnRzLkFDVElWRSk7XG4gICAgZS5jbGFzc0xpc3QuYWRkKGV4cG9ydHMuQUNUSVZFKTtcbn0pO1xuZXhwb3J0cy5hY3RpdmF0ZSA9IGFjdGl2YXRlO1xuLyoqXG4gKiBkZWFjdGl2YXRlIGhlbHBlci5cbiAqXG4gKiBSZW1vdmVzIHRoZSBBQ1RJVkUgY2xhc3MuXG4gKi9cbmNvbnN0IGRlYWN0aXZhdGUgPSAodmlldywgaWQpID0+ICgwLCB1dGlsXzEuZ2V0QnlJZCkodmlldywgaWQpXG4gICAgLm1hcCgoZSkgPT4gZS5jbGFzc0xpc3QucmVtb3ZlKGV4cG9ydHMuQUNUSVZFKSk7XG5leHBvcnRzLmRlYWN0aXZhdGUgPSBkZWFjdGl2YXRlO1xuLyoqXG4gKiBpc0FjdGl2ZSBoZWxwZGVyXG4gKlxuICogUXVlcmllcyB3aGV0aGVyIHRoZSBBQ1RJVkUgY2xhc3MgaXMgcHJlc2VudC5cbiAqL1xuY29uc3QgaXNBY3RpdmUgPSAodmlldywgaWQpID0+ICgwLCB1dGlsXzEuZ2V0QnlJZCkodmlldywgaWQpXG4gICAgLm1hcCgoZSkgPT4gZS5jbGFzc0xpc3QuY29udGFpbnMoZXhwb3J0cy5BQ1RJVkUpKVxuICAgIC5vckp1c3QoKCkgPT4gZmFsc2UpXG4gICAgLmdldCgpO1xuZXhwb3J0cy5pc0FjdGl2ZSA9IGlzQWN0aXZlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWN0aXZlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ESVNBQkxFRCA9IHZvaWQgMDtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbi8qKlxuICogRElTQUJMRURcbiAqL1xuZXhwb3J0cy5ESVNBQkxFRCA9ICctZGlzYWJsZWQnO1xuLy8vY2xhc3NOYW1lczplbmRcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpc2FibGVkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50b2dnbGUgPSBleHBvcnRzLnNob3cgPSBleHBvcnRzLmhpZGUgPSBleHBvcnRzLmlzSGlkZGVuID0gZXhwb3J0cy5ISURERU4gPSB2b2lkIDA7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbi8qKlxuICogSElEREVOIG1lYW5zIGFuIGVsZW1lbnQgc2hvdWxkIG5vdCBiZSB2aXNpYmxlIGJ1dCBub3QgcmVtb3ZlZFxuICogZnJvbSB0aGUgRE9NLlxuICovXG5leHBvcnRzLkhJRERFTiA9ICctd3ctaGlkZGVuJztcbi8qKlxuICogaXNIaWRkZW4gaGVscGVyLlxuICpcbiAqIFJldHJpZXZlcyBhbiBIVE1MRWxlbWVudCBieSBpZCBhbmQgY2hlY2tzIHdoZXRoZXJcbiAqIGl0IGhhcyB0aGUgaGlkZGVuIGNsYXNzIGF0dGFjaGVkLlxuICovXG5jb25zdCBpc0hpZGRlbiA9ICh2aWV3LCBpZCkgPT4ge1xuICAgIGxldCBtID0gdmlldy5maW5kQnlJZChpZCk7XG4gICAgaWYgKG0uaXNOb3RoaW5nKCkpIHtcbiAgICAgICAgKDAsIHV0aWxfMS53YXJuTWlzc2luZykodmlldywgaWQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBtLmdldCgpLmNsYXNzTGlzdC5jb250YWlucyhleHBvcnRzLkhJRERFTik7XG4gICAgfVxufTtcbmV4cG9ydHMuaXNIaWRkZW4gPSBpc0hpZGRlbjtcbi8qKlxuICogaGlkZSBoZWxwZXIuXG4gKlxuICogQXR0ZW1wdHMgdG8gYWRkIEhJRERFTiB0byB0aGUgdGFyZ2V0IGVsZW1lbnRzIGNsYXNzIG5hbWUuXG4gKi9cbmNvbnN0IGhpZGUgPSAodmlldywgaWQpID0+IHtcbiAgICBsZXQgbSA9IHZpZXcuZmluZEJ5SWQoaWQpO1xuICAgIGlmIChtLmlzTm90aGluZygpKSB7XG4gICAgICAgIHJldHVybiAoMCwgdXRpbF8xLndhcm5NaXNzaW5nKSh2aWV3LCBpZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgZSA9IG0uZ2V0KCk7XG4gICAgICAgIGUuY2xhc3NMaXN0LnJlbW92ZShleHBvcnRzLkhJRERFTik7XG4gICAgICAgIGUuY2xhc3NMaXN0LmFkZChleHBvcnRzLkhJRERFTik7XG4gICAgfVxufTtcbmV4cG9ydHMuaGlkZSA9IGhpZGU7XG4vKipcbiAqIHNob3cgaGVscGVyLlxuICpcbiAqIEF0dGVtcHRzIHRvIHJlbW92ZSB0aGUgSElEREVOIGNsYXNzIG5hbWUgZnJvbSB0aGUgdGFyZ2V0IGVsZW1lbnQuXG4gKi9cbmNvbnN0IHNob3cgPSAodmlldywgaWQpID0+IHtcbiAgICBsZXQgbSA9IHZpZXcuZmluZEJ5SWQoaWQpO1xuICAgIGlmIChtLmlzTm90aGluZygpKSB7XG4gICAgICAgIHJldHVybiAoMCwgdXRpbF8xLndhcm5NaXNzaW5nKSh2aWV3LCBpZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtLmdldCgpLmNsYXNzTGlzdC5yZW1vdmUoZXhwb3J0cy5ISURERU4pO1xuICAgIH1cbn07XG5leHBvcnRzLnNob3cgPSBzaG93O1xuLyoqXG4gKiB0b2dnbGUgaGVscGVyLlxuICpcbiAqIEF0dGVtcHRzIHRvIHRvZ2dsZSB0aGUgSElEREVOIGNsYXNzIG5hbWUgZnJvbSB0aGUgdGFyZ2V0IGVsZW1lbnRcbiAqIGNsYXNzTGlzdC5cbiAqL1xuY29uc3QgdG9nZ2xlID0gKHZpZXcsIGlkKSA9PiB7XG4gICAgbGV0IG0gPSB2aWV3LmZpbmRCeUlkKGlkKTtcbiAgICBpZiAobS5pc05vdGhpbmcoKSkge1xuICAgICAgICByZXR1cm4gKDAsIHV0aWxfMS53YXJuTWlzc2luZykodmlldywgaWQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbS5nZXQoKS5jbGFzc0xpc3QudG9nZ2xlKGV4cG9ydHMuSElEREVOKTtcbiAgICB9XG59O1xuZXhwb3J0cy50b2dnbGUgPSB0b2dnbGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oaWRkZW4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFN0eWxlQ2xhc3NOYW1lID0gZXhwb3J0cy5zdHlsZXMgPSBleHBvcnRzLlN0eWxlID0gZXhwb3J0cy5PVVRMSU5FID0gZXhwb3J0cy5FUlJPUiA9IGV4cG9ydHMuV0FSTklORyA9IGV4cG9ydHMuSU5GTyA9IGV4cG9ydHMuU1VDQ0VTUyA9IGV4cG9ydHMuUFJJTUFSWSA9IGV4cG9ydHMuREVGQVVMVCA9IHZvaWQgMDtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbi8qKlxuICogREVGQVVMVCBzdHlsZS5cbiAqL1xuZXhwb3J0cy5ERUZBVUxUID0gJy1kZWZhdWx0Jztcbi8qKlxuICogUFJJTUFSWSBzdHlsZS5cbiAqL1xuZXhwb3J0cy5QUklNQVJZID0gJy1wcmltYXJ5Jztcbi8qKlxuICogU1VDQ0VTUyBzdHlsZS5cbiAqL1xuZXhwb3J0cy5TVUNDRVNTID0gJy1zdWNjZXNzJztcbi8qKlxuICogSU5GTyBzdHlsZS5cbiAqL1xuZXhwb3J0cy5JTkZPID0gJy1pbmZvJztcbi8qKlxuICogV0FSTklORyBzdHlsZS5cbiAqL1xuZXhwb3J0cy5XQVJOSU5HID0gJy13YXJuaW5nJztcbi8qKlxuICogRVJST1Igc3R5bGUuXG4gKi9cbmV4cG9ydHMuRVJST1IgPSAnLWVycm9yJztcbi8qKlxuICogT1VUTElORSBzdHlsZS5cbiAqL1xuZXhwb3J0cy5PVVRMSU5FID0gJy1vdXRsaW5lJztcbi8vL2NsYXNzTmFtZXM6ZW5kXG4vKipcbiAqIFN0eWxlIGVudW0uXG4gKi9cbnZhciBTdHlsZTtcbihmdW5jdGlvbiAoU3R5bGUpIHtcbiAgICBTdHlsZVtcIkRlZmF1bHRcIl0gPSBcImRlZmF1bHRcIjtcbiAgICBTdHlsZVtcIlByaW1hcnlcIl0gPSBcInByaW1hcnlcIjtcbiAgICBTdHlsZVtcIlN1Y2Nlc3NcIl0gPSBcInN1Y2Nlc3NcIjtcbiAgICBTdHlsZVtcIkluZm9cIl0gPSBcImluZm9cIjtcbiAgICBTdHlsZVtcIldhcm5pbmdcIl0gPSBcIndhcm5pbmdcIjtcbiAgICBTdHlsZVtcIkVycm9yXCJdID0gXCJlcnJvclwiO1xufSkoU3R5bGUgPSBleHBvcnRzLlN0eWxlIHx8IChleHBvcnRzLlN0eWxlID0ge30pKTtcbmV4cG9ydHMuc3R5bGVzID0gW1xuICAgIFN0eWxlLkRlZmF1bHQsXG4gICAgU3R5bGUuU3VjY2VzcyxcbiAgICBTdHlsZS5JbmZvLFxuICAgIFN0eWxlLldhcm5pbmcsXG4gICAgU3R5bGUuRXJyb3Jcbl07XG4vKipcbiAqIGdldFN0eWxlQ2xhc3NOYW1lXG4gKi9cbmNvbnN0IGdldFN0eWxlQ2xhc3NOYW1lID0gKHMpID0+IHtcbiAgICBzd2l0Y2ggKHMpIHtcbiAgICAgICAgY2FzZSBTdHlsZS5EZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuREVGQVVMVDtcbiAgICAgICAgY2FzZSBTdHlsZS5QcmltYXJ5OlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuUFJJTUFSWTtcbiAgICAgICAgY2FzZSBTdHlsZS5TdWNjZXNzOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuU1VDQ0VTUztcbiAgICAgICAgY2FzZSBTdHlsZS5JbmZvOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuSU5GTztcbiAgICAgICAgY2FzZSBTdHlsZS5XYXJuaW5nOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuV0FSTklORztcbiAgICAgICAgY2FzZSBTdHlsZS5FcnJvcjpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkVSUk9SO1xuICAgIH1cbiAgICByZXR1cm4gZXhwb3J0cy5ERUZBVUxUO1xufTtcbmV4cG9ydHMuZ2V0U3R5bGVDbGFzc05hbWUgPSBnZXRTdHlsZUNsYXNzTmFtZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UYWcgPSBleHBvcnRzLlRBRyA9IGV4cG9ydHMuU3R5bGUgPSB2b2lkIDA7XG5jb25zdCBkb21fMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG5jb25zdCB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xuY29uc3Qgc3R5bGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZW50L3N0eWxlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU3R5bGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0eWxlXzEuU3R5bGU7IH0gfSk7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbmNvbnN0IF9fMSA9IHJlcXVpcmUoXCIuLi8uLi9cIik7XG5jb25zdCB0YWdfMSA9IHJlcXVpcmUoXCIuL3dtbC90YWdcIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLlRBRyA9ICd3dy10YWcnO1xuLyoqXG4gKiBUYWdcbiAqL1xuY2xhc3MgVGFnIGV4dGVuZHMgd21sXzEuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHRhZ18xLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICd0YWcnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWQ6ICgwLCBfXzEuZ2V0SWQpKHRoaXMuYXR0cnMpLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAoMCwgdXRpbF8xLmNvbmNhdCkoZXhwb3J0cy5UQUcsICgwLCBfXzEuZ2V0Q2xhc3NOYW1lKSh0aGlzLmF0dHJzKSwgKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5zdHlsZSkgP1xuICAgICAgICAgICAgICAgICgwLCBzdHlsZV8xLmdldFN0eWxlQ2xhc3NOYW1lKSh0aGlzLmF0dHJzLnN0eWxlKSA6XG4gICAgICAgICAgICAgICAgc3R5bGVfMS5ERUZBVUxUKSxcbiAgICAgICAgICAgIG9uY2xpY2s6IChfKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5vbkNsaWNrKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLm9uQ2xpY2soKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250ZW50OiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLnRleHQpID9cbiAgICAgICAgICAgICAgICBbKDAsIGRvbV8xLnRleHQpKHRoaXMuYXR0cnMudGV4dCldIDogdGhpcy5jaGlsZHJlblxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuVGFnID0gVGFnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1haW4gPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnc3BhbicsIHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMud21sLmlkIH0sICdpZCc6IF9fY29udGV4dC52YWx1ZXMuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuY2xhc3NOYW1lLCAnb25jbGljayc6IF9fY29udGV4dC52YWx1ZXMub25jbGljayB9LCBbXG4gICAgICAgICAgICAgICAgLi4uKF9fY29udGV4dC52YWx1ZXMuY29udGVudClcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2FwdGlvbiA9IGV4cG9ydHMuVGh1bWJuYWlsID0gZXhwb3J0cy5USFVNQk5BSUxfQ0FQVElPTiA9IGV4cG9ydHMuVEhVTUJOQUlMID0gdm9pZCAwO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvdGh1bWJuYWlsXCIpO1xuY29uc3Qgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xuY29uc3QgX18xID0gcmVxdWlyZShcIi4uLy4uL1wiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuVEhVTUJOQUlMID0gJ3d3LXRodW1ibmFpbCc7XG5leHBvcnRzLlRIVU1CTkFJTF9DQVBUSU9OID0gJ3d3LXRodW1ibmFpbF9fY2FwdGlvbic7XG4vKipcbiAqIFRodW1ibmFpbFxuICovXG5jbGFzcyBUaHVtYm5haWwgZXh0ZW5kcyB3bWxfMS5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZpZXcgPSAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmhyZWYpID9cbiAgICAgICAgICAgIG5ldyB2aWV3cy5BbmNob3IodGhpcykgOiBuZXcgdmlld3MuVGh1bWJuYWlsKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiAoMCwgX18xLmdldElkKSh0aGlzLmF0dHJzKSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogKDAsIHV0aWxfMS5jb25jYXQpKGV4cG9ydHMuVEhVTUJOQUlMLCAoMCwgX18xLmdldENsYXNzTmFtZSkodGhpcy5hdHRycykpLFxuICAgICAgICAgICAgaHJlZjogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5ocmVmKSA/XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRycy5ocmVmIDogJycsXG4gICAgICAgICAgICBvbmNsaWNrOiAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMub25DbGljaykge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMub25DbGljaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlRodW1ibmFpbCA9IFRodW1ibmFpbDtcbi8qKlxuICogQ2FwdGlvblxuICovXG5jbGFzcyBDYXB0aW9uIGV4dGVuZHMgd21sXzEuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLkNhcHRpb24odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6ICgwLCBfXzEuZ2V0SWQpKHRoaXMuYXR0cnMpLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAoMCwgdXRpbF8xLmNvbmNhdCkoZXhwb3J0cy5USFVNQk5BSUxfQ0FQVElPTiwgKDAsIF9fMS5nZXRDbGFzc05hbWUpKHRoaXMuYXR0cnMpKVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQ2FwdGlvbiA9IENhcHRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2FwdGlvbiA9IGV4cG9ydHMuQW5jaG9yID0gZXhwb3J0cy5UaHVtYm5haWwgPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBUaHVtYm5haWwge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdkaXYnLCB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuY2xhc3NOYW1lLCAnb25jbGljayc6IF9fY29udGV4dC52YWx1ZXMub25jbGljayB9LCBbXG4gICAgICAgICAgICAgICAgLi4uKF9fY29udGV4dC5jaGlsZHJlbilcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5UaHVtYm5haWwgPSBUaHVtYm5haWw7XG47XG5jbGFzcyBBbmNob3Ige1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdhJywgeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmNsYXNzTmFtZSwgJ2hyZWYnOiBfX2NvbnRleHQudmFsdWVzLmhyZWYsICdvbmNsaWNrJzogX19jb250ZXh0LnZhbHVlcy5vbmNsaWNrIH0sIFtcbiAgICAgICAgICAgICAgICAuLi4oX19jb250ZXh0LmNoaWxkcmVuKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLkFuY2hvciA9IEFuY2hvcjtcbjtcbmNsYXNzIENhcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdkaXYnLCB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuY2xhc3NOYW1lIH0sIFtcbiAgICAgICAgICAgICAgICAuLi4oX19jb250ZXh0LmNoaWxkcmVuKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLkNhcHRpb24gPSBDYXB0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGh1bWJuYWlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CdXR0b25Hcm91cCA9IGV4cG9ydHMuQlVUVE9OX0dST1VQX0NPTVBBVCA9IGV4cG9ydHMuQlVUVE9OX0dST1VQX0JVVFRPTiA9IGV4cG9ydHMuQlVUVE9OX0dST1VQID0gdm9pZCAwO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvYnV0dG9uLWdyb3VwXCIpO1xuY29uc3Qgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xuY29uc3QgdG9vbGJhcl8xID0gcmVxdWlyZShcIi4uL3Rvb2xiYXJcIik7XG5jb25zdCBfXzEgPSByZXF1aXJlKFwiLi4vLi4vXCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5CVVRUT05fR1JPVVAgPSAnd3ctYnV0dG9uLWdyb3VwJztcbmV4cG9ydHMuQlVUVE9OX0dST1VQX0JVVFRPTiA9ICd3dy1idXR0b24tZ3JvdXBfX2J1dHRvbic7XG5leHBvcnRzLkJVVFRPTl9HUk9VUF9DT01QQVQgPSAnd3ctYnV0dG9uLWdyb3VwLWNvbXBhdCc7XG4vKipcbiAqIEJ1dHRvbkdyb3VwIGdyb3VwcyBtdWx0aXBsZSBidXR0b25zIGludG8gb25lIGVsZW1lbnQuXG4gKi9cbmNsYXNzIEJ1dHRvbkdyb3VwIGV4dGVuZHMgd21sXzEuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgICAgIGlkOiAoMCwgX18xLmdldElkKSh0aGlzLmF0dHJzKSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLkJVVFRPTl9HUk9VUCwgdG9vbGJhcl8xLlRPT0xCQVJfQ09NUEFULCAoMCwgX18xLmdldENsYXNzTmFtZSkodGhpcy5hdHRycykpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5CdXR0b25Hcm91cCA9IEJ1dHRvbkdyb3VwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1haW4gPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnZGl2JywgeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMucm9vdC5jbGFzc05hbWUgfSwgW1xuICAgICAgICAgICAgICAgIC4uLihfX2NvbnRleHQuY2hpbGRyZW4pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idXR0b24tZ3JvdXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk11bHRpQnV0dG9uU2VsZWN0ID0gZXhwb3J0cy5CdXR0b25TZWxlY3QgPSBleHBvcnRzLk11bHRpQnV0dG9uU2VjdGlvbiA9IGV4cG9ydHMuQnV0dG9uU2VjdGlvbiA9IGV4cG9ydHMuQnV0dG9uU2VsZWN0VmFsdWVzID0gZXhwb3J0cy5CdXR0b25DaGFuZ2VkRXZlbnQgPSBleHBvcnRzLkJVVFRPTl9TRUxFQ1RfT1BUSU9OID0gZXhwb3J0cy5CVVRUT05fU0VMRUNUID0gdm9pZCAwO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG5jb25zdCBfXzEgPSByZXF1aXJlKFwiLi4vLi4vXCIpO1xuY29uc3QgX18yID0gcmVxdWlyZShcIi4uL1wiKTtcbmNvbnN0IGJ1dHRvbl9zZWxlY3RfMSA9IHJlcXVpcmUoXCIuL3dtbC9idXR0b24tc2VsZWN0XCIpO1xuLy8vY2xhc3NOYW1lOmJlZ2luXG5leHBvcnRzLkJVVFRPTl9TRUxFQ1QgPSAnd3ctYnV0dG9uLXNlbGVjdCc7XG5leHBvcnRzLkJVVFRPTl9TRUxFQ1RfT1BUSU9OID0gJ3d3LWJ1dHRvbi1zZWxlY3RfX29wdGlvbic7XG4vKipcbiAqIEJ1dHRvbkNoYW5nZWRFdmVudFxuICovXG5jbGFzcyBCdXR0b25DaGFuZ2VkRXZlbnQgZXh0ZW5kcyBfXzIuRXZlbnQge1xufVxuZXhwb3J0cy5CdXR0b25DaGFuZ2VkRXZlbnQgPSBCdXR0b25DaGFuZ2VkRXZlbnQ7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIEJ1dHRvblNlbGVjdFZhbHVlcyB7XG4gICAgY29uc3RydWN0b3IocmVmLCBidXR0b24pIHtcbiAgICAgICAgdGhpcy5yZWYgPSByZWY7XG4gICAgICAgIHRoaXMuYnV0dG9uID0gYnV0dG9uO1xuICAgICAgICB0aGlzLmlkID0gKDAsIF9fMS5nZXRJZCkodGhpcy5yZWYuYXR0cnMpO1xuICAgICAgICB0aGlzLmNsYXNzTmFtZSA9ICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLkJVVFRPTl9TRUxFQ1QsICgwLCBfXzEuZ2V0Q2xhc3NOYW1lKSh0aGlzLnJlZi5hdHRycykpO1xuICAgIH1cbn1cbmV4cG9ydHMuQnV0dG9uU2VsZWN0VmFsdWVzID0gQnV0dG9uU2VsZWN0VmFsdWVzO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBCdXR0b25TZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihyZWYsIG9uQ2xpY2spIHtcbiAgICAgICAgdGhpcy5yZWYgPSByZWY7XG4gICAgICAgIHRoaXMub25DbGljayA9IG9uQ2xpY2s7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IGdldEN1cnJlbnQodGhpcy5yZWYuYXR0cnMpO1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gW107XG4gICAgICAgIHRoaXMub3B0aW9ucyA9ICh0aGlzLnJlZi5hdHRycyAmJiB0aGlzLnJlZi5hdHRycy5vcHRpb25zKSA/XG4gICAgICAgICAgICB0aGlzLnJlZi5hdHRycy5vcHRpb25zIDogW107XG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSAobikgPT4gdGhpcy5yZWYudmFsdWVzLmJ1dHRvbi5jdXJyZW50ID09PSBuO1xuICAgICAgICB0aGlzLmdldENsYXNzTmFtZXMgPSAobikgPT4gKDAsIHV0aWxfMS5jb25jYXQpKGV4cG9ydHMuQlVUVE9OX1NFTEVDVF9PUFRJT04sIHRoaXMucmVmLnZhbHVlcy5idXR0b24ub3B0aW9uc1tuXS5jbGFzc05hbWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuQnV0dG9uU2VjdGlvbiA9IEJ1dHRvblNlY3Rpb247XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIE11bHRpQnV0dG9uU2VjdGlvbiBleHRlbmRzIEJ1dHRvblNlY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHJlZiwgb25DbGljaykge1xuICAgICAgICBzdXBlcihyZWYsIG9uQ2xpY2spO1xuICAgICAgICB0aGlzLnJlZiA9IHJlZjtcbiAgICAgICAgdGhpcy5vbkNsaWNrID0gb25DbGljaztcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IGdldFNlbGVjdGVkKHRoaXMucmVmKTtcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IChuKSA9PiB0aGlzLnJlZi52YWx1ZXMuYnV0dG9uLnNlbGVjdGVkLmluZGV4T2YobikgPiAtMTtcbiAgICB9XG59XG5leHBvcnRzLk11bHRpQnV0dG9uU2VjdGlvbiA9IE11bHRpQnV0dG9uU2VjdGlvbjtcbi8qKlxuICogQnV0dG9uU2VsZWN0XG4gKi9cbmNsYXNzIEJ1dHRvblNlbGVjdCBleHRlbmRzIF9fMi5BYnN0cmFjdENvbnRyb2wge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgYnV0dG9uX3NlbGVjdF8xLkJ1dHRvblNlbGVjdFZpZXcodGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0gbmV3IEJ1dHRvblNlbGVjdFZhbHVlcyh0aGlzLCBuZXcgQnV0dG9uU2VjdGlvbih0aGlzLCAoaWR4KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5idXR0b24uY3VycmVudCA9IGlkeDtcbiAgICAgICAgICAgIGlmICgodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLm9uQ2hhbmdlKSlcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLm9uQ2hhbmdlKG5ldyBCdXR0b25DaGFuZ2VkRXZlbnQodGhpcy5hdHRycy5uYW1lLCB0aGlzLnZhbHVlcy5idXR0b24ub3B0aW9uc1tpZHhdLnZhbHVlKSk7XG4gICAgICAgICAgICB0aGlzLnZpZXcuaW52YWxpZGF0ZSgpO1xuICAgICAgICB9KSk7XG4gICAgfVxufVxuZXhwb3J0cy5CdXR0b25TZWxlY3QgPSBCdXR0b25TZWxlY3Q7XG4vKipcbiAqIE11bHRpQnV0dG9uU2VsZWN0XG4gKi9cbmNsYXNzIE11bHRpQnV0dG9uU2VsZWN0IGV4dGVuZHMgX18yLkFic3RyYWN0Q29udHJvbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyBidXR0b25fc2VsZWN0XzEuQnV0dG9uU2VsZWN0Vmlldyh0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSBuZXcgQnV0dG9uU2VsZWN0VmFsdWVzKHRoaXMsIG5ldyBNdWx0aUJ1dHRvblNlY3Rpb24odGhpcywgKG4pID0+IHtcbiAgICAgICAgICAgIGxldCBzZWxlY3RlZCA9IHRoaXMudmFsdWVzLmJ1dHRvbi5zZWxlY3RlZDtcbiAgICAgICAgICAgIGxldCBwb3MgPSBzZWxlY3RlZC5pbmRleE9mKG4pO1xuICAgICAgICAgICAgaWYgKHBvcyA+IC0xKVxuICAgICAgICAgICAgICAgIHNlbGVjdGVkLnNwbGljZShwb3MsIDEpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNlbGVjdGVkLnB1c2gobik7XG4gICAgICAgICAgICBpZiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLm9uQ2hhbmdlKVxuICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMub25DaGFuZ2UobmV3IEJ1dHRvbkNoYW5nZWRFdmVudCh0aGlzLmF0dHJzLm5hbWUsIHNlbGVjdGVkLm1hcChuID0+IHRoaXMudmFsdWVzLmJ1dHRvbi5vcHRpb25zW25dLnZhbHVlKSkpO1xuICAgICAgICAgICAgdGhpcy52aWV3LmludmFsaWRhdGUoKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuTXVsdGlCdXR0b25TZWxlY3QgPSBNdWx0aUJ1dHRvblNlbGVjdDtcbmNvbnN0IGdldEN1cnJlbnQgPSAoYXR0cnMpID0+IHtcbiAgICBpZiAoKGF0dHJzICE9IG51bGwpICYmXG4gICAgICAgIChhdHRycy52YWx1ZSAhPSBudWxsKSAmJlxuICAgICAgICAoYXR0cnMub3B0aW9ucyAhPSBudWxsKSkge1xuICAgICAgICByZXR1cm4gYXR0cnMub3B0aW9ucy5yZWR1Y2UoKHAsIGMsIGspID0+IGMudmFsdWUgPT09XG4gICAgICAgICAgICBhdHRycy52YWx1ZSA/IGsgOiBwLCAtMSk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn07XG5jb25zdCBnZXRTZWxlY3RlZCA9ICh0aGF0KSA9PiB7XG4gICAgaWYgKHRoYXQuYXR0cnMgJiZcbiAgICAgICAgdGhhdC5hdHRycyAmJlxuICAgICAgICB0aGF0LmF0dHJzLnZhbHVlICYmXG4gICAgICAgIHRoYXQuYXR0cnMub3B0aW9ucykge1xuICAgICAgICBsZXQgeyB2YWx1ZSwgb3B0aW9ucyB9ID0gdGhhdC5hdHRycztcbiAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCh2ID0+IG9wdGlvbnMucmVkdWNlKChwLCBjLCBpKSA9PiAocCA+IC0xKSA/IHAgOiAoYy52YWx1ZSA9PT0gdikgPyBpIDogcCwgLTEpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJ1dHRvblNlbGVjdFZpZXcgPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbmNvbnN0IGJ1dHRvbl9ncm91cF8xID0gcmVxdWlyZShcIi4uLy4uL2J1dHRvbi1ncm91cFwiKTtcbjtcbmNvbnN0IGJ1dHRvbl8xID0gcmVxdWlyZShcIi4uLy4uL2J1dHRvblwiKTtcbjtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG47XG5jbGFzcyBCdXR0b25TZWxlY3RWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KG5ldyBidXR0b25fZ3JvdXBfMS5CdXR0b25Hcm91cCh7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuaWQsICdjbGFzc05hbWUnOiBfX2NvbnRleHQudmFsdWVzLmNsYXNzTmFtZSB9LCBbXG4gICAgICAgICAgICAgICAgLi4uX19mb3JJbihfX2NvbnRleHQudmFsdWVzLmJ1dHRvbi5vcHRpb25zLCAob3B0LCBpZHgsIF8kJGFsbCkgPT4gKFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgYnV0dG9uXzEuQnV0dG9uKHsgJ2NsYXNzTmFtZSc6IF9fY29udGV4dC52YWx1ZXMuYnV0dG9uLmdldENsYXNzTmFtZXMoaWR4KSwgJ2FjdGl2ZSc6IF9fY29udGV4dC52YWx1ZXMuYnV0dG9uLmlzQWN0aXZlKGlkeCksICdvbkNsaWNrJzogKCkgPT4gX19jb250ZXh0LnZhbHVlcy5idXR0b24ub25DbGljayhpZHgpLCAndGV4dCc6IG9wdC50ZXh0IH0sIFtdKSwgeyAnY2xhc3NOYW1lJzogX19jb250ZXh0LnZhbHVlcy5idXR0b24uZ2V0Q2xhc3NOYW1lcyhpZHgpLCAnYWN0aXZlJzogX19jb250ZXh0LnZhbHVlcy5idXR0b24uaXNBY3RpdmUoaWR4KSwgJ29uQ2xpY2snOiAoKSA9PiBfX2NvbnRleHQudmFsdWVzLmJ1dHRvbi5vbkNsaWNrKGlkeCksICd0ZXh0Jzogb3B0LnRleHQgfSlcbiAgICAgICAgICAgICAgICBdKSwgKCkgPT4gKFtdKSlcbiAgICAgICAgICAgIF0pLCB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuaWQsICdjbGFzc05hbWUnOiBfX2NvbnRleHQudmFsdWVzLmNsYXNzTmFtZSB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuQnV0dG9uU2VsZWN0VmlldyA9IEJ1dHRvblNlbGVjdFZpZXc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idXR0b24tc2VsZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CdXR0b24gPSBleHBvcnRzLkJ1dHRvbkNsaWNrZWRFdmVudCA9IGV4cG9ydHMuQlVUVE9OID0gZXhwb3J0cy5TdHlsZSA9IHZvaWQgMDtcbmNvbnN0IHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2J1dHRvblwiKTtcbmNvbnN0IGRvbV8xID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbmNvbnN0IHRvb2xiYXJfMSA9IHJlcXVpcmUoXCIuLi90b29sYmFyXCIpO1xuY29uc3QgYWN0aXZlXzEgPSByZXF1aXJlKFwiLi4vLi4vY29udGVudC9zdGF0ZS9hY3RpdmVcIik7XG5jb25zdCBvcmllbnRhdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRlbnQvb3JpZW50YXRpb25cIik7XG5jb25zdCBzdHlsZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRlbnQvc3R5bGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTdHlsZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3R5bGVfMS5TdHlsZTsgfSB9KTtcbmNvbnN0IHNpemVfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZW50L3NpemVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbmNvbnN0IF9fMSA9IHJlcXVpcmUoXCIuLi8uLi9cIik7XG5jb25zdCBfXzIgPSByZXF1aXJlKFwiLi4vXCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5CVVRUT04gPSAnd3ctYnV0dG9uJztcbjtcbi8qKlxuICogQnV0dG9uQ2xpY2tlZEV2ZW50XG4gKi9cbmNsYXNzIEJ1dHRvbkNsaWNrZWRFdmVudCBleHRlbmRzIF9fMi5FdmVudCB7XG59XG5leHBvcnRzLkJ1dHRvbkNsaWNrZWRFdmVudCA9IEJ1dHRvbkNsaWNrZWRFdmVudDtcbi8qKlxuICogQnV0dG9uIGlzIGFuIGltcHJvdmVtZW50IG92ZXIgSFRNTEJ1dHRpb25FbGVtZW50XG4gKi9cbmNsYXNzIEJ1dHRvbiBleHRlbmRzIF9fMi5BYnN0cmFjdENvbnRyb2wge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZpZXcgPSAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmFuY2hvcikgP1xuICAgICAgICAgICAgbmV3IHZpZXdzLkFuY2hvclZpZXcodGhpcykgOiBuZXcgdmlld3MuQnV0dG9uVmlldyh0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBidXR0b246IHtcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdidXR0b24nXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpZDogKDAsIF9fMS5nZXRJZCkodGhpcy5hdHRycyksXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAoMCwgdXRpbF8xLmNvbmNhdCkoZXhwb3J0cy5CVVRUT04sICgwLCBfXzEuZ2V0Q2xhc3NOYW1lKSh0aGlzLmF0dHJzKSwgdG9vbGJhcl8xLlRPT0xCQVJfQ09NUEFULCAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLnN0eWxlKSA/XG4gICAgICAgICAgICAgICAgICAgICgwLCBzdHlsZV8xLmdldFN0eWxlQ2xhc3NOYW1lKSh0aGlzLmF0dHJzLnN0eWxlKSA6XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlXzEuREVGQVVMVCwgKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5zaXplKSA/XG4gICAgICAgICAgICAgICAgICAgICgwLCBzaXplXzEuZ2V0U2l6ZUNsYXNzTmFtZSkodGhpcy5hdHRycy5zaXplKSA6ICcnLCAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLm91dGxpbmUpID9cbiAgICAgICAgICAgICAgICAgICAgc3R5bGVfMS5PVVRMSU5FIDogJycsICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuYmxvY2spID9cbiAgICAgICAgICAgICAgICAgICAgb3JpZW50YXRpb25fMS5CTE9DSyA6ICcnLCAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmFjdGl2ZSkgP1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVfMS5BQ1RJVkUgOiAnJyksXG4gICAgICAgICAgICAgICAgdHlwZTogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy50eXBlKSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMudHlwZSA6ICdidXR0b24nLFxuICAgICAgICAgICAgICAgIG5hbWU6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMubmFtZSkgPyB0aGlzLmF0dHJzLm5hbWUgOiAnJyxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5kaXNhYmxlZCkgPyB0cnVlIDogbnVsbCxcbiAgICAgICAgICAgICAgICBhbmNob3I6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuYW5jaG9yKSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMuYW5jaG9yIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgb25jbGljazogKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLm9uQ2xpY2sgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMub25DbGljayhuZXcgQnV0dG9uQ2xpY2tlZEV2ZW50KCh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMubmFtZSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMubmFtZSA6ICcnLCB0aGlzLmF0dHJzLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiAoKSA9PiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLnRleHQpID9cbiAgICAgICAgICAgICAgICAgICAgWygwLCBkb21fMS50ZXh0KSh0aGlzLmF0dHJzLnRleHQpXSA6IHRoaXMuY2hpbGRyZW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZGlzYWJsZSB0aGlzIGJ1dHRvbi5cbiAgICAgKi9cbiAgICBkaXNhYmxlKCkge1xuICAgICAgICAoMCwgdXRpbF8xLmdldEJ5SWQpKHRoaXMudmlldywgdGhpcy52YWx1ZXMuYnV0dG9uLndtbC5pZClcbiAgICAgICAgICAgIC5tYXAoKGIpID0+IGIuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZW5hYmxlIHRoaXMgYnV0dG9uLlxuICAgICAqL1xuICAgIGVuYWJsZSgpIHtcbiAgICAgICAgKDAsIHV0aWxfMS5nZXRCeUlkKSh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLmJ1dHRvbi53bWwuaWQpXG4gICAgICAgICAgICAubWFwKChiKSA9PiBiLnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRvZ2dsZSB0aGUgZGlzYWJsZWQgc3RhdGUgb2YgdGhpcyBidXR0b24uXG4gICAgICovXG4gICAgdG9nZ2xlKCkge1xuICAgICAgICAoMCwgdXRpbF8xLmdldEJ5SWQpKHRoaXMudmlldywgdGhpcy52YWx1ZXMuYnV0dG9uLndtbC5pZClcbiAgICAgICAgICAgIC5tYXAoKGIpID0+IGIuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpID9cbiAgICAgICAgICAgIHRoaXMuZW5hYmxlKCkgOiB0aGlzLmRpc2FibGUoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5CdXR0b24gPSBCdXR0b247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQW5jaG9yVmlldyA9IGV4cG9ydHMuQnV0dG9uVmlldyA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9faWYgPSAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpID0+IChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0ID8gX19hbHQoKSA6IFtdO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9ySW4gPSAobGlzdCwgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2Zvck9mID0gKG8sIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHRleHQgPSBfX2RvY3VtZW50LnRleHQ7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHVuc2FmZSA9IF9fZG9jdW1lbnQudW5zYWZlO1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCBpc1NldCA9ICh2YWx1ZSkgPT4gdmFsdWUgIT0gbnVsbDtcbmNsYXNzIEJ1dHRvblZpZXcge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdidXR0b24nLCB7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmJ1dHRvbi53bWwuaWQgfSwgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5idXR0b24uaWQsICd0eXBlJzogX19jb250ZXh0LnZhbHVlcy5idXR0b24udHlwZSwgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLmJ1dHRvbi5uYW1lLCAnZGlzYWJsZWQnOiBfX2NvbnRleHQudmFsdWVzLmJ1dHRvbi5kaXNhYmxlZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5idXR0b24uY2xhc3NOYW1lLCAnb25jbGljayc6IF9fY29udGV4dC52YWx1ZXMuYnV0dG9uLm9uY2xpY2sgfSwgW1xuICAgICAgICAgICAgICAgIC4uLihfX2NvbnRleHQudmFsdWVzLmJ1dHRvbi5jb250ZW50KCkpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuQnV0dG9uVmlldyA9IEJ1dHRvblZpZXc7XG47XG5jbGFzcyBBbmNob3JWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnYScsIHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuYnV0dG9uLndtbC5pZCB9LCAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmJ1dHRvbi5pZCwgJ3R5cGUnOiBfX2NvbnRleHQudmFsdWVzLmJ1dHRvbi50eXBlLCAnaHJlZic6ICcjJywgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLmJ1dHRvbi5uYW1lLCAnZGlzYWJsZWQnOiBfX2NvbnRleHQudmFsdWVzLmJ1dHRvbi5kaXNhYmxlZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5idXR0b24uY2xhc3NOYW1lLCAnb25jbGljayc6IF9fY29udGV4dC52YWx1ZXMuYnV0dG9uLm9uY2xpY2sgfSwgW1xuICAgICAgICAgICAgICAgIC4uLihfX2NvbnRleHQudmFsdWVzLmJ1dHRvbi5jb250ZW50KCkpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuQW5jaG9yVmlldyA9IEFuY2hvclZpZXc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idXR0b24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNoZWNrYm94ID0gZXhwb3J0cy5DaGVja0NoYW5nZWRFdmVudCA9IGV4cG9ydHMuQ0hFQ0tCT1ggPSB2b2lkIDA7XG5jb25zdCBjaGVja2JveF8xID0gcmVxdWlyZShcIi4vd21sL2NoZWNrYm94XCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG5jb25zdCBfXzEgPSByZXF1aXJlKFwiLi4vXCIpO1xuY29uc3QgX18yID0gcmVxdWlyZShcIi4uLy4uL1wiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuQ0hFQ0tCT1ggPSAnd3ctY2hlY2tib3gnO1xuLyoqXG4gKiBDaGVja0NoYW5nZWRFdmVudCBzaWduYWxzIHRoZSB1c2VyIGhhcyBjaGFuZ2VkIHRoZSBjaGVja2JveCBzdGF0ZS5cbiAqL1xuY2xhc3MgQ2hlY2tDaGFuZ2VkRXZlbnQgZXh0ZW5kcyBfXzEuRXZlbnQge1xufVxuZXhwb3J0cy5DaGVja0NoYW5nZWRFdmVudCA9IENoZWNrQ2hhbmdlZEV2ZW50O1xuLyoqXG4gKiBDaGVja2JveCBjb250cm9sLlxuICpcbiAqIFRoaXMgaXMgYW4gYWx0ZXJuYXRpdmUgdG8gdGhlIG5hdGl2ZSBjaGVja2JveCB0aGF0IGNhbiBiZSBzdHlsZWQuXG4gKi9cbmNsYXNzIENoZWNrYm94IGV4dGVuZHMgX18xLkFic3RyYWN0Q29udHJvbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyBjaGVja2JveF8xLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgICAgIGlkOiAoMCwgX18yLmdldElkKSh0aGlzLmF0dHJzKSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLkNIRUNLQk9YLCAoMCwgX18yLmdldENsYXNzTmFtZSkodGhpcy5hdHRycykpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5wdXQ6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAoMCwgX18xLmdldE5hbWUpKHRoaXMuYXR0cnMpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLnZhbHVlKSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMudmFsdWUgOiBudWxsLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzLmlucHV0LnZhbHVlID0gKCF0aGlzLnZhbHVlcy5pbnB1dC52YWx1ZSkgfHwgbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5vbkNoYW5nZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMub25DaGFuZ2UobmV3IENoZWNrQ2hhbmdlZEV2ZW50KHRoaXMudmFsdWVzLmlucHV0Lm5hbWUsIHRoaXMudmFsdWVzLmlucHV0LnZhbHVlIHx8IGZhbHNlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hlY2tib3ggPSBDaGVja2JveDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYWluID0gdm9pZCAwO1xuY29uc3QgX19kb2N1bWVudCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbmNvbnN0IG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ3NwYW4nLCB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMucm9vdC5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5yb290LmNsYXNzTmFtZSB9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2xhYmVsJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2lucHV0JywgeyAndHlwZSc6ICdjaGVja2JveCcsICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5pbnB1dC5uYW1lLCAnY2hlY2tlZCc6IF9fY29udGV4dC52YWx1ZXMuaW5wdXQudmFsdWUsICdvbmNoYW5nZSc6IF9fY29udGV4dC52YWx1ZXMuaW5wdXQub25DaGFuZ2UgfSwgW10pLFxuICAgICAgICAgICAgICAgICAgICAuLi4oX19jb250ZXh0LmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVja2JveC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2xvc2VCdXR0b24gPSBleHBvcnRzLkNMT1NFX0JVVFRPTiA9IHZvaWQgMDtcbmNvbnN0IHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbmNvbnN0IF9fMSA9IHJlcXVpcmUoXCIuLi8uLi9cIik7XG5jb25zdCBjbG9zZV9idXR0b25fMSA9IHJlcXVpcmUoXCIuL3dtbC9jbG9zZS1idXR0b25cIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLkNMT1NFX0JVVFRPTiA9ICd3dy1jbG9zZS1idXR0b24nO1xuO1xuLyoqXG4gKiBDbG9zZUJ1dHRvbiB1c2VkIHRvIGRpc3BsYXkgdGhlIFwieFwiIG9uIGRpYWxvZ3MgZXRjLlxuICovXG5jbGFzcyBDbG9zZUJ1dHRvbiBleHRlbmRzIHdtbF8xLkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyBjbG9zZV9idXR0b25fMS5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiAoMCwgX18xLmdldElkKSh0aGlzLmF0dHJzKSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogKDAsIHV0aWxfMS5jb25jYXQpKGV4cG9ydHMuQ0xPU0VfQlVUVE9OLCAoMCwgX18xLmdldENsYXNzTmFtZSkodGhpcy5hdHRycykpLFxuICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdjbG9zZS1idXR0b24nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25jbGljazogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMub25DbGljaylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5vbkNsaWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5DbG9zZUJ1dHRvbiA9IENsb3NlQnV0dG9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1haW4gPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbmNvbnN0IGNsb3NlXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY29udGVudC9jbG9zZVwiKTtcbjtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnYnV0dG9uJywgeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmNsYXNzTmFtZSwgJ29uY2xpY2snOiBfX2NvbnRleHQudmFsdWVzLm9uY2xpY2sgfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGNsb3NlXzEuQ2xvc2Uoe30sIFtdKSwge30pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbG9zZS1idXR0b24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRhdGVGaWVsZCA9IGV4cG9ydHMuRGF0ZUNoYW5nZWRFdmVudCA9IGV4cG9ydHMuRm9ybWF0ID0gZXhwb3J0cy51c0Zvcm1hdHMgPSBleHBvcnRzLmNvbW1vbkZvcm1hdHMgPSBleHBvcnRzLmlzbzg2MDFGb3JtYXRzID0gZXhwb3J0cy5ZRVNURVJEQVkgPSBleHBvcnRzLk5PVyA9IGV4cG9ydHMuVE9EQVkgPSBleHBvcnRzLkRFTEFZID0gZXhwb3J0cy5WQUxVRV9GT1JNQVQgPSBleHBvcnRzLkRFRkFVTFRfSU5QVVRfRElTUExBWSA9IGV4cG9ydHMuREVGQVVMVF9JTlBVVF9QTEFDRUhPTERFUiA9IGV4cG9ydHMuREVGQVVMVF9JTlBVVF9GT1JNQVQgPSBleHBvcnRzLkRBVEVfRklFTERfSU5QVVQgPSBleHBvcnRzLkRBVEVfRklFTEQgPSB2b2lkIDA7XG5jb25zdCB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9kYXRlLWZpZWxkXCIpO1xuY29uc3QgbW9tZW50ID0gcmVxdWlyZShcIm1vbWVudFwiKTtcbmNvbnN0IG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbmNvbnN0IGZlZWRiYWNrXzEgPSByZXF1aXJlKFwiLi4vZmVlZGJhY2tcIik7XG5jb25zdCBmb3JtXzEgPSByZXF1aXJlKFwiLi4vZm9ybVwiKTtcbmNvbnN0IF9fMSA9IHJlcXVpcmUoXCIuLi8uLi9cIik7XG5jb25zdCBfXzIgPSByZXF1aXJlKFwiLi4vXCIpO1xuY29uc3Qgb3JpZW50YXRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZW50L29yaWVudGF0aW9uXCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5EQVRFX0ZJRUxEID0gJ3d3LWRhdGUtZmllbGQnO1xuZXhwb3J0cy5EQVRFX0ZJRUxEX0lOUFVUID0gJ3d3LWRhdGUtZmllbGRfX2lucHV0Jztcbi8vL2NsYXNzTmFtZXM6ZW5kXG5leHBvcnRzLkRFRkFVTFRfSU5QVVRfRk9STUFUID0gbW9tZW50LklTT184NjAxO1xuZXhwb3J0cy5ERUZBVUxUX0lOUFVUX1BMQUNFSE9MREVSID0gJ1lZWVktTU0tREQnO1xuZXhwb3J0cy5ERUZBVUxUX0lOUFVUX0RJU1BMQVkgPSAnWVlZWS1NTS1ERCc7XG5leHBvcnRzLlZBTFVFX0ZPUk1BVCA9ICdZWVlZLU1NLUREJztcbmV4cG9ydHMuREVMQVkgPSAyMDA7XG5leHBvcnRzLlRPREFZID0gJ3RvZGF5JztcbmV4cG9ydHMuTk9XID0gJ25vdyc7XG5leHBvcnRzLllFU1RFUkRBWSA9ICd5ZXN0ZXJkYXknO1xuZXhwb3J0cy5pc284NjAxRm9ybWF0cyA9IFtcbiAgICAnWVlZWS1NTS1ERCcsXG4gICAgJ1lZWVktTU0tRCcsXG4gICAgJ1lZWVktTS1ERCcsXG4gICAgJ1lZWVktTS1EJyxcbiAgICAnWVktTU0tREQnLFxuICAgICdZWS1NTS1EJyxcbiAgICAnWVktTS1ERCcsXG4gICAgJ1lZLU0tRCcsXG4gICAgJ1lZWVkvTU0vREQnLFxuICAgICdZWVlZL01NL0QnLFxuICAgICdZWVlZL00vREQnLFxuICAgICdZWVlZL00vRCcsXG4gICAgJ1lZL01NL0REJyxcbiAgICAnWVkvTU0vRCcsXG4gICAgJ1lZL00vREQnLFxuICAgICdZWS9NL0QnLFxuICAgICdZWVlZIE1NIEREJyxcbiAgICAnWVlZWSBNTSBEJyxcbiAgICAnWVlZWSBNIEREJyxcbiAgICAnWVlZWSBNIEQnLFxuICAgICdZWSBNTSBERCcsXG4gICAgJ1lZIE1NIEQnLFxuICAgICdZWSBNIEREJyxcbiAgICAnWVkgTSBEJyxcbiAgICAnWVlZWU1NREQnLFxuICAgICdZWVlZTU1EJyxcbiAgICAnWVlZWU1ERCcsXG4gICAgJ1lZWVlNRCcsXG4gICAgJ1lZTU1ERCcsXG4gICAgJ1lZTU1EJyxcbiAgICAnWVlNREQnLFxuICAgICdZWU1EJyxcbl07XG5leHBvcnRzLmNvbW1vbkZvcm1hdHMgPSBbXG4gICAgJ0RELU1NLVlZWVknLFxuICAgICdELU1NLVlZWVknLFxuICAgICdERC1NLVlZWVknLFxuICAgICdELU0tWVlZWScsXG4gICAgJ0RELU1NLVlZJyxcbiAgICAnRC1NTS1ZWScsXG4gICAgJ0RELU0tWVknLFxuICAgICdELU0tWVknLFxuICAgICdERC9NTS9ZWVlZJyxcbiAgICAnRC9NTS9ZWVlZJyxcbiAgICAnREQvTS9ZWVlZJyxcbiAgICAnRC9NL1lZWVknLFxuICAgICdERC9NTS9ZWScsXG4gICAgJ0QvTU0vWVknLFxuICAgICdERC9NL1lZJyxcbiAgICAnRC9NL1lZJyxcbiAgICAnREQgTU0gWVlZWScsXG4gICAgJ0QgTU0gWVlZWScsXG4gICAgJ0REIE0gWVlZWScsXG4gICAgJ0QgTSBZWVlZJyxcbiAgICAnREQgTU0gWVknLFxuICAgICdEIE1NIFlZJyxcbiAgICAnREQgTSBZWScsXG4gICAgJ0QgTSBZWScsXG4gICAgJ0RETU1ZWVlZJyxcbiAgICAnRE1NWVlZWScsXG4gICAgJ0RETVlZWVknLFxuICAgICdETVlZWVknLFxuICAgICdERE1NWVknLFxuICAgICdETU1ZWScsXG4gICAgJ0RETVlZJyxcbiAgICAnRE1ZWScsXG5dO1xuZXhwb3J0cy51c0Zvcm1hdHMgPSBbXG4gICAgJ01NLURELVlZWVknLFxuICAgICdNTS1ELVlZWVknLFxuICAgICdNLURELVlZWVknLFxuICAgICdNLUQtWVlZWScsXG4gICAgJ01NLURELVlZJyxcbiAgICAnTU0tRC1ZWScsXG4gICAgJ00tREQtWVknLFxuICAgICdNLUQtWVknLFxuICAgICdNTS9ERC9ZWVlZJyxcbiAgICAnTU0vRC9ZWVlZJyxcbiAgICAnTS9ERC9ZWVlZJyxcbiAgICAnTS9EL1lZWVknLFxuICAgICdNTS9ERC9ZWScsXG4gICAgJ01NL0QvWVknLFxuICAgICdNL0REL1lZJyxcbiAgICAnTS9EL1lZJyxcbiAgICAnTU0gREQgWVlZWScsXG4gICAgJ01NIEQgWVlZWScsXG4gICAgJ00gREQgWVlZWScsXG4gICAgJ00gRCBZWVlZJyxcbiAgICAnTU0gREQgWVknLFxuICAgICdNTSBEIFlZJyxcbiAgICAnTSBERCBZWScsXG4gICAgJ00gRCBZWScsXG4gICAgJ01NRERZWVlZJyxcbiAgICAnTU1EWVlZWScsXG4gICAgJ01ERFlZWVknLFxuICAgICdNRFlZWVknLFxuICAgICdNTUREWVknLFxuICAgICdNTURZWScsXG4gICAgJ01ERFlZJyxcbiAgICAnTURZWScsXG5dO1xuLyoqXG4gKiBGb3JtYXQgaXMgdXNlZCB0byBkZXRlcm1pbmUgd2hhdCBmb3JtYXQgaW5wdXQgc2hvdWxkIGJlIHBhcnNlZCBhcy5cbiAqL1xudmFyIEZvcm1hdDtcbihmdW5jdGlvbiAoRm9ybWF0KSB7XG4gICAgRm9ybWF0W0Zvcm1hdFtcIklTTzg2MDFcIl0gPSAxXSA9IFwiSVNPODYwMVwiO1xuICAgIEZvcm1hdFtGb3JtYXRbXCJDT01NT05cIl0gPSAyXSA9IFwiQ09NTU9OXCI7XG4gICAgRm9ybWF0W0Zvcm1hdFtcIlVTQVwiXSA9IDNdID0gXCJVU0FcIjtcbn0pKEZvcm1hdCA9IGV4cG9ydHMuRm9ybWF0IHx8IChleHBvcnRzLkZvcm1hdCA9IHt9KSk7XG4vKipcbiAqIERhdGVDaGFuZ2VkRXZlbnQgaXMgZ2VuZXJhdGVkIHdoZW4gYSB2YWxpZCBkYXRlIGhhcyBiZWVuIGVudGVyZWQuXG4gKlxuICogVGhlIHZhbHVlIGlzIGEgdHJ1bmNhdGVkIElTTzg2MDEgc3RyaW5nIGNvbnNpc3Rpbmcgb2YgdGhlIGRhdGUgcGFydCBhbG9uZS5cbiAqL1xuY2xhc3MgRGF0ZUNoYW5nZWRFdmVudCBleHRlbmRzIF9fMi5FdmVudCB7XG59XG5leHBvcnRzLkRhdGVDaGFuZ2VkRXZlbnQgPSBEYXRlQ2hhbmdlZEV2ZW50O1xuLyoqXG4gKiBEYXRlRmllbGQgcHJvdmlkZXMgYSB0ZXh0IGZpZWxkIGZvciBlbnRlcmluZyBkYXRlcy5cbiAqXG4gKiBJdCB3aWxsIG9ubHkgZmlyZSBjaGFuZ2UgZXZlbnRzIHdoZW4gdGhlIGRhdGUgaW5wdXQgbWF0Y2hlcyBvbmVcbiAqIG9mIHRoZSAzIGZvcm1hdCBzZXRzIChJU084NjAxLENvbW1vbixVUykuXG4gKlxuICogSWYgdGhlIHVzZXIgcmVtb3ZlcyBmb2N1cyBhbmQgdGhlIGVudHJ5IGlzIG5vdCB2YWxpZCwgaXQgd2lsbCBiZSBpZ25vcmVkXG4gKiBhbmQgbm8gY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQuIE9uY2UgYSB2YWxpZCBkYXRlIGhhcyBiZWVuIGVudGVyZWQsXG4gKiB0aGUgdmFsdWUgZGlzcGxheWVkIGNhbiBiZSBmb3JtYXRlZCB1c2luZyB0aGUgZm9ybWF0IHNwZWNpZmllZCBpbiB0aGVcbiAqIFwiZGlzcGxheVwiIGF0dHJpYnV0ZS4gVGhpcyBkb2VzIG5vdCBhZmZlY3QgdGhlIGFjdHVhbCB2YWx1ZSBwcm92aWRlZFxuICogdG8gb25DaGFuZ2UgaGFuZGxlcnMuXG4gKi9cbmNsYXNzIERhdGVGaWVsZCBleHRlbmRzIGZvcm1fMS5BYnN0cmFjdEZvcm1Db250cm9sIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgICAgIHdtbDogeyBpZDogJ3Jvb3QnIH0sXG4gICAgICAgICAgICAgICAgaWQ6ICgwLCBfXzEuZ2V0SWQpKHRoaXMuYXR0cnMpLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogKDAsIHV0aWxfMS5jb25jYXQpKGV4cG9ydHMuREFURV9GSUVMRCwgKDAsIF9fMS5nZXRDbGFzc05hbWUpKHRoaXMuYXR0cnMpLCAoMCwgb3JpZW50YXRpb25fMS5nZXRCbG9ja0NsYXNzTmFtZSkodGhpcy5hdHRycyksICgwLCBmZWVkYmFja18xLmdldFZhbGlkaXR5Q2xhc3NOYW1lKSh0aGlzLmF0dHJzKSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udHJvbDoge1xuICAgICAgICAgICAgICAgIHdtbDogeyBpZDogJ2lucHV0JyB9LFxuICAgICAgICAgICAgICAgIGlkOiAoMCwgX18xLmdldElkKSh0aGlzLmF0dHJzKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMubmFtZSkgfHwgJycsXG4gICAgICAgICAgICAgICAgdGV4dDogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5sYWJlbCkgfHwgJydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZXNzYWdlczoge1xuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ21lc3NhZ2VzJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGV4dDogKDAsIGZlZWRiYWNrXzEuZ2V0TWVzc2FnZSkodGhpcy5hdHRycylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbnB1dDoge1xuICAgICAgICAgICAgICAgIHdtbDogeyBpZDogJ2lucHV0JyB9LFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogZXhwb3J0cy5EQVRFX0ZJRUxEX0lOUFVULFxuICAgICAgICAgICAgICAgIG5hbWU6ICgwLCBfXzIuZ2V0TmFtZSkodGhpcy5hdHRycyksXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBnZXRGb3JtYXQodGhpcy5hdHRycyksXG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IGdldFBsYWNlaG9sZGVyKHRoaXMuYXR0cnMpLFxuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGdldERpc3BsYXkodGhpcy5hdHRycyksXG4gICAgICAgICAgICAgICAgbW9tZW50OiAoKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy52YWx1ZSkgP1xuICAgICAgICAgICAgICAgICAgICAoMCwgbWF5YmVfMS5qdXN0KShwYXJzZURhdGUoZ2V0VmFsdWUodGhpcy5hdHRycyksIGdldEZvcm1hdCh0aGlzLmF0dHJzKSkpIDpcbiAgICAgICAgICAgICAgICAgICAgKDAsIG1heWJlXzEubm90aGluZykoKSksXG4gICAgICAgICAgICAgICAgdmFsdWU6ICgpID0+ICh0aGlzLnZhbHVlcy5pbnB1dC5tb21lbnQuaXNKdXN0KCkgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZXMuaW5wdXQubW9tZW50LmdldCgpLmlzVmFsaWQoKSkgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcy5pbnB1dC5tb21lbnQuZ2V0KCkuZm9ybWF0KHRoaXMudmFsdWVzLmlucHV0LmRpc3BsYXkpIDogJycsXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuZGlzYWJsZWQgPT09IHRydWUpID9cbiAgICAgICAgICAgICAgICAgICAgdHJ1ZSA6IG51bGwsXG4gICAgICAgICAgICAgICAgb25mb2N1czogKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZS50YXJnZXQuc2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbmlucHV0OiAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlLnRhcmdldC5vbmlucHV0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZXMuaW5wdXQub25rZXl1cChlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9ua2V5dXA6ICgwLCB1dGlsXzEuZGVib3VuY2UpKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGUudGFyZ2V0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcy5pbnB1dC5tb21lbnQgPSAoMCwgbWF5YmVfMS5ub3RoaW5nKSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlQ2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbSA9IHBhcnNlRGF0ZSh2YWx1ZSwgdGhpcy52YWx1ZXMuaW5wdXQuZm9ybWF0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzLmlucHV0Lm1vbWVudCA9ICgwLCBtYXliZV8xLmp1c3QpKG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZUNoYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgZXhwb3J0cy5ERUxBWSksXG4gICAgICAgICAgICAgICAgb25ibHVyOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlldy5pbnZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZpcmVDaGFuZ2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMub25DaGFuZ2UpIHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gdGhpcy5hdHRycy5uYW1lIHx8ICcnO1xuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWVzLmlucHV0Lm1vbWVudC5pc0p1c3QoKSkge1xuICAgICAgICAgICAgICAgIGxldCBtID0gdGhpcy52YWx1ZXMuaW5wdXQubW9tZW50LmdldCgpO1xuICAgICAgICAgICAgICAgIGlmIChtLmlzVmFsaWQoKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5vbkNoYW5nZShuZXcgRGF0ZUNoYW5nZWRFdmVudChuYW1lLCBtLmZvcm1hdChleHBvcnRzLlZBTFVFX0ZPUk1BVCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMub25DaGFuZ2UobmV3IERhdGVDaGFuZ2VkRXZlbnQobmFtZSwgdW5kZWZpbmVkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0TWVzc2FnZShtc2cpIHtcbiAgICAgICAgdGhpcy52YWx1ZXMubWVzc2FnZXMudGV4dCA9IG1zZztcbiAgICAgICAgKDAsIGZvcm1fMS5zZXRNZXNzYWdlKSh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLm1lc3NhZ2VzLndtbC5pZCwgbXNnKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlbW92ZU1lc3NhZ2UoKSB7XG4gICAgICAgIHRoaXMudmFsdWVzLm1lc3NhZ2VzLnRleHQgPSAnJztcbiAgICAgICAgKDAsIGZvcm1fMS5yZW1vdmVNZXNzYWdlKSh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLm1lc3NhZ2VzLndtbC5pZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmV4cG9ydHMuRGF0ZUZpZWxkID0gRGF0ZUZpZWxkO1xuY29uc3QgcGFyc2VEYXRlID0gKGQsIGZvcm1hdHMpID0+IHtcbiAgICBsZXQgc3RyID0gZC50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICgoc3RyID09PSBleHBvcnRzLlRPREFZKSB8fCAoc3RyID09PSBleHBvcnRzLk5PVykpIHtcbiAgICAgICAgcmV0dXJuIG1vbWVudC51dGMoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RyID09PSBleHBvcnRzLllFU1RFUkRBWSkge1xuICAgICAgICByZXR1cm4gbW9tZW50LnV0YygpLnN1YnRyYWN0KDEsICdkJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbW9tZW50LnV0YyhkLCBbLi4uZm9ybWF0cywgbW9tZW50LklTT184NjAxXSwgdHJ1ZSk7XG4gICAgfVxufTtcbmNvbnN0IGdldFZhbHVlID0gKGF0dHJzKSA9PiAoYXR0cnMgJiYgYXR0cnMudmFsdWUpID8gYXR0cnMudmFsdWUgOiAnJztcbmNvbnN0IGdldEZvcm1hdCA9IChhdHRycykgPT4ge1xuICAgIGlmIChhdHRycyAmJiBhdHRycy5mb3JtYXQpIHtcbiAgICAgICAgc3dpdGNoIChhdHRycy5mb3JtYXQpIHtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5jb21tb25Gb3JtYXRzO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJldHVybiBleHBvcnRzLnVzRm9ybWF0cztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV4cG9ydHMuaXNvODYwMUZvcm1hdHM7XG59O1xuY29uc3QgZ2V0UGxhY2Vob2xkZXIgPSAoYXR0cnMpID0+IHtcbiAgICBpZiAoYXR0cnMgJiYgYXR0cnMucGxhY2Vob2xkZXIpXG4gICAgICAgIHJldHVybiBhdHRycy5wbGFjZWhvbGRlcjtcbiAgICBpZiAoYXR0cnMgJiYgYXR0cnMuZm9ybWF0KSB7XG4gICAgICAgIHN3aXRjaCAoYXR0cnMuZm9ybWF0KSB7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdERC1NTS1ZWVlZJztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ01NLURELVlZWVknO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1lZWVktTU0tREQnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnWVlZWS1NTS1ERCc7XG59O1xuY29uc3QgZ2V0RGlzcGxheSA9IChhdHRycykgPT4gKGF0dHJzICYmIGF0dHJzLmRpc3BsYXkpID8gYXR0cnMuZGlzcGxheSA6IGV4cG9ydHMuREVGQVVMVF9JTlBVVF9ESVNQTEFZO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1haW4gPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbmNvbnN0IGxhYmVsXzEgPSByZXF1aXJlKFwiLi4vLi4vbGFiZWxcIik7XG47XG5jb25zdCBoZWxwXzEgPSByZXF1aXJlKFwiLi4vLi4vaGVscFwiKTtcbjtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnZGl2JywgeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMucm9vdC5jbGFzc05hbWUgfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGxhYmVsXzEuTGFiZWwoeyAnZm9yJzogX19jb250ZXh0LnZhbHVlcy5yb290LmlkLCAndGV4dCc6IF9fY29udGV4dC52YWx1ZXMubGFiZWwudGV4dCB9LCBbXSksIHsgJ2Zvcic6IF9fY29udGV4dC52YWx1ZXMucm9vdC5pZCwgJ3RleHQnOiBfX2NvbnRleHQudmFsdWVzLmxhYmVsLnRleHQgfSksXG4gICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2lucHV0JywgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pbnB1dC53bWwuaWQgfSwgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLmlucHV0LndtbC5pZCwgJ29uZm9jdXMnOiBfX2NvbnRleHQudmFsdWVzLmlucHV0Lm9uZm9jdXMsICdvbmlucHV0JzogX19jb250ZXh0LnZhbHVlcy5pbnB1dC5vbmlucHV0LCAnb25rZXl1cCc6IF9fY29udGV4dC52YWx1ZXMuaW5wdXQub25rZXl1cCwgJ29uYmx1cic6IF9fY29udGV4dC52YWx1ZXMuaW5wdXQub25ibHVyLCAndmFsdWUnOiBfX2NvbnRleHQudmFsdWVzLmlucHV0LnZhbHVlKCksICdkaXNhYmxlZCc6IF9fY29udGV4dC52YWx1ZXMuaW5wdXQuZGlzYWJsZWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuaW5wdXQuY2xhc3NOYW1lLCAncGxhY2Vob2xkZXInOiBfX2NvbnRleHQudmFsdWVzLmlucHV0LnBsYWNlaG9sZGVyIH0sIFtdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBoZWxwXzEuSGVscCh7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLm1lc3NhZ2VzLndtbC5pZCB9LCAndGV4dCc6IF9fY29udGV4dC52YWx1ZXMubWVzc2FnZXMudGV4dCB9LCBbXSksIHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMubWVzc2FnZXMud21sLmlkIH0sICd0ZXh0JzogX19jb250ZXh0LnZhbHVlcy5tZXNzYWdlcy50ZXh0IH0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRlLWZpZWxkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EaXNwbGF5RmllbGQgPSBleHBvcnRzLkRJU1BMQVlfRklFTERfQ09OVEVOVCA9IGV4cG9ydHMuRElTUExBWV9GSUVMRCA9IGV4cG9ydHMuU3R5bGUgPSB2b2lkIDA7XG5jb25zdCB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xuY29uc3QgdG9vbGJhcl8xID0gcmVxdWlyZShcIi4uL3Rvb2xiYXJcIik7XG5jb25zdCBvcmllbnRhdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRlbnQvb3JpZW50YXRpb25cIik7XG5jb25zdCBkaXNhYmxlZF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRlbnQvc3RhdGUvZGlzYWJsZWRcIik7XG5jb25zdCBzdHlsZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRlbnQvc3R5bGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTdHlsZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3R5bGVfMS5TdHlsZTsgfSB9KTtcbmNvbnN0IHNpemVfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZW50L3NpemVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbmNvbnN0IF9fMSA9IHJlcXVpcmUoXCIuLi8uLi9cIik7XG5jb25zdCBkaXNwbGF5X2ZpZWxkXzEgPSByZXF1aXJlKFwiLi93bWwvZGlzcGxheS1maWVsZFwiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuRElTUExBWV9GSUVMRCA9ICd3dy1kaXNwbGF5LWZpZWxkJztcbmV4cG9ydHMuRElTUExBWV9GSUVMRF9DT05URU5UID0gJ3d3LWRpc3BsYXktZmllbGRfX2NvbnRlbnQnO1xuO1xuLyoqXG4gKiBEaXNwbGF5RmllbGQgaXMgdXNlZCB0byBkaXNwbGF5IGEgdmFsdWUgaW4gYSB0ZXh0IGZpZWxkIGxpa2UgYm94LlxuICovXG5jbGFzcyBEaXNwbGF5RmllbGQgZXh0ZW5kcyB3bWxfMS5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgZGlzcGxheV9maWVsZF8xLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdkaXNwbGF5J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlkOiAoMCwgX18xLmdldElkKSh0aGlzLmF0dHJzKSxcbiAgICAgICAgICAgIGRpc2FibGVkOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmRpc2FibGVkKSA/XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRycy5kaXNhYmxlZCA6IGZhbHNlLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAoMCwgdXRpbF8xLmNvbmNhdCkoZXhwb3J0cy5ESVNQTEFZX0ZJRUxELCAoMCwgX18xLmdldENsYXNzTmFtZSkodGhpcy5hdHRycyksIHRvb2xiYXJfMS5UT09MQkFSX0NPTVBBVCwgKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5zdHlsZSkgP1xuICAgICAgICAgICAgICAgICgwLCBzdHlsZV8xLmdldFN0eWxlQ2xhc3NOYW1lKSh0aGlzLmF0dHJzLnN0eWxlKSA6XG4gICAgICAgICAgICAgICAgc3R5bGVfMS5ERUZBVUxULCAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLnNpemUpID9cbiAgICAgICAgICAgICAgICAoMCwgc2l6ZV8xLmdldFNpemVDbGFzc05hbWUpKHRoaXMuYXR0cnMuc2l6ZSkgOiAnJywgKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5ibG9jaykgP1xuICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uXzEuQkxPQ0sgOiAnJywgKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5kaXNhYmxlZCkgP1xuICAgICAgICAgICAgICAgIGRpc2FibGVkXzEuRElTQUJMRUQgOiAnJyksXG4gICAgICAgICAgICBvbmNsaWNrOiAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7IC8vcHJldmVudCBhIGJ1ZyB3aGVuIHVzZWQgd2l0aCBSZXN1bHRzTWVudVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJzICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMub25DbGljayAmJlxuICAgICAgICAgICAgICAgICAgICAoIXRoaXMudmFsdWVzLmRpc2FibGVkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5vbkNsaWNrKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogZXhwb3J0cy5ESVNQTEFZX0ZJRUxEX0NPTlRFTlRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkRpc3BsYXlGaWVsZCA9IERpc3BsYXlGaWVsZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYWluID0gdm9pZCAwO1xuY29uc3QgX19kb2N1bWVudCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbmNvbnN0IG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ2RpdicsIHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jbGFzc05hbWUsICdvbmNsaWNrJzogX19jb250ZXh0LnZhbHVlcy5vbmNsaWNrIH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnZGl2JywgeyAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmNvbnRlbnQuY2xhc3NOYW1lIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgLi4uKF9fY29udGV4dC5jaGlsZHJlbilcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlzcGxheS1maWVsZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRHJvcERvd24gPSBleHBvcnRzLkRST1BfRE9XTl9DT05URU5UID0gZXhwb3J0cy5EUk9QX0RPV05fVE9HR0xFID0gZXhwb3J0cy5EUk9QX0RPV04gPSB2b2lkIDA7XG5jb25zdCB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9kcm9wLWRvd25cIik7XG5jb25zdCBoaWRkZW4gPSByZXF1aXJlKFwiLi4vLi4vY29udGVudC9zdGF0ZS9oaWRkZW5cIik7XG5jb25zdCBzdHlsZSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZW50L3N0eWxlXCIpO1xuY29uc3Qgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbmNvbnN0IGJ1dHRvbl9ncm91cF8xID0gcmVxdWlyZShcIi4uL2J1dHRvbi1ncm91cFwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xuY29uc3QgX18xID0gcmVxdWlyZShcIi4uLy4uL1wiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuRFJPUF9ET1dOID0gJ3d3LWRyb3AtZG93bi1tZW51JztcbmV4cG9ydHMuRFJPUF9ET1dOX1RPR0dMRSA9ICd3dy1kcm9wLWRvd24tbWVudV9fdG9nZ2xlJztcbmV4cG9ydHMuRFJPUF9ET1dOX0NPTlRFTlQgPSAnd3ctZHJvcC1kb3duX19jb250ZW50Jztcbi8qKlxuICogRHJvcERvd24gcHJvdmlkZXMgYSBjb21wb25lbnQgZm9yIGRpc3BsYXlpbmcgYSBwb3AgdXAgbWVudS5cbiAqXG4gKiAgICArLS0tLS0tLS0rXG4gKiAgICB8ICBNZW51ICB8XG4gKiAgICArLS0tLS0tLS0rXG4gKiAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAqICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogICAgfCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8XG4gKiAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgIHwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfFxuICogICAgfCAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgICB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHxcbiAqICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gKi9cbmNsYXNzIERyb3BEb3duIGV4dGVuZHMgd21sXzEuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ3Jvb3QnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpZDogKDAsIF9fMS5nZXRJZCkodGhpcy5hdHRycyksXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAoMCwgdXRpbF8xLmNvbmNhdCkoZXhwb3J0cy5EUk9QX0RPV04sIGJ1dHRvbl9ncm91cF8xLkJVVFRPTl9HUk9VUF9DT01QQVQsICgwLCBfXzEuZ2V0Q2xhc3NOYW1lKSh0aGlzLmF0dHJzKSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBidXR0b246IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmJ1dHRvblRleHQpID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5idXR0b25UZXh0IDogJycsXG4gICAgICAgICAgICAgICAgYW5jaG9yOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmFuY2hvcikgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLmFuY2hvciA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogKDAsIHV0aWxfMS5jb25jYXQpKGV4cG9ydHMuRFJPUF9ET1dOX1RPR0dMRSwgc3R5bGUuREVGQVVMVCwgKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5idXR0b25DbGFzc05hbWUpID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5idXR0b25DbGFzc05hbWUgOiAnJyksXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuZGlzYWJsZWQpID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5kaXNhYmxlZCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogKCkgPT4gKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5idXR0b25UZW1wbGF0ZSkgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLmJ1dHRvblRlbXBsYXRlKHRoaXMpIDogbmV3IHZpZXdzLkJ1dHRvblZpZXcodGhpcyksXG4gICAgICAgICAgICAgICAgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWF5Um9vdCA9ICgwLCB1dGlsXzEuZ2V0QnlJZCkodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5yb290LndtbC5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXlSb290LmlzSnVzdCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZSA9IG1heVJvb3QuZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZXMuY29udGVudC5hdXRvQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaGlkZSA9IHRoaXMudmFsdWVzLmNvbnRlbnQuaGlkZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ludGVyY2VwdCBjbGlja3Mgb24gYnV0dG9uIGFuZCBjb250ZW50IHNlY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBkb3VibGluZyB1cCBoYW5kbGVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5jaGlsZHJlbltpXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGlkZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuY2hpbGRyZW5baV0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvZ2dsZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ2NvbnRlbnQnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLkRST1BfRE9XTl9DT05URU5ULCBoaWRkZW4uSElEREVOKSxcbiAgICAgICAgICAgICAgICBhdXRvQ2xvc2U6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuYXV0b0Nsb3NlID09PSBmYWxzZSkgP1xuICAgICAgICAgICAgICAgICAgICBmYWxzZSA6IHRydWUsXG4gICAgICAgICAgICAgICAgcmVuZGVyOiAoKSA9PiB0aGlzLmNoaWxkcmVuLFxuICAgICAgICAgICAgICAgIGhpZGU6ICgpID0+IHRoaXMuaGlkZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlzSGlkZGVuKCkge1xuICAgICAgICByZXR1cm4gaGlkZGVuLmlzSGlkZGVuKHRoaXMudmlldywgdGhpcy52YWx1ZXMuY29udGVudC53bWwuaWQpO1xuICAgIH1cbiAgICBoaWRlKCkge1xuICAgICAgICBoaWRkZW4uaGlkZSh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLmNvbnRlbnQud21sLmlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNob3coKSB7XG4gICAgICAgIGhpZGRlbi5zaG93KHRoaXMudmlldywgdGhpcy52YWx1ZXMuY29udGVudC53bWwuaWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9nZ2xlKCkge1xuICAgICAgICBoaWRkZW4udG9nZ2xlKHRoaXMudmlldywgdGhpcy52YWx1ZXMuY29udGVudC53bWwuaWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaGFuZGxlRXZlbnQoZSkge1xuICAgICAgICAoMCwgdXRpbF8xLmdldEJ5SWQpKHRoaXMudmlldywgdGhpcy52YWx1ZXMucm9vdC53bWwuaWQpXG4gICAgICAgICAgICAubWFwKChyb290KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWRvY3VtZW50LmJvZHkuY29udGFpbnMocm9vdCkpXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzKTtcbiAgICAgICAgICAgIGlmICgoIXJvb3QuY29udGFpbnMoZS50YXJnZXQpKSlcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ecm9wRG93biA9IERyb3BEb3duO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1haW4gPSBleHBvcnRzLkJ1dHRvblZpZXcgPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbmNvbnN0IGJ1dHRvbl8xID0gcmVxdWlyZShcIi4uLy4uL2J1dHRvblwiKTtcbjtcbmNvbnN0IGNhcmV0XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY29udGVudC9jYXJldFwiKTtcbjtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBCdXR0b25WaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KG5ldyBidXR0b25fMS5CdXR0b24oeyAnY2xhc3NOYW1lJzogX19jb250ZXh0LnZhbHVlcy5idXR0b24uY2xhc3NOYW1lLCAnYW5jaG9yJzogX19jb250ZXh0LnZhbHVlcy5idXR0b24uYW5jaG9yLCAnZGlzYWJsZWQnOiBfX2NvbnRleHQudmFsdWVzLmJ1dHRvbi5kaXNhYmxlZCwgJ29uQ2xpY2snOiBfX2NvbnRleHQudmFsdWVzLmJ1dHRvbi5vbkNsaWNrIH0sIFtcbiAgICAgICAgICAgICAgICB0ZXh0KChfX2NvbnRleHQudmFsdWVzLmJ1dHRvbi50ZXh0ICsgJyAnKSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgY2FyZXRfMS5DYXJldCh7fSwgW10pLCB7fSlcbiAgICAgICAgICAgIF0pLCB7ICdjbGFzc05hbWUnOiBfX2NvbnRleHQudmFsdWVzLmJ1dHRvbi5jbGFzc05hbWUsICdhbmNob3InOiBfX2NvbnRleHQudmFsdWVzLmJ1dHRvbi5hbmNob3IsICdkaXNhYmxlZCc6IF9fY29udGV4dC52YWx1ZXMuYnV0dG9uLmRpc2FibGVkLCAnb25DbGljayc6IF9fY29udGV4dC52YWx1ZXMuYnV0dG9uLm9uQ2xpY2sgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLkJ1dHRvblZpZXcgPSBCdXR0b25WaWV3O1xuO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ2RpdicsIHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMucm9vdC53bWwuaWQgfSwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5yb290LmNsYXNzTmFtZSB9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLnJlZ2lzdGVyVmlldyhfX2NvbnRleHQudmFsdWVzLmJ1dHRvbi50ZW1wbGF0ZSgpKS5yZW5kZXIoKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnZGl2JywgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5jb250ZW50LndtbC5pZCB9LCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmNvbnRlbnQuY2xhc3NOYW1lIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgLi4uKF9fY29udGV4dC52YWx1ZXMuY29udGVudC5yZW5kZXIoKSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZHJvcC1kb3duLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ecm9wTGlzdEZpZWxkID0gZXhwb3J0cy5EUk9QX0xJU1RfRklFTEQgPSBleHBvcnRzLkl0ZW1DaGFuZ2VkRXZlbnQgPSB2b2lkIDA7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbmNvbnN0IGZlZWRiYWNrXzEgPSByZXF1aXJlKFwiLi4vZmVlZGJhY2tcIik7XG5jb25zdCBzZWxlY3RfMSA9IHJlcXVpcmUoXCIuLi9zZWxlY3RcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJdGVtQ2hhbmdlZEV2ZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxlY3RfMS5JdGVtQ2hhbmdlZEV2ZW50OyB9IH0pO1xuY29uc3QgZm9ybV8xID0gcmVxdWlyZShcIi4uL2Zvcm1cIik7XG5jb25zdCBfXzEgPSByZXF1aXJlKFwiLi4vLi4vXCIpO1xuY29uc3QgX18yID0gcmVxdWlyZShcIi4uL1wiKTtcbmNvbnN0IGRyb3BfbGlzdF9maWVsZF8xID0gcmVxdWlyZShcIi4vd21sL2Ryb3AtbGlzdC1maWVsZFwiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuRFJPUF9MSVNUX0ZJRUxEID0gJ3d3LWRyb3AtbGlzdC1maWVsZCc7XG4vKipcbiAqIERyb3BMaXN0RmllbGRcbiAqL1xuY2xhc3MgRHJvcExpc3RGaWVsZCBleHRlbmRzIGZvcm1fMS5BYnN0cmFjdEZvcm1Db250cm9sIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IGRyb3BfbGlzdF9maWVsZF8xLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ3Jvb3QnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpZDogKDAsIF9fMS5nZXRJZCkodGhpcy5hdHRycyksXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAoMCwgdXRpbF8xLmNvbmNhdCkoZXhwb3J0cy5EUk9QX0xJU1RfRklFTEQsICgwLCBfXzEuZ2V0Q2xhc3NOYW1lKSh0aGlzLmF0dHJzKSwgKDAsIGZlZWRiYWNrXzEuZ2V0VmFsaWRpdHlDbGFzc05hbWUpKHRoaXMuYXR0cnMpKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAnbWVzc2FnZSdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRleHQ6ICgwLCBmZWVkYmFja18xLmdldE1lc3NhZ2UpKHRoaXMuYXR0cnMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgICAgICBpZDogKDAsIF9fMi5nZXROYW1lKSh0aGlzLmF0dHJzKSxcbiAgICAgICAgICAgICAgICB0ZXh0OiAoMCwgZm9ybV8xLmdldExhYmVsKSh0aGlzLmF0dHJzKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnRyb2w6IHtcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdjb250cm9sJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbmFtZTogKDAsIF9fMi5nZXROYW1lKSh0aGlzLmF0dHJzKSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICgwLCBmZWVkYmFja18xLmdldFZhbGlkaXR5Q2xhc3NOYW1lKSh0aGlzLmF0dHJzKSxcbiAgICAgICAgICAgICAgICBibG9jazogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5wbGFjZWhvbGRlciksXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuZGlzYWJsZWQpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLnZhbHVlKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLm9wdGlvbnMpID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5vcHRpb25zIDogW10sXG4gICAgICAgICAgICAgICAgc3RyaW5naWZpZXI6IHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5zdHJpbmdpZmllcixcbiAgICAgICAgICAgICAgICBpdGVtVGVtcGxhdGU6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuaXRlbVRlbXBsYXRlKSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMuaXRlbVRlbXBsYXRlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG5vSXRlbXNUZW1wbGF0ZTogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5ub0l0ZW1zVGVtcGxhdGUpID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5ub0l0ZW1zVGVtcGxhdGUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgb25TZWxlY3Q6IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMub25DaGFuZ2UpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLm9uQ2hhbmdlKG5ldyBzZWxlY3RfMS5JdGVtQ2hhbmdlZEV2ZW50KGUubmFtZSwgZS52YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHNldE1lc3NhZ2UobXNnKSB7XG4gICAgICAgIGdldEhlbHAodGhpcykubWFwKGggPT4gaC5zZXRNZXNzYWdlKG1zZykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVtb3ZlTWVzc2FnZSgpIHtcbiAgICAgICAgZ2V0SGVscCh0aGlzKS5tYXAoaCA9PiBoLnJlbW92ZU1lc3NhZ2UoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmV4cG9ydHMuRHJvcExpc3RGaWVsZCA9IERyb3BMaXN0RmllbGQ7XG5jb25zdCBnZXRIZWxwID0gKHQpID0+ICgwLCB1dGlsXzEuZ2V0QnlJZCkodC52aWV3LCB0LnZhbHVlcy5tZXNzYWdlcy53bWwuaWQpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1haW4gPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbmNvbnN0IGxhYmVsXzEgPSByZXF1aXJlKFwiLi4vLi4vbGFiZWxcIik7XG47XG5jb25zdCBoZWxwXzEgPSByZXF1aXJlKFwiLi4vLi4vaGVscFwiKTtcbjtcbmNvbnN0IGRyb3BfbGlzdF8xID0gcmVxdWlyZShcIi4uLy4uL2Ryb3AtbGlzdFwiKTtcbjtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnZGl2JywgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5yb290LndtbC5pZCB9LCAnaWQnOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMucm9vdC5jbGFzc05hbWUgfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGxhYmVsXzEuTGFiZWwoeyAnZm9yJzogX19jb250ZXh0LnZhbHVlcy5yb290LmlkLCAndGV4dCc6IF9fY29udGV4dC52YWx1ZXMubGFiZWwudGV4dCB9LCBbXSksIHsgJ2Zvcic6IF9fY29udGV4dC52YWx1ZXMucm9vdC5pZCwgJ3RleHQnOiBfX2NvbnRleHQudmFsdWVzLmxhYmVsLnRleHQgfSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZHJvcF9saXN0XzEuRHJvcExpc3QoeyAnY2xhc3NOYW1lJzogX19jb250ZXh0LnZhbHVlcy5jb250cm9sLmNsYXNzTmFtZSwgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLmNvbnRyb2wubmFtZSwgJ3BsYWNlaG9sZGVyJzogX19jb250ZXh0LnZhbHVlcy5jb250cm9sLnBsYWNlaG9sZGVyLCAnZGlzYWJsZWQnOiBfX2NvbnRleHQudmFsdWVzLmNvbnRyb2wuZGlzYWJsZWQsICdibG9jayc6IF9fY29udGV4dC52YWx1ZXMuY29udHJvbC5ibG9jaywgJ3ZhbHVlJzogX19jb250ZXh0LnZhbHVlcy5jb250cm9sLnZhbHVlLCAnb3B0aW9ucyc6IF9fY29udGV4dC52YWx1ZXMuY29udHJvbC5vcHRpb25zLCAnb25TZWxlY3QnOiBfX2NvbnRleHQudmFsdWVzLmNvbnRyb2wub25TZWxlY3QsICdub0l0ZW1zVGVtcGxhdGUnOiBfX2NvbnRleHQudmFsdWVzLmNvbnRyb2wubm9JdGVtc1RlbXBsYXRlLCAnaXRlbVRlbXBsYXRlJzogX19jb250ZXh0LnZhbHVlcy5jb250cm9sLml0ZW1UZW1wbGF0ZSwgJ3N0cmluZ2lmaWVyJzogX19jb250ZXh0LnZhbHVlcy5jb250cm9sLnN0cmluZ2lmaWVyIH0sIFtdKSwgeyAnY2xhc3NOYW1lJzogX19jb250ZXh0LnZhbHVlcy5jb250cm9sLmNsYXNzTmFtZSwgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLmNvbnRyb2wubmFtZSwgJ3BsYWNlaG9sZGVyJzogX19jb250ZXh0LnZhbHVlcy5jb250cm9sLnBsYWNlaG9sZGVyLCAnZGlzYWJsZWQnOiBfX2NvbnRleHQudmFsdWVzLmNvbnRyb2wuZGlzYWJsZWQsICdibG9jayc6IF9fY29udGV4dC52YWx1ZXMuY29udHJvbC5ibG9jaywgJ3ZhbHVlJzogX19jb250ZXh0LnZhbHVlcy5jb250cm9sLnZhbHVlLCAnb3B0aW9ucyc6IF9fY29udGV4dC52YWx1ZXMuY29udHJvbC5vcHRpb25zLCAnb25TZWxlY3QnOiBfX2NvbnRleHQudmFsdWVzLmNvbnRyb2wub25TZWxlY3QsICdub0l0ZW1zVGVtcGxhdGUnOiBfX2NvbnRleHQudmFsdWVzLmNvbnRyb2wubm9JdGVtc1RlbXBsYXRlLCAnaXRlbVRlbXBsYXRlJzogX19jb250ZXh0LnZhbHVlcy5jb250cm9sLml0ZW1UZW1wbGF0ZSwgJ3N0cmluZ2lmaWVyJzogX19jb250ZXh0LnZhbHVlcy5jb250cm9sLnN0cmluZ2lmaWVyIH0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGhlbHBfMS5IZWxwKHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMubWVzc2FnZXMud21sLmlkIH0sICd0ZXh0JzogX19jb250ZXh0LnZhbHVlcy5tZXNzYWdlcy50ZXh0IH0sIFtdKSwgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5tZXNzYWdlcy53bWwuaWQgfSwgJ3RleHQnOiBfX2NvbnRleHQudmFsdWVzLm1lc3NhZ2VzLnRleHQgfSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRyb3AtbGlzdC1maWVsZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRHJvcExpc3QgPSBleHBvcnRzLkRST1BfTElTVCA9IGV4cG9ydHMuSXRlbVNlbGVjdGVkRXZlbnQgPSB2b2lkIDA7XG5jb25zdCB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9kcm9wLWxpc3RcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbmNvbnN0IHNpemVfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZW50L3NpemVcIik7XG5jb25zdCBvcmllbnRhdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRlbnQvb3JpZW50YXRpb25cIik7XG5jb25zdCByZXN1bHRzX21lbnVfMSA9IHJlcXVpcmUoXCIuLi9yZXN1bHRzLW1lbnVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJdGVtU2VsZWN0ZWRFdmVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzdWx0c19tZW51XzEuSXRlbVNlbGVjdGVkRXZlbnQ7IH0gfSk7XG5jb25zdCBzZWFyY2hfMSA9IHJlcXVpcmUoXCIuLi9zZWFyY2hcIik7XG5jb25zdCBfXzEgPSByZXF1aXJlKFwiLi4vLi4vXCIpO1xuY29uc3QgX18yID0gcmVxdWlyZShcIi4uL1wiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuRFJPUF9MSVNUID0gJ3d3LWRyb3AtbGlzdCc7XG4vKipcbiAqIERyb3BMaXN0IHByb3ZpZGVzIGEgY29udHJvbCBmb3IgbWFraW5nIGEgc2VsZWN0aW9uIGZyb20gYSBsaXN0IG9mIGNob2ljZXMuXG4gKi9cbmNsYXNzIERyb3BMaXN0IGV4dGVuZHMgX18yLkFic3RyYWN0Q29udHJvbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiAoMCwgX18xLmdldElkKSh0aGlzLmF0dHJzKSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogKDAsIHV0aWxfMS5jb25jYXQpKGV4cG9ydHMuRFJPUF9MSVNULCAoMCwgX18xLmdldENsYXNzTmFtZSkodGhpcy5hdHRycyksICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuc2l6ZSkgP1xuICAgICAgICAgICAgICAgICgwLCBzaXplXzEuZ2V0U2l6ZUNsYXNzTmFtZSkodGhpcy5hdHRycy5zaXplKSA6ICcnLCAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmJsb2NrKSA/XG4gICAgICAgICAgICAgICAgb3JpZW50YXRpb25fMS5CTE9DSyA6ICcnKSxcbiAgICAgICAgICAgIG5hbWU6ICgwLCBfXzIuZ2V0TmFtZSkodGhpcy5hdHRycyksXG4gICAgICAgICAgICB2YWx1ZTogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy52YWx1ZSksXG4gICAgICAgICAgICBjb250cm9sOiB7XG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAnZHJvcC1saXN0J1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZXNzYWdlczoge1xuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ21lc3NhZ2VzJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXNwbGF5OiB7XG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuZGlzYWJsZWQpLFxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdHRycy5vcHRpb25zICYmIHRoaXMudmFsdWVzLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRDdXJyZW50KHRoaXMuYXR0cnMub3B0aW9ucywgdGhpcy52YWx1ZXMudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cnMucGxhY2Vob2xkZXIgfHwgJ1NlbGVjdCBvbmUnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lbnU6IHtcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdtZW51J1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbmFtZTogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5uYW1lKSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMubmFtZSA6ICcnLFxuICAgICAgICAgICAgICAgIGJsb2NrOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmJsb2NrKSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMuYmxvY2sgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBoaWRkZW46IHRydWUsXG4gICAgICAgICAgICAgICAgcmVzdWx0czogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5vcHRpb25zKSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMub3B0aW9ucyA6IFtdLFxuICAgICAgICAgICAgICAgIG9uU2VsZWN0OiAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLm9uU2VsZWN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5vblNlbGVjdChuZXcgcmVzdWx0c19tZW51XzEuSXRlbVNlbGVjdGVkRXZlbnQoZS5uYW1lLCBlLnZhbHVlLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzLnZhbHVlID0gZS52YWx1ZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3LmludmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGl0ZW1UZW1wbGF0ZTogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5pdGVtVGVtcGxhdGUpID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5pdGVtVGVtcGxhdGUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbm9JdGVtc1RlbXBsYXRlOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLm5vSXRlbXNUZW1wbGF0ZSkgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLm5vSXRlbXNUZW1wbGF0ZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBzdHJpbmdpZmllcjogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5zdHJpbmdpZmllcikgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLnN0cmluZ2lmaWVyIDogKHYpID0+IHYubGFiZWxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdXBkYXRlIGNoYW5nZXMgdGhlIG9wdGlvbnMgYXZhaWxhYmxlIGluIHRoZSBsaXN0LlxuICAgICAqXG4gICAgICogVGhlIHZpZXcgd2lsbCBiZSBpbnZhbGlkYXRlZC5cbiAgICAgKi9cbiAgICB1cGRhdGUob3B0aW9ucykge1xuICAgICAgICB0aGlzLnZhbHVlcy5tZW51LnJlc3VsdHMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnZpZXcuaW52YWxpZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogb3BlbiB0aGUgcmVzdWx0cyBtZW51LlxuICAgICAqL1xuICAgIG9wZW4oKSB7XG4gICAgICAgICgwLCBzZWFyY2hfMS5vcGVuTWVudSkodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5tZW51LndtbC5pZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjbG9zZSB0aGUgcmVzdWx0cyBtZW51LlxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICAoMCwgc2VhcmNoXzEuY2xvc2VNZW51KSh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLm1lbnUud21sLmlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRvZ2dsZSB0aGUgcmVzdWx0cyBtZW51LlxuICAgICAqL1xuICAgIHRvZ2dsZSgpIHtcbiAgICAgICAgKDAsIHNlYXJjaF8xLnRvZ2dsZU1lbnUpKHRoaXMudmlldywgdGhpcy52YWx1ZXMubWVudS53bWwuaWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLkRyb3BMaXN0ID0gRHJvcExpc3Q7XG5jb25zdCBnZXRDdXJyZW50ID0gKG9wdHMsIHZhbHVlLCB0ZXh0ID0gJ1NlbGVjdCBvbmUnKSA9PiBvcHRzLnJlZHVjZSgocCwgYykgPT4gYy52YWx1ZSA9PT0gdmFsdWUgPyBjLmxhYmVsIDogcCwgdGV4dCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWFpbiA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuY29uc3QgY2FyZXRfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb250ZW50L2NhcmV0XCIpO1xuO1xuY29uc3QgcmVzdWx0c19tZW51XzEgPSByZXF1aXJlKFwiLi4vLi4vcmVzdWx0cy1tZW51XCIpO1xuO1xuY29uc3QgZGlzcGxheV9maWVsZF8xID0gcmVxdWlyZShcIi4uLy4uL2Rpc3BsYXktZmllbGRcIik7XG47XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ2RpdicsIHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jbGFzc05hbWUgfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGRpc3BsYXlfZmllbGRfMS5EaXNwbGF5RmllbGQoeyAnb25DbGljayc6IF9fY29udGV4dC52YWx1ZXMuZGlzcGxheS5vbkNsaWNrLCAnZGlzYWJsZWQnOiBfX2NvbnRleHQudmFsdWVzLmRpc3BsYXkuZGlzYWJsZWQgfSwgW1xuICAgICAgICAgICAgICAgICAgICB0ZXh0KF9fY29udGV4dC52YWx1ZXMuZGlzcGxheS5wbGFjZWhvbGRlcigpKSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgY2FyZXRfMS5DYXJldCh7fSwgW10pLCB7fSlcbiAgICAgICAgICAgICAgICBdKSwgeyAnb25DbGljayc6IF9fY29udGV4dC52YWx1ZXMuZGlzcGxheS5vbkNsaWNrLCAnZGlzYWJsZWQnOiBfX2NvbnRleHQudmFsdWVzLmRpc3BsYXkuZGlzYWJsZWQgfSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgcmVzdWx0c19tZW51XzEuUmVzdWx0c01lbnUoeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5tZW51LndtbC5pZCB9LCAnYmxvY2snOiBfX2NvbnRleHQudmFsdWVzLm1lbnUuYmxvY2ssICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5tZW51Lm5hbWUsICdoaWRkZW4nOiBfX2NvbnRleHQudmFsdWVzLm1lbnUuaGlkZGVuLCAncmVzdWx0cyc6IF9fY29udGV4dC52YWx1ZXMubWVudS5yZXN1bHRzLCAnb25TZWxlY3QnOiBfX2NvbnRleHQudmFsdWVzLm1lbnUub25TZWxlY3QsICdub0l0ZW1zVGVtcGxhdGUnOiBfX2NvbnRleHQudmFsdWVzLm1lbnUubm9JdGVtc1RlbXBsYXRlLCAnaXRlbVRlbXBsYXRlJzogX19jb250ZXh0LnZhbHVlcy5tZW51Lml0ZW1UZW1wbGF0ZSwgJ3N0cmluZ2lmaWVyJzogX19jb250ZXh0LnZhbHVlcy5tZW51LnN0cmluZ2lmaWVyIH0sIFtdKSwgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5tZW51LndtbC5pZCB9LCAnYmxvY2snOiBfX2NvbnRleHQudmFsdWVzLm1lbnUuYmxvY2ssICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5tZW51Lm5hbWUsICdoaWRkZW4nOiBfX2NvbnRleHQudmFsdWVzLm1lbnUuaGlkZGVuLCAncmVzdWx0cyc6IF9fY29udGV4dC52YWx1ZXMubWVudS5yZXN1bHRzLCAnb25TZWxlY3QnOiBfX2NvbnRleHQudmFsdWVzLm1lbnUub25TZWxlY3QsICdub0l0ZW1zVGVtcGxhdGUnOiBfX2NvbnRleHQudmFsdWVzLm1lbnUubm9JdGVtc1RlbXBsYXRlLCAnaXRlbVRlbXBsYXRlJzogX19jb250ZXh0LnZhbHVlcy5tZW51Lml0ZW1UZW1wbGF0ZSwgJ3N0cmluZ2lmaWVyJzogX19jb250ZXh0LnZhbHVlcy5tZW51LnN0cmluZ2lmaWVyIH0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kcm9wLWxpc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRpb25TdGF0ZTJDbGFzc05hbWUgPSBleHBvcnRzLmdldE1lc3NhZ2UgPSBleHBvcnRzLmdldFZhbGlkaXR5Q2xhc3NOYW1lID0gZXhwb3J0cy5nZXRWYWxpZGF0aW9uU3RhdGUgPSBleHBvcnRzLnJlbW92ZVZhbGlkYXRpb25TdGF0ZSA9IGV4cG9ydHMuc2V0VmFsaWRhdGlvblN0YXRlID0gZXhwb3J0cy5yZW1vdmVNZXNzYWdlID0gZXhwb3J0cy5zZXRNZXNzYWdlID0gZXhwb3J0cy5BYnN0cmFjdEZlZWRiYWNrQ29udHJvbCA9IGV4cG9ydHMuVmFsaWRhdGlvblN0YXRlID0gdm9pZCAwO1xuY29uc3Qgc3R5bGUgPSByZXF1aXJlKFwiLi4vY29udGVudC9zdHlsZVwiKTtcbmNvbnN0IGRvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuY29uc3QgY29udHJvbF8xID0gcmVxdWlyZShcIi4uL2NvbnRyb2xcIik7XG4vKipcbiAqIFZhbGlkYXRpb25TdGF0ZVxuICovXG52YXIgVmFsaWRhdGlvblN0YXRlO1xuKGZ1bmN0aW9uIChWYWxpZGF0aW9uU3RhdGUpIHtcbiAgICBWYWxpZGF0aW9uU3RhdGVbXCJOZXV0cmFsXCJdID0gXCJuZXV0cmFsXCI7XG4gICAgVmFsaWRhdGlvblN0YXRlW1wiRXJyb3JcIl0gPSBcImVycm9yXCI7XG4gICAgVmFsaWRhdGlvblN0YXRlW1wiU3VjY2Vzc1wiXSA9IFwic3VjY2Vzc1wiO1xuICAgIFZhbGlkYXRpb25TdGF0ZVtcIldhcm5pbmdcIl0gPSBcIndhcm5pbmdcIjtcbn0pKFZhbGlkYXRpb25TdGF0ZSA9IGV4cG9ydHMuVmFsaWRhdGlvblN0YXRlIHx8IChleHBvcnRzLlZhbGlkYXRpb25TdGF0ZSA9IHt9KSk7XG4vKipcbiAqIEFic3RyYWN0RmVlZGJhY2tDb250cm9sXG4gKlxuICogUHJvdmlkZXMgYSBkZWZhdWx0IGltcGxlbWVudGFpb24gb2YgdGhlIGludGVyZmFjZSBtZXRob2RzLlxuICovXG5jbGFzcyBBYnN0cmFjdEZlZWRiYWNrQ29udHJvbCBleHRlbmRzIGNvbnRyb2xfMS5BYnN0cmFjdENvbnRyb2wge1xuICAgIHNldE1lc3NhZ2UobXNnKSB7XG4gICAgICAgICgwLCBleHBvcnRzLnNldE1lc3NhZ2UpKHRoaXMudmlldywgdGhpcy52YWx1ZXMubWVzc2FnZXMud21sLmlkLCBtc2cpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVtb3ZlTWVzc2FnZSgpIHtcbiAgICAgICAgKDAsIGV4cG9ydHMucmVtb3ZlTWVzc2FnZSkodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5tZXNzYWdlcy53bWwuaWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0VmFsaWRhdGlvblN0YXRlKHN0YXRlKSB7XG4gICAgICAgICgwLCBleHBvcnRzLnNldFZhbGlkYXRpb25TdGF0ZSkodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5jb250cm9sLndtbC5pZCwgc3RhdGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVtb3ZlVmFsaWRhdGlvblN0YXRlKCkge1xuICAgICAgICAoMCwgZXhwb3J0cy5yZW1vdmVWYWxpZGF0aW9uU3RhdGUpKHRoaXMudmlldywgdGhpcy52YWx1ZXMuY29udHJvbC53bWwuaWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0VmFsaWRhdGlvblN0YXRlKCkge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuZ2V0VmFsaWRhdGlvblN0YXRlKSh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLmNvbnRyb2wud21sLmlkKTtcbiAgICB9XG59XG5leHBvcnRzLkFic3RyYWN0RmVlZGJhY2tDb250cm9sID0gQWJzdHJhY3RGZWVkYmFja0NvbnRyb2w7XG4vKipcbiAqIHNldE1lc3NhZ2UgaGVscGVyLlxuICovXG5jb25zdCBzZXRNZXNzYWdlID0gKHZpZXcsIGlkLCBtc2cpID0+ICgwLCB1dGlsXzEuZ2V0QnlJZCkodmlldywgaWQpXG4gICAgLm1hcChtZXNzYWdlcyA9PiB7XG4gICAgbGV0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShtc2cpO1xuICAgIHdoaWxlIChtZXNzYWdlcy5sYXN0Q2hpbGQpXG4gICAgICAgIG1lc3NhZ2VzLnJlbW92ZUNoaWxkKG1lc3NhZ2VzLmxhc3RDaGlsZCk7XG4gICAgbWVzc2FnZXMuYXBwZW5kQ2hpbGQobm9kZSk7XG59KTtcbmV4cG9ydHMuc2V0TWVzc2FnZSA9IHNldE1lc3NhZ2U7XG4vKipcbiAqIHJlbW92ZU1lc3NhZ2VcbiAqL1xuY29uc3QgcmVtb3ZlTWVzc2FnZSA9ICh2aWV3LCBpZCkgPT4gKDAsIHV0aWxfMS5nZXRCeUlkKSh2aWV3LCBpZClcbiAgICAubWFwKG1lc3NhZ2VzID0+IHtcbiAgICB3aGlsZSAobWVzc2FnZXMubGFzdENoaWxkKVxuICAgICAgICBtZXNzYWdlcy5yZW1vdmVDaGlsZChtZXNzYWdlcy5sYXN0Q2hpbGQpO1xufSk7XG5leHBvcnRzLnJlbW92ZU1lc3NhZ2UgPSByZW1vdmVNZXNzYWdlO1xuLyoqXG4gKiBzZXRWYWxpZGF0aW9uU3RhdGUgaGVscGVyLlxuICovXG5jb25zdCBzZXRWYWxpZGF0aW9uU3RhdGUgPSAodmlldywgaWQsIHN0YXRlKSA9PiB7XG4gICAgKDAsIGV4cG9ydHMucmVtb3ZlVmFsaWRhdGlvblN0YXRlKSh2aWV3LCBpZCk7XG4gICAgaWYgKHN0YXRlICE9PSBWYWxpZGF0aW9uU3RhdGUuTmV1dHJhbClcbiAgICAgICAgKDAsIHV0aWxfMS5nZXRCeUlkKSh2aWV3LCBpZClcbiAgICAgICAgICAgIC5tYXAoZSA9PiBlLmNsYXNzTGlzdC5hZGQoKDAsIGV4cG9ydHMudmFsaWRhdGlvblN0YXRlMkNsYXNzTmFtZSkoc3RhdGUpKSk7XG59O1xuZXhwb3J0cy5zZXRWYWxpZGF0aW9uU3RhdGUgPSBzZXRWYWxpZGF0aW9uU3RhdGU7XG4vKipcbiAqIHJlbW92ZVZhbGlkYXRpb25TdGF0ZSBoZWxwZXIuXG4gKi9cbmNvbnN0IHJlbW92ZVZhbGlkYXRpb25TdGF0ZSA9ICh2aWV3LCBpZCkgPT4ge1xuICAgICgwLCB1dGlsXzEuZ2V0QnlJZCkodmlldywgaWQpXG4gICAgICAgIC5tYXAoKGgpID0+IHtcbiAgICAgICAgaC5jbGFzc0xpc3QucmVtb3ZlKHN0eWxlLlNVQ0NFU1MpO1xuICAgICAgICBoLmNsYXNzTGlzdC5yZW1vdmUoc3R5bGUuRVJST1IpO1xuICAgICAgICBoLmNsYXNzTGlzdC5yZW1vdmUoc3R5bGUuV0FSTklORyk7XG4gICAgfSk7XG59O1xuZXhwb3J0cy5yZW1vdmVWYWxpZGF0aW9uU3RhdGUgPSByZW1vdmVWYWxpZGF0aW9uU3RhdGU7XG4vKipcbiAqIGdldFZhbGlkYXRpb25TdGF0ZSBjYWxjdWxhdGVzIHRoZSBWYWxpZGF0aW9uU3RhdGUgb2YgYW4gSFRNTEVsZW1lbnRcbiAqIChpZGVudGlmaWVkIGJ5IGlkKSBieSBhbmFseXNpbmcgaXRzIGNsYXNzIGxpc3QuXG4gKi9cbmNvbnN0IGdldFZhbGlkYXRpb25TdGF0ZSA9ICh2aWV3LCBpZCkgPT4gKDAsIHV0aWxfMS5nZXRCeUlkKSh2aWV3LCBpZClcbiAgICAubWFwKGggPT4ge1xuICAgIGlmIChoLmNsYXNzTGlzdC5jb250YWlucyhzdHlsZS5TVUNDRVNTKSlcbiAgICAgICAgcmV0dXJuIFZhbGlkYXRpb25TdGF0ZS5TdWNjZXNzO1xuICAgIGVsc2UgaWYgKGguY2xhc3NMaXN0LmNvbnRhaW5zKHN0eWxlLldBUk5JTkcpKVxuICAgICAgICByZXR1cm4gVmFsaWRhdGlvblN0YXRlLldhcm5pbmc7XG4gICAgZWxzZSBpZiAoaC5jbGFzc0xpc3QuY29udGFpbnMoc3R5bGUuRVJST1IpKVxuICAgICAgICByZXR1cm4gVmFsaWRhdGlvblN0YXRlLkVycm9yO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIFZhbGlkYXRpb25TdGF0ZS5OZXV0cmFsO1xufSlcbiAgICAuZ2V0KCk7XG5leHBvcnRzLmdldFZhbGlkYXRpb25TdGF0ZSA9IGdldFZhbGlkYXRpb25TdGF0ZTtcbi8qKlxuICogZ2V0VmFsaWRpdHlDbGFzc05hbWUgcHJvdmlkZXMgdGhlIGFwcGxpY2FibGUgc3R5bGUgY2xhc3MgYnkgY2hlY2tpbmdcbiAqIHRoZSB2YWxpZGl0eSBwcm9wZXJ0aWVzIG9mIEZlZWRiYWNrQ29udHJvQXR0cnMuXG4gKi9cbmNvbnN0IGdldFZhbGlkaXR5Q2xhc3NOYW1lID0gKGF0dHJzKSA9PiB7XG4gICAgaWYgKGF0dHJzKSB7XG4gICAgICAgIGlmIChhdHRycy5lcnJvciAmJiAoYXR0cnMuZXJyb3IgIT0gJycpKVxuICAgICAgICAgICAgcmV0dXJuIHN0eWxlLkVSUk9SO1xuICAgICAgICBpZiAoYXR0cnMud2FybmluZyAmJiAoYXR0cnMud2FybmluZyAhPSAnJykpXG4gICAgICAgICAgICByZXR1cm4gc3R5bGUuV0FSTklORztcbiAgICAgICAgaWYgKGF0dHJzLnN1Y2Nlc3MgJiYgKGF0dHJzLnN1Y2Nlc3MgIT0gJycpKVxuICAgICAgICAgICAgcmV0dXJuIHN0eWxlLlNVQ0NFU1M7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn07XG5leHBvcnRzLmdldFZhbGlkaXR5Q2xhc3NOYW1lID0gZ2V0VmFsaWRpdHlDbGFzc05hbWU7XG4vKipcbiAqIGdldE1lc3NhZ2VcbiAqL1xuY29uc3QgZ2V0TWVzc2FnZSA9IChhdHRycykgPT4ge1xuICAgIGlmIChhdHRycykge1xuICAgICAgICBpZiAoYXR0cnMuZXJyb3IgJiYgKGF0dHJzLmVycm9yICE9ICcnKSlcbiAgICAgICAgICAgIHJldHVybiBhdHRycy5lcnJvcjtcbiAgICAgICAgaWYgKGF0dHJzLndhcm5pbmcgJiYgKGF0dHJzLndhcm5pbmcgIT0gJycpKVxuICAgICAgICAgICAgcmV0dXJuIGF0dHJzLndhcm5pbmc7XG4gICAgICAgIGlmIChhdHRycy5zdWNjZXNzICYmIChhdHRycy5zdWNjZXNzICE9ICcnKSlcbiAgICAgICAgICAgIHJldHVybiBhdHRycy5zdWNjZXNzO1xuICAgICAgICBpZiAoYXR0cnMubWVzc2FnZSAmJiAoYXR0cnMubWVzc2FnZSAhPSAnJykpXG4gICAgICAgICAgICByZXR1cm4gYXR0cnMubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufTtcbmV4cG9ydHMuZ2V0TWVzc2FnZSA9IGdldE1lc3NhZ2U7XG4vKipcbiAqIHZhbGlkYXRpb25TdGF0ZTJDbGFzc05hbWUgdHJhbnNmb3JtcyBhIFZhbGlkYXRpb25TdGF0ZSBpbnRvXG4gKiB0aGUgY29ycmVzcG9uZGluZyBjbGFzcyBuYW1lIChpZiBhbnkpLlxuICovXG5jb25zdCB2YWxpZGF0aW9uU3RhdGUyQ2xhc3NOYW1lID0gKHN0YXRlKSA9PiB7XG4gICAgaWYgKHN0YXRlID09PSBWYWxpZGF0aW9uU3RhdGUuU3VjY2VzcylcbiAgICAgICAgcmV0dXJuIHN0eWxlLlNVQ0NFU1M7XG4gICAgZWxzZSBpZiAoc3RhdGUgPT09IFZhbGlkYXRpb25TdGF0ZS5XYXJuaW5nKVxuICAgICAgICByZXR1cm4gc3R5bGUuV0FSTklORztcbiAgICBlbHNlIGlmIChzdGF0ZSA9PT0gVmFsaWRhdGlvblN0YXRlLkVycm9yKVxuICAgICAgICByZXR1cm4gc3R5bGUuRVJST1I7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gJyc7XG59O1xuZXhwb3J0cy52YWxpZGF0aW9uU3RhdGUyQ2xhc3NOYW1lID0gdmFsaWRhdGlvblN0YXRlMkNsYXNzTmFtZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZlZWRiYWNrLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5saXN0MkFycmF5ID0gZXhwb3J0cy5GaWxlSW5wdXQgPSBleHBvcnRzLkZpbGVDaGFuZ2VkRXZlbnQgPSBleHBvcnRzLkZJTEVfSU5QVVQgPSB2b2lkIDA7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbmNvbnN0IF9fMSA9IHJlcXVpcmUoXCIuLi8uLi9cIik7XG5jb25zdCBfXzIgPSByZXF1aXJlKFwiLi4vXCIpO1xuY29uc3QgZmlsZV9pbnB1dF8xID0gcmVxdWlyZShcIi4vd21sL2ZpbGUtaW5wdXRcIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLkZJTEVfSU5QVVQgPSAnd3ctZmlsZS1pbnB1dCc7XG4vKipcbiAqIEZpbGVDaGFuZ2VkRXZlbnQgaXMgZmlyZWQgd2hlblxuICovXG5jbGFzcyBGaWxlQ2hhbmdlZEV2ZW50IGV4dGVuZHMgX18yLkV2ZW50IHtcbn1cbmV4cG9ydHMuRmlsZUNoYW5nZWRFdmVudCA9IEZpbGVDaGFuZ2VkRXZlbnQ7XG4vKipcbiAqIEZpbGVJbnB1dCBwcm92aWRlcyBhIHN1cmZhY2UgZm9yIGZpbGUgc2VsZWN0aW9uLlxuICpcbiAqIEl0IHN1cHBvcnRzIGRyYWcgYW5kIGRyb3Agb2YgdGhlIGZpbGVzIGFzIGlucHV0LlxuICovXG5jbGFzcyBGaWxlSW5wdXQgZXh0ZW5kcyBfXzIuQWJzdHJhY3RDb250cm9sIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IGZpbGVfaW5wdXRfMS5GaWxlSW5wdXRWaWV3KHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiAoMCwgX18xLmdldElkKSh0aGlzLmF0dHJzKSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogKDAsIHV0aWxfMS5jb25jYXQpKGV4cG9ydHMuRklMRV9JTlBVVCwgKDAsIF9fMS5nZXRDbGFzc05hbWUpKHRoaXMuYXR0cnMpKSxcbiAgICAgICAgICAgIG5hbWU6ICgwLCBfXzIuZ2V0TmFtZSkodGhpcy5hdHRycyksXG4gICAgICAgICAgICBhY2NlcHQ6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuYWNjZXB0KSA/XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRycy5hY2NlcHQgOiAnJyxcbiAgICAgICAgICAgIG11bHRpcGxlOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLm11bHRpcGxlKSA/XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRycy5tdWx0aXBsZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNoYW5nZTogKGUpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgaW5wdXQgPSBlLnRhcmdldDtcbiAgICAgICAgICAgICAgICBpZiAoKGlucHV0LmZpbGVzICE9IG51bGwpICYmXG4gICAgICAgICAgICAgICAgICAgIChpbnB1dC5maWxlcy5sZW5ndGggPiAwKSAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMub25DaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5vbkNoYW5nZShuZXcgRmlsZUNoYW5nZWRFdmVudChpbnB1dC5uYW1lLCAoMCwgZXhwb3J0cy5saXN0MkFycmF5KShpbnB1dC5maWxlcykpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5GaWxlSW5wdXQgPSBGaWxlSW5wdXQ7XG4vKipcbiAqIGxpc3QyQXJyYXkgY29udmVydHMgYSBGaWxlTGlzdCBpbnRvIGEgcGxhaW4gYXJyYXkgb2YgZmlsZXMuXG4gKi9cbmNvbnN0IGxpc3QyQXJyYXkgPSAobGlzdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldFtpXSA9IGxpc3RbaV07XG4gICAgcmV0dXJuIHJldDtcbn07XG5leHBvcnRzLmxpc3QyQXJyYXkgPSBsaXN0MkFycmF5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZpbGVJbnB1dFZpZXcgPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBGaWxlSW5wdXRWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnaW5wdXQnLCB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuY2xhc3NOYW1lLCAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMubmFtZSwgJ3R5cGUnOiAnZmlsZScsICdhY2NlcHQnOiBfX2NvbnRleHQudmFsdWVzLmFjY2VwdCwgJ29uY2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5jaGFuZ2UsICdtdWx0aXBsZSc6IF9fY29udGV4dC52YWx1ZXMubXVsdGlwbGUgfSwgW10pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5GaWxlSW5wdXRWaWV3ID0gRmlsZUlucHV0Vmlldztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbGUtaW5wdXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZpbGVVcGxvYWRTdXJmYWNlID0gZXhwb3J0cy5GSUxFX1VQTE9BRF9TVVJGQUNFX1RFWFQgPSBleHBvcnRzLkZJTEVfVVBMT0FEX1NVUkZBQ0VfSU5QVVQgPSBleHBvcnRzLkZJTEVfVVBMT0FEX1NVUkZBQ0UgPSBleHBvcnRzLklOU1RSVUNUSU9OX1RFWFQgPSBleHBvcnRzLkZpbGVDaGFuZ2VkRXZlbnQgPSB2b2lkIDA7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbmNvbnN0IGZpbGVfaW5wdXRfMSA9IHJlcXVpcmUoXCIuLi9maWxlLWlucHV0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmlsZUNoYW5nZWRFdmVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmlsZV9pbnB1dF8xLkZpbGVDaGFuZ2VkRXZlbnQ7IH0gfSk7XG5jb25zdCBfXzEgPSByZXF1aXJlKFwiLi4vLi4vXCIpO1xuY29uc3QgX18yID0gcmVxdWlyZShcIi4uL1wiKTtcbmNvbnN0IGZpbGVfdXBsb2FkX3N1cmZhY2VfMSA9IHJlcXVpcmUoXCIuL3dtbC9maWxlLXVwbG9hZC1zdXJmYWNlXCIpO1xuZXhwb3J0cy5JTlNUUlVDVElPTl9URVhUID0gJ0Nob29zZSBhIGZpbGUnO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5GSUxFX1VQTE9BRF9TVVJGQUNFID0gJ3d3LWZpbGUtdXBsb2FkLXN1cmZhY2UnO1xuZXhwb3J0cy5GSUxFX1VQTE9BRF9TVVJGQUNFX0lOUFVUID0gJ3d3LWZpbGUtdXBsb2FkLXN1cmZhY2VfX2lucHV0JztcbmV4cG9ydHMuRklMRV9VUExPQURfU1VSRkFDRV9URVhUID0gJ3d3LWZpbGUtdXBsb2FkLXN1cmZhY2VfX3RleHQnO1xuLyoqXG4gKiBGaWxlVXBsb2FkU3VyZmFjZSBwcm92aWRlcyBhIHN1cmZhY2UgZm9yIGZpbGUgc2VsZWN0aW9uLlxuICpcbiAqIEl0IHN1cHBvcnRzIGRyYWcgYW5kIGRyb3Agb2YgdGhlIGZpbGVzIGFzIGlucHV0LlxuICovXG5jbGFzcyBGaWxlVXBsb2FkU3VyZmFjZSBleHRlbmRzIF9fMi5BYnN0cmFjdENvbnRyb2wge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgZmlsZV91cGxvYWRfc3VyZmFjZV8xLkZpbGVVcGxvYWRTdXJmYWNlVmlldyh0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBpZDogKDAsIF9fMS5nZXRJZCkodGhpcy5hdHRycyksXG4gICAgICAgICAgICBjbGFzc05hbWU6ICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLkZJTEVfVVBMT0FEX1NVUkZBQ0UsICgwLCBfXzEuZ2V0Q2xhc3NOYW1lKSh0aGlzLmF0dHJzKSksXG4gICAgICAgICAgICBzdG9wOiAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRyb3A6IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgbGV0IG5hbWUgPSAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLm5hbWUpID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5uYW1lIDogJyc7XG4gICAgICAgICAgICAgICAgaWYgKGUuZGF0YVRyYW5zZmVyICYmIGUuZGF0YVRyYW5zZmVyLmZpbGVzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzLmlucHV0Lm9uQ2hhbmdlKG5ldyBmaWxlX2lucHV0XzEuRmlsZUNoYW5nZWRFdmVudChuYW1lLCAoMCwgZmlsZV9pbnB1dF8xLmxpc3QyQXJyYXkpKGUuZGF0YVRyYW5zZmVyLmZpbGVzKSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlucHV0OiB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBleHBvcnRzLkZJTEVfVVBMT0FEX1NVUkZBQ0VfSU5QVVQsXG4gICAgICAgICAgICAgICAgbmFtZTogKDAsIF9fMi5nZXROYW1lKSh0aGlzLmF0dHJzKSxcbiAgICAgICAgICAgICAgICBhY2NlcHQ6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuYWNjZXB0KSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMuYWNjZXB0IDogJycsXG4gICAgICAgICAgICAgICAgbXVsdGlwbGU6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMubXVsdGlwbGUpID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5tdWx0aXBsZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZXMudGV4dC52YWx1ZSA9IGUudmFsdWVbMF0ubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5vbkNoYW5nZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMub25DaGFuZ2UoZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlldy5pbnZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRleHQ6IHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGV4cG9ydHMuRklMRV9VUExPQURfU1VSRkFDRV9URVhULFxuICAgICAgICAgICAgICAgIHZhbHVlOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLnRleHQpID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy50ZXh0IDogZXhwb3J0cy5JTlNUUlVDVElPTl9URVhUXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5GaWxlVXBsb2FkU3VyZmFjZSA9IEZpbGVVcGxvYWRTdXJmYWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZpbGVVcGxvYWRTdXJmYWNlVmlldyA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuY29uc3QgZmlsZV9pbnB1dF8xID0gcmVxdWlyZShcIi4uLy4uL2ZpbGUtaW5wdXRcIik7XG47XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgRmlsZVVwbG9hZFN1cmZhY2VWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnZGl2JywgeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmNsYXNzTmFtZSwgJ29uZHJhZ2VudGVyJzogX19jb250ZXh0LnZhbHVlcy5zdG9wLCAnb25kcmFnb3Zlcic6IF9fY29udGV4dC52YWx1ZXMuc3RvcCwgJ29uZHJvcCc6IF9fY29udGV4dC52YWx1ZXMuZHJvcCB9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZmlsZV9pbnB1dF8xLkZpbGVJbnB1dCh7ICdjbGFzc05hbWUnOiBfX2NvbnRleHQudmFsdWVzLmlucHV0LmNsYXNzTmFtZSwgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLmlucHV0Lm5hbWUsICdhY2NlcHQnOiBfX2NvbnRleHQudmFsdWVzLmlucHV0LmFjY2VwdCwgJ211bHRpcGxlJzogX19jb250ZXh0LnZhbHVlcy5pbnB1dC5tdWx0aXBsZSwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5pbnB1dC5vbkNoYW5nZSB9LCBbXSksIHsgJ2NsYXNzTmFtZSc6IF9fY29udGV4dC52YWx1ZXMuaW5wdXQuY2xhc3NOYW1lLCAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMuaW5wdXQubmFtZSwgJ2FjY2VwdCc6IF9fY29udGV4dC52YWx1ZXMuaW5wdXQuYWNjZXB0LCAnbXVsdGlwbGUnOiBfX2NvbnRleHQudmFsdWVzLmlucHV0Lm11bHRpcGxlLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLmlucHV0Lm9uQ2hhbmdlIH0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdkaXYnLCB7ICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMudGV4dC5jbGFzc05hbWUgfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaDMnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dChfX2NvbnRleHQudmFsdWVzLnRleHQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5GaWxlVXBsb2FkU3VyZmFjZVZpZXcgPSBGaWxlVXBsb2FkU3VyZmFjZVZpZXc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWxlLXVwbG9hZC1zdXJmYWNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mb2N1cyA9IGV4cG9ydHMuRm9jdXNMb3N0RXZlbnQgPSBleHBvcnRzLkZvY3VzR2FpbmVkRXZlbnQgPSB2b2lkIDA7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbi8qKlxuICogRm9jdXNHYWluZWRFdmVudFxuICovXG5jbGFzcyBGb2N1c0dhaW5lZEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgfVxufVxuZXhwb3J0cy5Gb2N1c0dhaW5lZEV2ZW50ID0gRm9jdXNHYWluZWRFdmVudDtcbi8qKlxuICogRm9jdXNMb3N0RXZlbnRcbiAqL1xuY2xhc3MgRm9jdXNMb3N0RXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB9XG59XG5leHBvcnRzLkZvY3VzTG9zdEV2ZW50ID0gRm9jdXNMb3N0RXZlbnQ7XG4vKipcbiAqIGZvY3VzIERPTSBoZWxwZXIuXG4gKi9cbmNvbnN0IGZvY3VzID0gKHZpZXcsIGlkKSA9PiB7XG4gICAgKDAsIHV0aWxfMS5nZXRCeUlkKSh2aWV3LCBpZClcbiAgICAgICAgLm1hcChlID0+IGUuZm9jdXMoKSk7XG59O1xuZXhwb3J0cy5mb2N1cyA9IGZvY3VzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIFRoZSBmb3JtIG1vZHVsZSBkZWFscyB3aXRoIGNvbnRyb2xzIHNwZWNpZmljYWxseSBmb3IgYWNjZXB0aW5nIHVzZXIgaW5wdXQuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVtb3ZlTWVzc2FnZSA9IGV4cG9ydHMuc2V0TWVzc2FnZSA9IGV4cG9ydHMuZ2V0TGFiZWwgPSBleHBvcnRzLkFic3RyYWN0Rm9ybUNvbnRyb2wgPSB2b2lkIDA7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IGZlZWRiYWNrXzEgPSByZXF1aXJlKFwiLi9mZWVkYmFja1wiKTtcbi8qKlxuICogQWJzdHJhY3RGb3JtQ29udHJvbCBwcm92aWRlcyBhIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYVxuICogRm9ybUNvbnRyb2wuXG4gKi9cbmNsYXNzIEFic3RyYWN0Rm9ybUNvbnRyb2wgZXh0ZW5kcyBmZWVkYmFja18xLkFic3RyYWN0RmVlZGJhY2tDb250cm9sIHtcbn1cbmV4cG9ydHMuQWJzdHJhY3RGb3JtQ29udHJvbCA9IEFic3RyYWN0Rm9ybUNvbnRyb2w7XG4vKipcbiAqIGdldExhYmVsIGV4dHJhY3RzIHRoZSBsYWJlbCB2YWx1ZSBmcm9tIEZyb21Db250cm9sQXR0cnMuXG4gKi9cbmNvbnN0IGdldExhYmVsID0gKGF0dHJzKSA9PiAoYXR0cnMgJiYgYXR0cnMubGFiZWwpID8gYXR0cnMubGFiZWwgOiAnJztcbmV4cG9ydHMuZ2V0TGFiZWwgPSBnZXRMYWJlbDtcbi8qKlxuICogc2V0TWVzc2FnZSBoZWxwZXIuXG4gKlxuICogU2V0cyB0aGUgbWVzc2FnZSBvbiB0aGUgSGVscCB3aWRnZXQuXG4gKi9cbmNvbnN0IHNldE1lc3NhZ2UgPSAodmlldywgaWQsIG1zZykgPT4ge1xuICAgICgwLCB1dGlsXzEuZ2V0QnlJZCkodmlldywgaWQpLm1hcChoID0+IHsgaC5zZXRNZXNzYWdlKG1zZyk7IH0pO1xufTtcbmV4cG9ydHMuc2V0TWVzc2FnZSA9IHNldE1lc3NhZ2U7XG4vKipcbiAqIHJlbW92ZU1lc3NhZ2UgaGVscGVyLlxuICpcbiAqIFJlbW92ZXMgdGhlIG1lc3NhZ2UgZnJvbSB0aGUgSGVscCB3aWRnZXQuXG4gKi9cbmNvbnN0IHJlbW92ZU1lc3NhZ2UgPSAodmlldywgaWQpID0+IHtcbiAgICAoMCwgdXRpbF8xLmdldEJ5SWQpKHZpZXcsIGlkKS5tYXAoaCA9PiB7IGgucmVtb3ZlTWVzc2FnZSgpOyB9KTtcbn07XG5leHBvcnRzLnJlbW92ZU1lc3NhZ2UgPSByZW1vdmVNZXNzYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSGVscCA9IGV4cG9ydHMuSEVMUCA9IHZvaWQgMDtcbmNvbnN0IGRvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbmNvbnN0IHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbmNvbnN0IGZlZWRiYWNrXzEgPSByZXF1aXJlKFwiLi4vZmVlZGJhY2tcIik7XG5jb25zdCBfXzEgPSByZXF1aXJlKFwiLi4vLi4vXCIpO1xuY29uc3QgaGVscF8xID0gcmVxdWlyZShcIi4vd21sL2hlbHBcIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLkhFTFAgPSAnd3ctaGVscCc7XG4vKipcbiAqIEhlbHBcbiAqL1xuY2xhc3MgSGVscCBleHRlbmRzIHdtbF8xLkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyBoZWxwXzEuTWFpbih0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBoZWxwOiB7XG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAnaGVscCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlkOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmlkKSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMuaWQgOiAnJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLkhFTFAsICgwLCBfXzEuZ2V0Q2xhc3NOYW1lKSh0aGlzLmF0dHJzKSksXG4gICAgICAgICAgICAgICAgdGV4dDogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy50ZXh0KSA/XG4gICAgICAgICAgICAgICAgICAgIFtkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLmF0dHJzLnRleHQpXSA6IHRoaXMuY2hpbGRyZW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgc2V0TWVzc2FnZShtc2cpIHtcbiAgICAgICAgKDAsIGZlZWRiYWNrXzEuc2V0TWVzc2FnZSkodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5oZWxwLndtbC5pZCwgbXNnKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlbW92ZU1lc3NhZ2UoKSB7XG4gICAgICAgICgwLCBmZWVkYmFja18xLnJlbW92ZU1lc3NhZ2UpKHRoaXMudmlldywgdGhpcy52YWx1ZXMuaGVscC53bWwuaWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLkhlbHAgPSBIZWxwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1haW4gPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnc3BhbicsIHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuaGVscC53bWwuaWQgfSwgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5oZWxwLmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmhlbHAuY2xhc3NOYW1lIH0sIFtcbiAgICAgICAgICAgICAgICAuLi4oX19jb250ZXh0LnZhbHVlcy5oZWxwLnRleHQpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRWYWx1ZSA9IGV4cG9ydHMuZ2V0RGlzYWJsZWQgPSBleHBvcnRzLmdldE5hbWUgPSBleHBvcnRzLkFic3RyYWN0Q29udHJvbCA9IGV4cG9ydHMuRXZlbnQgPSB2b2lkIDA7XG4vKipcbiAqIFRoaXMgbW9kdWxlIHByb3ZpZGVzIHRoZSBwYXJlbnQgaW50ZXJmYWNlcyBmb3IgbW9zdCBvZiB0aGVcbiAqIHdpZGdldHMgY29uc2lkZXJlZCAnY29udHJvbHMnLlxuICpcbiAqIENvbnRyb2xzIGFsbG93IHVzZXJzIHRvIG1hbmlwdWxhdGUgdGhlIHN0YXRlIG9mIGFuIGFwcGxpY2F0aW9uXG4gKiBieSBpbnRlcmFjdGluZyB3aXRoIHdpZGdldHMgb24gc2NyZWVuLiBJbiBzaW1wbGVyIHRlcm1zLFxuICogdGhleSBhcmUgdGhlIHdpZGdldHMgdGhhdCBhY2NlcHQgdXNlciBpbnB1dCBvciB0cmlnZ2VyXG4gKiByZWFjdGlvbnMgd2hlbiB0aGUgdXNlciBtYW5pcHVsYXRlcyB0aGVtLlxuICpcbiAqIEdlbmVyYWxseSwgd2UgdXNlIGEgc3RyZWFtaW5nIGJhc2VkIHdvcmtmbG93LCB0aGF0IGlzXG4gKiBhcyB0aGUgdXNlciBwcmVmb3JtcyBhIHN1cHBvcnRlZCBhY3Rpb24gYW5kIGV2ZW50IGlzIGdlbmVyYXRlZFxuICogZWFjaCBhbmQgZXZlcnkgdGltZSBhbmQgc29tZSBoYW5kbGVyIGlzIGFwcGxpZWQgdG8gdGhlIGV2ZW50LlxuICovXG4vKiogQGltcG9ydHMgKi9cbmNvbnN0IHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLyoqXG4gKiBFdmVudCBpcyB0aGUgcGFyZW50IGNsYXNzIG9mIGFsbCBldmVudHMgZ2VuZXJhdGVkIGJ5IGNvbnRyb2xzLlxuICovXG5jbGFzcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbn1cbmV4cG9ydHMuRXZlbnQgPSBFdmVudDtcbi8qKlxuICogQWJzdHJhY3RDb250cm9sIGltcGxlbWVudHMgdGhlIG1ldGhvZHMgb2YgdGhlIENvbnRyb2wgaW50ZXJmYWNlLlxuICovXG5jbGFzcyBBYnN0cmFjdENvbnRyb2wgZXh0ZW5kcyB3bWxfMS5Db21wb25lbnQge1xufVxuZXhwb3J0cy5BYnN0cmFjdENvbnRyb2wgPSBBYnN0cmFjdENvbnRyb2w7XG4vKipcbiAqIGdldE5hbWVcbiAqL1xuY29uc3QgZ2V0TmFtZSA9IChhdHRycykgPT4gKGF0dHJzICYmIGF0dHJzLm5hbWUpID8gYXR0cnMubmFtZSA6ICcnO1xuZXhwb3J0cy5nZXROYW1lID0gZ2V0TmFtZTtcbi8qKlxuICogZ2V0RGlzYWJsZWRcbiAqL1xuY29uc3QgZ2V0RGlzYWJsZWQgPSAoYXR0cnMpID0+IChhdHRycyAmJiBhdHRycy5kaXNhYmxlZCkgPyBhdHRycy5kaXNhYmxlZCA6IHVuZGVmaW5lZDtcbmV4cG9ydHMuZ2V0RGlzYWJsZWQgPSBnZXREaXNhYmxlZDtcbi8qKlxuICogZ2V0VmFsdWVcbiAqL1xuY29uc3QgZ2V0VmFsdWUgPSAoYXR0cnMpID0+IChhdHRycyAmJiBhdHRycy52YWx1ZSkgPyAoMCwgbWF5YmVfMS5qdXN0KShhdHRycy52YWx1ZSkgOiAoMCwgbWF5YmVfMS5ub3RoaW5nKSgpO1xuZXhwb3J0cy5nZXRWYWx1ZSA9IGdldFZhbHVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFkZE9uID0gZXhwb3J0cy5JbnB1dEdyb3VwID0gZXhwb3J0cy5JTlBVVF9HUk9VUF9CVVRUT05fQURET04gPSBleHBvcnRzLklOUFVUX0dST1VQX0FERE9OID0gZXhwb3J0cy5JTlBVVF9HUk9VUCA9IHZvaWQgMDtcbmNvbnN0IHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbmNvbnN0IF9fMSA9IHJlcXVpcmUoXCIuLi8uLi9cIik7XG5jb25zdCBpbnB1dF9ncm91cF8xID0gcmVxdWlyZShcIi4vd21sL2lucHV0LWdyb3VwXCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5JTlBVVF9HUk9VUCA9ICd3dy1pbnB1dC1ncm91cCc7XG5leHBvcnRzLklOUFVUX0dST1VQX0FERE9OID0gJ3d3LWlucHV0LWdyb3VwX19hZGRvbic7XG5leHBvcnRzLklOUFVUX0dST1VQX0JVVFRPTl9BRERPTiA9ICd3dy1pbnB1dC1ncm91cF9fYnV0dG9uLWFkZG9uJztcbi8qKlxuICogSW5wdXRHcm91cCBhbGxvd3MgYW4gaW5wdXQgdG8gYmUgd3JhcHBlZCB0b2dldGhlciB3aXRoIG90aGVyIGNvbnRyb2xzIHRvXG4gKiBhcHBlYXIgYXMgb25lLlxuICpcbiAqIFRoaXMgaXMgdXNlZnVsIGZvciBjcmVhdGluZyBpbnB1dHMgdGhhdCBtYXkgaGF2ZSByZWxhdGVkIGZpZWxkcyB0aGF0IHNob3VsZFxuICogYmUgbW9kaWZpZWQgd2hlbiBjaGFuZ2VkLiBGb3IgZXhhbXBsZSwgZW50ZXJpbmcgYW4gYW1vdW50IGFuZCBjdXJyZW5jeSBpbiB0aGVcbiAqIHNhbWUgcGxhY2UuXG4gKlxuICogICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAqICB8IFRURCBeIHwgNTAwMC4wMCAgICAgICAgICAgICAgICB8XG4gKiAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICovXG5jbGFzcyBJbnB1dEdyb3VwIGV4dGVuZHMgd21sXzEuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IGlucHV0X2dyb3VwXzEuSW5wdXRHcm91cFZpZXcodGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6ICgwLCBfXzEuZ2V0SWQpKHRoaXMuYXR0cnMpLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAoMCwgdXRpbF8xLmNvbmNhdCkoZXhwb3J0cy5JTlBVVF9HUk9VUCwgKDAsIF9fMS5nZXRDbGFzc05hbWUpKHRoaXMuYXR0cnMpKSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLklucHV0R3JvdXAgPSBJbnB1dEdyb3VwO1xuLyoqXG4gKiBBZGRPbiBpcyB1c2VkIHRvIGF0dGFjaCB0aGUgZXh0cmEgdGV4dCBvciBjb250cm9sIHRvIHRoZSBpbnB1dC5cbiAqL1xuY2xhc3MgQWRkT24gZXh0ZW5kcyB3bWxfMS5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgaW5wdXRfZ3JvdXBfMS5BZGRPblZpZXcodGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6ICgwLCBfXzEuZ2V0SWQpKHRoaXMuYXR0cnMpLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAoMCwgdXRpbF8xLmNvbmNhdCkodGhpcy5hdHRycy5idXR0b24gP1xuICAgICAgICAgICAgICAgIGV4cG9ydHMuSU5QVVRfR1JPVVBfQlVUVE9OX0FERE9OIDpcbiAgICAgICAgICAgICAgICBleHBvcnRzLklOUFVUX0dST1VQX0FERE9OLCAoMCwgX18xLmdldENsYXNzTmFtZSkodGhpcy5hdHRycykpLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQWRkT24gPSBBZGRPbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZGRPblZpZXcgPSBleHBvcnRzLklucHV0R3JvdXBWaWV3ID0gdm9pZCAwO1xuY29uc3QgX19kb2N1bWVudCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbmNvbnN0IG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgSW5wdXRHcm91cFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdkaXYnLCB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuY2xhc3NOYW1lIH0sIFtcbiAgICAgICAgICAgICAgICAuLi4oX19jb250ZXh0LmNoaWxkcmVuKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLklucHV0R3JvdXBWaWV3ID0gSW5wdXRHcm91cFZpZXc7XG47XG5jbGFzcyBBZGRPblZpZXcge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdkaXYnLCB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuY2xhc3NOYW1lIH0sIFtcbiAgICAgICAgICAgICAgICAuLi4oX19jb250ZXh0LmNoaWxkcmVuKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLkFkZE9uVmlldyA9IEFkZE9uVmlldztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlucHV0LWdyb3VwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MYWJlbCA9IGV4cG9ydHMuTEFCRUwgPSB2b2lkIDA7XG5jb25zdCBkb2N1bWVudCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG5jb25zdCB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG5jb25zdCBfXzEgPSByZXF1aXJlKFwiLi4vLi4vXCIpO1xuY29uc3QgbGFiZWxfMSA9IHJlcXVpcmUoXCIuL3dtbC9sYWJlbFwiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuTEFCRUwgPSAnd3ctbGFiZWwnO1xuLyoqXG4gKiBMYWJlbFxuICovXG5jbGFzcyBMYWJlbCBleHRlbmRzIHdtbF8xLkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyBsYWJlbF8xLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLkxBQkVMLCAoMCwgX18xLmdldENsYXNzTmFtZSkodGhpcy5hdHRycykpLFxuICAgICAgICAgICAgICAgIGZvcjogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5mb3IpID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5mb3IgOiAnJyxcbiAgICAgICAgICAgICAgICB0ZXh0OiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLnRleHQpID9cbiAgICAgICAgICAgICAgICAgICAgW2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMuYXR0cnMudGV4dCldIDogdGhpcy5jaGlsZHJlblxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuTGFiZWwgPSBMYWJlbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYWluID0gdm9pZCAwO1xuY29uc3QgX19kb2N1bWVudCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbmNvbnN0IG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ2xhYmVsJywgeyAnZm9yJzogX19jb250ZXh0LnZhbHVlcy5sYWJlbC5mb3IsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMubGFiZWwuY2xhc3NOYW1lIH0sIFtcbiAgICAgICAgICAgICAgICAuLi4oX19jb250ZXh0LnZhbHVlcy5sYWJlbC50ZXh0KVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGFiZWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk11bHRpU2VsZWN0ID0gZXhwb3J0cy5JdGVtc0NoYW5nZWRFdmVudCA9IGV4cG9ydHMuREVGQVVMVF9GT05UX0lOQ1JFTUVOVCA9IGV4cG9ydHMuREVGQVVMVF9JTlBVVF9XSURUSCA9IGV4cG9ydHMuTVVMVElfU0VMRUNUX1RBRyA9IGV4cG9ydHMuTVVMVElfU0VMRUNUX0lOUFVUID0gZXhwb3J0cy5NVUxUSV9TRUxFQ1RfQ09OVEVOVCA9IGV4cG9ydHMuTVVMVElfU0VMRUNUID0gZXhwb3J0cy5UZXJtQ2hhbmdlZEV2ZW50ID0gdm9pZCAwO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvbXVsdGktc2VsZWN0XCIpO1xuY29uc3Qgb3JpZW50YXRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZW50L29yaWVudGF0aW9uXCIpO1xuY29uc3QgZm9ybV8xID0gcmVxdWlyZShcIi4uL2Zvcm1cIik7XG5jb25zdCBzZWFyY2hfMSA9IHJlcXVpcmUoXCIuLi9zZWFyY2hcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUZXJtQ2hhbmdlZEV2ZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWFyY2hfMS5UZXJtQ2hhbmdlZEV2ZW50OyB9IH0pO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG5jb25zdCBfXzEgPSByZXF1aXJlKFwiLi4vLi4vXCIpO1xuY29uc3QgX18yID0gcmVxdWlyZShcIi4uL1wiKTtcbmNvbnN0IGZlZWRiYWNrXzEgPSByZXF1aXJlKFwiLi4vZmVlZGJhY2tcIik7XG5jb25zdCBhY3RpdmVfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZW50L3N0YXRlL2FjdGl2ZVwiKTtcbmNvbnN0IGRpc2FibGVkXzEgPSByZXF1aXJlKFwiLi4vLi4vY29udGVudC9zdGF0ZS9kaXNhYmxlZFwiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuTVVMVElfU0VMRUNUID0gJ3d3LW11bHRpLXNlbGVjdCc7XG5leHBvcnRzLk1VTFRJX1NFTEVDVF9DT05URU5UID0gJ3d3LW11bHRpLXNlbGVjdF9fY29udGVudCc7XG5leHBvcnRzLk1VTFRJX1NFTEVDVF9JTlBVVCA9ICd3dy1tdWx0aS1zZWxlY3RfX2lucHV0JztcbmV4cG9ydHMuTVVMVElfU0VMRUNUX1RBRyA9ICd3dy1tdWx0aS1zZWxlY3RfX3RhZyc7XG4vLy9jbGFzc05hbWVzOmVuZFxuZXhwb3J0cy5ERUZBVUxUX0lOUFVUX1dJRFRIID0gNTA7XG5leHBvcnRzLkRFRkFVTFRfRk9OVF9JTkNSRU1FTlQgPSA3O1xuLyoqXG4gKiBJdGVtc0NoYW5nZWRFdmVudFxuICovXG5jbGFzcyBJdGVtc0NoYW5nZWRFdmVudCBleHRlbmRzIF9fMi5FdmVudCB7XG59XG5leHBvcnRzLkl0ZW1zQ2hhbmdlZEV2ZW50ID0gSXRlbXNDaGFuZ2VkRXZlbnQ7XG4vKipcbiAqIE11bHRpU2VsZWN0XG4gKi9cbmNsYXNzIE11bHRpU2VsZWN0IGV4dGVuZHMgZm9ybV8xLkFic3RyYWN0Rm9ybUNvbnRyb2wge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbih0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAncm9vdCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmRpc2FibGVkKSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMuZGlzYWJsZWQgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpZDogKDAsIF9fMS5nZXRJZCkodGhpcy5hdHRycyksXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAoMCwgdXRpbF8xLmNvbmNhdCkoZXhwb3J0cy5NVUxUSV9TRUxFQ1QsICgwLCBfXzEuZ2V0Q2xhc3NOYW1lKSh0aGlzLmF0dHJzKSwgKDAsIGZlZWRiYWNrXzEuZ2V0VmFsaWRpdHlDbGFzc05hbWUpKHRoaXMuYXR0cnMpLCAoMCwgb3JpZW50YXRpb25fMS5nZXRCbG9ja0NsYXNzTmFtZSkodGhpcy5hdHRycyksICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuZGlzYWJsZWQpID9cbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWRfMS5ESVNBQkxFRCA6ICcnKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnRyb2w6IHtcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdyb290J1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ2xhYmVsJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGV4dDogKDAsIGZvcm1fMS5nZXRMYWJlbCkodGhpcy5hdHRycylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWFyY2g6IHtcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdzZWFyY2gnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBibG9jazogdGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmJsb2NrIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBpdGVtVGVtcGxhdGU6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuaXRlbVRlbXBsYXRlKSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMuaXRlbVRlbXBsYXRlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG5vSXRlbXNUZW1wbGF0ZTogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5ub0l0ZW1zVGVtcGxhdGUpID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5ub0l0ZW1zVGVtcGxhdGUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgb25TZWFyY2g6IChldnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5vblNlYXJjaClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMub25TZWFyY2goZXZ0KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uU2VsZWN0OiAoeyB2YWx1ZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZUNoYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZXNzYWdlczoge1xuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ21lc3NhZ2UnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0ZXh0OiAoMCwgZmVlZGJhY2tfMS5nZXRNZXNzYWdlKSh0aGlzLmF0dHJzKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGV4cG9ydHMuTVVMVElfU0VMRUNUX0NPTlRFTlQsXG4gICAgICAgICAgICAgICAgb25mb2N1czogKCkgPT4gdGhpcy5mb2N1cygpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGFnczoge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogKDAsIHV0aWxfMS5jb25jYXQpKGV4cG9ydHMuTVVMVElfU0VMRUNUX1RBRywgKDAsIGZlZWRiYWNrXzEuZ2V0VmFsaWRpdHlDbGFzc05hbWUpKHRoaXMuYXR0cnMpKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy52YWx1ZSkgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLnZhbHVlIDogW10sXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuZGlzYWJsZWQpID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5kaXNhYmxlZCA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGhhczogKCkgPT4gdGhpcy52YWx1ZXMudGFncy52YWx1ZS5sZW5ndGggPiAwLFxuICAgICAgICAgICAgICAgIGdldFRleHQ6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuc3RyaW5naWZpZXIpID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5zdHJpbmdpZmllciA6ICh2KSA9PiBTdHJpbmcodiksXG4gICAgICAgICAgICAgICAgb25EaXNtaXNzOiAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaWR4ID0gTnVtYmVyKGUubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzLnRhZ3MudmFsdWUuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZUNoYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbnB1dDoge1xuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ2lucHV0J1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBleHBvcnRzLk1VTFRJX1NFTEVDVF9JTlBVVCxcbiAgICAgICAgICAgICAgICBuYW1lOiAoMCwgX18yLmdldE5hbWUpKHRoaXMuYXR0cnMpLFxuICAgICAgICAgICAgICAgIGlucHV0V2lkdGg6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuaW5wdXRXaWR0aCkgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLmlucHV0V2lkdGggOiBleHBvcnRzLkRFRkFVTFRfSU5QVVRfV0lEVEgsXG4gICAgICAgICAgICAgICAgZm9udEluY3JlbWVudDogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5mb250SW5jcmVtZW50KSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMuZm9udEluY3JlbWVudCA6IGV4cG9ydHMuREVGQVVMVF9GT05UX0lOQ1JFTUVOVCxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5kaXNhYmxlZCkgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLmRpc2FibGVkIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG9uU2VhcmNoOiAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMudmFsdWVzLnJvb3QuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JvdyhlLnZhbHVlLmxlbmd0aCArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5vblNlYXJjaClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLm9uU2VhcmNoKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lbnU6IHtcbiAgICAgICAgICAgICAgICB3bWw6IHsgaWQ6ICdtZW51JyB9LFxuICAgICAgICAgICAgICAgIG5hbWU6ICgwLCBfXzIuZ2V0TmFtZSkodGhpcy5hdHRycyksXG4gICAgICAgICAgICAgICAgYmxvY2s6IHRydWUsXG4gICAgICAgICAgICAgICAgb25TZWxlY3Q6IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZXMudGFncy52YWx1ZS5wdXNoKGUudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmVDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGl0ZW1UZW1wbGF0ZTogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5pdGVtVGVtcGxhdGUpID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5pdGVtVGVtcGxhdGUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbm9JdGVtc1RlbXBsYXRlOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLm5vSXRlbXNUZW1wbGF0ZSkgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLm5vSXRlbXNUZW1wbGF0ZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBzdHJpbmdpZmllcjogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5zdHJpbmdpZmllcikgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLnN0cmluZ2lmaWVyIDogdW5kZWZpbmVkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZmlyZUNoYW5nZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5vbkNoYW5nZSlcbiAgICAgICAgICAgIHRoaXMuYXR0cnMub25DaGFuZ2UobmV3IEl0ZW1zQ2hhbmdlZEV2ZW50KCgwLCBfXzIuZ2V0TmFtZSkodGhpcy5hdHRycyksIHRoaXMudmFsdWVzLnRhZ3MudmFsdWUuc2xpY2UoKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdyb3cobikge1xuICAgICAgICBsZXQgbUlucHV0ID0gKDAsIHV0aWxfMS5nZXRCeUlkKSh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLmlucHV0LndtbC5pZCk7XG4gICAgICAgIGlmIChtSW5wdXQuaXNOb3RoaW5nKCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBpID0gbUlucHV0LmdldCgpO1xuICAgICAgICBsZXQgbURvbSA9ICgwLCB1dGlsXzEuZ2V0QnlJZCkoaS52aWV3LCBpLnZhbHVlcy53bWwuaWQpO1xuICAgICAgICBpZiAobURvbS5pc05vdGhpbmcoKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGRvbSA9IG1Eb20uZ2V0KCk7XG4gICAgICAgIGRvbS5zdHlsZS53aWR0aCA9IGAke24gKiB0aGlzLnZhbHVlcy5pbnB1dC5mb250SW5jcmVtZW50fXB4YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICByZWRyYXcoKSB7XG4gICAgICAgIHRoaXMudmlldy5pbnZhbGlkYXRlKCk7XG4gICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldE1lc3NhZ2UobXNnKSB7XG4gICAgICAgICgwLCBmb3JtXzEuc2V0TWVzc2FnZSkodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5tZXNzYWdlcy53bWwuaWQsIG1zZyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZW1vdmVNZXNzYWdlKCkge1xuICAgICAgICAoMCwgZm9ybV8xLnJlbW92ZU1lc3NhZ2UpKHRoaXMudmlldywgdGhpcy52YWx1ZXMubWVzc2FnZXMud21sLmlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHVwZGF0ZShyZXN1bHRzKSB7XG4gICAgICAgICgwLCBzZWFyY2hfMS51cGRhdGVNZW51KSh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLm1lbnUud21sLmlkLCByZXN1bHRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9wZW4oKSB7XG4gICAgICAgICgwLCBzZWFyY2hfMS5vcGVuTWVudSkodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5tZW51LndtbC5pZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgKDAsIHNlYXJjaF8xLmNsb3NlTWVudSkodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5tZW51LndtbC5pZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmb2N1cygpIHtcbiAgICAgICAgZ2V0SW5wdXQodGhpcykubWFwKGkgPT4gaS5mb2N1cygpKTtcbiAgICAgICAgZ2V0Um9vdCh0aGlzKS5tYXAoZSA9PiBlLmNsYXNzTGlzdC5hZGQoYWN0aXZlXzEuQUNUSVZFKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBwdXNoIGEgdmFsdWUgb250byB0aGUgZW5kIG9mIHRoZSBpbnRlcm5hbCBzdGFjay5cbiAgICAgKi9cbiAgICBwdXNoKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWVzLnRhZ3MudmFsdWUucHVzaCh2YWx1ZSk7XG4gICAgICAgIHRoaXMuZmlyZUNoYW5nZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLk11bHRpU2VsZWN0ID0gTXVsdGlTZWxlY3Q7XG5jb25zdCBnZXRJbnB1dCA9IChtKSA9PiAoMCwgdXRpbF8xLmdldEJ5SWQpKG0udmlldywgbS52YWx1ZXMuaW5wdXQud21sLmlkKTtcbmNvbnN0IGdldFJvb3QgPSAobSkgPT4gKDAsIHV0aWxfMS5nZXRCeUlkKShtLnZpZXcsIG0udmFsdWVzLnJvb3Qud21sLmlkKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYWluID0gdm9pZCAwO1xuY29uc3QgX19kb2N1bWVudCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbmNvbnN0IG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG5jb25zdCBsYWJlbF8xID0gcmVxdWlyZShcIi4uLy4uL2xhYmVsXCIpO1xuO1xuY29uc3QgaGVscF8xID0gcmVxdWlyZShcIi4uLy4uL2hlbHBcIik7XG47XG5jb25zdCB0YWdfMSA9IHJlcXVpcmUoXCIuLi8uLi90YWdcIik7XG47XG5jb25zdCBzZWFyY2hfMSA9IHJlcXVpcmUoXCIuLi8uLi9zZWFyY2hcIik7XG47XG5jb25zdCByZXN1bHRzX21lbnVfMSA9IHJlcXVpcmUoXCIuLi8uLi9yZXN1bHRzLW1lbnVcIik7XG47XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ2RpdicsIHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5yb290LmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NOYW1lIH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBsYWJlbF8xLkxhYmVsKHsgJ2Zvcic6IF9fY29udGV4dC52YWx1ZXMucm9vdC5pZCwgJ3RleHQnOiBfX2NvbnRleHQudmFsdWVzLmxhYmVsLnRleHQgfSwgW10pLCB7ICdmb3InOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuaWQsICd0ZXh0JzogX19jb250ZXh0LnZhbHVlcy5sYWJlbC50ZXh0IH0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdkaXYnLCB7ICdvbmNsaWNrJzogX19jb250ZXh0LnZhbHVlcy5jb250ZW50Lm9uZm9jdXMsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuY29udGVudC5jbGFzc05hbWUgfSwgW1xuICAgICAgICAgICAgICAgICAgICAuLi4oKF9fY29udGV4dC52YWx1ZXMudGFncy5oYXMoKSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgKCgpID0+IChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uX19mb3JJbihfX2NvbnRleHQudmFsdWVzLnRhZ3MudmFsdWUsICh2YWx1ZSwgaWR4LCBfJCRhbGwpID0+IChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRhZ18xLlRhZyh7ICduYW1lJzogU3RyaW5nKGlkeCksICd0ZXh0JzogX19jb250ZXh0LnZhbHVlcy50YWdzLmdldFRleHQodmFsdWUpLCAnZGlzYWJsZWQnOiBfX2NvbnRleHQudmFsdWVzLnRhZ3MuZGlzYWJsZWQsICdjbGFzc05hbWUnOiBfX2NvbnRleHQudmFsdWVzLnRhZ3MuY2xhc3NOYW1lLCAnb25EaXNtaXNzJzogX19jb250ZXh0LnZhbHVlcy50YWdzLm9uRGlzbWlzcyB9LCBbXSksIHsgJ25hbWUnOiBTdHJpbmcoaWR4KSwgJ3RleHQnOiBfX2NvbnRleHQudmFsdWVzLnRhZ3MuZ2V0VGV4dCh2YWx1ZSksICdkaXNhYmxlZCc6IF9fY29udGV4dC52YWx1ZXMudGFncy5kaXNhYmxlZCwgJ2NsYXNzTmFtZSc6IF9fY29udGV4dC52YWx1ZXMudGFncy5jbGFzc05hbWUsICdvbkRpc21pc3MnOiBfX2NvbnRleHQudmFsdWVzLnRhZ3Mub25EaXNtaXNzIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSksICgpID0+IChbXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSkoKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAoKCkgPT4gKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0KCcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSkpKCkpLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBzZWFyY2hfMS5JbnB1dCh7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmlucHV0LndtbC5pZCB9LCAnY2xhc3NOYW1lJzogX19jb250ZXh0LnZhbHVlcy5pbnB1dC5jbGFzc05hbWUsICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5pbnB1dC5uYW1lLCAnZGlzYWJsZWQnOiBfX2NvbnRleHQudmFsdWVzLmlucHV0LmRpc2FibGVkLCAnb25TZWFyY2gnOiBfX2NvbnRleHQudmFsdWVzLmlucHV0Lm9uU2VhcmNoIH0sIFtdKSwgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pbnB1dC53bWwuaWQgfSwgJ2NsYXNzTmFtZSc6IF9fY29udGV4dC52YWx1ZXMuaW5wdXQuY2xhc3NOYW1lLCAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMuaW5wdXQubmFtZSwgJ2Rpc2FibGVkJzogX19jb250ZXh0LnZhbHVlcy5pbnB1dC5kaXNhYmxlZCwgJ29uU2VhcmNoJzogX19jb250ZXh0LnZhbHVlcy5pbnB1dC5vblNlYXJjaCB9KVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHJlc3VsdHNfbWVudV8xLlJlc3VsdHNNZW51KHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMubWVudS53bWwuaWQgfSwgJ2Jsb2NrJzogX19jb250ZXh0LnZhbHVlcy5tZW51LmJsb2NrLCAnaGlkZGVuJzogdHJ1ZSwgJ29uU2VsZWN0JzogX19jb250ZXh0LnZhbHVlcy5tZW51Lm9uU2VsZWN0LCAnbm9JdGVtc1RlbXBsYXRlJzogX19jb250ZXh0LnZhbHVlcy5tZW51Lm5vSXRlbXNUZW1wbGF0ZSwgJ2l0ZW1UZW1wbGF0ZSc6IF9fY29udGV4dC52YWx1ZXMubWVudS5pdGVtVGVtcGxhdGUsICdzdHJpbmdpZmllcic6IF9fY29udGV4dC52YWx1ZXMubWVudS5zdHJpbmdpZmllciB9LCBbXSksIHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMubWVudS53bWwuaWQgfSwgJ2Jsb2NrJzogX19jb250ZXh0LnZhbHVlcy5tZW51LmJsb2NrLCAnaGlkZGVuJzogdHJ1ZSwgJ29uU2VsZWN0JzogX19jb250ZXh0LnZhbHVlcy5tZW51Lm9uU2VsZWN0LCAnbm9JdGVtc1RlbXBsYXRlJzogX19jb250ZXh0LnZhbHVlcy5tZW51Lm5vSXRlbXNUZW1wbGF0ZSwgJ2l0ZW1UZW1wbGF0ZSc6IF9fY29udGV4dC52YWx1ZXMubWVudS5pdGVtVGVtcGxhdGUsICdzdHJpbmdpZmllcic6IF9fY29udGV4dC52YWx1ZXMubWVudS5zdHJpbmdpZmllciB9KSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBoZWxwXzEuSGVscCh7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLm1lc3NhZ2VzLndtbC5pZCB9LCAndGV4dCc6IF9fY29udGV4dC52YWx1ZXMubWVzc2FnZXMudGV4dCB9LCBbXSksIHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMubWVzc2FnZXMud21sLmlkIH0sICd0ZXh0JzogX19jb250ZXh0LnZhbHVlcy5tZXNzYWdlcy50ZXh0IH0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tdWx0aS1zZWxlY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBhZ2VyID0gZXhwb3J0cy5QYWdlU2VsZWN0ZWRFdmVudCA9IGV4cG9ydHMuUEFHRVJfTkVYVCA9IGV4cG9ydHMuUEFHRVJfUFJFVklPVVMgPSBleHBvcnRzLlBBR0VSID0gdm9pZCAwO1xuY29uc3Qgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xuY29uc3QgX18xID0gcmVxdWlyZShcIi4uLy4uL1wiKTtcbmNvbnN0IF9fMiA9IHJlcXVpcmUoXCIuLi9cIik7XG5jb25zdCB2aWV3c18xID0gcmVxdWlyZShcIi4vdmlld3NcIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLlBBR0VSID0gJ3d3LXBhZ2VyJztcbmV4cG9ydHMuUEFHRVJfUFJFVklPVVMgPSAnd3ctcGFnZXJfX2ZpcnN0JztcbmV4cG9ydHMuUEFHRVJfTkVYVCA9ICd3dy1wYWdlcl9fbmV4dCc7XG4vLy9jbGFzc05hbWVzOmVuZFxuY29uc3QgUFJFVklPVVNfVEVYVCA9ICfihpAgUHJldmlvdXMnO1xuY29uc3QgTkVYVF9URVhUID0gJ05leHQg4oaSJztcbi8qKlxuICogUGFnZVNlbGVjdGVkRXZlbnQgaW5kaWNhdGVzIHRoZSB1c2VyIGhhcyBjbGlja2VkIG9uIGEgY29udHJvbCB0byBkaXNwbGF5XG4gKiBhIGRpZmZlcmVudCBwYWdlIGluIGEgcmVzdWx0IHNldC5cbiAqXG4gKiBUaGUgdmFsdWUgb2YgdGhpcyBldmVudCBpcyB0aGUgcGFnZSBudW1iZXIgdGhhdCB3YXMgc2VsZWN0ZWQuXG4gKi9cbmNsYXNzIFBhZ2VTZWxlY3RlZEV2ZW50IGV4dGVuZHMgX18yLkV2ZW50IHtcbn1cbmV4cG9ydHMuUGFnZVNlbGVjdGVkRXZlbnQgPSBQYWdlU2VsZWN0ZWRFdmVudDtcbi8qKlxuICogUGFnZXIgcHJvdmlkZXMgYSBjb250cm9sIGZvciBzdGVwIGJhY2t3YXJkcyBvciBmb3J3YXJkcyB0aHJvdWdoIHBhZ2luYXRlZFxuICogZGF0YS5cbiAqL1xuY2xhc3MgUGFnZXIgZXh0ZW5kcyB3bWxfMS5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3NfMS5QYWdlclZpZXcodGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6ICgwLCBfXzEuZ2V0SWQpKHRoaXMuYXR0cnMpLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAoMCwgdXRpbF8xLmNvbmNhdCkoZXhwb3J0cy5QQUdFUiwgdGhpcy5hdHRycy5jbGFzc05hbWUpLFxuICAgICAgICAgICAgY3VycmVudDogdGhpcy5hdHRycy5jdXJyZW50IHx8IDEsXG4gICAgICAgICAgICB0b3RhbDogdGhpcy5hdHRycy50b3RhbCB8fCAwLFxuICAgICAgICAgICAgcHJldmlvdXM6IHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGV4cG9ydHMuUEFHRVJfUFJFVklPVVMsXG4gICAgICAgICAgICAgICAgaXNEaXNhYmxlZDogKCkgPT4gKHRoaXMudmFsdWVzLmN1cnJlbnQgPD0gMSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMudmFsdWVzLnRvdGFsID09PSAwKSxcbiAgICAgICAgICAgICAgICB0ZXh0OiB0aGlzLmF0dHJzLnByZXZpb3VzVGV4dCB8fCBQUkVWSU9VU19URVhULFxuICAgICAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZXMuY3VycmVudCA9IHRoaXMudmFsdWVzLmN1cnJlbnQgLSAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmV4dDoge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogZXhwb3J0cy5QQUdFUl9ORVhULFxuICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuYXR0cnMubmV4dFRleHQgfHwgTkVYVF9URVhULFxuICAgICAgICAgICAgICAgIGlzRGlzYWJsZWQ6ICgpID0+IHRoaXMudmFsdWVzLmN1cnJlbnQgPj0gdGhpcy52YWx1ZXMudG90YWwsXG4gICAgICAgICAgICAgICAgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcy5jdXJyZW50ID0gdGhpcy52YWx1ZXMuY3VycmVudCArIDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZmlyZSgpIHtcbiAgICAgICAgdGhpcy52aWV3LmludmFsaWRhdGUoKTtcbiAgICAgICAgaWYgKHRoaXMuYXR0cnMub25DaGFuZ2UpXG4gICAgICAgICAgICB0aGlzLmF0dHJzLm9uQ2hhbmdlKG5ldyBQYWdlU2VsZWN0ZWRFdmVudCh0aGlzLmF0dHJzLm5hbWUgfHwgJycsIHRoaXMudmFsdWVzLmN1cnJlbnQpKTtcbiAgICB9XG59XG5leHBvcnRzLlBhZ2VyID0gUGFnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGFnZXJWaWV3ID0gdm9pZCAwO1xuY29uc3QgX19kb2N1bWVudCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbmNvbnN0IG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG5jb25zdCBsaW5rXzEgPSByZXF1aXJlKFwiLi4vLi4vY29udGVudC9saW5rXCIpO1xuO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9faWYgPSAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpID0+IChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0ID8gX19hbHQoKSA6IFtdO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9ySW4gPSAobGlzdCwgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2Zvck9mID0gKG8sIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHRleHQgPSBfX2RvY3VtZW50LnRleHQ7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHVuc2FmZSA9IF9fZG9jdW1lbnQudW5zYWZlO1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCBpc1NldCA9ICh2YWx1ZSkgPT4gdmFsdWUgIT0gbnVsbDtcbmNsYXNzIFBhZ2VyVmlldyB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ25hdicsIHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jbGFzc05hbWUgfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCd1bCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdsaScsIHsgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5wcmV2aW91cy5jbGFzc05hbWUgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgbGlua18xLkxpbmsoeyAnY2xhc3NOYW1lJzogJy13dy1uby1kZWNvcmF0aW9uJywgJ3RleHQnOiBfX2NvbnRleHQudmFsdWVzLnByZXZpb3VzLnRleHQsICdkaXNhYmxlZCc6IF9fY29udGV4dC52YWx1ZXMucHJldmlvdXMuaXNEaXNhYmxlZCgpLCAnb25DbGljayc6IF9fY29udGV4dC52YWx1ZXMucHJldmlvdXMub25DbGljayB9LCBbXSksIHsgJ2NsYXNzTmFtZSc6ICctd3ctbm8tZGVjb3JhdGlvbicsICd0ZXh0JzogX19jb250ZXh0LnZhbHVlcy5wcmV2aW91cy50ZXh0LCAnZGlzYWJsZWQnOiBfX2NvbnRleHQudmFsdWVzLnByZXZpb3VzLmlzRGlzYWJsZWQoKSwgJ29uQ2xpY2snOiBfX2NvbnRleHQudmFsdWVzLnByZXZpb3VzLm9uQ2xpY2sgfSlcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIC4uLihfX2NvbnRleHQuY2hpbGRyZW4pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnbGknLCB7ICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMubmV4dC5jbGFzc05hbWUgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgbGlua18xLkxpbmsoeyAnY2xhc3NOYW1lJzogJy13dy1uby1kZWNvcmF0aW9uJywgJ3RleHQnOiBfX2NvbnRleHQudmFsdWVzLm5leHQudGV4dCwgJ2Rpc2FibGVkJzogX19jb250ZXh0LnZhbHVlcy5uZXh0LmlzRGlzYWJsZWQoKSwgJ29uQ2xpY2snOiBfX2NvbnRleHQudmFsdWVzLm5leHQub25DbGljayB9LCBbXSksIHsgJ2NsYXNzTmFtZSc6ICctd3ctbm8tZGVjb3JhdGlvbicsICd0ZXh0JzogX19jb250ZXh0LnZhbHVlcy5uZXh0LnRleHQsICdkaXNhYmxlZCc6IF9fY29udGV4dC52YWx1ZXMubmV4dC5pc0Rpc2FibGVkKCksICdvbkNsaWNrJzogX19jb250ZXh0LnZhbHVlcy5uZXh0Lm9uQ2xpY2sgfSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLlBhZ2VyVmlldyA9IFBhZ2VyVmlldztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpZXdzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QYWdpbmF0b3IgPSBleHBvcnRzLlBvc2l0aW9uVmlld0NvbnRleHQgPSBleHBvcnRzLlBhZ2VDaGFuZ2VkRXZlbnQgPSBleHBvcnRzLlBBR0lOQVRPUl9MQVNUID0gZXhwb3J0cy5QQUdJTkFUT1JfTkVYVCA9IGV4cG9ydHMuUEFHSU5BVE9SX1BPU0lUSU9OID0gZXhwb3J0cy5QQUdJTkFUT1JfUFJFVklPVVMgPSBleHBvcnRzLlBBR0lOQVRPUl9GSVJTVCA9IGV4cG9ydHMuUEFHSU5BVE9SID0gdm9pZCAwO1xuY29uc3Qgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbmNvbnN0IHRpbWVyXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2NvbnRyb2wvdGltZXJcIik7XG5jb25zdCBkaXNhYmxlZF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRlbnQvc3RhdGUvZGlzYWJsZWRcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbmNvbnN0IF9fMSA9IHJlcXVpcmUoXCIuLi8uLi9cIik7XG5jb25zdCBfXzIgPSByZXF1aXJlKFwiLi4vXCIpO1xuY29uc3QgcGFnaW5hdG9yXzEgPSByZXF1aXJlKFwiLi93bWwvcGFnaW5hdG9yXCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5QQUdJTkFUT1IgPSAnd3ctcGFnaW5hdG9yJztcbmV4cG9ydHMuUEFHSU5BVE9SX0ZJUlNUID0gJ3d3LXBhZ2luYXRvcl9fZmlyc3QnO1xuZXhwb3J0cy5QQUdJTkFUT1JfUFJFVklPVVMgPSAnd3ctcGFnaW5hdG9yX19wcmV2aW91cyc7XG5leHBvcnRzLlBBR0lOQVRPUl9QT1NJVElPTiA9ICd3dy1wYWdpbmF0b3JfX3Bvc2l0aW9uJztcbmV4cG9ydHMuUEFHSU5BVE9SX05FWFQgPSAnd3ctcGFnaW5hdG9yX19uZXh0JztcbmV4cG9ydHMuUEFHSU5BVE9SX0xBU1QgPSAnd3ctcGFnaW5hdG9yX19sYXN0Jztcbi8qKlxuICogUGFnZUNoYW5nZWRFdmVudCBpbmRpY2F0aW5nIHRoZSBjdXJyZW50IHBhZ2UgaGFzIGJlZW4gY2hhbmdlZC5cbiAqL1xuY2xhc3MgUGFnZUNoYW5nZWRFdmVudCBleHRlbmRzIF9fMi5FdmVudCB7XG59XG5leHBvcnRzLlBhZ2VDaGFuZ2VkRXZlbnQgPSBQYWdlQ2hhbmdlZEV2ZW50O1xuLyoqXG4gKiBQb3NpdGlvblZpZXdDb250ZXh0IGNvbnRhaW5zIHRoZSBpbmZvIG5lZWRlZCB0byByZW5kZXIgdGhlIHBvc2l0b24gcGFydCBvZlxuICogdGhlIHBhZ2luYXRvci5cbiAqL1xuY2xhc3MgUG9zaXRpb25WaWV3Q29udGV4dCB7XG4gICAgY29uc3RydWN0b3IoY2xhc3NOYW1lLCBjdXJyZW50LCB0b3RhbCwgb25DaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IGN1cnJlbnQ7XG4gICAgICAgIHRoaXMudG90YWwgPSB0b3RhbDtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IG9uQ2hhbmdlO1xuICAgIH1cbn1cbmV4cG9ydHMuUG9zaXRpb25WaWV3Q29udGV4dCA9IFBvc2l0aW9uVmlld0NvbnRleHQ7XG4vKipcbiAqIFBhZ2luYXRvciBwcm92aWRlcyBhIGNvbnRyb2wgZm9yIG5hdmlnYXRpbmcgcGFnZWQgZGF0YSwgcmVzdWx0cywgdmlldyBldGMuXG4gKi9cbmNsYXNzIFBhZ2luYXRvciBleHRlbmRzIHdtbF8xLkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyBwYWdpbmF0b3JfMS5QYWdpbmF0b3JWaWV3KHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiAoMCwgX18xLmdldElkKSh0aGlzLmF0dHJzKSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogKDAsIHV0aWxfMS5jb25jYXQpKGV4cG9ydHMuUEFHSU5BVE9SLCAoMCwgX18xLmdldENsYXNzTmFtZSkodGhpcy5hdHRycykpLFxuICAgICAgICAgICAgY3VycmVudDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmN1cnJlbnQpID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5jdXJyZW50IDogMSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b3RhbDogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy50b3RhbCkgP1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMudG90YWwgOiAxLFxuICAgICAgICAgICAgZmlyc3Q6IHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGV4cG9ydHMuUEFHSU5BVE9SX0ZJUlNULFxuICAgICAgICAgICAgICAgIGlzRGlzYWJsZWQ6ICgpID0+ICh0aGlzLnZhbHVlcy5jdXJyZW50LnZhbHVlIDw9IDEpLFxuICAgICAgICAgICAgICAgIG9uY2xpY2s6IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZXMuY3VycmVudC52YWx1ZSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmV2aW91czoge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogZXhwb3J0cy5QQUdJTkFUT1JfUFJFVklPVVMsXG4gICAgICAgICAgICAgICAgaXNEaXNhYmxlZDogKCkgPT4gKHRoaXMudmFsdWVzLmN1cnJlbnQudmFsdWUgPD0gMSksXG4gICAgICAgICAgICAgICAgb25jbGljazogKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcy5jdXJyZW50LnZhbHVlID0gdGhpcy52YWx1ZXMuY3VycmVudC52YWx1ZSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogZXhwb3J0cy5QQUdJTkFUT1JfUE9TSVRJT04sXG4gICAgICAgICAgICAgICAgdmlldzogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3R4ID0gbmV3IFBvc2l0aW9uVmlld0NvbnRleHQodGhpcy52YWx1ZXMucG9zaXRpb24uY2xhc3NOYW1lLCB0aGlzLnZhbHVlcy5jdXJyZW50LnZhbHVlLCB0aGlzLnZhbHVlcy50b3RhbCwgKDAsIHRpbWVyXzEuZGVib3VuY2UpKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbiA9IE51bWJlcihlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgobiA+IDApICYmIChuIDw9IHRoaXMudmFsdWVzLnRvdGFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzLmN1cnJlbnQudmFsdWUgPSBuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCA1MDAwKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5wb3NpdGlvblZpZXcpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMucG9zaXRpb25WaWV3KGN0eCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IHBhZ2luYXRvcl8xLlBvc2l0aW9uVmlldyhjdHgpKS5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmV4dDoge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogZXhwb3J0cy5QQUdJTkFUT1JfTkVYVCxcbiAgICAgICAgICAgICAgICBpc0Rpc2FibGVkOiAoKSA9PiAodGhpcy52YWx1ZXMuY3VycmVudC52YWx1ZSA+PSB0aGlzLnZhbHVlcy50b3RhbCksXG4gICAgICAgICAgICAgICAgb25jbGljazogKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcy5jdXJyZW50LnZhbHVlID0gdGhpcy52YWx1ZXMuY3VycmVudC52YWx1ZSArIDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYXN0OiB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBleHBvcnRzLlBBR0lOQVRPUl9MQVNULFxuICAgICAgICAgICAgICAgIGlzRGlzYWJsZWQ6ICgpID0+ICh0aGlzLnZhbHVlcy5jdXJyZW50LnZhbHVlID49IHRoaXMudmFsdWVzLnRvdGFsKSxcbiAgICAgICAgICAgICAgICBvbmNsaWNrOiAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzLmN1cnJlbnQudmFsdWUgPSB0aGlzLnZhbHVlcy50b3RhbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpc2FibGVkOiB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBkaXNhYmxlZF8xLkRJU0FCTEVEXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZmlyZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5vbkNoYW5nZSlcbiAgICAgICAgICAgIHRoaXMuYXR0cnMub25DaGFuZ2UobmV3IFBhZ2VDaGFuZ2VkRXZlbnQodGhpcy5hdHRycy5uYW1lIHx8ICcnLCB0aGlzLnZhbHVlcy5jdXJyZW50LnZhbHVlKSk7XG4gICAgICAgIHRoaXMudmlldy5pbnZhbGlkYXRlKCk7XG4gICAgfVxufVxuZXhwb3J0cy5QYWdpbmF0b3IgPSBQYWdpbmF0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGFnaW5hdG9yVmlldyA9IGV4cG9ydHMuUG9zaXRpb25WaWV3ID0gdm9pZCAwO1xuY29uc3QgX19kb2N1bWVudCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbmNvbnN0IG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG5jb25zdCB0ZXh0X2lucHV0XzEgPSByZXF1aXJlKFwiLi4vLi4vdGV4dC1pbnB1dFwiKTtcbjtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBQb3NpdGlvblZpZXcge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdsaScsIHsgJ2NsYXNzJzogX19jb250ZXh0LmNsYXNzTmFtZSB9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3NwYW4nLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdQYWdlICcpLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyB0ZXh0X2lucHV0XzEuVGV4dElucHV0KHsgJ3R5cGUnOiAnbnVtYmVyJywgJ21hdGNoJzogJ1swLTldJywgJ3ZhbHVlJzogU3RyaW5nKF9fY29udGV4dC5jdXJyZW50KSwgJ29uQ2hhbmdlJzogX19jb250ZXh0Lm9uQ2hhbmdlIH0sIFtdKSwgeyAndHlwZSc6ICdudW1iZXInLCAnbWF0Y2gnOiAnWzAtOV0nLCAndmFsdWUnOiBTdHJpbmcoX19jb250ZXh0LmN1cnJlbnQpLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQub25DaGFuZ2UgfSksXG4gICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJyBvZiAnKSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dChfX2NvbnRleHQudG90YWwpXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5Qb3NpdGlvblZpZXcgPSBQb3NpdGlvblZpZXc7XG47XG5jbGFzcyBQYWdpbmF0b3JWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgndWwnLCB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuY2xhc3NOYW1lIH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnbGknLCB7ICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuZmlyc3QuY2xhc3NOYW1lIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgLi4uKChfX2NvbnRleHQudmFsdWVzLmZpcnN0LmlzRGlzYWJsZWQoKSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgKCgpID0+IChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3NwYW4nLCB7ICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuZGlzYWJsZWQuY2xhc3NOYW1lIH0sIFtdKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSkpKCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgKCgpID0+IChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2EnLCB7ICdocmVmJzogJyMnLCAnb25jbGljayc6IF9fY29udGV4dC52YWx1ZXMuZmlyc3Qub25jbGljayB9LCBbXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pKSgpKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdsaScsIHsgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5wcmV2aW91cy5jbGFzc05hbWUgfSwgW1xuICAgICAgICAgICAgICAgICAgICAuLi4oKF9fY29udGV4dC52YWx1ZXMucHJldmlvdXMuaXNEaXNhYmxlZCgpKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAoKCkgPT4gKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnc3BhbicsIHsgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5kaXNhYmxlZC5jbGFzc05hbWUgfSwgW10pXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSkoKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAoKCkgPT4gKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnYScsIHsgJ2hyZWYnOiAnIycsICdvbmNsaWNrJzogX19jb250ZXh0LnZhbHVlcy5wcmV2aW91cy5vbmNsaWNrIH0sIFtdKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSkpKCkpXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX19jb250ZXh0LnZhbHVlcy5wb3NpdGlvbi52aWV3KCksXG4gICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2xpJywgeyAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLm5leHQuY2xhc3NOYW1lIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgLi4uKChfX2NvbnRleHQudmFsdWVzLm5leHQuaXNEaXNhYmxlZCgpKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAoKCkgPT4gKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnc3BhbicsIHsgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5kaXNhYmxlZC5jbGFzc05hbWUgfSwgW10pXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSkoKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAoKCkgPT4gKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnYScsIHsgJ2hyZWYnOiAnIycsICdvbmNsaWNrJzogX19jb250ZXh0LnZhbHVlcy5uZXh0Lm9uY2xpY2sgfSwgW10pXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSkoKSlcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnbGknLCB7ICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMubGFzdC5jbGFzc05hbWUgfSwgW1xuICAgICAgICAgICAgICAgICAgICAuLi4oKF9fY29udGV4dC52YWx1ZXMubGFzdC5pc0Rpc2FibGVkKCkpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICgoKSA9PiAoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdzcGFuJywgeyAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmRpc2FibGVkLmNsYXNzTmFtZSB9LCBbXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pKSgpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICgoKSA9PiAoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdhJywgeyAnaHJlZic6ICcjJywgJ29uY2xpY2snOiBfX2NvbnRleHQudmFsdWVzLmxhc3Qub25jbGljayB9LCBbXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pKSgpKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuUGFnaW5hdG9yVmlldyA9IFBhZ2luYXRvclZpZXc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWdpbmF0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJhbmdlZFBhZ2VyID0gZXhwb3J0cy5SQU5HRURfUEFHRVJfUEFHRSA9IGV4cG9ydHMuUkFOR0VEX1BBR0VSID0gdm9pZCAwO1xuY29uc3Qgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbmNvbnN0IGFycmF5XzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvYXJyYXlcIik7XG5jb25zdCBhY3RpdmVfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZW50L3N0YXRlL2FjdGl2ZVwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xuY29uc3QgX18xID0gcmVxdWlyZShcIi4uLy4uL1wiKTtcbmNvbnN0IHBhZ2VyXzEgPSByZXF1aXJlKFwiLi4vcGFnZXJcIik7XG5jb25zdCB2aWV3c18xID0gcmVxdWlyZShcIi4vdmlld3NcIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLlJBTkdFRF9QQUdFUiA9ICd3dy1yYW5nZWQtcGFnZXInO1xuZXhwb3J0cy5SQU5HRURfUEFHRVJfUEFHRSA9ICd3dy1yYW5nZWQtcGFnZXJfX3BhZ2UnO1xuLyoqXG4gKiBSYW5nZWRQYWdlciBwcm92aWRlcyBhIHZhcmlhbnQgb2YgdGhlIFtbUGFnZXJdXSBjb250cm9sIHRoYXQgcHJvdmlkZXNcbiAqIGFkZGl0aW9uYWwgYnV0dG9ucyBmb3Igc2VsZWN0aW5nIHNwZWNpZmljIHBhZ2VzLlxuICovXG5jbGFzcyBSYW5nZWRQYWdlciBleHRlbmRzIHdtbF8xLkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3c18xLlJhbmdlZFBhZ2VyVmlldyh0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBpZDogKDAsIF9fMS5nZXRJZCkodGhpcy5hdHRycyksXG4gICAgICAgICAgICBjbGFzc05hbWU6ICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLlJBTkdFRF9QQUdFUiwgdGhpcy5hdHRycy5jbGFzc05hbWUpLFxuICAgICAgICAgICAgY3VycmVudDogdGhpcy5hdHRycy5jdXJyZW50IHx8IDEsXG4gICAgICAgICAgICB0b3RhbDogdGhpcy5hdHRycy50b3RhbCB8fCAxLFxuICAgICAgICAgICAgcGFnZXM6IHBhZ2luYXRlKHRoaXMuYXR0cnMubWF4IHx8IHRoaXMuYXR0cnMudG90YWwgfHwgMSwgdGhpcy5hdHRycy50b3RhbCB8fCAxLCB0aGlzLmF0dHJzLmN1cnJlbnQgfHwgMSksXG4gICAgICAgICAgICBvbkNoYW5nZTogKGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcy5jdXJyZW50ID0gZS52YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYWdlOiB7XG4gICAgICAgICAgICAgICAgZ2V0Q2xhc3NOYW1lOiAoaSkgPT4gKDAsIHV0aWxfMS5jb25jYXQpKGV4cG9ydHMuUkFOR0VEX1BBR0VSX1BBR0UsIChpID09PSB0aGlzLnZhbHVlcy5jdXJyZW50KSA/IGFjdGl2ZV8xLkFDVElWRSA6ICcnKSxcbiAgICAgICAgICAgICAgICBvbkNsaWNrOiAoaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcy5jdXJyZW50ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmaXJlKCkge1xuICAgICAgICAvLyBYWFg6IFRoZXJlIGlzIGEgYnVnIGluIHdtbCB0aGF0IHByZXZlbnRzIGludmFsaWRhdGluZyBhIHZpZXcgd2hvc2VcbiAgICAgICAgLy8gcm9vdCBpcyBhbm90aGVyIHdtbCB3aWRnZXQuIFRoaXMgdmlldyB3aWxsIG5vdCBoYXZlIGEgcGFyZW50IGVsZW1lbnQgXG4gICAgICAgIC8vIHNvIHdlIG11c3QgaW52YWxpZGF0ZSB0aGUgUGFnZXIgdmlldy5cbiAgICAgICAgKDAsIHV0aWxfMS5nZXRCeUlkKSh0aGlzLnZpZXcsIFwicGFnZXJcIikubWFwKHcgPT4gdy52aWV3LmludmFsaWRhdGUoKSk7XG4gICAgICAgIGlmICh0aGlzLmF0dHJzLm9uQ2hhbmdlKVxuICAgICAgICAgICAgdGhpcy5hdHRycy5vbkNoYW5nZShuZXcgcGFnZXJfMS5QYWdlU2VsZWN0ZWRFdmVudCh0aGlzLmF0dHJzLm5hbWUgfHwgJycsIHRoaXMudmFsdWVzLmN1cnJlbnQpKTtcbiAgICB9XG59XG5leHBvcnRzLlJhbmdlZFBhZ2VyID0gUmFuZ2VkUGFnZXI7XG5jb25zdCBwYWdpbmF0ZSA9IChtYXgsIHRvdGFsLCBjdXJyZW50KSA9PiB7XG4gICAgbGV0IGFsbFBhZ2VzID0gKDAsIGFycmF5XzEubWFrZSkodG90YWwsIGkgPT4gaSArIDEpO1xuICAgIGlmIChhbGxQYWdlcy5sZW5ndGggPD0gbWF4KVxuICAgICAgICByZXR1cm4gYWxsUGFnZXM7XG4gICAgLy8gVGhlIHRvdGFsIGRpc3RhbmNlIGZyb20gdGhlIGN1cnJlbnQgdG8gZW5kIGluIGJvdGggZGlyZWN0aW9uIGFjY291dGluZ1xuICAgIC8vIGZvciB0aGUgZmFjdCB0aGF0IHRoZSBzdGFydCwgY3VycmVudCBhbmQgZW5kIHBhZ2VzIG11c3QgYmUgcHJlc2VudC4gVGhpc1xuICAgIC8vIGlzIHRoZSByZWFsIG51bWJlciBvZiBzcGFjZXMgd2UgaGF2ZSBmb3IgcGFnZXMuXG4gICAgbGV0IHRvdGFsQWxsb3dlZCA9IG1heCAtIDM7XG4gICAgbGV0IGRpc3RhbmNlT25lV2F5ID0gTWF0aC5mbG9vcih0b3RhbEFsbG93ZWQgLyAyKTtcbiAgICAvL0NhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgZnJvbSBjdXJyZW50IC0+IHN0YXJ0IHdlIHdpbGwgYWxsb3cuIFdoZW4gdGhlIFxuICAgIC8vbnVtYmVyIG9mIHNwYWNlcyBhdmFpbGFibGUgaXMgbm90IGV2ZW4sIHdlIGdpdmUgdGhlIGV4dHJhIHBhZ2UgdG8gc3RhcnQuXG4gICAgbGV0IHN0YXJ0RGlzdGFuY2UgPSBkaXN0YW5jZU9uZVdheSArICh0b3RhbEFsbG93ZWQgJSAyKTtcbiAgICBsZXQgZGlzdGFuY2VGcm9tU3RhcnQgPSBjdXJyZW50IC0gMTtcbiAgICAvLyBUaGUgcmVtYWluaW5nIG51bWJlciBvZiBwYWdlcyBvbmNlIGFsbCB0aGUgcGFnZXMgZnJvbSBjdXJyZW50IGJhY2sgdG9cbiAgICAvLyBzdGFydCBoYXZlIGJlZW4gZmlsbGVkLiBUaGlzIGNhbiBiZSBuZWdhdGl2ZSBpbmRpY2F0aW5nIHN0YXJ0LWN1cnJlbnRcbiAgICAvLyB3aWxsIG5vdCBmaXQgaW4gZGlzdGFuY2VPbmVXYXkuXG4gICAgbGV0IHN0YXJ0UmVtYWluZGVyID0gc3RhcnREaXN0YW5jZSAtIGRpc3RhbmNlRnJvbVN0YXJ0O1xuICAgIC8vQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBmcm9tIGN1cnJlbnQgLT4gZW5kIHdlIHdpbGwgYWxsb3cuIEFueXRoaW5nIGxlZnRvdmVyXG4gICAgLy9mcm9tICBzdGFydERpc3RhbmNlIGlzIGFkZGVkIGhlcmUuXG4gICAgbGV0IGVuZERpc3RhbmNlID0gKHN0YXJ0UmVtYWluZGVyID4gMCkgP1xuICAgICAgICBkaXN0YW5jZU9uZVdheSArIHN0YXJ0UmVtYWluZGVyIDpcbiAgICAgICAgZGlzdGFuY2VPbmVXYXk7XG4gICAgbGV0IGRpc3RhbmNlRnJvbUVuZCA9IHRvdGFsIC0gY3VycmVudDtcbiAgICBsZXQgZW5kUmVtYWluZGVyID0gZW5kRGlzdGFuY2UgLSBkaXN0YW5jZUZyb21FbmQ7XG4gICAgLy8gSWYgd2UgaGF2ZSBhIHJlbWFpbmRlciBoZXJlLCB3ZSBjYW4gZ2l2ZSBpdCBiYWNrIHRvIGN1cnJlbnQgLT4gc3RhcnQuXG4gICAgaWYgKGVuZFJlbWFpbmRlciA+IDApXG4gICAgICAgIHN0YXJ0RGlzdGFuY2UgPSBzdGFydERpc3RhbmNlICsgZW5kUmVtYWluZGVyO1xuICAgIHJldHVybiBhbGxQYWdlcy5tYXAocGFnZSA9PiB7XG4gICAgICAgIGlmICgoKHBhZ2UgPCBjdXJyZW50KSAmJiAocGFnZSAhPSAxKSkgJiZcbiAgICAgICAgICAgICgoY3VycmVudCAtIHBhZ2UpID49IHN0YXJ0RGlzdGFuY2UpKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGlmICgoKHBhZ2UgPiBjdXJyZW50KSAmJiAocGFnZSAhPSB0b3RhbCkpICYmXG4gICAgICAgICAgICAoKHBhZ2UgLSBjdXJyZW50KSA+PSBlbmREaXN0YW5jZSkpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgcmV0dXJuIHBhZ2U7XG4gICAgfSkuZmlsdGVyKChwYWdlLCBpZHgsIGxpc3QpID0+ICgobGlzdFtpZHggLSAxXSA9PT0gMCkgJiYgKHBhZ2UgPT09IDApKSA/IGZhbHNlIDogdHJ1ZSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJhbmdlZFBhZ2VyVmlldyA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuY29uc3QgbGlua18xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRlbnQvbGlua1wiKTtcbjtcbmNvbnN0IHBhZ2VyXzEgPSByZXF1aXJlKFwiLi4vcGFnZXJcIik7XG47XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgUmFuZ2VkUGFnZXJWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KG5ldyBwYWdlcl8xLlBhZ2VyKHsgd21sOiB7ICdpZCc6ICdwYWdlcicgfSwgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pZCwgJ2NsYXNzTmFtZSc6IF9fY29udGV4dC52YWx1ZXMuY2xhc3NOYW1lLCAnY3VycmVudCc6IF9fY29udGV4dC52YWx1ZXMuY3VycmVudCwgJ3RvdGFsJzogX19jb250ZXh0LnZhbHVlcy50b3RhbCwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5vbkNoYW5nZSB9LCBbXG4gICAgICAgICAgICAgICAgLi4uX19mb3JJbihfX2NvbnRleHQudmFsdWVzLnBhZ2VzLCAoaWR4LCBfJCRpLCBfJCRhbGwpID0+IChbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdsaScsIHsgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5wYWdlLmdldENsYXNzTmFtZShpZHgpIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLigoKGlkeCA9PT0gMCkpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKCkgPT4gKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgbGlua18xLkxpbmsoeyAnY2xhc3NOYW1lJzogJy13dy1uby1kZWNvcmF0aW9uJywgJ2Rpc2FibGVkJzogdHJ1ZSwgJ3RleHQnOiAn4oCmJyB9LCBbXSksIHsgJ2NsYXNzTmFtZSc6ICctd3ctbm8tZGVjb3JhdGlvbicsICdkaXNhYmxlZCc6IHRydWUsICd0ZXh0JzogJ+KApicgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSkoKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCgpID0+IChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGxpbmtfMS5MaW5rKHsgJ2NsYXNzTmFtZSc6ICctd3ctbm8tZGVjb3JhdGlvbicsICd0ZXh0JzogU3RyaW5nKGlkeCksICdvbkNsaWNrJzogKCkgPT4gX19jb250ZXh0LnZhbHVlcy5wYWdlLm9uQ2xpY2soaWR4KSB9LCBbXSksIHsgJ2NsYXNzTmFtZSc6ICctd3ctbm8tZGVjb3JhdGlvbicsICd0ZXh0JzogU3RyaW5nKGlkeCksICdvbkNsaWNrJzogKCkgPT4gX19jb250ZXh0LnZhbHVlcy5wYWdlLm9uQ2xpY2soaWR4KSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pKSgpKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pLCAoKSA9PiAoW10pKVxuICAgICAgICAgICAgXSksIHsgd21sOiB7ICdpZCc6ICdwYWdlcicgfSwgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pZCwgJ2NsYXNzTmFtZSc6IF9fY29udGV4dC52YWx1ZXMuY2xhc3NOYW1lLCAnY3VycmVudCc6IF9fY29udGV4dC52YWx1ZXMuY3VycmVudCwgJ3RvdGFsJzogX19jb250ZXh0LnZhbHVlcy50b3RhbCwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5vbkNoYW5nZSB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuUmFuZ2VkUGFnZXJWaWV3ID0gUmFuZ2VkUGFnZXJWaWV3O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlld3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlc3VsdHNNZW51ID0gZXhwb3J0cy5JdGVtU2VsZWN0ZWRFdmVudCA9IGV4cG9ydHMuUkVTVUxUU19NRU5VID0gdm9pZCAwO1xuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbmNvbnN0IHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG5jb25zdCBfXzEgPSByZXF1aXJlKFwiLi4vLi4vXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG5jb25zdCBfXzIgPSByZXF1aXJlKFwiLi4vXCIpO1xuY29uc3QgcmVzdWx0c19tZW51XzEgPSByZXF1aXJlKFwiLi93bWwvcmVzdWx0cy1tZW51XCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5SRVNVTFRTX01FTlUgPSAnd3ctcmVzdWx0cy1tZW51Jztcbi8qKlxuICogSXRlbVNlbGVjdGVkRXZlbnRcbiAqL1xuY2xhc3MgSXRlbVNlbGVjdGVkRXZlbnQgZXh0ZW5kcyBfXzIuRXZlbnQge1xufVxuZXhwb3J0cy5JdGVtU2VsZWN0ZWRFdmVudCA9IEl0ZW1TZWxlY3RlZEV2ZW50O1xuLyoqXG4gKiBSZXN1bHRzTWVudSB1c2VkIHRvIGRpc3BsYXkgcmVzdWx0cyBpbiBzZWxlY3Qgc3R5bGVkIGNvbnRyb2xzLlxuICovXG5jbGFzcyBSZXN1bHRzTWVudSBleHRlbmRzIHdtbF8xLkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyByZXN1bHRzX21lbnVfMS5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgIGlkOiAnbWVudSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmVlOiAoMCwgbWF5YmVfMS5ub3RoaW5nKSgpLFxuICAgICAgICAgICAgcmVzdWx0czogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5yZXN1bHRzKSA/XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRycy5yZXN1bHRzIDogW10sXG4gICAgICAgICAgICBuYW1lOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLm5hbWUpID9cbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLm5hbWUgOiAnJyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogKDAsIHV0aWxfMS5jb25jYXQpKGV4cG9ydHMuUkVTVUxUU19NRU5VLCAoMCwgX18xLmdldENsYXNzTmFtZSkodGhpcy5hdHRycykpLFxuICAgICAgICAgICAgYmxvY2s6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuYmxvY2spID9cbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLmJsb2NrIDogZmFsc2UsXG4gICAgICAgICAgICBoaWRkZW46ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuaGlkZGVuKSA/XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRycy5oaWRkZW4gOiBmYWxzZSxcbiAgICAgICAgICAgIGl0ZW06IHtcbiAgICAgICAgICAgICAgICBzdHJpbmdpZmllcjogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5zdHJpbmdpZmllcikgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLnN0cmluZ2lmaWVyIDogKHYpID0+IE9iamVjdC50b1N0cmluZy5jYWxsKHYpLFxuICAgICAgICAgICAgICAgIGNsaWNrOiAoaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5vblNlbGVjdClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMub25TZWxlY3QobmV3IEl0ZW1TZWxlY3RlZEV2ZW50KHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5uYW1lIHx8ICcnLCB0aGlzLnZhbHVlcy5yZXN1bHRzW2luZGV4XSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IChyZXN1bHQsIGluZGV4KSA9PiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLml0ZW1UZW1wbGF0ZSkgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLml0ZW1UZW1wbGF0ZShyZXN1bHQsIGluZGV4LCB0aGlzKSA6XG4gICAgICAgICAgICAgICAgICAgIG5ldyByZXN1bHRzX21lbnVfMS5JdGVtVGVtcGxhdGVWaWV3KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbjogdGhpcy52YWx1ZXMuaXRlbS5zdHJpbmdpZmllcihyZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIG5vSXRlbXNUZW1wbGF0ZTogKCkgPT4gKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5ub0l0ZW1zVGVtcGxhdGUpID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5ub0l0ZW1zVGVtcGxhdGUgOiBuZXcgcmVzdWx0c19tZW51XzEuTm9JdGVtc1RlbXBsYXRlVmlldyh7fSksXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIG9wZW4oKSB7XG4gICAgICAgICgwLCB1dGlsXzEuZ2V0QnlJZCkodGhpcy52aWV3LCB0aGlzLnZhbHVlcy53bWwuaWQpXG4gICAgICAgICAgICAubWFwKChtKSA9PiBtLnNob3coKSk7XG4gICAgICAgIHRoaXMudmFsdWVzLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLm9uT3BlbilcbiAgICAgICAgICAgIHRoaXMuYXR0cnMub25PcGVuKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgKDAsIHV0aWxfMS5nZXRCeUlkKSh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLndtbC5pZClcbiAgICAgICAgICAgIC5tYXAoKG0pID0+IG0uaGlkZSgpKTtcbiAgICAgICAgdGhpcy52YWx1ZXMuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5vbkNsb3NlKVxuICAgICAgICAgICAgdGhpcy5hdHRycy5vbkNsb3NlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b2dnbGUoKSB7XG4gICAgICAgICgwLCB1dGlsXzEuZ2V0QnlJZCkodGhpcy52aWV3LCB0aGlzLnZhbHVlcy53bWwuaWQpXG4gICAgICAgICAgICAubWFwKChtKSA9PiBtLnRvZ2dsZSgpKTtcbiAgICAgICAgdGhpcy52YWx1ZXMuaGlkZGVuID0gIXRoaXMudmFsdWVzLmhpZGRlbjtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVzLmhpZGRlbiA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgdGhpcy5hdHRycyAmJlxuICAgICAgICAgICAgdGhpcy5hdHRycy5vbkNsb3NlKVxuICAgICAgICAgICAgdGhpcy5hdHRycy5vbkNsb3NlKCk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudmFsdWVzLmhpZGRlbiA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgIHRoaXMuYXR0cnMgJiZcbiAgICAgICAgICAgIHRoaXMuYXR0cnMub25PcGVuKVxuICAgICAgICAgICAgdGhpcy5hdHRycy5vbk9wZW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGhhbmRsZUV2ZW50KGUpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVzLnRyZWUuaXNKdXN0KCkpIHtcbiAgICAgICAgICAgIGxldCByb290ID0gdGhpcy52YWx1ZXMudHJlZS5nZXQoKTtcbiAgICAgICAgICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyhyb290KSlcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMpO1xuICAgICAgICAgICAgaWYgKCghcm9vdC5jb250YWlucyhlLnRhcmdldCkpKVxuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiB1cGRhdGUgd2lsbCBjYXVzZSB0aGUgbWVudSB0byBiZSBkaXNwbGF5ZWQuXG4gICAgICovXG4gICAgdXBkYXRlKHJlc3VsdHMpIHtcbiAgICAgICAgdGhpcy52YWx1ZXMucmVzdWx0cyA9IHJlc3VsdHM7XG4gICAgICAgIHRoaXMudmFsdWVzLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLnZpZXcuaW52YWxpZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLnZhbHVlcy50cmVlID0gKDAsIG1heWJlXzEuanVzdCkodGhpcy52aWV3LnJlbmRlcigpKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcyk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXMudHJlZS5nZXQoKTtcbiAgICB9XG59XG5leHBvcnRzLlJlc3VsdHNNZW51ID0gUmVzdWx0c01lbnU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWFpbiA9IGV4cG9ydHMuTm9JdGVtc1RlbXBsYXRlVmlldyA9IGV4cG9ydHMuSXRlbVRlbXBsYXRlVmlldyA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuY29uc3QgbGlua18xID0gcmVxdWlyZShcIi4uLy4uLy4uL2NvbnRlbnQvbGlua1wiKTtcbjtcbmNvbnN0IG1lbnVfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9tZW51L21lbnVcIik7XG47XG5jb25zdCBpdGVtXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vbWVudS9pdGVtXCIpO1xuO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9faWYgPSAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpID0+IChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0ID8gX19hbHQoKSA6IFtdO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9ySW4gPSAobGlzdCwgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2Zvck9mID0gKG8sIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHRleHQgPSBfX2RvY3VtZW50LnRleHQ7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHVuc2FmZSA9IF9fZG9jdW1lbnQudW5zYWZlO1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCBpc1NldCA9ICh2YWx1ZSkgPT4gdmFsdWUgIT0gbnVsbDtcbjtcbmNsYXNzIEl0ZW1UZW1wbGF0ZVZpZXcge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdzcGFuJywge30sIFtcbiAgICAgICAgICAgICAgICB0ZXh0KF9fY29udGV4dC5vcHRpb24pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuSXRlbVRlbXBsYXRlVmlldyA9IEl0ZW1UZW1wbGF0ZVZpZXc7XG47XG5jbGFzcyBOb0l0ZW1zVGVtcGxhdGVWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnYicsIHt9LCBbXG4gICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnTm8gcmVzdWx0cyB0byBkaXNwbGF5LicpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuTm9JdGVtc1RlbXBsYXRlVmlldyA9IE5vSXRlbXNUZW1wbGF0ZVZpZXc7XG47XG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KG5ldyBtZW51XzEuTWVudSh7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLndtbC5pZCB9LCAnY2xhc3NOYW1lJzogX19jb250ZXh0LnZhbHVlcy5jbGFzc05hbWUsICdibG9jayc6IF9fY29udGV4dC52YWx1ZXMuYmxvY2ssICdoaWRkZW4nOiBfX2NvbnRleHQudmFsdWVzLmhpZGRlbiB9LCBbXG4gICAgICAgICAgICAgICAgLi4uX19mb3JJbihfX2NvbnRleHQudmFsdWVzLnJlc3VsdHMsIChyZXN1bHQsIGluZGV4LCBfJCRhbGwpID0+IChbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGl0ZW1fMS5JdGVtKHsgJ25hbWUnOiAoJycgKyBpbmRleCkgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgbGlua18xLkxpbmsoeyAnb25DbGljayc6ICgpID0+IF9fY29udGV4dC52YWx1ZXMuaXRlbS5jbGljayhpbmRleCkgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5yZWdpc3RlclZpZXcoX19jb250ZXh0LnZhbHVlcy5pdGVtLnRlbXBsYXRlKHJlc3VsdCwgaW5kZXgpKS5yZW5kZXIoKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksIHsgJ29uQ2xpY2snOiAoKSA9PiBfX2NvbnRleHQudmFsdWVzLml0ZW0uY2xpY2soaW5kZXgpIH0pXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7ICduYW1lJzogKCcnICsgaW5kZXgpIH0pXG4gICAgICAgICAgICAgICAgXSksICgpID0+IChbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5yZWdpc3RlclZpZXcoX19jb250ZXh0LnZhbHVlcy5pdGVtLm5vSXRlbXNUZW1wbGF0ZSgpKS5yZW5kZXIoKVxuICAgICAgICAgICAgICAgIF0pKVxuICAgICAgICAgICAgXSksIHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMud21sLmlkIH0sICdjbGFzc05hbWUnOiBfX2NvbnRleHQudmFsdWVzLmNsYXNzTmFtZSwgJ2Jsb2NrJzogX19jb250ZXh0LnZhbHVlcy5ibG9jaywgJ2hpZGRlbic6IF9fY29udGV4dC52YWx1ZXMuaGlkZGVuIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc3VsdHMtbWVudS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudG9nZ2xlTWVudSA9IGV4cG9ydHMuY2xvc2VNZW51ID0gZXhwb3J0cy5vcGVuTWVudSA9IGV4cG9ydHMudXBkYXRlTWVudSA9IGV4cG9ydHMuU2VhcmNoID0gZXhwb3J0cy5JbnB1dCA9IGV4cG9ydHMuRXNjYXBlRXZlbnQgPSBleHBvcnRzLkZvY3VzTG9zdEV2ZW50ID0gZXhwb3J0cy5Gb2N1c0dhaW5lZEV2ZW50ID0gZXhwb3J0cy5UZXJtQ2hhbmdlZEV2ZW50ID0gZXhwb3J0cy5TRUFSQ0hfSU5QVVQgPSBleHBvcnRzLlNFQVJDSCA9IGV4cG9ydHMuRVNDQVBFID0gZXhwb3J0cy5JdGVtU2VsZWN0ZWRFdmVudCA9IHZvaWQgMDtcbmNvbnN0IHZpZXdzID0gcmVxdWlyZShcIi4vd21sL3NlYXJjaFwiKTtcbmNvbnN0IHRpbWVyXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2NvbnRyb2wvdGltZXJcIik7XG5jb25zdCBvcmllbnRhdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRlbnQvb3JpZW50YXRpb25cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbmNvbnN0IHJlc3VsdHNfbWVudV8xID0gcmVxdWlyZShcIi4uL3Jlc3VsdHMtbWVudVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkl0ZW1TZWxlY3RlZEV2ZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZXN1bHRzX21lbnVfMS5JdGVtU2VsZWN0ZWRFdmVudDsgfSB9KTtcbmNvbnN0IF9fMSA9IHJlcXVpcmUoXCIuLi8uLi9cIik7XG5jb25zdCBfXzIgPSByZXF1aXJlKFwiLi4vXCIpO1xuLyoqXG4gKiBFU0NBUEUga2V5IGNvZGUuXG4gKi9cbmV4cG9ydHMuRVNDQVBFID0gMjc7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLlNFQVJDSCA9ICd3dy1zZWFyY2gnO1xuZXhwb3J0cy5TRUFSQ0hfSU5QVVQgPSAnd3ctc2VhcmNoX19pbnB1dCc7XG4vKipcbiAqIFRlcm1DaGFuZ2VkRXZlbnQgc2lnbmFscyB0aGUgc2VhcmNoIHRlcm0gaGFzIGNoYW5nZWQuXG4gKi9cbmNsYXNzIFRlcm1DaGFuZ2VkRXZlbnQgZXh0ZW5kcyBfXzIuRXZlbnQge1xufVxuZXhwb3J0cy5UZXJtQ2hhbmdlZEV2ZW50ID0gVGVybUNoYW5nZWRFdmVudDtcbi8qKlxuICogRm9jdXNHYWluZWRFdmVudCBzaWduYWxzIHRoZSB1c2VyIGFzIGdpdmVuIGZvY3VzIHRvIHRoZSBjb250cm9sLlxuICovXG5jbGFzcyBGb2N1c0dhaW5lZEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgfVxufVxuZXhwb3J0cy5Gb2N1c0dhaW5lZEV2ZW50ID0gRm9jdXNHYWluZWRFdmVudDtcbi8qKlxuICogRm9jdXNMb3N0RXZlbnQgc2lnbmFscyB0aGUgdXNlciBoYXMgcmVtb3ZlZCBmb2N1cyBmcm9tIHRoZSBjb250cm9sLlxuICovXG5jbGFzcyBGb2N1c0xvc3RFdmVudCB7XG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cbn1cbmV4cG9ydHMuRm9jdXNMb3N0RXZlbnQgPSBGb2N1c0xvc3RFdmVudDtcbi8qKlxuICogRXNjYXBlRXZlbnQgc2lnbmFscyB0aGUgdXNlciBoYXMgcHJlc3NlZCB0aGUgZXNjYXBlIGtleSB3aGlsZSB0eXBpbmcuXG4gKi9cbmNsYXNzIEVzY2FwZUV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgfVxufVxuZXhwb3J0cy5Fc2NhcGVFdmVudCA9IEVzY2FwZUV2ZW50O1xuLyoqXG4gKiBJbnB1dCBwcm92aWRlcyB0aGUgaW5wdXQgcGFydCBvZiBhIFNlYXJjaCBjb250cm9sLlxuICpcbiAqIFRoaXMgaXMgaGVyZSBtb3N0bHkgZm9yIGNvZGUgcmUtdXNlLlxuICovXG5jbGFzcyBJbnB1dCBleHRlbmRzIF9fMi5BYnN0cmFjdENvbnRyb2wge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuSW5wdXRWaWV3KHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHdtbDogeyBpZDogJ3Jvb3QnIH0sXG4gICAgICAgICAgICBjbGFzc05hbWU6ICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLlNFQVJDSF9JTlBVVCwgKDAsIF9fMS5nZXRDbGFzc05hbWUpKHRoaXMuYXR0cnMpKSxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLnBsYWNlaG9sZGVyKSA/XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRycy5wbGFjZWhvbGRlciA6ICcnLFxuICAgICAgICAgICAgcmVhZE9ubHk6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMucmVhZE9ubHkpIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGRpc2FibGVkOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmRpc2FibGVkKSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICBhdXRvY29tcGxldGU6ICdkbyBub3QgZW5hYmxlIHBsZWFzZScsXG4gICAgICAgICAgICBhdXRvZm9jdXM6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuYXV0b2ZvY3VzKSA/XG4gICAgICAgICAgICAgICAgdHJ1ZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHNpemU6IFN0cmluZygodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLnNpemUpID9cbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLnNpemUgOiAyMCksXG4gICAgICAgICAgICB2YWx1ZTogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy52YWx1ZSkgP1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMudmFsdWUgOiAnJyxcbiAgICAgICAgICAgIG9uZm9jdXM6IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMub25Gb2N1cylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5vbkZvY3VzKG5ldyBGb2N1c0dhaW5lZEV2ZW50KHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5uYW1lIHx8ICcnKSk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnZhbHVlID0gdGFyZ2V0LnZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9ua2V5dXA6IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gZXhwb3J0cy5FU0NBUEUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5vbkVzY2FwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMub25Fc2NhcGUobmV3IEVzY2FwZUV2ZW50KHRoaXMuYXR0cnMubmFtZSB8fCAnJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlU2VhcmNoKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbmlucHV0OiAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vRm9yIGNvbXBhdGFiaWxpdHkgcmVhc29uc1xuICAgICAgICAgICAgICAgIGUudGFyZ2V0Lm9uaW5wdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzLm9ua2V5dXAoZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25ibHVyOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5vbkJsdXIpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMub25CbHVyKG5ldyBGb2N1c0xvc3RFdmVudCh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMubmFtZSB8fCAnJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBmaXJlU2VhcmNoKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5vblNlYXJjaCkge1xuICAgICAgICAgICAgbGV0IG5hbWUgPSAnJyArIHRoaXMuYXR0cnMubmFtZTtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGUudGFyZ2V0LnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5hdHRycy5vblNlYXJjaChuZXcgVGVybUNoYW5nZWRFdmVudChuYW1lLCB2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlcmVkKCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZXMuYXV0b2ZvY3VzID09PSB0cnVlKVxuICAgICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBmb2N1cyBzdGVhbHMgdXNlciBmb2N1cyB0byB0aGUgSW5wdXQuXG4gICAgICovXG4gICAgZm9jdXMoKSB7XG4gICAgICAgICgwLCB0aW1lcl8xLnRpY2spKCgpID0+IGdldElucHV0KHRoaXMpLm1hcChpID0+IGkuZm9jdXMoKSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogc2V0U2l6ZSBzZXRzIHRoZSBzaXplIG9mIHRoZSBpbnB1dC5cbiAgICAgKi9cbiAgICBzZXRTaXplKG4pIHtcbiAgICAgICAgdGhpcy52YWx1ZXMuc2l6ZSA9IFN0cmluZyhuKTtcbiAgICAgICAgZ2V0SW5wdXQodGhpcykubWFwKGkgPT4gaS5zZXRBdHRyaWJ1dGUoJ3NpemUnLCBTdHJpbmcobikpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldFNpemUgcmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgKGludGVybmFsbHkgdHJhY2tlZCkgc2l6ZVxuICAgICAqIG9mIHRoZSBJbnB1dC5cbiAgICAgKi9cbiAgICBnZXRTaXplKCkge1xuICAgICAgICByZXR1cm4gTnVtYmVyKHRoaXMudmFsdWVzLnNpemUpO1xuICAgIH1cbn1cbmV4cG9ydHMuSW5wdXQgPSBJbnB1dDtcbi8qKlxuICogU2VhcmNoIHByb3ZpZGVzIGFuIGlucHV0IHRoYXQgY2FuIGJlIHVzZWQgaW4gdGhlIHVpIGZvciBhIHNlYXJjaCBlbmdpbmUuXG4gKi9cbmNsYXNzIFNlYXJjaCBleHRlbmRzIF9fMi5BYnN0cmFjdENvbnRyb2wge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbih0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAncm9vdCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlkOiAoMCwgX18xLmdldElkKSh0aGlzLmF0dHJzKSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLlNFQVJDSCwgKDAsIF9fMS5nZXRDbGFzc05hbWUpKHRoaXMuYXR0cnMpLCAoMCwgb3JpZW50YXRpb25fMS5nZXRCbG9ja0NsYXNzTmFtZSkodGhpcy5hdHRycykpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5wdXQ6IHtcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdpbnB1dCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG5hbWU6ICgwLCBfXzIuZ2V0TmFtZSkodGhpcy5hdHRycyksXG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMucGxhY2Vob2xkZXIpID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5wbGFjZWhvbGRlciA6ICcnLFxuICAgICAgICAgICAgICAgIGF1dG9mb2N1czogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5hdXRvZm9jdXMpID9cbiAgICAgICAgICAgICAgICAgICAgdHJ1ZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICByZWFkT25seTogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5yZWFkT25seSkgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmRpc2FibGVkKSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMudGVybSkgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLnRlcm0gOlxuICAgICAgICAgICAgICAgICAgICAodGhpcy5hdHRycyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5zdHJpbmdpZmllciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy52YWx1ZSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5zdHJpbmdpZmllcih0aGlzLmF0dHJzLnZhbHVlKSA6ICcnLFxuICAgICAgICAgICAgICAgIG9uRm9jdXM6IHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5vbkZvY3VzIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBvblNlYXJjaDogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5vblNlYXJjaCkgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLm9uU2VhcmNoIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG9uRXNjYXBlOiAoKSA9PiB0aGlzLmNsb3NlKCksXG4gICAgICAgICAgICAgICAgb25CbHVyOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLm9uQmx1cikgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLm9uQmx1ciA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lbnU6IHtcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdtZW51J1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbmFtZTogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5uYW1lKSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMubmFtZSA6ICcnLFxuICAgICAgICAgICAgICAgIGJsb2NrOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmJsb2NrKSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMuYmxvY2sgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBvblNlbGVjdDogKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLm9uU2VsZWN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5vblNlbGVjdChlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGl0ZW1UZW1wbGF0ZTogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5pdGVtVGVtcGxhdGUpID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5pdGVtVGVtcGxhdGUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbm9JdGVtc1RlbXBsYXRlOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLm5vSXRlbXNUZW1wbGF0ZSkgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLm5vSXRlbXNUZW1wbGF0ZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBzdHJpbmdpZmllcjogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5zdHJpbmdpZmllcikgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLnN0cmluZ2lmaWVyIDogdW5kZWZpbmVkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAoMCwgdXRpbF8xLmdldEJ5SWQpKHRoaXMudmlldywgdGhpcy52YWx1ZXMucm9vdC53bWwuaWQpXG4gICAgICAgICAgICAubWFwKChlKSA9PiB7IGUudmFsdWUgPSB2YWx1ZTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBmb2N1cyBnaXZlcyBmb2N1cyB0byB0aGUgaW5wdXQuXG4gICAgICovXG4gICAgZm9jdXMoKSB7XG4gICAgICAgICgwLCB1dGlsXzEuZ2V0QnlJZCkodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5pbnB1dC53bWwuaWQpXG4gICAgICAgICAgICAubWFwKGkgPT4gaS5mb2N1cygpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHVwZGF0ZSB0aGUgU2VsZWN0IHdpdGggbmV3IGl0ZW0gb3B0aW9ucyB0b1xuICAgICAqIHByZXNlbnQgdG8gdGhlIHVzZXIuXG4gICAgICovXG4gICAgdXBkYXRlKHJlc3VsdHMpIHtcbiAgICAgICAgKDAsIGV4cG9ydHMudXBkYXRlTWVudSkodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5tZW51LndtbC5pZCwgcmVzdWx0cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBvcGVuIHRoZSByZXN1bHRzIG1lbnUuXG4gICAgICovXG4gICAgb3BlbigpIHtcbiAgICAgICAgKDAsIGV4cG9ydHMub3Blbk1lbnUpKHRoaXMudmlldywgdGhpcy52YWx1ZXMubWVudS53bWwuaWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogY2xvc2UgdGhlIHJlc3VsdHMgbWVudS5cbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgKDAsIGV4cG9ydHMuY2xvc2VNZW51KSh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLm1lbnUud21sLmlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5TZWFyY2ggPSBTZWFyY2g7XG5jb25zdCBnZXRJbnB1dCA9IChpKSA9PiAoMCwgdXRpbF8xLmdldEJ5SWQpKGkudmlldywgaS52YWx1ZXMud21sLmlkKTtcbi8qKlxuICogdXBkYXRlTWVudSB3aWxsIGNhdXNlIHRoZSBtZW51IHRvIGJlIGRpc3BsYXllZCB3aXRoIG5ldyBpdGVtcy5cbiAqL1xuY29uc3QgdXBkYXRlTWVudSA9ICh2aWV3LCBpZCwgcmVzdWx0cykgPT4ge1xuICAgIGxldCBtTWVudSA9ICgwLCB1dGlsXzEuZ2V0QnlJZCkodmlldywgaWQpO1xuICAgIGlmIChtTWVudS5pc0p1c3QoKSlcbiAgICAgICAgbU1lbnUuZ2V0KCkudXBkYXRlKHJlc3VsdHMpO1xufTtcbmV4cG9ydHMudXBkYXRlTWVudSA9IHVwZGF0ZU1lbnU7XG4vKipcbiAqIG9wZW5NZW51IHdpbGwgY2F1c2UgdGhlIG1lbnUgdG8gYmUgZGlzcGxheWVkIHdpdGggd2hhdGV2ZXIgY29udGVudHNcbiAqIHdlcmUgcHJldmlvdXNseSBzZXQuXG4gKi9cbmNvbnN0IG9wZW5NZW51ID0gKHZpZXcsIGlkKSA9PiB7XG4gICAgKDAsIHV0aWxfMS5nZXRCeUlkKSh2aWV3LCBpZClcbiAgICAgICAgLm1hcCgobSkgPT4gbS5vcGVuKCkpO1xufTtcbmV4cG9ydHMub3Blbk1lbnUgPSBvcGVuTWVudTtcbi8qKlxuICogY2xvc2VNZW51IHdpbGwgY2F1c2UgdGhlIG1lbnUgdG8gbm8gbG9uZ2VyIGJlIGRpc3BsYXllZC5cbiAqL1xuY29uc3QgY2xvc2VNZW51ID0gKHZpZXcsIGlkKSA9PiB7XG4gICAgKDAsIHV0aWxfMS5nZXRCeUlkKSh2aWV3LCBpZClcbiAgICAgICAgLm1hcCgobSkgPT4gbS5jbG9zZSgpKTtcbn07XG5leHBvcnRzLmNsb3NlTWVudSA9IGNsb3NlTWVudTtcbi8qKlxuICogdG9nZ2xlTWVudVxuICovXG5jb25zdCB0b2dnbGVNZW51ID0gKHZpZXcsIGlkKSA9PiB7XG4gICAgKDAsIHV0aWxfMS5nZXRCeUlkKSh2aWV3LCBpZClcbiAgICAgICAgLm1hcCgobSkgPT4gbS50b2dnbGUoKSk7XG59O1xuZXhwb3J0cy50b2dnbGVNZW51ID0gdG9nZ2xlTWVudTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYWluID0gZXhwb3J0cy5JbnB1dFZpZXcgPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbmNvbnN0IHJlc3VsdHNfbWVudV8xID0gcmVxdWlyZShcIi4uLy4uL3Jlc3VsdHMtbWVudVwiKTtcbjtcbmNvbnN0IF9fMSA9IHJlcXVpcmUoXCIuLi9cIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgSW5wdXRWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnaW5wdXQnLCB7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLndtbC5pZCB9LCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmNsYXNzTmFtZSwgJ29ua2V5dXAnOiBfX2NvbnRleHQudmFsdWVzLm9ua2V5dXAsICdvbmlucHV0JzogX19jb250ZXh0LnZhbHVlcy5vbmlucHV0LCAnb25mb2N1cyc6IF9fY29udGV4dC52YWx1ZXMub25mb2N1cywgJ29uYmx1cic6IF9fY29udGV4dC52YWx1ZXMub25ibHVyLCAnYXV0b2ZvY3VzJzogX19jb250ZXh0LnZhbHVlcy5hdXRvZm9jdXMsICdhdXRvY29tcGxldGUnOiBfX2NvbnRleHQudmFsdWVzLmF1dG9jb21wbGV0ZSwgJ3NpemUnOiBfX2NvbnRleHQudmFsdWVzLnNpemUsICdwbGFjZWhvbGRlcic6IF9fY29udGV4dC52YWx1ZXMucGxhY2Vob2xkZXIsICdyZWFkT25seSc6IF9fY29udGV4dC52YWx1ZXMucmVhZE9ubHksICdkaXNhYmxlZCc6IF9fY29udGV4dC52YWx1ZXMuZGlzYWJsZWQsICd2YWx1ZSc6IF9fY29udGV4dC52YWx1ZXMudmFsdWUgfSwgW10pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5JbnB1dFZpZXcgPSBJbnB1dFZpZXc7XG47XG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnZGl2JywgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5yb290LndtbC5pZCB9LCAnaWQnOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMucm9vdC5jbGFzc05hbWUgfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IF9fMS5JbnB1dCh7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmlucHV0LndtbC5pZCB9LCAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMuaW5wdXQubmFtZSwgJ2F1dG9mb2N1cyc6IF9fY29udGV4dC52YWx1ZXMuaW5wdXQuYXV0b2ZvY3VzLCAnb25Gb2N1cyc6IF9fY29udGV4dC52YWx1ZXMuaW5wdXQub25Gb2N1cywgJ29uU2VhcmNoJzogX19jb250ZXh0LnZhbHVlcy5pbnB1dC5vblNlYXJjaCwgJ29uRXNjYXBlJzogX19jb250ZXh0LnZhbHVlcy5pbnB1dC5vbkVzY2FwZSwgJ29uQmx1cic6IF9fY29udGV4dC52YWx1ZXMuaW5wdXQub25CbHVyLCAncGxhY2Vob2xkZXInOiBfX2NvbnRleHQudmFsdWVzLmlucHV0LnBsYWNlaG9sZGVyLCAncmVhZE9ubHknOiBfX2NvbnRleHQudmFsdWVzLmlucHV0LnJlYWRPbmx5LCAnZGlzYWJsZWQnOiBfX2NvbnRleHQudmFsdWVzLmlucHV0LmRpc2FibGVkLCAndmFsdWUnOiBfX2NvbnRleHQudmFsdWVzLmlucHV0LnZhbHVlIH0sIFtdKSwgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pbnB1dC53bWwuaWQgfSwgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLmlucHV0Lm5hbWUsICdhdXRvZm9jdXMnOiBfX2NvbnRleHQudmFsdWVzLmlucHV0LmF1dG9mb2N1cywgJ29uRm9jdXMnOiBfX2NvbnRleHQudmFsdWVzLmlucHV0Lm9uRm9jdXMsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMuaW5wdXQub25TZWFyY2gsICdvbkVzY2FwZSc6IF9fY29udGV4dC52YWx1ZXMuaW5wdXQub25Fc2NhcGUsICdvbkJsdXInOiBfX2NvbnRleHQudmFsdWVzLmlucHV0Lm9uQmx1ciwgJ3BsYWNlaG9sZGVyJzogX19jb250ZXh0LnZhbHVlcy5pbnB1dC5wbGFjZWhvbGRlciwgJ3JlYWRPbmx5JzogX19jb250ZXh0LnZhbHVlcy5pbnB1dC5yZWFkT25seSwgJ2Rpc2FibGVkJzogX19jb250ZXh0LnZhbHVlcy5pbnB1dC5kaXNhYmxlZCwgJ3ZhbHVlJzogX19jb250ZXh0LnZhbHVlcy5pbnB1dC52YWx1ZSB9KSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyByZXN1bHRzX21lbnVfMS5SZXN1bHRzTWVudSh7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLm1lbnUud21sLmlkIH0sICdoaWRkZW4nOiB0cnVlLCAnYmxvY2snOiBfX2NvbnRleHQudmFsdWVzLm1lbnUuYmxvY2ssICdvblNlbGVjdCc6IF9fY29udGV4dC52YWx1ZXMubWVudS5vblNlbGVjdCwgJ25vSXRlbXNUZW1wbGF0ZSc6IF9fY29udGV4dC52YWx1ZXMubWVudS5ub0l0ZW1zVGVtcGxhdGUsICdpdGVtVGVtcGxhdGUnOiBfX2NvbnRleHQudmFsdWVzLm1lbnUuaXRlbVRlbXBsYXRlLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLm1lbnUuc3RyaW5naWZpZXIgfSwgW10pLCB7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLm1lbnUud21sLmlkIH0sICdoaWRkZW4nOiB0cnVlLCAnYmxvY2snOiBfX2NvbnRleHQudmFsdWVzLm1lbnUuYmxvY2ssICdvblNlbGVjdCc6IF9fY29udGV4dC52YWx1ZXMubWVudS5vblNlbGVjdCwgJ25vSXRlbXNUZW1wbGF0ZSc6IF9fY29udGV4dC52YWx1ZXMubWVudS5ub0l0ZW1zVGVtcGxhdGUsICdpdGVtVGVtcGxhdGUnOiBfX2NvbnRleHQudmFsdWVzLm1lbnUuaXRlbVRlbXBsYXRlLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLm1lbnUuc3RyaW5naWZpZXIgfSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlYXJjaC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudXBkYXRlID0gZXhwb3J0cy5jbG9zZSA9IGV4cG9ydHMub3BlbiA9IGV4cG9ydHMuU2VsZWN0ID0gZXhwb3J0cy5TZWFyY2hTZWN0aW9uID0gZXhwb3J0cy5JbnB1dFNlY3Rpb24gPSBleHBvcnRzLkxhYmVsU2VjdGlvbiA9IGV4cG9ydHMuTWVzc2FnZXNTZWN0aW9uID0gZXhwb3J0cy5Db250cm9sU2VjdGlvbiA9IGV4cG9ydHMuUm9vdFNlY3Rpb24gPSBleHBvcnRzLkl0ZW1VbnNldEV2ZW50ID0gZXhwb3J0cy5JdGVtQ2hhbmdlZEV2ZW50ID0gZXhwb3J0cy5TRUxFQ1QgPSBleHBvcnRzLkl0ZW1TZWxlY3RlZEV2ZW50ID0gZXhwb3J0cy5UZXJtQ2hhbmdlZEV2ZW50ID0gdm9pZCAwO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvc2VsZWN0XCIpO1xuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbmNvbnN0IG9yaWVudGF0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vY29udGVudC9vcmllbnRhdGlvblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xuY29uc3QgZmVlZGJhY2tfMSA9IHJlcXVpcmUoXCIuLi9mZWVkYmFja1wiKTtcbmNvbnN0IGZvcm1fMSA9IHJlcXVpcmUoXCIuLi9mb3JtXCIpO1xuY29uc3QgX18xID0gcmVxdWlyZShcIi4uLy4uL1wiKTtcbmNvbnN0IF9fMiA9IHJlcXVpcmUoXCIuLi9cIik7XG5jb25zdCBzZWFyY2hfMSA9IHJlcXVpcmUoXCIuLi9zZWFyY2hcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUZXJtQ2hhbmdlZEV2ZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWFyY2hfMS5UZXJtQ2hhbmdlZEV2ZW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSXRlbVNlbGVjdGVkRXZlbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlYXJjaF8xLkl0ZW1TZWxlY3RlZEV2ZW50OyB9IH0pO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5TRUxFQ1QgPSAnd3ctc2VsZWN0Jztcbi8qKlxuICogSXRlbUNoYW5nZWRFdmVudFxuICovXG5jbGFzcyBJdGVtQ2hhbmdlZEV2ZW50IGV4dGVuZHMgX18yLkV2ZW50IHtcbn1cbmV4cG9ydHMuSXRlbUNoYW5nZWRFdmVudCA9IEl0ZW1DaGFuZ2VkRXZlbnQ7XG4vKipcbiAqIEl0ZW1VbnNldEV2ZW50XG4gKi9cbmNsYXNzIEl0ZW1VbnNldEV2ZW50IGV4dGVuZHMgX18yLkV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIHN1cGVyKG5hbWUsIHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgfVxufVxuZXhwb3J0cy5JdGVtVW5zZXRFdmVudCA9IEl0ZW1VbnNldEV2ZW50O1xuLyoqXG4gKiBSb290U2VjdGlvblxuICovXG5jbGFzcyBSb290U2VjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoYXR0cnMpIHtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLndtbCA9IHsgaWQ6ICdyb290JyB9O1xuICAgICAgICB0aGlzLmlkID0gKDAsIF9fMS5nZXRJZCkodGhpcy5hdHRycyk7XG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gKDAsIHV0aWxfMS5jb25jYXQpKGV4cG9ydHMuU0VMRUNULCAoMCwgX18xLmdldENsYXNzTmFtZSkodGhpcy5hdHRycyksICgwLCBmZWVkYmFja18xLmdldFZhbGlkaXR5Q2xhc3NOYW1lKSh0aGlzLmF0dHJzKSwgKDAsIG9yaWVudGF0aW9uXzEuZ2V0QmxvY2tDbGFzc05hbWUpKHRoaXMuYXR0cnMpKTtcbiAgICB9XG59XG5leHBvcnRzLlJvb3RTZWN0aW9uID0gUm9vdFNlY3Rpb247XG4vKipcbiAqIENvbnRyb2xTZWN0aW9uXG4gKi9cbmNsYXNzIENvbnRyb2xTZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy53bWwgPSB7IGlkOiAncm9vdCcgfTtcbiAgICB9XG59XG5leHBvcnRzLkNvbnRyb2xTZWN0aW9uID0gQ29udHJvbFNlY3Rpb247XG4vKipcbiAqIE1lc3NhZ2VzU2VjdGlvblxuICovXG5jbGFzcyBNZXNzYWdlc1NlY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGF0dHJzKSB7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy53bWwgPSB7IGlkOiAnbWVzc2FnZScgfTtcbiAgICAgICAgdGhpcy50ZXh0ID0gKDAsIGZlZWRiYWNrXzEuZ2V0TWVzc2FnZSkodGhpcy5hdHRycyk7XG4gICAgfVxufVxuZXhwb3J0cy5NZXNzYWdlc1NlY3Rpb24gPSBNZXNzYWdlc1NlY3Rpb247XG4vKipcbiAqIExhYmVsU2VjdGlvblxuICovXG5jbGFzcyBMYWJlbFNlY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGF0dHJzKSB7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy5pZCA9ICgwLCBfXzIuZ2V0TmFtZSkodGhpcy5hdHRycyk7XG4gICAgICAgIHRoaXMudGV4dCA9ICgwLCBmb3JtXzEuZ2V0TGFiZWwpKHRoaXMuYXR0cnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuTGFiZWxTZWN0aW9uID0gTGFiZWxTZWN0aW9uO1xuLyoqXG4gKiBJbnB1dFNlY3Rpb25cbiAqL1xuY2xhc3MgSW5wdXRTZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihhdHRycykge1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMud21sID0geyBpZDogJ2lucHV0JyB9O1xuICAgIH1cbn1cbmV4cG9ydHMuSW5wdXRTZWN0aW9uID0gSW5wdXRTZWN0aW9uO1xuLyoqXG4gKiBTZWFyY2hTZWN0aW9uXG4gKi9cbmNsYXNzIFNlYXJjaFNlY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGF0dHJzLCBjbG9zZSwgb25TZWxlY3QpIHtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLmNsb3NlID0gY2xvc2U7XG4gICAgICAgIHRoaXMub25TZWxlY3QgPSBvblNlbGVjdDtcbiAgICAgICAgdGhpcy53bWwgPSB7IGlkOiAnc2VhcmNoJyB9O1xuICAgICAgICB0aGlzLm5hbWUgPSAoMCwgX18yLmdldE5hbWUpKHRoaXMuYXR0cnMpO1xuICAgICAgICB0aGlzLmNsYXNzTmFtZSA9ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuaW5wdXRDbGFzc05hbWUpID9cbiAgICAgICAgICAgIHRoaXMuYXR0cnMuaW5wdXRDbGFzc05hbWUgOiAnJztcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMucGxhY2Vob2xkZXIpID9cbiAgICAgICAgICAgIHRoaXMuYXR0cnMucGxhY2Vob2xkZXIgOiAnJztcbiAgICAgICAgdGhpcy5ibG9jayA9ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuYmxvY2spID9cbiAgICAgICAgICAgIHRoaXMuYXR0cnMuYmxvY2sgOiBmYWxzZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMudmFsdWUpID9cbiAgICAgICAgICAgIHRoaXMuYXR0cnMudmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmVhZE9ubHkgPSAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLnJlYWRPbmx5KTtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuZGlzYWJsZWQpO1xuICAgICAgICB0aGlzLml0ZW1UZW1wbGF0ZSA9ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuaXRlbVRlbXBsYXRlKSA/XG4gICAgICAgICAgICB0aGlzLmF0dHJzLml0ZW1UZW1wbGF0ZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5ub0l0ZW1zVGVtcGxhdGUgPSAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLm5vSXRlbXNUZW1wbGF0ZSkgP1xuICAgICAgICAgICAgdGhpcy5hdHRycy5ub0l0ZW1zVGVtcGxhdGUgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc3RyaW5naWZpZXIgPSAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLnN0cmluZ2lmaWVyKSA/XG4gICAgICAgICAgICB0aGlzLmF0dHJzLnN0cmluZ2lmaWVyIDogdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm9uU2VhcmNoID0gKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5vblNlYXJjaCkgP1xuICAgICAgICAgICAgdGhpcy5hdHRycy5vblNlYXJjaCA6ICgpID0+IHsgfTtcbiAgICB9XG59XG5leHBvcnRzLlNlYXJjaFNlY3Rpb24gPSBTZWFyY2hTZWN0aW9uO1xuLyoqXG4gKiBTZWxlY3QgcHJvdmlkZXMgYW4gY29udHJvbCBmb3Igc2VsZWN0aW5nIGFuIGl0ZW0gZnJvbSBhXG4gKiBsaXN0LlxuICovXG5jbGFzcyBTZWxlY3QgZXh0ZW5kcyBmb3JtXzEuQWJzdHJhY3RGb3JtQ29udHJvbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHJvb3Q6IG5ldyBSb290U2VjdGlvbih0aGlzLmF0dHJzKSxcbiAgICAgICAgICAgIGNvbnRyb2w6IG5ldyBDb250cm9sU2VjdGlvbigpLFxuICAgICAgICAgICAgbWVzc2FnZXM6IG5ldyBNZXNzYWdlc1NlY3Rpb24odGhpcy5hdHRycyksXG4gICAgICAgICAgICBsYWJlbDogbmV3IExhYmVsU2VjdGlvbih0aGlzLmF0dHJzKSxcbiAgICAgICAgICAgIGlucHV0OiBuZXcgSW5wdXRTZWN0aW9uKHRoaXMuYXR0cnMpLFxuICAgICAgICAgICAgc2VhcmNoOiBuZXcgU2VhcmNoU2VjdGlvbih0aGlzLmF0dHJzLCAoKSA9PiB0aGlzLmNsb3NlKCksIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzLnRhZy52YWx1ZSA9ICgwLCBtYXliZV8xLmp1c3QpKGUudmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMub25DaGFuZ2UpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMub25DaGFuZ2UobmV3IEl0ZW1DaGFuZ2VkRXZlbnQoJycgKyB0aGlzLmF0dHJzLm5hbWUsIGUudmFsdWUpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuaW52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0YWc6IHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICgwLCBmZWVkYmFja18xLmdldFZhbGlkaXR5Q2xhc3NOYW1lKSh0aGlzLmF0dHJzKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogKCh0aGlzLmF0dHJzICYmXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLmF0dHJzLnZhbHVlICE9IHVuZGVmaW5lZCkpID9cbiAgICAgICAgICAgICAgICAgICAgKDAsIG1heWJlXzEuanVzdCkodGhpcy5hdHRycy52YWx1ZSkgOiAoMCwgbWF5YmVfMS5ub3RoaW5nKSgpKSxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5kaXNhYmxlZCkgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLmRpc2FibGVkIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNTZXQ6ICgpID0+IHRoaXMudmFsdWVzLnRhZy52YWx1ZS5pc0p1c3QoKSxcbiAgICAgICAgICAgICAgICBnZXRUZXh0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuc3RyaW5naWZpZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRycy5zdHJpbmdpZmllcih0aGlzLnZhbHVlcy50YWcudmFsdWUuZ2V0KCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkaXNtaXNzOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzLnRhZy52YWx1ZSA9ICgwLCBtYXliZV8xLm5vdGhpbmcpKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMub25VbnNldClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMub25VbnNldChuZXcgSXRlbVVuc2V0RXZlbnQodGhpcy5hdHRycy5uYW1lICsgJycpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3LmludmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIG9wZW4oKSB7XG4gICAgICAgICgwLCBleHBvcnRzLm9wZW4pKHRoaXMudmlldywgdGhpcy52YWx1ZXMuc2VhcmNoLndtbC5pZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgKDAsIGV4cG9ydHMuY2xvc2UpKHRoaXMudmlldywgdGhpcy52YWx1ZXMuc2VhcmNoLndtbC5pZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRNZXNzYWdlKG1zZykge1xuICAgICAgICB0aGlzLnZhbHVlcy5tZXNzYWdlcy50ZXh0ID0gbXNnO1xuICAgICAgICAoMCwgZm9ybV8xLnNldE1lc3NhZ2UpKHRoaXMudmlldywgdGhpcy52YWx1ZXMubWVzc2FnZXMud21sLmlkLCBtc2cpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVtb3ZlTWVzc2FnZSgpIHtcbiAgICAgICAgdGhpcy52YWx1ZXMubWVzc2FnZXMudGV4dCA9ICcnO1xuICAgICAgICAoMCwgZm9ybV8xLnJlbW92ZU1lc3NhZ2UpKHRoaXMudmlldywgdGhpcy52YWx1ZXMubWVzc2FnZXMud21sLmlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHVwZGF0ZSB0aGUgU2VsZWN0IHdpdGggbmV3IGl0ZW0gb3B0aW9ucyB0b1xuICAgICAqIHByZXNlbnQgdG8gdGhlIHVzZXIuXG4gICAgICovXG4gICAgdXBkYXRlKHJlc3VsdHMpIHtcbiAgICAgICAgKDAsIGV4cG9ydHMudXBkYXRlKSh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLnNlYXJjaC53bWwuaWQsIHJlc3VsdHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLlNlbGVjdCA9IFNlbGVjdDtcbi8qKlxuICogb3BlbiBoZWxwZXIuXG4gKlxuICogSW52b2tlcyB0aGUgb3BlbiBtZXRob2Qgb24gdGhlIFNlYXJjaCB3aWRnZXQuXG4gKi9cbmNvbnN0IG9wZW4gPSAodmlldywgaWQpID0+IHtcbiAgICAoMCwgdXRpbF8xLmdldEJ5SWQpKHZpZXcsIGlkKVxuICAgICAgICAubWFwKChtKSA9PiBtLm9wZW4oKSk7XG59O1xuZXhwb3J0cy5vcGVuID0gb3Blbjtcbi8qKlxuICogY2xvc2UgaGVscGVyLlxuICpcbiAqIEludm9rZXMgdGhlIGNsb3NlIG1ldGhvZCBvbiB0aGUgU2VhcmNoIHdpZGdldC5cbiAqL1xuY29uc3QgY2xvc2UgPSAodmlldywgaWQpID0+IHtcbiAgICAoMCwgdXRpbF8xLmdldEJ5SWQpKHZpZXcsIGlkKVxuICAgICAgICAubWFwKChtKSA9PiBtLmNsb3NlKCkpO1xufTtcbmV4cG9ydHMuY2xvc2UgPSBjbG9zZTtcbi8qKlxuICogdXBkYXRlIGhlbHBlci5cbiAqXG4gKiBJbnZva2VzIHRoZSB1cGRhdGUgbWV0aG9kIG9uIHRoZSBTZWFyY2ggd2lkZ2V0LlxuICovXG5jb25zdCB1cGRhdGUgPSAodmlldywgaWQsIHJlc3VsdHMpID0+IHtcbiAgICBsZXQgbVNlYXJjaCA9ICgwLCB1dGlsXzEuZ2V0QnlJZCkodmlldywgaWQpO1xuICAgIGlmIChtU2VhcmNoLmlzSnVzdCgpKVxuICAgICAgICBtU2VhcmNoLmdldCgpLnVwZGF0ZShyZXN1bHRzKTtcbn07XG5leHBvcnRzLnVwZGF0ZSA9IHVwZGF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYWluID0gdm9pZCAwO1xuY29uc3QgX19kb2N1bWVudCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbmNvbnN0IG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG5jb25zdCBzZWFyY2hfMSA9IHJlcXVpcmUoXCIuLi8uLi9zZWFyY2hcIik7XG47XG5jb25zdCBsYWJlbF8xID0gcmVxdWlyZShcIi4uLy4uL2xhYmVsXCIpO1xuO1xuY29uc3QgaGVscF8xID0gcmVxdWlyZShcIi4uLy4uL2hlbHBcIik7XG47XG5jb25zdCB0YWdfMSA9IHJlcXVpcmUoXCIuLi8uLi90YWdcIik7XG47XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ2RpdicsIHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5yb290LmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NOYW1lIH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBsYWJlbF8xLkxhYmVsKHsgJ2Zvcic6IF9fY29udGV4dC52YWx1ZXMucm9vdC5pZCwgJ3RleHQnOiBfX2NvbnRleHQudmFsdWVzLmxhYmVsLnRleHQgfSwgW10pLCB7ICdmb3InOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuaWQsICd0ZXh0JzogX19jb250ZXh0LnZhbHVlcy5sYWJlbC50ZXh0IH0pLFxuICAgICAgICAgICAgICAgIC4uLigoX19jb250ZXh0LnZhbHVlcy50YWcuaXNTZXQoKSkgP1xuICAgICAgICAgICAgICAgICAgICAoKCkgPT4gKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRhZ18xLlRhZyh7ICd0ZXh0JzogX19jb250ZXh0LnZhbHVlcy50YWcuZ2V0VGV4dCgpLCAnY2xhc3NOYW1lJzogX19jb250ZXh0LnZhbHVlcy50YWcuY2xhc3NOYW1lLCAnZGlzYWJsZWQnOiBfX2NvbnRleHQudmFsdWVzLnRhZy5kaXNhYmxlZCwgJ29uRGlzbWlzcyc6IF9fY29udGV4dC52YWx1ZXMudGFnLmRpc21pc3MgfSwgW10pLCB7ICd0ZXh0JzogX19jb250ZXh0LnZhbHVlcy50YWcuZ2V0VGV4dCgpLCAnY2xhc3NOYW1lJzogX19jb250ZXh0LnZhbHVlcy50YWcuY2xhc3NOYW1lLCAnZGlzYWJsZWQnOiBfX2NvbnRleHQudmFsdWVzLnRhZy5kaXNhYmxlZCwgJ29uRGlzbWlzcyc6IF9fY29udGV4dC52YWx1ZXMudGFnLmRpc21pc3MgfSlcbiAgICAgICAgICAgICAgICAgICAgXSkpKCkgOlxuICAgICAgICAgICAgICAgICAgICAoKCkgPT4gKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHNlYXJjaF8xLlNlYXJjaCh7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLnNlYXJjaC53bWwuaWQgfSwgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLnNlYXJjaC5uYW1lLCAnY2xhc3NOYW1lJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2guY2xhc3NOYW1lLCAnYmxvY2snOiBfX2NvbnRleHQudmFsdWVzLnNlYXJjaC5ibG9jaywgJ3BsYWNlaG9sZGVyJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2gucGxhY2Vob2xkZXIsICdyZWFkT25seSc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLnJlYWRPbmx5LCAnZGlzYWJsZWQnOiBfX2NvbnRleHQudmFsdWVzLnNlYXJjaC5kaXNhYmxlZCwgJ2l0ZW1UZW1wbGF0ZSc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLml0ZW1UZW1wbGF0ZSwgJ25vSXRlbXNUZW1wbGF0ZSc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLm5vSXRlbXNUZW1wbGF0ZSwgJ3N0cmluZ2lmaWVyJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2guc3RyaW5naWZpZXIsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLm9uU2VhcmNoLCAnb25TZWxlY3QnOiBfX2NvbnRleHQudmFsdWVzLnNlYXJjaC5vblNlbGVjdCB9LCBbXSksIHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLndtbC5pZCB9LCAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLm5hbWUsICdjbGFzc05hbWUnOiBfX2NvbnRleHQudmFsdWVzLnNlYXJjaC5jbGFzc05hbWUsICdibG9jayc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLmJsb2NrLCAncGxhY2Vob2xkZXInOiBfX2NvbnRleHQudmFsdWVzLnNlYXJjaC5wbGFjZWhvbGRlciwgJ3JlYWRPbmx5JzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2gucmVhZE9ubHksICdkaXNhYmxlZCc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLmRpc2FibGVkLCAnaXRlbVRlbXBsYXRlJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2guaXRlbVRlbXBsYXRlLCAnbm9JdGVtc1RlbXBsYXRlJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2gubm9JdGVtc1RlbXBsYXRlLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLnNlYXJjaC5zdHJpbmdpZmllciwgJ29uU2VhcmNoJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2gub25TZWFyY2gsICdvblNlbGVjdCc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLm9uU2VsZWN0IH0pXG4gICAgICAgICAgICAgICAgICAgIF0pKSgpKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBoZWxwXzEuSGVscCh7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLm1lc3NhZ2VzLndtbC5pZCB9LCAndGV4dCc6IF9fY29udGV4dC52YWx1ZXMubWVzc2FnZXMudGV4dCB9LCBbXSksIHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMubWVzc2FnZXMud21sLmlkIH0sICd0ZXh0JzogX19jb250ZXh0LnZhbHVlcy5tZXNzYWdlcy50ZXh0IH0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWxlY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0YWNrU2VsZWN0ID0gZXhwb3J0cy5JdGVtc0NoYW5nZWRFdmVudCA9IGV4cG9ydHMuU1RBQ0tfU0VMRUNUID0gZXhwb3J0cy5UZXJtQ2hhbmdlZEV2ZW50ID0gdm9pZCAwO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvc3RhY2stc2VsZWN0XCIpO1xuY29uc3Qgb3JpZW50YXRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZW50L29yaWVudGF0aW9uXCIpO1xuY29uc3QgZm9ybV8xID0gcmVxdWlyZShcIi4uL2Zvcm1cIik7XG5jb25zdCBzZWFyY2hfMSA9IHJlcXVpcmUoXCIuLi9zZWFyY2hcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUZXJtQ2hhbmdlZEV2ZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWFyY2hfMS5UZXJtQ2hhbmdlZEV2ZW50OyB9IH0pO1xuY29uc3Qgc2VsZWN0XzEgPSByZXF1aXJlKFwiLi4vc2VsZWN0XCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG5jb25zdCBfXzEgPSByZXF1aXJlKFwiLi4vLi4vXCIpO1xuY29uc3QgX18yID0gcmVxdWlyZShcIi4uL1wiKTtcbmNvbnN0IGZlZWRiYWNrXzEgPSByZXF1aXJlKFwiLi4vZmVlZGJhY2tcIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLlNUQUNLX1NFTEVDVCA9ICd3dy1zdGFjay1zZWxlY3QnO1xuLyoqXG4gKiBJdGVtc0NoYW5nZWRFdmVudFxuICovXG5jbGFzcyBJdGVtc0NoYW5nZWRFdmVudCBleHRlbmRzIF9fMi5FdmVudCB7XG59XG5leHBvcnRzLkl0ZW1zQ2hhbmdlZEV2ZW50ID0gSXRlbXNDaGFuZ2VkRXZlbnQ7XG4vKipcbiAqIFN0YWNrU2VsZWN0IHByb3ZpZGVzIGEgY29udHJvbCBmb3IgYWxsb3dpbmcgYSB1c2VyIHRvIHNlbGVjdFxuICogbXVsdGlwbGUgaXRlbXMgZnJvbSBhIGxpc3QuXG4gKlxuICogSXQgdXNlIGEgc3RhY2sgdG8gZGlzcGxheSB0aGUgc2VsZWN0ZWQgaXRlbXMuXG4gKlxuICogICAgICs9PT09PT09PT09PT09PT09PT09PT09PT09K1xuICogICAgIHwgIDxzZWxlY3Q+ICAgICAgICAgICAgICAgfFxuICogICAgICs9PT09PT09PT09PT09PT09PT09PT09PT09K1xuICogICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICogICAgIHwgICA8aXRlbT4gICAgICAgICAgICAgIHggfFxuICogICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICogICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICogICAgIHwgICA8aXRlbT4gICAgICAgICAgICAgIHggfFxuICogICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICogICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICogICAgIHwgICA8aXRlbT4gICAgICAgICAgICAgIHggfFxuICogICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICovXG5jbGFzcyBTdGFja1NlbGVjdCBleHRlbmRzIGZvcm1fMS5BYnN0cmFjdEZvcm1Db250cm9sIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ3Jvb3QnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpZDogKDAsIF9fMS5nZXRJZCkodGhpcy5hdHRycyksXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAoMCwgdXRpbF8xLmNvbmNhdCkoZXhwb3J0cy5TVEFDS19TRUxFQ1QsICgwLCBfXzEuZ2V0Q2xhc3NOYW1lKSh0aGlzLmF0dHJzKSwgKDAsIGZlZWRiYWNrXzEuZ2V0VmFsaWRpdHlDbGFzc05hbWUpKHRoaXMuYXR0cnMpLCAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmJsb2NrKSA/IG9yaWVudGF0aW9uXzEuQkxPQ0sgOiAnJyksXG4gICAgICAgICAgICAgICAgZGlyOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmRpcikgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLmRpciA6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250cm9sOiB7XG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAncm9vdCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdsYWJlbCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRleHQ6ICgwLCBmb3JtXzEuZ2V0TGFiZWwpKHRoaXMuYXR0cnMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VhcmNoOiB7XG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAnc2VhcmNoJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbmFtZTogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5uYW1lKSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMubmFtZSA6ICcnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgYmxvY2s6IHRydWUsXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuZGlzYWJsZWQpID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5kaXNhYmxlZCA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLnBsYWNlaG9sZGVyKSB8fCAnJyxcbiAgICAgICAgICAgICAgICBvblNlYXJjaDogKGV2dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLm9uU2VhcmNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5vblNlYXJjaChldnQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25TZWxlY3Q6ICh7IHZhbHVlIH0pID0+IHRoaXMucHVzaCh2YWx1ZSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZXNzYWdlczoge1xuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ21lc3NhZ2UnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0ZXh0OiAoMCwgZmVlZGJhY2tfMS5nZXRNZXNzYWdlKSh0aGlzLmF0dHJzKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0YWNrOiB7XG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAnc3RhY2snXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBuYW1lOiAoMCwgX18yLmdldE5hbWUpKHRoaXMuYXR0cnMpLFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmRpc2FibGVkKSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMuZGlzYWJsZWQgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy52YWx1ZSkgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLnZhbHVlIDogW10sXG4gICAgICAgICAgICAgICAgZGVjb3JhdG9yOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLnN0cmluZ2lmaWVyKSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMuc3RyaW5naWZpZXIgOiAodikgPT4gU3RyaW5nKHYpLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLm9uQ2hhbmdlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5vbkNoYW5nZShlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHNldE1lc3NhZ2UobXNnKSB7XG4gICAgICAgICgwLCBmb3JtXzEuc2V0TWVzc2FnZSkodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5tZXNzYWdlcy53bWwuaWQsIG1zZyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZW1vdmVNZXNzYWdlKCkge1xuICAgICAgICAoMCwgZm9ybV8xLnJlbW92ZU1lc3NhZ2UpKHRoaXMudmlldywgdGhpcy52YWx1ZXMubWVzc2FnZXMud21sLmlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHVwZGF0ZSB0aGUgbGlzdCBvZiBhdmFpbGFibGUgb3B0aW9ucyBkaXNwbGF5ZWQgdG8gdGhlIHVzZXIuXG4gICAgICovXG4gICAgdXBkYXRlKGxpc3QpIHtcbiAgICAgICAgKDAsIHNlbGVjdF8xLnVwZGF0ZSkodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5zZWFyY2gud21sLmlkLCBsaXN0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHB1c2ggYSB2YWx1ZSBvbnRvIHRoZSBzdGFjay5cbiAgICAgKi9cbiAgICBwdXNoKHYpIHtcbiAgICAgICAgdGhpc1xuICAgICAgICAgICAgLnZpZXdcbiAgICAgICAgICAgIC5maW5kQnlJZCh0aGlzLnZhbHVlcy5zdGFjay53bWwuaWQpXG4gICAgICAgICAgICAubWFwKHMgPT4gcy5wdXNoKHYpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5TdGFja1NlbGVjdCA9IFN0YWNrU2VsZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1haW4gPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbmNvbnN0IHNlYXJjaF8xID0gcmVxdWlyZShcIi4uLy4uL3NlYXJjaFwiKTtcbjtcbmNvbnN0IHN0YWNrXzEgPSByZXF1aXJlKFwiLi4vLi4vc3RhY2tcIik7XG47XG5jb25zdCBsYWJlbF8xID0gcmVxdWlyZShcIi4uLy4uL2xhYmVsXCIpO1xuO1xuY29uc3QgaGVscF8xID0gcmVxdWlyZShcIi4uLy4uL2hlbHBcIik7XG47XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ2RpdicsIHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5yb290LmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NOYW1lIH0sIFtcbiAgICAgICAgICAgICAgICAuLi4oKChfX2NvbnRleHQudmFsdWVzLnJvb3QuZGlyID09PSAtMSkpID9cbiAgICAgICAgICAgICAgICAgICAgKCgpID0+IChbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBsYWJlbF8xLkxhYmVsKHsgJ2Zvcic6IF9fY29udGV4dC52YWx1ZXMucm9vdC5pZCwgJ3RleHQnOiBfX2NvbnRleHQudmFsdWVzLmxhYmVsLnRleHQgfSwgW10pLCB7ICdmb3InOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuaWQsICd0ZXh0JzogX19jb250ZXh0LnZhbHVlcy5sYWJlbC50ZXh0IH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgc2VhcmNoXzEuU2VhcmNoKHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLndtbC5pZCB9LCAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLm5hbWUsICd2YWx1ZSc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLnZhbHVlLCAnYmxvY2snOiBfX2NvbnRleHQudmFsdWVzLnNlYXJjaC5ibG9jaywgJ2Rpc2FibGVkJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2guZGlzYWJsZWQsICdzdHJpbmdpZmllcic6IF9fY29udGV4dC52YWx1ZXMuc3RhY2suZGVjb3JhdG9yLCAncGxhY2Vob2xkZXInOiBfX2NvbnRleHQudmFsdWVzLnNlYXJjaC5wbGFjZWhvbGRlciwgJ29uU2VhcmNoJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2gub25TZWFyY2gsICdvblNlbGVjdCc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLm9uU2VsZWN0IH0sIFtdKSwgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2gud21sLmlkIH0sICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2gubmFtZSwgJ3ZhbHVlJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2gudmFsdWUsICdibG9jayc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLmJsb2NrLCAnZGlzYWJsZWQnOiBfX2NvbnRleHQudmFsdWVzLnNlYXJjaC5kaXNhYmxlZCwgJ3N0cmluZ2lmaWVyJzogX19jb250ZXh0LnZhbHVlcy5zdGFjay5kZWNvcmF0b3IsICdwbGFjZWhvbGRlcic6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLnBsYWNlaG9sZGVyLCAnb25TZWFyY2gnOiBfX2NvbnRleHQudmFsdWVzLnNlYXJjaC5vblNlYXJjaCwgJ29uU2VsZWN0JzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2gub25TZWxlY3QgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBzdGFja18xLlN0YWNrKHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuc3RhY2sud21sLmlkIH0sICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5zdGFjay5uYW1lLCAndmFsdWUnOiBfX2NvbnRleHQudmFsdWVzLnN0YWNrLnZhbHVlLCAnZGlzYWJsZWQnOiBfX2NvbnRleHQudmFsdWVzLnN0YWNrLmRpc2FibGVkLCAnZGVjb3JhdG9yJzogX19jb250ZXh0LnZhbHVlcy5zdGFjay5kZWNvcmF0b3IsICdvbkNoYW5nZSc6IF9fY29udGV4dC52YWx1ZXMuc3RhY2sub25DaGFuZ2UgfSwgW10pLCB7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLnN0YWNrLndtbC5pZCB9LCAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMuc3RhY2submFtZSwgJ3ZhbHVlJzogX19jb250ZXh0LnZhbHVlcy5zdGFjay52YWx1ZSwgJ2Rpc2FibGVkJzogX19jb250ZXh0LnZhbHVlcy5zdGFjay5kaXNhYmxlZCwgJ2RlY29yYXRvcic6IF9fY29udGV4dC52YWx1ZXMuc3RhY2suZGVjb3JhdG9yLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLnN0YWNrLm9uQ2hhbmdlIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgaGVscF8xLkhlbHAoeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5tZXNzYWdlcy53bWwuaWQgfSwgJ3RleHQnOiBfX2NvbnRleHQudmFsdWVzLm1lc3NhZ2VzLnRleHQgfSwgW10pLCB7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLm1lc3NhZ2VzLndtbC5pZCB9LCAndGV4dCc6IF9fY29udGV4dC52YWx1ZXMubWVzc2FnZXMudGV4dCB9KVxuICAgICAgICAgICAgICAgICAgICBdKSkoKSA6XG4gICAgICAgICAgICAgICAgICAgICgoKSA9PiAoW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgbGFiZWxfMS5MYWJlbCh7ICdmb3InOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuaWQsICd0ZXh0JzogX19jb250ZXh0LnZhbHVlcy5sYWJlbC50ZXh0IH0sIFtdKSwgeyAnZm9yJzogX19jb250ZXh0LnZhbHVlcy5yb290LmlkLCAndGV4dCc6IF9fY29udGV4dC52YWx1ZXMubGFiZWwudGV4dCB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHN0YWNrXzEuU3RhY2soeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5zdGFjay53bWwuaWQgfSwgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLnN0YWNrLm5hbWUsICd2YWx1ZSc6IF9fY29udGV4dC52YWx1ZXMuc3RhY2sudmFsdWUsICdkZWNvcmF0b3InOiBfX2NvbnRleHQudmFsdWVzLnN0YWNrLmRlY29yYXRvciwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5zdGFjay5vbkNoYW5nZSB9LCBbXSksIHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuc3RhY2sud21sLmlkIH0sICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5zdGFjay5uYW1lLCAndmFsdWUnOiBfX2NvbnRleHQudmFsdWVzLnN0YWNrLnZhbHVlLCAnZGVjb3JhdG9yJzogX19jb250ZXh0LnZhbHVlcy5zdGFjay5kZWNvcmF0b3IsICdvbkNoYW5nZSc6IF9fY29udGV4dC52YWx1ZXMuc3RhY2sub25DaGFuZ2UgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBzZWFyY2hfMS5TZWFyY2goeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2gud21sLmlkIH0sICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2gubmFtZSwgJ3ZhbHVlJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2gudmFsdWUsICdibG9jayc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLmJsb2NrLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLnN0YWNrLmRlY29yYXRvciwgJ29uU2VhcmNoJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2gub25TZWFyY2gsICdvblNlbGVjdCc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLm9uU2VsZWN0IH0sIFtdKSwgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2gud21sLmlkIH0sICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2gubmFtZSwgJ3ZhbHVlJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2gudmFsdWUsICdibG9jayc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLmJsb2NrLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLnN0YWNrLmRlY29yYXRvciwgJ29uU2VhcmNoJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2gub25TZWFyY2gsICdvblNlbGVjdCc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLm9uU2VsZWN0IH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgaGVscF8xLkhlbHAoeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5tZXNzYWdlcy53bWwuaWQgfSwgJ3RleHQnOiBfX2NvbnRleHQudmFsdWVzLm1lc3NhZ2VzLnRleHQgfSwgW10pLCB7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLm1lc3NhZ2VzLndtbC5pZCB9LCAndGV4dCc6IF9fY29udGV4dC52YWx1ZXMubWVzc2FnZXMudGV4dCB9KVxuICAgICAgICAgICAgICAgICAgICBdKSkoKSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YWNrLXNlbGVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3RhY2sgPSBleHBvcnRzLlN0YWNrQ2hhbmdlZEV2ZW50ID0gZXhwb3J0cy5TVEFDS19DTE9TRV9CVVRUT04gPSBleHBvcnRzLlNUQUNLX0VMRU1FTlRfQ09OVEVOVCA9IGV4cG9ydHMuU1RBQ0tfRUxFTUVOVCA9IGV4cG9ydHMuU1RBQ0sgPSB2b2lkIDA7XG5jb25zdCB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9zdGFja1wiKTtcbmNvbnN0IGRvbV8xID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xuY29uc3QgX18xID0gcmVxdWlyZShcIi4uLy4uL1wiKTtcbmNvbnN0IF9fMiA9IHJlcXVpcmUoXCIuLi9cIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLlNUQUNLID0gJ3d3LXN0YWNrJztcbmV4cG9ydHMuU1RBQ0tfRUxFTUVOVCA9ICd3dy1zdGFja19fZWxlbWVudCc7XG5leHBvcnRzLlNUQUNLX0VMRU1FTlRfQ09OVEVOVCA9ICd3dy1zdGFja19fZWxlbWVudF9fY29udGVudCc7XG5leHBvcnRzLlNUQUNLX0NMT1NFX0JVVFRPTiA9ICd3dy1zdGFja19fYnV0dG9uJztcbi8qKlxuICogU3RhY2tDaGFuZ2VkRXZlbnQgaXMgZ2VuZXJhdGVkIHdoZW4gdGhlIHVzZXIgcmVtb3ZlcyBhbiBpdGVtIGZyb20gdGhlIHN0YWNrLlxuICovXG5jbGFzcyBTdGFja0NoYW5nZWRFdmVudCBleHRlbmRzIF9fMi5FdmVudCB7XG59XG5leHBvcnRzLlN0YWNrQ2hhbmdlZEV2ZW50ID0gU3RhY2tDaGFuZ2VkRXZlbnQ7XG4vKipcbiAqIFN0YWNrIGRpc3BsYXlzIGEgbGlzdCBvZiBpdGVtcyB0aGF0IGNhbiBiZSBtb2RpZmllZFxuICogYnkgcmVsZWFzaW5nIG9uZSBvciBtb3JlIGF0IGEgdGltZS5cbiAqL1xuY2xhc3MgU3RhY2sgZXh0ZW5kcyBfXzIuQWJzdHJhY3RDb250cm9sIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgICAgIGlkOiAoMCwgX18xLmdldElkKSh0aGlzLmF0dHJzKSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLlNUQUNLLCAoMCwgX18xLmdldENsYXNzTmFtZSkodGhpcy5hdHRycykpLFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmRpc2FibGVkKSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMuZGlzYWJsZWQgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy52YWx1ZSkgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLnZhbHVlIDogW10sXG4gICAgICAgICAgICAgICAgZmlyZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMudmFsdWVzLnJvb3QuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMub25DaGFuZ2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5vbkNoYW5nZShuZXcgU3RhY2tDaGFuZ2VkRXZlbnQodGhpcy5hdHRycy5uYW1lLCB0aGlzLnZhbHVlcy5yb290LnZhbHVlLnNsaWNlKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlldy5pbnZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZWxlbWVudDoge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogZXhwb3J0cy5TVEFDS19FTEVNRU5ULFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAodiwgaWR4KSA9PiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmVsZW1lbnRUZW1wbGF0ZSkgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLmVsZW1lbnRUZW1wbGF0ZSh0aGlzKSh2KShpZHgpKHRoaXMudmlldykgOlxuICAgICAgICAgICAgICAgICAgICB2aWV3cy5jb250ZW50KHRoaXMsIHYsIGlkeCkodGhpcy52aWV3KSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogZXhwb3J0cy5TVEFDS19FTEVNRU5UX0NPTlRFTlRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNsb3NlOiAoaW5kZXgpID0+ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZXMucm9vdC52YWx1ZS5zcGxpY2UoTnVtYmVyKGluZGV4KSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzLnJvb3QuZmlyZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVjb3JhdG9yOiAodikgPT4gKDAsIGRvbV8xLnRleHQpKCh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuZGVjb3JhdG9yKSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMuZGVjb3JhdG9yKHYpIDogdiArICcnKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb3NlOiB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBleHBvcnRzLlNUQUNLX0NMT1NFX0JVVFRPTlxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBwdXNoIGEgbmV3IG1lbWJlciBvbnRvIHRoZSBzdGFjay5cbiAgICAgKi9cbiAgICBwdXNoKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWVzLnJvb3QudmFsdWUucHVzaCh2YWx1ZSk7XG4gICAgICAgIHRoaXMudmFsdWVzLnJvb3QuZmlyZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLlN0YWNrID0gU3RhY2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWFpbiA9IGV4cG9ydHMuY29udGVudCA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9faWYgPSAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpID0+IChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0ID8gX19hbHQoKSA6IFtdO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9ySW4gPSAobGlzdCwgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2Zvck9mID0gKG8sIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHRleHQgPSBfX2RvY3VtZW50LnRleHQ7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHVuc2FmZSA9IF9fZG9jdW1lbnQudW5zYWZlO1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCBpc1NldCA9ICh2YWx1ZSkgPT4gdmFsdWUgIT0gbnVsbDtcbmNvbnN0IGNvbnRlbnQgPSAocywgdiwgXykgPT4gKF9fdGhpcykgPT4ge1xuICAgIHJldHVybiBbXG4gICAgICAgIF9fdGhpcy5ub2RlKCdkaXYnLCB7ICdjbGFzcyc6IHMudmFsdWVzLmVsZW1lbnQuY29udGVudC5jbGFzc05hbWUgfSwgW1xuICAgICAgICAgICAgcy52YWx1ZXMuZWxlbWVudC5kZWNvcmF0b3IodilcbiAgICAgICAgXSlcbiAgICBdO1xufTtcbmV4cG9ydHMuY29udGVudCA9IGNvbnRlbnQ7XG47XG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgndWwnLCB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMucm9vdC5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5yb290LmNsYXNzTmFtZSB9LCBbXG4gICAgICAgICAgICAgICAgLi4uX19mb3JJbihfX2NvbnRleHQudmFsdWVzLnJvb3QudmFsdWUsICh2LCBpbmRleCwgXyQkYWxsKSA9PiAoW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnbGknLCB7ICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuZWxlbWVudC5jbGFzc05hbWUgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uKF9fY29udGV4dC52YWx1ZXMuZWxlbWVudC50ZW1wbGF0ZSh2LCBpbmRleCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uKCgoX19jb250ZXh0LnZhbHVlcy5yb290LmRpc2FibGVkID09PSBmYWxzZSkpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKCkgPT4gKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2J1dHRvbicsIHsgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jbG9zZS5jbGFzc05hbWUsICdvbmNsaWNrJzogX19jb250ZXh0LnZhbHVlcy5lbGVtZW50LmNsb3NlKGluZGV4KSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCfDlycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSkpKCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoKSA9PiAoW10pKSgpKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pLCAoKSA9PiAoW10pKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhY2suanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN3aXRjaCA9IGV4cG9ydHMuU3dpdGNoQ2hhbmdlZEV2ZW50ID0gZXhwb3J0cy5TV0lUQ0hfU0xJREVSID0gZXhwb3J0cy5TV0lUQ0ggPSB2b2lkIDA7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbmNvbnN0IF9fMSA9IHJlcXVpcmUoXCIuLi8uLi9cIik7XG5jb25zdCBfXzIgPSByZXF1aXJlKFwiLi4vXCIpO1xuY29uc3Qgc3dpdGNoXzEgPSByZXF1aXJlKFwiLi93bWwvc3dpdGNoXCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5TV0lUQ0ggPSAnd3ctc3dpdGNoJztcbmV4cG9ydHMuU1dJVENIX1NMSURFUiA9ICd3dy1zd2l0Y2hfX3NsaWRlcic7XG4vKipcbiAqIFN3aXRjaENoYW5nZWRFdmVudCBzaWduYWxzIHRoZSB1c2VyIGhhcyBjaGFuZ2VkIHRoZSBzd2l0Y2guXG4gKi9cbmNsYXNzIFN3aXRjaENoYW5nZWRFdmVudCBleHRlbmRzIF9fMi5FdmVudCB7XG59XG5leHBvcnRzLlN3aXRjaENoYW5nZWRFdmVudCA9IFN3aXRjaENoYW5nZWRFdmVudDtcbi8qKlxuICogU3dpdGNoIGFsbG93cyB0aGUgdXNlciB0byBzZWxlY3QgYmV0d2VlbiBvbmUgb3IgdHdvIHZhbHVlcy5cbiAqL1xuY2xhc3MgU3dpdGNoIGV4dGVuZHMgX18yLkFic3RyYWN0Q29udHJvbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyBzd2l0Y2hfMS5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgICAgICBpZDogKDAsIF9fMS5nZXRJZCkodGhpcy5hdHRycyksXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAoMCwgdXRpbF8xLmNvbmNhdCkoZXhwb3J0cy5TV0lUQ0gsICgwLCBfXzEuZ2V0Q2xhc3NOYW1lKSh0aGlzLmF0dHJzKSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzbGlkZXI6IHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGV4cG9ydHMuU1dJVENIX1NMSURFUlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlucHV0OiB7XG4gICAgICAgICAgICAgICAgbmFtZTogKDAsIF9fMi5nZXROYW1lKSh0aGlzLmF0dHJzKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy52YWx1ZSkgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLnZhbHVlIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgY2hlY2tlZDogKCkgPT4gdGhpcy52YWx1ZXMuaW5wdXQudmFsdWUgPyB0cnVlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiAoMCwgX18yLmdldERpc2FibGVkKSh0aGlzLmF0dHJzKSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcy5pbnB1dC52YWx1ZSA9ICghdGhpcy52YWx1ZXMuaW5wdXQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5vbkNoYW5nZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLm9uQ2hhbmdlKG5ldyBTd2l0Y2hDaGFuZ2VkRXZlbnQodGhpcy52YWx1ZXMuaW5wdXQubmFtZSwgdGhpcy52YWx1ZXMuaW5wdXQudmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5Td2l0Y2ggPSBTd2l0Y2g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWFpbiA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9faWYgPSAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpID0+IChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0ID8gX19hbHQoKSA6IFtdO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9ySW4gPSAobGlzdCwgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2Zvck9mID0gKG8sIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHRleHQgPSBfX2RvY3VtZW50LnRleHQ7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHVuc2FmZSA9IF9fZG9jdW1lbnQudW5zYWZlO1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCBpc1NldCA9ICh2YWx1ZSkgPT4gdmFsdWUgIT0gbnVsbDtcbmNsYXNzIE1haW4ge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdsYWJlbCcsIHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5yb290LmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NOYW1lIH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaW5wdXQnLCB7ICd0eXBlJzogJ2NoZWNrYm94JywgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLmlucHV0Lm5hbWUsICdjaGVja2VkJzogX19jb250ZXh0LnZhbHVlcy5pbnB1dC5jaGVja2VkKCksICdkaXNhYmxlZCc6IF9fY29udGV4dC52YWx1ZXMuaW5wdXQuZGlzYWJsZWQsICdvbmNoYW5nZSc6IF9fY29udGV4dC52YWx1ZXMuaW5wdXQub25DaGFuZ2UgfSwgW10pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdkaXYnLCB7ICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuc2xpZGVyLmNsYXNzTmFtZSB9LCBbXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN3aXRjaC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVGFiQmFyID0gZXhwb3J0cy5UYWIgPSBleHBvcnRzLlRhYkNsaWNrZWRFdmVudCA9IGV4cG9ydHMuVEFCX0JBUiA9IGV4cG9ydHMuVEFCID0gdm9pZCAwO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvdGFiLWJhclwiKTtcbmNvbnN0IGRvbV8xID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbmNvbnN0IHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG5jb25zdCBhY3RpdmVfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZW50L3N0YXRlL2FjdGl2ZVwiKTtcbmNvbnN0IG9yaWVudGF0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vY29udGVudC9vcmllbnRhdGlvblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xuY29uc3QgX18xID0gcmVxdWlyZShcIi4uLy4uL1wiKTtcbmNvbnN0IF9fMiA9IHJlcXVpcmUoXCIuLi9cIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG4vKipcbiAqIFRBQlxuICovXG5leHBvcnRzLlRBQiA9ICd3dy10YWInO1xuLyoqXG4gKiBUQUJfQkFSXG4gKi9cbmV4cG9ydHMuVEFCX0JBUiA9ICd3dy10YWItYmFyJztcbi8qKlxuICogVGFiQ2xpY2tlZEV2ZW50IGlzIGZpcmVkIHdoZW4gYSB1c2VyIGNsaWNrcyBvbiBhIHRhYi5cbiAqXG4gKiBJdCBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdGFiIHRoYXQgd2FzIGNsaWNrZWQuXG4gKi9cbmNsYXNzIFRhYkNsaWNrZWRFdmVudCBleHRlbmRzIF9fMi5FdmVudCB7XG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICBzdXBlcihuYW1lLCBuYW1lKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB9XG59XG5leHBvcnRzLlRhYkNsaWNrZWRFdmVudCA9IFRhYkNsaWNrZWRFdmVudDtcbi8qKlxuICogVGFiIHByb3ZpZGVzIGEgc2luZ2xlIHRhYiBpdGVtLlxuICpcbiAqIFdoZW4gYSB0YWIgaXMgY2xpY2tlZCwgaXQgYXR0ZW1wdHMgdG8gcmVtb3ZlIHRoZSBhY3RpdmUgY2xhc3MgZnJvbVxuICogaXQncyBzaWJsaW5ncyBhbmQgYXBwbHkgaXQgdG8gaXRzZWxmLiBUaGVyZWZvcmUgdGhlIHNpYmxpbmcgb2YgYVxuICogdGFiIHNob3VsZCBhbHdheXMgYmUgYSBUYWIuXG4gKi9cbmNsYXNzIFRhYiBleHRlbmRzIF9fMi5BYnN0cmFjdENvbnRyb2wge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuVGFiKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdyb290J1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaWQ6ICgwLCBfXzEuZ2V0SWQpKHRoaXMuYXR0cnMpLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogKDAsIHV0aWxfMS5jb25jYXQpKGV4cG9ydHMuVEFCLCAoMCwgX18xLmdldENsYXNzTmFtZSkodGhpcy5hdHRycyksICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuYWN0aXZlKSA/IGFjdGl2ZV8xLkFDVElWRSA6ICcnKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAnbGluaydcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMudGV4dCkgP1xuICAgICAgICAgICAgICAgICAgICBbKDAsIGRvbV8xLnRleHQpKHRoaXMuYXR0cnMudGV4dCldIDogdGhpcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgICBjbGlja2VkOiAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXliZVJvb3QgPSAoMCwgdXRpbF8xLmdldEJ5SWQpKHRoaXMudmlldywgdGhpcy52YWx1ZXMucm9vdC53bWwuaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF5YmVSb290LmlzTm90aGluZygpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcm9vdCA9IG1heWJlUm9vdC5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhcmVudCA9IHJvb3QucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNpYnMgPSBwYXJlbnQuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2licy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpYnNbaV0uY2xhc3NMaXN0LnJlbW92ZShhY3RpdmVfMS5BQ1RJVkUpO1xuICAgICAgICAgICAgICAgICAgICByb290LmNsYXNzTGlzdC5hZGQoYWN0aXZlXzEuQUNUSVZFKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5vbkNsaWNrKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5vbkNsaWNrKG5ldyBUYWJDbGlja2VkRXZlbnQoYCR7dGhpcy5hdHRycy5uYW1lfWApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNsaWNrIHRoaXMgVGFiXG4gICAgICovXG4gICAgY2xpY2soKSB7XG4gICAgICAgICgwLCB1dGlsXzEuZ2V0QnlJZCkodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5yb290LndtbC5pZClcbiAgICAgICAgICAgIC5tYXAoZSA9PiBlLmNsaWNrKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLlRhYiA9IFRhYjtcbi8qKlxuICogVGFiQmFyIGFjdHMgYXMgYSBwYXJlbnQgY29udGFpbmVyIGZvciBhIGdyb3VwIG9mIFRhYi5cbiAqXG4gKiBVc2UgaXQgdG8gY3JlYXRlIGEgdGFiYmVkIG5hdmlnYXRpb24gb3IgdmlldyBmb3IgbWFpbiBsYXlvdXQsXG4gKiBzdWIgdmlld3Mgb3IgZm9ybXMgZXRjLlxuICovXG5jbGFzcyBUYWJCYXIgZXh0ZW5kcyB3bWxfMS5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuVGFiQmFyKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgICAgICBpZDogKDAsIF9fMS5nZXRJZCkodGhpcy5hdHRycyksXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAoMCwgdXRpbF8xLmNvbmNhdCkoZXhwb3J0cy5UQUJfQkFSLCAoMCwgX18xLmdldENsYXNzTmFtZSkodGhpcy5hdHRycyksICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuanVzdGlmeSkgPyBvcmllbnRhdGlvbl8xLkpVU1RJRklFRCA6ICcnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuVGFiQmFyID0gVGFiQmFyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRhYiA9IGV4cG9ydHMuVGFiQmFyID0gdm9pZCAwO1xuY29uc3QgX19kb2N1bWVudCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbmNvbnN0IG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgVGFiQmFyIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgndWwnLCB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMucm9vdC5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5yb290LmNsYXNzTmFtZSB9LCBbXG4gICAgICAgICAgICAgICAgLi4uKF9fY29udGV4dC5jaGlsZHJlbilcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5UYWJCYXIgPSBUYWJCYXI7XG47XG5jbGFzcyBUYWIge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdsaScsIHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMucm9vdC53bWwuaWQgfSwgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5yb290LmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NOYW1lIH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnYScsIHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuYS53bWwuaWQgfSwgJ2hyZWYnOiAnIycsICdvbmNsaWNrJzogX19jb250ZXh0LnZhbHVlcy5hLmNsaWNrZWQgfSwgW1xuICAgICAgICAgICAgICAgICAgICAuLi4oX19jb250ZXh0LnZhbHVlcy5hLmNvbnRlbnQpXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5UYWIgPSBUYWI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWItYmFyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UYWcgPSBleHBvcnRzLkRpc21pc3NFdmVudCA9IGV4cG9ydHMuVEFHX0NPTlRST0xfRElTTUlTUyA9IGV4cG9ydHMuVEFHX0NPTlRST0xfVEVYVCA9IGV4cG9ydHMuVEFHX0NPTlRST0wgPSB2b2lkIDA7XG5jb25zdCBzdHlsZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRlbnQvc3R5bGVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbmNvbnN0IF9fMSA9IHJlcXVpcmUoXCIuLi8uLi9cIik7XG5jb25zdCBfXzIgPSByZXF1aXJlKFwiLi4vXCIpO1xuY29uc3QgdGFnXzEgPSByZXF1aXJlKFwiLi93bWwvdGFnXCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5UQUdfQ09OVFJPTCA9ICd3dy10YWctY29udHJvbCc7XG5leHBvcnRzLlRBR19DT05UUk9MX1RFWFQgPSAnd3ctdGFnLWNvbnRyb2xfX3RleHQnO1xuZXhwb3J0cy5UQUdfQ09OVFJPTF9ESVNNSVNTID0gJ3d3LXRhZy1jb250cm9sX19kaXNtaXNzJztcbi8qKlxuICogRGlzbWlzc0V2ZW50IGlzIGdlbmVyYXRlZCB3aGVuIHRoZSBjbG9zZSBidXR0b24gdXMgY2xpY2tlZC5cbiAqL1xuY2xhc3MgRGlzbWlzc0V2ZW50IGV4dGVuZHMgX18yLkV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIHN1cGVyKG5hbWUsIHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgfVxufVxuZXhwb3J0cy5EaXNtaXNzRXZlbnQgPSBEaXNtaXNzRXZlbnQ7XG4vKipcbiAqIFRhZyBkaXNwbGF5cyBzb21lIHRleHQgaW4gYSBkaXNtaXNzYWJsZSB0YWcuXG4gKlxuICogVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGlzIFRhZyBhbmQgdGhlIG9uZSBmcm9tIHRoZSBjb250ZW50XG4gKiBtb2R1bGUgaXMgdGhhdCB0aGlzIG9uZSBpcyBwcmltYXJpbHkgbWVhbnQgdG8gYmUgdXNlZCBhcyBhIGNvbnRyb2xcbiAqIG9yIGFzIHBhcnQgb2YgYSBtb3JlIGNvbXBsaWNhdGVkIGNvbnRyb2wuXG4gKi9cbmNsYXNzIFRhZyBleHRlbmRzIF9fMi5BYnN0cmFjdENvbnRyb2wge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdGFnXzEuTWFpbih0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBpZDogKDAsIF9fMS5nZXRJZCkodGhpcy5hdHRycyksXG4gICAgICAgICAgICBjbGFzc05hbWU6ICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLlRBR19DT05UUk9MLCAoMCwgX18xLmdldENsYXNzTmFtZSkodGhpcy5hdHRycykpLFxuICAgICAgICAgICAgc3R5bGU6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuc3R5bGUpID9cbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLnN0eWxlIDogc3R5bGVfMS5TdHlsZS5EZWZhdWx0LFxuICAgICAgICAgICAgZGlzYWJsZWQ6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuZGlzYWJsZWQpID9cbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLmRpc2FibGVkIDogZmFsc2UsXG4gICAgICAgICAgICB0ZXh0OiB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBleHBvcnRzLlRBR19DT05UUk9MX1RFWFQsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMudGV4dCkgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLnRleHQgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGlzbWlzczoge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogZXhwb3J0cy5UQUdfQ09OVFJPTF9ESVNNSVNTLFxuICAgICAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5vbkRpc21pc3MpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLm9uRGlzbWlzcyhuZXcgRGlzbWlzc0V2ZW50KHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5uYW1lIHx8ICcnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuVGFnID0gVGFnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1haW4gPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbmNvbnN0IHQgPSByZXF1aXJlKFwiLi4vLi4vLi4vY29udGVudC90YWdcIik7XG47XG5jb25zdCBjbG9zZV8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2NvbnRlbnQvY2xvc2VcIik7XG47XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChuZXcgdC5UYWcoeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmlkLCAnY2xhc3NOYW1lJzogX19jb250ZXh0LnZhbHVlcy5jbGFzc05hbWUsICdzdHlsZSc6IF9fY29udGV4dC52YWx1ZXMuc3R5bGUgfSwgW1xuICAgICAgICAgICAgICAgIC4uLigoKF9fY29udGV4dC52YWx1ZXMudGV4dC52YWx1ZSAhPT0gJycpKSA/XG4gICAgICAgICAgICAgICAgICAgICgoKSA9PiAoW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3NwYW4nLCB7ICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMudGV4dC5jbGFzc05hbWUgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQoX19jb250ZXh0LnZhbHVlcy50ZXh0LnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgXSkpKCkgOlxuICAgICAgICAgICAgICAgICAgICAoKCkgPT4gKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQoJycpXG4gICAgICAgICAgICAgICAgICAgIF0pKSgpKSxcbiAgICAgICAgICAgICAgICAuLi4oX19jb250ZXh0LmNoaWxkcmVuKSxcbiAgICAgICAgICAgICAgICAuLi4oKChfX2NvbnRleHQudmFsdWVzLmRpc2FibGVkICE9PSB0cnVlKSkgP1xuICAgICAgICAgICAgICAgICAgICAoKCkgPT4gKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGNsb3NlXzEuQ2xvc2UoeyAnY2xhc3NOYW1lJzogX19jb250ZXh0LnZhbHVlcy5kaXNtaXNzLmNsYXNzTmFtZSwgJ29uQ2xpY2snOiBfX2NvbnRleHQudmFsdWVzLmRpc21pc3Mub25DbGljayB9LCBbXSksIHsgJ2NsYXNzTmFtZSc6IF9fY29udGV4dC52YWx1ZXMuZGlzbWlzcy5jbGFzc05hbWUsICdvbkNsaWNrJzogX19jb250ZXh0LnZhbHVlcy5kaXNtaXNzLm9uQ2xpY2sgfSlcbiAgICAgICAgICAgICAgICAgICAgXSkpKCkgOlxuICAgICAgICAgICAgICAgICAgICAoKCkgPT4gKFtdKSkoKSlcbiAgICAgICAgICAgIF0pLCB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuaWQsICdjbGFzc05hbWUnOiBfX2NvbnRleHQudmFsdWVzLmNsYXNzTmFtZSwgJ3N0eWxlJzogX19jb250ZXh0LnZhbHVlcy5zdHlsZSB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWcuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRleHRGaWVsZCA9IGV4cG9ydHMuVEVYVF9GSUVMRCA9IGV4cG9ydHMuVGV4dENoYW5nZWRFdmVudCA9IHZvaWQgMDtcbmNvbnN0IHZpZXdzID0gcmVxdWlyZShcIi4vd21sL3RleHQtZmllbGRcIik7XG5jb25zdCByZWNvcmRfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9yZWNvcmRcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbmNvbnN0IGZlZWRiYWNrXzEgPSByZXF1aXJlKFwiLi4vZmVlZGJhY2tcIik7XG5jb25zdCBmb3JtXzEgPSByZXF1aXJlKFwiLi4vZm9ybVwiKTtcbmNvbnN0IHRleHRfaW5wdXRfMSA9IHJlcXVpcmUoXCIuLi90ZXh0LWlucHV0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGV4dENoYW5nZWRFdmVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGV4dF9pbnB1dF8xLlRleHRDaGFuZ2VkRXZlbnQ7IH0gfSk7XG5jb25zdCBfXzEgPSByZXF1aXJlKFwiLi4vLi4vXCIpO1xuY29uc3QgX18yID0gcmVxdWlyZShcIi4uL1wiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuVEVYVF9GSUVMRCA9ICd3dy10ZXh0LWZpZWxkJztcbi8qKlxuICogVGV4dEZpZWxkIHByb3ZpZGVzIGEgd3JhcHBlZCBuYXRpdmUgdGV4dCBpbnB1dCBjb250cm9sLlxuICovXG5jbGFzcyBUZXh0RmllbGQgZXh0ZW5kcyBmb3JtXzEuQWJzdHJhY3RGb3JtQ29udHJvbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdyb290J1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAoMCwgdXRpbF8xLmNvbmNhdCkoZXhwb3J0cy5URVhUX0ZJRUxELCAoMCwgX18xLmdldENsYXNzTmFtZSkodGhpcy5hdHRycyksICgwLCBmZWVkYmFja18xLmdldFZhbGlkaXR5Q2xhc3NOYW1lKSh0aGlzLmF0dHJzKSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZXNzYWdlczoge1xuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ21lc3NhZ2UnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0ZXh0OiAoMCwgZmVlZGJhY2tfMS5nZXRNZXNzYWdlKSh0aGlzLmF0dHJzKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICgwLCBfXzIuZ2V0TmFtZSkodGhpcy5hdHRycyksXG4gICAgICAgICAgICAgICAgdGV4dDogKDAsIGZvcm1fMS5nZXRMYWJlbCkodGhpcy5hdHRycylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250cm9sOiB7XG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAncm9vdCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGF0dHJzOiAoMCwgcmVjb3JkXzEubWVyZ2UpKHRoaXMuYXR0cnMuaHRtbCB8fCB7fSwge1xuICAgICAgICAgICAgICAgICAgICBpZDogKDAsIF9fMS5nZXRJZCkodGhpcy5hdHRycyksXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICgwLCBfXzIuZ2V0TmFtZSkodGhpcy5hdHRycyksXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMudHlwZSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy50eXBlIDogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICBtaW46ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMubWluKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLm1pbiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgbWF4OiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLm1heCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5tYXggOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGZvY3VzOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmZvY3VzKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLmZvY3VzIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5wbGFjZWhvbGRlcikgP1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5wbGFjZWhvbGRlciA6ICcnLFxuICAgICAgICAgICAgICAgICAgICBtYXRjaDogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5tYXRjaCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5tYXRjaCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmxlbmd0aCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5sZW5ndGggOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLnZhbHVlKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLnZhbHVlIDogJycsXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmRpc2FibGVkKSA/IHRydWUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIHJlYWRPbmx5OiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLnJlYWRPbmx5KSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnVlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICByb3dzOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLnJvd3MpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMucm93cyA6IDEsXG4gICAgICAgICAgICAgICAgICAgIG9uaW5wdXQ6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMub25DaGFuZ2UpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uaW5wdXQodGhpcykgOiAoKSA9PiB7IH0sXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLm9uQ2hhbmdlKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLm9uQ2hhbmdlIDogKCkgPT4geyB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgc2V0TWVzc2FnZShtc2cpIHtcbiAgICAgICAgZ2V0SGVscCh0aGlzKS5tYXAoaCA9PiBoLnNldE1lc3NhZ2UobXNnKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZW1vdmVNZXNzYWdlKCkge1xuICAgICAgICBnZXRIZWxwKHRoaXMpLm1hcChoID0+IGgucmVtb3ZlTWVzc2FnZSgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5UZXh0RmllbGQgPSBUZXh0RmllbGQ7XG5jb25zdCBnZXRIZWxwID0gKHQpID0+ICgwLCB1dGlsXzEuZ2V0QnlJZCkodC52aWV3LCB0LnZhbHVlcy5tZXNzYWdlcy53bWwuaWQpO1xuY29uc3Qgb25pbnB1dCA9IChmKSA9PiAoZSkgPT4ge1xuICAgIGlmIChmLmF0dHJzICYmIGYuYXR0cnMgJiYgZi5hdHRycy5vbkNoYW5nZSlcbiAgICAgICAgZi5hdHRycy5vbkNoYW5nZShuZXcgdGV4dF9pbnB1dF8xLlRleHRDaGFuZ2VkRXZlbnQoKGYuYXR0cnMgJiYgZi5hdHRycy5uYW1lKSA/XG4gICAgICAgICAgICBmLmF0dHJzLm5hbWUgOiAnJywgZS50YXJnZXQudmFsdWUpKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWFpbiA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuY29uc3QgbGFiZWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9sYWJlbFwiKTtcbjtcbmNvbnN0IGhlbHBfMSA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwXCIpO1xuO1xuY29uc3QgdGV4dF9pbnB1dF8xID0gcmVxdWlyZShcIi4uLy4uL3RleHQtaW5wdXRcIik7XG47XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ2RpdicsIHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMucm9vdC53bWwuaWQgfSwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5yb290LmNsYXNzTmFtZSB9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgbGFiZWxfMS5MYWJlbCh7ICdmb3InOiBfX2NvbnRleHQudmFsdWVzLmNvbnRyb2wuYXR0cnMuaWQsICd0ZXh0JzogX19jb250ZXh0LnZhbHVlcy5sYWJlbC50ZXh0IH0sIFtdKSwgeyAnZm9yJzogX19jb250ZXh0LnZhbHVlcy5jb250cm9sLmF0dHJzLmlkLCAndGV4dCc6IF9fY29udGV4dC52YWx1ZXMubGFiZWwudGV4dCB9KSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyB0ZXh0X2lucHV0XzEuVGV4dElucHV0KF9fY29udGV4dC52YWx1ZXMuY29udHJvbC5hdHRycywgW10pLCBfX2NvbnRleHQudmFsdWVzLmNvbnRyb2wuYXR0cnMpLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGhlbHBfMS5IZWxwKHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMubWVzc2FnZXMud21sLmlkIH0sICd0ZXh0JzogX19jb250ZXh0LnZhbHVlcy5tZXNzYWdlcy50ZXh0IH0sIFtdKSwgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5tZXNzYWdlcy53bWwuaWQgfSwgJ3RleHQnOiBfX2NvbnRleHQudmFsdWVzLm1lc3NhZ2VzLnRleHQgfSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRleHQtZmllbGQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRleHRJbnB1dCA9IGV4cG9ydHMuVGV4dENoYW5nZWRFdmVudCA9IGV4cG9ydHMuVEVYVF9JTlBVVCA9IHZvaWQgMDtcbmNvbnN0IHZpZXdzID0gcmVxdWlyZShcIi4vd21sL3RleHQtaW5wdXRcIik7XG5jb25zdCB0aW1lcl8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9jb250cm9sL3RpbWVyXCIpO1xuY29uc3QgcmVjb3JkXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvcmVjb3JkXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG5jb25zdCBvcmllbnRhdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRlbnQvb3JpZW50YXRpb25cIik7XG5jb25zdCBzaXplXzEgPSByZXF1aXJlKFwiLi4vLi4vY29udGVudC9zaXplXCIpO1xuY29uc3QgZm9jdXNfMSA9IHJlcXVpcmUoXCIuLi9mb2N1c1wiKTtcbmNvbnN0IF9fMSA9IHJlcXVpcmUoXCIuLi8uLi9cIik7XG5jb25zdCBfXzIgPSByZXF1aXJlKFwiLi4vXCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5URVhUX0lOUFVUID0gJ3d3LXRleHQtaW5wdXQnO1xuLyoqXG4gKiBUZXh0Q2hhbmdlZEV2ZW50XG4gKi9cbmNsYXNzIFRleHRDaGFuZ2VkRXZlbnQgZXh0ZW5kcyBfXzIuRXZlbnQge1xufVxuZXhwb3J0cy5UZXh0Q2hhbmdlZEV2ZW50ID0gVGV4dENoYW5nZWRFdmVudDtcbi8qKlxuICogVGV4dElucHV0IHByb3ZpZGVzIHNvbWUgZXh0cmEgc3R5bGluZyB0byB0aGUgbmF0aXZlIGlucHV0LlxuICovXG5jbGFzcyBUZXh0SW5wdXQgZXh0ZW5kcyBfXzIuQWJzdHJhY3RDb250cm9sIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52aWV3ID0gKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5yb3dzICYmIHRoaXMuYXR0cnMucm93cyA+IDEpID9cbiAgICAgICAgICAgIG5ldyB2aWV3cy5UZXh0YXJlYSh0aGlzKSA6IG5ldyB2aWV3cy5JbnB1dCh0aGlzKTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmxlbmd0aCkgP1xuICAgICAgICAgICAgdGhpcy5hdHRycy5sZW5ndGggOiBJbmZpbml0eTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBjb250cm9sOiB7XG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAncm9vdCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXR0cnM6ICgwLCByZWNvcmRfMS5tZXJnZSkoKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5odG1sKSB8fCB7fSwge1xuICAgICAgICAgICAgICAgIGlkOiAoMCwgX18xLmdldElkKSh0aGlzLmF0dHJzKSxcbiAgICAgICAgICAgICAgICBjbGFzczogKDAsIHV0aWxfMS5jb25jYXQpKGV4cG9ydHMuVEVYVF9JTlBVVCwgKDAsIF9fMS5nZXRDbGFzc05hbWUpKHRoaXMuYXR0cnMpLCAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLnNpemUpID9cbiAgICAgICAgICAgICAgICAgICAgKDAsIHNpemVfMS5nZXRTaXplQ2xhc3NOYW1lKSh0aGlzLmF0dHJzLnNpemUpIDogJycsICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuYmxvY2spID9cbiAgICAgICAgICAgICAgICAgICAgb3JpZW50YXRpb25fMS5CTE9DSyA6ICcnKSxcbiAgICAgICAgICAgICAgICBuYW1lOiAoMCwgX18yLmdldE5hbWUpKHRoaXMuYXR0cnMpLFxuICAgICAgICAgICAgICAgIHR5cGU6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMudHlwZSkgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLnR5cGUgOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgbWluOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLm1pbikgP1xuICAgICAgICAgICAgICAgICAgICBTdHJpbmcodGhpcy5hdHRycy5taW4pIDogbnVsbCxcbiAgICAgICAgICAgICAgICBtYXg6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMubWF4KSA/XG4gICAgICAgICAgICAgICAgICAgIFN0cmluZyh0aGlzLmF0dHJzLm1heCkgOiBudWxsLFxuICAgICAgICAgICAgICAgIG1hdGNoOiBuZXcgUmVnRXhwKCh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMubWF0Y2gpID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5tYXRjaCA6ICcuJyksXG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMucGxhY2Vob2xkZXIpID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5wbGFjZWhvbGRlciA6ICcnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLnZhbHVlKSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMudmFsdWUgOiAnJyxcbiAgICAgICAgICAgICAgICByb3dzOiBTdHJpbmcoKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5yb3dzKSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMucm93cyA6IDEpLFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmRpc2FibGVkID09PSB0cnVlKSA/XG4gICAgICAgICAgICAgICAgICAgIHRydWUgOiBudWxsLFxuICAgICAgICAgICAgICAgIHJlYWRPbmx5OiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLnJlYWRPbmx5ID09PSB0cnVlKSA/XG4gICAgICAgICAgICAgICAgICAgIHRydWUgOiBudWxsLFxuICAgICAgICAgICAgICAgIG9ua2V5ZG93bjogKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUua2V5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gZS50YXJnZXQudmFsdWUgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKCF0aGlzLnZhbHVlcy5hdHRycy5tYXRjaC50ZXN0KGUua2V5KSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodmFsdWUubGVuZ3RoID4gdGhpcy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25pbnB1dDogZGlzcGF0Y2hJbnB1dCh0aGlzKSxcbiAgICAgICAgICAgICAgICBhdXRvZm9jdXM6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuZm9jdXMpID8gdHJ1ZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBvbmZvY3VzOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMub25Gb2N1c0dhaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMub25Gb2N1c0dhaW5lZChuZXcgZm9jdXNfMS5Gb2N1c0dhaW5lZEV2ZW50KCgwLCBfXzIuZ2V0TmFtZSkodGhpcy5hdHRycykpKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uYmx1cjogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLm9uRm9jdXNMb3N0KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5vbkZvY3VzTG9zdChuZXcgZm9jdXNfMS5Gb2N1c0xvc3RFdmVudCgoMCwgX18yLmdldE5hbWUpKHRoaXMuYXR0cnMpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlcy5hdHRycy5hdXRvZm9jdXMgPT09IHRydWUpXG4gICAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgfVxuICAgIGZvY3VzKCkge1xuICAgICAgICByZXR1cm4gKDAsIHRpbWVyXzEudGljaykoKCkgPT4gKDAsIGZvY3VzXzEuZm9jdXMpKHRoaXMudmlldywgdGhpcy52YWx1ZXMuY29udHJvbC53bWwuaWQpKTtcbiAgICB9XG59XG5leHBvcnRzLlRleHRJbnB1dCA9IFRleHRJbnB1dDtcbi8qKlxuICogZGlzcGF0Y2hJbnB1dCB3aGVuIHRoZSB1c2VyIGlucHV0cyBzb21lIHRleHQuXG4gKi9cbmNvbnN0IGRpc3BhdGNoSW5wdXQgPSAoaSkgPT4gKGUpID0+IHtcbiAgICBpZiAoaS5hdHRycyAmJiBpLmF0dHJzLm9uQ2hhbmdlKVxuICAgICAgICBpLmF0dHJzLm9uQ2hhbmdlKG5ldyBUZXh0Q2hhbmdlZEV2ZW50KChpLmF0dHJzICYmIGkuYXR0cnMubmFtZSkgP1xuICAgICAgICAgICAgaS5hdHRycy5uYW1lIDogJycsIGUudGFyZ2V0LnZhbHVlKSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklucHV0ID0gZXhwb3J0cy5UZXh0YXJlYSA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuY29uc3QgZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9faWYgPSAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpID0+IChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0ID8gX19hbHQoKSA6IFtdO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9ySW4gPSAobGlzdCwgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2Zvck9mID0gKG8sIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHRleHQgPSBfX2RvY3VtZW50LnRleHQ7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHVuc2FmZSA9IF9fZG9jdW1lbnQudW5zYWZlO1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCBpc1NldCA9ICh2YWx1ZSkgPT4gdmFsdWUgIT0gbnVsbDtcbmNsYXNzIFRleHRhcmVhIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgndGV4dGFyZWEnLCBfX2NvbnRleHQudmFsdWVzLmF0dHJzLCBbXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoX19jb250ZXh0LnZhbHVlcy5hdHRycy52YWx1ZSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5UZXh0YXJlYSA9IFRleHRhcmVhO1xuO1xuY2xhc3MgSW5wdXQge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdpbnB1dCcsIF9fY29udGV4dC52YWx1ZXMuYXR0cnMsIFtdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuSW5wdXQgPSBJbnB1dDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRleHQtaW5wdXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRvb2xiYXIgPSBleHBvcnRzLlRPT0xCQVJfQ09NUEFUID0gZXhwb3J0cy5UT09MQkFSID0gdm9pZCAwO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvdG9vbGJhclwiKTtcbmNvbnN0IHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbmNvbnN0IF9fMSA9IHJlcXVpcmUoXCIuLi8uLi9cIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLlRPT0xCQVIgPSAnd3ctdG9vbGJhcic7XG5leHBvcnRzLlRPT0xCQVJfQ09NUEFUID0gJy10b29sYmFyLWNvbXBhdCc7XG4vKipcbiAqIFRvb2xiYXIgcHJvdmlkZXMgYSB3aWRnZXQgZm9yIGdyb3VwaW5nIHJlbGF0ZWQgY29udHJvbHMgaW50byBhXG4gKiBzaW5nbGUgcm93LlxuICovXG5jbGFzcyBUb29sYmFyIGV4dGVuZHMgd21sXzEuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgICAgIGlkOiAoMCwgX18xLmdldElkKSh0aGlzLmF0dHJzKSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLlRPT0xCQVIsICgwLCBfXzEuZ2V0Q2xhc3NOYW1lKSh0aGlzLmF0dHJzKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlRvb2xiYXIgPSBUb29sYmFyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1haW4gPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnZGl2JywgeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMucm9vdC5jbGFzc05hbWUgfSwgW1xuICAgICAgICAgICAgICAgIC4uLihfX2NvbnRleHQuY2hpbGRyZW4pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b29sYmFyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UeXBlYWhlYWQgPSBleHBvcnRzLlRZUEVBSEVBRCA9IGV4cG9ydHMuSXRlbVNlbGVjdGVkRXZlbnQgPSBleHBvcnRzLlRleHRDaGFuZ2VkRXZlbnQgPSBleHBvcnRzLlRlcm1DaGFuZ2VkRXZlbnQgPSB2b2lkIDA7XG5jb25zdCB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC90eXBlYWhlYWRcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbmNvbnN0IGZvcm1fMSA9IHJlcXVpcmUoXCIuLi9mb3JtXCIpO1xuY29uc3Qgc2VhcmNoXzEgPSByZXF1aXJlKFwiLi4vc2VhcmNoXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGVybUNoYW5nZWRFdmVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VhcmNoXzEuVGVybUNoYW5nZWRFdmVudDsgfSB9KTtcbmNvbnN0IHRleHRfZmllbGRfMSA9IHJlcXVpcmUoXCIuLi90ZXh0LWZpZWxkXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGV4dENoYW5nZWRFdmVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGV4dF9maWVsZF8xLlRleHRDaGFuZ2VkRXZlbnQ7IH0gfSk7XG5jb25zdCBzZWxlY3RfMSA9IHJlcXVpcmUoXCIuLi9zZWxlY3RcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJdGVtU2VsZWN0ZWRFdmVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZWN0XzEuSXRlbVNlbGVjdGVkRXZlbnQ7IH0gfSk7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLlRZUEVBSEVBRCA9ICd3dy10eXBlYWhlYWQnO1xuLyoqXG4gKiBUeXBlYWhlYWQgcHJvdmlkZXMgYW4gdGV4dCBpbnB1dCBmaWVsZCB0aGF0IGNhbiBzdWdnZXN0cyB2YWx1ZXNcbiAqIGFzIHRoZSB1c2VyIHR5cGVzLlxuICovXG5jbGFzcyBUeXBlYWhlYWQgZXh0ZW5kcyBmb3JtXzEuQWJzdHJhY3RGb3JtQ29udHJvbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHJvb3Q6IG5ldyBzZWxlY3RfMS5Sb290U2VjdGlvbih0aGlzLmF0dHJzKSxcbiAgICAgICAgICAgIGNvbnRyb2w6IG5ldyBzZWxlY3RfMS5Db250cm9sU2VjdGlvbigpLFxuICAgICAgICAgICAgbWVzc2FnZXM6IG5ldyBzZWxlY3RfMS5NZXNzYWdlc1NlY3Rpb24odGhpcy5hdHRycyksXG4gICAgICAgICAgICBsYWJlbDogbmV3IHNlbGVjdF8xLkxhYmVsU2VjdGlvbih0aGlzLmF0dHJzKSxcbiAgICAgICAgICAgIHNlYXJjaDogbmV3IHNlbGVjdF8xLlNlYXJjaFNlY3Rpb24odGhpcy5hdHRycywgKCkgPT4gdGhpcy5jbG9zZSgpLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBsZXQgbVNlYXJjaCA9ICgwLCB1dGlsXzEuZ2V0QnlJZCkodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5zZWFyY2gud21sLmlkKTtcbiAgICAgICAgICAgICAgICBpZiAobVNlYXJjaC5pc0p1c3QoKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcyA9IG1TZWFyY2guZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdHIgPSAodGhpcy52YWx1ZXMuc2VhcmNoLnN0cmluZ2lmaWVyKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcy5zZWFyY2guc3RyaW5naWZpZXIoZS52YWx1ZSkgOiBlLnZhbHVlICsgJyc7XG4gICAgICAgICAgICAgICAgICAgIHMuc2V0KHN0cik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMub25DaGFuZ2UpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLm9uQ2hhbmdlKG5ldyB0ZXh0X2ZpZWxkXzEuVGV4dENoYW5nZWRFdmVudCgnJyArIHRoaXMuYXR0cnMubmFtZSwgc3RyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgb3BlbigpIHtcbiAgICAgICAgKDAsIHNlbGVjdF8xLm9wZW4pKHRoaXMudmlldywgdGhpcy52YWx1ZXMuc2VhcmNoLndtbC5pZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgKDAsIHNlbGVjdF8xLmNsb3NlKSh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLnNlYXJjaC53bWwuaWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0TWVzc2FnZShtc2cpIHtcbiAgICAgICAgdGhpcy52YWx1ZXMubWVzc2FnZXMudGV4dCA9IG1zZztcbiAgICAgICAgKDAsIGZvcm1fMS5zZXRNZXNzYWdlKSh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLm1lc3NhZ2VzLndtbC5pZCwgbXNnKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlbW92ZU1lc3NhZ2UoKSB7XG4gICAgICAgIHRoaXMudmFsdWVzLm1lc3NhZ2VzLnRleHQgPSAnJztcbiAgICAgICAgKDAsIGZvcm1fMS5yZW1vdmVNZXNzYWdlKSh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLm1lc3NhZ2VzLndtbC5pZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB1cGRhdGUocmVzdWx0cykge1xuICAgICAgICAoMCwgc2VsZWN0XzEudXBkYXRlKSh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLnNlYXJjaC53bWwuaWQsIHJlc3VsdHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLlR5cGVhaGVhZCA9IFR5cGVhaGVhZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYWluID0gdm9pZCAwO1xuY29uc3QgX19kb2N1bWVudCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbmNvbnN0IG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG5jb25zdCBzZWFyY2hfMSA9IHJlcXVpcmUoXCIuLi8uLi9zZWFyY2hcIik7XG47XG5jb25zdCBsYWJlbF8xID0gcmVxdWlyZShcIi4uLy4uL2xhYmVsXCIpO1xuO1xuY29uc3QgaGVscF8xID0gcmVxdWlyZShcIi4uLy4uL2hlbHBcIik7XG47XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ2RpdicsIHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5yb290LmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NOYW1lIH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBsYWJlbF8xLkxhYmVsKHsgJ2Zvcic6IF9fY29udGV4dC52YWx1ZXMucm9vdC5pZCwgJ3RleHQnOiBfX2NvbnRleHQudmFsdWVzLmxhYmVsLnRleHQgfSwgW10pLCB7ICdmb3InOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuaWQsICd0ZXh0JzogX19jb250ZXh0LnZhbHVlcy5sYWJlbC50ZXh0IH0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHNlYXJjaF8xLlNlYXJjaCh7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLnNlYXJjaC53bWwuaWQgfSwgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLnNlYXJjaC5uYW1lLCAnY2xhc3NOYW1lJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2guY2xhc3NOYW1lLCAnYmxvY2snOiBfX2NvbnRleHQudmFsdWVzLnNlYXJjaC5ibG9jaywgJ2Rpc2FibGVkJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2guZGlzYWJsZWQsICdwbGFjZWhvbGRlcic6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLnBsYWNlaG9sZGVyLCAncmVhZE9ubHknOiBfX2NvbnRleHQudmFsdWVzLnNlYXJjaC5yZWFkT25seSwgJ2l0ZW1UZW1wbGF0ZSc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLml0ZW1UZW1wbGF0ZSwgJ25vSXRlbXNUZW1wbGF0ZSc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLm5vSXRlbXNUZW1wbGF0ZSwgJ3N0cmluZ2lmaWVyJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2guc3RyaW5naWZpZXIsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLm9uU2VhcmNoLCAnb25TZWxlY3QnOiBfX2NvbnRleHQudmFsdWVzLnNlYXJjaC5vblNlbGVjdCB9LCBbXSksIHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLndtbC5pZCB9LCAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLm5hbWUsICdjbGFzc05hbWUnOiBfX2NvbnRleHQudmFsdWVzLnNlYXJjaC5jbGFzc05hbWUsICdibG9jayc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLmJsb2NrLCAnZGlzYWJsZWQnOiBfX2NvbnRleHQudmFsdWVzLnNlYXJjaC5kaXNhYmxlZCwgJ3BsYWNlaG9sZGVyJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2gucGxhY2Vob2xkZXIsICdyZWFkT25seSc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLnJlYWRPbmx5LCAnaXRlbVRlbXBsYXRlJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2guaXRlbVRlbXBsYXRlLCAnbm9JdGVtc1RlbXBsYXRlJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2gubm9JdGVtc1RlbXBsYXRlLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLnNlYXJjaC5zdHJpbmdpZmllciwgJ29uU2VhcmNoJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2gub25TZWFyY2gsICdvblNlbGVjdCc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLm9uU2VsZWN0IH0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGhlbHBfMS5IZWxwKHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMubWVzc2FnZXMud21sLmlkIH0sICd0ZXh0JzogX19jb250ZXh0LnZhbHVlcy5tZXNzYWdlcy50ZXh0IH0sIFtdKSwgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5tZXNzYWdlcy53bWwuaWQgfSwgJ3RleHQnOiBfX2NvbnRleHQudmFsdWVzLm1lc3NhZ2VzLnRleHQgfSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVhaGVhZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUHJvcGVydHlMaXN0ID0gZXhwb3J0cy5EYXRhQ3R4ID0gZXhwb3J0cy5QUk9QRVJUWV9MSVNUID0gdm9pZCAwO1xuY29uc3Qgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbmNvbnN0IHBhdGhfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9yZWNvcmQvcGF0aFwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xuY29uc3QgX18xID0gcmVxdWlyZShcIi4uLy4uL1wiKTtcbmNvbnN0IHByb3BlcnR5X2xpc3RfMSA9IHJlcXVpcmUoXCIuL3dtbC9wcm9wZXJ0eS1saXN0XCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5QUk9QRVJUWV9MSVNUID0gJ3d3LXByb3BlcnR5LWxpc3QnO1xuLyoqXG4gKiBEYXRhQ3R4XG4gKi9cbmNsYXNzIERhdGFDdHgge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEsIG5hbWUsIHZhbHVlLCBmb3JtYXQpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdDtcbiAgICB9XG59XG5leHBvcnRzLkRhdGFDdHggPSBEYXRhQ3R4O1xuLyoqXG4gKiBQcm9wZXJ0eUxpc3QgZ2VuZXJhdGVzIGEgZGVzY3JpcHRpb24gbGlzdCB1c2luZyB0aGUgcHJvcGVydGllcyBvZlxuICogYW4gb2JqZWN0LlxuICovXG5jbGFzcyBQcm9wZXJ0eUxpc3QgZXh0ZW5kcyB3bWxfMS5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgcHJvcGVydHlfbGlzdF8xLlByb3BlcnR5TGlzdFZpZXcodGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogKDAsIHV0aWxfMS5jb25jYXQpKGV4cG9ydHMuUFJPUEVSVFlfTElTVCwgKDAsIF9fMS5nZXRDbGFzc05hbWUpKHRoaXMuYXR0cnMpKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpZWxkczogKCh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuZmllbGRzKSA/XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRycy5maWVsZHMgOiBbXSksXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6ICgodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmRhdGEpID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5kYXRhIDoge30pLFxuICAgICAgICAgICAgICAgIGdldDogKGYpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1EYXRhID0gKDAsIHBhdGhfMS5nZXQpKGYubmFtZSwgdGhpcy52YWx1ZXMuZGF0YS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtRGF0YS5pc05vdGhpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcHJvcGVydHlfbGlzdF8xLk5vdGhpbmdWaWV3KHt9KS5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSBtRGF0YS5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZtdCA9IChmLmZvcm1hdCkgPyBmLmZvcm1hdCA6IChjKSA9PiAnJyArIGM7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdHggPSBuZXcgRGF0YUN0eChkLCBmLm5hbWUsIHRoaXMudmFsdWVzLmRhdGEudmFsdWUsIGZtdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmLmRhdGFGcmFnbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmLmRhdGFGcmFnbWVudChjdHgpLnJlbmRlcigpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHByb3BlcnR5X2xpc3RfMS5EYXRhVmlldyhjdHgpLnJlbmRlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogc2V0RGF0YSB0byBiZSBkaXNwbGF5ZWQuXG4gICAgICovXG4gICAgc2V0RGF0YShkYXRhKSB7XG4gICAgICAgIHRoaXMudmFsdWVzLmRhdGEudmFsdWUgPSBkYXRhO1xuICAgICAgICB0aGlzLnZpZXcuaW52YWxpZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLlByb3BlcnR5TGlzdCA9IFByb3BlcnR5TGlzdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qcm9wZXJ0eUxpc3RWaWV3ID0gZXhwb3J0cy5EYXRhVmlldyA9IGV4cG9ydHMuTm90aGluZ1ZpZXcgPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbjtcbmNvbnN0IGRlc2NyaXB0aW9uX2xpc3RfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9sYXlvdXQvZGVzY3JpcHRpb24tbGlzdFwiKTtcbjtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBOb3RoaW5nVmlldyB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChuZXcgZGVzY3JpcHRpb25fbGlzdF8xLkRhdGEoe30sIFtdKSwge30pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RoaW5nVmlldyA9IE5vdGhpbmdWaWV3O1xuO1xuY2xhc3MgRGF0YVZpZXcge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQobmV3IGRlc2NyaXB0aW9uX2xpc3RfMS5EYXRhKHt9LCBbXG4gICAgICAgICAgICAgICAgdGV4dChfX2NvbnRleHQuZm9ybWF0KF9fY29udGV4dC5kYXRhKSlcbiAgICAgICAgICAgIF0pLCB7fSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLkRhdGFWaWV3ID0gRGF0YVZpZXc7XG47XG5jbGFzcyBQcm9wZXJ0eUxpc3RWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KG5ldyBkZXNjcmlwdGlvbl9saXN0XzEuRGVzY3JpcHRpb25MaXN0KHsgJ2NsYXNzTmFtZSc6IF9fY29udGV4dC52YWx1ZXMucm9vdC5jbGFzc05hbWUgfSwgW1xuICAgICAgICAgICAgICAgIC4uLl9fZm9ySW4oX19jb250ZXh0LnZhbHVlcy5maWVsZHMsIChmaWVsZCwgXyQkaSwgXyQkYWxsKSA9PiAoW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZXNjcmlwdGlvbl9saXN0XzEuVGl0bGUoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQoZmllbGQuaGVhZGluZylcbiAgICAgICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICAgICAgX19jb250ZXh0LnZhbHVlcy5kYXRhLmdldChmaWVsZClcbiAgICAgICAgICAgICAgICBdKSwgKCkgPT4gKFtdKSlcbiAgICAgICAgICAgIF0pLCB7ICdjbGFzc05hbWUnOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NOYW1lIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5Qcm9wZXJ0eUxpc3RWaWV3ID0gUHJvcGVydHlMaXN0Vmlldztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3BlcnR5LWxpc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNvcnRCeUlkID0gZXhwb3J0cy5Tb3J0UmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IHBhdGhfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9yZWNvcmQvcGF0aFwiKTtcbmNvbnN0IHNvcnRfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9hcnJheS9zb3J0XCIpO1xuLyoqXG4gKiBTb3J0UmVxdWVzdCBjb250YWlucyB0aGUgaW5mbyBuZWVkZWQgdG8gcHJlZm9ybSBhIHNvcnQuXG4gKi9cbmNsYXNzIFNvcnRSZXF1ZXN0IHtcbiAgICBjb25zdHJ1Y3Rvcihjb2x1bW4sIGRhdGEsIGtleSkge1xuICAgICAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgfVxufVxuZXhwb3J0cy5Tb3J0UmVxdWVzdCA9IFNvcnRSZXF1ZXN0O1xuLyoqXG4gKiBzb3J0QnlJZCBzb3J0cyBhIGRhdGFzZXQgYnkgYSBjb2x1bW4gdXNpbmcgdGhlIGNvbHVtbnMgaWQuXG4gKlxuICogRGF0YSBpcyBvbmx5IHNvcnRlZCBieSBvbmUgY29sdW1uIGF0IGEgdGltZS5cbiAqL1xuY29uc3Qgc29ydEJ5SWQgPSAoY29scywga2V5LCBkYXRhLCBpZCkgPT4ge1xuICAgIGxldCBzcGVjID0gY29sc1tpZF07XG4gICAgbGV0IFtjdXJyZW50LCBvcmlnaW5hbF0gPSBkYXRhO1xuICAgIGlmIChzcGVjID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBbY3VycmVudCwga2V5XTtcbiAgICBpZiAoIXNwZWMuc29ydClcbiAgICAgICAgcmV0dXJuIFtjdXJyZW50LCBrZXldO1xuICAgIGlmIChrZXlbMF0gPT09IGlkKSB7XG4gICAgICAgIHJldHVybiBbY3VycmVudC5yZXZlcnNlKCksIFtrZXlbMF0sIGtleVsxXSAqIC0xXV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgc3RyYXRlZ3kgPSBnZXRTb3J0U3RyYXRlZ3koc3BlYy5zb3J0KTtcbiAgICAgICAgbGV0IGFsaWFzID0gc3BlYy5hbGlhcyA/IHNwZWMuYWxpYXMgOiBzcGVjLm5hbWU7XG4gICAgICAgIHJldHVybiBbZG9Tb3J0KG9yaWdpbmFsLnNsaWNlKCksIHN0cmF0ZWd5LCBhbGlhcyksIFtpZCwgLTFdXTtcbiAgICB9XG59O1xuZXhwb3J0cy5zb3J0QnlJZCA9IHNvcnRCeUlkO1xuY29uc3QgZ2V0U29ydFN0cmF0ZWd5ID0gKHMpID0+IHtcbiAgICBpZiAodHlwZW9mIHMgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiBzO1xuICAgIGlmIChzID09PSAnZGF0ZScpXG4gICAgICAgIHJldHVybiBzb3J0XzEuZGF0ZTtcbiAgICBpZiAocyA9PT0gJ251bWJlcicpXG4gICAgICAgIHJldHVybiBzb3J0XzEubnVtYmVyO1xuICAgIGlmIChzID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIHNvcnRfMS5zdHJpbmc7XG4gICAgcmV0dXJuIHNvcnRfMS5uYXR1cmFsO1xufTtcbmNvbnN0IGRvU29ydCA9IChkYXRhLCBzLCBhbGlhcykgPT4gZGF0YS5zb3J0KChhLCBiKSA9PiBzKGdldEFueShhbGlhcywgYSksIGdldEFueShhbGlhcywgYikpKTtcbmNvbnN0IGdldEFueSA9IChwYXRoLCBzcmMpID0+ICgwLCBwYXRoXzEuZ2V0RGVmYXVsdCkocGF0aCwgc3JjLCB1bmRlZmluZWQpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c29ydC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGF0YUNoYW5nZWRFdmVudCA9IGV4cG9ydHMuQ2VsbENsaWNrZWRFdmVudCA9IGV4cG9ydHMuSGVhZGluZ0NsaWNrZWRFdmVudCA9IHZvaWQgMDtcbi8qKlxuICogSGVhZGluZ0NsaWNrZWRFdmVudCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb25cbiAqIG9uZSBvZiB0aGUgY29sdW1uIGhlYWRpbmdzLlxuICovXG5jbGFzcyBIZWFkaW5nQ2xpY2tlZEV2ZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb2x1bW4pIHtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgfVxufVxuZXhwb3J0cy5IZWFkaW5nQ2xpY2tlZEV2ZW50ID0gSGVhZGluZ0NsaWNrZWRFdmVudDtcbi8qKlxuICogQ2VsbENsaWNrZWRFdmVudCB0cmlnZ2VyZWQgd2hlbiBhIGNlbGwgaXMgY2xpY2tlZCBvbi5cbiAqL1xuY2xhc3MgQ2VsbENsaWNrZWRFdmVudCB7XG4gICAgY29uc3RydWN0b3IoY29sdW1uLCByb3cpIHtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgICAgIHRoaXMucm93ID0gcm93O1xuICAgIH1cbn1cbmV4cG9ydHMuQ2VsbENsaWNrZWRFdmVudCA9IENlbGxDbGlja2VkRXZlbnQ7XG4vKipcbiAqIERhdGFDaGFuZ2VkRXZlbnQgZ2VuZXJhdGVkIHdoZW4gdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkYXRhXG4gKiBjaGFuZ2VzLlxuICovXG5jbGFzcyBEYXRhQ2hhbmdlZEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBkYXRhLCBrZXkpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgfVxufVxuZXhwb3J0cy5EYXRhQ2hhbmdlZEV2ZW50ID0gRGF0YUNoYW5nZWRFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EYXRhVGFibGUgPSBleHBvcnRzLk5ld0NlbGxDb250ZXh0ID0gZXhwb3J0cy5OZXdCb2R5Q29udGV4dCA9IGV4cG9ydHMuTmV3SGVhZGluZ0NvbnRleHQgPSBleHBvcnRzLk5ld0hlYWRDb250ZXh0ID0gZXhwb3J0cy5ERVNDID0gZXhwb3J0cy5BU0MgPSBleHBvcnRzLkRBVEFfVEFCTEVfQ0VMTCA9IGV4cG9ydHMuREFUQV9UQUJMRV9CT0RZID0gZXhwb3J0cy5EQVRBX1RBQkxFX0hFQURJTkcgPSBleHBvcnRzLkRBVEFfVEFCTEVfSEVBRCA9IGV4cG9ydHMuREFUQV9UQUJMRSA9IGV4cG9ydHMuSGVhZGluZ0NsaWNrZWRFdmVudCA9IGV4cG9ydHMuQ2VsbENsaWNrZWRFdmVudCA9IGV4cG9ydHMuRGF0YUNoYW5nZWRFdmVudCA9IGV4cG9ydHMuU29ydFJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC90YWJsZVwiKTtcbmNvbnN0IHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG5jb25zdCBhcnJheV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL2FycmF5XCIpO1xuY29uc3QgcGF0aF8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL3JlY29yZC9wYXRoXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG5jb25zdCBfXzEgPSByZXF1aXJlKFwiLi4vLi4vXCIpO1xuY29uc3Qgc29ydF8xID0gcmVxdWlyZShcIi4vY29sdW1uL3NvcnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTb3J0UmVxdWVzdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc29ydF8xLlNvcnRSZXF1ZXN0OyB9IH0pO1xuY29uc3QgZXZlbnRfMSA9IHJlcXVpcmUoXCIuL2V2ZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGF0YUNoYW5nZWRFdmVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXZlbnRfMS5EYXRhQ2hhbmdlZEV2ZW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2VsbENsaWNrZWRFdmVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXZlbnRfMS5DZWxsQ2xpY2tlZEV2ZW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSGVhZGluZ0NsaWNrZWRFdmVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXZlbnRfMS5IZWFkaW5nQ2xpY2tlZEV2ZW50OyB9IH0pO1xuY29uc3QgcmFuZ2VfMSA9IHJlcXVpcmUoXCIuL3JhbmdlXCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5EQVRBX1RBQkxFID0gJ3d3LWRhdGEtdGFibGUnO1xuZXhwb3J0cy5EQVRBX1RBQkxFX0hFQUQgPSAnd3ctZGF0YS10YWJsZV9faGVhZCc7XG5leHBvcnRzLkRBVEFfVEFCTEVfSEVBRElORyA9ICd3dy1kYXRhLXRhYmxlX19oZWFkaW5nJztcbmV4cG9ydHMuREFUQV9UQUJMRV9CT0RZID0gJ3d3LWRhdGEtdGFibGVfX2JvZHknO1xuZXhwb3J0cy5EQVRBX1RBQkxFX0NFTEwgPSAnd3ctZGF0YS10YWJsZV9fY2VsbCc7XG5leHBvcnRzLkFTQyA9ICctYXNjJztcbmV4cG9ydHMuREVTQyA9ICctZGVzYyc7XG4vKipcbiAqIE5ld0hlYWRDb250ZXh0XG4gKi9cbmNsYXNzIE5ld0hlYWRDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3Rvcih0YWJsZSkge1xuICAgICAgICB0aGlzLnRhYmxlID0gdGFibGU7XG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gKDAsIHV0aWxfMS5jb25jYXQpKGV4cG9ydHMuREFUQV9UQUJMRV9IRUFELCAodGhpcy50YWJsZS5hdHRycyAmJiB0aGlzLnRhYmxlLmF0dHJzLmhlYWRDbGFzc05hbWUgfHwgJycpKTtcbiAgICAgICAgdGhpcy5jb2x1bW5zID0gdGhpcy50YWJsZS52YWx1ZXMuY29sdW1ucztcbiAgICAgICAgdGhpcy5kYXRhID0gdGhpcy50YWJsZS52YWx1ZXMuZGF0YXNldFswXTtcbiAgICAgICAgdGhpcy5oZWFkaW5nID0gKGMsIGkpID0+IGdldEhlYWRpbmdWaWV3KHRoaXMudGFibGUsIG5ldyBOZXdIZWFkaW5nQ29udGV4dCh0aGlzLnRhYmxlLCB0aGlzLCBjLCBpKSwgYykucmVuZGVyKCk7XG4gICAgfVxufVxuZXhwb3J0cy5OZXdIZWFkQ29udGV4dCA9IE5ld0hlYWRDb250ZXh0O1xuLyoqXG4gKiBOZXdIZWFkaW5nQ29udGV4dFxuICovXG5jbGFzcyBOZXdIZWFkaW5nQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IodGFibGUsIGhlYWRDb250ZXh0LCBjb2x1bW4sIGluZGV4KSB7XG4gICAgICAgIHRoaXMudGFibGUgPSB0YWJsZTtcbiAgICAgICAgdGhpcy5oZWFkQ29udGV4dCA9IGhlYWRDb250ZXh0O1xuICAgICAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLmNsYXNzTmFtZSA9ICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLkRBVEFfVEFCTEVfSEVBRElORywgKHRoaXMudGFibGUuYXR0cnMgJiYgdGhpcy50YWJsZS5hdHRycy5oZWFkaW5nQ2xhc3NOYW1lIHx8ICcnKSwgdGhpcy5jb2x1bW4uaGVhZGluZ0NsYXNzTmFtZSwgZ2V0U29ydENsYXNzTmFtZSh0aGlzLnRhYmxlLnZhbHVlcy5zb3J0S2V5LCB0aGlzLmluZGV4KSk7XG4gICAgICAgIHRoaXMub25jbGljayA9IChfKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb2x1bW4uc29ydClcbiAgICAgICAgICAgICAgICB0aGlzLnRhYmxlLnZhbHVlcy5zb3J0KHRoaXMuaW5kZXgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29sdW1uLm9uSGVhZGluZ0NsaWNrZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5jb2x1bW4ub25IZWFkaW5nQ2xpY2tlZChuZXcgZXZlbnRfMS5IZWFkaW5nQ2xpY2tlZEV2ZW50KHRoaXMuaW5kZXgpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnRhYmxlLmF0dHJzICYmIHRoaXMudGFibGUuYXR0cnMub25IZWFkaW5nQ2xpY2tlZClcbiAgICAgICAgICAgICAgICB0aGlzLnRhYmxlLmF0dHJzLm9uSGVhZGluZ0NsaWNrZWQobmV3IGV2ZW50XzEuSGVhZGluZ0NsaWNrZWRFdmVudCh0aGlzLmluZGV4KSk7XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5OZXdIZWFkaW5nQ29udGV4dCA9IE5ld0hlYWRpbmdDb250ZXh0O1xuLyoqXG4gKiBOZXdCb2R5Q29udGV4dFxuICovXG5jbGFzcyBOZXdCb2R5Q29udGV4dCB7XG4gICAgY29uc3RydWN0b3IodGFibGUpIHtcbiAgICAgICAgdGhpcy50YWJsZSA9IHRhYmxlO1xuICAgICAgICB0aGlzLmNsYXNzTmFtZSA9ICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLkRBVEFfVEFCTEVfQk9EWSwgKHRoaXMudGFibGUuYXR0cnMgJiYgdGhpcy50YWJsZS5hdHRycy5ib2R5Q2xhc3NOYW1lIHx8ICcnKSk7XG4gICAgICAgIHRoaXMuY29sdW1ucyA9IHRoaXMudGFibGUudmFsdWVzLmNvbHVtbnM7XG4gICAgICAgIHRoaXMuZGF0YSA9IHRoaXMudGFibGUudmFsdWVzLmRhdGFzZXRbMF07XG4gICAgICAgIHRoaXMuY2VsbCA9IChjLCBpZCwgcm93KSA9PiBnZXRDZWxsVmlldyh0aGlzLnRhYmxlLCBuZXcgTmV3Q2VsbENvbnRleHQodGhpcy50YWJsZSwgdGhpcywgYywgaWQsIHJvdyksIGMpLnJlbmRlcigpO1xuICAgIH1cbn1cbmV4cG9ydHMuTmV3Qm9keUNvbnRleHQgPSBOZXdCb2R5Q29udGV4dDtcbi8qKlxuICogTmV3Q2VsbENvbnRleHRcbiAqL1xuY2xhc3MgTmV3Q2VsbENvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHRhYmxlLCBib2R5Q29udGV4dCwgc3BlYywgY29sdW1uLCByb3cpIHtcbiAgICAgICAgdGhpcy50YWJsZSA9IHRhYmxlO1xuICAgICAgICB0aGlzLmJvZHlDb250ZXh0ID0gYm9keUNvbnRleHQ7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICAgICAgICB0aGlzLnJvdyA9IHJvdztcbiAgICAgICAgdGhpcy5pZCA9IGNlbGxJZCh0aGlzLmNvbHVtbiwgdGhpcy5yb3cpO1xuICAgICAgICB0aGlzLmNsYXNzTmFtZSA9ICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLkRBVEFfVEFCTEVfQ0VMTCwgKHRoaXMudGFibGUuYXR0cnMgJiYgdGhpcy50YWJsZS5hdHRycy5jZWxsQ2xhc3NOYW1lIHx8ICcnKSwgdGhpcy5zcGVjLmNlbGxDbGFzc05hbWUsIGdldFNvcnRDbGFzc05hbWUodGhpcy50YWJsZS52YWx1ZXMuc29ydEtleSwgdGhpcy5jb2x1bW4pKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9ICgwLCBwYXRoXzEudW5zYWZlR2V0KSh0aGlzLnNwZWMubmFtZSwgdGhpcy50YWJsZS52YWx1ZXMuZGF0YXNldFswXVt0aGlzLnJvd10pO1xuICAgICAgICB0aGlzLmRhdHVtID0gdGhpcy50YWJsZS52YWx1ZXMuZGF0YXNldFswXVt0aGlzLnJvd107XG4gICAgICAgIHRoaXMuZm9ybWF0ID0gdGhpcy5zcGVjLmZvcm1hdCA/XG4gICAgICAgICAgICB0aGlzLnNwZWMuZm9ybWF0IDpcbiAgICAgICAgICAgIChjKSA9PiBTdHJpbmcoYyA9PSBudWxsID8gJycgOiBjKTtcbiAgICAgICAgdGhpcy5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3BlYy5vbkNlbGxDbGlja2VkKVxuICAgICAgICAgICAgICAgIHRoaXMuc3BlYy5vbkNlbGxDbGlja2VkKG5ldyBldmVudF8xLkNlbGxDbGlja2VkRXZlbnQodGhpcy5jb2x1bW4sIHRoaXMucm93KSk7XG4gICAgICAgICAgICBpZiAodGhpcy50YWJsZS5hdHRycyAmJiB0aGlzLnRhYmxlLmF0dHJzLm9uQ2VsbENsaWNrZWQpXG4gICAgICAgICAgICAgICAgdGhpcy50YWJsZS5hdHRycy5vbkNlbGxDbGlja2VkKG5ldyBldmVudF8xLkNlbGxDbGlja2VkRXZlbnQodGhpcy5jb2x1bW4sIHRoaXMucm93KSk7XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5OZXdDZWxsQ29udGV4dCA9IE5ld0NlbGxDb250ZXh0O1xuLyoqXG4gKiBEYXRhVGFibGUgY2FuIGJlIHVzZWQgZm9yIGRpc3BsYXlpbmcgc29ydGFibGVcbiAqIHRhYnVsYXIgZGF0YS5cbiAqL1xuY2xhc3MgRGF0YVRhYmxlIGV4dGVuZHMgd21sXzEuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudGhlYWRWaWV3ID0gbmV3IHZpZXdzLkVtcHR5Vmlldyh7fSk7XG4gICAgICAgIHRoaXMudGJvZHlWaWV3ID0gbmV3IHZpZXdzLkVtcHR5Vmlldyh7fSk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgd21sOiB7IGlkOiAndGFibGUnIH0sXG4gICAgICAgICAgICBpZDogKDAsIF9fMS5nZXRJZCkodGhpcy5hdHRycyksXG4gICAgICAgICAgICBjbGFzc05hbWU6ICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLkRBVEFfVEFCTEUsICgwLCBfXzEuZ2V0Q2xhc3NOYW1lKSh0aGlzLmF0dHJzKSksXG4gICAgICAgICAgICBuYW1lOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLm5hbWUgfHwgJycpLFxuICAgICAgICAgICAgc29ydGFibGU6ICh0aGlzLmF0dHJzICYmICh0aGlzLmF0dHJzLnNvcnRhYmxlICE9IG51bGwpKSA/XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRycy5zb3J0YWJsZSA6IHRydWUsXG4gICAgICAgICAgICBzb3J0S2V5OiAoKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5zb3J0S2V5KSA/XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRycy5zb3J0S2V5IDogWy0xLCAxXSksXG4gICAgICAgICAgICBzb3J0OiAoY29sKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWVzLnNvcnRhYmxlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvcnQoY29sKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkYXRhc2V0OiAoKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5kYXRhKSA/XG4gICAgICAgICAgICAgICAgW3RoaXMuYXR0cnMuZGF0YS5zbGljZSgpLCB0aGlzLmF0dHJzLmRhdGEuc2xpY2UoKV0gOlxuICAgICAgICAgICAgICAgIFtbXSwgW11dKSxcbiAgICAgICAgICAgIGNvbHVtbnM6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuY29sdW1ucykgP1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMuY29sdW1ucyA6IFtdLFxuICAgICAgICAgICAgdGhlYWQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRoZWFkVmlldyA9IGdldEhlYWRWaWV3KHRoaXMsIG5ldyBOZXdIZWFkQ29udGV4dCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGhlYWRWaWV3LnJlbmRlcigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRib2R5OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50Ym9keVZpZXcgPSBnZXRCb2R5Vmlldyh0aGlzLCBuZXcgTmV3Qm9keUNvbnRleHQodGhpcykpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRib2R5Vmlldy5yZW5kZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmaXJlQ2hhbmdlKCkge1xuICAgICAgICBpZiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLm9uQ2hhbmdlKVxuICAgICAgICAgICAgdGhpcy5hdHRycy5vbkNoYW5nZShuZXcgZXZlbnRfMS5EYXRhQ2hhbmdlZEV2ZW50KHRoaXMudmFsdWVzLm5hbWUsIHRoaXMudmFsdWVzLmRhdGFzZXRbMF0uc2xpY2UoKSwgdGhpcy52YWx1ZXMuc29ydEtleS5zbGljZSgpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHVwZGF0ZSB0aGUgZGF0YSBkaXNwbGF5ZWQgd2l0aCBhIG5ldyBkYXRhLlxuICAgICAqL1xuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIHRoaXMudmFsdWVzLmRhdGFzZXQgPSBbZGF0YS5zbGljZSgpLCBkYXRhLnNsaWNlKCldO1xuICAgICAgICB0aGlzLnZpZXcuaW52YWxpZGF0ZSgpO1xuICAgICAgICB0aGlzLmZpcmVDaGFuZ2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHVwZGF0ZVdpdGhTb3J0S2V5IGlzIGxpa2UgdXBkYXRlIGJ1dCB3aWxsIHNldCB0aGUgc29ydCBrZXkgYXMgd2VsbC5cbiAgICAgKi9cbiAgICB1cGRhdGVXaXRoU29ydEtleShkYXRhLCBrZXkpIHtcbiAgICAgICAgdGhpcy52YWx1ZXMuc29ydEtleSA9IGtleTtcbiAgICAgICAgdGhpcy51cGRhdGUoZGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBzb3J0IHRoZSB0YWJsZSBkYXRhIGJ5IHRoZSBjb2x1bW4gaWQgc3BlY2lmaWVkLlxuICAgICAqXG4gICAgICogVGhlIGRhdGEgY2FuIG9ubHkgYmUgc29ydGVkIGJ5IG9uZSBjb2x1bW4gYXQgYSB0aW1lIGFuZCB0aGF0IGNvbHVtblxuICAgICAqIG11c3Qgc3BlY2lmeSB0aGUgXCJzb3J0XCIga2V5LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgY2F1c2VzIGEgcmVwYWludC5cbiAgICAgKi9cbiAgICBzb3J0KGlkKSB7XG4gICAgICAgIGxldCB7IHNvcnRLZXksIGRhdGFzZXQgfSA9IHRoaXMudmFsdWVzO1xuICAgICAgICBsZXQgZGVsID0gZ2V0U29ydERlbGVnYXRlKHRoaXMpO1xuICAgICAgICBsZXQgW2RhdGEsIGtleV0gPSBkZWwobmV3IHNvcnRfMS5Tb3J0UmVxdWVzdChpZCwgZGF0YXNldFsxXSwgc29ydEtleSkpO1xuICAgICAgICB0aGlzLnZhbHVlcy5kYXRhc2V0WzBdID0gZGF0YTtcbiAgICAgICAgdGhpcy52YWx1ZXMuc29ydEtleSA9IGtleTtcbiAgICAgICAgdGhpcy52aWV3LmludmFsaWRhdGUoKTtcbiAgICAgICAgdGhpcy5maXJlQ2hhbmdlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXRSb3cgcmV0dXJucyBhIFJhbmdlIG9mIEhUTUxUYWJsZUNlbGxFbGVtZW50cyBmb3IgdGhlIHJvd1xuICAgICAqIHRoYXQgbWF0Y2hlcyB0aGUgcHJvdmlkZWQgaWQuXG4gICAgICpcbiAgICAgKiBJZiBubyByb3dzIGFyZSBmb3VuZCBieSB0aGF0IGlkLCB0aGUgUmFuZ2Ugd2lsbCBiZSBlbXB0eS5cbiAgICAgKiBJbiBvcmRlciBmb3IgdGhpcyBtZXRob2QgdG8gd29yayB0aGUgYm9keSB2aWV3IE1VU1QgaW5jbHVkZVxuICAgICAqIHRoZSB3bWw6aWQgb24gZWFjaCA8dHI+IGVsZW1lbnQgdGhhdCByZXByZXNlbnRzIGEgcm93IG9mIGRhdGEuXG4gICAgICovXG4gICAgZ2V0Um93KHJvdykge1xuICAgICAgICBsZXQgbVRyID0gKDAsIHV0aWxfMS5nZXRCeUlkKSh0aGlzLnRib2R5VmlldywgYCR7cm93fWApO1xuICAgICAgICBpZiAobVRyLmlzTm90aGluZygpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyByYW5nZV8xLlJhbmdlSW5zdGFuY2UoW10pO1xuICAgICAgICBsZXQgdHIgPSBtVHIuZ2V0KCk7XG4gICAgICAgIHJldHVybiBuZXcgcmFuZ2VfMS5SYW5nZUluc3RhbmNlKCgwLCBhcnJheV8xLm1ha2UpKHRyLmNlbGxzLmxlbmd0aCwgKG4pID0+IHRyLmNlbGxzW25dKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldENlbGwgcHJvdmlkZXMgYSBSYW5nZSBjb250YWluaW5nIGEgY2VsbCBsb2NhdGVkIGF0IHRoZVxuICAgICAqIGludGVyc2VjdGlvbiBvZiB0aGUgY29sdW1uIGFuZCByb3cuXG4gICAgICovXG4gICAgZ2V0Q2VsbChjb2x1bW4sIHJvdykge1xuICAgICAgICBsZXQgY2VsbHMgPSB0aGlzLmdldFJvdyhyb3cpLmNlbGxzO1xuICAgICAgICBpZiAoIWNlbGxzW2NvbHVtbl0pXG4gICAgICAgICAgICByZXR1cm4gbmV3IHJhbmdlXzEuUmFuZ2VJbnN0YW5jZShbXSk7XG4gICAgICAgIHJldHVybiBuZXcgcmFuZ2VfMS5SYW5nZUluc3RhbmNlKFtjZWxsc1tjb2x1bW5dXSk7XG4gICAgfVxufVxuZXhwb3J0cy5EYXRhVGFibGUgPSBEYXRhVGFibGU7XG5jb25zdCBnZXRIZWFkVmlldyA9ICh0YWJsZSwgY3R4KSA9PiAodGFibGUuYXR0cnMgJiYgdGFibGUuYXR0cnMuaGVhZEZyYWdtZW50KSA/XG4gICAgdGFibGUuYXR0cnMuaGVhZEZyYWdtZW50KGN0eCkgOiBuZXcgdmlld3MuSGVhZFZpZXcoY3R4KTtcbmNvbnN0IGdldEhlYWRpbmdWaWV3ID0gKHRhYmxlLCBjdHgsIGMpID0+IGMuaGVhZGluZ0ZyYWdtZW50ID8gYy5oZWFkaW5nRnJhZ21lbnQoY3R4KSA6XG4gICAgKHRhYmxlLmF0dHJzICYmIHRhYmxlLmF0dHJzLmhlYWRpbmdGcmFnbWVudCkgP1xuICAgICAgICB0YWJsZS5hdHRycy5oZWFkaW5nRnJhZ21lbnQoY3R4KSA6IG5ldyB2aWV3cy5IZWFkaW5nVmlldyhjdHgpO1xuY29uc3QgZ2V0Qm9keVZpZXcgPSAodGFibGUsIGN0eCkgPT4gKHRhYmxlLmF0dHJzICYmIHRhYmxlLmF0dHJzLmJvZHlGcmFnbWVudCkgP1xuICAgIHRhYmxlLmF0dHJzLmJvZHlGcmFnbWVudChjdHgpIDpcbiAgICBuZXcgdmlld3MuQm9keVZpZXcoY3R4KTtcbmNvbnN0IGdldENlbGxWaWV3ID0gKHRhYmxlLCBjdHgsIGMpID0+IGMuY2VsbEZyYWdtZW50ID8gYy5jZWxsRnJhZ21lbnQoY3R4KSA6XG4gICAgKHRhYmxlLmF0dHJzICYmIHRhYmxlLmF0dHJzLmNlbGxGcmFnbWVudCkgP1xuICAgICAgICB0YWJsZS5hdHRycy5jZWxsRnJhZ21lbnQoY3R4KSA6XG4gICAgICAgIG5ldyB2aWV3cy5DZWxsVmlldyhjdHgpO1xuY29uc3QgZ2V0U29ydERlbGVnYXRlID0gKHRhYmxlKSA9PiAodGFibGUuYXR0cnMgJiYgdGFibGUuYXR0cnMuc29ydERlbGVnYXRlKSA/XG4gICAgdGFibGUuYXR0cnMuc29ydERlbGVnYXRlIDpcbiAgICAocikgPT4gKDAsIHNvcnRfMS5zb3J0QnlJZCkodGFibGUudmFsdWVzLmNvbHVtbnMsIHIua2V5LCBbdGFibGUudmFsdWVzLmRhdGFzZXRbMF0sIHIuZGF0YV0sIHIuY29sdW1uKTtcbmNvbnN0IGdldFNvcnRDbGFzc05hbWUgPSAoa2V5LCBpbmRleCkgPT4gKGtleVswXSA9PT0gaW5kZXgpID8gKGtleVsxXSA9PT0gMSkgPyBleHBvcnRzLkFTQyA6IGV4cG9ydHMuREVTQyA6ICcnO1xuY29uc3QgY2VsbElkID0gKGNvbHVtbiwgcm93KSA9PiBgJHtjb2x1bW59LCR7cm93fWA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmFuZ2VJbnN0YW5jZSA9IHZvaWQgMDtcbi8qKlxuICogUmFuZ2VJbnN0YW5jZVxuICovXG5jbGFzcyBSYW5nZUluc3RhbmNlIHtcbiAgICBjb25zdHJ1Y3RvcihjZWxscykge1xuICAgICAgICB0aGlzLmNlbGxzID0gY2VsbHM7XG4gICAgfVxufVxuZXhwb3J0cy5SYW5nZUluc3RhbmNlID0gUmFuZ2VJbnN0YW5jZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhbmdlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYWluID0gZXhwb3J0cy5DZWxsVmlldyA9IGV4cG9ydHMuQm9keVZpZXcgPSBleHBvcnRzLkhlYWRpbmdWaWV3ID0gZXhwb3J0cy5IZWFkVmlldyA9IGV4cG9ydHMuRW1wdHlWaWV3ID0gdm9pZCAwO1xuY29uc3QgX19kb2N1bWVudCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbmNvbnN0IG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG47XG5jb25zdCB0YWJsZV8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2xheW91dC90YWJsZVwiKTtcbjtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBFbXB0eVZpZXcge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdkaXYnLCB7fSwgW10pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5FbXB0eVZpZXcgPSBFbXB0eVZpZXc7XG47XG5jbGFzcyBIZWFkVmlldyB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ3RoZWFkJywgeyAnY2xhc3MnOiBfX2NvbnRleHQuY2xhc3NOYW1lIH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgndHInLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAuLi5fX2ZvckluKF9fY29udGV4dC5jb2x1bW5zLCAoY29sLCBpZHgsIF8kJGFsbCkgPT4gKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fY29udGV4dC5oZWFkaW5nKGNvbCwgaWR4KVxuICAgICAgICAgICAgICAgICAgICBdKSwgKCkgPT4gKFtdKSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLkhlYWRWaWV3ID0gSGVhZFZpZXc7XG47XG5jbGFzcyBIZWFkaW5nVmlldyB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ3RoJywgeyAnY2xhc3MnOiBfX2NvbnRleHQuY2xhc3NOYW1lLCAnb25jbGljayc6IF9fY29udGV4dC5vbmNsaWNrIH0sIFtcbiAgICAgICAgICAgICAgICB0ZXh0KF9fY29udGV4dC5jb2x1bW4uaGVhZGluZylcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5IZWFkaW5nVmlldyA9IEhlYWRpbmdWaWV3O1xuO1xuY2xhc3MgQm9keVZpZXcge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCd0Ym9keScsIHsgJ2NsYXNzJzogX19jb250ZXh0LmNsYXNzTmFtZSB9LCBbXG4gICAgICAgICAgICAgICAgLi4uX19mb3JJbihfX2NvbnRleHQuZGF0YSwgKF8sIHJvdywgXyQkYWxsKSA9PiAoW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgndHInLCB7IHdtbDogeyAnaWQnOiBTdHJpbmcocm93KSB9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLl9fZm9ySW4oX19jb250ZXh0LmNvbHVtbnMsIChjb2wsIGlkeCwgXyQkYWxsKSA9PiAoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fY29udGV4dC5jZWxsKGNvbCwgaWR4LCByb3cpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSwgKCkgPT4gKFtdKSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKSwgKCkgPT4gKFtdKSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5Cb2R5VmlldyA9IEJvZHlWaWV3O1xuO1xuY2xhc3MgQ2VsbFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCd0ZCcsIHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC5pZCB9LCAnY2xhc3MnOiBfX2NvbnRleHQuY2xhc3NOYW1lLCAnb25jbGljayc6IF9fY29udGV4dC5vbmNsaWNrIH0sIFtcbiAgICAgICAgICAgICAgICB0ZXh0KF9fY29udGV4dC5mb3JtYXQoX19jb250ZXh0LnZhbHVlKSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5DZWxsVmlldyA9IENlbGxWaWV3O1xuO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChuZXcgdGFibGVfMS5UYWJsZUxheW91dCh7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLndtbC5pZCB9LCAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmlkLCAnY2xhc3NOYW1lJzogX19jb250ZXh0LnZhbHVlcy5jbGFzc05hbWUgfSwgW1xuICAgICAgICAgICAgICAgIF9fY29udGV4dC52YWx1ZXMudGhlYWQoKSxcbiAgICAgICAgICAgICAgICBfX2NvbnRleHQudmFsdWVzLnRib2R5KClcbiAgICAgICAgICAgIF0pLCB7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLndtbC5pZCB9LCAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmlkLCAnY2xhc3NOYW1lJzogX19jb250ZXh0LnZhbHVlcy5jbGFzc05hbWUgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFsZXJ0ID0gZXhwb3J0cy5BTEVSVCA9IGV4cG9ydHMuU3R5bGUgPSB2b2lkIDA7XG5jb25zdCBkb21fMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG5jb25zdCB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xuY29uc3Qgc3R5bGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZW50L3N0eWxlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU3R5bGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0eWxlXzEuU3R5bGU7IH0gfSk7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbmNvbnN0IF9fMSA9IHJlcXVpcmUoXCIuLi8uLi9cIik7XG5jb25zdCBhbGVydF8xID0gcmVxdWlyZShcIi4vd21sL2FsZXJ0XCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5BTEVSVCA9ICd3dy1hbGVydCc7XG4vKipcbiAqIEFsZXJ0IGlzIHVzZWQgZm9yIGRpc3BsYXlpbmcgaW1wb3J0YW50IG1lc3NhZ2VzIHRvIHVzZXJzLlxuICovXG5jbGFzcyBBbGVydCBleHRlbmRzIHdtbF8xLkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyBhbGVydF8xLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdhbGVydCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZDogKDAsIF9fMS5nZXRJZCkodGhpcy5hdHRycyksXG4gICAgICAgICAgICBjbGFzc05hbWU6ICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLkFMRVJULCAoMCwgX18xLmdldENsYXNzTmFtZSkodGhpcy5hdHRycyksICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuc3R5bGUpID9cbiAgICAgICAgICAgICAgICAoMCwgc3R5bGVfMS5nZXRTdHlsZUNsYXNzTmFtZSkodGhpcy5hdHRycy5zdHlsZSkgOlxuICAgICAgICAgICAgICAgIHN0eWxlXzEuREVGQVVMVCksXG4gICAgICAgICAgICBjbG9zYWJsZTogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5jbG9zYWJsZSkgP1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMuY2xvc2FibGUgOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbnRlbnQ6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMudGV4dCkgP1xuICAgICAgICAgICAgICAgIFsoMCwgZG9tXzEudGV4dCkodGhpcy5hdHRycy50ZXh0KV0gOiB0aGlzLmNoaWxkcmVuXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNsb3NlIHRoZSBhbGVydC5cbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgbGV0IG1Sb290ID0gKDAsIHV0aWxfMS5nZXRCeUlkKSh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLndtbC5pZCk7XG4gICAgICAgIGlmIChtUm9vdC5pc0p1c3QoKSkge1xuICAgICAgICAgICAgbGV0IHJvb3QgPSBtUm9vdC5nZXQoKTtcbiAgICAgICAgICAgIGlmIChyb290LnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgcm9vdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHJvb3QpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5BbGVydCA9IEFsZXJ0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1haW4gPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbmNvbnN0IGNsb3NlXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY29udGVudC9jbG9zZVwiKTtcbjtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnZGl2JywgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy53bWwuaWQgfSwgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jbGFzc05hbWUgfSwgW1xuICAgICAgICAgICAgICAgIC4uLihfX2NvbnRleHQudmFsdWVzLmNvbnRlbnQpLFxuICAgICAgICAgICAgICAgIC4uLigoX19jb250ZXh0LnZhbHVlcy5jbG9zYWJsZSkgP1xuICAgICAgICAgICAgICAgICAgICAoKCkgPT4gKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGNsb3NlXzEuQ2xvc2UoeyAnb25DbGljayc6ICgpID0+IF9fY29udGV4dC5jbG9zZSgpIH0sIFtdKSwgeyAnb25DbGljayc6ICgpID0+IF9fY29udGV4dC5jbG9zZSgpIH0pXG4gICAgICAgICAgICAgICAgICAgIF0pKSgpIDpcbiAgICAgICAgICAgICAgICAgICAgKCgpID0+IChbXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0KCcnKVxuICAgICAgICAgICAgICAgICAgICBdKSkoKSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFsZXJ0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db25maXJtID0gZXhwb3J0cy5QcmltYXJ5ID0gZXhwb3J0cy5DT05GSVJNX1lFUyA9IGV4cG9ydHMuQ09ORklSTV9OTyA9IGV4cG9ydHMuQ09ORklSTSA9IHZvaWQgMDtcbmNvbnN0IHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbmNvbnN0IF9fMSA9IHJlcXVpcmUoXCIuLi8uLi9cIik7XG5jb25zdCBwcm9tcHRfMSA9IHJlcXVpcmUoXCIuLi9wcm9tcHRcIik7XG5jb25zdCBjb25maXJtXzEgPSByZXF1aXJlKFwiLi93bWwvY29uZmlybVwiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuQ09ORklSTSA9ICd3dy1jb25maXJtJztcbmV4cG9ydHMuQ09ORklSTV9OTyA9ICd3dy1jb25maXJtX19ubyc7XG5leHBvcnRzLkNPTkZJUk1fWUVTID0gJ3d3LXByb21wdF9feWVzJztcbi8vL2NsYXNzTmFtZXM6ZW5kXG4vKipcbiAqIFByaW1hcnkgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIHllcyBvciBubyBidXR0b24gc2hvdWxkIGJlIGhpZ2hsaWdodGVkLlxuICovXG52YXIgUHJpbWFyeTtcbihmdW5jdGlvbiAoUHJpbWFyeSkge1xuICAgIFByaW1hcnlbXCJOb1wiXSA9IFwibm9cIjtcbiAgICBQcmltYXJ5W1wiWWVzXCJdID0gXCJ5ZXNcIjtcbn0pKFByaW1hcnkgPSBleHBvcnRzLlByaW1hcnkgfHwgKGV4cG9ydHMuUHJpbWFyeSA9IHt9KSk7XG4vKipcbiAqIENvbmZpcm0gZGlzcGxheXMgYSBkaWFsb2cgZm9yIGNvbmZpcm1pbmcgYW4gYWN0aW9uLlxuICovXG5jbGFzcyBDb25maXJtIGV4dGVuZHMgd21sXzEuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IGNvbmZpcm1fMS5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiAoMCwgX18xLmdldElkKSh0aGlzLmF0dHJzKSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogKDAsIHV0aWxfMS5jb25jYXQpKGV4cG9ydHMuQ09ORklSTSwgKDAsIF9fMS5nZXRDbGFzc05hbWUpKHRoaXMuYXR0cnMpKSxcbiAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgIGlkOiAnbW9kYWwnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGVhZGVyOiB7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMudGl0bGUpID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy50aXRsZSA6ICcnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9vdGVyOiB7XG4gICAgICAgICAgICAgICAgbm86IHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5ub1RleHQpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMubm9UZXh0IDogJ05vJyxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAoMCwgdXRpbF8xLmNvbmNhdCkoZXhwb3J0cy5DT05GSVJNX05PLCAodGhpcy5hdHRycyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5wcmltYXJ5ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLnByaW1hcnkgPT09IFByaW1hcnkuTm8pID8gJy1wcmltYXJ5JyA6ICcnKSxcbiAgICAgICAgICAgICAgICAgICAgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5vbk5vKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMub25ObygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB5ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy55ZXNUZXh0KSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLnllc1RleHQgOiAnWWVzJyxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3llcydcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAoMCwgdXRpbF8xLmNvbmNhdCkoZXhwb3J0cy5DT05GSVJNX1lFUywgKHRoaXMuYXR0cnMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMucHJpbWFyeSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5wcmltYXJ5ID09PSBQcmltYXJ5Lk5vKSA/ICcnIDogJy1wcmltYXJ5JyksXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMub25ZZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5vblllcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgKDAsIHByb21wdF8xLmNsb3NlKSh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLndtbC5pZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29uZmlybSA9IENvbmZpcm07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWFpbiA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuY29uc3QgYnV0dG9uXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY29udHJvbC9idXR0b25cIik7XG47XG5jb25zdCBjbG9zZV9idXR0b25fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb250cm9sL2Nsb3NlLWJ1dHRvblwiKTtcbjtcbmNvbnN0IG1vZGFsXzEgPSByZXF1aXJlKFwiLi4vLi4vbW9kYWxcIik7XG47XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChuZXcgbW9kYWxfMS5Nb2RhbCh7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLndtbC5pZCB9LCAnY2xhc3NOYW1lJzogX19jb250ZXh0LnZhbHVlcy5jbGFzc05hbWUgfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IG1vZGFsXzEuTW9kYWxIZWFkZXIoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgY2xvc2VfYnV0dG9uXzEuQ2xvc2VCdXR0b24oeyAnb25DbGljayc6IF9fY29udGV4dC52YWx1ZXMuZm9vdGVyLm5vLm9uQ2xpY2sgfSwgW10pLCB7ICdvbkNsaWNrJzogX19jb250ZXh0LnZhbHVlcy5mb290ZXIubm8ub25DbGljayB9KSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dChfX2NvbnRleHQudmFsdWVzLmhlYWRlci50aXRsZSlcbiAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IG1vZGFsXzEuTW9kYWxCb2R5KHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIC4uLihfX2NvbnRleHQuY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBtb2RhbF8xLk1vZGFsRm9vdGVyKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGJ1dHRvbl8xLkJ1dHRvbih7ICd0ZXh0JzogX19jb250ZXh0LnZhbHVlcy5mb290ZXIubm8udGV4dCwgJ2NsYXNzTmFtZSc6IF9fY29udGV4dC52YWx1ZXMuZm9vdGVyLm5vLmNsYXNzTmFtZSwgJ29uQ2xpY2snOiBfX2NvbnRleHQudmFsdWVzLmZvb3Rlci5uby5vbkNsaWNrIH0sIFtdKSwgeyAndGV4dCc6IF9fY29udGV4dC52YWx1ZXMuZm9vdGVyLm5vLnRleHQsICdjbGFzc05hbWUnOiBfX2NvbnRleHQudmFsdWVzLmZvb3Rlci5uby5jbGFzc05hbWUsICdvbkNsaWNrJzogX19jb250ZXh0LnZhbHVlcy5mb290ZXIubm8ub25DbGljayB9KSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgYnV0dG9uXzEuQnV0dG9uKHsgJ3RleHQnOiBfX2NvbnRleHQudmFsdWVzLmZvb3Rlci55ZXMudGV4dCwgJ2NsYXNzTmFtZSc6IF9fY29udGV4dC52YWx1ZXMuZm9vdGVyLnllcy5jbGFzc05hbWUsICdvbkNsaWNrJzogX19jb250ZXh0LnZhbHVlcy5mb290ZXIueWVzLm9uQ2xpY2sgfSwgW10pLCB7ICd0ZXh0JzogX19jb250ZXh0LnZhbHVlcy5mb290ZXIueWVzLnRleHQsICdjbGFzc05hbWUnOiBfX2NvbnRleHQudmFsdWVzLmZvb3Rlci55ZXMuY2xhc3NOYW1lLCAnb25DbGljayc6IF9fY29udGV4dC52YWx1ZXMuZm9vdGVyLnllcy5vbkNsaWNrIH0pXG4gICAgICAgICAgICAgICAgXSksIHt9KVxuICAgICAgICAgICAgXSksIHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMud21sLmlkIH0sICdjbGFzc05hbWUnOiBfX2NvbnRleHQudmFsdWVzLmNsYXNzTmFtZSB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25maXJtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbmZvcm0gPSBleHBvcnRzLklORk9STV9PSyA9IGV4cG9ydHMuSU5GT1JNID0gdm9pZCAwO1xuY29uc3Qgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xuY29uc3QgX18xID0gcmVxdWlyZShcIi4uLy4uL1wiKTtcbmNvbnN0IHByb21wdF8xID0gcmVxdWlyZShcIi4uL3Byb21wdFwiKTtcbmNvbnN0IGluZm9ybV8xID0gcmVxdWlyZShcIi4vd21sL2luZm9ybVwiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuSU5GT1JNID0gJ3d3LWluZm9ybSc7XG5leHBvcnRzLklORk9STV9PSyA9ICd3dy1pbmZvcm1fX29rJztcbi8qKlxuICogSW5mb3JtIGRpc3BsYXlzIGEgbWVzc2FnZSB0byB0aGUgdXNlci5cbiAqL1xuY2xhc3MgSW5mb3JtIGV4dGVuZHMgd21sXzEuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IGluZm9ybV8xLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6ICgwLCBfXzEuZ2V0SWQpKHRoaXMuYXR0cnMpLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAoMCwgdXRpbF8xLmNvbmNhdCkoZXhwb3J0cy5JTkZPUk0sICgwLCBfXzEuZ2V0Q2xhc3NOYW1lKSh0aGlzLmF0dHJzKSksXG4gICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICBpZDogJ21vZGFsJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhlYWRlcjoge1xuICAgICAgICAgICAgICAgIHRpdGxlOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLnRpdGxlKSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMudGl0bGUgOiAnJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvb3Rlcjoge1xuICAgICAgICAgICAgICAgIG9rOiB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuYnV0dG9uVGV4dCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5idXR0b25UZXh0IDogJ09rJyxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogJ29rJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLklORk9STV9PSywgJy1wcmltYXJ5JyksXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMub25DbG9zZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLm9uQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgICgwLCBwcm9tcHRfMS5jbG9zZSkodGhpcy52aWV3LCB0aGlzLnZhbHVlcy53bWwuaWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLkluZm9ybSA9IEluZm9ybTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYWluID0gdm9pZCAwO1xuY29uc3QgX19kb2N1bWVudCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbmNvbnN0IG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG5jb25zdCBidXR0b25fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb250cm9sL2J1dHRvblwiKTtcbjtcbmNvbnN0IGNsb3NlX2J1dHRvbl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2NvbnRyb2wvY2xvc2UtYnV0dG9uXCIpO1xuO1xuY29uc3QgbW9kYWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9tb2RhbFwiKTtcbjtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KG5ldyBtb2RhbF8xLk1vZGFsKHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMud21sLmlkIH0sICdjbGFzc05hbWUnOiBfX2NvbnRleHQudmFsdWVzLmNsYXNzTmFtZSB9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgbW9kYWxfMS5Nb2RhbEhlYWRlcih7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBjbG9zZV9idXR0b25fMS5DbG9zZUJ1dHRvbih7ICdvbkNsaWNrJzogX19jb250ZXh0LnZhbHVlcy5mb290ZXIub2sub25DbGljayB9LCBbXSksIHsgJ29uQ2xpY2snOiBfX2NvbnRleHQudmFsdWVzLmZvb3Rlci5vay5vbkNsaWNrIH0pLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0KF9fY29udGV4dC52YWx1ZXMuaGVhZGVyLnRpdGxlKVxuICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgbW9kYWxfMS5Nb2RhbEJvZHkoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgLi4uKF9fY29udGV4dC5jaGlsZHJlbilcbiAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IG1vZGFsXzEuTW9kYWxGb290ZXIoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgYnV0dG9uXzEuQnV0dG9uKHsgJ3RleHQnOiBfX2NvbnRleHQudmFsdWVzLmZvb3Rlci5vay50ZXh0LCAnY2xhc3NOYW1lJzogX19jb250ZXh0LnZhbHVlcy5mb290ZXIub2suY2xhc3NOYW1lLCAnb25DbGljayc6IF9fY29udGV4dC52YWx1ZXMuZm9vdGVyLm9rLm9uQ2xpY2sgfSwgW10pLCB7ICd0ZXh0JzogX19jb250ZXh0LnZhbHVlcy5mb290ZXIub2sudGV4dCwgJ2NsYXNzTmFtZSc6IF9fY29udGV4dC52YWx1ZXMuZm9vdGVyLm9rLmNsYXNzTmFtZSwgJ29uQ2xpY2snOiBfX2NvbnRleHQudmFsdWVzLmZvb3Rlci5vay5vbkNsaWNrIH0pXG4gICAgICAgICAgICAgICAgXSksIHt9KVxuICAgICAgICAgICAgXSksIHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMud21sLmlkIH0sICdjbGFzc05hbWUnOiBfX2NvbnRleHQudmFsdWVzLmNsYXNzTmFtZSB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmZvcm0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1vZGFsRm9vdGVyID0gZXhwb3J0cy5Nb2RhbEJvZHkgPSBleHBvcnRzLk1vZGFsSGVhZGVyID0gZXhwb3J0cy5Nb2RhbCA9IGV4cG9ydHMuTU9EQUxfRk9PVEVSID0gZXhwb3J0cy5NT0RBTF9CT0RZID0gZXhwb3J0cy5NT0RBTF9IRUFERVIgPSBleHBvcnRzLk1PREFMX0NPTlRFTlQgPSBleHBvcnRzLk1PREFMX1BPU0lUSU9OID0gZXhwb3J0cy5NT0RBTCA9IHZvaWQgMDtcbmNvbnN0IHZpZXdzID0gcmVxdWlyZShcIi4vd21sL21vZGFsXCIpO1xuY29uc3Qgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xuY29uc3QgX18xID0gcmVxdWlyZShcIi4uLy4uL1wiKTtcbmNvbnN0IGxheW91dF8xID0gcmVxdWlyZShcIi4uLy4uL2xheW91dFwiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuTU9EQUwgPSAnd3ctbW9kYWwnO1xuZXhwb3J0cy5NT0RBTF9QT1NJVElPTiA9ICd3dy1tb2RhbF9fcG9zaXRpb24nO1xuZXhwb3J0cy5NT0RBTF9DT05URU5UID0gJ3d3LW1vZGFsX19jb250ZW50JztcbmV4cG9ydHMuTU9EQUxfSEVBREVSID0gJ3d3LW1vZGFsX19oZWFkZXInO1xuZXhwb3J0cy5NT0RBTF9CT0RZID0gJ3d3LW1vZGFsX19ib2R5JztcbmV4cG9ydHMuTU9EQUxfRk9PVEVSID0gJ3d3LW1vZGFsX19mb290ZXInO1xuLyoqXG4gKiBNb2RhbFxuICovXG5jbGFzcyBNb2RhbCBleHRlbmRzIHdtbF8xLkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5Nb2RhbCh0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICBpZDogJ3Jvb3QnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWQ6ICgwLCBfXzEuZ2V0SWQpKHRoaXMuYXR0cnMpLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAoMCwgdXRpbF8xLmNvbmNhdCkoZXhwb3J0cy5NT0RBTCwgKDAsIF9fMS5nZXRDbGFzc05hbWUpKHRoaXMuYXR0cnMpKSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGV4cG9ydHMuTU9EQUxfQ09OVEVOVFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBleHBvcnRzLk1PREFMX1BPU0lUSU9OXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNsb3NlIHRoZSBtb2RhbC5cbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgbGV0IG1PID0gKDAsIHV0aWxfMS5nZXRCeUlkKSh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLndtbC5pZCk7XG4gICAgICAgIGlmIChtTy5pc0p1c3QoKSkge1xuICAgICAgICAgICAgbGV0IG4gPSBtTy5nZXQoKTtcbiAgICAgICAgICAgIGlmIChuLnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgbi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG4pO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Nb2RhbCA9IE1vZGFsO1xuLyoqXG4gKiBNb2RhbEhlYWRlclxuICovXG5jbGFzcyBNb2RhbEhlYWRlciBleHRlbmRzIGxheW91dF8xLkFic3RyYWN0TGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1vZGFsSGVhZGVyKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgIGlkOiAncm9vdCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZDogKDAsIF9fMS5nZXRJZCkodGhpcy5hdHRycyksXG4gICAgICAgICAgICBjbGFzc05hbWU6ICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLk1PREFMX0hFQURFUiwgKDAsIF9fMS5nZXRDbGFzc05hbWUpKHRoaXMuYXR0cnMpKSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHsgd21sOiB7IGlkOiAncm9vdCcgfSB9XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5Nb2RhbEhlYWRlciA9IE1vZGFsSGVhZGVyO1xuLyoqXG4gKiBNb2RhbEJvZHlBdHRyc1xuICovXG5jbGFzcyBNb2RhbEJvZHkgZXh0ZW5kcyBsYXlvdXRfMS5BYnN0cmFjdExheW91dCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5Nb2RhbEJvZHkodGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdyb290J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlkOiAoMCwgX18xLmdldElkKSh0aGlzLmF0dHJzKSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogKDAsIHV0aWxfMS5jb25jYXQpKGV4cG9ydHMuTU9EQUxfQk9EWSwgKDAsIF9fMS5nZXRDbGFzc05hbWUpKHRoaXMuYXR0cnMpKSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHsgd21sOiB7IGlkOiAncm9vdCcgfSB9XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5Nb2RhbEJvZHkgPSBNb2RhbEJvZHk7XG4vKipcbiAqIE1vZGFsRm9vdGVyXG4gKi9cbmNsYXNzIE1vZGFsRm9vdGVyIGV4dGVuZHMgd21sXzEuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1vZGFsRm9vdGVyKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgIGlkOiAncm9vdCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZDogKDAsIF9fMS5nZXRJZCkodGhpcy5hdHRycyksXG4gICAgICAgICAgICBjbGFzc05hbWU6ICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLk1PREFMX0ZPT1RFUiwgKDAsIF9fMS5nZXRDbGFzc05hbWUpKHRoaXMuYXR0cnMpKSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHsgd21sOiB7IGlkOiAncm9vdCcgfSB9XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5Nb2RhbEZvb3RlciA9IE1vZGFsRm9vdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1vZGFsRm9vdGVyID0gZXhwb3J0cy5Nb2RhbEJvZHkgPSBleHBvcnRzLk1vZGFsSGVhZGVyID0gZXhwb3J0cy5Nb2RhbCA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9faWYgPSAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpID0+IChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0ID8gX19hbHQoKSA6IFtdO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9ySW4gPSAobGlzdCwgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2Zvck9mID0gKG8sIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHRleHQgPSBfX2RvY3VtZW50LnRleHQ7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHVuc2FmZSA9IF9fZG9jdW1lbnQudW5zYWZlO1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCBpc1NldCA9ICh2YWx1ZSkgPT4gdmFsdWUgIT0gbnVsbDtcbmNsYXNzIE1vZGFsIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnZGl2JywgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy53bWwuaWQgfSwgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jbGFzc05hbWUgfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdkaXYnLCB7ICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMucG9zaXRpb24uY2xhc3NOYW1lIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2RpdicsIHsgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jb250ZW50LmNsYXNzTmFtZSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi4oX19jb250ZXh0LmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuTW9kYWwgPSBNb2RhbDtcbjtcbmNsYXNzIE1vZGFsSGVhZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnZGl2JywgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy53bWwuaWQgfSwgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jbGFzc05hbWUgfSwgW1xuICAgICAgICAgICAgICAgIC4uLihfX2NvbnRleHQuY2hpbGRyZW4pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuTW9kYWxIZWFkZXIgPSBNb2RhbEhlYWRlcjtcbjtcbmNsYXNzIE1vZGFsQm9keSB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ2RpdicsIHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMud21sLmlkIH0sICdpZCc6IF9fY29udGV4dC52YWx1ZXMuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuY2xhc3NOYW1lIH0sIFtcbiAgICAgICAgICAgICAgICAuLi4oX19jb250ZXh0LmNoaWxkcmVuKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk1vZGFsQm9keSA9IE1vZGFsQm9keTtcbjtcbmNsYXNzIE1vZGFsRm9vdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnZGl2JywgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy53bWwuaWQgfSwgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jbGFzc05hbWUgfSwgW1xuICAgICAgICAgICAgICAgIC4uLihfX2NvbnRleHQuY2hpbGRyZW4pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuTW9kYWxGb290ZXIgPSBNb2RhbEZvb3Rlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGFsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jbG9zZSA9IGV4cG9ydHMuUHJvbXB0ID0gZXhwb3J0cy5QUk9NUFRfU0FWRSA9IGV4cG9ydHMuUFJPTVBUX0NMT1NFID0gZXhwb3J0cy5QUk9NUFQgPSB2b2lkIDA7XG5jb25zdCB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG5jb25zdCBfXzEgPSByZXF1aXJlKFwiLi4vLi4vXCIpO1xuY29uc3QgcHJvbXB0XzEgPSByZXF1aXJlKFwiLi93bWwvcHJvbXB0XCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5QUk9NUFQgPSAnd3ctcHJvbXB0JztcbmV4cG9ydHMuUFJPTVBUX0NMT1NFID0gJ3d3LXByb21wdF9fY2xvc2UnO1xuZXhwb3J0cy5QUk9NUFRfU0FWRSA9ICd3dy1wcm9tcHRfX3NhdmUnO1xuLyoqXG4gKiBQcm9tcHQgZGlzcGxheXMgYSBkaWFsb2cgdG8gdGhlIHVzZXIgc3VpdGFibGUgZm9yIGNvbGxlY3RpbmcgZGF0YVxuICogaW5wdXQuXG4gKi9cbmNsYXNzIFByb21wdCBleHRlbmRzIHdtbF8xLkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyBwcm9tcHRfMS5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiAoMCwgX18xLmdldElkKSh0aGlzLmF0dHJzKSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogKDAsIHV0aWxfMS5jb25jYXQpKGV4cG9ydHMuUFJPTVBULCAoMCwgX18xLmdldENsYXNzTmFtZSkodGhpcy5hdHRycykpLFxuICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdtb2RhbCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoZWFkZXI6IHtcbiAgICAgICAgICAgICAgICB0aXRsZTogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy50aXRsZSkgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLnRpdGxlIDogJydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb290ZXI6IHtcbiAgICAgICAgICAgICAgICBjbG9zZToge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmNsb3NlVGV4dCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5jbG9zZVRleHQgOiAnQ2xvc2UnLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGV4cG9ydHMuUFJPTVBUX0NMT1NFLFxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLm9uQ2FuY2VsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMub25DYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2F2ZToge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLnNhdmVUZXh0KSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLnNhdmVUZXh0IDogJ1NhdmUnLFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnc2F2ZSdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAoMCwgdXRpbF8xLmNvbmNhdCkoJy1wcmltYXJ5JywgZXhwb3J0cy5QUk9NUFRfU0FWRSksXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmRpc2FibGVkKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnVlIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMub25TYXZlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMub25TYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICAoMCwgZXhwb3J0cy5jbG9zZSkodGhpcy52aWV3LCB0aGlzLnZhbHVlcy53bWwuaWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogZW5hYmxlIHNhdmluZy5cbiAgICAgKi9cbiAgICBlbmFibGUoKSB7XG4gICAgICAgIGdldFNhdmUodGhpcykubWFwKGIgPT4gYi5lbmFibGUoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBkaXNhYmxlIHNhdmluZy5cbiAgICAgKi9cbiAgICBkaXNhYmxlKCkge1xuICAgICAgICBnZXRTYXZlKHRoaXMpLm1hcChiID0+IGIuZGlzYWJsZSgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5Qcm9tcHQgPSBQcm9tcHQ7XG5jb25zdCBnZXRTYXZlID0gKHApID0+ICgwLCB1dGlsXzEuZ2V0QnlJZCkocC52aWV3LCBwLnZhbHVlcy5mb290ZXIuc2F2ZS53bWwuaWQpO1xuLyoqXG4gKiBjbG9zZSB0aGUgTW9kYWwgaW4gYSB2aWV3LlxuICovXG5jb25zdCBjbG9zZSA9ICh2aWV3LCBpZCkgPT4gKDAsIHV0aWxfMS5nZXRCeUlkKSh2aWV3LCBpZCkubWFwKG0gPT4gbS5jbG9zZSgpKTtcbmV4cG9ydHMuY2xvc2UgPSBjbG9zZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYWluID0gdm9pZCAwO1xuY29uc3QgX19kb2N1bWVudCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbmNvbnN0IG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG5jb25zdCBidXR0b25fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb250cm9sL2J1dHRvblwiKTtcbjtcbmNvbnN0IGNsb3NlX2J1dHRvbl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2NvbnRyb2wvY2xvc2UtYnV0dG9uXCIpO1xuO1xuY29uc3QgbW9kYWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9tb2RhbFwiKTtcbjtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KG5ldyBtb2RhbF8xLk1vZGFsKHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMud21sLmlkIH0sICdjbGFzc05hbWUnOiBfX2NvbnRleHQudmFsdWVzLmNsYXNzTmFtZSB9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgbW9kYWxfMS5Nb2RhbEhlYWRlcih7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBjbG9zZV9idXR0b25fMS5DbG9zZUJ1dHRvbih7ICdvbkNsaWNrJzogX19jb250ZXh0LnZhbHVlcy5mb290ZXIuY2xvc2Uub25DbGljayB9LCBbXSksIHsgJ29uQ2xpY2snOiBfX2NvbnRleHQudmFsdWVzLmZvb3Rlci5jbG9zZS5vbkNsaWNrIH0pLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0KF9fY29udGV4dC52YWx1ZXMuaGVhZGVyLnRpdGxlKVxuICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgbW9kYWxfMS5Nb2RhbEJvZHkoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgLi4uKF9fY29udGV4dC5jaGlsZHJlbilcbiAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IG1vZGFsXzEuTW9kYWxGb290ZXIoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgYnV0dG9uXzEuQnV0dG9uKHsgJ3RleHQnOiBfX2NvbnRleHQudmFsdWVzLmZvb3Rlci5jbG9zZS50ZXh0LCAnY2xhc3NOYW1lJzogX19jb250ZXh0LnZhbHVlcy5mb290ZXIuY2xvc2UuY2xhc3NOYW1lLCAnb25DbGljayc6IF9fY29udGV4dC52YWx1ZXMuZm9vdGVyLmNsb3NlLm9uQ2xpY2sgfSwgW10pLCB7ICd0ZXh0JzogX19jb250ZXh0LnZhbHVlcy5mb290ZXIuY2xvc2UudGV4dCwgJ2NsYXNzTmFtZSc6IF9fY29udGV4dC52YWx1ZXMuZm9vdGVyLmNsb3NlLmNsYXNzTmFtZSwgJ29uQ2xpY2snOiBfX2NvbnRleHQudmFsdWVzLmZvb3Rlci5jbG9zZS5vbkNsaWNrIH0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBidXR0b25fMS5CdXR0b24oeyAndGV4dCc6IF9fY29udGV4dC52YWx1ZXMuZm9vdGVyLnNhdmUudGV4dCwgJ2NsYXNzTmFtZSc6IF9fY29udGV4dC52YWx1ZXMuZm9vdGVyLnNhdmUuY2xhc3NOYW1lLCAnZGlzYWJsZWQnOiBfX2NvbnRleHQudmFsdWVzLmZvb3Rlci5zYXZlLmRpc2FibGVkLCAnb25DbGljayc6IF9fY29udGV4dC52YWx1ZXMuZm9vdGVyLnNhdmUub25DbGljayB9LCBbXSksIHsgJ3RleHQnOiBfX2NvbnRleHQudmFsdWVzLmZvb3Rlci5zYXZlLnRleHQsICdjbGFzc05hbWUnOiBfX2NvbnRleHQudmFsdWVzLmZvb3Rlci5zYXZlLmNsYXNzTmFtZSwgJ2Rpc2FibGVkJzogX19jb250ZXh0LnZhbHVlcy5mb290ZXIuc2F2ZS5kaXNhYmxlZCwgJ29uQ2xpY2snOiBfX2NvbnRleHQudmFsdWVzLmZvb3Rlci5zYXZlLm9uQ2xpY2sgfSlcbiAgICAgICAgICAgICAgICBdKSwge30pXG4gICAgICAgICAgICBdKSwgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy53bWwuaWQgfSwgJ2NsYXNzTmFtZSc6IF9fY29udGV4dC52YWx1ZXMuY2xhc3NOYW1lIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb21wdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0Q2xhc3NOYW1lID0gZXhwb3J0cy5nZXRJZCA9IHZvaWQgMDtcbi8qKlxuICogZ2V0SWQgZnJvbSBhIHdpZGdldCdzIHBhc3NlZCBhdHRyaWJ1dGVzLlxuICovXG5jb25zdCBnZXRJZCA9IChhdHRycykgPT4gYXR0cnMuaWQgPyBhdHRycy5pZCA6ICcnO1xuZXhwb3J0cy5nZXRJZCA9IGdldElkO1xuLyoqXG4gKiBnZXRDbGFzc05hbWUgZnJvbSBhIHdpZGdldCdzIHBhc3NlZCBhdHRyaWJ1dGVzLlxuICpcbiAqIFJldHVybnMgYW4gZW1wdHkgc3RyaW5nIGlmIHRoZSBlbGVtZW50IGhhcyBub3QgY2xhc3NOYW1lIGF0dHJpYnV0ZS5cbiAqL1xuY29uc3QgZ2V0Q2xhc3NOYW1lID0gKGF0dHJzKSA9PiBhdHRycy5jbGFzc05hbWUgfHwgJyc7XG5leHBvcnRzLmdldENsYXNzTmFtZSA9IGdldENsYXNzTmFtZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BY3Rpb25CYXIgPSBleHBvcnRzLkFDVElPTl9CQVJfQ09OVEVOVCA9IGV4cG9ydHMuQUNUSU9OX0JBUiA9IHZvaWQgMDtcbmNvbnN0IG9yaWVudGF0aW9uID0gcmVxdWlyZShcIi4uLy4uL2NvbnRlbnQvb3JpZW50YXRpb25cIik7XG5jb25zdCBfXzEgPSByZXF1aXJlKFwiLi4vLi5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbmNvbnN0IF9fMiA9IHJlcXVpcmUoXCIuLi9cIik7XG5jb25zdCBhY3Rpb25fYmFyXzEgPSByZXF1aXJlKFwiLi93bWwvYWN0aW9uLWJhclwiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbi8qKlxuICogQUNUSU9OX0JBUiBjbGFzcyBuYW1lLiBmb3IgdGhlIEFjdGlvbkJhciByb290LlxuICovXG5leHBvcnRzLkFDVElPTl9CQVIgPSAnd3ctYWN0aW9uLWJhcic7XG4vKipcbiAqIEFDVElPTl9CQVJfQ09OVEVOVCBjbGFzcyBuYW1lLlxuICovXG5leHBvcnRzLkFDVElPTl9CQVJfQ09OVEVOVCA9ICd3dy1hY3Rpb24tYmFyX19jb250ZW50Jztcbi8qKlxuICogQWN0aW9uQmFyIHByb3ZpZGVzIGEgYmFyIGFjcm9zcyB0aGUgc2NyZWVuIHRoYXQgY2FuIGJlXG4gKiB1c2VkIGFzIGEgdG9vbGJhciwgbmF2aWdhdGlvbiBtZW51IG9yIHNvbWV0aGluZyBzaW1pbGxhci5cbiAqL1xuY2xhc3MgQWN0aW9uQmFyIGV4dGVuZHMgX18yLkFic3RyYWN0TGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IGFjdGlvbl9iYXJfMS5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdyb290JyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlkOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmlkKSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMuaWQgOiAnJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLkFDVElPTl9CQVIsIF9fMi5MQVlPVVQsIG9yaWVudGF0aW9uLlBPU0lUSU9ORUQsICgwLCBfXzEuZ2V0Q2xhc3NOYW1lKSh0aGlzLmF0dHJzKSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAnY29udGVudCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNsYXNzOiBleHBvcnRzLkFDVElPTl9CQVJfQ09OVEVOVFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQWN0aW9uQmFyID0gQWN0aW9uQmFyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1haW4gPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnZGl2JywgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5yb290LndtbC5pZCB9LCAnaWQnOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMucm9vdC5jbGFzc05hbWUgfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdkaXYnLCB7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmNvbnRlbnQud21sLmlkIH0sICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuY29udGVudC5jbGFzcyB9LCBbXG4gICAgICAgICAgICAgICAgICAgIC4uLihfX2NvbnRleHQuY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjdGlvbi1iYXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNhbGxvdXQgPSBleHBvcnRzLkNBTExPVVQgPSBleHBvcnRzLlN0eWxlID0gdm9pZCAwO1xuY29uc3Qgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbmNvbnN0IHN0eWxlXzEgPSByZXF1aXJlKFwiLi4vLi4vY29udGVudC9zdHlsZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN0eWxlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdHlsZV8xLlN0eWxlOyB9IH0pO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG5jb25zdCBfXzEgPSByZXF1aXJlKFwiLi4vLi4vXCIpO1xuY29uc3QgY2FsbG91dF8xID0gcmVxdWlyZShcIi4vd21sL2NhbGxvdXRcIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLkNBTExPVVQgPSAnd3ctY2FsbG91dCc7XG4vKipcbiAqIENhbGxvdXRcbiAqL1xuY2xhc3MgQ2FsbG91dCBleHRlbmRzIHdtbF8xLkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyBjYWxsb3V0XzEuTWFpbih0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBpZDogKDAsIF9fMS5nZXRJZCkodGhpcy5hdHRycyksXG4gICAgICAgICAgICBjbGFzc05hbWU6ICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLkNBTExPVVQsICgwLCBfXzEuZ2V0Q2xhc3NOYW1lKSh0aGlzLmF0dHJzKSwgKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5zdHlsZSkgP1xuICAgICAgICAgICAgICAgICgwLCBzdHlsZV8xLmdldFN0eWxlQ2xhc3NOYW1lKSh0aGlzLmF0dHJzLnN0eWxlKSA6XG4gICAgICAgICAgICAgICAgc3R5bGVfMS5ERUZBVUxUKVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQ2FsbG91dCA9IENhbGxvdXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWFpbiA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9faWYgPSAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpID0+IChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0ID8gX19hbHQoKSA6IFtdO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9ySW4gPSAobGlzdCwgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2Zvck9mID0gKG8sIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHRleHQgPSBfX2RvY3VtZW50LnRleHQ7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHVuc2FmZSA9IF9fZG9jdW1lbnQudW5zYWZlO1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCBpc1NldCA9ICh2YWx1ZSkgPT4gdmFsdWUgIT0gbnVsbDtcbmNsYXNzIE1haW4ge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdkaXYnLCB7ICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuY2xhc3NOYW1lIH0sIFtcbiAgICAgICAgICAgICAgICAuLi4oX19jb250ZXh0LmNoaWxkcmVuKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FsbG91dC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGF0YSA9IGV4cG9ydHMuVGl0bGUgPSBleHBvcnRzLkRlc2NyaXB0aW9uTGlzdCA9IGV4cG9ydHMuREVTQ1JJUFRJT05fTElTVF9EQVRBID0gZXhwb3J0cy5ERVNDUklQVElPTl9MSVNUX1RJVExFID0gZXhwb3J0cy5ERVNDUklQVElPTl9MSVNUID0gdm9pZCAwO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvZGVzY3JpcHRpb24tbGlzdFwiKTtcbmNvbnN0IHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG5jb25zdCBvcmllbnRhdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRlbnQvb3JpZW50YXRpb25cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbmNvbnN0IF9fMSA9IHJlcXVpcmUoXCIuLi8uLi9cIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLkRFU0NSSVBUSU9OX0xJU1QgPSAnd3ctZGVzY3JpcHRpb24tbGlzdCc7XG5leHBvcnRzLkRFU0NSSVBUSU9OX0xJU1RfVElUTEUgPSAnd3ctZGVzY3JpcHRpb24tbGlzdF9fdGl0bGUnO1xuZXhwb3J0cy5ERVNDUklQVElPTl9MSVNUX0RBVEEgPSAnd3ctZGVzY3JpcHRpb24tbGlzdF9fZGF0YSc7XG4vKipcbiAqIERlc2NyaXB0aW9uTGlzdCBsYXlvdXQuXG4gKi9cbmNsYXNzIERlc2NyaXB0aW9uTGlzdCBleHRlbmRzIHdtbF8xLkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5EZXNjcmlwdGlvbkxpc3QodGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6ICgwLCBfXzEuZ2V0SWQpKHRoaXMuYXR0cnMpLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAoMCwgdXRpbF8xLmNvbmNhdCkoZXhwb3J0cy5ERVNDUklQVElPTl9MSVNULCAoMCwgX18xLmdldENsYXNzTmFtZSkodGhpcy5hdHRycyksICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuaG9yaXpvbnRhbCkgPyBvcmllbnRhdGlvbl8xLkhPUklaT05UQUwgOiAnJylcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkRlc2NyaXB0aW9uTGlzdCA9IERlc2NyaXB0aW9uTGlzdDtcbi8qKlxuICogVGl0bGVcbiAqL1xuY2xhc3MgVGl0bGUgZXh0ZW5kcyB3bWxfMS5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuVGl0bGUodGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6ICgwLCBfXzEuZ2V0SWQpKHRoaXMuYXR0cnMpLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAoMCwgdXRpbF8xLmNvbmNhdCkoZXhwb3J0cy5ERVNDUklQVElPTl9MSVNUX1RJVExFLCAoMCwgX18xLmdldENsYXNzTmFtZSkodGhpcy5hdHRycykpXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5UaXRsZSA9IFRpdGxlO1xuLyoqXG4gKiBEYXRhXG4gKi9cbmNsYXNzIERhdGEgZXh0ZW5kcyB3bWxfMS5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuRGF0YSh0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBpZDogKDAsIF9fMS5nZXRJZCkodGhpcy5hdHRycyksXG4gICAgICAgICAgICBjbGFzc05hbWU6ICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLkRFU0NSSVBUSU9OX0xJU1RfREFUQSwgKDAsIF9fMS5nZXRDbGFzc05hbWUpKHRoaXMuYXR0cnMpKVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuRGF0YSA9IERhdGE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGF0YSA9IGV4cG9ydHMuVGl0bGUgPSBleHBvcnRzLkRlc2NyaXB0aW9uTGlzdCA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9faWYgPSAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpID0+IChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0ID8gX19hbHQoKSA6IFtdO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9ySW4gPSAobGlzdCwgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2Zvck9mID0gKG8sIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHRleHQgPSBfX2RvY3VtZW50LnRleHQ7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHVuc2FmZSA9IF9fZG9jdW1lbnQudW5zYWZlO1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCBpc1NldCA9ICh2YWx1ZSkgPT4gdmFsdWUgIT0gbnVsbDtcbmNsYXNzIERlc2NyaXB0aW9uTGlzdCB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ2RsJywgeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmNsYXNzTmFtZSB9LCBbXG4gICAgICAgICAgICAgICAgLi4uKF9fY29udGV4dC5jaGlsZHJlbilcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5EZXNjcmlwdGlvbkxpc3QgPSBEZXNjcmlwdGlvbkxpc3Q7XG47XG5jbGFzcyBUaXRsZSB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ2R0JywgeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmNsYXNzTmFtZSB9LCBbXG4gICAgICAgICAgICAgICAgLi4uKF9fY29udGV4dC5jaGlsZHJlbilcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5UaXRsZSA9IFRpdGxlO1xuO1xuY2xhc3MgRGF0YSB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ2RkJywgeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmNsYXNzTmFtZSB9LCBbXG4gICAgICAgICAgICAgICAgLi4uKF9fY29udGV4dC5jaGlsZHJlbilcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5EYXRhID0gRGF0YTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlc2NyaXB0aW9uLWxpc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRyYXdlckxheW91dCA9IGV4cG9ydHMuRFJBV0VSX0xBWU9VVF9DT05URU5UID0gZXhwb3J0cy5EUkFXRVJfTEFZT1VUID0gdm9pZCAwO1xuY29uc3Qgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbmNvbnN0IGFycmF5XzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvYXJyYXlcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbmNvbnN0IF9fMSA9IHJlcXVpcmUoXCIuLi9cIik7XG5jb25zdCB2aWV3XzEgPSByZXF1aXJlKFwiLi92aWV3XCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5EUkFXRVJfTEFZT1VUID0gJ3d3LWRyYXdlci1sYXlvdXQnO1xuZXhwb3J0cy5EUkFXRVJfTEFZT1VUX0NPTlRFTlQgPSAnd3ctZHJhd2VyLWxheW91dF9fY29udGVudCc7XG4vKipcbiAqIERyYXdlckxheW91dCBwcm92aWRlcyBhIDIgY29sdW1uIGxheW91dCBmb3IgYW4gYXBwbGljYXRpb24gd2hlcmUgdGhlIGZpcnN0XG4gKiBjb2x1bW4gaXMgYW4gb3B0aW9uYWxseSBkaXNwbGF5ZWQgbWVudSBcImRyYXdlclwiIGFuZCB0aGUgc2Vjb25kIHVzZWQgZm9yXG4gKiByZWd1bGFyIGFwcGxpY2F0aW9uIGNvbnRlbnQuXG4gKlxuICogTWV0aG9kcyBleGlzdHMgdG8gb3BlbiBvciBjbG9zZSB0aGUgZHJhd2VyIGFzIHdlbGwgYXMgcmVwbGFjZSB0aGUgY29udGVudFxuICogZGlzcGxheWVkIGluIHRoZSBzZWNvbmQgY29sdW1uIGFzIGRlc2lyZWQuXG4gICovXG5jbGFzcyBEcmF3ZXJMYXlvdXQgZXh0ZW5kcyB3bWxfMS5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld18xLkRyYXdlckxheW91dFZpZXcodGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgd21sOiB7IGlkOiAnbGF5b3V0JyB9LFxuICAgICAgICAgICAgaWQ6IHRoaXMuYXR0cnMuaWQsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLkRSQVdFUl9MQVlPVVQsIF9fMS5MQVlPVVQsIHRoaXMuYXR0cnMuY2xhc3NOYW1lKSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICAgICAgICB3bWw6IHsgaWQ6ICdjb250ZW50JyB9LFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogKDAsIHV0aWxfMS5jb25jYXQpKGV4cG9ydHMuRFJBV0VSX0xBWU9VVF9DT05URU5ULCBfXzEuTEFZT1VUKSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiBnZXRDb250ZW50KHRoaXMuY2hpbGRyZW4sIHRoaXMuYXR0cnMuZHJhd2VyKSxcbiAgICAgICAgICAgICAgICBwZXJzaXN0OiAodGhpcy5hdHRycy5wZXJzaXN0IHx8ICcnKS5zcGxpdCgnLCcpLmZpbHRlcihpZCA9PiBpZClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkcmF3ZXI6IHtcbiAgICAgICAgICAgICAgICB3bWw6IHsgaWQ6ICdkcmF3ZXInIH0sXG4gICAgICAgICAgICAgICAgaGlkZGVuOiAhdGhpcy5hdHRycy5vcGVuLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGdldERyYXdlcih0aGlzLmNoaWxkcmVuLCB0aGlzLmF0dHJzLmRyYXdlcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IF9kcmF3ZXIoKSB7XG4gICAgICAgIHJldHVybiAoMCwgdXRpbF8xLmdldEJ5SWQpKHRoaXMudmlldywgdGhpcy52YWx1ZXMuZHJhd2VyLndtbC5pZCkuZ2V0KCk7XG4gICAgfVxuICAgIGdldCBfY29udGVudCgpIHtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSAoMCwgdXRpbF8xLmdldEJ5SWQpKHRoaXMudmlldywgdGhpcy52YWx1ZXMuY29udGVudC53bWwuaWQpLmdldCgpO1xuICAgICAgICBpZiAodGhpcy5hdHRycy5jb250ZW50KVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQucXVlcnlTZWxlY3RvcihgIyR7dGhpcy5hdHRycy5jb250ZW50fWApO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogaXNPcGVuIGluZGljYXRlcyB3aGV0aGVyIHRoZSBkcmF3ZXIgcGFydCBvZiB0aGUgbGF5b3V0IGlzIG9wZW4uXG4gICAgICovXG4gICAgaXNPcGVuKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuX2RyYXdlci5pc0hpZGRlbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBvcGVuIHRoZSBkcmF3ZXIgcGFydCBvZiB0aGUgbGF5b3V0LlxuICAgICAqL1xuICAgIG9wZW4oKSB7XG4gICAgICAgIHRoaXMuX2RyYXdlci5zaG93KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNsb3NlIHRoZSBkcmF3ZXIgcGFydCBvZiB0aGUgbGF5b3V0LlxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLl9kcmF3ZXIuaGlkZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0b2dnbGUgdGhlIHN0YXRlIG9mIHRoZSBkcmF3ZXIgcGFydCBvZiB0aGUgbGF5b3V0LlxuICAgICAqL1xuICAgIHRvZ2dsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuKCkpXG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgIH1cbiAgICBzZXRDb250ZW50KGZyYWcpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVDb250ZW50KCk7XG4gICAgICAgIGxldCBjb250ZW50ID0gdGhpcy5fY29udGVudDtcbiAgICAgICAgZnJhZy5mb3JFYWNoKGNoaWxkID0+IGNvbnRlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlbW92ZUNvbnRlbnQoKSB7XG4gICAgICAgIGxldCBjb250ZW50ID0gdGhpcy5fY29udGVudDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250ZW50LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSBjb250ZW50LmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKCEoMCwgYXJyYXlfMS5jb250YWlucykodGhpcy52YWx1ZXMuY29udGVudC5wZXJzaXN0LCBjaGlsZC5pZCkpXG4gICAgICAgICAgICAgICAgY29udGVudC5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5EcmF3ZXJMYXlvdXQgPSBEcmF3ZXJMYXlvdXQ7XG5jb25zdCBnZXREcmF3ZXIgPSAoY2hpbGRyZW4sIGlkKSA9PiAoMCwgYXJyYXlfMS5maW5kKShjaGlsZHJlbiwgKGVsKSA9PiBlbC5pZCA9PT0gaWQpXG4gICAgLm1hcCgoZWwpID0+IFtlbF0pXG4gICAgLm9ySnVzdCgoKSA9PiBbXSlcbiAgICAuZ2V0KCk7XG5jb25zdCBnZXRDb250ZW50ID0gKGNoaWxkcmVuLCBpZCkgPT4gY2hpbGRyZW4uZmlsdGVyKGNoaWxkID0+IGNoaWxkLmlkICE9PSBpZCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRHJhd2VyTGF5b3V0VmlldyA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuY29uc3QgZHJhd2VyXzEgPSByZXF1aXJlKFwiLi4vLi4vbWVudS9kcmF3ZXJcIik7XG47XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgRHJhd2VyTGF5b3V0VmlldyB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ2RpdicsIHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMud21sLmlkIH0sICdpZCc6IF9fY29udGV4dC52YWx1ZXMuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuY2xhc3NOYW1lIH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkcmF3ZXJfMS5EcmF3ZXIoeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5kcmF3ZXIud21sLmlkIH0sICdoaWRkZW4nOiBfX2NvbnRleHQudmFsdWVzLmRyYXdlci5oaWRkZW4gfSwgW1xuICAgICAgICAgICAgICAgICAgICAuLi4oX19jb250ZXh0LnZhbHVlcy5kcmF3ZXIuY29udGVudClcbiAgICAgICAgICAgICAgICBdKSwgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5kcmF3ZXIud21sLmlkIH0sICdoaWRkZW4nOiBfX2NvbnRleHQudmFsdWVzLmRyYXdlci5oaWRkZW4gfSksXG4gICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2RpdicsIHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuY29udGVudC53bWwuaWQgfSwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jb250ZW50LmNsYXNzTmFtZSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIC4uLihfX2NvbnRleHQudmFsdWVzLmNvbnRlbnQuY29udGVudClcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLkRyYXdlckxheW91dFZpZXcgPSBEcmF3ZXJMYXlvdXRWaWV3O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlldy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29sdW1uID0gZXhwb3J0cy5Sb3cgPSBleHBvcnRzLkdyaWRMYXlvdXQgPSBleHBvcnRzLkdSSURfTEFZT1VUX0NPTFVNTiA9IGV4cG9ydHMuR1JJRF9MQVlPVVRfUk9XID0gZXhwb3J0cy5HUklEX0xBWU9VVCA9IHZvaWQgMDtcbmNvbnN0IHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2dyaWRcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbmNvbnN0IF9fMSA9IHJlcXVpcmUoXCIuLi9cIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLkdSSURfTEFZT1VUID0gJ3d3LWdyaWQtbGF5b3V0JztcbmV4cG9ydHMuR1JJRF9MQVlPVVRfUk9XID0gJ3d3LWdyaWQtbGF5b3V0X19yb3cnO1xuZXhwb3J0cy5HUklEX0xBWU9VVF9DT0xVTU4gPSAnd3ctZ3JpZC1sYXlvdXRfX2NvbHVtbic7XG47XG4vKipcbiAqIEdyaWRMYXlvdXRcbiAqL1xuY2xhc3MgR3JpZExheW91dCBleHRlbmRzIF9fMS5BYnN0cmFjdExheW91dCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5HcmlkTGF5b3V0KHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICAgICAgICBpZDogdGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmlkLFxuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ3Jvb3QnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjID0gKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5jbGFzc05hbWUpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMuY2xhc3NOYW1lIDogJyc7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbF8xLmNvbmNhdCkoZXhwb3J0cy5HUklEX0xBWU9VVCwgX18xLkxBWU9VVCwgYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuR3JpZExheW91dCA9IEdyaWRMYXlvdXQ7XG4vKipcbiAqIFJvd1xuICovXG5jbGFzcyBSb3cgZXh0ZW5kcyBfXzEuQWJzdHJhY3RMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuUm93KHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICAgICAgICBpZDogdGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmlkLFxuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ3JvdycsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGMgPSAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmNsYXNzTmFtZSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5jbGFzc05hbWUgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLkdSSURfTEFZT1VUX1JPVywgYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuUm93ID0gUm93O1xuLyoqXG4gKiBDb2x1bW5cbiAqL1xuY2xhc3MgQ29sdW1uIGV4dGVuZHMgX18xLkFic3RyYWN0TGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLkNvbHVtbih0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5pZCxcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdjb2x1bW4nXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLkdSSURfTEFZT1VUX0NPTFVNTiwgdGhpcy5hdHRycy5zcGFuID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgLXNwYW4ke3RoaXMuYXR0cnMuc3Bhbn1gIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLXNwYW4xMicsIHRoaXMuYXR0cnMub2Zmc2V0ID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgLW9mZnNldCR7dGhpcy5hdHRycy5vZmZzZXR9YCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJycsIHRoaXMuYXR0cnMuY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbF8xLmNvbmNhdCkoZXhwb3J0cy5HUklEX0xBWU9VVF9DT0xVTU4sICctc3BhbjEyJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5Db2x1bW4gPSBDb2x1bW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29sdW1uID0gZXhwb3J0cy5Sb3cgPSBleHBvcnRzLkdyaWRMYXlvdXQgPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBHcmlkTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnZGl2JywgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5jb250ZW50LndtbC5pZCB9LCAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmNvbnRlbnQuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuY29udGVudC5jbGFzc05hbWUoKSB9LCBbXG4gICAgICAgICAgICAgICAgLi4uKF9fY29udGV4dC5jaGlsZHJlbilcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5HcmlkTGF5b3V0ID0gR3JpZExheW91dDtcbjtcbmNsYXNzIFJvdyB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ2RpdicsIHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuY29udGVudC53bWwuaWQgfSwgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5jb250ZW50LmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmNvbnRlbnQuY2xhc3NOYW1lKCkgfSwgW1xuICAgICAgICAgICAgICAgIC4uLihfX2NvbnRleHQuY2hpbGRyZW4pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuUm93ID0gUm93O1xuO1xuY2xhc3MgQ29sdW1uIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnZGl2JywgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5jb250ZW50LndtbC5pZCB9LCAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmNvbnRlbnQuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuY29udGVudC5jbGFzc05hbWUoKSB9LCBbXG4gICAgICAgICAgICAgICAgLi4uKF9fY29udGV4dC5jaGlsZHJlbilcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5Db2x1bW4gPSBDb2x1bW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncmlkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ib3Jpem9udGFsTGF5b3V0ID0gZXhwb3J0cy5Ib3Jpem9udGFsTGF5b3V0T3JpZW50YXRpb24gPSBleHBvcnRzLkhPUklaT05UQUxfTEFZT1VUID0gdm9pZCAwO1xuY29uc3Qgd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG5jb25zdCB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9ob3Jpem9udGFsXCIpO1xuY29uc3Qgb3JpZW50YXRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZW50L29yaWVudGF0aW9uXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG5jb25zdCBfXzEgPSByZXF1aXJlKFwiLi4vLi4vXCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5IT1JJWk9OVEFMX0xBWU9VVCA9ICd3dy1ob3Jpem9udGFsLWxheW91dCc7XG4vLy9jbGFzc05hbWVzOmVuZFxuLyoqXG4gKiBIb3Jpem9udGFsTGF5b3V0T3JpZW50YXRpb25cbiAqL1xudmFyIEhvcml6b250YWxMYXlvdXRPcmllbnRhdGlvbjtcbihmdW5jdGlvbiAoSG9yaXpvbnRhbExheW91dE9yaWVudGF0aW9uKSB7XG4gICAgSG9yaXpvbnRhbExheW91dE9yaWVudGF0aW9uW1wiTGVmdFwiXSA9IFwibGVmdFwiO1xuICAgIEhvcml6b250YWxMYXlvdXRPcmllbnRhdGlvbltcIlJpZ2h0XCJdID0gXCJyaWdodFwiO1xufSkoSG9yaXpvbnRhbExheW91dE9yaWVudGF0aW9uID0gZXhwb3J0cy5Ib3Jpem9udGFsTGF5b3V0T3JpZW50YXRpb24gfHwgKGV4cG9ydHMuSG9yaXpvbnRhbExheW91dE9yaWVudGF0aW9uID0ge30pKTtcbi8qKlxuICogSG9yaXpvbnRhbExheW91dCB1c2VzIHRoZSBjc3MgZmxleGJveCB0byBwcm92aWRlIGEgY29udGFpbmVyXG4gKiB3aGVyZSBhbGwgaXRlbXMgYXJlIGxhaWQgb3V0IGluIGEgc2luZ2xlIHJvdy5cbiAqL1xuY2xhc3MgSG9yaXpvbnRhbExheW91dCBleHRlbmRzIHdtbC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbih0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgaWQ6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuaWQpID8gdGhpcy5hdHRycy5pZCA6ICcnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogKDAsIHV0aWxfMS5jb25jYXQpKGV4cG9ydHMuSE9SSVpPTlRBTF9MQVlPVVQsICgwLCBfXzEuZ2V0Q2xhc3NOYW1lKSh0aGlzLmF0dHJzKSwgZ2V0T3JpZW50YXRpb24odGhpcy5hdHRycykpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5Ib3Jpem9udGFsTGF5b3V0ID0gSG9yaXpvbnRhbExheW91dDtcbmNvbnN0IGdldE9yaWVudGF0aW9uID0gKGF0dHJzKSA9PiAoYXR0cnMgJiYgYXR0cnMub3JpZW50YXRpb24pID9cbiAgICBhdHRycy5vcmllbnRhdGlvbiA9PT0gSG9yaXpvbnRhbExheW91dE9yaWVudGF0aW9uLlJpZ2h0ID9cbiAgICAgICAgb3JpZW50YXRpb25fMS5SSUdIVCA6IG9yaWVudGF0aW9uXzEuTEVGVCA6ICcnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1haW4gPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnZGl2JywgeyAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NOYW1lIH0sIFtcbiAgICAgICAgICAgICAgICAuLi4oX19jb250ZXh0LmNoaWxkcmVuKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG9yaXpvbnRhbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZG9SZW1vdmVDb250ZW50ID0gZXhwb3J0cy5kb1NldENvbnRlbnQgPSBleHBvcnRzLkFic3RyYWN0TGF5b3V0ID0gZXhwb3J0cy5MQVlPVVQgPSB2b2lkIDA7XG5jb25zdCB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLkxBWU9VVCA9ICctbGF5b3V0Jztcbi8qKlxuICogQWJzdHJhY3RMYXlvdXQgcHJvdmlkZXMgYW4gaW1wbGVtZW50YXRpb24gb2YgTGF5b3V0LlxuICovXG5jbGFzcyBBYnN0cmFjdExheW91dCBleHRlbmRzIHdtbF8xLkNvbXBvbmVudCB7XG4gICAgc2V0Q29udGVudChjKSB7XG4gICAgICAgICgwLCBleHBvcnRzLmRvU2V0Q29udGVudCkodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5jb250ZW50LndtbC5pZCwgYyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZW1vdmVDb250ZW50KCkge1xuICAgICAgICAoMCwgZXhwb3J0cy5kb1JlbW92ZUNvbnRlbnQpKHRoaXMudmlldywgdGhpcy52YWx1ZXMuY29udGVudC53bWwuaWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLkFic3RyYWN0TGF5b3V0ID0gQWJzdHJhY3RMYXlvdXQ7XG4vKipcbiAqIGRvU2V0Q29udGVudCBvbiBhIE5vZGUgZm91bmQgaW4gYSB2aWV3LlxuICovXG5jb25zdCBkb1NldENvbnRlbnQgPSAodmlldywgaWQsIGNvbnRlbnQpID0+IHtcbiAgICBsZXQgbWF5YmVSb290ID0gdmlldy5maW5kQnlJZChpZCk7XG4gICAgaWYgKG1heWJlUm9vdC5pc05vdGhpbmcoKSlcbiAgICAgICAgcmV0dXJuICgwLCB1dGlsXzEud2Fybk1pc3NpbmcpKHZpZXcsIGlkKTtcbiAgICBsZXQgbiA9IG1heWJlUm9vdC5nZXQoKTtcbiAgICB3aGlsZSAobi5maXJzdENoaWxkKVxuICAgICAgICBuLnJlbW92ZUNoaWxkKG4uZmlyc3RDaGlsZCk7XG4gICAgY29udGVudCA9IEFycmF5LmlzQXJyYXkoY29udGVudCkgPyBjb250ZW50IDogW2NvbnRlbnRdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGVudC5sZW5ndGg7IGkrKylcbiAgICAgICAgbi5hcHBlbmRDaGlsZChjb250ZW50W2ldKTtcbn07XG5leHBvcnRzLmRvU2V0Q29udGVudCA9IGRvU2V0Q29udGVudDtcbi8qKlxuICogZG9SZW1vdmVDb250ZW50IGZyb20gYSBWaWV3LlxuICovXG5jb25zdCBkb1JlbW92ZUNvbnRlbnQgPSAodmlldywgaWQpID0+IHtcbiAgICBsZXQgbWF5YmVOb2RlID0gdmlldy5maW5kQnlJZChpZCk7XG4gICAgaWYgKG1heWJlTm9kZS5pc05vdGhpbmcoKSlcbiAgICAgICAgcmV0dXJuICgwLCB1dGlsXzEud2Fybk1pc3NpbmcpKHZpZXcsIGlkKTtcbiAgICBsZXQgbiA9IG1heWJlTm9kZS5nZXQoKTtcbiAgICB3aGlsZSAobi5maXJzdENoaWxkKVxuICAgICAgICBuLnJlbW92ZUNoaWxkKG4uZmlyc3RDaGlsZCk7XG59O1xuZXhwb3J0cy5kb1JlbW92ZUNvbnRlbnQgPSBkb1JlbW92ZUNvbnRlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGlzdExheW91dCA9IGV4cG9ydHMuTGlzdExheW91dEl0ZW0gPSBleHBvcnRzLkxJU1RfTEFZT1VUX0lURU0gPSBleHBvcnRzLkxJU1RfTEFZT1VUID0gdm9pZCAwO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvbGlzdFwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xuY29uc3QgYWN0aXZlXzEgPSByZXF1aXJlKFwiLi4vLi4vY29udGVudC9zdGF0ZS9hY3RpdmVcIik7XG5jb25zdCBfXzEgPSByZXF1aXJlKFwiLi4vXCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5MSVNUX0xBWU9VVCA9ICd3dy1saXN0LWxheW91dCc7XG5leHBvcnRzLkxJU1RfTEFZT1VUX0lURU0gPSAnd3ctbGlzdC1sYXlvdXRfX2l0ZW0nO1xuLyoqXG4gKiBMaXN0TGF5b3V0SXRlbVxuICovXG5jbGFzcyBMaXN0TGF5b3V0SXRlbSBleHRlbmRzIF9fMS5BYnN0cmFjdExheW91dCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5MaXN0TGF5b3V0SXRlbSh0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAnaXRlbSdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlkOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmlkKSA/IHRoaXMuYXR0cnMuaWQgOiAnJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLkxJU1RfTEFZT1VUX0lURU0sICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuYWN0aXZlKSA/IGFjdGl2ZV8xLkFDVElWRSA6ICcnKSxcbiAgICAgICAgICAgICAgICBuYW1lOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLm5hbWUpID8gdGhpcy5hdHRycy5uYW1lIDogJycsXG4gICAgICAgICAgICAgICAgb25jbGljazogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLm9uQ2xpY2spXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLm9uQ2xpY2sodGhpcy5hdHRycyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMubmFtZSB8fCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBpc0FjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuICgwLCBhY3RpdmVfMS5pc0FjdGl2ZSkodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5jb250ZW50LndtbC5pZCk7XG4gICAgfVxuICAgIGFjdGl2YXRlKCkge1xuICAgICAgICAoMCwgYWN0aXZlXzEuYWN0aXZhdGUpKHRoaXMudmlldywgdGhpcy52YWx1ZXMuY29udGVudC53bWwuaWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVhY3RpdmF0ZSgpIHtcbiAgICAgICAgKDAsIGFjdGl2ZV8xLmRlYWN0aXZhdGUpKHRoaXMudmlldywgdGhpcy52YWx1ZXMuY29udGVudC53bWwuaWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9nZ2xlQWN0aXZlKCkge1xuICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZSgpKVxuICAgICAgICAgICAgdGhpcy5kZWFjdGl2YXRlKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5MaXN0TGF5b3V0SXRlbSA9IExpc3RMYXlvdXRJdGVtO1xuLyoqXG4gKiBMaXN0TGF5b3V0IGlzIHVzZWQgdG8gY3JlYXRlIGEgdmVydGljYWwgbGlzdCBvZiBjb250ZW50LlxuICpcbiAqIENoaWxkcmVuIG11c3QgYmUgTGlzdEdyb3VwSXRlbXMuXG4gKi9cbmNsYXNzIExpc3RMYXlvdXQgZXh0ZW5kcyBfXzEuQWJzdHJhY3RMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuTGlzdExheW91dCh0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAnbGlzdCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlkOiB0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuaWQsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAoMCwgdXRpbF8xLmNvbmNhdCkoZXhwb3J0cy5MSVNUX0xBWU9VVCwgX18xLkxBWU9VVCwgKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5jbGFzc05hbWUpID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5jbGFzc05hbWUgOiAnJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkxpc3RMYXlvdXQgPSBMaXN0TGF5b3V0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxpc3RMYXlvdXQgPSBleHBvcnRzLkxpc3RMYXlvdXRJdGVtID0gdm9pZCAwO1xuY29uc3QgX19kb2N1bWVudCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbmNvbnN0IG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgTGlzdExheW91dEl0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdsaScsIHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuY29udGVudC53bWwuaWQgfSwgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5jb250ZW50LmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmNvbnRlbnQuY2xhc3NOYW1lLCAnb25jbGljayc6IF9fY29udGV4dC52YWx1ZXMuY29udGVudC5vbmNsaWNrIH0sIFtcbiAgICAgICAgICAgICAgICAuLi4oX19jb250ZXh0LmNoaWxkcmVuKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLkxpc3RMYXlvdXRJdGVtID0gTGlzdExheW91dEl0ZW07XG47XG5jbGFzcyBMaXN0TGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgndWwnLCB7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmNvbnRlbnQud21sLmlkIH0sICdpZCc6IF9fY29udGV4dC52YWx1ZXMuY29udGVudC5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jb250ZW50LmNsYXNzTmFtZSB9LCBbXG4gICAgICAgICAgICAgICAgLi4uKF9fY29udGV4dC5jaGlsZHJlbilcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5MaXN0TGF5b3V0ID0gTGlzdExheW91dDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1haW5MYXlvdXQgPSBleHBvcnRzLk1BSU5fTEFZT1VUID0gdm9pZCAwO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvbWFpblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xuY29uc3QgX18xID0gcmVxdWlyZShcIi4uL1wiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuTUFJTl9MQVlPVVQgPSAnd3ctbWFpbi1sYXlvdXQnO1xuLyoqXG4gKiBNYWluTGF5b3V0IHByb3ZpZGVzIGEgY29udGFpbmVyIGZvciB0aGUgbWFpbiBjb250ZW50IG9mIGFuIGFwcGxpY2F0aW9uLlxuICovXG5jbGFzcyBNYWluTGF5b3V0IGV4dGVuZHMgX18xLkFic3RyYWN0TGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ21haW4nXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpZDogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycykgPyB0aGlzLmF0dHJzLmlkIDogJycsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAoMCwgdXRpbF8xLmNvbmNhdCkoZXhwb3J0cy5NQUlOX0xBWU9VVCwgX18xLkxBWU9VVCwgKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycykgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLmNsYXNzTmFtZSA6ICcnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuTWFpbkxheW91dCA9IE1haW5MYXlvdXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWFpbiA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9faWYgPSAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpID0+IChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0ID8gX19hbHQoKSA6IFtdO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9ySW4gPSAobGlzdCwgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2Zvck9mID0gKG8sIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHRleHQgPSBfX2RvY3VtZW50LnRleHQ7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHVuc2FmZSA9IF9fZG9jdW1lbnQudW5zYWZlO1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCBpc1NldCA9ICh2YWx1ZSkgPT4gdmFsdWUgIT0gbnVsbDtcbmNsYXNzIE1haW4ge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdkaXYnLCB7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmNvbnRlbnQud21sLmlkIH0sICdpZCc6IF9fY29udGV4dC52YWx1ZXMuY29udGVudC5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jb250ZW50LmNsYXNzTmFtZSB9LCBbXG4gICAgICAgICAgICAgICAgLi4uKF9fY29udGV4dC5jaGlsZHJlbilcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1haW4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1ldGVyQmFyID0gZXhwb3J0cy5NZXRlciA9IGV4cG9ydHMuTUVURVJfQkFSID0gZXhwb3J0cy5NRVRFUiA9IHZvaWQgMDtcbmNvbnN0IHZpZXdzID0gcmVxdWlyZShcIi4vd21sL21ldGVyXCIpO1xuY29uc3Qgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xuY29uc3QgX18xID0gcmVxdWlyZShcIi4uLy4uL1wiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuTUVURVIgPSAnd3ctbWV0ZXInO1xuZXhwb3J0cy5NRVRFUl9CQVIgPSAnd3ctbWV0ZXJfX2Jhcic7XG4vKipcbiAqIE1ldGVyXG4gKi9cbmNsYXNzIE1ldGVyIGV4dGVuZHMgd21sXzEuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1ldGVyKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiAoMCwgX18xLmdldElkKSh0aGlzLmF0dHJzKSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogKDAsIHV0aWxfMS5jb25jYXQpKGV4cG9ydHMuTUVURVIsICgwLCBfXzEuZ2V0Q2xhc3NOYW1lKSh0aGlzLmF0dHJzKSlcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLk1ldGVyID0gTWV0ZXI7XG4vKipcbiAqIE1ldGVyQmFyXG4gKi9cbmNsYXNzIE1ldGVyQmFyIGV4dGVuZHMgd21sXzEuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1ldGVyQmFyKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiAoMCwgX18xLmdldElkKSh0aGlzLmF0dHJzKSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogKDAsIHV0aWxfMS5jb25jYXQpKGV4cG9ydHMuTUVURVJfQkFSLCAoMCwgX18xLmdldENsYXNzTmFtZSkodGhpcy5hdHRycykpLFxuICAgICAgICAgICAgdmFsdWU6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMudmFsdWUpID9cbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLnZhbHVlIDogMCxcbiAgICAgICAgICAgIGNvbG9yOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmNvbG9yKSA/XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRycy5jb2xvciA6ICcnLFxuICAgICAgICAgICAgc3R5bGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgbGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlcy5jb2xvcilcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5wdXNoKGBiYWNrZ3JvdW5kLWNvbG9yOiR7dGhpcy52YWx1ZXMuY29sb3J9YCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWVzLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICBsaXN0LnB1c2goYHdpZHRoOiR7dGhpcy52YWx1ZXMudmFsdWV9JWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0LmpvaW4oJzsnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogc2V0VmFsdWUgc2V0cyB0aGUgdmFsdWUgb2YgdGhlIE1ldGVyQmFyLlxuICAgICAqL1xuICAgIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWVzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudmlldy5pbnZhbGlkYXRlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBpbmNyZWFzZSB0aGUgdmFsdWUgYnkgdGhlIHNwZWNpZmllZCBhbW91bnQuXG4gICAgICovXG4gICAgaW5jcmVhc2UodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZXMudmFsdWUgPSB0aGlzLnZhbHVlcy52YWx1ZSArIHZhbHVlO1xuICAgICAgICB0aGlzLnZpZXcuaW52YWxpZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogZGVjcmVhc2UgdGhlIHZhbHVlIGJ5IHRoZSBzcGVjaWZpZWQgYW1vdW50LlxuICAgICAqL1xuICAgIGRlY3JlYXNlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWVzLnZhbHVlID0gdGhpcy52YWx1ZXMudmFsdWUgLSB2YWx1ZTtcbiAgICAgICAgdGhpcy52aWV3LmludmFsaWRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHNldENvbG9yIG9mIHRoZSBNZXRlckJhci5cbiAgICAgKi9cbiAgICBzZXRDb2xvcihjb2xvcikge1xuICAgICAgICB0aGlzLnZhbHVlcy5jb2xvciA9IGNvbG9yO1xuICAgICAgICB0aGlzLnZpZXcuaW52YWxpZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLk1ldGVyQmFyID0gTWV0ZXJCYXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWV0ZXJCYXIgPSBleHBvcnRzLk1ldGVyID0gdm9pZCAwO1xuY29uc3QgX19kb2N1bWVudCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbmNvbnN0IG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgTWV0ZXIge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdkaXYnLCB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuY2xhc3NOYW1lIH0sIFtcbiAgICAgICAgICAgICAgICAuLi4oX19jb250ZXh0LmNoaWxkcmVuKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk1ldGVyID0gTWV0ZXI7XG47XG5jbGFzcyBNZXRlckJhciB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ2RpdicsIHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jbGFzc05hbWUsICdzdHlsZSc6IF9fY29udGV4dC52YWx1ZXMuc3R5bGUoKSB9LCBbXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk1ldGVyQmFyID0gTWV0ZXJCYXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGFuZWxGb290ZXIgPSBleHBvcnRzLlBhbmVsQm9keSA9IGV4cG9ydHMuUGFuZWxIZWFkZXIgPSBleHBvcnRzLlBhbmVsID0gZXhwb3J0cy5QQU5FTF9GT09URVIgPSBleHBvcnRzLlBBTkVMX0JPRFkgPSBleHBvcnRzLlBBTkVMX0hFQURFUiA9IGV4cG9ydHMuUEFORUwgPSB2b2lkIDA7XG5jb25zdCBzdHlsZSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZW50L3N0eWxlXCIpO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvcGFuZWxcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbmNvbnN0IF9fMSA9IHJlcXVpcmUoXCIuLlwiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbi8qKlxuICogUEFORUwgd3JhcHBlciBjbGFzcy5cbiAqL1xuZXhwb3J0cy5QQU5FTCA9ICd3dy1wYW5lbCc7XG4vKipcbiAqIFBBTkVMX0hFQURFUiBjbGFzcyBuYW1lLlxuICovXG5leHBvcnRzLlBBTkVMX0hFQURFUiA9ICd3dy1wYW5lbF9faGVhZGVyJztcbi8qKlxuICogUEFORUxfQk9EWSBjbGFzcyBuYW1lLlxuICovXG5leHBvcnRzLlBBTkVMX0JPRFkgPSAnd3ctcGFuZWxfX2JvZHknO1xuLyoqXG4gKiBQQU5FTF9GT09URVIgY2xhc3MgbmFtZS5cbiAqL1xuZXhwb3J0cy5QQU5FTF9GT09URVIgPSAnd3ctcGFuZWxfX2Zvb3Rlcic7XG4vKipcbiAqIFBhbmVsIHByb3ZpZGVzIGEgcmVjdGFuZ3VsYXIgY29udGFpbmVyIGZvciB2aXN1YWxseSBzZXBlcmF0aW5nXG4gKiBjb250ZW50IGJ5IGNvbnRleHQuXG4gKi9cbmNsYXNzIFBhbmVsIGV4dGVuZHMgX18xLkFic3RyYWN0TGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLlBhbmVsKHRoaXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogdmFsdWVzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogcm9vdCB2YWx1ZXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICAgICAgICBpZDogdGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmlkLFxuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ3BhbmVsJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogKDAsIHV0aWxfMS5jb25jYXQpKGV4cG9ydHMuUEFORUwsIF9fMS5MQVlPVVQsICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuc3R5bGUpID9cbiAgICAgICAgICAgICAgICAgICAgYC0ke3RoaXMuYXR0cnMuc3R5bGV9YCA6IHN0eWxlLkRFRkFVTFQsIHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5jbGFzc05hbWUgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLmNsYXNzTmFtZSA6ICcnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuUGFuZWwgPSBQYW5lbDtcbi8qKlxuICogUGFuZWxIZWFkZXJcbiAqL1xuY2xhc3MgUGFuZWxIZWFkZXIgZXh0ZW5kcyBfXzEuQWJzdHJhY3RMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuUGFuZWxIZWFkZXIodGhpcyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB2YWx1ZXNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ2hlYWRlcidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlkOiB0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuaWQsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAoMCwgdXRpbF8xLmNvbmNhdCkoZXhwb3J0cy5QQU5FTF9IRUFERVIsIF9fMS5MQVlPVVQsIHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5jbGFzc05hbWUgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLmNsYXNzTmFtZSA6ICcnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuUGFuZWxIZWFkZXIgPSBQYW5lbEhlYWRlcjtcbi8qKlxuICogUGFuZWxCb2R5XG4gKi9cbmNsYXNzIFBhbmVsQm9keSBleHRlbmRzIF9fMS5BYnN0cmFjdExheW91dCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5QYW5lbEJvZHkodGhpcyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB2YWx1ZXNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ2JvZHknXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpZDogdGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmlkLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogKDAsIHV0aWxfMS5jb25jYXQpKGV4cG9ydHMuUEFORUxfQk9EWSwgX18xLkxBWU9VVCwgdGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmNsYXNzTmFtZSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMuY2xhc3NOYW1lIDogJycpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5QYW5lbEJvZHkgPSBQYW5lbEJvZHk7XG4vKipcbiAqIFBhbmVsRm9vdGVyXG4gKi9cbmNsYXNzIFBhbmVsRm9vdGVyIGV4dGVuZHMgX18xLkFic3RyYWN0TGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLlBhbmVsRm9vdGVyKHRoaXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogdmFsdWVzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdmb290ZXInXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpZDogdGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmlkLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogKDAsIHV0aWxfMS5jb25jYXQpKGV4cG9ydHMuUEFORUxfRk9PVEVSLCBfXzEuTEFZT1VULCB0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuY2xhc3NOYW1lID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRycy5jbGFzc05hbWUgOiAnJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlBhbmVsRm9vdGVyID0gUGFuZWxGb290ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGFuZWxGb290ZXIgPSBleHBvcnRzLlBhbmVsQm9keSA9IGV4cG9ydHMuUGFuZWxIZWFkZXIgPSBleHBvcnRzLlBhbmVsID0gdm9pZCAwO1xuY29uc3QgX19kb2N1bWVudCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbmNvbnN0IG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgUGFuZWwge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdkaXYnLCB7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmNvbnRlbnQuaWQgfSwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jb250ZW50LmNsYXNzTmFtZSB9LCBbXG4gICAgICAgICAgICAgICAgLi4uKF9fY29udGV4dC5jaGlsZHJlbilcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5QYW5lbCA9IFBhbmVsO1xuO1xuY2xhc3MgUGFuZWxIZWFkZXIge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdkaXYnLCB7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmNvbnRlbnQuaWQgfSwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jb250ZW50LmNsYXNzTmFtZSB9LCBbXG4gICAgICAgICAgICAgICAgLi4uKF9fY29udGV4dC5jaGlsZHJlbilcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5QYW5lbEhlYWRlciA9IFBhbmVsSGVhZGVyO1xuO1xuY2xhc3MgUGFuZWxCb2R5IHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnZGl2JywgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5jb250ZW50LmlkIH0sICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuY29udGVudC5jbGFzc05hbWUgfSwgW1xuICAgICAgICAgICAgICAgIC4uLihfX2NvbnRleHQuY2hpbGRyZW4pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuUGFuZWxCb2R5ID0gUGFuZWxCb2R5O1xuO1xuY2xhc3MgUGFuZWxGb290ZXIge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdkaXYnLCB7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmNvbnRlbnQuaWQgfSwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jb250ZW50LmNsYXNzTmFtZSB9LCBbXG4gICAgICAgICAgICAgICAgLi4uKF9fY29udGV4dC5jaGlsZHJlbilcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5QYW5lbEZvb3RlciA9IFBhbmVsRm9vdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFuZWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRhYkxheW91dCA9IGV4cG9ydHMuVEFCX0xBWU9VVCA9IHZvaWQgMDtcbmNvbnN0IHZpZXdzID0gcmVxdWlyZShcIi4vd21sL3RhYlwiKTtcbmNvbnN0IHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG5jb25zdCBkb21fMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG5jb25zdCBfXzEgPSByZXF1aXJlKFwiLi4vLi4vXCIpO1xuY29uc3QgX18yID0gcmVxdWlyZShcIi4uL1wiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuVEFCX0xBWU9VVCA9ICd3dy10YWItbGF5b3V0Jztcbi8qKlxuICogVGFiTGF5b3V0IHByb3ZpZGVzIGEgbGF5b3V0IHdob3NlIGRpc3BsYXllZCBjb250ZW50IGNhbiBiZSBjaGFuZ2VkIHZpYSB0YWJzLlxuICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgVGFiMSAgfCAgVGFiMiAgfCBUYWIyICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxDb250ZW50PiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHxfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX3xcbiAqL1xuY2xhc3MgVGFiTGF5b3V0IGV4dGVuZHMgd21sXzEuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgICAgIGlkOiAoMCwgX18xLmdldElkKSh0aGlzLmF0dHJzKSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLlRBQl9MQVlPVVQsIF9fMi5MQVlPVVQsICgwLCBfXzEuZ2V0Q2xhc3NOYW1lKSh0aGlzLmF0dHJzKSksXG4gICAgICAgICAgICAgICAgY29udGVudDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5hY3RpdmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWF5YmVBY3RpdmUgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMudmFsdWVzLnRhYnMuZGF0YVt0aGlzLmF0dHJzLmFjdGl2ZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1heWJlQWN0aXZlLmlzSnVzdCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXliZUFjdGl2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0KClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbnRlbnRGdW4odGhpcykodGhpcy52aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGFiczoge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQ6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuYWN0aXZlKSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMuYWN0aXZlIDogJycsXG4gICAgICAgICAgICAgICAgZGF0YTogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy50YWJzKSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMudGFicyA6IHt9LFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICh0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0LnRhYkZ1bilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0LnRhYkZ1bih0aGlzKSh0aGlzLnZpZXcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodC50ZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsoMCwgZG9tXzEudGV4dCkodC50ZXh0KV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uQ2xpY2s6IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlcy50YWJzLmN1cnJlbnQgIT09IGUubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzLnRhYnMuY3VycmVudCA9IGUubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhYiA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy52YWx1ZXMudGFicy5kYXRhW2UubmFtZV0pLmdldCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcy5yb290LmNvbnRlbnQgPSAoKSA9PiB0YWIuY29udGVudEZ1bih0aGlzKSh0aGlzLnZpZXcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXcuaW52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgc2V0Q29udGVudChjKSB7XG4gICAgICAgIHRoaXMudmFsdWVzLnJvb3QuY29udGVudCA9ICgpID0+IGM7XG4gICAgICAgIHRoaXMudmlldy5pbnZhbGlkYXRlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZW1vdmVDb250ZW50KCkge1xuICAgICAgICB0aGlzLnZhbHVlcy5yb290LmNvbnRlbnQgPSAoKSA9PiBbXTtcbiAgICAgICAgdGhpcy52aWV3LmludmFsaWRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5UYWJMYXlvdXQgPSBUYWJMYXlvdXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWFpbiA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuY29uc3QgdGFiX2Jhcl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2NvbnRyb2wvdGFiLWJhclwiKTtcbjtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnZGl2JywgeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMucm9vdC5jbGFzc05hbWUgfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRhYl9iYXJfMS5UYWJCYXIoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgLi4uX19mb3JPZihfX2NvbnRleHQudmFsdWVzLnRhYnMuZGF0YSwgKHRhYiwgbmFtZSwgXyQkYWxsKSA9PiAoW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgdGFiX2Jhcl8xLlRhYih7ICduYW1lJzogbmFtZSwgJ2FjdGl2ZSc6IChfX2NvbnRleHQudmFsdWVzLnRhYnMuY3VycmVudCA9PT0gbmFtZSksICdvbkNsaWNrJzogX19jb250ZXh0LnZhbHVlcy50YWJzLm9uQ2xpY2sgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLihfX2NvbnRleHQudmFsdWVzLnRhYnMuY29udGVudCh0YWIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksIHsgJ25hbWUnOiBuYW1lLCAnYWN0aXZlJzogKF9fY29udGV4dC52YWx1ZXMudGFicy5jdXJyZW50ID09PSBuYW1lKSwgJ29uQ2xpY2snOiBfX2NvbnRleHQudmFsdWVzLnRhYnMub25DbGljayB9KVxuICAgICAgICAgICAgICAgICAgICBdKSwgKCkgPT4gKFtdKSlcbiAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgIC4uLihfX2NvbnRleHQudmFsdWVzLnJvb3QuY29udGVudCgpKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFiLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UYWJsZUxheW91dCA9IGV4cG9ydHMuVGFibGVXaW5kb3cgPSBleHBvcnRzLlRhYmxlQ2VsbCA9IGV4cG9ydHMuVGFibGVIZWFkaW5nID0gZXhwb3J0cy5UYWJsZVJvdyA9IGV4cG9ydHMuVGFibGVGb290ZXIgPSBleHBvcnRzLlRhYmxlQm9keSA9IGV4cG9ydHMuVGFibGVIZWFkZXIgPSBleHBvcnRzLkhPVkVSQUJMRSA9IGV4cG9ydHMuQUxURVJOQVRFID0gZXhwb3J0cy5DT01QQUNUID0gZXhwb3J0cy5CT1JERVJFRCA9IGV4cG9ydHMuVEFCTEVfV0lORE9XID0gZXhwb3J0cy5UQUJMRV9MQVlPVVQgPSBleHBvcnRzLlRBQkxFX0NFTEwgPSBleHBvcnRzLlRBQkxFX0hFQURJTkcgPSBleHBvcnRzLlRBQkxFX1JPVyA9IGV4cG9ydHMuVEFCTEVfRk9PVEVSID0gZXhwb3J0cy5UQUJMRV9CT0RZID0gZXhwb3J0cy5UQUJMRV9IRUFERVIgPSB2b2lkIDA7XG5jb25zdCB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC90YWJsZVwiKTtcbmNvbnN0IHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbmNvbnN0IF9fMSA9IHJlcXVpcmUoXCIuLi8uLi9cIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLlRBQkxFX0hFQURFUiA9ICd3dy10YWJsZS1sYXlvdXRfX2hlYWRlcic7XG5leHBvcnRzLlRBQkxFX0JPRFkgPSAnd3ctdGFibGUtbGF5b3V0X19ib2R5JztcbmV4cG9ydHMuVEFCTEVfRk9PVEVSID0gJ3d3LXRhYmxlLWxheW91dF9fZm9vdGVyJztcbmV4cG9ydHMuVEFCTEVfUk9XID0gJ3d3LXRhYmxlLWxheW91dF9fcm93JztcbmV4cG9ydHMuVEFCTEVfSEVBRElORyA9ICd3dy10YWJsZS1sYXlvdXQgX2hlYWRpbmcnO1xuZXhwb3J0cy5UQUJMRV9DRUxMID0gJ3d3LXRhYmxlLWxheW91dF9fY2VsbCc7XG5leHBvcnRzLlRBQkxFX0xBWU9VVCA9ICd3dy10YWJsZS1sYXlvdXQnO1xuZXhwb3J0cy5UQUJMRV9XSU5ET1cgPSAnd3ctdGFibGUtd2luZG93JztcbmV4cG9ydHMuQk9SREVSRUQgPSAnLWJvcmRlcmVkJztcbmV4cG9ydHMuQ09NUEFDVCA9ICctY29tcGFjdCc7XG5leHBvcnRzLkFMVEVSTkFURSA9ICctYWx0ZXJuYXRlJztcbmV4cG9ydHMuSE9WRVJBQkxFID0gJy1ob3ZlcmFibGUnO1xuLyoqXG4gKiBUYWJsZUhlYWRlciAoPHRoZWFkPilcbiAqL1xuY2xhc3MgVGFibGVIZWFkZXIgZXh0ZW5kcyB3bWxfMS5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuVGFibGVIZWFkZXIodGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6ICgwLCBfXzEuZ2V0SWQpKHRoaXMuYXR0cnMpLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAoMCwgdXRpbF8xLmNvbmNhdCkoZXhwb3J0cy5UQUJMRV9IRUFERVIsICgwLCBfXzEuZ2V0Q2xhc3NOYW1lKSh0aGlzLmF0dHJzKSlcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlRhYmxlSGVhZGVyID0gVGFibGVIZWFkZXI7XG4vKipcbiAqIFRhYmxlQm9keVxuICovXG5jbGFzcyBUYWJsZUJvZHkgZXh0ZW5kcyB3bWxfMS5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuVGFibGVCb2R5KHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiAoMCwgX18xLmdldElkKSh0aGlzLmF0dHJzKSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogKDAsIHV0aWxfMS5jb25jYXQpKGV4cG9ydHMuVEFCTEVfQk9EWSwgKDAsIF9fMS5nZXRDbGFzc05hbWUpKHRoaXMuYXR0cnMpKVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuVGFibGVCb2R5ID0gVGFibGVCb2R5O1xuLyoqXG4gKiBUYWJsZUZvb3RlclxuICovXG5jbGFzcyBUYWJsZUZvb3RlciBleHRlbmRzIHdtbF8xLkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5UYWJsZUZvb3Rlcih0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBpZDogKDAsIF9fMS5nZXRJZCkodGhpcy5hdHRycyksXG4gICAgICAgICAgICBjbGFzc05hbWU6ICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLlRBQkxFX0ZPT1RFUiwgKDAsIF9fMS5nZXRDbGFzc05hbWUpKHRoaXMuYXR0cnMpKVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuVGFibGVGb290ZXIgPSBUYWJsZUZvb3Rlcjtcbi8qKlxuICogVGFibGVSb3dcbiAqL1xuY2xhc3MgVGFibGVSb3cgZXh0ZW5kcyB3bWxfMS5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuVGFibGVSb3codGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6ICgwLCBfXzEuZ2V0SWQpKHRoaXMuYXR0cnMpLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAoMCwgdXRpbF8xLmNvbmNhdCkoZXhwb3J0cy5UQUJMRV9ST1csICgwLCBfXzEuZ2V0Q2xhc3NOYW1lKSh0aGlzLmF0dHJzKSksXG4gICAgICAgICAgICBvbmNsaWNrOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLm9uY2xpY2spID9cbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLm9uY2xpY2sgOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlRhYmxlUm93ID0gVGFibGVSb3c7XG4vKipcbiAqIFRhYmxlSGVhZGluZ1xuICovXG5jbGFzcyBUYWJsZUhlYWRpbmcgZXh0ZW5kcyB3bWxfMS5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuVGFibGVIZWFkaW5nKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiAoMCwgX18xLmdldElkKSh0aGlzLmF0dHJzKSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogKDAsIHV0aWxfMS5jb25jYXQpKGV4cG9ydHMuVEFCTEVfSEVBRElORywgKDAsIF9fMS5nZXRDbGFzc05hbWUpKHRoaXMuYXR0cnMpKSxcbiAgICAgICAgICAgIG9uY2xpY2s6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMub25jbGljaykgP1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMub25jbGljayA6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuVGFibGVIZWFkaW5nID0gVGFibGVIZWFkaW5nO1xuLyoqXG4gKiBUYWJsZUNlbGxcbiAqL1xuY2xhc3MgVGFibGVDZWxsIGV4dGVuZHMgd21sXzEuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLlRhYmxlQ2VsbCh0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBpZDogKDAsIF9fMS5nZXRJZCkodGhpcy5hdHRycyksXG4gICAgICAgICAgICBjbGFzc05hbWU6ICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLlRBQkxFX0NFTEwsICgwLCBfXzEuZ2V0Q2xhc3NOYW1lKSh0aGlzLmF0dHJzKSksXG4gICAgICAgICAgICBjb2xzcGFuOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmNvbHNwYW4pID9cbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLmNvbHNwYW4gOiAxLFxuICAgICAgICAgICAgcm93c3BhbjogKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5yb3dzcGFuKSA/XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRycy5yb3dzcGFuIDogMSxcbiAgICAgICAgICAgIG9uY2xpY2s6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMub25jbGljaykgP1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMub25jbGljayA6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuVGFibGVDZWxsID0gVGFibGVDZWxsO1xuLyoqXG4gKiBUYWJsZVdpbmRvdyBhbGxvd3MgYSBUYWJsZUxheW91dCB0byBiZSBzY3JvbGxlZCBvbiBzbWFsbGVyIHNjcmVlbnMuXG4gKi9cbmNsYXNzIFRhYmxlV2luZG93IGV4dGVuZHMgd21sXzEuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLlRhYmxlV2luZG93KHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiAoMCwgX18xLmdldElkKSh0aGlzLmF0dHJzKSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogKDAsIHV0aWxfMS5jb25jYXQpKGV4cG9ydHMuVEFCTEVfV0lORE9XLCAoMCwgX18xLmdldENsYXNzTmFtZSkodGhpcy5hdHRycykpXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5UYWJsZVdpbmRvdyA9IFRhYmxlV2luZG93O1xuLyoqXG4gKiBUYWJsZUxheW91dCBwcm92aWRlcyBhIDx0YWJsZT4gYmFzZWQgbGF5b3V0LlxuICovXG5jbGFzcyBUYWJsZUxheW91dCBleHRlbmRzIHdtbF8xLkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5UYWJsZUxheW91dCh0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICBpZDogJ3RhYmxlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlkOiAoMCwgX18xLmdldElkKSh0aGlzLmF0dHJzKSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogKDAsIHV0aWxfMS5jb25jYXQpKGV4cG9ydHMuVEFCTEVfTEFZT1VULCAoMCwgX18xLmdldENsYXNzTmFtZSkodGhpcy5hdHRycyksICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuYWx0ZXJuYXRlKSA/IGV4cG9ydHMuQUxURVJOQVRFIDogJycsICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuYm9yZGVyZWQpID8gZXhwb3J0cy5CT1JERVJFRCA6ICcnLCAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmNvbXBhY3QpID8gZXhwb3J0cy5DT01QQUNUIDogJycsICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuaG92ZXJhYmxlKSA/IGV4cG9ydHMuSE9WRVJBQkxFIDogJycpLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuVGFibGVMYXlvdXQgPSBUYWJsZUxheW91dDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UYWJsZUxheW91dCA9IGV4cG9ydHMuVGFibGVXaW5kb3cgPSBleHBvcnRzLlRhYmxlQ2VsbCA9IGV4cG9ydHMuVGFibGVIZWFkaW5nID0gZXhwb3J0cy5UYWJsZVJvdyA9IGV4cG9ydHMuVGFibGVGb290ZXIgPSBleHBvcnRzLlRhYmxlQm9keSA9IGV4cG9ydHMuVGFibGVIZWFkZXIgPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBUYWJsZUhlYWRlciB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ3RoZWFkJywgeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmNsYXNzTmFtZSB9LCBbXG4gICAgICAgICAgICAgICAgLi4uKF9fY29udGV4dC5jaGlsZHJlbilcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5UYWJsZUhlYWRlciA9IFRhYmxlSGVhZGVyO1xuO1xuY2xhc3MgVGFibGVCb2R5IHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgndGJvZHknLCB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuY2xhc3NOYW1lIH0sIFtcbiAgICAgICAgICAgICAgICAuLi4oX19jb250ZXh0LmNoaWxkcmVuKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLlRhYmxlQm9keSA9IFRhYmxlQm9keTtcbjtcbmNsYXNzIFRhYmxlRm9vdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgndGZvb3QnLCB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuY2xhc3NOYW1lIH0sIFtcbiAgICAgICAgICAgICAgICAuLi4oX19jb250ZXh0LmNoaWxkcmVuKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLlRhYmxlRm9vdGVyID0gVGFibGVGb290ZXI7XG47XG5jbGFzcyBUYWJsZVJvdyB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ3RyJywgeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmNsYXNzTmFtZSwgJ29uY2xpY2snOiBfX2NvbnRleHQudmFsdWVzLm9uY2xpY2sgfSwgW1xuICAgICAgICAgICAgICAgIC4uLihfX2NvbnRleHQuY2hpbGRyZW4pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuVGFibGVSb3cgPSBUYWJsZVJvdztcbjtcbmNsYXNzIFRhYmxlSGVhZGluZyB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ3RoJywgeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmNsYXNzTmFtZSwgJ29uY2xpY2snOiBfX2NvbnRleHQudmFsdWVzLm9uY2xpY2sgfSwgW1xuICAgICAgICAgICAgICAgIC4uLihfX2NvbnRleHQuY2hpbGRyZW4pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuVGFibGVIZWFkaW5nID0gVGFibGVIZWFkaW5nO1xuO1xuY2xhc3MgVGFibGVDZWxsIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgndGQnLCB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuY2xhc3NOYW1lLCAnY29sc3Bhbic6IFN0cmluZyhfX2NvbnRleHQudmFsdWVzLmNvbHNwYW4pLCAncm93c3Bhbic6IFN0cmluZyhfX2NvbnRleHQudmFsdWVzLnJvd3NwYW4pLCAnb25jbGljayc6IF9fY29udGV4dC52YWx1ZXMub25jbGljayB9LCBbXG4gICAgICAgICAgICAgICAgLi4uKF9fY29udGV4dC5jaGlsZHJlbilcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5UYWJsZUNlbGwgPSBUYWJsZUNlbGw7XG47XG5jbGFzcyBUYWJsZVdpbmRvdyB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ2RpdicsIHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jbGFzc05hbWUgfSwgW1xuICAgICAgICAgICAgICAgIC4uLihfX2NvbnRleHQuY2hpbGRyZW4pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuVGFibGVXaW5kb3cgPSBUYWJsZVdpbmRvdztcbjtcbmNsYXNzIFRhYmxlTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgndGFibGUnLCB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuY2xhc3NOYW1lIH0sIFtcbiAgICAgICAgICAgICAgICAuLi4oX19jb250ZXh0LmNoaWxkcmVuKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLlRhYmxlTGF5b3V0ID0gVGFibGVMYXlvdXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2VsbCA9IGV4cG9ydHMuV0VMTCA9IHZvaWQgMDtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xuY29uc3QgX18xID0gcmVxdWlyZShcIi4uXCIpO1xuY29uc3Qgd2VsbF8xID0gcmVxdWlyZShcIi4vd21sL3dlbGxcIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLldFTEwgPSAnd3ctd2VsbCc7XG4vKipcbiAqIFdlbGwgcHJvdmlkZXMgYSByZWN0YW5ndWxhciBjb250YWluZXIgZm9yIHZpc3VhbGx5IHNlcGVyYXRpbmdcbiAqIGNvbnRlbnQgYnkgY29udGV4dC5cbiAqL1xuY2xhc3MgV2VsbCBleHRlbmRzIF9fMS5BYnN0cmFjdExheW91dCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB3ZWxsXzEuV2VsbFZpZXcodGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiByb290IHZhbHVlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgICAgIGlkOiB0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuaWQsXG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAnd2VsbCcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLldFTEwsIF9fMS5MQVlPVVQsIHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5jbGFzc05hbWUgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLmNsYXNzTmFtZSA6ICcnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuV2VsbCA9IFdlbGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2VsbFZpZXcgPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBXZWxsVmlldyB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ2RpdicsIHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuY29udGVudC5pZCB9LCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmNvbnRlbnQuY2xhc3NOYW1lIH0sIFtcbiAgICAgICAgICAgICAgICAuLi4oX19jb250ZXh0LmNoaWxkcmVuKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLldlbGxWaWV3ID0gV2VsbFZpZXc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWxsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EcmF3ZXIgPSBleHBvcnRzLkRSQVdFUl9DT05URU5UID0gZXhwb3J0cy5EUkFXRVIgPSB2b2lkIDA7XG5jb25zdCBoaWRkZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZW50L3N0YXRlL2hpZGRlblwiKTtcbmNvbnN0IGxheW91dF8xID0gcmVxdWlyZShcIi4uLy4uL2xheW91dFwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xuY29uc3QgZHJhd2VyXzEgPSByZXF1aXJlKFwiLi93bWwvZHJhd2VyXCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5EUkFXRVIgPSAnd3ctZHJhd2VyJztcbmV4cG9ydHMuRFJBV0VSX0NPTlRFTlQgPSAnd3ctZHJhd2VyX19jb250ZW50Jztcbi8qKlxuICogRHJhd2VyIHByb3ZpZGVzIGEgd2lkZ2V0IGZvciBkaXNwbGF5aW5nIG5hdmlnYXRpb24gYW5kIG90aGVyIHNpZGViYXIgY29udGVudC5cbiAqXG4gKiBJdCdzIGFwaSBhbGxvd3MgZm9yIHRvZ2dsaW5nIGJldHdlZW4gaGlkZGVuIGFuZCBzaG93biBzdGF0ZXMgYXMgd2VsbCBhc1xuICogcXVlcnlpbmcgdGhlIGN1cnJlbnQgc3RhdGUuXG4gKlxuICogVGhpcyB3aWRnZXQncyBzdHlsZSBpbnRlbnRpb25hbGx5IGdpdmVzIGl0IGEgaGlnaCB6LWluZGV4IHNvIHRoYXQgaXQgYXBwZWFyc1xuICogaW4tZnJvbnQgIG9mIG90aGVyIGNvbnRlbnQuIEFkanVzdCB0aGUgcmVzcGVjdGl2ZSBzdHlsZSB2YXJpYWJsZXMgdG8gY2hhbmdlLlxuICovXG5jbGFzcyBEcmF3ZXIgZXh0ZW5kcyBsYXlvdXRfMS5BYnN0cmFjdExheW91dCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyBkcmF3ZXJfMS5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgICAgICBpZDogdGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmlkLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogKDAsIHV0aWxfMS5jb25jYXQpKGV4cG9ydHMuRFJBV0VSLCAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmhpZGRlbikgP1xuICAgICAgICAgICAgICAgICAgICBoaWRkZW5fMS5ISURERU4gOiAnJyksXG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAncm9vdCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ2NvbnRlbnQnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGV4cG9ydHMuRFJBV0VSX0NPTlRFTlQsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuY29udGVudCkgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLmNvbnRlbnQgOiB0aGlzLmNoaWxkcmVuXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlzSGlkZGVuKCkge1xuICAgICAgICByZXR1cm4gKDAsIGhpZGRlbl8xLmlzSGlkZGVuKSh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLnJvb3Qud21sLmlkKTtcbiAgICB9XG4gICAgaGlkZSgpIHtcbiAgICAgICAgKDAsIGhpZGRlbl8xLmhpZGUpKHRoaXMudmlldywgdGhpcy52YWx1ZXMucm9vdC53bWwuaWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2hvdygpIHtcbiAgICAgICAgKDAsIGhpZGRlbl8xLnNob3cpKHRoaXMudmlldywgdGhpcy52YWx1ZXMucm9vdC53bWwuaWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9nZ2xlKCkge1xuICAgICAgICAoMCwgaGlkZGVuXzEudG9nZ2xlKSh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLnJvb3Qud21sLmlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5EcmF3ZXIgPSBEcmF3ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWFpbiA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9faWYgPSAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpID0+IChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0ID8gX19hbHQoKSA6IFtdO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9ySW4gPSAobGlzdCwgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2Zvck9mID0gKG8sIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHRleHQgPSBfX2RvY3VtZW50LnRleHQ7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHVuc2FmZSA9IF9fZG9jdW1lbnQudW5zYWZlO1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCBpc1NldCA9ICh2YWx1ZSkgPT4gdmFsdWUgIT0gbnVsbDtcbmNsYXNzIE1haW4ge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdkaXYnLCB7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLnJvb3Qud21sLmlkIH0sICdpZCc6IF9fY29udGV4dC52YWx1ZXMucm9vdC5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5yb290LmNsYXNzTmFtZSB9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2RpdicsIHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuY29udGVudC53bWwuaWQgfSwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jb250ZW50LmNsYXNzTmFtZSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIC4uLihfX2NvbnRleHQudmFsdWVzLmNvbnRlbnQudmFsdWUpXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRyYXdlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWVudUhlYWRlciA9IGV4cG9ydHMuTUVOVV9IRUFERVIgPSB2b2lkIDA7XG5jb25zdCB3bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbmNvbnN0IGRvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbmNvbnN0IHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2hlYWRlclwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuLyoqXG4gKiBNRU5VX0hFQURFUlxuICovXG5leHBvcnRzLk1FTlVfSEVBREVSID0gJ3d3LW1lbnUtaGVhZGVyJztcbi8qKlxuICogTWVudUhlYWRlciBjYW4gYmUgdXNlZCB0byBkaXNwbGF5IG5vbi1jbGlja2FibGUgaGVhZGluZyB0ZXh0IGluIGEgbmF2IG1lbnUuXG4gKi9cbmNsYXNzIE1lbnVIZWFkZXIgZXh0ZW5kcyB3bWwuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgc3Bhbjoge1xuICAgICAgICAgICAgICAgIGlkOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmlkKSA/IHRoaXMuYXR0cnMuaWQgOiAnJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLk1FTlVfSEVBREVSLCAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmNsYXNzTmFtZSkgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLmNsYXNzTmFtZSA6ICcnKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRleHQ6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMudGV4dCkgP1xuICAgICAgICAgICAgICAgIFtkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLmF0dHJzLnRleHQpXSA6IHRoaXMuY2hpbGRyZW5cbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLk1lbnVIZWFkZXIgPSBNZW51SGVhZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1haW4gPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnc3BhbicsIHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5zcGFuLmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLnNwYW4uY2xhc3NOYW1lIH0sIFtcbiAgICAgICAgICAgICAgICAuLi4oX19jb250ZXh0LnZhbHVlcy50ZXh0KVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVhZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JdGVtID0gZXhwb3J0cy5EaXZpZGVyID0gZXhwb3J0cy5JdGVtQ2xpY2tlZEV2ZW50ID0gZXhwb3J0cy5ESVZJREVSID0gZXhwb3J0cy5JVEVNID0gdm9pZCAwO1xuY29uc3Qgd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG5jb25zdCBkb2N1bWVudCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG5jb25zdCB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9pdGVtXCIpO1xuY29uc3QgYWN0aXZlXzEgPSByZXF1aXJlKFwiLi4vLi4vY29udGVudC9zdGF0ZS9hY3RpdmVcIik7XG5jb25zdCBhY3RpdmVfMiA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZW50L3N0YXRlL2FjdGl2ZVwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5JVEVNID0gJ3d3LW1lbnUtaXRlbSc7XG5leHBvcnRzLkRJVklERVIgPSAnd3ctbWVudS1kaXZpZGVyJztcbi8qKlxuICogSXRlbUNsaWNrZWRFdmVudCBpcyBmaXJlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiBhbiBpdGVtIGluXG4gKiBhIG5hdiBsaXN0LlxuICovXG5jbGFzcyBJdGVtQ2xpY2tlZEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgfVxufVxuZXhwb3J0cy5JdGVtQ2xpY2tlZEV2ZW50ID0gSXRlbUNsaWNrZWRFdmVudDtcbi8qKlxuICogRGl2aWRlciBpcyB1c2VkIHRvIGFkZCBhIGhvcml6b250YWwgbGluZSBpbiBwbGFjZSBvZiBhbiBpdGVtIHRvIHNpZ2luaWZ5IGFcbiAqIG5ldyBzZWN0aW9uLlxuICovXG5jbGFzcyBEaXZpZGVyIGV4dGVuZHMgd21sLkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5EaXZpZGVyVmlldyh0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IGV4cG9ydHMuRElWSURFUlxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuRGl2aWRlciA9IERpdmlkZXI7XG4vKipcbiAqIEl0ZW0gd3JhcHMgY29udGVudCBpbiBhIG5hdmlnYXRpb24gbGlzdC5cbiAqXG4gKiBJdGVtcyBzaG91bGQgbm90IGhhdmUgYW55IHNpYmxpbmdzIHRoYXQgYXJlIG5vdCBvdGhlciBJdGVtcy5cbiAqL1xuY2xhc3MgSXRlbSBleHRlbmRzIHdtbC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbih0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAncm9vdCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlkOiAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmlkKSA/IHRoaXMuYXR0cnMuaWQgOiAnJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLklURU0sICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMuYWN0aXZlKSA/IGFjdGl2ZV8yLkFDVElWRSA6ICcnKSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcjogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy50ZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5hdHRycy50ZXh0KV07XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGFjdGl2YXRlKCkge1xuICAgICAgICAoMCwgYWN0aXZlXzEuYWN0aXZhdGUpKHRoaXMudmlldywgdGhpcy52YWx1ZXMucm9vdC53bWwuaWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVhY3RpdmF0ZSgpIHtcbiAgICAgICAgKDAsIGFjdGl2ZV8xLmRlYWN0aXZhdGUpKHRoaXMudmlldywgdGhpcy52YWx1ZXMucm9vdC53bWwuaWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLkl0ZW0gPSBJdGVtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1haW4gPSBleHBvcnRzLkRpdmlkZXJWaWV3ID0gdm9pZCAwO1xuY29uc3QgX19kb2N1bWVudCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbmNvbnN0IG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG47XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgRGl2aWRlclZpZXcge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdsaScsIHsgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jbGFzc05hbWUgfSwgW10pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5EaXZpZGVyVmlldyA9IERpdmlkZXJWaWV3O1xuO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ2xpJywgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5yb290LndtbC5pZCB9LCAnaWQnOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMucm9vdC5jbGFzc05hbWUgfSwgW1xuICAgICAgICAgICAgICAgIC4uLihfX2NvbnRleHQudmFsdWVzLnJvb3QuY29udGVudC5yZW5kZXIoKSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWl0ZW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1lbnUgPSBleHBvcnRzLkhlYWRlckl0ZW0gPSBleHBvcnRzLkNPTlRFTlRfTU9ERSA9IGV4cG9ydHMuTkFWX01PREUgPSBleHBvcnRzLk1FTlVfSEVBREVSX0lURU0gPSBleHBvcnRzLk1FTlUgPSB2b2lkIDA7XG5jb25zdCBoaWRkZW4gPSByZXF1aXJlKFwiLi4vLi4vY29udGVudC9zdGF0ZS9oaWRkZW5cIik7XG5jb25zdCBoZWFkZXJWaWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9oZWFkZXJcIik7XG5jb25zdCB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xuY29uc3QgZG9tXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG5jb25zdCBvcmllbnRhdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRlbnQvb3JpZW50YXRpb25cIik7XG5jb25zdCBfXzEgPSByZXF1aXJlKFwiLi4vLi4vXCIpO1xuY29uc3QgbWVudV8xID0gcmVxdWlyZShcIi4vd21sL21lbnVcIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLk1FTlUgPSAnd3ctbWVudSc7XG5leHBvcnRzLk1FTlVfSEVBREVSX0lURU0gPSAnd3ctbWVudV9faGVhZGVyLWl0ZW0nO1xuLy8vY2xhc3NOYW1lczplbmRcbmV4cG9ydHMuTkFWX01PREUgPSAnbmF2JztcbmV4cG9ydHMuQ09OVEVOVF9NT0RFID0gJ2NvbnRlbnQnO1xuLyoqXG4gKiBIZWFkZXJJdGVtXG4gKi9cbmNsYXNzIEhlYWRlckl0ZW0gZXh0ZW5kcyB3bWxfMS5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgaGVhZGVyVmlld3MuTWFpbih0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAoMCwgdXRpbF8xLmNvbmNhdCkoZXhwb3J0cy5NRU5VX0hFQURFUl9JVEVNLCAoMCwgX18xLmdldENsYXNzTmFtZSkodGhpcy5hdHRycykpLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICh0aGlzLmF0dHJzICYmIHRoaXMuYXR0cnMudGV4dCkgP1xuICAgICAgICAgICAgICAgICAgICBbKDAsIGRvbV8xLnRleHQpKHRoaXMuYXR0cnMudGV4dCldIDogdGhpcy5jaGlsZHJlblxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuSGVhZGVySXRlbSA9IEhlYWRlckl0ZW07XG4vKipcbiAqIE1lbnUgcHJvdmlkZXMgYSBET00gY29udGFpbmVyIGZvciByZW5kZXJpbmdcbiAqIGEgZHJvcGRvd24gc3R5bGUgbWVudS5cbiAqL1xuY2xhc3MgTWVudSBleHRlbmRzIHdtbF8xLkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyBtZW51XzEuTWFpbih0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAncm9vdCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlkOiAoMCwgX18xLmdldElkKSh0aGlzLmF0dHJzKSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICgwLCB1dGlsXzEuY29uY2F0KShleHBvcnRzLk1FTlUsICgwLCBfXzEuZ2V0Q2xhc3NOYW1lKSh0aGlzLmF0dHJzKSwgKHRoaXMuYXR0cnMgJiYgdGhpcy5hdHRycy5oaWRkZW4pID8gaGlkZGVuLkhJRERFTiA6ICcnLCAodGhpcy5hdHRycyAmJiB0aGlzLmF0dHJzLmJsb2NrKSA/IG9yaWVudGF0aW9uXzEuQkxPQ0sgOiAnJylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZW51OiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdtZW51J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnRlbnQ6ICgpID0+IHRoaXMuY2hpbGRyZW5cbiAgICAgICAgfTtcbiAgICB9XG4gICAgaXNIaWRkZW4oKSB7XG4gICAgICAgIHJldHVybiBoaWRkZW4uaXNIaWRkZW4odGhpcy52aWV3LCB0aGlzLnZhbHVlcy5yb290LndtbC5pZCk7XG4gICAgfVxuICAgIGhpZGUoKSB7XG4gICAgICAgIGhpZGRlbi5oaWRlKHRoaXMudmlldywgdGhpcy52YWx1ZXMucm9vdC53bWwuaWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2hvdygpIHtcbiAgICAgICAgaGlkZGVuLnNob3codGhpcy52aWV3LCB0aGlzLnZhbHVlcy5yb290LndtbC5pZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b2dnbGUoKSB7XG4gICAgICAgIGhpZGRlbi50b2dnbGUodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5yb290LndtbC5pZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRDb250ZW50KGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy52YWx1ZXMuY29udGVudCA9ICgpID0+IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMudmlldy5pbnZhbGlkYXRlKCk7XG4gICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLk1lbnUgPSBNZW51O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1haW4gPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnbGknLCB7ICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMucm9vdC5jbGFzc05hbWUgfSwgW1xuICAgICAgICAgICAgICAgIC4uLihfX2NvbnRleHQudmFsdWVzLnJvb3QuY29udGVudClcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlYWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWFpbiA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9faWYgPSAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpID0+IChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0ID8gX19hbHQoKSA6IFtdO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9ySW4gPSAobGlzdCwgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2Zvck9mID0gKG8sIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHRleHQgPSBfX2RvY3VtZW50LnRleHQ7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHVuc2FmZSA9IF9fZG9jdW1lbnQudW5zYWZlO1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCBpc1NldCA9ICh2YWx1ZSkgPT4gdmFsdWUgIT0gbnVsbDtcbmNsYXNzIE1haW4ge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCd1bCcsIHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMucm9vdC53bWwuaWQgfSwgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5yb290LmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NOYW1lIH0sIFtcbiAgICAgICAgICAgICAgICAuLi4oX19jb250ZXh0LnZhbHVlcy5jb250ZW50KCkpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZW51LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5OYXZNZW51ID0gZXhwb3J0cy5OQVZfTUVOVSA9IGV4cG9ydHMuTGluayA9IGV4cG9ydHMuSXRlbSA9IHZvaWQgMDtcbmNvbnN0IHdtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xuY29uc3QgcmVjb3JkXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvcmVjb3JkXCIpO1xuY29uc3QgdHlwZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL3R5cGVcIik7XG5jb25zdCBvcmllbnRhdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRlbnQvb3JpZW50YXRpb25cIik7XG5jb25zdCB2aWV3XzEgPSByZXF1aXJlKFwiLi92aWV3XCIpO1xudmFyIGl0ZW1fMSA9IHJlcXVpcmUoXCIuLi9pdGVtXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSXRlbVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaXRlbV8xLkl0ZW07IH0gfSk7XG52YXIgbGlua18xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRlbnQvbGlua1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxpbmtcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpbmtfMS5MaW5rOyB9IH0pO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5OQVZfTUVOVSA9ICd3dy1uYXYtbWVudSc7XG4vKipcbiAqIE5hdk1lbnUgZ3JvdXBzIG9uZSBvciBtb3JlIG5hdmlnYXRpb25hbCBpdGVtcyB0b2dldGhlciB0byBmb3JtIGEgbWVudS5cbiAqXG4gKiBJdGVtcyBtYXkgYmUgZGVjbGFyZWQgZGlyZWN0bHkgYXMgY2hpbGQgZWxlbWVudHMgb2YgdGhpcyB3aWRnZXRzIG9yIHNwZWNpZmllZFxuICogdmlhIGF0dHJpYnV0ZXMgZm9yIGR5bmFtaWMgY3JlYXRpb24uXG4gKi9cbmNsYXNzIE5hdk1lbnUgZXh0ZW5kcyB3bWwuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdfMS5OYXZNZW51Vmlldyh0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBpZDogdGhpcy5hdHRycy5pZCxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogdXRpbC5jb25jYXQoZXhwb3J0cy5OQVZfTUVOVSwgdGhpcy5hdHRycy5jbGFzc05hbWUsIHRoaXMuYXR0cnMudmVydGljYWwgPyBvcmllbnRhdGlvbl8xLlZFUlRJQ0FMIDogJycpLFxuICAgICAgICAgICAgaXRlbXM6IGV4cGFuZCh0aGlzLmF0dHJzLml0ZW1zKVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuTmF2TWVudSA9IE5hdk1lbnU7XG5jb25zdCBleHBhbmQgPSAoc3BlYyA9IFtdKSA9PiB7XG4gICAgbGV0IGxpc3QgPSBBcnJheS5pc0FycmF5KHNwZWMpID8gc3BlYyA6IFtzcGVjXTtcbiAgICByZXR1cm4gbGlzdC5yZWR1Y2UoKGV4cGFuZGVkLCBpdGVtKSA9PiB7XG4gICAgICAgIGlmICgoMCwgdHlwZV8xLmlzU3RyaW5nKShpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIFsuLi5leHBhbmRlZCwgeyB0eXBlOiAnaGVhZGVyJywgdGV4dDogaXRlbSB9XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoMCwgdHlwZV8xLmlzT2JqZWN0KShpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAuLi5leHBhbmRlZCxcbiAgICAgICAgICAgICAgICAuLi4oMCwgcmVjb3JkXzEubWFwVG8pKGl0ZW0sICh2YWwsIHRleHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCB0eXBlXzEuaXNGdW5jdGlvbikodmFsKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICdsaW5rJywgbmFtZTogdGV4dCwgdGV4dCwgb25DbGljazogdmFsIH07XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCgwLCB0eXBlXzEuaXNPYmplY3QpKHZhbCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHJlY29yZF8xLm1lcmdlKSh7IHR5cGU6ICdsaW5rJywgbmFtZTogdGV4dCwgdGV4dCB9LCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsaW5rJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogU3RyaW5nKHZhbClcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIFsuLi5leHBhbmRlZCwgeyB0eXBlOiAnbWVudScsIGl0ZW1zOiBpdGVtIH1dO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGV4cGFuZGVkO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5OYXZNZW51VmlldyA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuY29uc3QgaXRlbV8xID0gcmVxdWlyZShcIi4uL2l0ZW1cIik7XG47XG5jb25zdCBoZWFkZXJfMSA9IHJlcXVpcmUoXCIuLi9oZWFkZXJcIik7XG47XG5jb25zdCBsaW5rXzEgPSByZXF1aXJlKFwiLi4vLi4vY29udGVudC9saW5rXCIpO1xuO1xuY29uc3QgXzEgPSByZXF1aXJlKFwiLlwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBOYXZNZW51VmlldyB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ3VsJywgeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmNsYXNzTmFtZSB9LCBbXG4gICAgICAgICAgICAgICAgLi4uX19mb3JJbihfX2NvbnRleHQudmFsdWVzLml0ZW1zLCAoaXRlbSwgXyQkaSwgXyQkYWxsKSA9PiAoW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBpdGVtXzEuSXRlbSh7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uKCgoaXRlbVsndHlwZSddID09PSAnaGVhZGVyJykpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKCkgPT4gKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgaGVhZGVyXzEuTWVudUhlYWRlcihpdGVtLCBbXSksIGl0ZW0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSkpKCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoKSA9PiAoWy4uLigoKGl0ZW1bJ3R5cGUnXSA9PT0gJ2xpbmsnKSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCgpID0+IChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgbGlua18xLkxpbmsoaXRlbSwgW10pLCBpdGVtKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSkpKCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCgpID0+IChbLi4uKCgoaXRlbVsndHlwZSddID09PSAnbWVudScpKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoKSA9PiAoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgXzEuTmF2TWVudShpdGVtLCBbXSksIGl0ZW0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pKSgpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCgpID0+IChbXSkpKCkpXSkpKCkpXSkpKCkpXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgICAgICBdKSwgKCkgPT4gKFtdKSksXG4gICAgICAgICAgICAgICAgLi4uKF9fY29udGV4dC5jaGlsZHJlbilcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5OYXZNZW51VmlldyA9IE5hdk1lbnVWaWV3O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlldy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogVGhpcyBtb2R1bGUgcHJvdmlkZXMgdXRpbGl0eSBmdW5jdGlvbnMgYW5kIGNvbnN0YW50cyB1c2VkXG4gKiB0aHJvdWdoIG91dCB0aGUgd21sLXdpZGdldHMgbW9kdWxlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlYm91bmNlID0gZXhwb3J0cy5yZXBsYWNlQ29udGVudCA9IGV4cG9ydHMubm9vcCA9IGV4cG9ydHMuY29uY2F0ID0gZXhwb3J0cy5jb21iaW5lID0gZXhwb3J0cy53YXJuTWlzc2luZyA9IGV4cG9ydHMuZ2V0QnlJZCA9IHZvaWQgMDtcbi8qKlxuICogZ2V0QnlJZCByZXRyZWl2ZXMgYW4gV01MRWxlbWVudCBmcm9tIGEgdmlldyBieSBpdHMgaWQuXG4gKlxuICogSWYgdGhlIFdNTEVsZW1lbnQgaXMgbm90IGZvdW5kIGEgd2FybmluZyBpcyBsb2dnZWQgdG8gY29uc29sZS5cbiAqL1xuY29uc3QgZ2V0QnlJZCA9ICh2aWV3LCBpZCkgPT4ge1xuICAgIGxldCBtID0gdmlldy5maW5kQnlJZChpZCk7XG4gICAgaWYgKG0uaXNOb3RoaW5nKCkpIHtcbiAgICAgICAgKDAsIGV4cG9ydHMud2Fybk1pc3NpbmcpKHZpZXcsIGlkKTtcbiAgICB9XG4gICAgcmV0dXJuIG07XG59O1xuZXhwb3J0cy5nZXRCeUlkID0gZ2V0QnlJZDtcbi8qKlxuICogd2FybiB2aWEgY29uc29sZSB0aGF0IGFuIGVsZW1lbnQgaXMgbWlzc2luZy5cbiAqL1xuY29uc3Qgd2Fybk1pc3NpbmcgPSAodmlldywgaWQpID0+IHtcbiAgICBjb25zb2xlLndhcm4oJ1RoZSB2aWV3ICcsIHZpZXcsIGAgZG9lcyBub3QgaGF2ZSBhbiBpZCBcIiR7aWR9XCIhYCk7XG59O1xuZXhwb3J0cy53YXJuTWlzc2luZyA9IHdhcm5NaXNzaW5nO1xuLyoqXG4gKiBjb21iaW5lIHRoZSBtZW1iZXJzIG9mIGFuIGFycmF5IGludG8gb25lIHN0cmluZy5cbiAqL1xuY29uc3QgY29tYmluZSA9IChzdHIsIGpvaW5lciA9ICcgJykgPT4gc3RyLmZpbHRlcihzID0+ICgocyAhPSBudWxsKSB8fCBzICE9ICcnKSkuam9pbihqb2luZXIpO1xuZXhwb3J0cy5jb21iaW5lID0gY29tYmluZTtcbi8qKlxuICogY29uY2F0IGpvaW5zIHZhcmlvdXMgc3RyaW5ncyB0b2dldGhlciB0byBmb3JtIGFuIGh0bWwgY2xhc3MgYXR0cmlidXRlIHZhbHVlLlxuICpcbiAqIFJlbW92ZXMgZW1wdHkgc3RyaW5ncywgbnVsbCBhbmQgdW5kZWZpbmVkIHZhbHVlcy5cbiAqL1xuY29uc3QgY29uY2F0ID0gKC4uLnN0cikgPT4gc3RyLmZpbHRlcihzID0+ICgocyA9PSBudWxsKSB8fCAocyA9PSAnJykpID8gZmFsc2UgOiB0cnVlKVxuICAgIC5tYXAocyA9PiBzLnRyaW0oKSkuam9pbignICcpO1xuZXhwb3J0cy5jb25jYXQgPSBjb25jYXQ7XG4vKipcbiAqIG5vb3BcbiAqL1xuY29uc3Qgbm9vcCA9ICgpID0+IHsgfTtcbmV4cG9ydHMubm9vcCA9IG5vb3A7XG4vKipcbiAqIHJlcGxhY2VDb250ZW50XG4gKi9cbmNvbnN0IHJlcGxhY2VDb250ZW50ID0gKHIsIG5vZGUpID0+IHtcbiAgICB3aGlsZSAobm9kZS5sYXN0Q2hpbGQpXG4gICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5sYXN0Q2hpbGQpO1xuICAgIG5vZGUuYXBwZW5kQ2hpbGQoci5yZW5kZXIoKSk7XG59O1xuZXhwb3J0cy5yZXBsYWNlQ29udGVudCA9IHJlcGxhY2VDb250ZW50O1xuLyoqXG4gKiBkZWJvdW5jZSBhIGZ1bmN0aW9uIHNvIHRoYXQgaXQgaXMgb25seSBjYWxsZWQgb25jZSBhZnRlclxuICogYSBwZXJpb2Qgb2YgdGltZS5cbiAqL1xuY29uc3QgZGVib3VuY2UgPSAoZiwgZGVsYXkpID0+IHtcbiAgICBsZXQgdGltZXIgPSAtMTtcbiAgICByZXR1cm4gZGVsYXkgPT09IDAgPyBmIDogKGEpID0+IHtcbiAgICAgICAgaWYgKHRpbWVyID09PSAtMSkge1xuICAgICAgICAgICAgdGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiBmKGEpLCBkZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgdGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiBmKGEpLCBkZWxheSk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbmV4cG9ydHMuZGVib3VuY2UgPSBkZWJvdW5jZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRocm90dGxlID0gZXhwb3J0cy5kZWJvdW5jZSA9IGV4cG9ydHMudGljayA9IHZvaWQgMDtcbi8qKlxuICogdGljayBydW5zIGEgZnVuY3Rpb24gaW4gdGhlIFwibmV4dCB0aWNrXCIgdXNpbmcgcHJvY2Vzcy5uZXh0VGljayBpbiBub2RlXG4gKiBvciBzZXRUaW1lb3V0KGYsIDApIGVsc2V3aGVyZS5cbiAqL1xuY29uc3QgdGljayA9IChmKSA9PiAodHlwZW9mIHdpbmRvdyA9PSAndW5kZWZpbmVkJykgP1xuICAgIHNldFRpbWVvdXQoZiwgMCkgOlxuICAgIHByb2Nlc3MubmV4dFRpY2soZik7XG5leHBvcnRzLnRpY2sgPSB0aWNrO1xuLyoqXG4gKiBkZWJvdW5jZSBkZWxheXMgdGhlIGFwcGxpY2F0aW9uIG9mIGEgZnVuY3Rpb24gdW50aWwgdGhlIHNwZWNpZmllZCB0aW1lXG4gKiBoYXMgcGFzc2VkLlxuICpcbiAqIElmIG11bHRpcGxlIGF0dGVtcHRzIHRvIGFwcGx5IHRoZSBmdW5jdGlvbiBoYXZlIG9jY3VyZWQsIHRoZW4gZWFjaCBhdHRlbXB0XG4gKiB3aWxsIHJlc3RhcnQgdGhlIGRlbGF5IHByb2Nlc3MuIFRoZSBmdW5jdGlvbiB3aWxsIG9ubHkgZXZlciBiZSBhcHBsaWVkIG9uY2VcbiAqIGFmdGVyIHRoZSBkZWxheSwgdXNpbmcgdGhlIHZhbHVlIG9mIHRoZSBmaW5hbCBhdHRlbXB0IGZvciBhcHBsaWNhdGlvbi5cbiAqL1xuY29uc3QgZGVib3VuY2UgPSAoZiwgZGVsYXkpID0+IHtcbiAgICBsZXQgaWQgPSAtMTtcbiAgICByZXR1cm4gKGEpID0+IHtcbiAgICAgICAgaWYgKGlkID09PSAtMSkge1xuICAgICAgICAgICAgaWQgPSBzZXRUaW1lb3V0KCgpID0+IGYoYSksIGRlbGF5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICAgICAgICBpZCA9IHNldFRpbWVvdXQoKCkgPT4gZihhKSwgZGVsYXkpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5leHBvcnRzLmRlYm91bmNlID0gZGVib3VuY2U7XG4vKipcbiAqIHRocm90dGxlIGxpbWl0cyB0aGUgYXBwbGljYXRpb24gb2YgYSBmdW5jdGlvbiB0byBvY2N1ciBvbmx5IG9uZSB3aXRoaW4gdGhlXG4gKiBzcGVjaWZpZWQgZHVyYXRpb24uXG4gKlxuICogVGhlIGZpcnN0IGFwcGxpY2F0aW9uIHdpbGwgZXhlY3V0ZSBpbW1lZGlhdGVseSBzdWJzZXF1ZW50IGFwcGxpY2F0aW9uc1xuICogd2lsbCBiZSBpZ25vcmVkIHVudGlsIHRoZSBkdXJhdGlvbiBoYXMgcGFzc2VkLlxuICovXG5jb25zdCB0aHJvdHRsZSA9IChmLCBkdXJhdGlvbikgPT4ge1xuICAgIGxldCB3YWl0ID0gZmFsc2U7XG4gICAgcmV0dXJuIChhKSA9PiB7XG4gICAgICAgIGlmICh3YWl0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZihhKTtcbiAgICAgICAgICAgIHdhaXQgPSB0cnVlO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB3YWl0ID0gZmFsc2UsIGR1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuZXhwb3J0cy50aHJvdHRsZSA9IHRocm90dGxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGltZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZpbmQgPSBleHBvcnRzLmNvbXBhY3QgPSBleHBvcnRzLmZsYXR0ZW4gPSBleHBvcnRzLmNvbWJpbmUgPSBleHBvcnRzLm1ha2UgPSBleHBvcnRzLnJlbW92ZUF0ID0gZXhwb3J0cy5yZW1vdmUgPSBleHBvcnRzLmRlZHVwZSA9IGV4cG9ydHMuZGlzdHJpYnV0ZSA9IGV4cG9ydHMuZ3JvdXAgPSBleHBvcnRzLnBhcnRpdGlvbiA9IGV4cG9ydHMuY29uY2F0ID0gZXhwb3J0cy5mbGF0TWFwID0gZXhwb3J0cy5tYXAgPSBleHBvcnRzLmNvbnRhaW5zID0gZXhwb3J0cy5lbXB0eSA9IGV4cG9ydHMudGFpbCA9IGV4cG9ydHMuaGVhZCA9IHZvaWQgMDtcbi8qKlxuICogVGhlIGFycmF5IG1vZHVsZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zXG4gKiBmb3Igd29ya2luZyB3aXRoIEpTIGFycmF5cy5cbiAqL1xuY29uc3QgcmVjb3JkXzEgPSByZXF1aXJlKFwiLi4vcmVjb3JkXCIpO1xuY29uc3QgbWF0aF8xID0gcmVxdWlyZShcIi4uLy4uL21hdGhcIik7XG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIi4uL21heWJlXCIpO1xuLyoqXG4gKiBoZWFkIHJldHVybnMgdGhlIGl0ZW0gYXQgaW5kZXggMCBvZiBhbiBhcnJheVxuICovXG5jb25zdCBoZWFkID0gKGxpc3QpID0+IGxpc3RbMF07XG5leHBvcnRzLmhlYWQgPSBoZWFkO1xuLyoqXG4gKiB0YWlsIHJldHVybnMgdGhlIGxhc3QgaXRlbSBpbiBhbiBhcnJheVxuICovXG5jb25zdCB0YWlsID0gKGxpc3QpID0+IGxpc3RbbGlzdC5sZW5ndGggLSAxXTtcbmV4cG9ydHMudGFpbCA9IHRhaWw7XG4vKipcbiAqIGVtcHR5IGluZGljYXRlcyB3aGV0aGVyIGFuIGFycmF5IGlzIGVtcHR5IG9yIG5vdC5cbiAqL1xuY29uc3QgZW1wdHkgPSAobGlzdCkgPT4gKGxpc3QubGVuZ3RoID09PSAwKTtcbmV4cG9ydHMuZW1wdHkgPSBlbXB0eTtcbi8qKlxuICogY29udGFpbnMgaW5kaWNhdGVzIHdoZXRoZXIgYW4gZWxlbWVudCBleGlzdHMgaW4gYW4gYXJyYXkuXG4gKi9cbmNvbnN0IGNvbnRhaW5zID0gKGxpc3QsIGEpID0+IChsaXN0LmluZGV4T2YoYSkgPiAtMSk7XG5leHBvcnRzLmNvbnRhaW5zID0gY29udGFpbnM7XG4vKipcbiAqIG1hcCBpcyBhIGN1cnJpZWQgdmVyc2lvbiBvZiB0aGUgQXJyYXkjbWFwIG1ldGhvZC5cbiAqL1xuY29uc3QgbWFwID0gKGxpc3QpID0+IChmKSA9PiBsaXN0Lm1hcChmKTtcbmV4cG9ydHMubWFwID0gbWFwO1xuLyoqXG4gKiBmbGF0TWFwIGFsbG93cyBhIGZ1bmN0aW9uIHRvIHByb2R1Y2UgYSBjb21iaW5lZCBzZXQgb2YgYXJyYXlzIGZyb20gYSBtYXBcbiAqIG9wZXJhdGlvbiBvdmVyIGVhY2ggbWVtYmVyIG9mIGEgbGlzdC5cbiAqL1xuY29uc3QgZmxhdE1hcCA9IChsaXN0LCBmKSA9PiBsaXN0LnJlZHVjZSgocCwgYywgaSkgPT4gcC5jb25jYXQoZihjLCBpLCBsaXN0KSksIFtdKTtcbmV4cG9ydHMuZmxhdE1hcCA9IGZsYXRNYXA7XG4vKipcbiAqIGNvbmNhdCBjb25jYXRlbmF0ZXMgZWxlbWVudHMgdG8gdGhlIGVuZCBvZiBhbiBhcnJheSB3aXRob3V0IGZsYXR0ZW5pbmdcbiAqIGlmIGFueSBvZiB0aGUgZWxlbWVudHMgYXJlIGFuIGFycmF5LlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gYWxzbyBpZ25vcmVzIG51bGwgYW5kIHVuZGVmaW5lZC5cbiAqL1xuY29uc3QgY29uY2F0ID0gKGxpc3QsIC4uLml0ZW1zKSA9PiBbLi4ubGlzdCwgLi4uaXRlbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbSAhPSBudWxsKV07XG5leHBvcnRzLmNvbmNhdCA9IGNvbmNhdDtcbi8qKlxuICogcGFydGl0aW9uIGFuIGFycmF5IGludG8gdHdvIHVzaW5nIGEgcGFydGl0aW9uaW5nIGZ1bmN0aW9uLlxuICpcbiAqIFRoZSBmaXJzdCBhcnJheSBjb250YWlucyB2YWx1ZXMgdGhhdCByZXR1cm4gdHJ1ZSBhbmQgdGhlIHNlY29uZCBmYWxzZS5cbiAqL1xuY29uc3QgcGFydGl0aW9uID0gKGxpc3QsIGYpID0+ICgwLCBleHBvcnRzLmVtcHR5KShsaXN0KSA/XG4gICAgW1tdLCBbXV0gOlxuICAgIGxpc3QucmVkdWNlKChbeWVzLCBub10sIGMsIGkpID0+IChmKGMsIGksIGxpc3QpID9cbiAgICAgICAgWygwLCBleHBvcnRzLmNvbmNhdCkoeWVzLCBjKSwgbm9dIDpcbiAgICAgICAgW3llcywgKDAsIGV4cG9ydHMuY29uY2F0KShubywgYyldKSwgW1tdLCBbXV0pO1xuZXhwb3J0cy5wYXJ0aXRpb24gPSBwYXJ0aXRpb247XG4vKipcbiAqIGdyb3VwIHRoZSBlbGVtZW50cyBvZiBhbiBhcnJheSBpbnRvIGEgUmVjb3JkIHdoZXJlIGVhY2ggcHJvcGVydHlcbiAqIGlzIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFzc2lnbmVkIHRvIGl0J3MgcHJvcGVydHkgbmFtZS5cbiAqL1xuY29uc3QgZ3JvdXAgPSAobGlzdCwgZikgPT4gbGlzdC5yZWR1Y2UoKHAsIGMsIGkpID0+IHtcbiAgICBsZXQgZyA9IGYoYywgaSwgbGlzdCk7XG4gICAgcmV0dXJuICgwLCByZWNvcmRfMS5tZXJnZSkocCwge1xuICAgICAgICBbZ106IEFycmF5LmlzQXJyYXkocFtnXSkgP1xuICAgICAgICAgICAgKDAsIGV4cG9ydHMuY29uY2F0KShwW2ddLCBjKSA6IFtjXVxuICAgIH0pO1xufSwge30pO1xuZXhwb3J0cy5ncm91cCA9IGdyb3VwO1xuLyoqXG4gKiBkaXN0cmlidXRlIGJyZWFrcyBhbiBhcnJheSBpbnRvIGFuIGFycmF5IG9mIGVxdWFsbHkgKGFwcHJveGltYXRlKSBzaXplZFxuICogc21hbGxlciBhcnJheXMuXG4gKi9cbmNvbnN0IGRpc3RyaWJ1dGUgPSAobGlzdCwgc2l6ZSkgPT4ge1xuICAgIGxldCByID0gbGlzdC5yZWR1Y2UoKHAsIGMsIGkpID0+ICgwLCBtYXRoXzEuaXNNdWx0aXBsZU9mKShzaXplLCBpICsgMSkgP1xuICAgICAgICBbKDAsIGV4cG9ydHMuY29uY2F0KShwWzBdLCAoMCwgZXhwb3J0cy5jb25jYXQpKHBbMV0sIGMpKSwgW11dIDpcbiAgICAgICAgW3BbMF0sICgwLCBleHBvcnRzLmNvbmNhdCkocFsxXSwgYyldLCBbW10sIFtdXSk7XG4gICAgcmV0dXJuIChyWzFdLmxlbmd0aCA9PT0gMCkgPyByWzBdIDogKDAsIGV4cG9ydHMuY29uY2F0KShyWzBdLCByWzFdKTtcbn07XG5leHBvcnRzLmRpc3RyaWJ1dGUgPSBkaXN0cmlidXRlO1xuLyoqXG4gKiBkZWR1cGUgYW4gYXJyYXkgYnkgZmlsdGVyaW5nIG91dCBlbGVtZW50c1xuICogdGhhdCBhcHBlYXIgdHdpY2UuXG4gKi9cbmNvbnN0IGRlZHVwZSA9IChsaXN0KSA9PiBsaXN0LmZpbHRlcigoZSwgaSwgbCkgPT4gbC5pbmRleE9mKGUpID09PSBpKTtcbmV4cG9ydHMuZGVkdXBlID0gZGVkdXBlO1xuLyoqXG4gKiByZW1vdmUgYW4gZWxlbWVudCBmcm9tIGFuIGFycmF5IHJldHVybmluZyBhIG5ldyBjb3B5IHdpdGggdGhlIGVsZW1lbnRcbiAqIHJlbW92ZWQuXG4gKi9cbmNvbnN0IHJlbW92ZSA9IChsaXN0LCB0YXJnZXQpID0+IHtcbiAgICBsZXQgaWR4ID0gbGlzdC5pbmRleE9mKHRhcmdldCk7XG4gICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGxpc3Quc2xpY2UoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBhID0gbGlzdC5zbGljZSgpO1xuICAgICAgICBhLnNwbGljZShpZHgsIDEpO1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG59O1xuZXhwb3J0cy5yZW1vdmUgPSByZW1vdmU7XG4vKipcbiAqIHJlbW92ZUF0IHJlbW92ZXMgYW4gZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4IHJldHVybmluZyBhIGNvcHlcbiAqIG9mIHRoZSBvcmlnaW5hbCBhcnJheSB3aXRoIHRoZSBlbGVtZW50IHJlbW92ZWQuXG4gKi9cbmNvbnN0IHJlbW92ZUF0ID0gKGxpc3QsIGlkeCkgPT4ge1xuICAgIGlmICgobGlzdC5sZW5ndGggPiBpZHgpICYmIChpZHggPiAtMSkpIHtcbiAgICAgICAgbGV0IGEgPSBsaXN0LnNsaWNlKCk7XG4gICAgICAgIGEuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGxpc3Quc2xpY2UoKTtcbiAgICB9XG59O1xuZXhwb3J0cy5yZW1vdmVBdCA9IHJlbW92ZUF0O1xuLyoqXG4gKiBtYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIG9mIGEgZ2l2ZW4gc2l6ZSB1c2luZyBhIGZ1bmN0aW9uIHRvIHByb3ZpZGVcbiAqIGVhY2ggZWxlbWVudC5cbiAqXG4gKiBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgdGhlIGluZGV4IG51bWJlciBmb3IgZWFjaCBzdGVwLlxuICovXG5jb25zdCBtYWtlID0gKHNpemUsIGYpID0+IHtcbiAgICBsZXQgYSA9IG5ldyBBcnJheShzaXplKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKylcbiAgICAgICAgYVtpXSA9IGYoaSk7XG4gICAgcmV0dXJuIGE7XG59O1xuZXhwb3J0cy5tYWtlID0gbWFrZTtcbi8qKlxuICogY29tYmluZSBhIGxpc3Qgb2Ygb2YgbGlzdHMgaW50byBvbmUgbGlzdC5cbiAqL1xuY29uc3QgY29tYmluZSA9IChsaXN0KSA9PiBsaXN0LnJlZHVjZSgocCwgYykgPT4gcC5jb25jYXQoYyksIFtdKTtcbmV4cG9ydHMuY29tYmluZSA9IGNvbWJpbmU7XG4vKipcbiAqIGZsYXR0ZW4gYSBsaXN0IG9mIGl0ZW1zIHRoYXQgbWF5IGJlIG11bHRpLWRpbWVuc2lvbmFsLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gbWF5IG5vdCBiZSBzdGFjayBzYWZlLlxuICovXG5jb25zdCBmbGF0dGVuID0gKGxpc3QpID0+IGxpc3QucmVkdWNlKChwLCBjKSA9PiBwLmNvbmNhdChBcnJheS5pc0FycmF5KGMpID8gKDAsIGV4cG9ydHMuZmxhdHRlbikoYykgOiBjKSwgW10pO1xuZXhwb3J0cy5mbGF0dGVuID0gZmxhdHRlbjtcbi8qKlxuICogY29tcGFjdCByZW1vdmVzIGFueSBvY2N1cmVuY2VzIG9mIG51bGwgb3IgdW5kZWZpbmVkIGluIHRoZSBsaXN0LlxuICovXG5jb25zdCBjb21wYWN0ID0gKGxpc3QpID0+IGxpc3QuZmlsdGVyKHYgPT4gKHYgIT0gbnVsbCkpO1xuZXhwb3J0cy5jb21wYWN0ID0gY29tcGFjdDtcbi8qKlxuICogZmluZCBzZWFyY2hlcyBhbiBhcnJheSBmb3IgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBwYXNzZXMgdGhlIHRlc3QgaW1wbGVtZW50ZWRcbiAqIGluIHRoZSBwcm92aWRlZCBbW0ZpbmRGdW5kXV0uXG4gKi9cbmNvbnN0IGZpbmQgPSAobGlzdCwgY2IpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmIChjYihsaXN0W2ldKSlcbiAgICAgICAgICAgIHJldHVybiAoMCwgbWF5YmVfMS5qdXN0KShsaXN0W2ldKTtcbiAgICByZXR1cm4gKDAsIG1heWJlXzEubm90aGluZykoKTtcbn07XG5leHBvcnRzLmZpbmQgPSBmaW5kO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIFVzZWZ1bCBmdW5jdGlvbnMgZm9yIHNvcnRpbmcgZGF0YSBpbiBhbiBhcnJheS5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGFyZSBleHBlY3RlZCB0byBiZSBwYXNzZWQgdG8gQXJyYXkjc29ydC5cbiAqIERlZmF1bHRzIHRvIGFzY2VuZGluZyBvcmRlciB1bmxlc3Mgc3BlY2lmaWVkIG90aGVyd2lzZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5uYXR1cmFsID0gZXhwb3J0cy5udW1iZXIgPSBleHBvcnRzLnN0cmluZyA9IGV4cG9ydHMuZGF0ZSA9IHZvaWQgMDtcbi8qKlxuICogZGF0ZSBzb3J0cyB0d28gc3RyaW5ncyByZXByZXNlbnRpbmcgZGF0ZXMuXG4gKlxuICogVGhlIGRhdGVzIGFyZSBwYXNzZWQgdG8gdGhlIGRhdGUgY29uc3RydWN0b3IuXG4gKi9cbmNvbnN0IGRhdGUgPSAoYSwgYikgPT4ge1xuICAgIGxldCBuYSA9IG5ldyBEYXRlKGEpLmdldFRpbWUoKTtcbiAgICBsZXQgbmIgPSBuZXcgRGF0ZShiKS5nZXRUaW1lKCk7XG4gICAgcmV0dXJuIG5hID4gbmIgPyAtMSA6IG5hIDwgbmIgPyAxIDogMDtcbn07XG5leHBvcnRzLmRhdGUgPSBkYXRlO1xuLyoqXG4gKiBzdHJpbmcgc29ydHMgdHdvIHN0cmluZ3MgYnkgZmlyc3QgbG93ZXIgY2FzaW5nIHRoZW0uXG4gKi9cbmNvbnN0IHN0cmluZyA9IChhLCBiKSA9PiB7XG4gICAgbGV0IGxhID0gU3RyaW5nKGEpLnJlcGxhY2UoL1xccysvLCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICBsZXQgbGIgPSBTdHJpbmcoYikucmVwbGFjZSgvXFxzKy8sICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiAobGEgPiBsYikgPyAtMSA6IChsYSA8IGxiKSA/IDEgOiAwO1xufTtcbmV4cG9ydHMuc3RyaW5nID0gc3RyaW5nO1xuLyoqXG4gKiBudW1iZXIgc29ydFxuICovXG5jb25zdCBudW1iZXIgPSAoYSwgYikgPT4ge1xuICAgIGxldCBuYSA9IHBhcnNlRmxvYXQoYSk7XG4gICAgbGV0IG5iID0gcGFyc2VGbG9hdChiKTtcbiAgICBuYSA9IChpc05hTihhKSkgPyAtSW5maW5pdHkgOiBhO1xuICAgIG5iID0gKGlzTmFOKGIpKSA/IC1JbmZpbml0eSA6IGI7XG4gICAgcmV0dXJuIChuYSA+IG5iKSA/IC0xIDogKG5hIDwgbmIpID8gMSA6IDA7XG59O1xuZXhwb3J0cy5udW1iZXIgPSBudW1iZXI7XG4vKipcbiAqIG5hdHVyYWwgc29ydCBpbXBlbG1lbnRhdGlvbi5cbiAqL1xuY29uc3QgbmF0dXJhbCA9IChhID0gJycsIGIgPSAnJykgPT4ge1xuICAgIHZhciByZUEgPSAvW15hLXpBLVpdL2c7XG4gICAgdmFyIHJlTiA9IC9bXjAtOV0vZztcbiAgICB2YXIgYUludCA9IHBhcnNlSW50KGEsIDEwKTtcbiAgICB2YXIgYkludCA9IHBhcnNlSW50KGIsIDEwKTtcbiAgICBpZiAoaXNOYU4oYUludCkgJiYgaXNOYU4oYkludCkpIHtcbiAgICAgICAgdmFyIGFBID0gU3RyaW5nKGEpLnJlcGxhY2UocmVBLCAnJyk7XG4gICAgICAgIHZhciBiQSA9IFN0cmluZyhiKS5yZXBsYWNlKHJlQSwgJycpO1xuICAgICAgICBpZiAoYUEgPT09IGJBKSB7XG4gICAgICAgICAgICB2YXIgYU4gPSBwYXJzZUludChTdHJpbmcoYSkucmVwbGFjZShyZU4sICcnKSwgMTApO1xuICAgICAgICAgICAgdmFyIGJOID0gcGFyc2VJbnQoU3RyaW5nKGIpLnJlcGxhY2UocmVOLCAnJyksIDEwKTtcbiAgICAgICAgICAgIHJldHVybiBhTiA9PT0gYk4gPyAwIDogYU4gPiBiTiA/IC0xIDogMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhQSA+IGJBID8gLTEgOiAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzTmFOKGFJbnQpKSB7IC8vQSBpcyBub3QgYW4gSW50XG4gICAgICAgIHJldHVybiAtMTsgLy90byBtYWtlIGFscGhhbnVtZXJpYyBzb3J0IGZpcnN0IHJldHVybiAtMSBoZXJlXG4gICAgfVxuICAgIGVsc2UgaWYgKGlzTmFOKGJJbnQpKSB7IC8vQiBpcyBub3QgYW4gSW50XG4gICAgICAgIHJldHVybiAxOyAvL3RvIG1ha2UgYWxwaGFudW1lcmljIHNvcnQgZmlyc3QgcmV0dXJuIDEgaGVyZVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFJbnQgPiBiSW50ID8gLTEgOiAxO1xuICAgIH1cbn07XG5leHBvcnRzLm5hdHVyYWwgPSBuYXR1cmFsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c29ydC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZnJvbU5hTiA9IGV4cG9ydHMuZnJvbU51bWJlciA9IGV4cG9ydHMuZnJvbUJvb2xlYW4gPSBleHBvcnRzLmZyb21TdHJpbmcgPSBleHBvcnRzLmZyb21PYmplY3QgPSBleHBvcnRzLmZyb21BcnJheSA9IGV4cG9ydHMuZnJvbU51bGxhYmxlID0gZXhwb3J0cy5qdXN0ID0gZXhwb3J0cy5ub3RoaW5nID0gZXhwb3J0cy5vZiA9IGV4cG9ydHMuSnVzdCA9IGV4cG9ydHMuTm90aGluZyA9IHZvaWQgMDtcbi8qKlxuICogTm90aGluZyByZXByZXNlbnRzIHRoZSBhYnNlbmNlIG9mIGEgdXNhYmxlIHZhbHVlLlxuICovXG5jbGFzcyBOb3RoaW5nIHtcbiAgICAvKipcbiAgICAgKiBtYXAgc2ltcGx5IHJldHVybnMgYSBOb3RoaW5nPEE+XG4gICAgICovXG4gICAgbWFwKF8pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb3RoaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGFwIGFsbG93cyBmb3IgYSBmdW5jdGlvbiB3cmFwcGVkIGluIGEgSnVzdCB0byBhcHBseVxuICAgICAqIHRvIHZhbHVlIHByZXNlbnQgaW4gdGhpcyBKdXN0LlxuICAgICAqL1xuICAgIGFwKF8pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb3RoaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIG9mIHdyYXBzIGEgdmFsdWUgaW4gYSBKdXN0LlxuICAgICAqL1xuICAgIG9mKGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBKdXN0KGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjaGFpbiBzaW1wbHkgcmV0dXJucyBhIE5vdGhpbmc8QT4uXG4gICAgICovXG4gICAgY2hhaW4oXykge1xuICAgICAgICByZXR1cm4gbmV3IE5vdGhpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYWx0IHdpbGwgcHJlZmVyIHdoYXRldmVyIE1heWJlIGluc3RhbmNlIHByb3ZpZGVkLlxuICAgICAqL1xuICAgIGFsdChhKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBlbXB0eSBwcm92aWRlcyBhIGRlZmF1bHQgTWF5YmUuXG4gICAgICogTWF5YmUuZW1wdHkoKSA9IG5ldyBOb3RoaW5nKClcbiAgICAgKi9cbiAgICBlbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb3RoaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGV4dGVuZCByZXR1cm5zIGEgTm90aGluZzxBPi5cbiAgICAgKi9cbiAgICBleHRlbmQoXykge1xuICAgICAgICByZXR1cm4gbmV3IE5vdGhpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZXEgcmV0dXJucyB0cnVlIGlmIGNvbXBhcmVkIHRvIGFub3RoZXIgTm90aGluZyBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBlcShtKSB7XG4gICAgICAgIHJldHVybiBtIGluc3RhbmNlb2YgTm90aGluZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogb3JKdXN0IGNvbnZlcnRzIGEgTm90aGluZzxBPiB0byBhIEp1c3RcbiAgICAgKiB1c2luZyB0aGUgdmFsdWUgZnJvbSB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgb3JKdXN0KGYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBKdXN0KGYoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIG9yRWxzZSBhbGxvd3MgYW4gYWx0ZXJuYXRpdmUgTWF5YmUgdmFsdWVcbiAgICAgKiB0byBiZSBwcm92aWRlZCBzaW5jZSB0aGlzIG9uZSBpcyBOb3RoaW5nPEE+LlxuICAgICAqL1xuICAgIG9yRWxzZShmKSB7XG4gICAgICAgIHJldHVybiBmKCk7XG4gICAgfVxuICAgIGlzTm90aGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlzSnVzdCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXQgdGhyb3dzIGFuIGVycm9yIGJlY2F1c2UgdGhlcmVcbiAgICAgKiBpcyBub3RoaW5nIGhlcmUgdG8gZ2V0LlxuICAgICAqL1xuICAgIGdldCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGdldCBhIHZhbHVlIGZyb20gTm90aGluZyEnKTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGhpbmcgPSBOb3RoaW5nO1xuLyoqXG4gKiBKdXN0IHJlcHJlc2VudHMgdGhlIHByZXNlbmNlIG9mIGEgdXNhYmxlIHZhbHVlLlxuICovXG5jbGFzcyBKdXN0IHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIG1hcCBvdmVyIHRoZSB2YWx1ZSBwcmVzZW50IGluIHRoZSBKdXN0LlxuICAgICAqL1xuICAgIG1hcChmKSB7XG4gICAgICAgIHJldHVybiBuZXcgSnVzdChmKHRoaXMudmFsdWUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYXAgYWxsb3dzIGZvciBhIGZ1bmN0aW9uIHdyYXBwZWQgaW4gYSBKdXN0IHRvIGFwcGx5XG4gICAgICogdG8gdmFsdWUgcHJlc2VudCBpbiB0aGlzIEp1c3QuXG4gICAgICovXG4gICAgYXAobWIpIHtcbiAgICAgICAgcmV0dXJuIG1iLm1hcChmID0+IGYodGhpcy52YWx1ZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBvZiB3cmFwcyBhIHZhbHVlIGluIGEgSnVzdC5cbiAgICAgKi9cbiAgICBvZihhKSB7XG4gICAgICAgIHJldHVybiBuZXcgSnVzdChhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogY2hhaW4gYWxsb3dzIHRoZSBzZXF1ZW5jaW5nIG9mIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBhIE1heWJlLlxuICAgICAqL1xuICAgIGNoYWluKGYpIHtcbiAgICAgICAgcmV0dXJuIGYodGhpcy52YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGFsdCB3aWxsIHByZWZlciB0aGUgZmlyc3QgSnVzdCBlbmNvdW50ZXJlZCAodGhpcykuXG4gICAgICovXG4gICAgYWx0KF8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGVtcHR5IHByb3ZpZGVzIGEgZGVmYXVsdCBNYXliZS5cbiAgICAgKiBNYXliZS5lbXB0eSgpID0gbmV3IE5vdGhpbmcoKVxuICAgICAqL1xuICAgIGVtcHR5KCkge1xuICAgICAgICByZXR1cm4gbmV3IE5vdGhpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZXh0ZW5kIGFsbG93cyBzZXF1ZW5jaW5nIG9mIE1heWJlcyB3aXRoXG4gICAgICogZnVuY3Rpb25zIHRoYXQgdW53cmFwIGludG8gbm9uIE1heWJlIHR5cGVzLlxuICAgICAqL1xuICAgIGV4dGVuZChmKSB7XG4gICAgICAgIHJldHVybiBuZXcgSnVzdChmKHRoaXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZXEgdGVzdHMgdGhlIHZhbHVlIG9mIHR3byBKdXN0cy5cbiAgICAgKi9cbiAgICBlcShtKSB7XG4gICAgICAgIHJldHVybiAoKG0gaW5zdGFuY2VvZiBKdXN0KSAmJiAobS52YWx1ZSA9PT0gdGhpcy52YWx1ZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBvckp1c3QgcmV0dXJucyB0aGlzIEp1c3QuXG4gICAgICovXG4gICAgb3JKdXN0KF8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIG9yRWxzZSByZXR1cm5zIHRoaXMgSnVzdFxuICAgICAqL1xuICAgIG9yRWxzZShfKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpc05vdGhpbmcoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaXNKdXN0KCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSB2YWx1ZSBvZiB0aGlzIEp1c3QuXG4gICAgICovXG4gICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG59XG5leHBvcnRzLkp1c3QgPSBKdXN0O1xuLyoqXG4gKiBvZlxuICovXG5jb25zdCBvZiA9IChhKSA9PiBuZXcgSnVzdChhKTtcbmV4cG9ydHMub2YgPSBvZjtcbi8qKlxuICogbm90aGluZyBjb252ZW5pZW5jZSBjb25zdHJ1Y3RvclxuICovXG5jb25zdCBub3RoaW5nID0gKCkgPT4gbmV3IE5vdGhpbmcoKTtcbmV4cG9ydHMubm90aGluZyA9IG5vdGhpbmc7XG4vKipcbiAqIGp1c3QgY29udmVuaWVuY2UgY29uc3RydWN0b3JcbiAqL1xuY29uc3QganVzdCA9IChhKSA9PiBuZXcgSnVzdChhKTtcbmV4cG9ydHMuanVzdCA9IGp1c3Q7XG4vKipcbiAqIGZyb21OdWxsYWJsZSBjb25zdHJ1Y3RzIGEgTWF5YmUgZnJvbSBhIHZhbHVlIHRoYXQgbWF5IGJlIG51bGwuXG4gKi9cbmNvbnN0IGZyb21OdWxsYWJsZSA9IChhKSA9PiBhID09IG51bGwgP1xuICAgIG5ldyBOb3RoaW5nKCkgOiBuZXcgSnVzdChhKTtcbmV4cG9ydHMuZnJvbU51bGxhYmxlID0gZnJvbU51bGxhYmxlO1xuLyoqXG4gKiBmcm9tQXJyYXkgY2hlY2tzIGFuIGFycmF5IHRvIHNlZSBpZiBpdCdzIGVtcHR5XG4gKlxuICogUmV0dXJucyBbW05vdGhpbmddXSBpZiBpdCBpcywgW1tKdXN0XV0gb3RoZXJ3aXNlLlxuICovXG5jb25zdCBmcm9tQXJyYXkgPSAoYSkgPT4gKGEubGVuZ3RoID09PSAwKSA/IG5ldyBOb3RoaW5nKCkgOiBuZXcgSnVzdChhKTtcbmV4cG9ydHMuZnJvbUFycmF5ID0gZnJvbUFycmF5O1xuLyoqXG4gKiBmcm9tT2JqZWN0IHVzZXMgT2JqZWN0LmtleXMgdG8gdHVybiBzZWUgaWYgYW4gb2JqZWN0XG4gKiBoYXMgYW55IG93biBwcm9wZXJ0aWVzLlxuICovXG5jb25zdCBmcm9tT2JqZWN0ID0gKG8pID0+IE9iamVjdC5rZXlzKG8pLmxlbmd0aCA9PT0gMCA/IG5ldyBOb3RoaW5nKCkgOiBuZXcgSnVzdChvKTtcbmV4cG9ydHMuZnJvbU9iamVjdCA9IGZyb21PYmplY3Q7XG4vKipcbiAqIGZyb21TdHJpbmcgY29uc3RydWN0cyBOb3RoaW5nPEE+IGlmIHRoZSBzdHJpbmcgaXMgZW1wdHkgb3IgSnVzdDxBPiBvdGhlcndpc2UuXG4gKi9cbmNvbnN0IGZyb21TdHJpbmcgPSAocykgPT4gKHMgPT09ICcnKSA/IG5ldyBOb3RoaW5nKCkgOiBuZXcgSnVzdChzKTtcbmV4cG9ydHMuZnJvbVN0cmluZyA9IGZyb21TdHJpbmc7XG4vKipcbiAqIGZyb21Cb29sZWFuIGNvbnN0cnVjdHMgTm90aGluZyBpZiBiIGlzIGZhbHNlLCBKdXN0PEE+IG90aGVyd2lzZVxuICovXG5jb25zdCBmcm9tQm9vbGVhbiA9IChiKSA9PiAoYiA9PT0gZmFsc2UpID8gbmV3IE5vdGhpbmcoKSA6IG5ldyBKdXN0KGIpO1xuZXhwb3J0cy5mcm9tQm9vbGVhbiA9IGZyb21Cb29sZWFuO1xuLyoqXG4gKiBmcm9tTnVtYmVyIGNvbnN0cnVjdHMgTm90aGluZyBpZiBuIGlzIDAgSnVzdDxBPiBvdGhlcndpc2UuXG4gKi9cbmNvbnN0IGZyb21OdW1iZXIgPSAobikgPT4gKG4gPT09IDApID8gbmV3IE5vdGhpbmcoKSA6IG5ldyBKdXN0KG4pO1xuZXhwb3J0cy5mcm9tTnVtYmVyID0gZnJvbU51bWJlcjtcbi8qKlxuICogZnJvbU5hTiBjb25zdHJ1Y3RzIE5vdGhpbmcgaWYgYSB2YWx1ZSBpcyBub3QgYSBudW1iZXIgb3JcbiAqIEp1c3Q8QT4gb3RoZXJ3aXNlLlxuICovXG5jb25zdCBmcm9tTmFOID0gKG4pID0+IGlzTmFOKG4pID8gbmV3IE5vdGhpbmcoKSA6IG5ldyBKdXN0KG4pO1xuZXhwb3J0cy5mcm9tTmFOID0gZnJvbU5hTjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1heWJlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5waWNrVmFsdWUgPSBleHBvcnRzLnBpY2tLZXkgPSBleHBvcnRzLm1ha2UgPSBleHBvcnRzLnJjb21wYWN0ID0gZXhwb3J0cy5jb21wYWN0ID0gZXhwb3J0cy5pc0JhZEtleSA9IGV4cG9ydHMuc2V0ID0gZXhwb3J0cy5ldmVyeSA9IGV4cG9ydHMuc29tZSA9IGV4cG9ydHMuZW1wdHkgPSBleHBvcnRzLmNvdW50ID0gZXhwb3J0cy5jbG9uZSA9IGV4cG9ydHMuaGFzS2V5ID0gZXhwb3J0cy52YWx1ZXMgPSBleHBvcnRzLmdyb3VwID0gZXhwb3J0cy5wYXJ0aXRpb24gPSBleHBvcnRzLmV4Y2x1ZGUgPSBleHBvcnRzLnJtZXJnZTUgPSBleHBvcnRzLnJtZXJnZTQgPSBleHBvcnRzLnJtZXJnZTMgPSBleHBvcnRzLnJtZXJnZSA9IGV4cG9ydHMubWVyZ2U1ID0gZXhwb3J0cy5tZXJnZTQgPSBleHBvcnRzLm1lcmdlMyA9IGV4cG9ydHMubWVyZ2UgPSBleHBvcnRzLmZpbHRlciA9IGV4cG9ydHMucmVkdWNlID0gZXhwb3J0cy5mb3JFYWNoID0gZXhwb3J0cy5tYXBUbyA9IGV4cG9ydHMubWFwID0gZXhwb3J0cy5rZXlzID0gZXhwb3J0cy5pc1JlY29yZCA9IGV4cG9ydHMuYXNzaWduID0gZXhwb3J0cy5iYWRLZXlzID0gdm9pZCAwO1xuLyoqXG4gKiBUaGUgcmVjb3JkIG1vZHVsZSBwcm92aWRlcyBmdW5jdGlvbnMgZm9yIHRyZWF0aW5nIEVTIG9iamVjdHMgYXMgcmVjb3Jkcy5cbiAqXG4gKiBTb21lIG9mIHRoZSBmdW5jdGlvbnMgcHJvdmlkZWQgaGVyZSBhcmUgbm90IHR5cGUgc2FmZSBhbmQgbWF5IHJlc3VsdCBpblxuICogcnVudGltZSBlcnJvcnMgaWYgbm90IHVzZWQgY2FyZWZ1bGx5LlxuICovXG5jb25zdCBhcnJheV8xID0gcmVxdWlyZShcIi4uL2FycmF5XCIpO1xuY29uc3QgdHlwZV8xID0gcmVxdWlyZShcIi4uL3R5cGVcIik7XG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIi4uL21heWJlXCIpO1xuLyoqXG4gKiBiYWRLZXlzIGlzIGEgbGlzdCBvZiBrZXlzIHdlIGRvbid0IHdhbnQgdG8gY29weSBhcm91bmQgYmV0d2VlbiBvYmplY3RzLlxuICpcbiAqIE1vc3RseSBkdWUgdG8gcHJvdG90eXBlIHBvbGx1dGlvbiBidXQgd2hvIGtub3dzIHdoYXQgb3RoZXIga2V5cyBtYXkgYmVjb21lXG4gKiBhIHByb2JsZW0gYXMgdGhlIGxhbmd1YWdlIG1hdHVyZXMuXG4gKi9cbmV4cG9ydHMuYmFkS2V5cyA9IFsnX19wcm90b19fJ107XG4vKipcbiAqIGFzc2lnbiBpcyBhbiBPYmplY3QuYXNzaWduIHBvbHlmaWxsLlxuICpcbiAqIEl0IGlzIHVzZWQgaW50ZXJuYWxseSBhbmQgc2hvdWxkIHByb2JhYmx5IG5vdCBiZSB1c2VkIGRpcmVjdGx5IGVsc2V3aGVyZS5cbiAqL1xuZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgLi4uX3ZhckFyZ3MpIHtcbiAgICBsZXQgdG8gPSBPYmplY3QodGFyZ2V0KTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDE7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBsZXQgbmV4dFNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgIGlmIChuZXh0U291cmNlICE9IG51bGwpXG4gICAgICAgICAgICBmb3IgKGxldCBuZXh0S2V5IGluIG5leHRTb3VyY2UpXG4gICAgICAgICAgICAgICAgLy8gQXZvaWQgYnVncyB3aGVuIGhhc093blByb3BlcnR5IGlzIHNoYWRvd2VkXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuZXh0U291cmNlLCBuZXh0S2V5KSlcbiAgICAgICAgICAgICAgICAgICAgKDAsIGV4cG9ydHMuc2V0KSh0bywgbmV4dEtleSwgbmV4dFNvdXJjZVtuZXh0S2V5XSk7XG4gICAgfVxuICAgIHJldHVybiB0bztcbn1cbmV4cG9ydHMuYXNzaWduID0gYXNzaWduO1xuLyoqXG4gKiBpc1JlY29yZCB0ZXN0cyB3aGV0aGVyIGEgdmFsdWUgaXMgYSByZWNvcmQuXG4gKlxuICogVG8gYmUgYSBSZWNvcmQsIGEgdmFsdWUgbXVzdCBiZSBhbiBvYmplY3QgYW5kOlxuICogMS4gbXVzdCBub3QgYmUgbnVsbFxuICogMi4gbXVzdCBub3QgYmUgYW4gQXJyYXlcbiAqIDIuIG11c3Qgbm90IGJlIGFuIGluc3RhbmNlIG9mIERhdGVcbiAqIDMuIG11c3Qgbm90IGJlIGFuIGluc3RhbmNlIG9mIFJlZ0V4cFxuICovXG5jb25zdCBpc1JlY29yZCA9ICh2YWx1ZSkgPT4gKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpICYmXG4gICAgKHZhbHVlICE9IG51bGwpICYmXG4gICAgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkgJiZcbiAgICAoISh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpKSAmJlxuICAgICghKHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSk7XG5leHBvcnRzLmlzUmVjb3JkID0gaXNSZWNvcmQ7XG4vKipcbiAqIGtleXMgaXMgYW4gT2JqZWN0LmtleXMgc2hvcnRjdXQuXG4gKi9cbmNvbnN0IGtleXMgPSAob2JqKSA9PiBPYmplY3Qua2V5cyhvYmopO1xuZXhwb3J0cy5rZXlzID0ga2V5cztcbi8qKlxuICogbWFwIG92ZXIgYSBSZWNvcmQncyBwcm9wZXJ0aWVzIHByb2R1Y2luZyBhIG5ldyByZWNvcmQuXG4gKlxuICogVGhlIG9yZGVyIG9mIGtleXMgcHJvY2Vzc2VkIGlzIG5vdCBndWFyYW50ZWVkLlxuICovXG5jb25zdCBtYXAgPSAocmVjLCBmKSA9PiAoMCwgZXhwb3J0cy5rZXlzKShyZWMpXG4gICAgLnJlZHVjZSgocCwgaykgPT4gKDAsIGV4cG9ydHMubWVyZ2UpKHAsICgwLCBleHBvcnRzLnNldCkoe30sIGssIGYocmVjW2tdLCBrLCByZWMpKSksIHt9KTtcbmV4cG9ydHMubWFwID0gbWFwO1xuLyoqXG4gKiBtYXBUbyBhbiBhcnJheSB0aGUgcHJvcGVydGllcyBvZiB0aGUgcHJvdmlkZWQgUmVjb3JkLlxuICpcbiAqIFRoZSBlbGVtZW50cyBvZiB0aGUgYXJyYXkgYXJlIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIGZ1bmN0aW9uIHByb3ZpZGVkXG4gKiB0byBlYWNoIHByb3BlcnR5LiBUaGUgb3JkZXIgb2YgZWxlbWVudHMgaXMgbm90IGd1YXJhbnRlZWQuXG4gKi9cbmNvbnN0IG1hcFRvID0gKHJlYywgZikgPT4gKDAsIGV4cG9ydHMua2V5cykocmVjKS5tYXAoayA9PiBmKHJlY1trXSwgaywgcmVjKSk7XG5leHBvcnRzLm1hcFRvID0gbWFwVG87XG4vKipcbiAqIGZvckVhY2ggaXMgc2ltaWxhciB0byBtYXAgb25seSB0aGUgcmVzdWx0IG9mIGVhY2ggZnVuY3Rpb24gY2FsbCBpcyBub3Qga2VwdC5cbiAqXG4gKiBUaGUgb3JkZXIgb2Yga2V5cyBwcm9jZXNzZWQgaXMgbm90IGd1YXJhbnRlZWQuXG4gKi9cbmNvbnN0IGZvckVhY2ggPSAocmVjLCBmKSA9PiAoMCwgZXhwb3J0cy5rZXlzKShyZWMpLmZvckVhY2goayA9PiBmKHJlY1trXSwgaywgcmVjKSk7XG5leHBvcnRzLmZvckVhY2ggPSBmb3JFYWNoO1xuLyoqXG4gKiByZWR1Y2UgYSBSZWNvcmQncyBrZXlzIHRvIGEgc2luZ2xlIHZhbHVlLlxuICpcbiAqIFRoZSBpbml0aWFsIHZhbHVlIChhY2N1bSkgbXVzdCBiZSBzdXBwbGllZCB0byBhdm9pZCBlcnJvcnMgd2hlblxuICogdGhlcmUgYXJlIG5vIHByb3BlcnRpZXMgb24gdGhlIFJlY29yZC4gVGhlIG9yZGVyIG9mIGtleXMgcHJvY2Vzc2VkIGlzXG4gKiBub3QgZ3VhcmFudGVlZC5cbiAqL1xuY29uc3QgcmVkdWNlID0gKHJlYywgYWNjdW0sIGYpID0+ICgwLCBleHBvcnRzLmtleXMpKHJlYykucmVkdWNlKChwLCBrKSA9PiBmKHAsIHJlY1trXSwgayksIGFjY3VtKTtcbmV4cG9ydHMucmVkdWNlID0gcmVkdWNlO1xuLyoqXG4gKiBmaWx0ZXIgdGhlIGtleXMgb2YgYSBSZWNvcmQgdXNpbmcgYSBmaWx0ZXIgZnVuY3Rpb24uXG4gKi9cbmNvbnN0IGZpbHRlciA9IChyZWMsIGYpID0+ICgwLCBleHBvcnRzLmtleXMpKHJlYylcbiAgICAucmVkdWNlKChwLCBrKSA9PiBmKHJlY1trXSwgaywgcmVjKSA/XG4gICAgKDAsIGV4cG9ydHMubWVyZ2UpKHAsICgwLCBleHBvcnRzLnNldCkoe30sIGssIHJlY1trXSkpIDogcCwge30pO1xuZXhwb3J0cy5maWx0ZXIgPSBmaWx0ZXI7XG4vKipcbiAqIG1lcmdlIHR3byBvYmplY3RzIChzaGFsbG93KSBpbnRvIG9uZSBuZXcgb2JqZWN0LlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWUncyB0eXBlIGlzIHRoZSBwcm9kdWN0IG9mIHRoZSB0d28gb2JqZWN0cyBwcm92aWRlZC5cbiAqL1xuY29uc3QgbWVyZ2UgPSAobGVmdCwgcmlnaHQpID0+IGFzc2lnbih7fSwgbGVmdCwgcmlnaHQpO1xuZXhwb3J0cy5tZXJnZSA9IG1lcmdlO1xuLyoqXG4gKiBtZXJnZTNcbiAqL1xuY29uc3QgbWVyZ2UzID0gKGEsIGIsIGMpID0+IGFzc2lnbih7fSwgYSwgYiwgYyk7XG5leHBvcnRzLm1lcmdlMyA9IG1lcmdlMztcbi8qKlxuICogbWVyZ2U0XG4gKi9cbmNvbnN0IG1lcmdlNCA9IChhLCBiLCBjLCBkKSA9PiBhc3NpZ24oe30sIGEsIGIsIGMsIGQpO1xuZXhwb3J0cy5tZXJnZTQgPSBtZXJnZTQ7XG4vKipcbiAqIG1lcmdlNVxuICovXG5jb25zdCBtZXJnZTUgPSAoYSwgYiwgYywgZCwgZSkgPT4gYXNzaWduKHt9LCBhLCBiLCBjLCBkLCBlKTtcbmV4cG9ydHMubWVyZ2U1ID0gbWVyZ2U1O1xuLyoqXG4gKiBybWVyZ2UgbWVyZ2VzIDIgcmVjb3JkcyByZWN1cnNpdmVseS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIG1heSB2aW9sYXRlIHR5cGUgc2FmZXR5LlxuICovXG5jb25zdCBybWVyZ2UgPSAobGVmdCwgcmlnaHQpID0+ICgwLCBleHBvcnRzLnJlZHVjZSkocmlnaHQsIGxlZnQsIGRlZXBNZXJnZSk7XG5leHBvcnRzLnJtZXJnZSA9IHJtZXJnZTtcbi8qKlxuICogcm1lcmdlM1xuICovXG5jb25zdCBybWVyZ2UzID0gKHIsIHMsIHQpID0+IFtzLCB0XVxuICAgIC5yZWR1Y2UoKHAsIGMpID0+ICgwLCBleHBvcnRzLnJlZHVjZSkoYywgKHApLCBkZWVwTWVyZ2UpLCByKTtcbmV4cG9ydHMucm1lcmdlMyA9IHJtZXJnZTM7XG4vKipcbiAqIHJtZXJnZTRcbiAqL1xuY29uc3Qgcm1lcmdlNCA9IChyLCBzLCB0LCB1KSA9PiBbcywgdCwgdV1cbiAgICAucmVkdWNlKChwLCBjKSA9PiAoMCwgZXhwb3J0cy5yZWR1Y2UpKGMsIChwKSwgZGVlcE1lcmdlKSwgcik7XG5leHBvcnRzLnJtZXJnZTQgPSBybWVyZ2U0O1xuLyoqXG4gKiBybWVyZ2U1XG4gKi9cbmNvbnN0IHJtZXJnZTUgPSAociwgcywgdCwgdSwgdikgPT4gW3MsIHQsIHUsIHZdXG4gICAgLnJlZHVjZSgocCwgYykgPT4gKDAsIGV4cG9ydHMucmVkdWNlKShjLCAocCksIGRlZXBNZXJnZSksIHIpO1xuZXhwb3J0cy5ybWVyZ2U1ID0gcm1lcmdlNTtcbmNvbnN0IGRlZXBNZXJnZSA9IChwcmUsIGN1cnIsIGtleSkgPT4gKDAsIGV4cG9ydHMuaXNSZWNvcmQpKGN1cnIpID9cbiAgICAoMCwgZXhwb3J0cy5tZXJnZSkocHJlLCAoMCwgZXhwb3J0cy5zZXQpKHt9LCBrZXksICgwLCBleHBvcnRzLmlzUmVjb3JkKShwcmVba2V5XSkgP1xuICAgICAgICAoMCwgZXhwb3J0cy5ybWVyZ2UpKHByZVtrZXldLCBjdXJyKSA6XG4gICAgICAgICgwLCBleHBvcnRzLm1lcmdlKSh7fSwgY3VycikpKSA6XG4gICAgKDAsIGV4cG9ydHMubWVyZ2UpKHByZSwgKDAsIGV4cG9ydHMuc2V0KSh7fSwga2V5LCBjdXJyKSk7XG4vKipcbiAqIGV4Y2x1ZGUgcmVtb3ZlcyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMgZnJvbSBhIFJlY29yZC5cbiAqL1xuY29uc3QgZXhjbHVkZSA9IChyZWMsIGtleXMpID0+IHtcbiAgICBsZXQgbGlzdCA9IEFycmF5LmlzQXJyYXkoa2V5cykgPyBrZXlzIDogW2tleXNdO1xuICAgIHJldHVybiAoMCwgZXhwb3J0cy5yZWR1Y2UpKHJlYywge30sIChwLCBjLCBrKSA9PiBsaXN0LmluZGV4T2YoaykgPiAtMSA/IHAgOiAoMCwgZXhwb3J0cy5tZXJnZSkocCwgKDAsIGV4cG9ydHMuc2V0KSh7fSwgaywgYykpKTtcbn07XG5leHBvcnRzLmV4Y2x1ZGUgPSBleGNsdWRlO1xuLyoqXG4gKiBwYXJ0aXRpb24gYSBSZWNvcmQgaW50byB0d28gc3ViLXJlY29yZHMgdXNpbmcgYSBQYXJ0aXRpb25GdW5jIGZ1bmN0aW9uLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gcHJvZHVjZXMgYW4gYXJyYXkgd2hlcmUgdGhlIGZpcnN0IGVsZW1lbnQgaXMgYSBSZWNvcmRcbiAqIG9mIHZhbHVlcyB0aGF0IHJldHVybiB0cnVlIGFuZCB0aGUgc2Vjb25kLCBmYWxzZS5cbiAqL1xuY29uc3QgcGFydGl0aW9uID0gKHIsIGYpID0+ICgwLCBleHBvcnRzLnJlZHVjZSkociwgW3t9LCB7fV0sIChbeWVzLCBub10sIGMsIGspID0+IGYoYywgaywgcikgP1xuICAgIFsoMCwgZXhwb3J0cy5tZXJnZSkoeWVzLCAoMCwgZXhwb3J0cy5zZXQpKHt9LCBrLCBjKSksIG5vXSA6XG4gICAgW3llcywgKDAsIGV4cG9ydHMubWVyZ2UpKG5vLCAoMCwgZXhwb3J0cy5zZXQpKHt9LCBrLCBjKSldKTtcbmV4cG9ydHMucGFydGl0aW9uID0gcGFydGl0aW9uO1xuLyoqXG4gKiBncm91cCB0aGUgcHJvcGVydGllcyBvZiBhIFJlY29yZCBpbnRvIGFub3RoZXIgUmVjb3JkIHVzaW5nIGEgR3JvdXBGdW5jXG4gKiBmdW5jdGlvbi5cbiAqL1xuY29uc3QgZ3JvdXAgPSAocmVjLCBmKSA9PiAoMCwgZXhwb3J0cy5yZWR1Y2UpKHJlYywge30sIChwcmV2LCBjdXJyLCBrZXkpID0+IHtcbiAgICBsZXQgY2F0ZWdvcnkgPSBmKGN1cnIsIGtleSwgcmVjKTtcbiAgICBsZXQgdmFsdWUgPSAoMCwgZXhwb3J0cy5pc1JlY29yZCkocHJldltjYXRlZ29yeV0pID9cbiAgICAgICAgKDAsIGV4cG9ydHMubWVyZ2UpKHByZXZbY2F0ZWdvcnldLCAoMCwgZXhwb3J0cy5zZXQpKHt9LCBrZXksIGN1cnIpKSA6XG4gICAgICAgICgwLCBleHBvcnRzLnNldCkoe30sIGtleSwgY3Vycik7XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLm1lcmdlKShwcmV2LCAoMCwgZXhwb3J0cy5zZXQpKHt9LCBjYXRlZ29yeSwgdmFsdWUpKTtcbn0pO1xuZXhwb3J0cy5ncm91cCA9IGdyb3VwO1xuLyoqXG4gKiB2YWx1ZXMgcmV0dXJucyBhIHNoYWxsb3cgYXJyYXkgb2YgdGhlIHZhbHVlcyBvZiBhIHJlY29yZC5cbiAqL1xuY29uc3QgdmFsdWVzID0gKHIpID0+ICgwLCBleHBvcnRzLnJlZHVjZSkociwgW10sIChwLCBjKSA9PiAoMCwgYXJyYXlfMS5jb25jYXQpKHAsIGMpKTtcbmV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuLyoqXG4gKiBoYXNLZXkgaW5kaWNhdGVzIHdoZXRoZXIgYSBSZWNvcmQgaGFzIGEgZ2l2ZW4ga2V5LlxuICovXG5jb25zdCBoYXNLZXkgPSAociwga2V5KSA9PiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChyLCBrZXkpO1xuZXhwb3J0cy5oYXNLZXkgPSBoYXNLZXk7XG4vKipcbiAqIGNsb25lIGEgUmVjb3JkLlxuICpcbiAqIEJyZWFrcyByZWZlcmVuY2VzIGFuZCBkZWVwIGNsb25lcyBhcnJheXMuXG4gKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIHVzZWQgb24gUmVjb3JkcyBvciBvYmplY3RzIHRoYXRcbiAqIGFyZSBub3QgY2xhc3MgaW5zdGFuY2VzLiBUaGlzIGZ1bmN0aW9uIG1heSB2aW9sYXRlIHR5cGUgc2FmZXR5LlxuICovXG5jb25zdCBjbG9uZSA9IChyKSA9PiAoMCwgZXhwb3J0cy5yZWR1Y2UpKHIsIHt9LCAocCwgYywgaykgPT4geyAoMCwgZXhwb3J0cy5zZXQpKHAsIGssIF9jbG9uZShjKSk7IHJldHVybiBwOyB9KTtcbmV4cG9ydHMuY2xvbmUgPSBjbG9uZTtcbmNvbnN0IF9jbG9uZSA9IChhKSA9PiB7XG4gICAgaWYgKCgwLCB0eXBlXzEuaXNBcnJheSkoYSkpXG4gICAgICAgIHJldHVybiBhLm1hcChfY2xvbmUpO1xuICAgIGVsc2UgaWYgKCgwLCBleHBvcnRzLmlzUmVjb3JkKShhKSlcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLmNsb25lKShhKTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBhO1xufTtcbi8qKlxuICogY291bnQgaG93IG1hbnkgcHJvcGVydGllcyBleGlzdCBvbiB0aGUgcmVjb3JkLlxuICovXG5jb25zdCBjb3VudCA9IChyKSA9PiAoMCwgZXhwb3J0cy5rZXlzKShyKS5sZW5ndGg7XG5leHBvcnRzLmNvdW50ID0gY291bnQ7XG4vKipcbiAqIGVtcHR5IHRlc3RzIHdoZXRoZXIgdGhlIG9iamVjdCBoYXMgYW55IHByb3BlcnRpZXMgb3Igbm90LlxuICovXG5jb25zdCBlbXB0eSA9IChyKSA9PiAoMCwgZXhwb3J0cy5jb3VudCkocikgPT09IDA7XG5leHBvcnRzLmVtcHR5ID0gZW1wdHk7XG4vKipcbiAqIHNvbWUgdGVzdHMgd2hldGhlciBhdCBsZWFzdCBvbmUgcHJvcGVydHkgb2YgYSBSZWNvcmQgcGFzc2VzIHRoZVxuICogdGVzdCBpbXBsZW1lbnRlZCBieSB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gKi9cbmNvbnN0IHNvbWUgPSAobywgZikgPT4gKDAsIGV4cG9ydHMua2V5cykobykuc29tZShrID0+IGYob1trXSwgaywgbykpO1xuZXhwb3J0cy5zb21lID0gc29tZTtcbi8qKlxuICogZXZlcnkgdGVzdHMgd2hldGhlciBlYWNoIHByb3BlcnR5IG9mIGEgUmVjb3JkIHBhc3NlcyB0aGVcbiAqIHRlc3QgaW1wbGVtZW50ZWQgYnkgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICovXG5jb25zdCBldmVyeSA9IChvLCBmKSA9PiAoMCwgZXhwb3J0cy5rZXlzKShvKS5ldmVyeShrID0+IGYob1trXSwgaywgbykpO1xuZXhwb3J0cy5ldmVyeSA9IGV2ZXJ5O1xuLyoqXG4gKiBzZXQgdGhlIHZhbHVlIG9mIGEga2V5IG9uIGEgUmVjb3JkIGlnbm9yaW5nIHByb2JsZW1hdGljIGtleXMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBleGlzdHMgdG8gYXZvaWQgdW5pbnRlbnRpb25hbGx5IHNldHRpbmcgcHJvYmxlbSBrZXlzIHN1Y2hcbiAqIGFzIF9fcHJvdG9fXyBvbiBhbiBvYmplY3QuXG4gKlxuICogRXZlbiB0aG91Z2ggdGhpcyBmdW5jdGlvbiBtdXRhdGVzIHRoZSBwcm92aWRlZCByZWNvcmQsIGl0IHNob3VsZCBiZSB1c2VkXG4gKiBhcyB0aG91Z2ggaXQgZG9lcyBub3QuXG4gKlxuICogRG9uJ3Q6XG4gKiBzZXQob2JqLCBrZXksIHZhbHVlKTtcbiAqXG4gKiBEbzpcbiAqIG9iaiA9IHNldChvYmosIGtleSwgdmFsdWUpO1xuICovXG5jb25zdCBzZXQgPSAociwgaywgdmFsdWUpID0+IHtcbiAgICBpZiAoISgwLCBleHBvcnRzLmlzQmFkS2V5KShrKSlcbiAgICAgICAgcltrXSA9IHZhbHVlO1xuICAgIHJldHVybiByO1xufTtcbmV4cG9ydHMuc2V0ID0gc2V0O1xuLyoqXG4gKiBpc0JhZEtleSB0ZXN0cyB3aGV0aGVyIGEga2V5IGlzIHByb2JsZW1hdGljIChMaWtlIF9fcHJvdG9fXykuXG4gKi9cbmNvbnN0IGlzQmFkS2V5ID0gKGtleSkgPT4gZXhwb3J0cy5iYWRLZXlzLmluZGV4T2Yoa2V5KSAhPT0gLTE7XG5leHBvcnRzLmlzQmFkS2V5ID0gaXNCYWRLZXk7XG4vKipcbiAqIGNvbXBhY3QgYSBSZWNvcmQgYnkgcmVtb3ZpbmcgYW55IHByb3BlcnRpZXMgdGhhdCA9PSBudWxsLlxuICovXG5jb25zdCBjb21wYWN0ID0gKHJlYykgPT4ge1xuICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGxldCBrZXkgaW4gcmVjKVxuICAgICAgICBpZiAocmVjLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICBpZiAocmVjW2tleV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAoMCwgZXhwb3J0cy5zZXQpKHJlc3VsdCwga2V5LCByZWNba2V5XSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLmNvbXBhY3QgPSBjb21wYWN0O1xuLyoqXG4gKiByY29tcGFjdCByZWN1cnNpdmVseSBjb21wYWN0cyBhIFJlY29yZC5cbiAqL1xuY29uc3QgcmNvbXBhY3QgPSAocmVjKSA9PiAoMCwgZXhwb3J0cy5jb21wYWN0KSgoMCwgZXhwb3J0cy5tYXApKHJlYywgdmFsID0+ICgwLCBleHBvcnRzLmlzUmVjb3JkKSh2YWwpID8gKDAsIGV4cG9ydHMucmNvbXBhY3QpKHZhbCkgOiB2YWwpKTtcbmV4cG9ydHMucmNvbXBhY3QgPSByY29tcGFjdDtcbi8qKlxuICogbWFrZSBjcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGEgUmVjb3JkIG9wdGlvbmFsbHkgdXNpbmcgdGhlIHByb3ZpZGVkXG4gKiB2YWx1ZSBhcyBhbiBpbml0aWFsaXplci5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGludGVuZGVkIHRvIGFzc2lzdCB3aXRoIGN1cmJpbmcgcHJvdG90eXBlIHBvbGx1dGlvbiBieVxuICogY29uZmlndXJpbmcgYSBzZXR0ZXIgZm9yIF9fcHJvdG9fXyB0aGF0IGlnbm9yZXMgY2hhbmdlcy5cbiAqL1xuY29uc3QgbWFrZSA9IChpbml0ID0ge30pID0+IHtcbiAgICBsZXQgcmVjID0ge307XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlYywgJ19fcHJvdG9fXycsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHNldCgpIHsgfVxuICAgIH0pO1xuICAgIGZvciAobGV0IGtleSBpbiBpbml0KVxuICAgICAgICBpZiAoaW5pdC5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmVjW2tleV0gPSBpbml0W2tleV07XG4gICAgcmV0dXJuIHJlYztcbn07XG5leHBvcnRzLm1ha2UgPSBtYWtlO1xuLyoqXG4gKiBwaWNrS2V5IHNlbGVjdHMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBwcm9wZXJ0eSBpbiBhIFJlY29yZCB0aGF0IHBhc3NlcyB0aGVcbiAqIHByb3ZpZGVkIHRlc3QuXG4gKi9cbmNvbnN0IHBpY2tLZXkgPSAocmVjLCB0ZXN0KSA9PiAoMCwgZXhwb3J0cy5yZWR1Y2UpKHJlYywgKDAsIG1heWJlXzEubm90aGluZykoKSwgKHAsIGMsIGspID0+IHAuaXNKdXN0KCkgPyBwIDogdGVzdChjLCBrLCByZWMpID8gKDAsIG1heWJlXzEuanVzdCkoaykgOiBwKTtcbmV4cG9ydHMucGlja0tleSA9IHBpY2tLZXk7XG4vKipcbiAqIHBpY2tWYWx1ZSBzZWxlY3RzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgcHJvcGVydHkgaW4gYSBSZWNvcmQgdGhhdCBwYXNzZXMgdGhlXG4gKiBwcm92aWRlZCB0ZXN0LlxuICovXG5jb25zdCBwaWNrVmFsdWUgPSAocmVjLCB0ZXN0KSA9PiAoMCwgZXhwb3J0cy5yZWR1Y2UpKHJlYywgKDAsIG1heWJlXzEubm90aGluZykoKSwgKHAsIGMsIGspID0+IHAuaXNKdXN0KCkgPyBwIDogdGVzdChjLCBrLCByZWMpID8gKDAsIG1heWJlXzEuanVzdCkoYykgOiBwKTtcbmV4cG9ydHMucGlja1ZhbHVlID0gcGlja1ZhbHVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnByb2plY3QgPSBleHBvcnRzLnVuZmxhdHRlbiA9IGV4cG9ydHMuZmxhdHRlbiA9IGV4cG9ydHMudW5lc2NhcGVSZWNvcmQgPSBleHBvcnRzLmVzY2FwZVJlY29yZCA9IGV4cG9ydHMudW5lc2NhcGUgPSBleHBvcnRzLmVzY2FwZSA9IGV4cG9ydHMuc2V0ID0gZXhwb3J0cy5nZXRTdHJpbmcgPSBleHBvcnRzLmdldERlZmF1bHQgPSBleHBvcnRzLmdldCA9IGV4cG9ydHMudW5zYWZlR2V0ID0gZXhwb3J0cy50b2tlbml6ZSA9IHZvaWQgMDtcbi8qKlxuICogVGhpcyBtb2R1bGUgcHJvdmlkZXMgYSBzeW50YXggYW5kIGFzc29jaWF0ZWQgZnVuY3Rpb25zIGZvclxuICogZ2V0dGluZyBhbmQgc2V0dGluZyB2YWx1ZXMgb24gRVMgb2JqZWN0cyBlYXNpbHkuXG4gKlxuICogR2l2ZW4gYSBwYXRoLCBhIHZhbHVlIGNhbiBlaXRoZXIgYmUgcmV0cmlldmVkIG9yIHNldCBvbiBhbiBvYmplY3QuXG4gKlxuICogVGhlIHBhdGggc3ludGF4IGZvbGxvd3MgdHlwaWNhbCBFUyBkb3Qgbm90YXRpb24sIGJyYWNrZXQgbm90YXRpb24gb3IgYSBtaXh0dXJlXG4gKiBvZiBib3RoLlxuICpcbiAqIE5vdGUgdGhhdCBxdW90ZXMgYXJlIG5vdCB1c2VkIHdoZW4gZGVzY3JpYmluZyBhIHBhdGggdmlhIGJyYWNrZXQgbm90YXRpb24uXG4gKlxuICogSWYgeW91IG5lZWQgdG8gdXNlIGEgZG90IG9yIHNxdWFyZSBicmFja2V0cyBpbiB5b3VyIHBhdGhzLCBwcmVmaXggdGhlbSB3aXRoXG4gKiB0aGUgXCJcXFwiIChiYWNrc2xhc2gpIGNoYXJhY3Rlci5cbiAqL1xuLyoqIGltcG9ydHMgKiovXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIi4uL21heWJlXCIpO1xuY29uc3QgXzEgPSByZXF1aXJlKFwiLi9cIik7XG5jb25zdCBUT0tFTl9ET1QgPSAnLic7XG5jb25zdCBUT0tFTl9CUkFDS0VUX0xFRlQgPSAnWyc7XG5jb25zdCBUT0tFTl9CUkFDS0VUX1JJR0hUID0gJ10nO1xuY29uc3QgVE9LRU5fRVNDQVBFID0gJ1xcXFwnO1xuLyoqXG4gKiB0b2tlbml6ZSBhIHBhdGggaW50byBhIGxpc3Qgb2Ygc2VxdWVudGlhbCBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuY29uc3QgdG9rZW5pemUgPSAoc3RyKSA9PiB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBidWYgPSAnJztcbiAgICBsZXQgY3VyciA9ICcnO1xuICAgIGxldCBuZXh0ID0gJyc7XG4gICAgbGV0IHRva2VucyA9IFtdO1xuICAgIHdoaWxlIChpIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICBjdXJyID0gc3RyW2ldO1xuICAgICAgICBuZXh0ID0gc3RyW2kgKyAxXTtcbiAgICAgICAgaWYgKGN1cnIgPT09IFRPS0VOX0VTQ0FQRSkge1xuICAgICAgICAgICAgLy9lc2NhcGUgc2VxdWVuY2VcbiAgICAgICAgICAgIGJ1ZiA9IGAke2J1Zn0ke25leHR9YDtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJyID09PSBUT0tFTl9ET1QpIHtcbiAgICAgICAgICAgIGlmIChidWYgIT09ICcnKVxuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKGJ1Zik7IC8vcmVjb2duaXplIGEgcGF0aCBhbmQgcHVzaCBhIG5ldyB0b2tlblxuICAgICAgICAgICAgYnVmID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGN1cnIgPT09IFRPS0VOX0JSQUNLRVRfTEVGVCkgJiZcbiAgICAgICAgICAgIG5leHQgPT09IFRPS0VOX0JSQUNLRVRfUklHSFQpIHtcbiAgICAgICAgICAgIC8vaW50ZXJjZXB0IGVtcHR5IGJyYWNrZXQgcGF0aHNcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJyID09PSBUT0tFTl9CUkFDS0VUX0xFRlQpIHtcbiAgICAgICAgICAgIGxldCBicmFja2V0QnVmID0gJyc7XG4gICAgICAgICAgICBsZXQgZmlyc3REb3QgPSAtMTtcbiAgICAgICAgICAgIGxldCBmaXJzdERvdEJ1ZiA9ICcnO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAvL2V2ZXJ5dGhpbmcgYmV0d2VlbiBicmFja2V0cyBpcyB0cmVhdGVkIGFzIGEgcGF0aFxuICAgICAgICAgICAgICAgIC8vaWYgbm8gY2xvc2luZyBicmFja2V0IGlzIGZvdW5kLCB3ZSBiYWNrIHRyYWNrIHRvIHRoZSBmaXJzdCBkb3RcbiAgICAgICAgICAgICAgICAvL2lmIHRoZXJlIGlzIG5vIGRvdCB0aGUgd2hvbGUgYnVmZmVyIGlzIHRyZWF0ZWQgYXMgYSBwYXRoXG4gICAgICAgICAgICAgICAgY3VyciA9IHN0cltpXTtcbiAgICAgICAgICAgICAgICBuZXh0ID0gc3RyW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoKGN1cnIgPT09IFRPS0VOX0JSQUNLRVRfUklHSFQpICYmXG4gICAgICAgICAgICAgICAgICAgIChuZXh0ID09PSBUT0tFTl9CUkFDS0VUX1JJR0hUKSkge1xuICAgICAgICAgICAgICAgICAgICAvL2VzY2FwZWQgcmlnaHQgYnJhY2tldFxuICAgICAgICAgICAgICAgICAgICBicmFja2V0QnVmID0gYCR7YnJhY2tldEJ1Zn0ke1RPS0VOX0JSQUNLRVRfUklHSFR9YDtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjdXJyID09PSBUT0tFTl9CUkFDS0VUX1JJR0hUKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vc3VjY2Vzc2Z1bGx5IHRva2VuaXplZCB0aGUgcGF0aFxuICAgICAgICAgICAgICAgICAgICBpZiAoYnVmICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKGJ1Zik7IC8vc2F2ZSB0aGUgcHJldmlvdXMgcGF0aFxuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaChicmFja2V0QnVmKTsgLy9zYXZlIHRoZSBjdXJyZW50IHBhdGhcbiAgICAgICAgICAgICAgICAgICAgYnVmID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjdXJyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9ubyBjbG9zaW5nIGJyYWNrZXQgZm91bmQgYW5kIHdlIHJhbiBvdXQgb2Ygc3RyaW5nIHRvIHNlYXJjaFxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3REb3QgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2JhY2t0cmFjayB0byB0aGUgZmlyc3QgZG90IGVuY291bnRlcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gZmlyc3REb3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3NhdmUgdGhlIHBhdGhzIHNvIGZhclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goYCR7YnVmfSR7VE9LRU5fQlJBQ0tFVF9MRUZUfSR7Zmlyc3REb3RCdWZ9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWYgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9lbHNlIGlmIG5vIGRvdHMgd2VyZSBmb3VuZCB0cmVhdCB0aGUgY3VycmVudCBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCByZXN0IG9mIHRoZSBzdHJpbmcgYXMgcGFydCBvZiBvbmUgcGF0aC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZiA9IGAke2J1Zn0ke1RPS0VOX0JSQUNLRVRfTEVGVH0ke2JyYWNrZXRCdWZ9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoY3VyciA9PT0gVE9LRU5fRE9UKSAmJiAoZmlyc3REb3QgPT09IC0xKSkge1xuICAgICAgICAgICAgICAgICAgICAvL3Rha2Ugbm90ZSBvZiB0aGUgbG9jYXRpb24gYW5kIHRva2VucyBiZXR3ZWVuIFxuICAgICAgICAgICAgICAgICAgICAvL3RoZSBvcGVuaW5nIGJyYWNrZXQgYW5kIGZpcnN0IGRvdC5cbiAgICAgICAgICAgICAgICAgICAgLy9JZiB0aGVyZSBpcyBubyBjbG9zaW5nIGJyYWNrZXQsIHdlIHVzZSB0aGlzIGluZm8gdG9cbiAgICAgICAgICAgICAgICAgICAgLy9sZXggcHJvcGVybHkuXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0RG90ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3REb3RCdWYgPSBicmFja2V0QnVmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmFja2V0QnVmID0gYCR7YnJhY2tldEJ1Zn0ke2N1cnJ9YDtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBidWYgPSBgJHtidWZ9JHtjdXJyfWA7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICBpZiAoKGJ1Zi5sZW5ndGggPiAwKSlcbiAgICAgICAgdG9rZW5zLnB1c2goYnVmKTtcbiAgICByZXR1cm4gdG9rZW5zO1xufTtcbmV4cG9ydHMudG9rZW5pemUgPSB0b2tlbml6ZTtcbi8qKlxuICogdW5zYWZlR2V0IHJldHJpZXZlcyBhIHZhbHVlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aFxuICogb24gYW55IEVTIG9iamVjdC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IGNoZWNrIGlmIGdldHRpbmcgdGhlIHZhbHVlIHN1Y2NlZWRlZCBvciBub3QuXG4gKi9cbmNvbnN0IHVuc2FmZUdldCA9IChwYXRoLCBzcmMpID0+IHtcbiAgICBpZiAoc3JjID09IG51bGwpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgbGV0IHRva3MgPSAoMCwgZXhwb3J0cy50b2tlbml6ZSkocGF0aCk7XG4gICAgbGV0IGhlYWQgPSBzcmNbdG9rcy5zaGlmdCgpXTtcbiAgICByZXR1cm4gdG9rcy5yZWR1Y2UoKHAsIGMpID0+IChwID09IG51bGwpID8gcCA6IHBbY10sIGhlYWQpO1xufTtcbmV4cG9ydHMudW5zYWZlR2V0ID0gdW5zYWZlR2V0O1xuLyoqXG4gKiBnZXQgYSB2YWx1ZSBmcm9tIGEgUmVjb3JkIGdpdmVuIGl0cyBwYXRoIHNhZmVseS5cbiAqL1xuY29uc3QgZ2V0ID0gKHBhdGgsIHNyYykgPT4gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSgoMCwgZXhwb3J0cy51bnNhZmVHZXQpKHBhdGgsIHNyYykpO1xuZXhwb3J0cy5nZXQgPSBnZXQ7XG4vKipcbiAqIGdldERlZmF1bHQgaXMgbGlrZSBnZXQgYnV0IHRha2VzIGEgZGVmYXVsdCB2YWx1ZSB0byByZXR1cm4gaWZcbiAqIHRoZSBwYXRoIGlzIG5vdCBmb3VuZC5cbiAqL1xuY29uc3QgZ2V0RGVmYXVsdCA9IChwYXRoLCBzcmMsIGRlZikgPT4gKDAsIGV4cG9ydHMuZ2V0KShwYXRoLCBzcmMpLm9ySnVzdCgoKSA9PiBkZWYpLmdldCgpO1xuZXhwb3J0cy5nZXREZWZhdWx0ID0gZ2V0RGVmYXVsdDtcbi8qKlxuICogZ2V0U3RyaW5nIGNhc3RzIHRoZSByZXN1bHRpbmcgdmFsdWUgdG8gYSBzdHJpbmcuXG4gKlxuICogQW4gZW1wdHkgc3RyaW5nIGlzIHByb3ZpZGVkIGlmIHRoZSBwYXRoIGlzIG5vdCBmb3VuZC5cbiAqL1xuY29uc3QgZ2V0U3RyaW5nID0gKHBhdGgsIHNyYykgPT4gKDAsIGV4cG9ydHMuZ2V0KShwYXRoLCBzcmMpLm1hcCh2ID0+IFN0cmluZyh2KSkub3JKdXN0KCgpID0+ICcnKS5nZXQoKTtcbmV4cG9ydHMuZ2V0U3RyaW5nID0gZ2V0U3RyaW5nO1xuLyoqXG4gKiBzZXQgc2V0cyBhIHZhbHVlIG9uIGFuIG9iamVjdCBnaXZlbiBhIHBhdGguXG4gKi9cbmNvbnN0IHNldCA9IChwLCB2LCByKSA9PiB7XG4gICAgbGV0IHRva3MgPSAoMCwgZXhwb3J0cy50b2tlbml6ZSkocCk7XG4gICAgcmV0dXJuIF9zZXQociwgdiwgdG9rcyk7XG59O1xuZXhwb3J0cy5zZXQgPSBzZXQ7XG5jb25zdCBfc2V0ID0gKHIsIHZhbHVlLCB0b2tzKSA9PiB7XG4gICAgbGV0IG87XG4gICAgaWYgKHRva3MubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgbyA9ICgwLCBfMS5pc1JlY29yZCkocikgPyAoMCwgXzEuY2xvbmUpKHIpIDoge307XG4gICAgbyA9ICgwLCBfMS5zZXQpKG8sIHRva3NbMF0sIF9zZXQob1t0b2tzWzBdXSwgdmFsdWUsIHRva3Muc2xpY2UoMSkpKTtcbiAgICByZXR1cm4gbztcbn07XG4vKipcbiAqIGVzY2FwZSBhIHBhdGggc28gdGhhdCBvY2N1cmVuY2VzIG9mIGRvdHMgYXJlIG5vdCBpbnRlcnByZXRlZCBhcyBwYXRocy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGVzY2FwZXMgZG90cyBhbmQgZG90cyBvbmx5LlxuICovXG5jb25zdCBlc2NhcGUgPSAocCkgPT4ge1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgYnVmID0gJyc7XG4gICAgbGV0IGN1cnIgPSAnJztcbiAgICB3aGlsZSAoaSA8IHAubGVuZ3RoKSB7XG4gICAgICAgIGN1cnIgPSBwW2ldO1xuICAgICAgICBpZiAoKGN1cnIgPT09IFRPS0VOX0VTQ0FQRSkgfHwgKGN1cnIgPT09IFRPS0VOX0RPVCkpXG4gICAgICAgICAgICBidWYgPSBgJHtidWZ9JHtUT0tFTl9FU0NBUEV9JHtjdXJyfWA7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJ1ZiA9IGAke2J1Zn0ke2N1cnJ9YDtcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gYnVmO1xufTtcbmV4cG9ydHMuZXNjYXBlID0gZXNjYXBlO1xuLyoqXG4gKiB1bmVzY2FwZSBhIHBhdGggdGhhdCBoYXMgYmVlbiBwcmV2aW91c2x5IGVzY2FwZWQuXG4gKi9cbmNvbnN0IHVuZXNjYXBlID0gKHApID0+IHtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGN1cnIgPSAnJztcbiAgICBsZXQgbmV4dCA9ICcnO1xuICAgIGxldCBidWYgPSAnJztcbiAgICB3aGlsZSAoaSA8IHAubGVuZ3RoKSB7XG4gICAgICAgIGN1cnIgPSBwW2ldO1xuICAgICAgICBuZXh0ID0gcFtpICsgMV07XG4gICAgICAgIGlmIChjdXJyID09PSBUT0tFTl9FU0NBUEUpIHtcbiAgICAgICAgICAgIGJ1ZiA9IGAke2J1Zn0ke25leHR9YDtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZiA9IGAke2J1Zn0ke2N1cnJ9YDtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiBidWY7XG59O1xuZXhwb3J0cy51bmVzY2FwZSA9IHVuZXNjYXBlO1xuLyoqXG4gKiBlc2NhcGVSZWNvcmQgZXNjYXBlcyBlYWNoIHByb3BlcnR5IG9mIGEgcmVjb3JkIHJlY3Vyc2l2ZWx5LlxuICovXG5jb25zdCBlc2NhcGVSZWNvcmQgPSAocikgPT4gKDAsIF8xLnJlZHVjZSkociwge30sIChwLCBjLCBrKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBjID09PSAnb2JqZWN0JylcbiAgICAgICAgcCA9ICgwLCBfMS5zZXQpKHAsICgwLCBleHBvcnRzLmVzY2FwZSkoayksICgwLCBleHBvcnRzLmVzY2FwZVJlY29yZCkoYykpO1xuICAgIGVsc2VcbiAgICAgICAgcCA9ICgwLCBfMS5zZXQpKHAsICgwLCBleHBvcnRzLmVzY2FwZSkoayksIGMpO1xuICAgIHJldHVybiBwO1xufSk7XG5leHBvcnRzLmVzY2FwZVJlY29yZCA9IGVzY2FwZVJlY29yZDtcbi8qKlxuICogdW5lc2NhcGVSZWNvcmQgdW5lc2NhcGVzIGVhY2ggcHJvcGVydHkgb2YgYSByZWNvcmQgcmVjdXJzaXZlbHkuXG4gKi9cbmNvbnN0IHVuZXNjYXBlUmVjb3JkID0gKHIpID0+ICgwLCBfMS5yZWR1Y2UpKHIsIHt9LCAocCwgYywgaykgPT4ge1xuICAgIGlmICgoMCwgXzEuaXNSZWNvcmQpKGMpKVxuICAgICAgICBwID0gKDAsIF8xLnNldCkocCwgKDAsIGV4cG9ydHMudW5lc2NhcGUpKGspLCAoMCwgZXhwb3J0cy51bmVzY2FwZVJlY29yZCkoYykpO1xuICAgIGVsc2VcbiAgICAgICAgcCA9ICgwLCBfMS5zZXQpKHAsICgwLCBleHBvcnRzLnVuZXNjYXBlKShrKSwgYyk7XG4gICAgcmV0dXJuIHA7XG59KTtcbmV4cG9ydHMudW5lc2NhcGVSZWNvcmQgPSB1bmVzY2FwZVJlY29yZDtcbi8qKlxuICogZmxhdHRlbiBhbiBvYmplY3QgaW50byBhIFJlY29yZCB3aGVyZSBlYWNoIGtleSBpcyBhIHBhdGggdG8gYSBub24tY29tcGxleFxuICogdmFsdWUgb3IgYXJyYXkuXG4gKlxuICogSWYgYW55IG9mIHRoZSBwYXRocyBjb250YWluIGRvdHMsIHRoZXkgd2lsbCBiZSBlc2NhcGVkLlxuICovXG5jb25zdCBmbGF0dGVuID0gKHIpID0+IChmbGF0SW1wbCgnJykoe30pKHIpKTtcbmV4cG9ydHMuZmxhdHRlbiA9IGZsYXR0ZW47XG5jb25zdCBmbGF0SW1wbCA9IChwZml4KSA9PiAocHJldikgPT4gKHIpID0+ICgwLCBfMS5yZWR1Y2UpKHIsIHByZXYsIChwLCBjLCBrKSA9PiAoMCwgXzEuaXNSZWNvcmQpKGMpID9cbiAgICAoZmxhdEltcGwocHJlZml4KHBmaXgsIGspKShwKShjKSkgOlxuICAgICgwLCBfMS5tZXJnZSkocCwgKDAsIF8xLnNldCkoe30sIHByZWZpeChwZml4LCBrKSwgYykpKTtcbmNvbnN0IHByZWZpeCA9IChwZml4LCBrZXkpID0+IChwZml4ID09PSAnJykgP1xuICAgICgwLCBleHBvcnRzLmVzY2FwZSkoa2V5KSA6IGAke3BmaXh9LiR7KDAsIGV4cG9ydHMuZXNjYXBlKShrZXkpfWA7XG4vKipcbiAqIHVuZmxhdHRlbiBhIGZsYXR0ZW5lZCBSZWNvcmQgc28gdGhhdCBhbnkgbmVzdGVkIHBhdGhzIGFyZSBleHBhbmRlZFxuICogdG8gdGhlaXIgZnVsbCByZXByZXNlbnRhdGlvbi5cbiAqL1xuY29uc3QgdW5mbGF0dGVuID0gKHIpID0+ICgwLCBfMS5yZWR1Y2UpKHIsIHt9LCAocCwgYywgaykgPT4gKDAsIGV4cG9ydHMuc2V0KShrLCBjLCBwKSk7XG5leHBvcnRzLnVuZmxhdHRlbiA9IHVuZmxhdHRlbjtcbi8qKlxuICogcHJvamVjdCBhIFJlY29yZCBhY2NvcmRpbmcgdG8gdGhlIGZpZWxkIHNwZWNpZmljYXRpb24gZ2l2ZW4uXG4gKlxuICogT25seSBwcm9wZXJ0aWVzIHRoYXQgYXBwZWFyIGluIHRoZSBzcGVjIGFuZCBzZXQgdG8gdHJ1ZSB3aWxsIGJlIHJldGFpbmVkLlxuICogVGhpcyBmdW5jdGlvbiBtYXkgdmlvbGF0ZSB0eXBlIHNhZmV0eSBhbmQgbWF5IGxlYXZlIHVuZGVmaW5lZCBob2xlcyBpbiB0aGVcbiAqIHJlc3VsdC5cbiAqL1xuY29uc3QgcHJvamVjdCA9IChzcGVjLCByZWMpID0+ICgwLCBfMS5yZWR1Y2UpKHNwZWMsIHt9LCAocCwgYywgaykgPT4gKGMgPT09IHRydWUpID8gKDAsIGV4cG9ydHMuc2V0KShrLCAoMCwgZXhwb3J0cy51bnNhZmVHZXQpKGssIHJlYyksIHApIDogcCk7XG5leHBvcnRzLnByb2plY3QgPSBwcm9qZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF0aC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudG9TdHJpbmcgPSBleHBvcnRzLnNob3cgPSBleHBvcnRzLnRlc3QgPSBleHBvcnRzLmlzID0gZXhwb3J0cy5pc1ByaW0gPSBleHBvcnRzLmlzRnVuY3Rpb24gPSBleHBvcnRzLmlzQm9vbGVhbiA9IGV4cG9ydHMuaXNOdW1iZXIgPSBleHBvcnRzLmlzU3RyaW5nID0gZXhwb3J0cy5pc0FycmF5ID0gZXhwb3J0cy5pc09iamVjdCA9IGV4cG9ydHMuQW55ID0gdm9pZCAwO1xuY29uc3QgcHJpbXMgPSBbJ3N0cmluZycsICdudW1iZXInLCAnYm9vbGVhbiddO1xuLyoqXG4gKiBBbnkgaXMgYSBjbGFzcyB1c2VkIHRvIHJlcHJlc2VudCB0eXBlc2NyaXB0J3MgXCJhbnlcIiB0eXBlLlxuICovXG5jbGFzcyBBbnkge1xufVxuZXhwb3J0cy5BbnkgPSBBbnk7XG4vKipcbiAqIGlzT2JqZWN0IHRlc3QuXG4gKlxuICogRG9lcyBub3QgY29uc2lkZXIgYW4gQXJyYXkgYW4gb2JqZWN0LlxuICovXG5jb25zdCBpc09iamVjdCA9ICh2YWx1ZSkgPT4gKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpICYmICghKDAsIGV4cG9ydHMuaXNBcnJheSkodmFsdWUpKTtcbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbi8qKlxuICogaXNBcnJheSB0ZXN0LlxuICovXG5leHBvcnRzLmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuLyoqXG4gKiBpc1N0cmluZyB0ZXN0LlxuICovXG5jb25zdCBpc1N0cmluZyA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcbi8qKlxuICogaXNOdW1iZXIgdGVzdC5cbiAqL1xuY29uc3QgaXNOdW1iZXIgPSAodmFsdWUpID0+ICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSAmJiAoIWlzTmFOKHZhbHVlKSk7XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG4vKipcbiAqIGlzQm9vbGVhbiB0ZXN0LlxuICovXG5jb25zdCBpc0Jvb2xlYW4gPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG4vKipcbiAqIGlzRnVuY3Rpb24gdGVzdC5cbiAqL1xuY29uc3QgaXNGdW5jdGlvbiA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbi8qKlxuICogaXNQcmltIHRlc3QuXG4gKi9cbmNvbnN0IGlzUHJpbSA9ICh2YWx1ZSkgPT4gISgoMCwgZXhwb3J0cy5pc09iamVjdCkodmFsdWUpIHx8XG4gICAgKDAsIGV4cG9ydHMuaXNBcnJheSkodmFsdWUpIHx8XG4gICAgKDAsIGV4cG9ydHMuaXNGdW5jdGlvbikodmFsdWUpKTtcbmV4cG9ydHMuaXNQcmltID0gaXNQcmltO1xuLyoqXG4gKiBpcyBwZXJmb3JtcyBhIHR5cGVvZiBvZiBjaGVjayBvbiBhIHR5cGUuXG4gKi9cbmNvbnN0IGlzID0gKGV4cGVjdGVkKSA9PiAodmFsdWUpID0+IHR5cGVvZiAodmFsdWUpID09PSBleHBlY3RlZDtcbmV4cG9ydHMuaXMgPSBpcztcbi8qKlxuICogdGVzdCB3aGV0aGVyIGEgdmFsdWUgY29uZm9ybXMgdG8gc29tZSBwYXR0ZXJuLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbWFkZSBhdmFpbGFibGUgbWFpbmx5IGZvciBhIGNydWRlIHBhdHRlcm4gbWF0Y2hpbmdcbiAqIG1hY2hpbmVyeSB0aGF0IHdvcmtzIGFzIGZvbGxvd3NzOlxuICogc3RyaW5nICAgLT4gTWF0Y2hlcyBvbiB0aGUgdmFsdWUgb2YgdGhlIHN0cmluZy5cbiAqIG51bWJlciAgIC0+IE1hdGNoZXMgb24gdGhlIHZhbHVlIG9mIHRoZSBudW1iZXIuXG4gKiBib29sZWFuICAtPiBNYXRjaGVzIG9uIHRoZSB2YWx1ZSBvZiB0aGUgYm9vbGVhbi5cbiAqIG9iamVjdCAgIC0+IEVhY2gga2V5IG9mIHRoZSBvYmplY3QgaXMgbWF0Y2hlZCBvbiB0aGUgdmFsdWUsIGFsbCBtdXN0IG1hdGNoLlxuICogZnVuY3Rpb24gLT4gVHJlYXRlZCBhcyBhIGNvbnN0cnVjdG9yIGFuZCByZXN1bHRzIGluIGFuIGluc3RhbmNlb2YgY2hlY2sgb3JcbiAqICAgICAgICAgICAgIGZvciBTdHJpbmcsTnVtYmVyIGFuZCBCb29sZWFuLCB0aGlzIHVzZXMgdGhlIHR5cGVvZiBjaGVjay4gSWZcbiAqICAgICAgICAgICAgIHRoZSBmdW5jdGlvbiBpcyBSZWdFeHAgdGhlbiB3ZSB1c2VzIHRoZSBSZWdFeHAudGVzdCBmdW5jdGlvblxuICogICAgICAgICAgICAgaW5zdGVhZC5cbiAqL1xuY29uc3QgdGVzdCA9ICh2YWx1ZSwgdCkgPT4ge1xuICAgIGlmICgocHJpbXMuaW5kZXhPZih0eXBlb2YgdCkgPiAtMSkgJiYgKHZhbHVlID09PSB0KSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgZWxzZSBpZiAoKHR5cGVvZiB0ID09PSAnZnVuY3Rpb24nKSAmJlxuICAgICAgICAoKCh0ID09PSBTdHJpbmcpICYmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSkgfHxcbiAgICAgICAgICAgICgodCA9PT0gTnVtYmVyKSAmJiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykpIHx8XG4gICAgICAgICAgICAoKHQgPT09IEJvb2xlYW4pICYmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykpIHx8XG4gICAgICAgICAgICAoKHQgPT09IEFycmF5KSAmJiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpKSB8fFxuICAgICAgICAgICAgKHQgPT09IEFueSkgfHxcbiAgICAgICAgICAgICh2YWx1ZSBpbnN0YW5jZW9mIHQpKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgZWxzZSBpZiAoKHQgaW5zdGFuY2VvZiBSZWdFeHApICYmXG4gICAgICAgICgodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykgJiZcbiAgICAgICAgICAgIHQudGVzdCh2YWx1ZSkpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBlbHNlIGlmICgodHlwZW9mIHQgPT09ICdvYmplY3QnKSAmJiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JykpXG4gICAgICAgIHJldHVybiBPYmplY3RcbiAgICAgICAgICAgIC5rZXlzKHQpXG4gICAgICAgICAgICAuZXZlcnkoayA9PiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgaykgP1xuICAgICAgICAgICAgKDAsIGV4cG9ydHMudGVzdCkodmFsdWVba10sIHRba10pIDogZmFsc2UpO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5leHBvcnRzLnRlc3QgPSB0ZXN0O1xuLyoqXG4gKiBzaG93IHRoZSB0eXBlIG9mIGEgdmFsdWUuXG4gKlxuICogTm90ZTogVGhpcyBtYXkgY3Jhc2ggaWYgdGhlIHZhbHVlIGlzIGFuXG4gKiBvYmplY3QgbGl0ZXJhbCB3aXRoIHJlY3Vyc2l2ZSByZWZlcmVuY2VzLlxuICovXG5jb25zdCBzaG93ID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIGBbJHt2YWx1ZS5tYXAoZXhwb3J0cy5zaG93KX1dO2A7XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpXG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHxcbiAgICAgICAgICAgICAgICB2YWx1ZS5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gJycgKyB2YWx1ZTtcbiAgICB9XG59O1xuZXhwb3J0cy5zaG93ID0gc2hvdztcbi8qKlxuICogdG9TdHJpbmcgY2FzdHMgYSB2YWx1ZSB0byBhIHN0cmluZy5cbiAqXG4gKiBJZiB0aGUgdmFsdWUgaXMgbnVsbCBvciB1bmRlZmluZWQgYW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGluc3RlYWQgb2ZcbiAqIHRoZSBkZWZhdWx0LlxuICovXG5jb25zdCB0b1N0cmluZyA9ICh2YWwpID0+ICh2YWwgPT0gbnVsbCkgPyAnJyA6IFN0cmluZyh2YWwpO1xuZXhwb3J0cy50b1N0cmluZyA9IHRvU3RyaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJvdW5kID0gZXhwb3J0cy5pc011bHRpcGxlT2YgPSB2b2lkIDA7XG4vKipcbiAqIGlzTXVsdGlwbGVPZiB0ZXN0cyB3aGV0aGVyIHRoZSBJbnRlZ2VyICd5JyBpcyBhIG11bHRpcGxlIG9mIHguXG4gKi9cbmNvbnN0IGlzTXVsdGlwbGVPZiA9ICh4LCB5KSA9PiAoKHkgJSB4KSA9PT0gMCk7XG5leHBvcnRzLmlzTXVsdGlwbGVPZiA9IGlzTXVsdGlwbGVPZjtcbi8qKlxuICogcm91bmQgYSBudW1iZXIgXCJ4XCIgdG8gXCJuXCIgcGxhY2VzIChuIGRlZmF1bHRzIHRvIDAgcGxhY2VzKS5cbiAqXG4gKiBUaGlzIHVzZXMgdGhlIE1hdGgucm91bmQoeCAqIG4pIC8gbiBtZXRob2QgaG93ZXZlciB3ZSB0YWtlIGludG9cbiAqIGNvbnNpZGVyYXRpb24gdGhlIE1hdGgucm91bmQoMS4wMDUgKiAxMDApIC8gMTAwID09PSAxIGlzc3VlIGJ5IHVzZSBvZiBhblxuICogb2Zmc2V0OlxuICpcbiAqIHNpZ24gKiAocm91bmQoKGFicyh4KSAqIDEwXm4pICsgKDEgLyAxMF5uKzEpKSAvIDEwXm4pXG4gKlxuICogV2hlcmU6XG4gKlxuICogc2lnbiBpcyB0aGUgc2lnbiBvZiB4XG4gKiByb3VuZCBpcyBNYXRoLnJvdW5kXG4gKiBhYnMgaXMgTWF0aC5hYnNcbiAqICgxIC8gMTBebisxKSBpcyB0aGUgb2Zmc2V0LlxuICpcbiAqIFRoZSBvZmZzZXQgaXMgb25seSB1c2VkIGlmIG4gaXMgbW9yZSB0aGFuIHplcm8uIFRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB4XG4gKiBpcyB1c2VkIGluIHRoZSBjYWxjdWxhdGlvbiB0byBhdm9pZCBKYXZhU2NyaXB0IGlkaW9zeW5jcmFjaWVzIHdoZW4gcm91bmRpbmdcbiAqIDAuNTpcbiAqIChNYXRoLnJvdW5kKCgxLjAwNSAqIDEwMCkrMC4wMDEpIC8gMTAwKSA9PT0gMS4wMVxuICpcbiAqIHdoZXJlYXNcbiAqIChNYXRoLnJvdW5kKCgtMS4wMDUgKiAxMDApKzAuMDAxKSAvIDEwMCkgPT09IC0xXG4gKlxuICogU2VlIHRoZSBkZXNjcmlwdGlvbiBbaGVyZV0oIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvcm91bmQpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqL1xuY29uc3Qgcm91bmQgPSAoeCwgbiA9IDApID0+IHtcbiAgICBsZXQgZXhwID0gTWF0aC5wb3coMTAsIG4pO1xuICAgIGxldCBzaWduID0geCA+PSAwID8gMSA6IC0xO1xuICAgIGxldCBvZmZzZXQgPSAobiA+IDApID8gKDEgLyAoTWF0aC5wb3coMTAsIG4gKyAxKSkpIDogMDtcbiAgICByZXR1cm4gc2lnbiAqIChNYXRoLnJvdW5kKChNYXRoLmFicyh4KSAqIGV4cCkgKyBvZmZzZXQpIC8gZXhwKTtcbn07XG5leHBvcnRzLnJvdW5kID0gcm91bmQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBUaGlzIG1vZHVsZSBwcm92aWRlcyBmdW5jdGlvbnMgdXNlZCBpbiB0ZW1wbGF0ZXMgdG8gZ2VuZXJhdGUgc3VwcG9ydGVkIERPTVxuICogbm9kZXMuXG4gKlxuICogVGhlIGlkZWEgaGVyZSBpcyB0byBwcm92aWRlIGFuIGFic3RyYWN0aW9uIG92ZXIgRE9NIGNvbnN0cnVjdGlvbiBzb1xuICogd2UgY2FuIGRldGVjdCB3aGV0aGVyIHdlIGFyZSBpbiBhIGJyb3dzZXIgb3IgZWxzZXdoZXJlIGFuZCBhZGp1c3QgdG9cbiAqIHN1aXRlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUVsZW1lbnQgPSBleHBvcnRzLnVuc2FmZSA9IGV4cG9ydHMudGV4dCA9IGV4cG9ydHMuY3JlYXRlVW5zYWZlTm9kZSA9IGV4cG9ydHMuY3JlYXRlVGV4dE5vZGUgPSBleHBvcnRzLmVzY2FwZUhUTUwgPSBleHBvcnRzLmVzY2FwZUF0dHJWYWx1ZSA9IGV4cG9ydHMuZXNjYXBlQXR0cnMgPSBleHBvcnRzLmlzQnJvd3NlciA9IGV4cG9ydHMuV01MRE9NRWxlbWVudCA9IGV4cG9ydHMuV01MRE9NVGV4dCA9IGV4cG9ydHMuV01MRE9NTm9kZSA9IGV4cG9ydHMuV01MTm9kZUxpc3QgPSB2b2lkIDA7XG5jb25zdCByZWNvcmRfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9yZWNvcmRcIik7XG5jb25zdCB0eXBlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvdHlwZVwiKTtcbi8vIERlY2xhcmVkIHNvIGlzQnJvd3NlciB3b3JrcyBvbiBub2RlLmpzLlxubGV0IHdpbmRvdyA9IGdsb2JhbDtcbmxldCBkb2N1bWVudCA9IGdsb2JhbC5kb2N1bWVudDtcbmNvbnN0IERPQ1RZUEUgPSAnPCFET0NUWVBFIGh0bWw+JztcbmNvbnN0IEFUVFJfRVNDX01BUCA9IHtcbiAgICAnJic6ICdcXFxcdTAwMjYnLFxuICAgICc+JzogJ1xcXFx1MDAzZScsXG4gICAgJzwnOiAnXFxcXHUwMDNjJyxcbiAgICAnXCInOiAnXFxcXHUwMDIyJyxcbiAgICAnPSc6ICdcXFxcdTAwM2QnLFxuICAgICdcXHUwMDVjJzogJ1xcXFx1MDA1YycsXG4gICAgJ1xcdTIwMjgnOiAnXFxcXHUyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICdcXFxcdTIwMjknXG59O1xuY29uc3QgYXR0cnNFc2NSZWdleCA9IG5ldyBSZWdFeHAoYFskeygwLCByZWNvcmRfMS5tYXBUbykoQVRUUl9FU0NfTUFQLCAoXywgaykgPT4gayl9XWAsICdnJyk7XG5jb25zdCBIVE1MX0VOVF9NQVAgPSB7XG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICdcXCcnOiAnJmFwb3M7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7J1xufTtcbmNvbnN0IGh0bWxFc2NSZWdleCA9IG5ldyBSZWdFeHAoYFskeygwLCByZWNvcmRfMS5tYXBUbykoSFRNTF9FTlRfTUFQLCAoXywgaykgPT4gayl9XWAsICdnJyk7XG5jb25zdCB2b2lkRWxlbWVudHMgPSBbXG4gICAgJ2FyZWEnLFxuICAgICdiYXNlJyxcbiAgICAnYnInLFxuICAgICdjb2wnLFxuICAgICdjb21tYW5kJyxcbiAgICAnZW1iZWQnLFxuICAgICdocicsXG4gICAgJ2ltZycsXG4gICAgJ2lucHV0JyxcbiAgICAna2V5Z2VuJyxcbiAgICAnbGluaycsXG4gICAgJ21ldGEnLFxuICAgICdwYXJhbScsXG4gICAgJ3NvdXJjZScsXG4gICAgJ3RyYWNrJyxcbiAgICAnd2JyJ1xuXTtcbi8qKlxuICogV01MTm9kZUxpc3QgaW1wbGVtZW50YXRpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBXTUxOb2RlTGlzdCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgaXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZvckVhY2goKSB7IH1cbn1cbmV4cG9ydHMuV01MTm9kZUxpc3QgPSBXTUxOb2RlTGlzdDtcbi8qKlxuICogV01MRE9NTm9kZSBpbXBsZW1lbnRzIHRoZSBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIG9mIHRoZSBET00gTm9kZSBpbnRlcmZhY2UgdG9cbiAqIGFsbG93IGEgZmFrZSBET00gdG8gYmUgYnVpbHQgaW4gc2VydmVyIHNpZGUgY29kZS5cbiAqXG4gKiBNb3N0IG9mIHRoZSBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIGNhbm5vdCBiZSByZWxpZWQgb24gYW5kIHNob3VsZCBub3QgYmVcbiAqIHVzZWQuXG4gKi9cbmNsYXNzIFdNTERPTU5vZGUge1xuICAgIGNvbnN0cnVjdG9yKG5vZGVOYW1lLCBub2RlVHlwZSkge1xuICAgICAgICB0aGlzLm5vZGVOYW1lID0gbm9kZU5hbWU7XG4gICAgICAgIHRoaXMubm9kZVR5cGUgPSBub2RlVHlwZTtcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVfTk9ERSA9IC0xO1xuICAgICAgICB0aGlzLkNEQVRBX1NFQ1RJT05fTk9ERSA9IC0xO1xuICAgICAgICB0aGlzLkNPTU1FTlRfTk9ERSA9IC0xO1xuICAgICAgICB0aGlzLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUgPSAtMTtcbiAgICAgICAgdGhpcy5ET0NVTUVOVF9OT0RFID0gLTE7XG4gICAgICAgIHRoaXMuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZID0gLTE7XG4gICAgICAgIHRoaXMuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTlMgPSAtMTtcbiAgICAgICAgdGhpcy5ET0NVTUVOVF9QT1NJVElPTl9ESVNDT05ORUNURUQgPSAtMTtcbiAgICAgICAgdGhpcy5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkcgPSAtMTtcbiAgICAgICAgdGhpcy5ET0NVTUVOVF9QT1NJVElPTl9JTVBMRU1FTlRBVElPTl9TUEVDSUZJQyA9IC0xO1xuICAgICAgICB0aGlzLkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORyA9IC0xO1xuICAgICAgICB0aGlzLkRPQ1VNRU5UX1RZUEVfTk9ERSA9IC0xO1xuICAgICAgICB0aGlzLkVMRU1FTlRfTk9ERSA9IC0xO1xuICAgICAgICB0aGlzLkVOVElUWV9OT0RFID0gLTE7XG4gICAgICAgIHRoaXMuRU5USVRZX1JFRkVSRU5DRV9OT0RFID0gLTE7XG4gICAgICAgIHRoaXMuTk9UQVRJT05fTk9ERSA9IC0xO1xuICAgICAgICB0aGlzLlBST0NFU1NJTkdfSU5TVFJVQ1RJT05fTk9ERSA9IC0xO1xuICAgICAgICB0aGlzLlRFWFRfTk9ERSA9IC0xO1xuICAgICAgICB0aGlzLmJhc2VVUkkgPSAnJztcbiAgICAgICAgdGhpcy5jaGlsZE5vZGVzID0gbmV3IFdNTE5vZGVMaXN0KCk7XG4gICAgICAgIHRoaXMuZmlyc3RDaGlsZCA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sYXN0Q2hpbGQgPSBudWxsO1xuICAgICAgICB0aGlzLm5hbWVzcGFjZVVSSSA9IG51bGw7XG4gICAgICAgIHRoaXMubmV4dFNpYmxpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLm5vZGVWYWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMub3duZXJEb2N1bWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMucGFyZW50RWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMucGFyZW50Tm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMucHJldmlvdXNTaWJsaW5nID0gbnVsbDtcbiAgICB9XG4gICAgZ2V0IHRleHRDb250ZW50KCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGFkZEV2ZW50TGlzdGVuZXIoKSB7IH1cbiAgICBkaXNwYXRjaEV2ZW50KCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoKSB7IH1cbiAgICBhcHBlbmRDaGlsZChuZXdDaGlsZCkge1xuICAgICAgICByZXR1cm4gbmV3Q2hpbGQ7XG4gICAgfVxuICAgIGNsb25lTm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29udGFpbnMoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0Um9vdE5vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBoYXNDaGlsZE5vZGVzKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGluc2VydEJlZm9yZShuZXdDaGlsZCkge1xuICAgICAgICByZXR1cm4gbmV3Q2hpbGQ7XG4gICAgfVxuICAgIGlzRGVmYXVsdE5hbWVzcGFjZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpc0VxdWFsTm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpc1NhbWVOb2RlKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxvb2t1cE5hbWVzcGFjZVVSSSgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxvb2t1cFByZWZpeCgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIG5vcm1hbGl6ZSgpIHsgfVxuICAgIHJlbW92ZSgpIHsgfVxuICAgIGJlZm9yZSgpIHsgfVxuICAgIGFmdGVyKCkgeyB9XG4gICAgcmVwbGFjZVdpdGgoKSB7IH1cbiAgICByZW1vdmVDaGlsZChvbGRDaGlsZCkge1xuICAgICAgICByZXR1cm4gb2xkQ2hpbGQ7XG4gICAgfVxuICAgIHJlcGxhY2VDaGlsZChfLCBvbGRDaGlsZCkge1xuICAgICAgICByZXR1cm4gb2xkQ2hpbGQ7XG4gICAgfVxufVxuZXhwb3J0cy5XTUxET01Ob2RlID0gV01MRE9NTm9kZTtcbi8qKlxuICogV01MRE9NVGV4dCBpcyB1c2VkIHRvIHJlcHJlc2VudCBUZXh0IG5vZGVzIG9uIHRoZSBzZXJ2ZXIgc2lkZS5cbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFdNTERPTVRleHQgZXh0ZW5kcyBXTUxET01Ob2RlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgZXNjYXBlID0gdHJ1ZSkge1xuICAgICAgICBzdXBlcignI3RleHQnLCAtMSk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5lc2NhcGUgPSBlc2NhcGU7XG4gICAgfVxuICAgIGdldCB0ZXh0Q29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXNjYXBlID8gKDAsIGV4cG9ydHMuZXNjYXBlSFRNTCkodGhpcy52YWx1ZSkgOiB0aGlzLnZhbHVlO1xuICAgIH1cbn1cbmV4cG9ydHMuV01MRE9NVGV4dCA9IFdNTERPTVRleHQ7XG4vKipcbiAqIFdNTERPTUVsZW1lbnQgaXMgdXNlZCB0byByZXByZXNlbnQgRWxlbWVudCBub2RlcyBvbiB0aGUgc2VydmVyIHNpZGUuXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBXTUxET01FbGVtZW50IGV4dGVuZHMgV01MRE9NTm9kZSB7XG4gICAgY29uc3RydWN0b3IodGFnLCBhdHRycywgY2hpbGRyZW4gPSBbXSkge1xuICAgICAgICBzdXBlcih0YWcsIC0xKTtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIH1cbiAgICBnZXQgaW5uZXJIVE1MKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5tYXAoYyA9PiAoYy5ub2RlTmFtZSA9PT0gJyN0ZXh0JykgP1xuICAgICAgICAgICAgYy50ZXh0Q29udGVudCA6XG4gICAgICAgICAgICBjLm91dGVySFRNTCkuam9pbignJyk7XG4gICAgfVxuICAgIGdldCBvdXRlckhUTUwoKSB7XG4gICAgICAgIGxldCB7IHRhZyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGNvbnRlbnQgPSB0aGlzLmlubmVySFRNTDtcbiAgICAgICAgbGV0IGF0dHJzID0gKDAsIHJlY29yZF8xLm1hcFRvKSgoMCwgZXhwb3J0cy5lc2NhcGVBdHRycykodGhpcy5hdHRycyksICh2YWx1ZSwgbmFtZSkgPT4gIXZhbHVlID9cbiAgICAgICAgICAgIG5hbWUgOiBgJHtuYW1lfT1cIiR7dmFsdWV9XCJgKS5qb2luKCcgJyk7XG4gICAgICAgIGF0dHJzID0gKGF0dHJzLnRyaW0oKSAhPSAnJykgPyBgICR7YXR0cnN9YCA6ICcnO1xuICAgICAgICBsZXQgb3BlbiA9IGA8JHt0YWd9JHthdHRyc30+YDtcbiAgICAgICAgaWYgKHRhZyA9PT0gXCJodG1sXCIpXG4gICAgICAgICAgICBvcGVuID0gYCR7RE9DVFlQRX0ke29wZW59YDtcbiAgICAgICAgcmV0dXJuICh2b2lkRWxlbWVudHMuaW5kZXhPZih0YWcpID4gLTEpID9cbiAgICAgICAgICAgIG9wZW4gOiBgJHtvcGVufSR7Y29udGVudH08LyR7dGFnfT5gO1xuICAgIH1cbiAgICBzZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmF0dHJzW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgYXBwZW5kQ2hpbGQobmV3Q2hpbGQpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKG5ld0NoaWxkKTtcbiAgICAgICAgcmV0dXJuIG5ld0NoaWxkO1xuICAgIH1cbn1cbmV4cG9ydHMuV01MRE9NRWxlbWVudCA9IFdNTERPTUVsZW1lbnQ7XG4vKipcbiAqIGlzQnJvd3NlciBpcyBzZXQgdG8gdHJ1ZSBpZiB3ZSBkZXRlY3QgYSB3aW5kb3cgYW5kIGRvY3VtZW50IGdsb2JhbCB2YXJpYWJsZS5cbiAqL1xuZXhwb3J0cy5pc0Jyb3dzZXIgPSAoKHdpbmRvdyAhPSBudWxsKSAmJiAoZG9jdW1lbnQgIT0gbnVsbCkpO1xuLyoqXG4gKiBlc2NhcGVBdHRycyBlc2NhcGVzIGVhY2gga2V5IHZhbHVlIHBhaXIgb2YgYSBXTUxET01BdHRycy5cbiAqL1xuY29uc3QgZXNjYXBlQXR0cnMgPSAoYXR0cnMpID0+ICgwLCByZWNvcmRfMS5tYXApKGF0dHJzLCB2YWx1ZSA9PiAoMCwgdHlwZV8xLmlzRnVuY3Rpb24pKHZhbHVlKSA/IHZhbHVlIDpcbiAgICAodmFsdWUgaW5zdGFuY2VvZiBXTUxET01UZXh0KSA/IHZhbHVlLnRleHRDb250ZW50IDpcbiAgICAgICAgKDAsIGV4cG9ydHMuZXNjYXBlQXR0clZhbHVlKShTdHJpbmcodmFsdWUpKSk7XG5leHBvcnRzLmVzY2FwZUF0dHJzID0gZXNjYXBlQXR0cnM7XG4vKipcbiAqIGVzY2FwZUF0dHJWYWx1ZSBmb3Igc2FmZSBicm93c2VyIGRpc3BsYXkuXG4gKi9cbmNvbnN0IGVzY2FwZUF0dHJWYWx1ZSA9ICh2YWx1ZSkgPT4gdmFsdWUucmVwbGFjZShhdHRyc0VzY1JlZ2V4LCBoaXQgPT4gQVRUUl9FU0NfTUFQW2hpdF0pO1xuZXhwb3J0cy5lc2NhcGVBdHRyVmFsdWUgPSBlc2NhcGVBdHRyVmFsdWU7XG4vKipcbiAqIGVzY2FwZUhUTUwgZm9yIHNhZmUgYnJvd3NlciBkaXNwbGF5LlxuICovXG5jb25zdCBlc2NhcGVIVE1MID0gKHZhbHVlKSA9PiB2YWx1ZS5yZXBsYWNlKGh0bWxFc2NSZWdleCwgaGl0ID0+IEhUTUxfRU5UX01BUFtoaXRdKTtcbmV4cG9ydHMuZXNjYXBlSFRNTCA9IGVzY2FwZUhUTUw7XG4vKipcbiAqIGNyZWF0ZVRleHROb2RlIHdyYXBwZXIuXG4gKi9cbmNvbnN0IGNyZWF0ZVRleHROb2RlID0gKHR4dCkgPT4ge1xuICAgIGxldCBzdHIgPSBTdHJpbmcoKHR4dCA9PSBudWxsKSA/ICcnIDogdHh0KTtcbiAgICByZXR1cm4gZXhwb3J0cy5pc0Jyb3dzZXIgPyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzdHIpIDogbmV3IFdNTERPTVRleHQoc3RyKTtcbn07XG5leHBvcnRzLmNyZWF0ZVRleHROb2RlID0gY3JlYXRlVGV4dE5vZGU7XG5leHBvcnRzLnRleHQgPSBleHBvcnRzLmNyZWF0ZVRleHROb2RlO1xuLyoqXG4gKiBjcmVhdGVVbnNhZmVOb2RlIGFsbG93cyByYXcgc3RyaW5ncyB0byBiZSBvdXRwdXQgd2l0aG91dCBlc2NhcGluZy5cbiAqXG4gKiBUSElTIE1VU1QgT05MWSBCRSBVU0VEIElGIFlPVSBBUkUgMTAwJSBTVVJFIFRIRSBTVFJJTkcgSVMgU0FGRSBUTyBPVVRQVVQhXG4gKi9cbmNvbnN0IGNyZWF0ZVVuc2FmZU5vZGUgPSAodHh0KSA9PiB7XG4gICAgbGV0IHN0ciA9IFN0cmluZygodHh0ID09IG51bGwpID8gJycgOiB0eHQpO1xuICAgIHJldHVybiBleHBvcnRzLmlzQnJvd3NlciA/IGNyZWF0ZUJyb3dzZXJVbnNhZmVOb2RlKHN0cikgOiBuZXcgV01MRE9NVGV4dChzdHIsIGZhbHNlKTtcbn07XG5leHBvcnRzLmNyZWF0ZVVuc2FmZU5vZGUgPSBjcmVhdGVVbnNhZmVOb2RlO1xuZXhwb3J0cy51bnNhZmUgPSBleHBvcnRzLmNyZWF0ZVVuc2FmZU5vZGU7XG5jb25zdCBjcmVhdGVCcm93c2VyVW5zYWZlTm9kZSA9IChodG1sKSA9PiB7XG4gICAgbGV0IHRtcGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgIHRtcGwuaW5uZXJIVE1MID0gaHRtbDtcbiAgICByZXR1cm4gdG1wbC5jb250ZW50O1xufTtcbi8qKlxuICogY3JlYXRlRWxlbWVudCB3cmFwcGVyLlxuICovXG5jb25zdCBjcmVhdGVFbGVtZW50ID0gKHRhZywgYXR0cnMgPSB7fSwgY2hpbGRyZW4gPSBbXSkgPT4ge1xuICAgIGlmICghZXhwb3J0cy5pc0Jyb3dzZXIpIHtcbiAgICAgICAgLy8gWFhYOiBUaGUgd2hvbGUgRWxlbWVudCBpbnRlcmZhY2UgaXMgbm90IGltcGxlbWVudGVkIGJ1dCBvbiBzZXJ2ZXJcbiAgICAgICAgLy8gc2lkZSB3ZSBhcmUgb25seSBpbnRlcmVzdGVkIGluIHNldEF0dHJpYnV0ZS5cbiAgICAgICAgcmV0dXJuIG5ldyBXTUxET01FbGVtZW50KHRhZywgYXR0cnMsIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICAoMCwgcmVjb3JkXzEuZm9yRWFjaCkoYXR0cnMsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy8gcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPVwiXCJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxufTtcbmV4cG9ydHMuY3JlYXRlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kb20uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlbmRlckFzTm9kZSA9IGV4cG9ydHMuQ29tcG9uZW50ID0gdm9pZCAwO1xuLyoqXG4gKiBDb21wb25lbnQgaXMgYW4gYWJzdHJhY3QgV2lkZ2V0IGltcGxlbWVudGF0aW9uXG4gKiB0aGF0IGNhbiBiZSB1c2VkIGluc3RlYWQgb2YgbWFudWFsbHkgaW1wbGVtZW50aW5nIHRoZSB3aG9sZSBpbnRlcmZhY2UuXG4gKi9cbmNsYXNzIENvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBfSBhdHRycyBpcyB0aGUgYXR0cmlidXRlcyB0aGlzIENvbXBvbmVudCBleGNlcHRzLlxuICAgICAqIEBwYXJhbSB7Q29udGVudFtdfSBjaGlsZHJlbiBpcyBhbiBhcnJheSBvZiBjb250ZW50IGZvciBDb21wb25lbnQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIH1cbiAgICByZW5kZXJlZCgpIHsgfVxuICAgIHJlbW92ZWQoKSB7IH1cbiAgICByZW5kZXIoKSB7IHJldHVybiB0aGlzLnZpZXcucmVuZGVyKCk7IH1cbn1cbmV4cG9ydHMuQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuO1xuLyoqXG4gKiByZW5kZXJBc05vZGUgY29udGVudCBmcm9tIGEgUmVuZGVyYWJsZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHVuc2FmZWx5IGFzc3VtZXMgdGhlIFJlbmRlcmFibGUgYWx3YXlzIHJldHVybnMgRE9NIGNvbnRlbnQuXG4gKi9cbmNvbnN0IHJlbmRlckFzTm9kZSA9IChyKSA9PiByLnJlbmRlcigpO1xuZXhwb3J0cy5yZW5kZXJBc05vZGUgPSByZW5kZXJBc05vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIvLyEgbW9tZW50LmpzXG4vLyEgdmVyc2lvbiA6IDIuMjkuNFxuLy8hIGF1dGhvcnMgOiBUaW0gV29vZCwgSXNrcmVuIENoZXJuZXYsIE1vbWVudC5qcyBjb250cmlidXRvcnNcbi8vISBsaWNlbnNlIDogTUlUXG4vLyEgbW9tZW50anMuY29tXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIGdsb2JhbC5tb21lbnQgPSBmYWN0b3J5KClcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIGhvb2tDYWxsYmFjaztcblxuICAgIGZ1bmN0aW9uIGhvb2tzKCkge1xuICAgICAgICByZXR1cm4gaG9va0NhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBpcyBkb25lIHRvIHJlZ2lzdGVyIHRoZSBtZXRob2QgY2FsbGVkIHdpdGggbW9tZW50KClcbiAgICAvLyB3aXRob3V0IGNyZWF0aW5nIGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cbiAgICBmdW5jdGlvbiBzZXRIb29rQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICAgICAgaG9va0NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNBcnJheShpbnB1dCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaW5wdXQgaW5zdGFuY2VvZiBBcnJheSB8fFxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KGlucHV0KSB7XG4gICAgICAgIC8vIElFOCB3aWxsIHRyZWF0IHVuZGVmaW5lZCBhbmQgbnVsbCBhcyBvYmplY3QgaWYgaXQgd2Fzbid0IGZvclxuICAgICAgICAvLyBpbnB1dCAhPSBudWxsXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBpbnB1dCAhPSBudWxsICYmXG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBPYmplY3RdJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc093blByb3AoYSwgYikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzT2JqZWN0RW1wdHkob2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcykge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoID09PSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGs7XG4gICAgICAgICAgICBmb3IgKGsgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc093blByb3Aob2JqLCBrKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZChpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT09IHZvaWQgMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc051bWJlcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgTnVtYmVyXSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RhdGUoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGlucHV0IGluc3RhbmNlb2YgRGF0ZSB8fFxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRGF0ZV0nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFwKGFyciwgZm4pIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGFyckxlbiA9IGFyci5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnJMZW47ICsraSkge1xuICAgICAgICAgICAgcmVzLnB1c2goZm4oYXJyW2ldLCBpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlbmQoYSwgYikge1xuICAgICAgICBmb3IgKHZhciBpIGluIGIpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGIsIGkpKSB7XG4gICAgICAgICAgICAgICAgYVtpXSA9IGJbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCAndG9TdHJpbmcnKSkge1xuICAgICAgICAgICAgYS50b1N0cmluZyA9IGIudG9TdHJpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCAndmFsdWVPZicpKSB7XG4gICAgICAgICAgICBhLnZhbHVlT2YgPSBiLnZhbHVlT2Y7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIHRydWUpLnV0YygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRQYXJzaW5nRmxhZ3MoKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZGVlcCBjbG9uZSB0aGlzIG9iamVjdC5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVtcHR5OiBmYWxzZSxcbiAgICAgICAgICAgIHVudXNlZFRva2VuczogW10sXG4gICAgICAgICAgICB1bnVzZWRJbnB1dDogW10sXG4gICAgICAgICAgICBvdmVyZmxvdzogLTIsXG4gICAgICAgICAgICBjaGFyc0xlZnRPdmVyOiAwLFxuICAgICAgICAgICAgbnVsbElucHV0OiBmYWxzZSxcbiAgICAgICAgICAgIGludmFsaWRFcmE6IG51bGwsXG4gICAgICAgICAgICBpbnZhbGlkTW9udGg6IG51bGwsXG4gICAgICAgICAgICBpbnZhbGlkRm9ybWF0OiBmYWxzZSxcbiAgICAgICAgICAgIHVzZXJJbnZhbGlkYXRlZDogZmFsc2UsXG4gICAgICAgICAgICBpc286IGZhbHNlLFxuICAgICAgICAgICAgcGFyc2VkRGF0ZVBhcnRzOiBbXSxcbiAgICAgICAgICAgIGVyYTogbnVsbCxcbiAgICAgICAgICAgIG1lcmlkaWVtOiBudWxsLFxuICAgICAgICAgICAgcmZjMjgyMjogZmFsc2UsXG4gICAgICAgICAgICB3ZWVrZGF5TWlzbWF0Y2g6IGZhbHNlLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFBhcnNpbmdGbGFncyhtKSB7XG4gICAgICAgIGlmIChtLl9wZiA9PSBudWxsKSB7XG4gICAgICAgICAgICBtLl9wZiA9IGRlZmF1bHRQYXJzaW5nRmxhZ3MoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS5fcGY7XG4gICAgfVxuXG4gICAgdmFyIHNvbWU7XG4gICAgaWYgKEFycmF5LnByb3RvdHlwZS5zb21lKSB7XG4gICAgICAgIHNvbWUgPSBBcnJheS5wcm90b3R5cGUuc29tZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzb21lID0gZnVuY3Rpb24gKGZ1bikge1xuICAgICAgICAgICAgdmFyIHQgPSBPYmplY3QodGhpcyksXG4gICAgICAgICAgICAgICAgbGVuID0gdC5sZW5ndGggPj4+IDAsXG4gICAgICAgICAgICAgICAgaTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gdCAmJiBmdW4uY2FsbCh0aGlzLCB0W2ldLCBpLCB0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkKG0pIHtcbiAgICAgICAgaWYgKG0uX2lzVmFsaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGZsYWdzID0gZ2V0UGFyc2luZ0ZsYWdzKG0pLFxuICAgICAgICAgICAgICAgIHBhcnNlZFBhcnRzID0gc29tZS5jYWxsKGZsYWdzLnBhcnNlZERhdGVQYXJ0cywgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgIT0gbnVsbDtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBpc05vd1ZhbGlkID1cbiAgICAgICAgICAgICAgICAgICAgIWlzTmFOKG0uX2QuZ2V0VGltZSgpKSAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy5vdmVyZmxvdyA8IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLmVtcHR5ICYmXG4gICAgICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkRXJhICYmXG4gICAgICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkTW9udGggJiZcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRXZWVrZGF5ICYmXG4gICAgICAgICAgICAgICAgICAgICFmbGFncy53ZWVrZGF5TWlzbWF0Y2ggJiZcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLm51bGxJbnB1dCAmJlxuICAgICAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZEZvcm1hdCAmJlxuICAgICAgICAgICAgICAgICAgICAhZmxhZ3MudXNlckludmFsaWRhdGVkICYmXG4gICAgICAgICAgICAgICAgICAgICghZmxhZ3MubWVyaWRpZW0gfHwgKGZsYWdzLm1lcmlkaWVtICYmIHBhcnNlZFBhcnRzKSk7XG5cbiAgICAgICAgICAgIGlmIChtLl9zdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBpc05vd1ZhbGlkID1cbiAgICAgICAgICAgICAgICAgICAgaXNOb3dWYWxpZCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy5jaGFyc0xlZnRPdmVyID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLnVudXNlZFRva2Vucy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuYmlnSG91ciA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmlzRnJvemVuID09IG51bGwgfHwgIU9iamVjdC5pc0Zyb3plbihtKSkge1xuICAgICAgICAgICAgICAgIG0uX2lzVmFsaWQgPSBpc05vd1ZhbGlkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNOb3dWYWxpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS5faXNWYWxpZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVJbnZhbGlkKGZsYWdzKSB7XG4gICAgICAgIHZhciBtID0gY3JlYXRlVVRDKE5hTik7XG4gICAgICAgIGlmIChmbGFncyAhPSBudWxsKSB7XG4gICAgICAgICAgICBleHRlbmQoZ2V0UGFyc2luZ0ZsYWdzKG0pLCBmbGFncyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkudXNlckludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cblxuICAgIC8vIFBsdWdpbnMgdGhhdCBhZGQgcHJvcGVydGllcyBzaG91bGQgYWxzbyBhZGQgdGhlIGtleSBoZXJlIChudWxsIHZhbHVlKSxcbiAgICAvLyBzbyB3ZSBjYW4gcHJvcGVybHkgY2xvbmUgb3Vyc2VsdmVzLlxuICAgIHZhciBtb21lbnRQcm9wZXJ0aWVzID0gKGhvb2tzLm1vbWVudFByb3BlcnRpZXMgPSBbXSksXG4gICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIGNvcHlDb25maWcodG8sIGZyb20pIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBwcm9wLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgbW9tZW50UHJvcGVydGllc0xlbiA9IG1vbWVudFByb3BlcnRpZXMubGVuZ3RoO1xuXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNBTW9tZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgdG8uX2lzQU1vbWVudE9iamVjdCA9IGZyb20uX2lzQU1vbWVudE9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2kpKSB7XG4gICAgICAgICAgICB0by5faSA9IGZyb20uX2k7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9mKSkge1xuICAgICAgICAgICAgdG8uX2YgPSBmcm9tLl9mO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbCkpIHtcbiAgICAgICAgICAgIHRvLl9sID0gZnJvbS5fbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3N0cmljdCkpIHtcbiAgICAgICAgICAgIHRvLl9zdHJpY3QgPSBmcm9tLl9zdHJpY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl90em0pKSB7XG4gICAgICAgICAgICB0by5fdHptID0gZnJvbS5fdHptO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNVVEMpKSB7XG4gICAgICAgICAgICB0by5faXNVVEMgPSBmcm9tLl9pc1VUQztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX29mZnNldCkpIHtcbiAgICAgICAgICAgIHRvLl9vZmZzZXQgPSBmcm9tLl9vZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9wZikpIHtcbiAgICAgICAgICAgIHRvLl9wZiA9IGdldFBhcnNpbmdGbGFncyhmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2xvY2FsZSkpIHtcbiAgICAgICAgICAgIHRvLl9sb2NhbGUgPSBmcm9tLl9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9tZW50UHJvcGVydGllc0xlbiA+IDApIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtb21lbnRQcm9wZXJ0aWVzTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwcm9wID0gbW9tZW50UHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgICAgICB2YWwgPSBmcm9tW3Byb3BdO1xuICAgICAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICB0b1twcm9wXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuXG4gICAgLy8gTW9tZW50IHByb3RvdHlwZSBvYmplY3RcbiAgICBmdW5jdGlvbiBNb21lbnQoY29uZmlnKSB7XG4gICAgICAgIGNvcHlDb25maWcodGhpcywgY29uZmlnKTtcbiAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5fZCAhPSBudWxsID8gY29uZmlnLl9kLmdldFRpbWUoKSA6IE5hTik7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcCBpbiBjYXNlIHVwZGF0ZU9mZnNldCBjcmVhdGVzIG5ldyBtb21lbnRcbiAgICAgICAgLy8gb2JqZWN0cy5cbiAgICAgICAgaWYgKHVwZGF0ZUluUHJvZ3Jlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTW9tZW50KG9iaikge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgb2JqIGluc3RhbmNlb2YgTW9tZW50IHx8IChvYmogIT0gbnVsbCAmJiBvYmouX2lzQU1vbWVudE9iamVjdCAhPSBudWxsKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGhvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgY29uc29sZS53YXJuXG4gICAgICAgICkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGlvbiB3YXJuaW5nOiAnICsgbXNnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZShtc2csIGZuKSB7XG4gICAgICAgIHZhciBmaXJzdFRpbWUgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG51bGwsIG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgYXJnLFxuICAgICAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgIGFyZ0xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ0xlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArPSAnXFxuWycgKyBpICsgJ10gJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIGFyZ3VtZW50c1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGFyZ3VtZW50c1swXSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgKz0ga2V5ICsgJzogJyArIGFyZ3VtZW50c1swXVtrZXldICsgJywgJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmcuc2xpY2UoMCwgLTIpOyAvLyBSZW1vdmUgdHJhaWxpbmcgY29tbWEgYW5kIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGFyZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgICAgIG1zZyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnXFxuQXJndW1lbnRzOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpLmpvaW4oJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBFcnJvcigpLnN0YWNrXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBmaXJzdFRpbWUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LCBmbik7XG4gICAgfVxuXG4gICAgdmFyIGRlcHJlY2F0aW9ucyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlU2ltcGxlKG5hbWUsIG1zZykge1xuICAgICAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlcihuYW1lLCBtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVwcmVjYXRpb25zW25hbWVdKSB7XG4gICAgICAgICAgICB3YXJuKG1zZyk7XG4gICAgICAgICAgICBkZXByZWNhdGlvbnNbbmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID0gZmFsc2U7XG4gICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyID0gbnVsbDtcblxuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICh0eXBlb2YgRnVuY3Rpb24gIT09ICd1bmRlZmluZWQnICYmIGlucHV0IGluc3RhbmNlb2YgRnVuY3Rpb24pIHx8XG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBGdW5jdGlvbl0nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0KGNvbmZpZykge1xuICAgICAgICB2YXIgcHJvcCwgaTtcbiAgICAgICAgZm9yIChpIGluIGNvbmZpZykge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoY29uZmlnLCBpKSkge1xuICAgICAgICAgICAgICAgIHByb3AgPSBjb25maWdbaV07XG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tpXSA9IHByb3A7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1snXycgKyBpXSA9IHByb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgLy8gTGVuaWVudCBvcmRpbmFsIHBhcnNpbmcgYWNjZXB0cyBqdXN0IGEgbnVtYmVyIGluIGFkZGl0aW9uIHRvXG4gICAgICAgIC8vIG51bWJlciArIChwb3NzaWJseSkgc3R1ZmYgY29taW5nIGZyb20gX2RheU9mTW9udGhPcmRpbmFsUGFyc2UuXG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSBcIm9yZGluYWxQYXJzZVwiIGZhbGxiYWNrIGluIG5leHQgbWFqb3IgcmVsZWFzZS5cbiAgICAgICAgdGhpcy5fZGF5T2ZNb250aE9yZGluYWxQYXJzZUxlbmllbnQgPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgKHRoaXMuX2RheU9mTW9udGhPcmRpbmFsUGFyc2Uuc291cmNlIHx8IHRoaXMuX29yZGluYWxQYXJzZS5zb3VyY2UpICtcbiAgICAgICAgICAgICAgICAnfCcgK1xuICAgICAgICAgICAgICAgIC9cXGR7MSwyfS8uc291cmNlXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY2hpbGRDb25maWcpIHtcbiAgICAgICAgdmFyIHJlcyA9IGV4dGVuZCh7fSwgcGFyZW50Q29uZmlnKSxcbiAgICAgICAgICAgIHByb3A7XG4gICAgICAgIGZvciAocHJvcCBpbiBjaGlsZENvbmZpZykge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoY2hpbGRDb25maWcsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSkgJiYgaXNPYmplY3QoY2hpbGRDb25maWdbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBwYXJlbnRDb25maWdbcHJvcF0pO1xuICAgICAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBjaGlsZENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZENvbmZpZ1twcm9wXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IGNoaWxkQ29uZmlnW3Byb3BdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXNbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAocHJvcCBpbiBwYXJlbnRDb25maWcpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBoYXNPd25Qcm9wKHBhcmVudENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICAhaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICBpc09iamVjdChwYXJlbnRDb25maWdbcHJvcF0pXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgY2hhbmdlcyB0byBwcm9wZXJ0aWVzIGRvbid0IG1vZGlmeSBwYXJlbnQgY29uZmlnXG4gICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gZXh0ZW5kKHt9LCByZXNbcHJvcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9jYWxlKGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIga2V5cztcblxuICAgIGlmIChPYmplY3Qua2V5cykge1xuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAga2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgICAgIHJlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKG9iaiwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdENhbGVuZGFyID0ge1xuICAgICAgICBzYW1lRGF5OiAnW1RvZGF5IGF0XSBMVCcsXG4gICAgICAgIG5leHREYXk6ICdbVG9tb3Jyb3cgYXRdIExUJyxcbiAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFthdF0gTFQnLFxuICAgICAgICBsYXN0RGF5OiAnW1llc3RlcmRheSBhdF0gTFQnLFxuICAgICAgICBsYXN0V2VlazogJ1tMYXN0XSBkZGRkIFthdF0gTFQnLFxuICAgICAgICBzYW1lRWxzZTogJ0wnLFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjYWxlbmRhcihrZXksIG1vbSwgbm93KSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9jYWxlbmRhcltrZXldIHx8IHRoaXMuX2NhbGVuZGFyWydzYW1lRWxzZSddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihvdXRwdXQpID8gb3V0cHV0LmNhbGwobW9tLCBub3cpIDogb3V0cHV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHplcm9GaWxsKG51bWJlciwgdGFyZ2V0TGVuZ3RoLCBmb3JjZVNpZ24pIHtcbiAgICAgICAgdmFyIGFic051bWJlciA9ICcnICsgTWF0aC5hYnMobnVtYmVyKSxcbiAgICAgICAgICAgIHplcm9zVG9GaWxsID0gdGFyZ2V0TGVuZ3RoIC0gYWJzTnVtYmVyLmxlbmd0aCxcbiAgICAgICAgICAgIHNpZ24gPSBudW1iZXIgPj0gMDtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChzaWduID8gKGZvcmNlU2lnbiA/ICcrJyA6ICcnKSA6ICctJykgK1xuICAgICAgICAgICAgTWF0aC5wb3coMTAsIE1hdGgubWF4KDAsIHplcm9zVG9GaWxsKSkudG9TdHJpbmcoKS5zdWJzdHIoMSkgK1xuICAgICAgICAgICAgYWJzTnVtYmVyXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGZvcm1hdHRpbmdUb2tlbnMgPVxuICAgICAgICAgICAgLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KFtIaF1tbShzcyk/fE1vfE1NP00/TT98RG98REREb3xERD9EP0Q/fGRkZD9kP3xkbz98d1tvfHddP3xXW298V10/fFFvP3xOezEsNX18WVlZWVlZfFlZWVlZfFlZWVl8WVl8eXsyLDR9fHlvP3xnZyhnZ2c/KT98R0coR0dHPyk/fGV8RXxhfEF8aGg/fEhIP3xraz98bW0/fHNzP3xTezEsOX18eHxYfHp6P3xaWj98LikvZyxcbiAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KExUU3xMVHxMTD9MP0w/fGx7MSw0fSkvZyxcbiAgICAgICAgZm9ybWF0RnVuY3Rpb25zID0ge30sXG4gICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zID0ge307XG5cbiAgICAvLyB0b2tlbjogICAgJ00nXG4gICAgLy8gcGFkZGVkOiAgIFsnTU0nLCAyXVxuICAgIC8vIG9yZGluYWw6ICAnTW8nXG4gICAgLy8gY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHsgdGhpcy5tb250aCgpICsgMSB9XG4gICAgZnVuY3Rpb24gYWRkRm9ybWF0VG9rZW4odG9rZW4sIHBhZGRlZCwgb3JkaW5hbCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbY2FsbGJhY2tdKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dID0gZnVuYztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFkZGVkKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1twYWRkZWRbMF1dID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB6ZXJvRmlsbChmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHBhZGRlZFsxXSwgcGFkZGVkWzJdKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yZGluYWwpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW29yZGluYWxdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5vcmRpbmFsKFxuICAgICAgICAgICAgICAgICAgICBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgICAgIHRva2VuXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGlucHV0KSB7XG4gICAgICAgIGlmIChpbnB1dC5tYXRjaCgvXFxbW1xcc1xcU10vKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL15cXFt8XFxdJC9nLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1xcXFwvZywgJycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gZm9ybWF0Lm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXSkge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoYXJyYXlbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtb20pIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSAnJyxcbiAgICAgICAgICAgICAgICBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGlzRnVuY3Rpb24oYXJyYXlbaV0pXG4gICAgICAgICAgICAgICAgICAgID8gYXJyYXlbaV0uY2FsbChtb20sIGZvcm1hdClcbiAgICAgICAgICAgICAgICAgICAgOiBhcnJheVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gZm9ybWF0IGRhdGUgdXNpbmcgbmF0aXZlIGRhdGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gZm9ybWF0TW9tZW50KG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbS5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGV4cGFuZEZvcm1hdChmb3JtYXQsIG0ubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gPVxuICAgICAgICAgICAgZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gfHwgbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCk7XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdKG0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cGFuZEZvcm1hdChmb3JtYXQsIGxvY2FsZSkge1xuICAgICAgICB2YXIgaSA9IDU7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLmxvbmdEYXRlRm9ybWF0KGlucHV0KSB8fCBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoaSA+PSAwICYmIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy50ZXN0KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKFxuICAgICAgICAgICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2VucyxcbiAgICAgICAgICAgICAgICByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb25nRGF0ZUZvcm1hdCA9IHtcbiAgICAgICAgTFRTOiAnaDptbTpzcyBBJyxcbiAgICAgICAgTFQ6ICdoOm1tIEEnLFxuICAgICAgICBMOiAnTU0vREQvWVlZWScsXG4gICAgICAgIExMOiAnTU1NTSBELCBZWVlZJyxcbiAgICAgICAgTExMOiAnTU1NTSBELCBZWVlZIGg6bW0gQScsXG4gICAgICAgIExMTEw6ICdkZGRkLCBNTU1NIEQsIFlZWVkgaDptbSBBJyxcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9uZ0RhdGVGb3JtYXQoa2V5KSB7XG4gICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldLFxuICAgICAgICAgICAgZm9ybWF0VXBwZXIgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXkudG9VcHBlckNhc2UoKV07XG5cbiAgICAgICAgaWYgKGZvcm1hdCB8fCAhZm9ybWF0VXBwZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldID0gZm9ybWF0VXBwZXJcbiAgICAgICAgICAgIC5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodG9rKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICB0b2sgPT09ICdNTU1NJyB8fFxuICAgICAgICAgICAgICAgICAgICB0b2sgPT09ICdNTScgfHxcbiAgICAgICAgICAgICAgICAgICAgdG9rID09PSAnREQnIHx8XG4gICAgICAgICAgICAgICAgICAgIHRvayA9PT0gJ2RkZGQnXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2suc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0b2s7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJycpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0SW52YWxpZERhdGUgPSAnSW52YWxpZCBkYXRlJztcblxuICAgIGZ1bmN0aW9uIGludmFsaWREYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52YWxpZERhdGU7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRPcmRpbmFsID0gJyVkJyxcbiAgICAgICAgZGVmYXVsdERheU9mTW9udGhPcmRpbmFsUGFyc2UgPSAvXFxkezEsMn0vO1xuXG4gICAgZnVuY3Rpb24gb3JkaW5hbChudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yZGluYWwucmVwbGFjZSgnJWQnLCBudW1iZXIpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0UmVsYXRpdmVUaW1lID0ge1xuICAgICAgICBmdXR1cmU6ICdpbiAlcycsXG4gICAgICAgIHBhc3Q6ICclcyBhZ28nLFxuICAgICAgICBzOiAnYSBmZXcgc2Vjb25kcycsXG4gICAgICAgIHNzOiAnJWQgc2Vjb25kcycsXG4gICAgICAgIG06ICdhIG1pbnV0ZScsXG4gICAgICAgIG1tOiAnJWQgbWludXRlcycsXG4gICAgICAgIGg6ICdhbiBob3VyJyxcbiAgICAgICAgaGg6ICclZCBob3VycycsXG4gICAgICAgIGQ6ICdhIGRheScsXG4gICAgICAgIGRkOiAnJWQgZGF5cycsXG4gICAgICAgIHc6ICdhIHdlZWsnLFxuICAgICAgICB3dzogJyVkIHdlZWtzJyxcbiAgICAgICAgTTogJ2EgbW9udGgnLFxuICAgICAgICBNTTogJyVkIG1vbnRocycsXG4gICAgICAgIHk6ICdhIHllYXInLFxuICAgICAgICB5eTogJyVkIHllYXJzJyxcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcmVsYXRpdmVUaW1lKG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW3N0cmluZ107XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKG91dHB1dClcbiAgICAgICAgICAgID8gb3V0cHV0KG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSlcbiAgICAgICAgICAgIDogb3V0cHV0LnJlcGxhY2UoLyVkL2ksIG51bWJlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFzdEZ1dHVyZShkaWZmLCBvdXRwdXQpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX3JlbGF0aXZlVGltZVtkaWZmID4gMCA/ICdmdXR1cmUnIDogJ3Bhc3QnXTtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oZm9ybWF0KSA/IGZvcm1hdChvdXRwdXQpIDogZm9ybWF0LnJlcGxhY2UoLyVzL2ksIG91dHB1dCk7XG4gICAgfVxuXG4gICAgdmFyIGFsaWFzZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFVuaXRBbGlhcyh1bml0LCBzaG9ydGhhbmQpIHtcbiAgICAgICAgdmFyIGxvd2VyQ2FzZSA9IHVuaXQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgYWxpYXNlc1tsb3dlckNhc2VdID0gYWxpYXNlc1tsb3dlckNhc2UgKyAncyddID0gYWxpYXNlc1tzaG9ydGhhbmRdID0gdW5pdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVVbml0cyh1bml0cykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHVuaXRzID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyBhbGlhc2VzW3VuaXRzXSB8fCBhbGlhc2VzW3VuaXRzLnRvTG93ZXJDYXNlKCldXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVPYmplY3RVbml0cyhpbnB1dE9iamVjdCkge1xuICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0ge30sXG4gICAgICAgICAgICBub3JtYWxpemVkUHJvcCxcbiAgICAgICAgICAgIHByb3A7XG5cbiAgICAgICAgZm9yIChwcm9wIGluIGlucHV0T2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChpbnB1dE9iamVjdCwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkUHJvcCA9IG5vcm1hbGl6ZVVuaXRzKHByb3ApO1xuICAgICAgICAgICAgICAgIGlmIChub3JtYWxpemVkUHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkSW5wdXRbbm9ybWFsaXplZFByb3BdID0gaW5wdXRPYmplY3RbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRJbnB1dDtcbiAgICB9XG5cbiAgICB2YXIgcHJpb3JpdGllcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkVW5pdFByaW9yaXR5KHVuaXQsIHByaW9yaXR5KSB7XG4gICAgICAgIHByaW9yaXRpZXNbdW5pdF0gPSBwcmlvcml0eTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzT2JqKSB7XG4gICAgICAgIHZhciB1bml0cyA9IFtdLFxuICAgICAgICAgICAgdTtcbiAgICAgICAgZm9yICh1IGluIHVuaXRzT2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcCh1bml0c09iaiwgdSkpIHtcbiAgICAgICAgICAgICAgICB1bml0cy5wdXNoKHsgdW5pdDogdSwgcHJpb3JpdHk6IHByaW9yaXRpZXNbdV0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHVuaXRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4gKHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDApIHx8IHllYXIgJSA0MDAgPT09IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzRmxvb3IobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICAvLyAtMCAtPiAwXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcikgfHwgMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0ludChhcmd1bWVudEZvckNvZXJjaW9uKSB7XG4gICAgICAgIHZhciBjb2VyY2VkTnVtYmVyID0gK2FyZ3VtZW50Rm9yQ29lcmNpb24sXG4gICAgICAgICAgICB2YWx1ZSA9IDA7XG5cbiAgICAgICAgaWYgKGNvZXJjZWROdW1iZXIgIT09IDAgJiYgaXNGaW5pdGUoY29lcmNlZE51bWJlcikpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYWJzRmxvb3IoY29lcmNlZE51bWJlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldFNldCh1bml0LCBrZWVwVGltZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNldCQxKHRoaXMsIHVuaXQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywga2VlcFRpbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0KHRoaXMsIHVuaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldChtb20sIHVuaXQpIHtcbiAgICAgICAgcmV0dXJuIG1vbS5pc1ZhbGlkKClcbiAgICAgICAgICAgID8gbW9tLl9kWydnZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKClcbiAgICAgICAgICAgIDogTmFOO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldCQxKG1vbSwgdW5pdCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG1vbS5pc1ZhbGlkKCkgJiYgIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHVuaXQgPT09ICdGdWxsWWVhcicgJiZcbiAgICAgICAgICAgICAgICBpc0xlYXBZZWFyKG1vbS55ZWFyKCkpICYmXG4gICAgICAgICAgICAgICAgbW9tLm1vbnRoKCkgPT09IDEgJiZcbiAgICAgICAgICAgICAgICBtb20uZGF0ZSgpID09PSAyOVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b0ludCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgbW9tLm1vbnRoKCksXG4gICAgICAgICAgICAgICAgICAgIGRheXNJbk1vbnRoKHZhbHVlLCBtb20ubW9udGgoKSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gc3RyaW5nR2V0KHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0cmluZ1NldCh1bml0cywgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB1bml0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplT2JqZWN0VW5pdHModW5pdHMpO1xuICAgICAgICAgICAgdmFyIHByaW9yaXRpemVkID0gZ2V0UHJpb3JpdGl6ZWRVbml0cyh1bml0cyksXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBwcmlvcml0aXplZExlbiA9IHByaW9yaXRpemVkLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwcmlvcml0aXplZExlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpc1twcmlvcml0aXplZFtpXS51bml0XSh1bml0c1twcmlvcml0aXplZFtpXS51bml0XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbdW5pdHNdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoMSA9IC9cXGQvLCAvLyAgICAgICAwIC0gOVxuICAgICAgICBtYXRjaDIgPSAvXFxkXFxkLywgLy8gICAgICAwMCAtIDk5XG4gICAgICAgIG1hdGNoMyA9IC9cXGR7M30vLCAvLyAgICAgMDAwIC0gOTk5XG4gICAgICAgIG1hdGNoNCA9IC9cXGR7NH0vLCAvLyAgICAwMDAwIC0gOTk5OVxuICAgICAgICBtYXRjaDYgPSAvWystXT9cXGR7Nn0vLCAvLyAtOTk5OTk5IC0gOTk5OTk5XG4gICAgICAgIG1hdGNoMXRvMiA9IC9cXGRcXGQ/LywgLy8gICAgICAgMCAtIDk5XG4gICAgICAgIG1hdGNoM3RvNCA9IC9cXGRcXGRcXGRcXGQ/LywgLy8gICAgIDk5OSAtIDk5OTlcbiAgICAgICAgbWF0Y2g1dG82ID0gL1xcZFxcZFxcZFxcZFxcZFxcZD8vLCAvLyAgIDk5OTk5IC0gOTk5OTk5XG4gICAgICAgIG1hdGNoMXRvMyA9IC9cXGR7MSwzfS8sIC8vICAgICAgIDAgLSA5OTlcbiAgICAgICAgbWF0Y2gxdG80ID0gL1xcZHsxLDR9LywgLy8gICAgICAgMCAtIDk5OTlcbiAgICAgICAgbWF0Y2gxdG82ID0gL1srLV0/XFxkezEsNn0vLCAvLyAtOTk5OTk5IC0gOTk5OTk5XG4gICAgICAgIG1hdGNoVW5zaWduZWQgPSAvXFxkKy8sIC8vICAgICAgIDAgLSBpbmZcbiAgICAgICAgbWF0Y2hTaWduZWQgPSAvWystXT9cXGQrLywgLy8gICAgLWluZiAtIGluZlxuICAgICAgICBtYXRjaE9mZnNldCA9IC9afFsrLV1cXGRcXGQ6P1xcZFxcZC9naSwgLy8gKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG4gICAgICAgIG1hdGNoU2hvcnRPZmZzZXQgPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy9naSwgLy8gKzAwIC0wMCArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcbiAgICAgICAgbWF0Y2hUaW1lc3RhbXAgPSAvWystXT9cXGQrKFxcLlxcZHsxLDN9KT8vLCAvLyAxMjM0NTY3ODkgMTIzNDU2Nzg5LjEyM1xuICAgICAgICAvLyBhbnkgd29yZCAob3IgdHdvKSBjaGFyYWN0ZXJzIG9yIG51bWJlcnMgaW5jbHVkaW5nIHR3by90aHJlZSB3b3JkIG1vbnRoIGluIGFyYWJpYy5cbiAgICAgICAgLy8gaW5jbHVkZXMgc2NvdHRpc2ggZ2FlbGljIHR3byB3b3JkIGFuZCBoeXBoZW5hdGVkIG1vbnRoc1xuICAgICAgICBtYXRjaFdvcmQgPVxuICAgICAgICAgICAgL1swLTldezAsMjU2fVsnYS16XFx1MDBBMC1cXHUwNUZGXFx1MDcwMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRjA3XFx1RkYxMC1cXHVGRkVGXXsxLDI1Nn18W1xcdTA2MDAtXFx1MDZGRlxcL117MSwyNTZ9KFxccyo/W1xcdTA2MDAtXFx1MDZGRl17MSwyNTZ9KXsxLDJ9L2ksXG4gICAgICAgIHJlZ2V4ZXM7XG5cbiAgICByZWdleGVzID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRSZWdleFRva2VuKHRva2VuLCByZWdleCwgc3RyaWN0UmVnZXgpIHtcbiAgICAgICAgcmVnZXhlc1t0b2tlbl0gPSBpc0Z1bmN0aW9uKHJlZ2V4KVxuICAgICAgICAgICAgPyByZWdleFxuICAgICAgICAgICAgOiBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZURhdGEpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpc1N0cmljdCAmJiBzdHJpY3RSZWdleCA/IHN0cmljdFJlZ2V4IDogcmVnZXg7XG4gICAgICAgICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHJlZ2V4ZXMsIHRva2VuKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodW5lc2NhcGVGb3JtYXQodG9rZW4pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWdleGVzW3Rva2VuXShjb25maWcuX3N0cmljdCwgY29uZmlnLl9sb2NhbGUpO1xuICAgIH1cblxuICAgIC8vIENvZGUgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM1NjE0OTMvaXMtdGhlcmUtYS1yZWdleHAtZXNjYXBlLWZ1bmN0aW9uLWluLWphdmFzY3JpcHRcbiAgICBmdW5jdGlvbiB1bmVzY2FwZUZvcm1hdChzKSB7XG4gICAgICAgIHJldHVybiByZWdleEVzY2FwZShcbiAgICAgICAgICAgIHNcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgnXFxcXCcsICcnKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgICAvXFxcXChcXFspfFxcXFwoXFxdKXxcXFsoW15cXF1cXFtdKilcXF18XFxcXCguKS9nLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAobWF0Y2hlZCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwMSB8fCBwMiB8fCBwMyB8fCBwNDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWdleEVzY2FwZShzKSB7XG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuICAgIH1cblxuICAgIHZhciB0b2tlbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFBhcnNlVG9rZW4odG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgZnVuYyA9IGNhbGxiYWNrLFxuICAgICAgICAgICAgdG9rZW5MZW47XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0b2tlbiA9IFt0b2tlbl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTnVtYmVyKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgICAgICAgICBhcnJheVtjYWxsYmFja10gPSB0b0ludChpbnB1dCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRva2VuTGVuID0gdG9rZW4ubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5MZW47IGkrKykge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuW2ldXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrUGFyc2VUb2tlbih0b2tlbiwgY2FsbGJhY2spIHtcbiAgICAgICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICAgICAgY29uZmlnLl93ID0gY29uZmlnLl93IHx8IHt9O1xuICAgICAgICAgICAgY2FsbGJhY2soaW5wdXQsIGNvbmZpZy5fdywgY29uZmlnLCB0b2tlbik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBpbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsICYmIGhhc093blByb3AodG9rZW5zLCB0b2tlbikpIHtcbiAgICAgICAgICAgIHRva2Vuc1t0b2tlbl0oaW5wdXQsIGNvbmZpZy5fYSwgY29uZmlnLCB0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgWUVBUiA9IDAsXG4gICAgICAgIE1PTlRIID0gMSxcbiAgICAgICAgREFURSA9IDIsXG4gICAgICAgIEhPVVIgPSAzLFxuICAgICAgICBNSU5VVEUgPSA0LFxuICAgICAgICBTRUNPTkQgPSA1LFxuICAgICAgICBNSUxMSVNFQ09ORCA9IDYsXG4gICAgICAgIFdFRUsgPSA3LFxuICAgICAgICBXRUVLREFZID0gODtcblxuICAgIGZ1bmN0aW9uIG1vZChuLCB4KSB7XG4gICAgICAgIHJldHVybiAoKG4gJSB4KSArIHgpICUgeDtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXhPZjtcblxuICAgIGlmIChBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuICAgICAgICBpbmRleE9mID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2Y7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXhPZiA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICAvLyBJIGtub3dcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpc1tpXSA9PT0gbykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c0luTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICAgICAgaWYgKGlzTmFOKHllYXIpIHx8IGlzTmFOKG1vbnRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbW9kTW9udGggPSBtb2QobW9udGgsIDEyKTtcbiAgICAgICAgeWVhciArPSAobW9udGggLSBtb2RNb250aCkgLyAxMjtcbiAgICAgICAgcmV0dXJuIG1vZE1vbnRoID09PSAxXG4gICAgICAgICAgICA/IGlzTGVhcFllYXIoeWVhcilcbiAgICAgICAgICAgICAgICA/IDI5XG4gICAgICAgICAgICAgICAgOiAyOFxuICAgICAgICAgICAgOiAzMSAtICgobW9kTW9udGggJSA3KSAlIDIpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNJywgWydNTScsIDJdLCAnTW8nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vbnRoKCkgKyAxO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRoc1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignTU1NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRocyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtb250aCcsICdNJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdtb250aCcsIDgpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignTScsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignTU0nLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignTU1NJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU1NJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTScsICdNTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9IHRvSW50KGlucHV0KSAtIDE7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTU1NJywgJ01NTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB2YXIgbW9udGggPSBjb25maWcuX2xvY2FsZS5tb250aHNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGZpbmQgYSBtb250aCBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWQuXG4gICAgICAgIGlmIChtb250aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhcnJheVtNT05USF0gPSBtb250aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRNb250aCA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1vbnRocyA9XG4gICAgICAgICAgICAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoXG4gICAgICAgICAgICAgICAgJ18nXG4gICAgICAgICAgICApLFxuICAgICAgICBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQgPVxuICAgICAgICAgICAgJ0phbl9GZWJfTWFyX0Fwcl9NYXlfSnVuX0p1bF9BdWdfU2VwX09jdF9Ob3ZfRGVjJy5zcGxpdCgnXycpLFxuICAgICAgICBNT05USFNfSU5fRk9STUFUID0gL0Rbb0RdPyhcXFtbXlxcW1xcXV0qXFxdfFxccykrTU1NTT8vLFxuICAgICAgICBkZWZhdWx0TW9udGhzU2hvcnRSZWdleCA9IG1hdGNoV29yZCxcbiAgICAgICAgZGVmYXVsdE1vbnRoc1JlZ2V4ID0gbWF0Y2hXb3JkO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzKG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocylcbiAgICAgICAgICAgICAgICA/IHRoaXMuX21vbnRoc1xuICAgICAgICAgICAgICAgIDogdGhpcy5fbW9udGhzWydzdGFuZGFsb25lJ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKVxuICAgICAgICAgICAgPyB0aGlzLl9tb250aHNbbS5tb250aCgpXVxuICAgICAgICAgICAgOiB0aGlzLl9tb250aHNbXG4gICAgICAgICAgICAgICAgICAodGhpcy5fbW9udGhzLmlzRm9ybWF0IHx8IE1PTlRIU19JTl9GT1JNQVQpLnRlc3QoZm9ybWF0KVxuICAgICAgICAgICAgICAgICAgICAgID8gJ2Zvcm1hdCdcbiAgICAgICAgICAgICAgICAgICAgICA6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgICAgICBdW20ubW9udGgoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzU2hvcnQobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzU2hvcnQpXG4gICAgICAgICAgICAgICAgPyB0aGlzLl9tb250aHNTaG9ydFxuICAgICAgICAgICAgICAgIDogdGhpcy5fbW9udGhzU2hvcnRbJ3N0YW5kYWxvbmUnXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHNTaG9ydClcbiAgICAgICAgICAgID8gdGhpcy5fbW9udGhzU2hvcnRbbS5tb250aCgpXVxuICAgICAgICAgICAgOiB0aGlzLl9tb250aHNTaG9ydFtcbiAgICAgICAgICAgICAgICAgIE1PTlRIU19JTl9GT1JNQVQudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICAgICAgXVttLm1vbnRoKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVN0cmljdFBhcnNlKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBpaSxcbiAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgIGxsYyA9IG1vbnRoTmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCB1c2VkXG4gICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7ICsraSkge1xuICAgICAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSB0aGlzLm1vbnRoc1Nob3J0KFxuICAgICAgICAgICAgICAgICAgICBtb20sXG4gICAgICAgICAgICAgICAgICAgICcnXG4gICAgICAgICAgICAgICAgKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1BhcnNlKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVTdHJpY3RQYXJzZS5jYWxsKHRoaXMsIG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogYWRkIHNvcnRpbmdcbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlclxuICAgICAgICAvLyBzZWUgc29ydGluZyBpbiBjb21wdXRlTW9udGhzUGFyc2VcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLFxuICAgICAgICAgICAgICAgICAgICAnaSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAnXicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsXG4gICAgICAgICAgICAgICAgICAgICdpJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN0cmljdCAmJiAhdGhpcy5fbW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICByZWdleCA9XG4gICAgICAgICAgICAgICAgICAgICdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHN0cmljdCAmJlxuICAgICAgICAgICAgICAgIGZvcm1hdCA9PT0gJ01NTU0nICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHN0cmljdCAmJlxuICAgICAgICAgICAgICAgIGZvcm1hdCA9PT0gJ01NTScgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fbW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBzZXRNb250aChtb20sIHZhbHVlKSB7XG4gICAgICAgIHZhciBkYXlPZk1vbnRoO1xuXG4gICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKC9eXFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b0ludCh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbW9tLmxvY2FsZURhdGEoKS5tb250aHNQYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogQW5vdGhlciBzaWxlbnQgZmFpbHVyZT9cbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRheU9mTW9udGggPSBNYXRoLm1pbihtb20uZGF0ZSgpLCBkYXlzSW5Nb250aChtb20ueWVhcigpLCB2YWx1ZSkpO1xuICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgJ01vbnRoJ10odmFsdWUsIGRheU9mTW9udGgpO1xuICAgICAgICByZXR1cm4gbW9tO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldE1vbnRoKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRNb250aCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQodGhpcywgJ01vbnRoJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXlzSW5Nb250aCgpIHtcbiAgICAgICAgcmV0dXJuIGRheXNJbk1vbnRoKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoc1Nob3J0UmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1Nob3J0UmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSBkZWZhdWx0TW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhzUmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1JlZ2V4ID0gZGVmYXVsdE1vbnRoc1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLl9tb250aHNTdHJpY3RSZWdleFxuICAgICAgICAgICAgICAgIDogdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlTW9udGhzUGFyc2UoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNtcExlblJldihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaG9ydFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbG9uZ1BpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBtb207XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgc2hvcnRQaWVjZXMucHVzaCh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlciBpdFxuICAgICAgICAvLyB3aWxsIG1hdGNoIHRoZSBsb25nZXIgcGllY2UuXG4gICAgICAgIHNob3J0UGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbG9uZ1BpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIG1peGVkUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIHNob3J0UGllY2VzW2ldID0gcmVnZXhFc2NhcGUoc2hvcnRQaWVjZXNbaV0pO1xuICAgICAgICAgICAgbG9uZ1BpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKGxvbmdQaWVjZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAyNDsgaSsrKSB7XG4gICAgICAgICAgICBtaXhlZFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKG1peGVkUGllY2VzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21vbnRoc1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJyxcbiAgICAgICAgICAgICdpJ1xuICAgICAgICApO1xuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsXG4gICAgICAgICAgICAnaSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignWScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnllYXIoKTtcbiAgICAgICAgcmV0dXJuIHkgPD0gOTk5OSA/IHplcm9GaWxsKHksIDQpIDogJysnICsgeTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVknLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy55ZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVknLCA0XSwgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZJywgNV0sIDAsICd5ZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWVknLCA2LCB0cnVlXSwgMCwgJ3llYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygneWVhcicsICd5Jyk7XG5cbiAgICAvLyBQUklPUklUSUVTXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3llYXInLCAxKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1knLCBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWVknLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWScsIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWScsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWVknLCBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnWVlZWVknLCAnWVlZWVlZJ10sIFlFQVIpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1lZWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID1cbiAgICAgICAgICAgIGlucHV0Lmxlbmd0aCA9PT0gMiA/IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KSA6IHRvSW50KGlucHV0KTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBwYXJzZUludChpbnB1dCwgMTApO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gZGF5c0luWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHllYXIpID8gMzY2IDogMzY1O1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICBob29rcy5wYXJzZVR3b0RpZ2l0WWVhciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gdG9JbnQoaW5wdXQpICsgKHRvSW50KGlucHV0KSA+IDY4ID8gMTkwMCA6IDIwMDApO1xuICAgIH07XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0WWVhciA9IG1ha2VHZXRTZXQoJ0Z1bGxZZWFyJywgdHJ1ZSk7XG5cbiAgICBmdW5jdGlvbiBnZXRJc0xlYXBZZWFyKCkge1xuICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih0aGlzLnllYXIoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRGF0ZSh5LCBtLCBkLCBoLCBNLCBzLCBtcykge1xuICAgICAgICAvLyBjYW4ndCBqdXN0IGFwcGx5KCkgdG8gY3JlYXRlIGEgZGF0ZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzE4MTM0OFxuICAgICAgICB2YXIgZGF0ZTtcbiAgICAgICAgLy8gdGhlIGRhdGUgY29uc3RydWN0b3IgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh5ICsgNDAwLCBtLCBkLCBoLCBNLCBzLCBtcyk7XG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUoZGF0ZS5nZXRGdWxsWWVhcigpKSkge1xuICAgICAgICAgICAgICAgIGRhdGUuc2V0RnVsbFllYXIoeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVVRDRGF0ZSh5KSB7XG4gICAgICAgIHZhciBkYXRlLCBhcmdzO1xuICAgICAgICAvLyB0aGUgRGF0ZS5VVEMgZnVuY3Rpb24gcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgYXJnc1swXSA9IHkgKyA0MDA7XG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJncykpO1xuICAgICAgICAgICAgaWYgKGlzRmluaXRlKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSkpIHtcbiAgICAgICAgICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgLy8gc3RhcnQtb2YtZmlyc3Qtd2VlayAtIHN0YXJ0LW9mLXllYXJcbiAgICBmdW5jdGlvbiBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIC8vIGZpcnN0LXdlZWsgZGF5IC0tIHdoaWNoIGphbnVhcnkgaXMgYWx3YXlzIGluIHRoZSBmaXJzdCB3ZWVrICg0IGZvciBpc28sIDEgZm9yIG90aGVyKVxuICAgICAgICAgICAgZndkID0gNyArIGRvdyAtIGRveSxcbiAgICAgICAgICAgIC8vIGZpcnN0LXdlZWsgZGF5IGxvY2FsIHdlZWtkYXkgLS0gd2hpY2ggbG9jYWwgd2Vla2RheSBpcyBmd2RcbiAgICAgICAgICAgIGZ3ZGx3ID0gKDcgKyBjcmVhdGVVVENEYXRlKHllYXIsIDAsIGZ3ZCkuZ2V0VVRDRGF5KCkgLSBkb3cpICUgNztcblxuICAgICAgICByZXR1cm4gLWZ3ZGx3ICsgZndkIC0gMTtcbiAgICB9XG5cbiAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlI0NhbGN1bGF0aW5nX2FfZGF0ZV9naXZlbl90aGVfeWVhci4yQ193ZWVrX251bWJlcl9hbmRfd2Vla2RheVxuICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrcyh5ZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgbG9jYWxXZWVrZGF5ID0gKDcgKyB3ZWVrZGF5IC0gZG93KSAlIDcsXG4gICAgICAgICAgICB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgICAgIGRheU9mWWVhciA9IDEgKyA3ICogKHdlZWsgLSAxKSArIGxvY2FsV2Vla2RheSArIHdlZWtPZmZzZXQsXG4gICAgICAgICAgICByZXNZZWFyLFxuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyO1xuXG4gICAgICAgIGlmIChkYXlPZlllYXIgPD0gMCkge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXIgLSAxO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5c0luWWVhcihyZXNZZWFyKSArIGRheU9mWWVhcjtcbiAgICAgICAgfSBlbHNlIGlmIChkYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXIpKSB7XG4gICAgICAgICAgICByZXNZZWFyID0geWVhciArIDE7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXIgLSBkYXlzSW5ZZWFyKHllYXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXI7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcjogcmVzWWVhcixcbiAgICAgICAgICAgIGRheU9mWWVhcjogcmVzRGF5T2ZZZWFyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtPZlllYXIobW9tLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldChtb20ueWVhcigpLCBkb3csIGRveSksXG4gICAgICAgICAgICB3ZWVrID0gTWF0aC5mbG9vcigobW9tLmRheU9mWWVhcigpIC0gd2Vla09mZnNldCAtIDEpIC8gNykgKyAxLFxuICAgICAgICAgICAgcmVzV2VlayxcbiAgICAgICAgICAgIHJlc1llYXI7XG5cbiAgICAgICAgaWYgKHdlZWsgPCAxKSB7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSAtIDE7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlayArIHdlZWtzSW5ZZWFyKHJlc1llYXIsIGRvdywgZG95KTtcbiAgICAgICAgfSBlbHNlIGlmICh3ZWVrID4gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpKSB7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlayAtIHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KTtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpO1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2VlazogcmVzV2VlayxcbiAgICAgICAgICAgIHllYXI6IHJlc1llYXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla3NJblllYXIoeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICAgICAgd2Vla09mZnNldE5leHQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciArIDEsIGRvdywgZG95KTtcbiAgICAgICAgcmV0dXJuIChkYXlzSW5ZZWFyKHllYXIpIC0gd2Vla09mZnNldCArIHdlZWtPZmZzZXROZXh0KSAvIDc7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3cnLCBbJ3d3JywgMl0sICd3bycsICd3ZWVrJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ1cnLCBbJ1dXJywgMl0sICdXbycsICdpc29XZWVrJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWsnLCAndycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2VlaycsICdXJyk7XG5cbiAgICAvLyBQUklPUklUSUVTXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWsnLCA1KTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWsnLCA1KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3cnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3d3JywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1cnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1dXJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oXG4gICAgICAgIFsndycsICd3dycsICdXJywgJ1dXJ10sXG4gICAgICAgIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMSldID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIExPQ0FMRVNcblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWsobW9tKSB7XG4gICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKG1vbSwgdGhpcy5fd2Vlay5kb3csIHRoaXMuX3dlZWsuZG95KS53ZWVrO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2VlayA9IHtcbiAgICAgICAgZG93OiAwLCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgZG95OiA2LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA2dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZXZWVrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZlllYXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrLmRveTtcbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gdGhpcy5sb2NhbGVEYXRhKCkud2Vlayh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWsoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB3ZWVrT2ZZZWFyKHRoaXMsIDEsIDQpLndlZWs7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignZCcsIDAsICdkbycsICdkYXknKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzTWluKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5cyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2UnLCAwLCAwLCAnd2Vla2RheScpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdFJywgMCwgMCwgJ2lzb1dlZWtkYXknKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF5JywgJ2QnKTtcbiAgICBhZGRVbml0QWxpYXMoJ3dlZWtkYXknLCAnZScpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla2RheScsICdFJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF5JywgMTEpO1xuICAgIGFkZFVuaXRQcmlvcml0eSgnd2Vla2RheScsIDExKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtkYXknLCAxMSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdkJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdlJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdFJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdkZCcsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNNaW5SZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignZGRkJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkZGQnLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydkZCcsICdkZGQnLCAnZGRkZCddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIHdlZWtkYXkgPSBjb25maWcuX2xvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZ2V0IGEgd2Vla2RheSBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWRcbiAgICAgICAgaWYgKHdlZWtkYXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgd2Vlay5kID0gd2Vla2RheTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRXZWVrZGF5ID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZCcsICdlJywgJ0UnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW5dID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlucHV0ID0gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VJc29XZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCkgJSA3IHx8IDc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzTmFOKGlucHV0KSA/IG51bGwgOiBpbnB1dDtcbiAgICB9XG5cbiAgICAvLyBMT0NBTEVTXG4gICAgZnVuY3Rpb24gc2hpZnRXZWVrZGF5cyh3cywgbikge1xuICAgICAgICByZXR1cm4gd3Muc2xpY2UobiwgNykuY29uY2F0KHdzLnNsaWNlKDAsIG4pKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzID1cbiAgICAgICAgICAgICdTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheScuc3BsaXQoJ18nKSxcbiAgICAgICAgZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQgPSAnU3VuX01vbl9UdWVfV2VkX1RodV9GcmlfU2F0Jy5zcGxpdCgnXycpLFxuICAgICAgICBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4gPSAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyksXG4gICAgICAgIGRlZmF1bHRXZWVrZGF5c1JlZ2V4ID0gbWF0Y2hXb3JkLFxuICAgICAgICBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkLFxuICAgICAgICBkZWZhdWx0V2Vla2RheXNNaW5SZWdleCA9IG1hdGNoV29yZDtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzKG0sIGZvcm1hdCkge1xuICAgICAgICB2YXIgd2Vla2RheXMgPSBpc0FycmF5KHRoaXMuX3dlZWtkYXlzKVxuICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c1xuICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1tcbiAgICAgICAgICAgICAgICAgIG0gJiYgbSAhPT0gdHJ1ZSAmJiB0aGlzLl93ZWVrZGF5cy5pc0Zvcm1hdC50ZXN0KGZvcm1hdClcbiAgICAgICAgICAgICAgICAgICAgICA/ICdmb3JtYXQnXG4gICAgICAgICAgICAgICAgICAgICAgOiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIG0gPT09IHRydWVcbiAgICAgICAgICAgID8gc2hpZnRXZWVrZGF5cyh3ZWVrZGF5cywgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgICAgICA6IG1cbiAgICAgICAgICAgID8gd2Vla2RheXNbbS5kYXkoKV1cbiAgICAgICAgICAgIDogd2Vla2RheXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNTaG9ydChtKSB7XG4gICAgICAgIHJldHVybiBtID09PSB0cnVlXG4gICAgICAgICAgICA/IHNoaWZ0V2Vla2RheXModGhpcy5fd2Vla2RheXNTaG9ydCwgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgICAgICA6IG1cbiAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNTaG9ydFttLmRheSgpXVxuICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1Nob3J0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzTWluKG0pIHtcbiAgICAgICAgcmV0dXJuIG0gPT09IHRydWVcbiAgICAgICAgICAgID8gc2hpZnRXZWVrZGF5cyh0aGlzLl93ZWVrZGF5c01pbiwgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgICAgICA6IG1cbiAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNNaW5bbS5kYXkoKV1cbiAgICAgICAgICAgIDogdGhpcy5fd2Vla2RheXNNaW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlU3RyaWN0UGFyc2UkMSh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBpaSxcbiAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgIGxsYyA9IHdlZWtkYXlOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyArK2kpIHtcbiAgICAgICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNNaW4oXG4gICAgICAgICAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgICAgICAgICAgJydcbiAgICAgICAgICAgICAgICApLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5c1Nob3J0KFxuICAgICAgICAgICAgICAgICAgICBtb20sXG4gICAgICAgICAgICAgICAgICAgICcnXG4gICAgICAgICAgICAgICAgKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1BhcnNlKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlU3RyaWN0UGFyc2UkMS5jYWxsKHRoaXMsIHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuXG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICAgICAgICAgJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLFxuICAgICAgICAgICAgICAgICAgICAnaSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgICAgICdeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLFxuICAgICAgICAgICAgICAgICAgICAnaSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAnXicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFxcXC4/JykgKyAnJCcsXG4gICAgICAgICAgICAgICAgICAgICdpJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICByZWdleCA9XG4gICAgICAgICAgICAgICAgICAgICdeJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2Vla2RheXMobW9tLCAnJykgK1xuICAgICAgICAgICAgICAgICAgICAnfF4nICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpICtcbiAgICAgICAgICAgICAgICAgICAgJ3xeJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgc3RyaWN0ICYmXG4gICAgICAgICAgICAgICAgZm9ybWF0ID09PSAnZGRkZCcgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHN0cmljdCAmJlxuICAgICAgICAgICAgICAgIGZvcm1hdCA9PT0gJ2RkZCcgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBzdHJpY3QgJiZcbiAgICAgICAgICAgICAgICBmb3JtYXQgPT09ICdkZCcgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZldlZWsoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXkgPSB0aGlzLl9pc1VUQyA/IHRoaXMuX2QuZ2V0VVRDRGF5KCkgOiB0aGlzLl9kLmdldERheSgpO1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaW5wdXQgPSBwYXJzZVdlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChpbnB1dCAtIGRheSwgJ2QnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRMb2NhbGVEYXlPZldlZWsoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gKHRoaXMuZGF5KCkgKyA3IC0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93KSAlIDc7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2Vla2RheSA6IHRoaXMuYWRkKGlucHV0IC0gd2Vla2RheSwgJ2QnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09EYXlPZldlZWsoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmVoYXZlcyB0aGUgc2FtZSBhcyBtb21lbnQjZGF5IGV4Y2VwdFxuICAgICAgICAvLyBhcyBhIGdldHRlciwgcmV0dXJucyA3IGluc3RlYWQgb2YgMCAoMS03IHJhbmdlIGluc3RlYWQgb2YgMC02KVxuICAgICAgICAvLyBhcyBhIHNldHRlciwgc3VuZGF5IHNob3VsZCBiZWxvbmcgdG8gdGhlIHByZXZpb3VzIHdlZWsuXG5cbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciB3ZWVrZGF5ID0gcGFyc2VJc29XZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXkodGhpcy5kYXkoKSAlIDcgPyB3ZWVrZGF5IDogd2Vla2RheSAtIDcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF5KCkgfHwgNztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtkYXlzUmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBkZWZhdWx0V2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla2RheXNTaG9ydFJlZ2V4KGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdFxuICAgICAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3ZWVrZGF5c01pblJlZ2V4KGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c01pblJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCAmJiBpc1N0cmljdFxuICAgICAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleFxuICAgICAgICAgICAgICAgIDogdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVXZWVrZGF5c1BhcnNlKCkge1xuICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWluUGllY2VzID0gW10sXG4gICAgICAgICAgICBzaG9ydFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbG9uZ1BpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBtb20sXG4gICAgICAgICAgICBtaW5wLFxuICAgICAgICAgICAgc2hvcnRwLFxuICAgICAgICAgICAgbG9uZ3A7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgbWlucCA9IHJlZ2V4RXNjYXBlKHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykpO1xuICAgICAgICAgICAgc2hvcnRwID0gcmVnZXhFc2NhcGUodGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgICAgIGxvbmdwID0gcmVnZXhFc2NhcGUodGhpcy53ZWVrZGF5cyhtb20sICcnKSk7XG4gICAgICAgICAgICBtaW5QaWVjZXMucHVzaChtaW5wKTtcbiAgICAgICAgICAgIHNob3J0UGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSB3ZWVrZGF5IChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICAgICAgbWluUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuXG4gICAgICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuXG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLFxuICAgICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLFxuICAgICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ14oJyArIG1pblBpZWNlcy5qb2luKCd8JykgKyAnKScsXG4gICAgICAgICAgICAnaSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBmdW5jdGlvbiBoRm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpICUgMTIgfHwgMTI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24ga0Zvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKSB8fCAyNDtcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSCcsIFsnSEgnLCAyXSwgMCwgJ2hvdXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignaCcsIFsnaGgnLCAyXSwgMCwgaEZvcm1hdCk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ2snLCBbJ2trJywgMl0sIDAsIGtGb3JtYXQpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdobW1zcycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICcnICtcbiAgICAgICAgICAgIGhGb3JtYXQuYXBwbHkodGhpcykgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKVxuICAgICAgICApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgJycgK1xuICAgICAgICAgICAgdGhpcy5ob3VycygpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXG4gICAgICAgICAgICB6ZXJvRmlsbCh0aGlzLnNlY29uZHMoKSwgMilcbiAgICAgICAgKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG1lcmlkaWVtKHRva2VuLCBsb3dlcmNhc2UpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tZXJpZGllbShcbiAgICAgICAgICAgICAgICB0aGlzLmhvdXJzKCksXG4gICAgICAgICAgICAgICAgdGhpcy5taW51dGVzKCksXG4gICAgICAgICAgICAgICAgbG93ZXJjYXNlXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtZXJpZGllbSgnYScsIHRydWUpO1xuICAgIG1lcmlkaWVtKCdBJywgZmFsc2UpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdob3VyJywgJ2gnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdob3VyJywgMTMpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgZnVuY3Rpb24gbWF0Y2hNZXJpZGllbShpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuX21lcmlkaWVtUGFyc2U7XG4gICAgfVxuXG4gICAgYWRkUmVnZXhUb2tlbignYScsIG1hdGNoTWVyaWRpZW0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0EnLCBtYXRjaE1lcmlkaWVtKTtcbiAgICBhZGRSZWdleFRva2VuKCdIJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdoJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdrJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdISCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdoaCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdraycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignaG1tc3MnLCBtYXRjaDV0bzYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignSG1tc3MnLCBtYXRjaDV0bzYpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0gnLCAnSEgnXSwgSE9VUik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2snLCAna2snXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBrSW5wdXQgPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGFycmF5W0hPVVJdID0ga0lucHV0ID09PSAyNCA/IDAgOiBrSW5wdXQ7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2EnLCAnQSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9pc1BtID0gY29uZmlnLl9sb2NhbGUuaXNQTShpbnB1dCk7XG4gICAgICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnaCcsICdoaCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNCxcbiAgICAgICAgICAgIHBvczIgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgICAgICBhcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczIpKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignSG1tJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MpKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdIbW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQsXG4gICAgICAgICAgICBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcbiAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICBmdW5jdGlvbiBsb2NhbGVJc1BNKGlucHV0KSB7XG4gICAgICAgIC8vIElFOCBRdWlya3MgTW9kZSAmIElFNyBTdGFuZGFyZHMgTW9kZSBkbyBub3QgYWxsb3cgYWNjZXNzaW5nIHN0cmluZ3MgbGlrZSBhcnJheXNcbiAgICAgICAgLy8gVXNpbmcgY2hhckF0IHNob3VsZCBiZSBtb3JlIGNvbXBhdGlibGUuXG4gICAgICAgIHJldHVybiAoaW5wdXQgKyAnJykudG9Mb3dlckNhc2UoKS5jaGFyQXQoMCkgPT09ICdwJztcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2UgPSAvW2FwXVxcLj9tP1xcLj8vaSxcbiAgICAgICAgLy8gU2V0dGluZyB0aGUgaG91ciBzaG91bGQga2VlcCB0aGUgdGltZSwgYmVjYXVzZSB0aGUgdXNlciBleHBsaWNpdGx5XG4gICAgICAgIC8vIHNwZWNpZmllZCB3aGljaCBob3VyIHRoZXkgd2FudC4gU28gdHJ5aW5nIHRvIG1haW50YWluIHRoZSBzYW1lIGhvdXIgKGluXG4gICAgICAgIC8vIGEgbmV3IHRpbWV6b25lKSBtYWtlcyBzZW5zZS4gQWRkaW5nL3N1YnRyYWN0aW5nIGhvdXJzIGRvZXMgbm90IGZvbGxvd1xuICAgICAgICAvLyB0aGlzIHJ1bGUuXG4gICAgICAgIGdldFNldEhvdXIgPSBtYWtlR2V0U2V0KCdIb3VycycsIHRydWUpO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlTWVyaWRpZW0oaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3BtJyA6ICdQTSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdhbScgOiAnQU0nO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGJhc2VDb25maWcgPSB7XG4gICAgICAgIGNhbGVuZGFyOiBkZWZhdWx0Q2FsZW5kYXIsXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0OiBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQsXG4gICAgICAgIGludmFsaWREYXRlOiBkZWZhdWx0SW52YWxpZERhdGUsXG4gICAgICAgIG9yZGluYWw6IGRlZmF1bHRPcmRpbmFsLFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSxcbiAgICAgICAgcmVsYXRpdmVUaW1lOiBkZWZhdWx0UmVsYXRpdmVUaW1lLFxuXG4gICAgICAgIG1vbnRoczogZGVmYXVsdExvY2FsZU1vbnRocyxcbiAgICAgICAgbW9udGhzU2hvcnQ6IGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCxcblxuICAgICAgICB3ZWVrOiBkZWZhdWx0TG9jYWxlV2VlayxcblxuICAgICAgICB3ZWVrZGF5czogZGVmYXVsdExvY2FsZVdlZWtkYXlzLFxuICAgICAgICB3ZWVrZGF5c01pbjogZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0OiBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCxcblxuICAgICAgICBtZXJpZGllbVBhcnNlOiBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZSxcbiAgICB9O1xuXG4gICAgLy8gaW50ZXJuYWwgc3RvcmFnZSBmb3IgbG9jYWxlIGNvbmZpZyBmaWxlc1xuICAgIHZhciBsb2NhbGVzID0ge30sXG4gICAgICAgIGxvY2FsZUZhbWlsaWVzID0ge30sXG4gICAgICAgIGdsb2JhbExvY2FsZTtcblxuICAgIGZ1bmN0aW9uIGNvbW1vblByZWZpeChhcnIxLCBhcnIyKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbWlubCA9IE1hdGgubWluKGFycjEubGVuZ3RoLCBhcnIyLmxlbmd0aCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBtaW5sOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChhcnIxW2ldICE9PSBhcnIyW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbmw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxlKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5ID8ga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICctJykgOiBrZXk7XG4gICAgfVxuXG4gICAgLy8gcGljayB0aGUgbG9jYWxlIGZyb20gdGhlIGFycmF5XG4gICAgLy8gdHJ5IFsnZW4tYXUnLCAnZW4tZ2InXSBhcyAnZW4tYXUnLCAnZW4tZ2InLCAnZW4nLCBhcyBpbiBtb3ZlIHRocm91Z2ggdGhlIGxpc3QgdHJ5aW5nIGVhY2hcbiAgICAvLyBzdWJzdHJpbmcgZnJvbSBtb3N0IHNwZWNpZmljIHRvIGxlYXN0LCBidXQgbW92ZSB0byB0aGUgbmV4dCBhcnJheSBpdGVtIGlmIGl0J3MgYSBtb3JlIHNwZWNpZmljIHZhcmlhbnQgdGhhbiB0aGUgY3VycmVudCByb290XG4gICAgZnVuY3Rpb24gY2hvb3NlTG9jYWxlKG5hbWVzKSB7XG4gICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgc3BsaXQ7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNwbGl0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2ldKS5zcGxpdCgnLScpO1xuICAgICAgICAgICAgaiA9IHNwbGl0Lmxlbmd0aDtcbiAgICAgICAgICAgIG5leHQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaSArIDFdKTtcbiAgICAgICAgICAgIG5leHQgPSBuZXh0ID8gbmV4dC5zcGxpdCgnLScpIDogbnVsbDtcbiAgICAgICAgICAgIHdoaWxlIChqID4gMCkge1xuICAgICAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoc3BsaXQuc2xpY2UoMCwgaikuam9pbignLScpKTtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgbmV4dCAmJlxuICAgICAgICAgICAgICAgICAgICBuZXh0Lmxlbmd0aCA+PSBqICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vblByZWZpeChzcGxpdCwgbmV4dCkgPj0gaiAtIDFcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy90aGUgbmV4dCBhcnJheSBpdGVtIGlzIGJldHRlciB0aGFuIGEgc2hhbGxvd2VyIHN1YnN0cmluZyBvZiB0aGlzIG9uZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMb2NhbGVOYW1lU2FuZShuYW1lKSB7XG4gICAgICAgIC8vIFByZXZlbnQgbmFtZXMgdGhhdCBsb29rIGxpa2UgZmlsZXN5c3RlbSBwYXRocywgaS5lIGNvbnRhaW4gJy8nIG9yICdcXCdcbiAgICAgICAgcmV0dXJuIG5hbWUubWF0Y2goJ15bXi9cXFxcXFxcXF0qJCcpICE9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZExvY2FsZShuYW1lKSB7XG4gICAgICAgIHZhciBvbGRMb2NhbGUgPSBudWxsLFxuICAgICAgICAgICAgYWxpYXNlZFJlcXVpcmU7XG4gICAgICAgIC8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIHJlZ2lzdGVyIGFuZCBsb2FkIGFsbCB0aGUgbG9jYWxlcyBpbiBOb2RlXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIG1vZHVsZSAmJlxuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgJiZcbiAgICAgICAgICAgIGlzTG9jYWxlTmFtZVNhbmUobmFtZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9sZExvY2FsZSA9IGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICAgICAgICAgICAgICBhbGlhc2VkUmVxdWlyZSA9IHJlcXVpcmU7XG4gICAgICAgICAgICAgICAgYWxpYXNlZFJlcXVpcmUoJy4vbG9jYWxlLycgKyBuYW1lKTtcbiAgICAgICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUob2xkTG9jYWxlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBtYXJrIGFzIG5vdCBmb3VuZCB0byBhdm9pZCByZXBlYXRpbmcgZXhwZW5zaXZlIGZpbGUgcmVxdWlyZSBjYWxsIGNhdXNpbmcgaGlnaCBDUFVcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRyeWluZyB0byBmaW5kIGVuLVVTLCBlbl9VUywgZW4tdXMgZm9yIGV2ZXJ5IGZvcm1hdCBjYWxsXG4gICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IG51bGw7IC8vIG51bGwgbWVhbnMgbm90IGZvdW5kXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbG9jYWxlIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxvY2FsZS4gIElmXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcbiAgICAvLyBsb2NhbGUga2V5LlxuICAgIGZ1bmN0aW9uIGdldFNldEdsb2JhbExvY2FsZShrZXksIHZhbHVlcykge1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkZWZpbmVMb2NhbGUoa2V5LCB2YWx1ZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIG1vbWVudC5kdXJhdGlvbi5fbG9jYWxlID0gbW9tZW50Ll9sb2NhbGUgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGdsb2JhbExvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vd2FybiB1c2VyIGlmIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGJ1dCB0aGUgbG9jYWxlIGNvdWxkIG5vdCBiZSBzZXRcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0xvY2FsZSAnICsga2V5ICsgJyBub3QgZm91bmQuIERpZCB5b3UgZm9yZ2V0IHRvIGxvYWQgaXQ/J1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGUuX2FiYnI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmaW5lTG9jYWxlKG5hbWUsIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxlLFxuICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgICAgICBjb25maWcuYWJiciA9IG5hbWU7XG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKFxuICAgICAgICAgICAgICAgICAgICAnZGVmaW5lTG9jYWxlT3ZlcnJpZGUnLFxuICAgICAgICAgICAgICAgICAgICAndXNlIG1vbWVudC51cGRhdGVMb2NhbGUobG9jYWxlTmFtZSwgY29uZmlnKSB0byBjaGFuZ2UgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYW4gZXhpc3RpbmcgbG9jYWxlLiBtb21lbnQuZGVmaW5lTG9jYWxlKGxvY2FsZU5hbWUsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbmZpZykgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RlZmluZS1sb2NhbGUvIGZvciBtb3JlIGluZm8uJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tuYW1lXS5fY29uZmlnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb25maWcucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0uX2NvbmZpZztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGNvbmZpZy5wYXJlbnRMb2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZS5fY29uZmlnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBuZXcgTG9jYWxlKG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNvbmZpZykpO1xuXG4gICAgICAgICAgICBpZiAobG9jYWxlRmFtaWxpZXNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluZUxvY2FsZSh4Lm5hbWUsIHguY29uZmlnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2Ugc2V0IHRoZSBsb2NhbGUgQUZURVIgYWxsIGNoaWxkIGxvY2FsZXMgaGF2ZSBiZWVuXG4gICAgICAgICAgICAvLyBjcmVhdGVkLCBzbyB3ZSB3b24ndCBlbmQgdXAgd2l0aCB0aGUgY2hpbGQgbG9jYWxlIHNldC5cbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcblxuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB1c2VmdWwgZm9yIHRlc3RpbmdcbiAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVMb2NhbGUobmFtZSwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGxvY2FsZSxcbiAgICAgICAgICAgICAgICB0bXBMb2NhbGUsXG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcblxuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCAmJiBsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGV4aXN0aW5nIGNoaWxkIGxvY2FsZSBpbi1wbGFjZSB0byBhdm9pZCBtZW1vcnktbGVha3NcbiAgICAgICAgICAgICAgICBsb2NhbGVzW25hbWVdLnNldChtZXJnZUNvbmZpZ3MobG9jYWxlc1tuYW1lXS5fY29uZmlnLCBjb25maWcpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTUVSR0VcbiAgICAgICAgICAgICAgICB0bXBMb2NhbGUgPSBsb2FkTG9jYWxlKG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICh0bXBMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSB0bXBMb2NhbGUuX2NvbmZpZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uZmlnID0gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKTtcbiAgICAgICAgICAgICAgICBpZiAodG1wTG9jYWxlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlTG9jYWxlIGlzIGNhbGxlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBhYmJyIHNvIGl0IHdpbGwgaGF2ZSBhIG5hbWUgKGdldHRlcnMgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIC8vIHVuZGVmaW5lZCBvdGhlcndpc2UpLlxuICAgICAgICAgICAgICAgICAgICBjb25maWcuYWJiciA9IG5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvY2FsZSA9IG5ldyBMb2NhbGUoY29uZmlnKTtcbiAgICAgICAgICAgICAgICBsb2NhbGUucGFyZW50TG9jYWxlID0gbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhc3MgbnVsbCBmb3IgY29uZmlnIHRvIHVudXBkYXRlLCB1c2VmdWwgZm9yIHRlc3RzXG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gZ2V0U2V0R2xvYmFsTG9jYWxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIGxvY2FsZSBkYXRhXG4gICAgZnVuY3Rpb24gZ2V0TG9jYWxlKGtleSkge1xuICAgICAgICB2YXIgbG9jYWxlO1xuXG4gICAgICAgIGlmIChrZXkgJiYga2V5Ll9sb2NhbGUgJiYga2V5Ll9sb2NhbGUuX2FiYnIpIHtcbiAgICAgICAgICAgIGtleSA9IGtleS5fbG9jYWxlLl9hYmJyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzQXJyYXkoa2V5KSkge1xuICAgICAgICAgICAgLy9zaG9ydC1jaXJjdWl0IGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShrZXkpO1xuICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrZXkgPSBba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaG9vc2VMb2NhbGUoa2V5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TG9jYWxlcygpIHtcbiAgICAgICAgcmV0dXJuIGtleXMobG9jYWxlcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tPdmVyZmxvdyhtKSB7XG4gICAgICAgIHZhciBvdmVyZmxvdyxcbiAgICAgICAgICAgIGEgPSBtLl9hO1xuXG4gICAgICAgIGlmIChhICYmIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9PT0gLTIpIHtcbiAgICAgICAgICAgIG92ZXJmbG93ID1cbiAgICAgICAgICAgICAgICBhW01PTlRIXSA8IDAgfHwgYVtNT05USF0gPiAxMVxuICAgICAgICAgICAgICAgICAgICA/IE1PTlRIXG4gICAgICAgICAgICAgICAgICAgIDogYVtEQVRFXSA8IDEgfHwgYVtEQVRFXSA+IGRheXNJbk1vbnRoKGFbWUVBUl0sIGFbTU9OVEhdKVxuICAgICAgICAgICAgICAgICAgICA/IERBVEVcbiAgICAgICAgICAgICAgICAgICAgOiBhW0hPVVJdIDwgMCB8fFxuICAgICAgICAgICAgICAgICAgICAgIGFbSE9VUl0gPiAyNCB8fFxuICAgICAgICAgICAgICAgICAgICAgIChhW0hPVVJdID09PSAyNCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoYVtNSU5VVEVdICE9PSAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhW1NFQ09ORF0gIT09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFbTUlMTElTRUNPTkRdICE9PSAwKSlcbiAgICAgICAgICAgICAgICAgICAgPyBIT1VSXG4gICAgICAgICAgICAgICAgICAgIDogYVtNSU5VVEVdIDwgMCB8fCBhW01JTlVURV0gPiA1OVxuICAgICAgICAgICAgICAgICAgICA/IE1JTlVURVxuICAgICAgICAgICAgICAgICAgICA6IGFbU0VDT05EXSA8IDAgfHwgYVtTRUNPTkRdID4gNTlcbiAgICAgICAgICAgICAgICAgICAgPyBTRUNPTkRcbiAgICAgICAgICAgICAgICAgICAgOiBhW01JTExJU0VDT05EXSA8IDAgfHwgYVtNSUxMSVNFQ09ORF0gPiA5OTlcbiAgICAgICAgICAgICAgICAgICAgPyBNSUxMSVNFQ09ORFxuICAgICAgICAgICAgICAgICAgICA6IC0xO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd0RheU9mWWVhciAmJlxuICAgICAgICAgICAgICAgIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBEQVRFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrcyAmJiBvdmVyZmxvdyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd1dlZWtkYXkgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLREFZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkub3ZlcmZsb3cgPSBvdmVyZmxvdztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cblxuICAgIC8vIGlzbyA4NjAxIHJlZ2V4XG4gICAgLy8gMDAwMC0wMC0wMCAwMDAwLVcwMCBvciAwMDAwLVcwMC0wICsgVCArIDAwIG9yIDAwOjAwIG9yIDAwOjAwOjAwIG9yIDAwOjAwOjAwLjAwMCArICswMDowMCBvciArMDAwMCBvciArMDApXG4gICAgdmFyIGV4dGVuZGVkSXNvUmVnZXggPVxuICAgICAgICAgICAgL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KS0oPzpcXGRcXGQtXFxkXFxkfFdcXGRcXGQtXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZCkpKD86KFR8ICkoXFxkXFxkKD86OlxcZFxcZCg/OjpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoWystXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/JC8sXG4gICAgICAgIGJhc2ljSXNvUmVnZXggPVxuICAgICAgICAgICAgL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KSg/OlxcZFxcZFxcZFxcZHxXXFxkXFxkXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZHwpKSg/OihUfCApKFxcZFxcZCg/OlxcZFxcZCg/OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbKy1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLyxcbiAgICAgICAgdHpSZWdleCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/LyxcbiAgICAgICAgaXNvRGF0ZXMgPSBbXG4gICAgICAgICAgICBbJ1lZWVlZWS1NTS1ERCcsIC9bKy1dXFxkezZ9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICAgICAgICAgIFsnWVlZWS1NTS1ERCcsIC9cXGR7NH0tXFxkXFxkLVxcZFxcZC9dLFxuICAgICAgICAgICAgWydHR0dHLVtXXVdXLUUnLCAvXFxkezR9LVdcXGRcXGQtXFxkL10sXG4gICAgICAgICAgICBbJ0dHR0ctW1ddV1cnLCAvXFxkezR9LVdcXGRcXGQvLCBmYWxzZV0sXG4gICAgICAgICAgICBbJ1lZWVktREREJywgL1xcZHs0fS1cXGR7M30vXSxcbiAgICAgICAgICAgIFsnWVlZWS1NTScsIC9cXGR7NH0tXFxkXFxkLywgZmFsc2VdLFxuICAgICAgICAgICAgWydZWVlZWVlNTUREJywgL1srLV1cXGR7MTB9L10sXG4gICAgICAgICAgICBbJ1lZWVlNTUREJywgL1xcZHs4fS9dLFxuICAgICAgICAgICAgWydHR0dHW1ddV1dFJywgL1xcZHs0fVdcXGR7M30vXSxcbiAgICAgICAgICAgIFsnR0dHR1tXXVdXJywgL1xcZHs0fVdcXGR7Mn0vLCBmYWxzZV0sXG4gICAgICAgICAgICBbJ1lZWVlEREQnLCAvXFxkezd9L10sXG4gICAgICAgICAgICBbJ1lZWVlNTScsIC9cXGR7Nn0vLCBmYWxzZV0sXG4gICAgICAgICAgICBbJ1lZWVknLCAvXFxkezR9LywgZmFsc2VdLFxuICAgICAgICBdLFxuICAgICAgICAvLyBpc28gdGltZSBmb3JtYXRzIGFuZCByZWdleGVzXG4gICAgICAgIGlzb1RpbWVzID0gW1xuICAgICAgICAgICAgWydISDptbTpzcy5TU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkXFwuXFxkKy9dLFxuICAgICAgICAgICAgWydISDptbTpzcyxTU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkLFxcZCsvXSxcbiAgICAgICAgICAgIFsnSEg6bW06c3MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgICAgIFsnSEg6bW0nLCAvXFxkXFxkOlxcZFxcZC9dLFxuICAgICAgICAgICAgWydISG1tc3MuU1NTUycsIC9cXGRcXGRcXGRcXGRcXGRcXGRcXC5cXGQrL10sXG4gICAgICAgICAgICBbJ0hIbW1zcyxTU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZCxcXGQrL10sXG4gICAgICAgICAgICBbJ0hIbW1zcycsIC9cXGRcXGRcXGRcXGRcXGRcXGQvXSxcbiAgICAgICAgICAgIFsnSEhtbScsIC9cXGRcXGRcXGRcXGQvXSxcbiAgICAgICAgICAgIFsnSEgnLCAvXFxkXFxkL10sXG4gICAgICAgIF0sXG4gICAgICAgIGFzcE5ldEpzb25SZWdleCA9IC9eXFwvP0RhdGVcXCgoLT9cXGQrKS9pLFxuICAgICAgICAvLyBSRkMgMjgyMiByZWdleDogRm9yIGRldGFpbHMgc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyODIyI3NlY3Rpb24tMy4zXG4gICAgICAgIHJmYzI4MjIgPVxuICAgICAgICAgICAgL14oPzooTW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSw/XFxzKT8oXFxkezEsMn0pXFxzKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKVxccyhcXGR7Miw0fSlcXHMoXFxkXFxkKTooXFxkXFxkKSg/OjooXFxkXFxkKSk/XFxzKD86KFVUfEdNVHxbRUNNUF1bU0RdVCl8KFtael0pfChbKy1dXFxkezR9KSkkLyxcbiAgICAgICAgb2JzT2Zmc2V0cyA9IHtcbiAgICAgICAgICAgIFVUOiAwLFxuICAgICAgICAgICAgR01UOiAwLFxuICAgICAgICAgICAgRURUOiAtNCAqIDYwLFxuICAgICAgICAgICAgRVNUOiAtNSAqIDYwLFxuICAgICAgICAgICAgQ0RUOiAtNSAqIDYwLFxuICAgICAgICAgICAgQ1NUOiAtNiAqIDYwLFxuICAgICAgICAgICAgTURUOiAtNiAqIDYwLFxuICAgICAgICAgICAgTVNUOiAtNyAqIDYwLFxuICAgICAgICAgICAgUERUOiAtNyAqIDYwLFxuICAgICAgICAgICAgUFNUOiAtOCAqIDYwLFxuICAgICAgICB9O1xuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXRcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSVNPKGNvbmZpZykge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBzdHJpbmcgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBtYXRjaCA9IGV4dGVuZGVkSXNvUmVnZXguZXhlYyhzdHJpbmcpIHx8IGJhc2ljSXNvUmVnZXguZXhlYyhzdHJpbmcpLFxuICAgICAgICAgICAgYWxsb3dUaW1lLFxuICAgICAgICAgICAgZGF0ZUZvcm1hdCxcbiAgICAgICAgICAgIHRpbWVGb3JtYXQsXG4gICAgICAgICAgICB0ekZvcm1hdCxcbiAgICAgICAgICAgIGlzb0RhdGVzTGVuID0gaXNvRGF0ZXMubGVuZ3RoLFxuICAgICAgICAgICAgaXNvVGltZXNMZW4gPSBpc29UaW1lcy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pc28gPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb0RhdGVzTGVuOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzb0RhdGVzW2ldWzFdLmV4ZWMobWF0Y2hbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVGb3JtYXQgPSBpc29EYXRlc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dUaW1lID0gaXNvRGF0ZXNbaV1bMl0gIT09IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0ZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb1RpbWVzTGVuOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc29UaW1lc1tpXVsxXS5leGVjKG1hdGNoWzNdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2hbMl0gc2hvdWxkIGJlICdUJyBvciBzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZUZvcm1hdCA9IChtYXRjaFsyXSB8fCAnICcpICsgaXNvVGltZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGltZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhbGxvd1RpbWUgJiYgdGltZUZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR6UmVnZXguZXhlYyhtYXRjaFs0XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHpGb3JtYXQgPSAnWic7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25maWcuX2YgPSBkYXRlRm9ybWF0ICsgKHRpbWVGb3JtYXQgfHwgJycpICsgKHR6Rm9ybWF0IHx8ICcnKTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyhcbiAgICAgICAgeWVhclN0cixcbiAgICAgICAgbW9udGhTdHIsXG4gICAgICAgIGRheVN0cixcbiAgICAgICAgaG91clN0cixcbiAgICAgICAgbWludXRlU3RyLFxuICAgICAgICBzZWNvbmRTdHJcbiAgICApIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtcbiAgICAgICAgICAgIHVudHJ1bmNhdGVZZWFyKHllYXJTdHIpLFxuICAgICAgICAgICAgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LmluZGV4T2YobW9udGhTdHIpLFxuICAgICAgICAgICAgcGFyc2VJbnQoZGF5U3RyLCAxMCksXG4gICAgICAgICAgICBwYXJzZUludChob3VyU3RyLCAxMCksXG4gICAgICAgICAgICBwYXJzZUludChtaW51dGVTdHIsIDEwKSxcbiAgICAgICAgXTtcblxuICAgICAgICBpZiAoc2Vjb25kU3RyKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJzZUludChzZWNvbmRTdHIsIDEwKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVudHJ1bmNhdGVZZWFyKHllYXJTdHIpIHtcbiAgICAgICAgdmFyIHllYXIgPSBwYXJzZUludCh5ZWFyU3RyLCAxMCk7XG4gICAgICAgIGlmICh5ZWFyIDw9IDQ5KSB7XG4gICAgICAgICAgICByZXR1cm4gMjAwMCArIHllYXI7XG4gICAgICAgIH0gZWxzZSBpZiAoeWVhciA8PSA5OTkpIHtcbiAgICAgICAgICAgIHJldHVybiAxOTAwICsgeWVhcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geWVhcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwcm9jZXNzUkZDMjgyMihzKSB7XG4gICAgICAgIC8vIFJlbW92ZSBjb21tZW50cyBhbmQgZm9sZGluZyB3aGl0ZXNwYWNlIGFuZCByZXBsYWNlIG11bHRpcGxlLXNwYWNlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG4gICAgICAgIHJldHVybiBzXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwoW14oKV0qXFwpfFtcXG5cXHRdL2csICcgJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8oXFxzXFxzKykvZywgJyAnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL15cXHNcXHMqLywgJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxzXFxzKiQvLCAnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tXZWVrZGF5KHdlZWtkYXlTdHIsIHBhcnNlZElucHV0LCBjb25maWcpIHtcbiAgICAgICAgaWYgKHdlZWtkYXlTdHIpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFJlcGxhY2UgdGhlIHZhbmlsbGEgSlMgRGF0ZSBvYmplY3Qgd2l0aCBhbiBpbmRlcGVuZGVudCBkYXktb2Ytd2VlayBjaGVjay5cbiAgICAgICAgICAgIHZhciB3ZWVrZGF5UHJvdmlkZWQgPSBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydC5pbmRleE9mKHdlZWtkYXlTdHIpLFxuICAgICAgICAgICAgICAgIHdlZWtkYXlBY3R1YWwgPSBuZXcgRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkSW5wdXRbMF0sXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZElucHV0WzFdLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRJbnB1dFsyXVxuICAgICAgICAgICAgICAgICkuZ2V0RGF5KCk7XG4gICAgICAgICAgICBpZiAod2Vla2RheVByb3ZpZGVkICE9PSB3ZWVrZGF5QWN0dWFsKSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykud2Vla2RheU1pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlT2Zmc2V0KG9ic09mZnNldCwgbWlsaXRhcnlPZmZzZXQsIG51bU9mZnNldCkge1xuICAgICAgICBpZiAob2JzT2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gb2JzT2Zmc2V0c1tvYnNPZmZzZXRdO1xuICAgICAgICB9IGVsc2UgaWYgKG1pbGl0YXJ5T2Zmc2V0KSB7XG4gICAgICAgICAgICAvLyB0aGUgb25seSBhbGxvd2VkIG1pbGl0YXJ5IHR6IGlzIFpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGhtID0gcGFyc2VJbnQobnVtT2Zmc2V0LCAxMCksXG4gICAgICAgICAgICAgICAgbSA9IGhtICUgMTAwLFxuICAgICAgICAgICAgICAgIGggPSAoaG0gLSBtKSAvIDEwMDtcbiAgICAgICAgICAgIHJldHVybiBoICogNjAgKyBtO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBhbmQgdGltZSBmcm9tIHJlZiAyODIyIGZvcm1hdFxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZykge1xuICAgICAgICB2YXIgbWF0Y2ggPSByZmMyODIyLmV4ZWMocHJlcHJvY2Vzc1JGQzI4MjIoY29uZmlnLl9pKSksXG4gICAgICAgICAgICBwYXJzZWRBcnJheTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBwYXJzZWRBcnJheSA9IGV4dHJhY3RGcm9tUkZDMjgyMlN0cmluZ3MoXG4gICAgICAgICAgICAgICAgbWF0Y2hbNF0sXG4gICAgICAgICAgICAgICAgbWF0Y2hbM10sXG4gICAgICAgICAgICAgICAgbWF0Y2hbMl0sXG4gICAgICAgICAgICAgICAgbWF0Y2hbNV0sXG4gICAgICAgICAgICAgICAgbWF0Y2hbNl0sXG4gICAgICAgICAgICAgICAgbWF0Y2hbN11cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoIWNoZWNrV2Vla2RheShtYXRjaFsxXSwgcGFyc2VkQXJyYXksIGNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbmZpZy5fYSA9IHBhcnNlZEFycmF5O1xuICAgICAgICAgICAgY29uZmlnLl90em0gPSBjYWxjdWxhdGVPZmZzZXQobWF0Y2hbOF0sIG1hdGNoWzldLCBtYXRjaFsxMF0pO1xuXG4gICAgICAgICAgICBjb25maWcuX2QgPSBjcmVhdGVVVENEYXRlLmFwcGx5KG51bGwsIGNvbmZpZy5fYSk7XG4gICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5yZmMyODIyID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIDEpIEFTUC5ORVQsIDIpIElTTywgMykgUkZDIDI4MjIgZm9ybWF0cywgb3IgNCkgb3B0aW9uYWwgZmFsbGJhY2sgaWYgcGFyc2luZyBpc24ndCBzdHJpY3RcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nKGNvbmZpZykge1xuICAgICAgICB2YXIgbWF0Y2hlZCA9IGFzcE5ldEpzb25SZWdleC5leGVjKGNvbmZpZy5faSk7XG4gICAgICAgIGlmIChtYXRjaGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgrbWF0Y2hlZFsxXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgIGlmIChjb25maWcuX2lzVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLl9zdHJpY3QpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRmluYWwgYXR0ZW1wdCwgdXNlIElucHV0IEZhbGxiYWNrXG4gICAgICAgICAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2sgPSBkZXByZWNhdGUoXG4gICAgICAgICd2YWx1ZSBwcm92aWRlZCBpcyBub3QgaW4gYSByZWNvZ25pemVkIFJGQzI4MjIgb3IgSVNPIGZvcm1hdC4gbW9tZW50IGNvbnN0cnVjdGlvbiBmYWxscyBiYWNrIHRvIGpzIERhdGUoKSwgJyArXG4gICAgICAgICAgICAnd2hpY2ggaXMgbm90IHJlbGlhYmxlIGFjcm9zcyBhbGwgYnJvd3NlcnMgYW5kIHZlcnNpb25zLiBOb24gUkZDMjgyMi9JU08gZGF0ZSBmb3JtYXRzIGFyZSAnICtcbiAgICAgICAgICAgICdkaXNjb3VyYWdlZC4gUGxlYXNlIHJlZmVyIHRvIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvanMtZGF0ZS8gZm9yIG1vcmUgaW5mby4nLFxuICAgICAgICBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShjb25maWcuX2kgKyAoY29uZmlnLl91c2VVVEMgPyAnIFVUQycgOiAnJykpO1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIFBpY2sgdGhlIGZpcnN0IGRlZmluZWQgb2YgdHdvIG9yIHRocmVlIGFyZ3VtZW50cy5cbiAgICBmdW5jdGlvbiBkZWZhdWx0cyhhLCBiLCBjKSB7XG4gICAgICAgIGlmIChhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIC8vIGhvb2tzIGlzIGFjdHVhbGx5IHRoZSBleHBvcnRlZCBtb21lbnQgb2JqZWN0XG4gICAgICAgIHZhciBub3dWYWx1ZSA9IG5ldyBEYXRlKGhvb2tzLm5vdygpKTtcbiAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIG5vd1ZhbHVlLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgICAgICAgICAgICAgbm93VmFsdWUuZ2V0VVRDTW9udGgoKSxcbiAgICAgICAgICAgICAgICBub3dWYWx1ZS5nZXRVVENEYXRlKCksXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbm93VmFsdWUuZ2V0RnVsbFllYXIoKSwgbm93VmFsdWUuZ2V0TW9udGgoKSwgbm93VmFsdWUuZ2V0RGF0ZSgpXTtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IGFuIGFycmF5IHRvIGEgZGF0ZS5cbiAgICAvLyB0aGUgYXJyYXkgc2hvdWxkIG1pcnJvciB0aGUgcGFyYW1ldGVycyBiZWxvd1xuICAgIC8vIG5vdGU6IGFsbCB2YWx1ZXMgcGFzdCB0aGUgeWVhciBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlLlxuICAgIC8vIFt5ZWFyLCBtb250aCwgZGF5ICwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXVxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21BcnJheShjb25maWcpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBkYXRlLFxuICAgICAgICAgICAgaW5wdXQgPSBbXSxcbiAgICAgICAgICAgIGN1cnJlbnREYXRlLFxuICAgICAgICAgICAgZXhwZWN0ZWRXZWVrZGF5LFxuICAgICAgICAgICAgeWVhclRvVXNlO1xuXG4gICAgICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnREYXRlID0gY3VycmVudERhdGVBcnJheShjb25maWcpO1xuXG4gICAgICAgIC8vY29tcHV0ZSBkYXkgb2YgdGhlIHllYXIgZnJvbSB3ZWVrcyBhbmQgd2Vla2RheXNcbiAgICAgICAgaWYgKGNvbmZpZy5fdyAmJiBjb25maWcuX2FbREFURV0gPT0gbnVsbCAmJiBjb25maWcuX2FbTU9OVEhdID09IG51bGwpIHtcbiAgICAgICAgICAgIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pZiB0aGUgZGF5IG9mIHRoZSB5ZWFyIGlzIHNldCwgZmlndXJlIG91dCB3aGF0IGl0IGlzXG4gICAgICAgIGlmIChjb25maWcuX2RheU9mWWVhciAhPSBudWxsKSB7XG4gICAgICAgICAgICB5ZWFyVG9Vc2UgPSBkZWZhdWx0cyhjb25maWcuX2FbWUVBUl0sIGN1cnJlbnREYXRlW1lFQVJdKTtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyVG9Vc2UpIHx8XG4gICAgICAgICAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPT09IDBcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd0RheU9mWWVhciA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKHllYXJUb1VzZSwgMCwgY29uZmlnLl9kYXlPZlllYXIpO1xuICAgICAgICAgICAgY29uZmlnLl9hW01PTlRIXSA9IGRhdGUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtEQVRFXSA9IGRhdGUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IGRhdGUuXG4gICAgICAgIC8vICogaWYgbm8geWVhciwgbW9udGgsIGRheSBvZiBtb250aCBhcmUgZ2l2ZW4sIGRlZmF1bHQgdG8gdG9kYXlcbiAgICAgICAgLy8gKiBpZiBkYXkgb2YgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgbW9udGggYW5kIHllYXJcbiAgICAgICAgLy8gKiBpZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBvbmx5IHllYXJcbiAgICAgICAgLy8gKiBpZiB5ZWFyIGlzIGdpdmVuLCBkb24ndCBkZWZhdWx0IGFueXRoaW5nXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAzICYmIGNvbmZpZy5fYVtpXSA9PSBudWxsOyArK2kpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gY3VycmVudERhdGVbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBaZXJvIG91dCB3aGF0ZXZlciB3YXMgbm90IGRlZmF1bHRlZCwgaW5jbHVkaW5nIHRpbWVcbiAgICAgICAgZm9yICg7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID1cbiAgICAgICAgICAgICAgICBjb25maWcuX2FbaV0gPT0gbnVsbCA/IChpID09PSAyID8gMSA6IDApIDogY29uZmlnLl9hW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIDI0OjAwOjAwLjAwMFxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPT09IDI0ICYmXG4gICAgICAgICAgICBjb25maWcuX2FbTUlOVVRFXSA9PT0gMCAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW1NFQ09ORF0gPT09IDAgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNSUxMSVNFQ09ORF0gPT09IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25maWcuX25leHREYXkgPSB0cnVlO1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZy5fZCA9IChjb25maWcuX3VzZVVUQyA/IGNyZWF0ZVVUQ0RhdGUgOiBjcmVhdGVEYXRlKS5hcHBseShcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBpbnB1dFxuICAgICAgICApO1xuICAgICAgICBleHBlY3RlZFdlZWtkYXkgPSBjb25maWcuX3VzZVVUQ1xuICAgICAgICAgICAgPyBjb25maWcuX2QuZ2V0VVRDRGF5KClcbiAgICAgICAgICAgIDogY29uZmlnLl9kLmdldERheSgpO1xuXG4gICAgICAgIC8vIEFwcGx5IHRpbWV6b25lIG9mZnNldCBmcm9tIGlucHV0LiBUaGUgYWN0dWFsIHV0Y09mZnNldCBjYW4gYmUgY2hhbmdlZFxuICAgICAgICAvLyB3aXRoIHBhcnNlWm9uZS5cbiAgICAgICAgaWYgKGNvbmZpZy5fdHptICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZC5zZXRVVENNaW51dGVzKGNvbmZpZy5fZC5nZXRVVENNaW51dGVzKCkgLSBjb25maWcuX3R6bSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLl9uZXh0RGF5KSB7XG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAyNDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGZvciBtaXNtYXRjaGluZyBkYXkgb2Ygd2Vla1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBjb25maWcuX3cgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjb25maWcuX3cuZCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fdy5kICE9PSBleHBlY3RlZFdlZWtkYXlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS53ZWVrZGF5TWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZykge1xuICAgICAgICB2YXIgdywgd2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95LCB0ZW1wLCB3ZWVrZGF5T3ZlcmZsb3csIGN1cldlZWs7XG5cbiAgICAgICAgdyA9IGNvbmZpZy5fdztcbiAgICAgICAgaWYgKHcuR0cgIT0gbnVsbCB8fCB3LlcgIT0gbnVsbCB8fCB3LkUgIT0gbnVsbCkge1xuICAgICAgICAgICAgZG93ID0gMTtcbiAgICAgICAgICAgIGRveSA9IDQ7XG5cbiAgICAgICAgICAgIC8vIFRPRE86IFdlIG5lZWQgdG8gdGFrZSB0aGUgY3VycmVudCBpc29XZWVrWWVhciwgYnV0IHRoYXQgZGVwZW5kcyBvblxuICAgICAgICAgICAgLy8gaG93IHdlIGludGVycHJldCBub3cgKGxvY2FsLCB1dGMsIGZpeGVkIG9mZnNldCkuIFNvIGNyZWF0ZVxuICAgICAgICAgICAgLy8gYSBub3cgdmVyc2lvbiBvZiBjdXJyZW50IGNvbmZpZyAodGFrZSBsb2NhbC91dGMvb2Zmc2V0IGZsYWdzLCBhbmRcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBub3cpLlxuICAgICAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyhcbiAgICAgICAgICAgICAgICB3LkdHLFxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtZRUFSXSxcbiAgICAgICAgICAgICAgICB3ZWVrT2ZZZWFyKGNyZWF0ZUxvY2FsKCksIDEsIDQpLnllYXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody5XLCAxKTtcbiAgICAgICAgICAgIHdlZWtkYXkgPSBkZWZhdWx0cyh3LkUsIDEpO1xuICAgICAgICAgICAgaWYgKHdlZWtkYXkgPCAxIHx8IHdlZWtkYXkgPiA3KSB7XG4gICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvdyA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRvdztcbiAgICAgICAgICAgIGRveSA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRveTtcblxuICAgICAgICAgICAgY3VyV2VlayA9IHdlZWtPZlllYXIoY3JlYXRlTG9jYWwoKSwgZG93LCBkb3kpO1xuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuZ2csIGNvbmZpZy5fYVtZRUFSXSwgY3VyV2Vlay55ZWFyKTtcblxuICAgICAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IHdlZWsuXG4gICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody53LCBjdXJXZWVrLndlZWspO1xuXG4gICAgICAgICAgICBpZiAody5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZWVrZGF5IC0tIGxvdyBkYXkgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBuZXh0IHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5kO1xuICAgICAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgMCB8fCB3ZWVrZGF5ID4gNikge1xuICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAody5lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBsb2NhbCB3ZWVrZGF5IC0tIGNvdW50aW5nIHN0YXJ0cyBmcm9tIGJlZ2lubmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IHcuZSArIGRvdztcbiAgICAgICAgICAgICAgICBpZiAody5lIDwgMCB8fCB3LmUgPiA2KSB7XG4gICAgICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IHRvIGJlZ2lubmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IGRvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod2VlayA8IDEgfHwgd2VlayA+IHdlZWtzSW5ZZWFyKHdlZWtZZWFyLCBkb3csIGRveSkpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh3ZWVrZGF5T3ZlcmZsb3cgIT0gbnVsbCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla2RheSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZW1wID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgICAgICAgICBjb25maWcuX2FbWUVBUl0gPSB0ZW1wLnllYXI7XG4gICAgICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRlbXAuZGF5T2ZZZWFyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIElTTyBzdGFuZGFyZFxuICAgIGhvb2tzLklTT184NjAxID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBjb25zdGFudCB0aGF0IHJlZmVycyB0byB0aGUgUkZDIDI4MjIgZm9ybVxuICAgIGhvb2tzLlJGQ18yODIyID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBmb3JtYXQgc3RyaW5nXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIHRvIGFub3RoZXIgcGFydCBvZiB0aGUgY3JlYXRpb24gZmxvdyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcHNcbiAgICAgICAgaWYgKGNvbmZpZy5fZiA9PT0gaG9va3MuSVNPXzg2MDEpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLl9mID09PSBob29rcy5SRkNfMjgyMikge1xuICAgICAgICAgICAgY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25maWcuX2EgPSBbXTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSB0cnVlO1xuXG4gICAgICAgIC8vIFRoaXMgYXJyYXkgaXMgdXNlZCB0byBtYWtlIGEgRGF0ZSwgZWl0aGVyIHdpdGggYG5ldyBEYXRlYCBvciBgRGF0ZS5VVENgXG4gICAgICAgIHZhciBzdHJpbmcgPSAnJyArIGNvbmZpZy5faSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBwYXJzZWRJbnB1dCxcbiAgICAgICAgICAgIHRva2VucyxcbiAgICAgICAgICAgIHRva2VuLFxuICAgICAgICAgICAgc2tpcHBlZCxcbiAgICAgICAgICAgIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG4gICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoID0gMCxcbiAgICAgICAgICAgIGVyYSxcbiAgICAgICAgICAgIHRva2VuTGVuO1xuXG4gICAgICAgIHRva2VucyA9XG4gICAgICAgICAgICBleHBhbmRGb3JtYXQoY29uZmlnLl9mLCBjb25maWcuX2xvY2FsZSkubWF0Y2goZm9ybWF0dGluZ1Rva2VucykgfHwgW107XG4gICAgICAgIHRva2VuTGVuID0gdG9rZW5zLmxlbmd0aDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2VuTGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgcGFyc2VkSW5wdXQgPSAoc3RyaW5nLm1hdGNoKGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSkgfHxcbiAgICAgICAgICAgICAgICBbXSlbMF07XG4gICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBza2lwcGVkID0gc3RyaW5nLnN1YnN0cigwLCBzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkpO1xuICAgICAgICAgICAgICAgIGlmIChza2lwcGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChza2lwcGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKFxuICAgICAgICAgICAgICAgICAgICBzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkgKyBwYXJzZWRJbnB1dC5sZW5ndGhcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggKz0gcGFyc2VkSW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZG9uJ3QgcGFyc2UgaWYgaXQncyBub3QgYSBrbm93biB0b2tlblxuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIHBhcnNlZElucHV0LCBjb25maWcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb25maWcuX3N0cmljdCAmJiAhcGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgcmVtYWluaW5nIHVucGFyc2VkIGlucHV0IGxlbmd0aCB0byB0aGUgc3RyaW5nXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmNoYXJzTGVmdE92ZXIgPVxuICAgICAgICAgICAgc3RyaW5nTGVuZ3RoIC0gdG90YWxQYXJzZWRJbnB1dExlbmd0aDtcbiAgICAgICAgaWYgKHN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHN0cmluZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhciBfMTJoIGZsYWcgaWYgaG91ciBpcyA8PSAxMlxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPD0gMTIgJiZcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPT09IHRydWUgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA+IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykucGFyc2VkRGF0ZVBhcnRzID0gY29uZmlnLl9hLnNsaWNlKDApO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5tZXJpZGllbSA9IGNvbmZpZy5fbWVyaWRpZW07XG4gICAgICAgIC8vIGhhbmRsZSBtZXJpZGllbVxuICAgICAgICBjb25maWcuX2FbSE9VUl0gPSBtZXJpZGllbUZpeFdyYXAoXG4gICAgICAgICAgICBjb25maWcuX2xvY2FsZSxcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSxcbiAgICAgICAgICAgIGNvbmZpZy5fbWVyaWRpZW1cbiAgICAgICAgKTtcblxuICAgICAgICAvLyBoYW5kbGUgZXJhXG4gICAgICAgIGVyYSA9IGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVyYTtcbiAgICAgICAgaWYgKGVyYSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9hW1lFQVJdID0gY29uZmlnLl9sb2NhbGUuZXJhc0NvbnZlcnRZZWFyKGVyYSwgY29uZmlnLl9hW1lFQVJdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICBjaGVja092ZXJmbG93KGNvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyaWRpZW1GaXhXcmFwKGxvY2FsZSwgaG91ciwgbWVyaWRpZW0pIHtcbiAgICAgICAgdmFyIGlzUG07XG5cbiAgICAgICAgaWYgKG1lcmlkaWVtID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbGUubWVyaWRpZW1Ib3VyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubWVyaWRpZW1Ib3VyKGhvdXIsIG1lcmlkaWVtKTtcbiAgICAgICAgfSBlbHNlIGlmIChsb2NhbGUuaXNQTSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFja1xuICAgICAgICAgICAgaXNQbSA9IGxvY2FsZS5pc1BNKG1lcmlkaWVtKTtcbiAgICAgICAgICAgIGlmIChpc1BtICYmIGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgKz0gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzUG0gJiYgaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3Qgc3VwcG9zZWQgdG8gaGFwcGVuXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGFycmF5IG9mIGZvcm1hdCBzdHJpbmdzXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZykge1xuICAgICAgICB2YXIgdGVtcENvbmZpZyxcbiAgICAgICAgICAgIGJlc3RNb21lbnQsXG4gICAgICAgICAgICBzY29yZVRvQmVhdCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBjdXJyZW50U2NvcmUsXG4gICAgICAgICAgICB2YWxpZEZvcm1hdEZvdW5kLFxuICAgICAgICAgICAgYmVzdEZvcm1hdElzVmFsaWQgPSBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ2ZMZW4gPSBjb25maWcuX2YubGVuZ3RoO1xuXG4gICAgICAgIGlmIChjb25maWdmTGVuID09PSAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkRm9ybWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29uZmlnZkxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgPSAwO1xuICAgICAgICAgICAgdmFsaWRGb3JtYXRGb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGVtcENvbmZpZyA9IGNvcHlDb25maWcoe30sIGNvbmZpZyk7XG4gICAgICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRlbXBDb25maWcuX3VzZVVUQyA9IGNvbmZpZy5fdXNlVVRDO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVtcENvbmZpZy5fZiA9IGNvbmZpZy5fZltpXTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQodGVtcENvbmZpZyk7XG5cbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKHRlbXBDb25maWcpKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRGb3JtYXRGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFueSBpbnB1dCB0aGF0IHdhcyBub3QgcGFyc2VkIGFkZCBhIHBlbmFsdHkgZm9yIHRoYXQgZm9ybWF0XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLmNoYXJzTGVmdE92ZXI7XG5cbiAgICAgICAgICAgIC8vb3IgdG9rZW5zXG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnVudXNlZFRva2Vucy5sZW5ndGggKiAxMDtcblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnNjb3JlID0gY3VycmVudFNjb3JlO1xuXG4gICAgICAgICAgICBpZiAoIWJlc3RGb3JtYXRJc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBzY29yZVRvQmVhdCA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTY29yZSA8IHNjb3JlVG9CZWF0IHx8XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkRm9ybWF0Rm91bmRcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcmVUb0JlYXQgPSBjdXJyZW50U2NvcmU7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNb21lbnQgPSB0ZW1wQ29uZmlnO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRGb3JtYXRGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdEZvcm1hdElzVmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcmVUb0JlYXQgPSBjdXJyZW50U2NvcmU7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNb21lbnQgPSB0ZW1wQ29uZmlnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4dGVuZChjb25maWcsIGJlc3RNb21lbnQgfHwgdGVtcENvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbU9iamVjdChjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSBub3JtYWxpemVPYmplY3RVbml0cyhjb25maWcuX2kpLFxuICAgICAgICAgICAgZGF5T3JEYXRlID0gaS5kYXkgPT09IHVuZGVmaW5lZCA/IGkuZGF0ZSA6IGkuZGF5O1xuICAgICAgICBjb25maWcuX2EgPSBtYXAoXG4gICAgICAgICAgICBbaS55ZWFyLCBpLm1vbnRoLCBkYXlPckRhdGUsIGkuaG91ciwgaS5taW51dGUsIGkuc2Vjb25kLCBpLm1pbGxpc2Vjb25kXSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqICYmIHBhcnNlSW50KG9iaiwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZyb21Db25maWcoY29uZmlnKSB7XG4gICAgICAgIHZhciByZXMgPSBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3cocHJlcGFyZUNvbmZpZyhjb25maWcpKSk7XG4gICAgICAgIGlmIChyZXMuX25leHREYXkpIHtcbiAgICAgICAgICAgIC8vIEFkZGluZyBpcyBzbWFydCBlbm91Z2ggYXJvdW5kIERTVFxuICAgICAgICAgICAgcmVzLmFkZCgxLCAnZCcpO1xuICAgICAgICAgICAgcmVzLl9uZXh0RGF5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwYXJlQ29uZmlnKGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBmb3JtYXQgPSBjb25maWcuX2Y7XG5cbiAgICAgICAgY29uZmlnLl9sb2NhbGUgPSBjb25maWcuX2xvY2FsZSB8fCBnZXRMb2NhbGUoY29uZmlnLl9sKTtcblxuICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgKGZvcm1hdCA9PT0gdW5kZWZpbmVkICYmIGlucHV0ID09PSAnJykpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKHsgbnVsbElucHV0OiB0cnVlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faSA9IGlucHV0ID0gY29uZmlnLl9sb2NhbGUucHJlcGFyc2UoaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTW9tZW50KGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhpbnB1dCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IGlucHV0O1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZm9ybWF0KSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0KSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWdGcm9tSW5wdXQoY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNWYWxpZChjb25maWcpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSW5wdXQoY29uZmlnKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faTtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaG9va3Mubm93KCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0LnZhbHVlT2YoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZyhjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2EgPSBtYXAoaW5wdXQuc2xpY2UoMCksIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbU9iamVjdChjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlucHV0KSkge1xuICAgICAgICAgICAgLy8gZnJvbSBtaWxsaXNlY29uZHNcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBpc1VUQykge1xuICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgIGlmIChmb3JtYXQgPT09IHRydWUgfHwgZm9ybWF0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgc3RyaWN0ID0gZm9ybWF0O1xuICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvY2FsZSA9PT0gdHJ1ZSB8fCBsb2NhbGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzdHJpY3QgPSBsb2NhbGU7XG4gICAgICAgICAgICBsb2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAoaXNPYmplY3QoaW5wdXQpICYmIGlzT2JqZWN0RW1wdHkoaW5wdXQpKSB8fFxuICAgICAgICAgICAgKGlzQXJyYXkoaW5wdXQpICYmIGlucHV0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBpbnB1dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBvYmplY3QgY29uc3RydWN0aW9uIG11c3QgYmUgZG9uZSB0aGlzIHdheS5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MjNcbiAgICAgICAgYy5faXNBTW9tZW50T2JqZWN0ID0gdHJ1ZTtcbiAgICAgICAgYy5fdXNlVVRDID0gYy5faXNVVEMgPSBpc1VUQztcbiAgICAgICAgYy5fbCA9IGxvY2FsZTtcbiAgICAgICAgYy5faSA9IGlucHV0O1xuICAgICAgICBjLl9mID0gZm9ybWF0O1xuICAgICAgICBjLl9zdHJpY3QgPSBzdHJpY3Q7XG5cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZyb21Db25maWcoYyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTG9jYWwoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG90eXBlTWluID0gZGVwcmVjYXRlKFxuICAgICAgICAgICAgJ21vbWVudCgpLm1pbiBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1heCBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyIDwgdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgcHJvdG90eXBlTWF4ID0gZGVwcmVjYXRlKFxuICAgICAgICAgICAgJ21vbWVudCgpLm1heCBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1pbiBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyID4gdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgIC8vIFBpY2sgYSBtb21lbnQgbSBmcm9tIG1vbWVudHMgc28gdGhhdCBtW2ZuXShvdGhlcikgaXMgdHJ1ZSBmb3IgYWxsXG4gICAgLy8gb3RoZXIuIFRoaXMgcmVsaWVzIG9uIHRoZSBmdW5jdGlvbiBmbiB0byBiZSB0cmFuc2l0aXZlLlxuICAgIC8vXG4gICAgLy8gbW9tZW50cyBzaG91bGQgZWl0aGVyIGJlIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzIG9yIGFuIGFycmF5LCB3aG9zZVxuICAgIC8vIGZpcnN0IGVsZW1lbnQgaXMgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMuXG4gICAgZnVuY3Rpb24gcGlja0J5KGZuLCBtb21lbnRzKSB7XG4gICAgICAgIHZhciByZXMsIGk7XG4gICAgICAgIGlmIChtb21lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KG1vbWVudHNbMF0pKSB7XG4gICAgICAgICAgICBtb21lbnRzID0gbW9tZW50c1swXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1vbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXMgPSBtb21lbnRzWzBdO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbW9tZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKCFtb21lbnRzW2ldLmlzVmFsaWQoKSB8fCBtb21lbnRzW2ldW2ZuXShyZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gbW9tZW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IFVzZSBbXS5zb3J0IGluc3RlYWQ/XG4gICAgZnVuY3Rpb24gbWluKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0JlZm9yZScsIGFyZ3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1heCgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNBZnRlcicsIGFyZ3MpO1xuICAgIH1cblxuICAgIHZhciBub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdyA/IERhdGUubm93KCkgOiArbmV3IERhdGUoKTtcbiAgICB9O1xuXG4gICAgdmFyIG9yZGVyaW5nID0gW1xuICAgICAgICAneWVhcicsXG4gICAgICAgICdxdWFydGVyJyxcbiAgICAgICAgJ21vbnRoJyxcbiAgICAgICAgJ3dlZWsnLFxuICAgICAgICAnZGF5JyxcbiAgICAgICAgJ2hvdXInLFxuICAgICAgICAnbWludXRlJyxcbiAgICAgICAgJ3NlY29uZCcsXG4gICAgICAgICdtaWxsaXNlY29uZCcsXG4gICAgXTtcblxuICAgIGZ1bmN0aW9uIGlzRHVyYXRpb25WYWxpZChtKSB7XG4gICAgICAgIHZhciBrZXksXG4gICAgICAgICAgICB1bml0SGFzRGVjaW1hbCA9IGZhbHNlLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIG9yZGVyTGVuID0gb3JkZXJpbmcubGVuZ3RoO1xuICAgICAgICBmb3IgKGtleSBpbiBtKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgaGFzT3duUHJvcChtLCBrZXkpICYmXG4gICAgICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhPZi5jYWxsKG9yZGVyaW5nLCBrZXkpICE9PSAtMSAmJlxuICAgICAgICAgICAgICAgICAgICAobVtrZXldID09IG51bGwgfHwgIWlzTmFOKG1ba2V5XSkpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9yZGVyTGVuOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChtW29yZGVyaW5nW2ldXSkge1xuICAgICAgICAgICAgICAgIGlmICh1bml0SGFzRGVjaW1hbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG9ubHkgYWxsb3cgbm9uLWludGVnZXJzIGZvciBzbWFsbGVzdCB1bml0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJzZUZsb2F0KG1bb3JkZXJpbmdbaV1dKSAhPT0gdG9JbnQobVtvcmRlcmluZ1tpXV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuaXRIYXNEZWNpbWFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1ZhbGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmFsaWQkMSgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKE5hTik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRHVyYXRpb24oZHVyYXRpb24pIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGR1cmF0aW9uKSxcbiAgICAgICAgICAgIHllYXJzID0gbm9ybWFsaXplZElucHV0LnllYXIgfHwgMCxcbiAgICAgICAgICAgIHF1YXJ0ZXJzID0gbm9ybWFsaXplZElucHV0LnF1YXJ0ZXIgfHwgMCxcbiAgICAgICAgICAgIG1vbnRocyA9IG5vcm1hbGl6ZWRJbnB1dC5tb250aCB8fCAwLFxuICAgICAgICAgICAgd2Vla3MgPSBub3JtYWxpemVkSW5wdXQud2VlayB8fCBub3JtYWxpemVkSW5wdXQuaXNvV2VlayB8fCAwLFxuICAgICAgICAgICAgZGF5cyA9IG5vcm1hbGl6ZWRJbnB1dC5kYXkgfHwgMCxcbiAgICAgICAgICAgIGhvdXJzID0gbm9ybWFsaXplZElucHV0LmhvdXIgfHwgMCxcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBub3JtYWxpemVkSW5wdXQubWludXRlIHx8IDAsXG4gICAgICAgICAgICBzZWNvbmRzID0gbm9ybWFsaXplZElucHV0LnNlY29uZCB8fCAwLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gbm9ybWFsaXplZElucHV0Lm1pbGxpc2Vjb25kIHx8IDA7XG5cbiAgICAgICAgdGhpcy5faXNWYWxpZCA9IGlzRHVyYXRpb25WYWxpZChub3JtYWxpemVkSW5wdXQpO1xuXG4gICAgICAgIC8vIHJlcHJlc2VudGF0aW9uIGZvciBkYXRlQWRkUmVtb3ZlXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9XG4gICAgICAgICAgICArbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgIHNlY29uZHMgKiAxZTMgKyAvLyAxMDAwXG4gICAgICAgICAgICBtaW51dGVzICogNmU0ICsgLy8gMTAwMCAqIDYwXG4gICAgICAgICAgICBob3VycyAqIDEwMDAgKiA2MCAqIDYwOyAvL3VzaW5nIDEwMDAgKiA2MCAqIDYwIGluc3RlYWQgb2YgMzZlNSB0byBhdm9pZCBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvcnMgaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzI5NzhcbiAgICAgICAgLy8gQmVjYXVzZSBvZiBkYXRlQWRkUmVtb3ZlIHRyZWF0cyAyNCBob3VycyBhcyBkaWZmZXJlbnQgZnJvbSBhXG4gICAgICAgIC8vIGRheSB3aGVuIHdvcmtpbmcgYXJvdW5kIERTVCwgd2UgbmVlZCB0byBzdG9yZSB0aGVtIHNlcGFyYXRlbHlcbiAgICAgICAgdGhpcy5fZGF5cyA9ICtkYXlzICsgd2Vla3MgKiA3O1xuICAgICAgICAvLyBJdCBpcyBpbXBvc3NpYmxlIHRvIHRyYW5zbGF0ZSBtb250aHMgaW50byBkYXlzIHdpdGhvdXQga25vd2luZ1xuICAgICAgICAvLyB3aGljaCBtb250aHMgeW91IGFyZSBhcmUgdGFsa2luZyBhYm91dCwgc28gd2UgaGF2ZSB0byBzdG9yZVxuICAgICAgICAvLyBpdCBzZXBhcmF0ZWx5LlxuICAgICAgICB0aGlzLl9tb250aHMgPSArbW9udGhzICsgcXVhcnRlcnMgKiAzICsgeWVhcnMgKiAxMjtcblxuICAgICAgICB0aGlzLl9kYXRhID0ge307XG5cbiAgICAgICAgdGhpcy5fbG9jYWxlID0gZ2V0TG9jYWxlKCk7XG5cbiAgICAgICAgdGhpcy5fYnViYmxlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEdXJhdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIER1cmF0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic1JvdW5kKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoLTEgKiBudW1iZXIpICogLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29tcGFyZSB0d28gYXJyYXlzLCByZXR1cm4gdGhlIG51bWJlciBvZiBkaWZmZXJlbmNlc1xuICAgIGZ1bmN0aW9uIGNvbXBhcmVBcnJheXMoYXJyYXkxLCBhcnJheTIsIGRvbnRDb252ZXJ0KSB7XG4gICAgICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcnJheTEubGVuZ3RoLCBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgICAgIGxlbmd0aERpZmYgPSBNYXRoLmFicyhhcnJheTEubGVuZ3RoIC0gYXJyYXkyLmxlbmd0aCksXG4gICAgICAgICAgICBkaWZmcyA9IDAsXG4gICAgICAgICAgICBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoZG9udENvbnZlcnQgJiYgYXJyYXkxW2ldICE9PSBhcnJheTJbaV0pIHx8XG4gICAgICAgICAgICAgICAgKCFkb250Q29udmVydCAmJiB0b0ludChhcnJheTFbaV0pICE9PSB0b0ludChhcnJheTJbaV0pKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgZGlmZnMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlmZnMgKyBsZW5ndGhEaWZmO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGZ1bmN0aW9uIG9mZnNldCh0b2tlbiwgc2VwYXJhdG9yKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy51dGNPZmZzZXQoKSxcbiAgICAgICAgICAgICAgICBzaWduID0gJysnO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAtb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHNpZ24gPSAnLSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHNpZ24gK1xuICAgICAgICAgICAgICAgIHplcm9GaWxsKH5+KG9mZnNldCAvIDYwKSwgMikgK1xuICAgICAgICAgICAgICAgIHNlcGFyYXRvciArXG4gICAgICAgICAgICAgICAgemVyb0ZpbGwofn5vZmZzZXQgJSA2MCwgMilcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9mZnNldCgnWicsICc6Jyk7XG4gICAgb2Zmc2V0KCdaWicsICcnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1onLCBtYXRjaFNob3J0T2Zmc2V0KTtcbiAgICBhZGRSZWdleFRva2VuKCdaWicsIG1hdGNoU2hvcnRPZmZzZXQpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydaJywgJ1paJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX3VzZVVUQyA9IHRydWU7XG4gICAgICAgIGNvbmZpZy5fdHptID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyB0aW1lem9uZSBjaHVua2VyXG4gICAgLy8gJysxMDowMCcgPiBbJzEwJywgICcwMCddXG4gICAgLy8gJy0xNTMwJyAgPiBbJy0xNScsICczMCddXG4gICAgdmFyIGNodW5rT2Zmc2V0ID0gLyhbXFwrXFwtXXxcXGRcXGQpL2dpO1xuXG4gICAgZnVuY3Rpb24gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaGVyLCBzdHJpbmcpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSAoc3RyaW5nIHx8ICcnKS5tYXRjaChtYXRjaGVyKSxcbiAgICAgICAgICAgIGNodW5rLFxuICAgICAgICAgICAgcGFydHMsXG4gICAgICAgICAgICBtaW51dGVzO1xuXG4gICAgICAgIGlmIChtYXRjaGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNodW5rID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdIHx8IFtdO1xuICAgICAgICBwYXJ0cyA9IChjaHVuayArICcnKS5tYXRjaChjaHVua09mZnNldCkgfHwgWyctJywgMCwgMF07XG4gICAgICAgIG1pbnV0ZXMgPSArKHBhcnRzWzFdICogNjApICsgdG9JbnQocGFydHNbMl0pO1xuXG4gICAgICAgIHJldHVybiBtaW51dGVzID09PSAwID8gMCA6IHBhcnRzWzBdID09PSAnKycgPyBtaW51dGVzIDogLW1pbnV0ZXM7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGEgbW9tZW50IGZyb20gaW5wdXQsIHRoYXQgaXMgbG9jYWwvdXRjL3pvbmUgZXF1aXZhbGVudCB0byBtb2RlbC5cbiAgICBmdW5jdGlvbiBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIG1vZGVsKSB7XG4gICAgICAgIHZhciByZXMsIGRpZmY7XG4gICAgICAgIGlmIChtb2RlbC5faXNVVEMpIHtcbiAgICAgICAgICAgIHJlcyA9IG1vZGVsLmNsb25lKCk7XG4gICAgICAgICAgICBkaWZmID1cbiAgICAgICAgICAgICAgICAoaXNNb21lbnQoaW5wdXQpIHx8IGlzRGF0ZShpbnB1dClcbiAgICAgICAgICAgICAgICAgICAgPyBpbnB1dC52YWx1ZU9mKClcbiAgICAgICAgICAgICAgICAgICAgOiBjcmVhdGVMb2NhbChpbnB1dCkudmFsdWVPZigpKSAtIHJlcy52YWx1ZU9mKCk7XG4gICAgICAgICAgICAvLyBVc2UgbG93LWxldmVsIGFwaSwgYmVjYXVzZSB0aGlzIGZuIGlzIGxvdy1sZXZlbCBhcGkuXG4gICAgICAgICAgICByZXMuX2Quc2V0VGltZShyZXMuX2QudmFsdWVPZigpICsgZGlmZik7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQocmVzLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0KS5sb2NhbCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF0ZU9mZnNldChtKSB7XG4gICAgICAgIC8vIE9uIEZpcmVmb3guMjQgRGF0ZSNnZXRUaW1lem9uZU9mZnNldCByZXR1cm5zIGEgZmxvYXRpbmcgcG9pbnQuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L3B1bGwvMTg3MVxuICAgICAgICByZXR1cm4gLU1hdGgucm91bmQobS5fZC5nZXRUaW1lem9uZU9mZnNldCgpKTtcbiAgICB9XG5cbiAgICAvLyBIT09LU1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciBhIG1vbWVudCBpcyBtdXRhdGVkLlxuICAgIC8vIEl0IGlzIGludGVuZGVkIHRvIGtlZXAgdGhlIG9mZnNldCBpbiBzeW5jIHdpdGggdGhlIHRpbWV6b25lLlxuICAgIGhvb2tzLnVwZGF0ZU9mZnNldCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgLy8ga2VlcExvY2FsVGltZSA9IHRydWUgbWVhbnMgb25seSBjaGFuZ2UgdGhlIHRpbWV6b25lLCB3aXRob3V0XG4gICAgLy8gYWZmZWN0aW5nIHRoZSBsb2NhbCBob3VyLiBTbyA1OjMxOjI2ICswMzAwIC0tW3V0Y09mZnNldCgyLCB0cnVlKV0tLT5cbiAgICAvLyA1OjMxOjI2ICswMjAwIEl0IGlzIHBvc3NpYmxlIHRoYXQgNTozMToyNiBkb2Vzbid0IGV4aXN0IHdpdGggb2Zmc2V0XG4gICAgLy8gKzAyMDAsIHNvIHdlIGFkanVzdCB0aGUgdGltZSBhcyBuZWVkZWQsIHRvIGJlIHZhbGlkLlxuICAgIC8vXG4gICAgLy8gS2VlcGluZyB0aGUgdGltZSBhY3R1YWxseSBhZGRzL3N1YnRyYWN0cyAob25lIGhvdXIpXG4gICAgLy8gZnJvbSB0aGUgYWN0dWFsIHJlcHJlc2VudGVkIHRpbWUuIFRoYXQgaXMgd2h5IHdlIGNhbGwgdXBkYXRlT2Zmc2V0XG4gICAgLy8gYSBzZWNvbmQgdGltZS4gSW4gY2FzZSBpdCB3YW50cyB1cyB0byBjaGFuZ2UgdGhlIG9mZnNldCBhZ2FpblxuICAgIC8vIF9jaGFuZ2VJblByb2dyZXNzID09IHRydWUgY2FzZSwgdGhlbiB3ZSBoYXZlIHRvIGFkanVzdCwgYmVjYXVzZVxuICAgIC8vIHRoZXJlIGlzIG5vIHN1Y2ggdGltZSBpbiB0aGUgZ2l2ZW4gdGltZXpvbmUuXG4gICAgZnVuY3Rpb24gZ2V0U2V0T2Zmc2V0KGlucHV0LCBrZWVwTG9jYWxUaW1lLCBrZWVwTWludXRlcykge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0IHx8IDAsXG4gICAgICAgICAgICBsb2NhbEFkanVzdDtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoaW5wdXQpIDwgMTYgJiYgIWtlZXBNaW51dGVzKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dCAqIDYwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1VUQyAmJiBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxBZGp1c3QgPSBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5wdXQ7XG4gICAgICAgICAgICB0aGlzLl9pc1VUQyA9IHRydWU7XG4gICAgICAgICAgICBpZiAobG9jYWxBZGp1c3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGxvY2FsQWRqdXN0LCAnbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9mZnNldCAhPT0gaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWtlZXBMb2NhbFRpbWUgfHwgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICBhZGRTdWJ0cmFjdChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVEdXJhdGlvbihpbnB1dCAtIG9mZnNldCwgJ20nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyBvZmZzZXQgOiBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0Wm9uZShpbnB1dCwga2VlcExvY2FsVGltZSkge1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IC1pbnB1dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoaW5wdXQsIGtlZXBMb2NhbFRpbWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAtdGhpcy51dGNPZmZzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvVVRDKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvTG9jYWwoa2VlcExvY2FsVGltZSkge1xuICAgICAgICBpZiAodGhpcy5faXNVVEMpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgICAgICAgICAgdGhpcy5faXNVVEMgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnRyYWN0KGdldERhdGVPZmZzZXQodGhpcyksICdtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl90em0gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQodGhpcy5fdHptLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX2kgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgdFpvbmUgPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoT2Zmc2V0LCB0aGlzLl9pKTtcbiAgICAgICAgICAgIGlmICh0Wm9uZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQodFpvbmUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNBbGlnbmVkSG91ck9mZnNldChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXQgPSBpbnB1dCA/IGNyZWF0ZUxvY2FsKGlucHV0KS51dGNPZmZzZXQoKSA6IDA7XG5cbiAgICAgICAgcmV0dXJuICh0aGlzLnV0Y09mZnNldCgpIC0gaW5wdXQpICUgNjAgPT09IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWUoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDApLnV0Y09mZnNldCgpIHx8XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDUpLnV0Y09mZnNldCgpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkKCkge1xuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX2lzRFNUU2hpZnRlZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYyA9IHt9LFxuICAgICAgICAgICAgb3RoZXI7XG5cbiAgICAgICAgY29weUNvbmZpZyhjLCB0aGlzKTtcbiAgICAgICAgYyA9IHByZXBhcmVDb25maWcoYyk7XG5cbiAgICAgICAgaWYgKGMuX2EpIHtcbiAgICAgICAgICAgIG90aGVyID0gYy5faXNVVEMgPyBjcmVhdGVVVEMoYy5fYSkgOiBjcmVhdGVMb2NhbChjLl9hKTtcbiAgICAgICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9XG4gICAgICAgICAgICAgICAgdGhpcy5pc1ZhbGlkKCkgJiYgY29tcGFyZUFycmF5cyhjLl9hLCBvdGhlci50b0FycmF5KCkpID4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xvY2FsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyAhdGhpcy5faXNVVEMgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0Y09mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0YygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgJiYgdGhpcy5fb2Zmc2V0ID09PSAwIDogZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQVNQLk5FVCBqc29uIGRhdGUgZm9ybWF0IHJlZ2V4XG4gICAgdmFyIGFzcE5ldFJlZ2V4ID0gL14oLXxcXCspPyg/OihcXGQqKVsuIF0pPyhcXGQrKTooXFxkKykoPzo6KFxcZCspKFxcLlxcZCopPyk/JC8sXG4gICAgICAgIC8vIGZyb20gaHR0cDovL2RvY3MuY2xvc3VyZS1saWJyYXJ5Lmdvb2dsZWNvZGUuY29tL2dpdC9jbG9zdXJlX2dvb2dfZGF0ZV9kYXRlLmpzLnNvdXJjZS5odG1sXG4gICAgICAgIC8vIHNvbWV3aGF0IG1vcmUgaW4gbGluZSB3aXRoIDQuNC4zLjIgMjAwNCBzcGVjLCBidXQgYWxsb3dzIGRlY2ltYWwgYW55d2hlcmVcbiAgICAgICAgLy8gYW5kIGZ1cnRoZXIgbW9kaWZpZWQgdG8gYWxsb3cgZm9yIHN0cmluZ3MgY29udGFpbmluZyBib3RoIHdlZWsgYW5kIGRheVxuICAgICAgICBpc29SZWdleCA9XG4gICAgICAgICAgICAvXigtfFxcKyk/UCg/OihbLStdP1swLTksLl0qKVkpPyg/OihbLStdP1swLTksLl0qKU0pPyg/OihbLStdP1swLTksLl0qKVcpPyg/OihbLStdP1swLTksLl0qKUQpPyg/OlQoPzooWy0rXT9bMC05LC5dKilIKT8oPzooWy0rXT9bMC05LC5dKilNKT8oPzooWy0rXT9bMC05LC5dKilTKT8pPyQvO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRHVyYXRpb24oaW5wdXQsIGtleSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBpbnB1dCxcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIGFnYWluc3QgcmVnZXhwIGlzIGV4cGVuc2l2ZSwgZG8gaXQgb24gZGVtYW5kXG4gICAgICAgICAgICBtYXRjaCA9IG51bGwsXG4gICAgICAgICAgICBzaWduLFxuICAgICAgICAgICAgcmV0LFxuICAgICAgICAgICAgZGlmZlJlcztcblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIG1zOiBpbnB1dC5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgICAgIGQ6IGlucHV0Ll9kYXlzLFxuICAgICAgICAgICAgICAgIE06IGlucHV0Ll9tb250aHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlucHV0KSB8fCAhaXNOYU4oK2lucHV0KSkge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbltrZXldID0gK2lucHV0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbi5taWxsaXNlY29uZHMgPSAraW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoKG1hdGNoID0gYXNwTmV0UmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWduID0gbWF0Y2hbMV0gPT09ICctJyA/IC0xIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgZDogdG9JbnQobWF0Y2hbREFURV0pICogc2lnbixcbiAgICAgICAgICAgICAgICBoOiB0b0ludChtYXRjaFtIT1VSXSkgKiBzaWduLFxuICAgICAgICAgICAgICAgIG06IHRvSW50KG1hdGNoW01JTlVURV0pICogc2lnbixcbiAgICAgICAgICAgICAgICBzOiB0b0ludChtYXRjaFtTRUNPTkRdKSAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbXM6IHRvSW50KGFic1JvdW5kKG1hdGNoW01JTExJU0VDT05EXSAqIDEwMDApKSAqIHNpZ24sIC8vIHRoZSBtaWxsaXNlY29uZCBkZWNpbWFsIHBvaW50IGlzIGluY2x1ZGVkIGluIHRoZSBtYXRjaFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICgobWF0Y2ggPSBpc29SZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgIHNpZ24gPSBtYXRjaFsxXSA9PT0gJy0nID8gLTEgOiAxO1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeTogcGFyc2VJc28obWF0Y2hbMl0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIE06IHBhcnNlSXNvKG1hdGNoWzNdLCBzaWduKSxcbiAgICAgICAgICAgICAgICB3OiBwYXJzZUlzbyhtYXRjaFs0XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgZDogcGFyc2VJc28obWF0Y2hbNV0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIGg6IHBhcnNlSXNvKG1hdGNoWzZdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBtOiBwYXJzZUlzbyhtYXRjaFs3XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgczogcGFyc2VJc28obWF0Y2hbOF0sIHNpZ24pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgdHlwZW9mIGR1cmF0aW9uID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgKCdmcm9tJyBpbiBkdXJhdGlvbiB8fCAndG8nIGluIGR1cmF0aW9uKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGRpZmZSZXMgPSBtb21lbnRzRGlmZmVyZW5jZShcbiAgICAgICAgICAgICAgICBjcmVhdGVMb2NhbChkdXJhdGlvbi5mcm9tKSxcbiAgICAgICAgICAgICAgICBjcmVhdGVMb2NhbChkdXJhdGlvbi50bylcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBkdXJhdGlvbi5tcyA9IGRpZmZSZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgZHVyYXRpb24uTSA9IGRpZmZSZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0ID0gbmV3IER1cmF0aW9uKGR1cmF0aW9uKTtcblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkgJiYgaGFzT3duUHJvcChpbnB1dCwgJ19sb2NhbGUnKSkge1xuICAgICAgICAgICAgcmV0Ll9sb2NhbGUgPSBpbnB1dC5fbG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpICYmIGhhc093blByb3AoaW5wdXQsICdfaXNWYWxpZCcpKSB7XG4gICAgICAgICAgICByZXQuX2lzVmFsaWQgPSBpbnB1dC5faXNWYWxpZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgY3JlYXRlRHVyYXRpb24uZm4gPSBEdXJhdGlvbi5wcm90b3R5cGU7XG4gICAgY3JlYXRlRHVyYXRpb24uaW52YWxpZCA9IGNyZWF0ZUludmFsaWQkMTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlSXNvKGlucCwgc2lnbikge1xuICAgICAgICAvLyBXZSdkIG5vcm1hbGx5IHVzZSB+fmlucCBmb3IgdGhpcywgYnV0IHVuZm9ydHVuYXRlbHkgaXQgYWxzb1xuICAgICAgICAvLyBjb252ZXJ0cyBmbG9hdHMgdG8gaW50cy5cbiAgICAgICAgLy8gaW5wIG1heSBiZSB1bmRlZmluZWQsIHNvIGNhcmVmdWwgY2FsbGluZyByZXBsYWNlIG9uIGl0LlxuICAgICAgICB2YXIgcmVzID0gaW5wICYmIHBhcnNlRmxvYXQoaW5wLnJlcGxhY2UoJywnLCAnLicpKTtcbiAgICAgICAgLy8gYXBwbHkgc2lnbiB3aGlsZSB3ZSdyZSBhdCBpdFxuICAgICAgICByZXR1cm4gKGlzTmFOKHJlcykgPyAwIDogcmVzKSAqIHNpZ247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzID0ge307XG5cbiAgICAgICAgcmVzLm1vbnRocyA9XG4gICAgICAgICAgICBvdGhlci5tb250aCgpIC0gYmFzZS5tb250aCgpICsgKG90aGVyLnllYXIoKSAtIGJhc2UueWVhcigpKSAqIDEyO1xuICAgICAgICBpZiAoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpLmlzQWZ0ZXIob3RoZXIpKSB7XG4gICAgICAgICAgICAtLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gK290aGVyIC0gK2Jhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKTtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIGlmICghKGJhc2UuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1pbGxpc2Vjb25kczogMCwgbW9udGhzOiAwIH07XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlciA9IGNsb25lV2l0aE9mZnNldChvdGhlciwgYmFzZSk7XG4gICAgICAgIGlmIChiYXNlLmlzQmVmb3JlKG90aGVyKSkge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKG90aGVyLCBiYXNlKTtcbiAgICAgICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSAtcmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIHJlcy5tb250aHMgPSAtcmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogcmVtb3ZlICduYW1lJyBhcmcgYWZ0ZXIgZGVwcmVjYXRpb24gaXMgcmVtb3ZlZFxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFkZGVyKGRpcmVjdGlvbiwgbmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCwgcGVyaW9kKSB7XG4gICAgICAgICAgICB2YXIgZHVyLCB0bXA7XG4gICAgICAgICAgICAvL2ludmVydCB0aGUgYXJndW1lbnRzLCBidXQgY29tcGxhaW4gYWJvdXQgaXRcbiAgICAgICAgICAgIGlmIChwZXJpb2QgIT09IG51bGwgJiYgIWlzTmFOKCtwZXJpb2QpKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAnbW9tZW50KCkuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcocGVyaW9kLCBudW1iZXIpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgbW9tZW50KCkuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcobnVtYmVyLCBwZXJpb2QpLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9hZGQtaW52ZXJ0ZWQtcGFyYW0vIGZvciBtb3JlIGluZm8uJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdG1wID0gdmFsO1xuICAgICAgICAgICAgICAgIHZhbCA9IHBlcmlvZDtcbiAgICAgICAgICAgICAgICBwZXJpb2QgPSB0bXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGR1ciA9IGNyZWF0ZUR1cmF0aW9uKHZhbCwgcGVyaW9kKTtcbiAgICAgICAgICAgIGFkZFN1YnRyYWN0KHRoaXMsIGR1ciwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFN1YnRyYWN0KG1vbSwgZHVyYXRpb24sIGlzQWRkaW5nLCB1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IGR1cmF0aW9uLl9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICBkYXlzID0gYWJzUm91bmQoZHVyYXRpb24uX2RheXMpLFxuICAgICAgICAgICAgbW9udGhzID0gYWJzUm91bmQoZHVyYXRpb24uX21vbnRocyk7XG5cbiAgICAgICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAvLyBObyBvcFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlT2Zmc2V0ID0gdXBkYXRlT2Zmc2V0ID09IG51bGwgPyB0cnVlIDogdXBkYXRlT2Zmc2V0O1xuXG4gICAgICAgIGlmIChtb250aHMpIHtcbiAgICAgICAgICAgIHNldE1vbnRoKG1vbSwgZ2V0KG1vbSwgJ01vbnRoJykgKyBtb250aHMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRheXMpIHtcbiAgICAgICAgICAgIHNldCQxKG1vbSwgJ0RhdGUnLCBnZXQobW9tLCAnRGF0ZScpICsgZGF5cyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWlsbGlzZWNvbmRzKSB7XG4gICAgICAgICAgICBtb20uX2Quc2V0VGltZShtb20uX2QudmFsdWVPZigpICsgbWlsbGlzZWNvbmRzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldChtb20sIGRheXMgfHwgbW9udGhzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhZGQgPSBjcmVhdGVBZGRlcigxLCAnYWRkJyksXG4gICAgICAgIHN1YnRyYWN0ID0gY3JlYXRlQWRkZXIoLTEsICdzdWJ0cmFjdCcpO1xuXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgfHwgaW5wdXQgaW5zdGFuY2VvZiBTdHJpbmc7XG4gICAgfVxuXG4gICAgLy8gdHlwZSBNb21lbnRJbnB1dCA9IE1vbWVudCB8IERhdGUgfCBzdHJpbmcgfCBudW1iZXIgfCAobnVtYmVyIHwgc3RyaW5nKVtdIHwgTW9tZW50SW5wdXRPYmplY3QgfCB2b2lkOyAvLyBudWxsIHwgdW5kZWZpbmVkXG4gICAgZnVuY3Rpb24gaXNNb21lbnRJbnB1dChpbnB1dCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaXNNb21lbnQoaW5wdXQpIHx8XG4gICAgICAgICAgICBpc0RhdGUoaW5wdXQpIHx8XG4gICAgICAgICAgICBpc1N0cmluZyhpbnB1dCkgfHxcbiAgICAgICAgICAgIGlzTnVtYmVyKGlucHV0KSB8fFxuICAgICAgICAgICAgaXNOdW1iZXJPclN0cmluZ0FycmF5KGlucHV0KSB8fFxuICAgICAgICAgICAgaXNNb21lbnRJbnB1dE9iamVjdChpbnB1dCkgfHxcbiAgICAgICAgICAgIGlucHV0ID09PSBudWxsIHx8XG4gICAgICAgICAgICBpbnB1dCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNNb21lbnRJbnB1dE9iamVjdChpbnB1dCkge1xuICAgICAgICB2YXIgb2JqZWN0VGVzdCA9IGlzT2JqZWN0KGlucHV0KSAmJiAhaXNPYmplY3RFbXB0eShpbnB1dCksXG4gICAgICAgICAgICBwcm9wZXJ0eVRlc3QgPSBmYWxzZSxcbiAgICAgICAgICAgIHByb3BlcnRpZXMgPSBbXG4gICAgICAgICAgICAgICAgJ3llYXJzJyxcbiAgICAgICAgICAgICAgICAneWVhcicsXG4gICAgICAgICAgICAgICAgJ3knLFxuICAgICAgICAgICAgICAgICdtb250aHMnLFxuICAgICAgICAgICAgICAgICdtb250aCcsXG4gICAgICAgICAgICAgICAgJ00nLFxuICAgICAgICAgICAgICAgICdkYXlzJyxcbiAgICAgICAgICAgICAgICAnZGF5JyxcbiAgICAgICAgICAgICAgICAnZCcsXG4gICAgICAgICAgICAgICAgJ2RhdGVzJyxcbiAgICAgICAgICAgICAgICAnZGF0ZScsXG4gICAgICAgICAgICAgICAgJ0QnLFxuICAgICAgICAgICAgICAgICdob3VycycsXG4gICAgICAgICAgICAgICAgJ2hvdXInLFxuICAgICAgICAgICAgICAgICdoJyxcbiAgICAgICAgICAgICAgICAnbWludXRlcycsXG4gICAgICAgICAgICAgICAgJ21pbnV0ZScsXG4gICAgICAgICAgICAgICAgJ20nLFxuICAgICAgICAgICAgICAgICdzZWNvbmRzJyxcbiAgICAgICAgICAgICAgICAnc2Vjb25kJyxcbiAgICAgICAgICAgICAgICAncycsXG4gICAgICAgICAgICAgICAgJ21pbGxpc2Vjb25kcycsXG4gICAgICAgICAgICAgICAgJ21pbGxpc2Vjb25kJyxcbiAgICAgICAgICAgICAgICAnbXMnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgICAgIHByb3BlcnR5TGVuID0gcHJvcGVydGllcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHByb3BlcnR5TGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHByb3BlcnR5ID0gcHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgIHByb3BlcnR5VGVzdCA9IHByb3BlcnR5VGVzdCB8fCBoYXNPd25Qcm9wKGlucHV0LCBwcm9wZXJ0eSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqZWN0VGVzdCAmJiBwcm9wZXJ0eVRlc3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNOdW1iZXJPclN0cmluZ0FycmF5KGlucHV0KSB7XG4gICAgICAgIHZhciBhcnJheVRlc3QgPSBpc0FycmF5KGlucHV0KSxcbiAgICAgICAgICAgIGRhdGFUeXBlVGVzdCA9IGZhbHNlO1xuICAgICAgICBpZiAoYXJyYXlUZXN0KSB7XG4gICAgICAgICAgICBkYXRhVHlwZVRlc3QgPVxuICAgICAgICAgICAgICAgIGlucHV0LmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWlzTnVtYmVyKGl0ZW0pICYmIGlzU3RyaW5nKGlucHV0KTtcbiAgICAgICAgICAgICAgICB9KS5sZW5ndGggPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5VGVzdCAmJiBkYXRhVHlwZVRlc3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNDYWxlbmRhclNwZWMoaW5wdXQpIHtcbiAgICAgICAgdmFyIG9iamVjdFRlc3QgPSBpc09iamVjdChpbnB1dCkgJiYgIWlzT2JqZWN0RW1wdHkoaW5wdXQpLFxuICAgICAgICAgICAgcHJvcGVydHlUZXN0ID0gZmFsc2UsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzID0gW1xuICAgICAgICAgICAgICAgICdzYW1lRGF5JyxcbiAgICAgICAgICAgICAgICAnbmV4dERheScsXG4gICAgICAgICAgICAgICAgJ2xhc3REYXknLFxuICAgICAgICAgICAgICAgICduZXh0V2VlaycsXG4gICAgICAgICAgICAgICAgJ2xhc3RXZWVrJyxcbiAgICAgICAgICAgICAgICAnc2FtZUVsc2UnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBwcm9wZXJ0eTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgcHJvcGVydHlUZXN0ID0gcHJvcGVydHlUZXN0IHx8IGhhc093blByb3AoaW5wdXQsIHByb3BlcnR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmplY3RUZXN0ICYmIHByb3BlcnR5VGVzdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDYWxlbmRhckZvcm1hdChteU1vbWVudCwgbm93KSB7XG4gICAgICAgIHZhciBkaWZmID0gbXlNb21lbnQuZGlmZihub3csICdkYXlzJywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBkaWZmIDwgLTZcbiAgICAgICAgICAgID8gJ3NhbWVFbHNlJ1xuICAgICAgICAgICAgOiBkaWZmIDwgLTFcbiAgICAgICAgICAgID8gJ2xhc3RXZWVrJ1xuICAgICAgICAgICAgOiBkaWZmIDwgMFxuICAgICAgICAgICAgPyAnbGFzdERheSdcbiAgICAgICAgICAgIDogZGlmZiA8IDFcbiAgICAgICAgICAgID8gJ3NhbWVEYXknXG4gICAgICAgICAgICA6IGRpZmYgPCAyXG4gICAgICAgICAgICA/ICduZXh0RGF5J1xuICAgICAgICAgICAgOiBkaWZmIDwgN1xuICAgICAgICAgICAgPyAnbmV4dFdlZWsnXG4gICAgICAgICAgICA6ICdzYW1lRWxzZSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsZW5kYXIkMSh0aW1lLCBmb3JtYXRzKSB7XG4gICAgICAgIC8vIFN1cHBvcnQgZm9yIHNpbmdsZSBwYXJhbWV0ZXIsIGZvcm1hdHMgb25seSBvdmVybG9hZCB0byB0aGUgY2FsZW5kYXIgZnVuY3Rpb25cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzWzBdKSB7XG4gICAgICAgICAgICAgICAgdGltZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBmb3JtYXRzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc01vbWVudElucHV0KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgICAgICAgICB0aW1lID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIGZvcm1hdHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzQ2FsZW5kYXJTcGVjKGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgICAgICAgICBmb3JtYXRzID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIHRpbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cbiAgICAgICAgLy8gR2V0dGluZyBzdGFydC1vZi10b2RheSBkZXBlbmRzIG9uIHdoZXRoZXIgd2UncmUgbG9jYWwvdXRjL29mZnNldCBvciBub3QuXG4gICAgICAgIHZhciBub3cgPSB0aW1lIHx8IGNyZWF0ZUxvY2FsKCksXG4gICAgICAgICAgICBzb2QgPSBjbG9uZVdpdGhPZmZzZXQobm93LCB0aGlzKS5zdGFydE9mKCdkYXknKSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGhvb2tzLmNhbGVuZGFyRm9ybWF0KHRoaXMsIHNvZCkgfHwgJ3NhbWVFbHNlJyxcbiAgICAgICAgICAgIG91dHB1dCA9XG4gICAgICAgICAgICAgICAgZm9ybWF0cyAmJlxuICAgICAgICAgICAgICAgIChpc0Z1bmN0aW9uKGZvcm1hdHNbZm9ybWF0XSlcbiAgICAgICAgICAgICAgICAgICAgPyBmb3JtYXRzW2Zvcm1hdF0uY2FsbCh0aGlzLCBub3cpXG4gICAgICAgICAgICAgICAgICAgIDogZm9ybWF0c1tmb3JtYXRdKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQoXG4gICAgICAgICAgICBvdXRwdXQgfHwgdGhpcy5sb2NhbGVEYXRhKCkuY2FsZW5kYXIoZm9ybWF0LCB0aGlzLCBjcmVhdGVMb2NhbChub3cpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1vbWVudCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FmdGVyKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB8fCAnbWlsbGlzZWNvbmQnO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA+IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsSW5wdXQudmFsdWVPZigpIDwgdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQmVmb3JlKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB8fCAnbWlsbGlzZWNvbmQnO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JldHdlZW4oZnJvbSwgdG8sIHVuaXRzLCBpbmNsdXNpdml0eSkge1xuICAgICAgICB2YXIgbG9jYWxGcm9tID0gaXNNb21lbnQoZnJvbSkgPyBmcm9tIDogY3JlYXRlTG9jYWwoZnJvbSksXG4gICAgICAgICAgICBsb2NhbFRvID0gaXNNb21lbnQodG8pID8gdG8gOiBjcmVhdGVMb2NhbCh0byk7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsRnJvbS5pc1ZhbGlkKCkgJiYgbG9jYWxUby5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaW5jbHVzaXZpdHkgPSBpbmNsdXNpdml0eSB8fCAnKCknO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGluY2x1c2l2aXR5WzBdID09PSAnKCdcbiAgICAgICAgICAgICAgICA/IHRoaXMuaXNBZnRlcihsb2NhbEZyb20sIHVuaXRzKVxuICAgICAgICAgICAgICAgIDogIXRoaXMuaXNCZWZvcmUobG9jYWxGcm9tLCB1bml0cykpICYmXG4gICAgICAgICAgICAoaW5jbHVzaXZpdHlbMV0gPT09ICcpJ1xuICAgICAgICAgICAgICAgID8gdGhpcy5pc0JlZm9yZShsb2NhbFRvLCB1bml0cylcbiAgICAgICAgICAgICAgICA6ICF0aGlzLmlzQWZ0ZXIobG9jYWxUbywgdW5pdHMpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZShpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KSxcbiAgICAgICAgICAgIGlucHV0TXM7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpIHx8ICdtaWxsaXNlY29uZCc7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID09PSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0TXMgPSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKSA8PSBpbnB1dE1zICYmXG4gICAgICAgICAgICAgICAgaW5wdXRNcyA8PSB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQWZ0ZXIoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNBZnRlcihpbnB1dCwgdW5pdHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQmVmb3JlKGlucHV0LCB1bml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQmVmb3JlKGlucHV0LCB1bml0cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlmZihpbnB1dCwgdW5pdHMsIGFzRmxvYXQpIHtcbiAgICAgICAgdmFyIHRoYXQsIHpvbmVEZWx0YSwgb3V0cHV0O1xuXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICB0aGF0ID0gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCB0aGlzKTtcblxuICAgICAgICBpZiAoIXRoYXQuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgem9uZURlbHRhID0gKHRoYXQudXRjT2Zmc2V0KCkgLSB0aGlzLnV0Y09mZnNldCgpKSAqIDZlNDtcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAxMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gMWUzO1xuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyAxMDAwXG4gICAgICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyA2ZTQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDM2ZTU7XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIDEwMDAgKiA2MCAqIDYwXG4gICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0aGlzIC0gdGhhdCAtIHpvbmVEZWx0YSkgLyA4NjRlNTtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gMTAwMCAqIDYwICogNjAgKiAyNCwgbmVnYXRlIGRzdFxuICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRoaXMgLSB0aGF0IC0gem9uZURlbHRhKSAvIDYwNDhlNTtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gMTAwMCAqIDYwICogNjAgKiAyNCAqIDcsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gdGhpcyAtIHRoYXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXNGbG9hdCA/IG91dHB1dCA6IGFic0Zsb29yKG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhEaWZmKGEsIGIpIHtcbiAgICAgICAgaWYgKGEuZGF0ZSgpIDwgYi5kYXRlKCkpIHtcbiAgICAgICAgICAgIC8vIGVuZC1vZi1tb250aCBjYWxjdWxhdGlvbnMgd29yayBjb3JyZWN0IHdoZW4gdGhlIHN0YXJ0IG1vbnRoIGhhcyBtb3JlXG4gICAgICAgICAgICAvLyBkYXlzIHRoYW4gdGhlIGVuZCBtb250aC5cbiAgICAgICAgICAgIHJldHVybiAtbW9udGhEaWZmKGIsIGEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRpZmZlcmVuY2UgaW4gbW9udGhzXG4gICAgICAgIHZhciB3aG9sZU1vbnRoRGlmZiA9IChiLnllYXIoKSAtIGEueWVhcigpKSAqIDEyICsgKGIubW9udGgoKSAtIGEubW9udGgoKSksXG4gICAgICAgICAgICAvLyBiIGlzIGluIChhbmNob3IgLSAxIG1vbnRoLCBhbmNob3IgKyAxIG1vbnRoKVxuICAgICAgICAgICAgYW5jaG9yID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiwgJ21vbnRocycpLFxuICAgICAgICAgICAgYW5jaG9yMixcbiAgICAgICAgICAgIGFkanVzdDtcblxuICAgICAgICBpZiAoYiAtIGFuY2hvciA8IDApIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmIC0gMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IgLSBhbmNob3IyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmICsgMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IyIC0gYW5jaG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY2hlY2sgZm9yIG5lZ2F0aXZlIHplcm8sIHJldHVybiB6ZXJvIGlmIG5lZ2F0aXZlIHplcm9cbiAgICAgICAgcmV0dXJuIC0od2hvbGVNb250aERpZmYgKyBhZGp1c3QpIHx8IDA7XG4gICAgfVxuXG4gICAgaG9va3MuZGVmYXVsdEZvcm1hdCA9ICdZWVlZLU1NLUREVEhIOm1tOnNzWic7XG4gICAgaG9va3MuZGVmYXVsdEZvcm1hdFV0YyA9ICdZWVlZLU1NLUREVEhIOm1tOnNzW1pdJztcblxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmxvY2FsZSgnZW4nKS5mb3JtYXQoJ2RkZCBNTU0gREQgWVlZWSBISDptbTpzcyBbR01UXVpaJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JU09TdHJpbmcoa2VlcE9mZnNldCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXRjID0ga2VlcE9mZnNldCAhPT0gdHJ1ZSxcbiAgICAgICAgICAgIG0gPSB1dGMgPyB0aGlzLmNsb25lKCkudXRjKCkgOiB0aGlzO1xuICAgICAgICBpZiAobS55ZWFyKCkgPCAwIHx8IG0ueWVhcigpID4gOTk5OSkge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChcbiAgICAgICAgICAgICAgICBtLFxuICAgICAgICAgICAgICAgIHV0Y1xuICAgICAgICAgICAgICAgICAgICA/ICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nXG4gICAgICAgICAgICAgICAgICAgIDogJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1onXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKSkge1xuICAgICAgICAgICAgLy8gbmF0aXZlIGltcGxlbWVudGF0aW9uIGlzIH41MHggZmFzdGVyLCB1c2UgaXQgd2hlbiB3ZSBjYW5cbiAgICAgICAgICAgIGlmICh1dGMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0RhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy52YWx1ZU9mKCkgKyB0aGlzLnV0Y09mZnNldCgpICogNjAgKiAxMDAwKVxuICAgICAgICAgICAgICAgICAgICAudG9JU09TdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgnWicsIGZvcm1hdE1vbWVudChtLCAnWicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KFxuICAgICAgICAgICAgbSxcbiAgICAgICAgICAgIHV0YyA/ICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyA6ICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTWidcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBodW1hbiByZWFkYWJsZSByZXByZXNlbnRhdGlvbiBvZiBhIG1vbWVudCB0aGF0IGNhblxuICAgICAqIGFsc28gYmUgZXZhbHVhdGVkIHRvIGdldCBhIG5ldyBtb21lbnQgd2hpY2ggaXMgdGhlIHNhbWVcbiAgICAgKlxuICAgICAqIEBsaW5rIGh0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC9kb2NzL2FwaS91dGlsLmh0bWwjdXRpbF9jdXN0b21faW5zcGVjdF9mdW5jdGlvbl9vbl9vYmplY3RzXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuICdtb21lbnQuaW52YWxpZCgvKiAnICsgdGhpcy5faSArICcgKi8pJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnVuYyA9ICdtb21lbnQnLFxuICAgICAgICAgICAgem9uZSA9ICcnLFxuICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgeWVhcixcbiAgICAgICAgICAgIGRhdGV0aW1lLFxuICAgICAgICAgICAgc3VmZml4O1xuICAgICAgICBpZiAoIXRoaXMuaXNMb2NhbCgpKSB7XG4gICAgICAgICAgICBmdW5jID0gdGhpcy51dGNPZmZzZXQoKSA9PT0gMCA/ICdtb21lbnQudXRjJyA6ICdtb21lbnQucGFyc2Vab25lJztcbiAgICAgICAgICAgIHpvbmUgPSAnWic7XG4gICAgICAgIH1cbiAgICAgICAgcHJlZml4ID0gJ1snICsgZnVuYyArICcoXCJdJztcbiAgICAgICAgeWVhciA9IDAgPD0gdGhpcy55ZWFyKCkgJiYgdGhpcy55ZWFyKCkgPD0gOTk5OSA/ICdZWVlZJyA6ICdZWVlZWVknO1xuICAgICAgICBkYXRldGltZSA9ICctTU0tRERbVF1ISDptbTpzcy5TU1MnO1xuICAgICAgICBzdWZmaXggPSB6b25lICsgJ1tcIildJztcblxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQocHJlZml4ICsgeWVhciArIGRhdGV0aW1lICsgc3VmZml4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXQoaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgaWYgKCFpbnB1dFN0cmluZykge1xuICAgICAgICAgICAgaW5wdXRTdHJpbmcgPSB0aGlzLmlzVXRjKClcbiAgICAgICAgICAgICAgICA/IGhvb2tzLmRlZmF1bHRGb3JtYXRVdGNcbiAgICAgICAgICAgICAgICA6IGhvb2tzLmRlZmF1bHRGb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dHB1dCA9IGZvcm1hdE1vbWVudCh0aGlzLCBpbnB1dFN0cmluZyk7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbSh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fCBjcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHsgdG86IHRoaXMsIGZyb206IHRpbWUgfSlcbiAgICAgICAgICAgICAgICAubG9jYWxlKHRoaXMubG9jYWxlKCkpXG4gICAgICAgICAgICAgICAgLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbU5vdyh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb20oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG8odGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHwgY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7IGZyb206IHRoaXMsIHRvOiB0aW1lIH0pXG4gICAgICAgICAgICAgICAgLmxvY2FsZSh0aGlzLmxvY2FsZSgpKVxuICAgICAgICAgICAgICAgIC5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvTm93KHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG8oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgLy8gSWYgcGFzc2VkIGEgbG9jYWxlIGtleSwgaXQgd2lsbCBzZXQgdGhlIGxvY2FsZSBmb3IgdGhpc1xuICAgIC8vIGluc3RhbmNlLiAgT3RoZXJ3aXNlLCBpdCB3aWxsIHJldHVybiB0aGUgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbiAgICAvLyB2YXJpYWJsZXMgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAgZnVuY3Rpb24gbG9jYWxlKGtleSkge1xuICAgICAgICB2YXIgbmV3TG9jYWxlRGF0YTtcblxuICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGUuX2FiYnI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdMb2NhbGVEYXRhID0gZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgICAgICBpZiAobmV3TG9jYWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxlID0gbmV3TG9jYWxlRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxhbmcgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5sYW5nKCkgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlIG1vbWVudCgpLmxvY2FsZURhdGEoKSB0byBnZXQgdGhlIGxhbmd1YWdlIGNvbmZpZ3VyYXRpb24uIFVzZSBtb21lbnQoKS5sb2NhbGUoKSB0byBjaGFuZ2UgbGFuZ3VhZ2VzLicsXG4gICAgICAgIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZTtcbiAgICB9XG5cbiAgICB2YXIgTVNfUEVSX1NFQ09ORCA9IDEwMDAsXG4gICAgICAgIE1TX1BFUl9NSU5VVEUgPSA2MCAqIE1TX1BFUl9TRUNPTkQsXG4gICAgICAgIE1TX1BFUl9IT1VSID0gNjAgKiBNU19QRVJfTUlOVVRFLFxuICAgICAgICBNU19QRVJfNDAwX1lFQVJTID0gKDM2NSAqIDQwMCArIDk3KSAqIDI0ICogTVNfUEVSX0hPVVI7XG5cbiAgICAvLyBhY3R1YWwgbW9kdWxvIC0gaGFuZGxlcyBuZWdhdGl2ZSBudW1iZXJzIChmb3IgZGF0ZXMgYmVmb3JlIDE5NzApOlxuICAgIGZ1bmN0aW9uIG1vZCQxKGRpdmlkZW5kLCBkaXZpc29yKSB7XG4gICAgICAgIHJldHVybiAoKGRpdmlkZW5kICUgZGl2aXNvcikgKyBkaXZpc29yKSAlIGRpdmlzb3I7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxTdGFydE9mRGF0ZSh5LCBtLCBkKSB7XG4gICAgICAgIC8vIHRoZSBkYXRlIGNvbnN0cnVjdG9yIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDApIHtcbiAgICAgICAgICAgIC8vIHByZXNlcnZlIGxlYXAgeWVhcnMgdXNpbmcgYSBmdWxsIDQwMCB5ZWFyIGN5Y2xlLCB0aGVuIHJlc2V0XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoeSArIDQwMCwgbSwgZCkgLSBNU19QRVJfNDAwX1lFQVJTO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHksIG0sIGQpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHV0Y1N0YXJ0T2ZEYXRlKHksIG0sIGQpIHtcbiAgICAgICAgLy8gRGF0ZS5VVEMgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIHJldHVybiBEYXRlLlVUQyh5ICsgNDAwLCBtLCBkKSAtIE1TX1BFUl80MDBfWUVBUlM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gRGF0ZS5VVEMoeSwgbSwgZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGFydE9mKHVuaXRzKSB7XG4gICAgICAgIHZhciB0aW1lLCBzdGFydE9mRGF0ZTtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gdW5kZWZpbmVkIHx8IHVuaXRzID09PSAnbWlsbGlzZWNvbmQnIHx8ICF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydE9mRGF0ZSA9IHRoaXMuX2lzVVRDID8gdXRjU3RhcnRPZkRhdGUgOiBsb2NhbFN0YXJ0T2ZEYXRlO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgMCwgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueWVhcigpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCkgLSAodGhpcy5tb250aCgpICUgMyksXG4gICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFyKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGgoKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRlKCkgLSB0aGlzLndlZWtkYXkoKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpc29XZWVrJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueWVhcigpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSgpIC0gKHRoaXMuaXNvV2Vla2RheSgpIC0gMSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSAtPSBtb2QkMShcbiAgICAgICAgICAgICAgICAgICAgdGltZSArICh0aGlzLl9pc1VUQyA/IDAgOiB0aGlzLnV0Y09mZnNldCgpICogTVNfUEVSX01JTlVURSksXG4gICAgICAgICAgICAgICAgICAgIE1TX1BFUl9IT1VSXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgLT0gbW9kJDEodGltZSwgTVNfUEVSX01JTlVURSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lIC09IG1vZCQxKHRpbWUsIE1TX1BFUl9TRUNPTkQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZC5zZXRUaW1lKHRpbWUpO1xuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuZE9mKHVuaXRzKSB7XG4gICAgICAgIHZhciB0aW1lLCBzdGFydE9mRGF0ZTtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gdW5kZWZpbmVkIHx8IHVuaXRzID09PSAnbWlsbGlzZWNvbmQnIHx8ICF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydE9mRGF0ZSA9IHRoaXMuX2lzVVRDID8gdXRjU3RhcnRPZkRhdGUgOiBsb2NhbFN0YXJ0T2ZEYXRlO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSArIDEsIDAsIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPVxuICAgICAgICAgICAgICAgICAgICBzdGFydE9mRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueWVhcigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb250aCgpIC0gKHRoaXMubW9udGgoKSAlIDMpICsgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICAgICAgKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkgKyAxLCAxKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgICAgICB0aW1lID1cbiAgICAgICAgICAgICAgICAgICAgc3RhcnRPZkRhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnllYXIoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGgoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSgpIC0gdGhpcy53ZWVrZGF5KCkgKyA3XG4gICAgICAgICAgICAgICAgICAgICkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0T2ZEYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFyKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGUoKSAtICh0aGlzLmlzb1dlZWtkYXkoKSAtIDEpICsgN1xuICAgICAgICAgICAgICAgICAgICApIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgdGhpcy5kYXRlKCkgKyAxKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSArPVxuICAgICAgICAgICAgICAgICAgICBNU19QRVJfSE9VUiAtXG4gICAgICAgICAgICAgICAgICAgIG1vZCQxKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZSArICh0aGlzLl9pc1VUQyA/IDAgOiB0aGlzLnV0Y09mZnNldCgpICogTVNfUEVSX01JTlVURSksXG4gICAgICAgICAgICAgICAgICAgICAgICBNU19QRVJfSE9VUlxuICAgICAgICAgICAgICAgICAgICApIC1cbiAgICAgICAgICAgICAgICAgICAgMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX01JTlVURSAtIG1vZCQxKHRpbWUsIE1TX1BFUl9NSU5VVEUpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX1NFQ09ORCAtIG1vZCQxKHRpbWUsIE1TX1BFUl9TRUNPTkQpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2Quc2V0VGltZSh0aW1lKTtcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWx1ZU9mKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZC52YWx1ZU9mKCkgLSAodGhpcy5fb2Zmc2V0IHx8IDApICogNjAwMDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5peCgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy52YWx1ZU9mKCkgLyAxMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0RhdGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbS55ZWFyKCksXG4gICAgICAgICAgICBtLm1vbnRoKCksXG4gICAgICAgICAgICBtLmRhdGUoKSxcbiAgICAgICAgICAgIG0uaG91cigpLFxuICAgICAgICAgICAgbS5taW51dGUoKSxcbiAgICAgICAgICAgIG0uc2Vjb25kKCksXG4gICAgICAgICAgICBtLm1pbGxpc2Vjb25kKCksXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9PYmplY3QoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXJzOiBtLnllYXIoKSxcbiAgICAgICAgICAgIG1vbnRoczogbS5tb250aCgpLFxuICAgICAgICAgICAgZGF0ZTogbS5kYXRlKCksXG4gICAgICAgICAgICBob3VyczogbS5ob3VycygpLFxuICAgICAgICAgICAgbWludXRlczogbS5taW51dGVzKCksXG4gICAgICAgICAgICBzZWNvbmRzOiBtLnNlY29uZHMoKSxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kczogbS5taWxsaXNlY29uZHMoKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgIC8vIG5ldyBEYXRlKE5hTikudG9KU09OKCkgPT09IG51bGxcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy50b0lTT1N0cmluZygpIDogbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkJDIoKSB7XG4gICAgICAgIHJldHVybiBpc1ZhbGlkKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNpbmdGbGFncygpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh7fSwgZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkQXQoKSB7XG4gICAgICAgIHJldHVybiBnZXRQYXJzaW5nRmxhZ3ModGhpcykub3ZlcmZsb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRpb25EYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5wdXQ6IHRoaXMuX2ksXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuX2YsXG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMuX2xvY2FsZSxcbiAgICAgICAgICAgIGlzVVRDOiB0aGlzLl9pc1VUQyxcbiAgICAgICAgICAgIHN0cmljdDogdGhpcy5fc3RyaWN0LFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCdOJywgMCwgMCwgJ2VyYUFiYnInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignTk4nLCAwLCAwLCAnZXJhQWJicicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdOTk4nLCAwLCAwLCAnZXJhQWJicicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdOTk5OJywgMCwgMCwgJ2VyYU5hbWUnKTtcbiAgICBhZGRGb3JtYXRUb2tlbignTk5OTk4nLCAwLCAwLCAnZXJhTmFycm93Jyk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigneScsIFsneScsIDFdLCAneW8nLCAnZXJhWWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd5JywgWyd5eScsIDJdLCAwLCAnZXJhWWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd5JywgWyd5eXknLCAzXSwgMCwgJ2VyYVllYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigneScsIFsneXl5eScsIDRdLCAwLCAnZXJhWWVhcicpO1xuXG4gICAgYWRkUmVnZXhUb2tlbignTicsIG1hdGNoRXJhQWJicik7XG4gICAgYWRkUmVnZXhUb2tlbignTk4nLCBtYXRjaEVyYUFiYnIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ05OTicsIG1hdGNoRXJhQWJicik7XG4gICAgYWRkUmVnZXhUb2tlbignTk5OTicsIG1hdGNoRXJhTmFtZSk7XG4gICAgYWRkUmVnZXhUb2tlbignTk5OTk4nLCBtYXRjaEVyYU5hcnJvdyk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFxuICAgICAgICBbJ04nLCAnTk4nLCAnTk5OJywgJ05OTk4nLCAnTk5OTk4nXSxcbiAgICAgICAgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICAgICAgdmFyIGVyYSA9IGNvbmZpZy5fbG9jYWxlLmVyYXNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgICAgIGlmIChlcmEpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lcmEgPSBlcmE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRFcmEgPSBpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBhZGRSZWdleFRva2VuKCd5JywgbWF0Y2hVbnNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbigneXknLCBtYXRjaFVuc2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCd5eXknLCBtYXRjaFVuc2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCd5eXl5JywgbWF0Y2hVbnNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbigneW8nLCBtYXRjaEVyYVllYXJPcmRpbmFsKTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWyd5JywgJ3l5JywgJ3l5eScsICd5eXl5J10sIFlFQVIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWyd5byddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHZhciBtYXRjaDtcbiAgICAgICAgaWYgKGNvbmZpZy5fbG9jYWxlLl9lcmFZZWFyT3JkaW5hbFJlZ2V4KSB7XG4gICAgICAgICAgICBtYXRjaCA9IGlucHV0Lm1hdGNoKGNvbmZpZy5fbG9jYWxlLl9lcmFZZWFyT3JkaW5hbFJlZ2V4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuX2xvY2FsZS5lcmFZZWFyT3JkaW5hbFBhcnNlKSB7XG4gICAgICAgICAgICBhcnJheVtZRUFSXSA9IGNvbmZpZy5fbG9jYWxlLmVyYVllYXJPcmRpbmFsUGFyc2UoaW5wdXQsIG1hdGNoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycmF5W1lFQVJdID0gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRXJhcyhtLCBmb3JtYXQpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgZGF0ZSxcbiAgICAgICAgICAgIGVyYXMgPSB0aGlzLl9lcmFzIHx8IGdldExvY2FsZSgnZW4nKS5fZXJhcztcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBlcmFzW2ldLnNpbmNlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJ1bmNhdGUgdGltZVxuICAgICAgICAgICAgICAgICAgICBkYXRlID0gaG9va3MoZXJhc1tpXS5zaW5jZSkuc3RhcnRPZignZGF5Jyk7XG4gICAgICAgICAgICAgICAgICAgIGVyYXNbaV0uc2luY2UgPSBkYXRlLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGVyYXNbaV0udW50aWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgICAgICAgICAgICBlcmFzW2ldLnVudGlsID0gK0luZmluaXR5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgICAgICAgICAgICAgIGRhdGUgPSBob29rcyhlcmFzW2ldLnVudGlsKS5zdGFydE9mKCdkYXknKS52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgICAgIGVyYXNbaV0udW50aWwgPSBkYXRlLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVyYXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlRXJhc1BhcnNlKGVyYU5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIGVyYXMgPSB0aGlzLmVyYXMoKSxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBhYmJyLFxuICAgICAgICAgICAgbmFycm93O1xuICAgICAgICBlcmFOYW1lID0gZXJhTmFtZS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBlcmFzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgbmFtZSA9IGVyYXNbaV0ubmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgYWJiciA9IGVyYXNbaV0uYWJici50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgbmFycm93ID0gZXJhc1tpXS5uYXJyb3cudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ04nOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdOTic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ05OTic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWJiciA9PT0gZXJhTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTk5OTic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gZXJhTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTk5OTk4nOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hcnJvdyA9PT0gZXJhTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChbbmFtZSwgYWJiciwgbmFycm93XS5pbmRleE9mKGVyYU5hbWUpID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZUVyYXNDb252ZXJ0WWVhcihlcmEsIHllYXIpIHtcbiAgICAgICAgdmFyIGRpciA9IGVyYS5zaW5jZSA8PSBlcmEudW50aWwgPyArMSA6IC0xO1xuICAgICAgICBpZiAoeWVhciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaG9va3MoZXJhLnNpbmNlKS55ZWFyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaG9va3MoZXJhLnNpbmNlKS55ZWFyKCkgKyAoeWVhciAtIGVyYS5vZmZzZXQpICogZGlyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RXJhTmFtZSgpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMubG9jYWxlRGF0YSgpLmVyYXMoKTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgICAgICB2YWwgPSB0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykudmFsdWVPZigpO1xuXG4gICAgICAgICAgICBpZiAoZXJhc1tpXS5zaW5jZSA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0udW50aWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVyYXNbaV0udW50aWwgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnNpbmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV0ubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRFcmFOYXJyb3coKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgIGVyYXMgPSB0aGlzLmxvY2FsZURhdGEoKS5lcmFzKCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBlcmFzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgLy8gdHJ1bmNhdGUgdGltZVxuICAgICAgICAgICAgdmFsID0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpLnZhbHVlT2YoKTtcblxuICAgICAgICAgICAgaWYgKGVyYXNbaV0uc2luY2UgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnVudGlsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV0ubmFycm93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVyYXNbaV0udW50aWwgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnNpbmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV0ubmFycm93O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEVyYUFiYnIoKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgIGVyYXMgPSB0aGlzLmxvY2FsZURhdGEoKS5lcmFzKCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBlcmFzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgLy8gdHJ1bmNhdGUgdGltZVxuICAgICAgICAgICAgdmFsID0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpLnZhbHVlT2YoKTtcblxuICAgICAgICAgICAgaWYgKGVyYXNbaV0uc2luY2UgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnVudGlsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV0uYWJicjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcmFzW2ldLnVudGlsIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS5zaW5jZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldLmFiYnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RXJhWWVhcigpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgZGlyLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMubG9jYWxlRGF0YSgpLmVyYXMoKTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBkaXIgPSBlcmFzW2ldLnNpbmNlIDw9IGVyYXNbaV0udW50aWwgPyArMSA6IC0xO1xuXG4gICAgICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgICAgICB2YWwgPSB0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykudmFsdWVPZigpO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKGVyYXNbaV0uc2luY2UgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnVudGlsKSB8fFxuICAgICAgICAgICAgICAgIChlcmFzW2ldLnVudGlsIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS5zaW5jZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLnllYXIoKSAtIGhvb2tzKGVyYXNbaV0uc2luY2UpLnllYXIoKSkgKiBkaXIgK1xuICAgICAgICAgICAgICAgICAgICBlcmFzW2ldLm9mZnNldFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy55ZWFyKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXJhc05hbWVSZWdleChpc1N0cmljdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19lcmFzTmFtZVJlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVFcmFzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNTdHJpY3QgPyB0aGlzLl9lcmFzTmFtZVJlZ2V4IDogdGhpcy5fZXJhc1JlZ2V4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVyYXNBYmJyUmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfZXJhc0FiYnJSZWdleCcpKSB7XG4gICAgICAgICAgICBjb21wdXRlRXJhc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzU3RyaWN0ID8gdGhpcy5fZXJhc0FiYnJSZWdleCA6IHRoaXMuX2VyYXNSZWdleDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcmFzTmFycm93UmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfZXJhc05hcnJvd1JlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVFcmFzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNTdHJpY3QgPyB0aGlzLl9lcmFzTmFycm93UmVnZXggOiB0aGlzLl9lcmFzUmVnZXg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF0Y2hFcmFBYmJyKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5lcmFzQWJiclJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXRjaEVyYU5hbWUoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLmVyYXNOYW1lUmVnZXgoaXNTdHJpY3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hdGNoRXJhTmFycm93KGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5lcmFzTmFycm93UmVnZXgoaXNTdHJpY3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hdGNoRXJhWWVhck9yZGluYWwoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLl9lcmFZZWFyT3JkaW5hbFJlZ2V4IHx8IG1hdGNoVW5zaWduZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZUVyYXNQYXJzZSgpIHtcbiAgICAgICAgdmFyIGFiYnJQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIG5hbWVQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIG5hcnJvd1BpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMuZXJhcygpO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBlcmFzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgbmFtZVBpZWNlcy5wdXNoKHJlZ2V4RXNjYXBlKGVyYXNbaV0ubmFtZSkpO1xuICAgICAgICAgICAgYWJiclBpZWNlcy5wdXNoKHJlZ2V4RXNjYXBlKGVyYXNbaV0uYWJicikpO1xuICAgICAgICAgICAgbmFycm93UGllY2VzLnB1c2gocmVnZXhFc2NhcGUoZXJhc1tpXS5uYXJyb3cpKTtcblxuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChyZWdleEVzY2FwZShlcmFzW2ldLm5hbWUpKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gocmVnZXhFc2NhcGUoZXJhc1tpXS5hYmJyKSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHJlZ2V4RXNjYXBlKGVyYXNbaV0ubmFycm93KSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9lcmFzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX2VyYXNOYW1lUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBuYW1lUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fZXJhc0FiYnJSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGFiYnJQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9lcmFzTmFycm93UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ14oJyArIG5hcnJvd1BpZWNlcy5qb2luKCd8JykgKyAnKScsXG4gICAgICAgICAgICAnaSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ2dnJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2Vla1llYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnR0cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc29XZWVrWWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gYWRkV2Vla1llYXJGb3JtYXRUb2tlbih0b2tlbiwgZ2V0dGVyKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKDAsIFt0b2tlbiwgdG9rZW4ubGVuZ3RoXSwgMCwgZ2V0dGVyKTtcbiAgICB9XG5cbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnJywgJ3dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZ2cnLCAnd2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHJywgJ2lzb1dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHR0cnLCAnaXNvV2Vla1llYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnd2Vla1llYXInLCAnZ2cnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWtZZWFyJywgJ0dHJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCd3ZWVrWWVhcicsIDEpO1xuICAgIGFkZFVuaXRQcmlvcml0eSgnaXNvV2Vla1llYXInLCAxKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0cnLCBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignZycsIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdHRycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdnZycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHJywgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnZ2cnLCBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignR0dHR0cnLCBtYXRjaDF0bzYsIG1hdGNoNik7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZ2cnLCBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihcbiAgICAgICAgWydnZ2dnJywgJ2dnZ2dnJywgJ0dHR0cnLCAnR0dHR0cnXSxcbiAgICAgICAgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgICAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAyKV0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZycsICdHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrWWVhcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIHRoaXMud2VlaygpLFxuICAgICAgICAgICAgdGhpcy53ZWVrZGF5KCksXG4gICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3csXG4gICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3lcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09XZWVrWWVhcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIHRoaXMuaXNvV2VlaygpLFxuICAgICAgICAgICAgdGhpcy5pc29XZWVrZGF5KCksXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgNFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldElTT1dlZWtzSW5ZZWFyKCkge1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIDEsIDQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldElTT1dlZWtzSW5JU09XZWVrWWVhcigpIHtcbiAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMuaXNvV2Vla1llYXIoKSwgMSwgNCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2Vla3NJblllYXIoKSB7XG4gICAgICAgIHZhciB3ZWVrSW5mbyA9IHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrO1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIHdlZWtJbmZvLmRvdywgd2Vla0luZm8uZG95KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXZWVrc0luV2Vla1llYXIoKSB7XG4gICAgICAgIHZhciB3ZWVrSW5mbyA9IHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrO1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy53ZWVrWWVhcigpLCB3ZWVrSW5mby5kb3csIHdlZWtJbmZvLmRveSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXJIZWxwZXIoaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrc1RhcmdldDtcbiAgICAgICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKHRoaXMsIGRvdywgZG95KS55ZWFyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2Vla3NUYXJnZXQgPSB3ZWVrc0luWWVhcihpbnB1dCwgZG93LCBkb3kpO1xuICAgICAgICAgICAgaWYgKHdlZWsgPiB3ZWVrc1RhcmdldCkge1xuICAgICAgICAgICAgICAgIHdlZWsgPSB3ZWVrc1RhcmdldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZXRXZWVrQWxsLmNhbGwodGhpcywgaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFdlZWtBbGwod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciBkYXlPZlllYXJEYXRhID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSksXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZShkYXlPZlllYXJEYXRhLnllYXIsIDAsIGRheU9mWWVhckRhdGEuZGF5T2ZZZWFyKTtcblxuICAgICAgICB0aGlzLnllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpKTtcbiAgICAgICAgdGhpcy5tb250aChkYXRlLmdldFVUQ01vbnRoKCkpO1xuICAgICAgICB0aGlzLmRhdGUoZGF0ZS5nZXRVVENEYXRlKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignUScsIDAsICdRbycsICdxdWFydGVyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3F1YXJ0ZXInLCAnUScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgncXVhcnRlcicsIDcpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignUScsIG1hdGNoMSk7XG4gICAgYWRkUGFyc2VUb2tlbignUScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTU9OVEhdID0gKHRvSW50KGlucHV0KSAtIDEpICogMztcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFF1YXJ0ZXIoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGxcbiAgICAgICAgICAgID8gTWF0aC5jZWlsKCh0aGlzLm1vbnRoKCkgKyAxKSAvIDMpXG4gICAgICAgICAgICA6IHRoaXMubW9udGgoKGlucHV0IC0gMSkgKiAzICsgKHRoaXMubW9udGgoKSAlIDMpKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignRCcsIFsnREQnLCAyXSwgJ0RvJywgJ2RhdGUnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF0ZScsICdEJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF0ZScsIDkpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignRCcsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignREQnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignRG8nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgICAgIHJldHVybiBpc1N0cmljdFxuICAgICAgICAgICAgPyBsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2UgfHwgbG9jYWxlLl9vcmRpbmFsUGFyc2VcbiAgICAgICAgICAgIDogbG9jYWxlLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudDtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydEJywgJ0REJ10sIERBVEUpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtEQVRFXSA9IHRvSW50KGlucHV0Lm1hdGNoKG1hdGNoMXRvMilbMF0pO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldERheU9mTW9udGggPSBtYWtlR2V0U2V0KCdEYXRlJywgdHJ1ZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignREREJywgWydEREREJywgM10sICdERERvJywgJ2RheU9mWWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXlPZlllYXInLCAnREREJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF5T2ZZZWFyJywgNCk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdEREQnLCBtYXRjaDF0bzMpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0REREQnLCBtYXRjaDMpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydEREQnLCAnRERERCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZlllYXIoaW5wdXQpIHtcbiAgICAgICAgdmFyIGRheU9mWWVhciA9XG4gICAgICAgICAgICBNYXRoLnJvdW5kKFxuICAgICAgICAgICAgICAgICh0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykgLSB0aGlzLmNsb25lKCkuc3RhcnRPZigneWVhcicpKSAvIDg2NGU1XG4gICAgICAgICAgICApICsgMTtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBkYXlPZlllYXIgOiB0aGlzLmFkZChpbnB1dCAtIGRheU9mWWVhciwgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignbScsIFsnbW0nLCAyXSwgMCwgJ21pbnV0ZScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaW51dGUnLCAnbScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbWludXRlJywgMTQpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignbScsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignbW0nLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ20nLCAnbW0nXSwgTUlOVVRFKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRNaW51dGUgPSBtYWtlR2V0U2V0KCdNaW51dGVzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3MnLCBbJ3NzJywgMl0sIDAsICdzZWNvbmQnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnc2Vjb25kJywgJ3MnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3NlY29uZCcsIDE1KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3MnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3NzJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydzJywgJ3NzJ10sIFNFQ09ORCk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0U2Vjb25kID0gbWFrZUdldFNldCgnU2Vjb25kcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdTJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTAwKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1MnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1MnLCAzXSwgMCwgJ21pbGxpc2Vjb25kJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTJywgNF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1MnLCA1XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTJywgNl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTJywgN10sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1MnLCA4XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1NTJywgOV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDA7XG4gICAgfSk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21pbGxpc2Vjb25kJywgJ21zJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdtaWxsaXNlY29uZCcsIDE2KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1MnLCBtYXRjaDF0bzMsIG1hdGNoMSk7XG4gICAgYWRkUmVnZXhUb2tlbignU1MnLCBtYXRjaDF0bzMsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignU1NTJywgbWF0Y2gxdG8zLCBtYXRjaDMpO1xuXG4gICAgdmFyIHRva2VuLCBnZXRTZXRNaWxsaXNlY29uZDtcbiAgICBmb3IgKHRva2VuID0gJ1NTU1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgICAgIGFkZFJlZ2V4VG9rZW4odG9rZW4sIG1hdGNoVW5zaWduZWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTXMoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01JTExJU0VDT05EXSA9IHRvSW50KCgnMC4nICsgaW5wdXQpICogMTAwMCk7XG4gICAgfVxuXG4gICAgZm9yICh0b2tlbiA9ICdTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBwYXJzZU1zKTtcbiAgICB9XG5cbiAgICBnZXRTZXRNaWxsaXNlY29uZCA9IG1ha2VHZXRTZXQoJ01pbGxpc2Vjb25kcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCd6JywgMCwgMCwgJ3pvbmVBYmJyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3p6JywgMCwgMCwgJ3pvbmVOYW1lJyk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRab25lQWJicigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ1VUQycgOiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRab25lTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ0Nvb3JkaW5hdGVkIFVuaXZlcnNhbCBUaW1lJyA6ICcnO1xuICAgIH1cblxuICAgIHZhciBwcm90byA9IE1vbWVudC5wcm90b3R5cGU7XG5cbiAgICBwcm90by5hZGQgPSBhZGQ7XG4gICAgcHJvdG8uY2FsZW5kYXIgPSBjYWxlbmRhciQxO1xuICAgIHByb3RvLmNsb25lID0gY2xvbmU7XG4gICAgcHJvdG8uZGlmZiA9IGRpZmY7XG4gICAgcHJvdG8uZW5kT2YgPSBlbmRPZjtcbiAgICBwcm90by5mb3JtYXQgPSBmb3JtYXQ7XG4gICAgcHJvdG8uZnJvbSA9IGZyb207XG4gICAgcHJvdG8uZnJvbU5vdyA9IGZyb21Ob3c7XG4gICAgcHJvdG8udG8gPSB0bztcbiAgICBwcm90by50b05vdyA9IHRvTm93O1xuICAgIHByb3RvLmdldCA9IHN0cmluZ0dldDtcbiAgICBwcm90by5pbnZhbGlkQXQgPSBpbnZhbGlkQXQ7XG4gICAgcHJvdG8uaXNBZnRlciA9IGlzQWZ0ZXI7XG4gICAgcHJvdG8uaXNCZWZvcmUgPSBpc0JlZm9yZTtcbiAgICBwcm90by5pc0JldHdlZW4gPSBpc0JldHdlZW47XG4gICAgcHJvdG8uaXNTYW1lID0gaXNTYW1lO1xuICAgIHByb3RvLmlzU2FtZU9yQWZ0ZXIgPSBpc1NhbWVPckFmdGVyO1xuICAgIHByb3RvLmlzU2FtZU9yQmVmb3JlID0gaXNTYW1lT3JCZWZvcmU7XG4gICAgcHJvdG8uaXNWYWxpZCA9IGlzVmFsaWQkMjtcbiAgICBwcm90by5sYW5nID0gbGFuZztcbiAgICBwcm90by5sb2NhbGUgPSBsb2NhbGU7XG4gICAgcHJvdG8ubG9jYWxlRGF0YSA9IGxvY2FsZURhdGE7XG4gICAgcHJvdG8ubWF4ID0gcHJvdG90eXBlTWF4O1xuICAgIHByb3RvLm1pbiA9IHByb3RvdHlwZU1pbjtcbiAgICBwcm90by5wYXJzaW5nRmxhZ3MgPSBwYXJzaW5nRmxhZ3M7XG4gICAgcHJvdG8uc2V0ID0gc3RyaW5nU2V0O1xuICAgIHByb3RvLnN0YXJ0T2YgPSBzdGFydE9mO1xuICAgIHByb3RvLnN1YnRyYWN0ID0gc3VidHJhY3Q7XG4gICAgcHJvdG8udG9BcnJheSA9IHRvQXJyYXk7XG4gICAgcHJvdG8udG9PYmplY3QgPSB0b09iamVjdDtcbiAgICBwcm90by50b0RhdGUgPSB0b0RhdGU7XG4gICAgcHJvdG8udG9JU09TdHJpbmcgPSB0b0lTT1N0cmluZztcbiAgICBwcm90by5pbnNwZWN0ID0gaW5zcGVjdDtcbiAgICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLmZvciAhPSBudWxsKSB7XG4gICAgICAgIHByb3RvW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdNb21lbnQ8JyArIHRoaXMuZm9ybWF0KCkgKyAnPic7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHByb3RvLnRvSlNPTiA9IHRvSlNPTjtcbiAgICBwcm90by50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgIHByb3RvLnVuaXggPSB1bml4O1xuICAgIHByb3RvLnZhbHVlT2YgPSB2YWx1ZU9mO1xuICAgIHByb3RvLmNyZWF0aW9uRGF0YSA9IGNyZWF0aW9uRGF0YTtcbiAgICBwcm90by5lcmFOYW1lID0gZ2V0RXJhTmFtZTtcbiAgICBwcm90by5lcmFOYXJyb3cgPSBnZXRFcmFOYXJyb3c7XG4gICAgcHJvdG8uZXJhQWJiciA9IGdldEVyYUFiYnI7XG4gICAgcHJvdG8uZXJhWWVhciA9IGdldEVyYVllYXI7XG4gICAgcHJvdG8ueWVhciA9IGdldFNldFllYXI7XG4gICAgcHJvdG8uaXNMZWFwWWVhciA9IGdldElzTGVhcFllYXI7XG4gICAgcHJvdG8ud2Vla1llYXIgPSBnZXRTZXRXZWVrWWVhcjtcbiAgICBwcm90by5pc29XZWVrWWVhciA9IGdldFNldElTT1dlZWtZZWFyO1xuICAgIHByb3RvLnF1YXJ0ZXIgPSBwcm90by5xdWFydGVycyA9IGdldFNldFF1YXJ0ZXI7XG4gICAgcHJvdG8ubW9udGggPSBnZXRTZXRNb250aDtcbiAgICBwcm90by5kYXlzSW5Nb250aCA9IGdldERheXNJbk1vbnRoO1xuICAgIHByb3RvLndlZWsgPSBwcm90by53ZWVrcyA9IGdldFNldFdlZWs7XG4gICAgcHJvdG8uaXNvV2VlayA9IHByb3RvLmlzb1dlZWtzID0gZ2V0U2V0SVNPV2VlaztcbiAgICBwcm90by53ZWVrc0luWWVhciA9IGdldFdlZWtzSW5ZZWFyO1xuICAgIHByb3RvLndlZWtzSW5XZWVrWWVhciA9IGdldFdlZWtzSW5XZWVrWWVhcjtcbiAgICBwcm90by5pc29XZWVrc0luWWVhciA9IGdldElTT1dlZWtzSW5ZZWFyO1xuICAgIHByb3RvLmlzb1dlZWtzSW5JU09XZWVrWWVhciA9IGdldElTT1dlZWtzSW5JU09XZWVrWWVhcjtcbiAgICBwcm90by5kYXRlID0gZ2V0U2V0RGF5T2ZNb250aDtcbiAgICBwcm90by5kYXkgPSBwcm90by5kYXlzID0gZ2V0U2V0RGF5T2ZXZWVrO1xuICAgIHByb3RvLndlZWtkYXkgPSBnZXRTZXRMb2NhbGVEYXlPZldlZWs7XG4gICAgcHJvdG8uaXNvV2Vla2RheSA9IGdldFNldElTT0RheU9mV2VlaztcbiAgICBwcm90by5kYXlPZlllYXIgPSBnZXRTZXREYXlPZlllYXI7XG4gICAgcHJvdG8uaG91ciA9IHByb3RvLmhvdXJzID0gZ2V0U2V0SG91cjtcbiAgICBwcm90by5taW51dGUgPSBwcm90by5taW51dGVzID0gZ2V0U2V0TWludXRlO1xuICAgIHByb3RvLnNlY29uZCA9IHByb3RvLnNlY29uZHMgPSBnZXRTZXRTZWNvbmQ7XG4gICAgcHJvdG8ubWlsbGlzZWNvbmQgPSBwcm90by5taWxsaXNlY29uZHMgPSBnZXRTZXRNaWxsaXNlY29uZDtcbiAgICBwcm90by51dGNPZmZzZXQgPSBnZXRTZXRPZmZzZXQ7XG4gICAgcHJvdG8udXRjID0gc2V0T2Zmc2V0VG9VVEM7XG4gICAgcHJvdG8ubG9jYWwgPSBzZXRPZmZzZXRUb0xvY2FsO1xuICAgIHByb3RvLnBhcnNlWm9uZSA9IHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0O1xuICAgIHByb3RvLmhhc0FsaWduZWRIb3VyT2Zmc2V0ID0gaGFzQWxpZ25lZEhvdXJPZmZzZXQ7XG4gICAgcHJvdG8uaXNEU1QgPSBpc0RheWxpZ2h0U2F2aW5nVGltZTtcbiAgICBwcm90by5pc0xvY2FsID0gaXNMb2NhbDtcbiAgICBwcm90by5pc1V0Y09mZnNldCA9IGlzVXRjT2Zmc2V0O1xuICAgIHByb3RvLmlzVXRjID0gaXNVdGM7XG4gICAgcHJvdG8uaXNVVEMgPSBpc1V0YztcbiAgICBwcm90by56b25lQWJiciA9IGdldFpvbmVBYmJyO1xuICAgIHByb3RvLnpvbmVOYW1lID0gZ2V0Wm9uZU5hbWU7XG4gICAgcHJvdG8uZGF0ZXMgPSBkZXByZWNhdGUoXG4gICAgICAgICdkYXRlcyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgZGF0ZSBpbnN0ZWFkLicsXG4gICAgICAgIGdldFNldERheU9mTW9udGhcbiAgICApO1xuICAgIHByb3RvLm1vbnRocyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbnRocyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgbW9udGggaW5zdGVhZCcsXG4gICAgICAgIGdldFNldE1vbnRoXG4gICAgKTtcbiAgICBwcm90by55ZWFycyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ3llYXJzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSB5ZWFyIGluc3RlYWQnLFxuICAgICAgICBnZXRTZXRZZWFyXG4gICAgKTtcbiAgICBwcm90by56b25lID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkuem9uZSBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50KCkudXRjT2Zmc2V0IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3Mvem9uZS8nLFxuICAgICAgICBnZXRTZXRab25lXG4gICAgKTtcbiAgICBwcm90by5pc0RTVFNoaWZ0ZWQgPSBkZXByZWNhdGUoXG4gICAgICAgICdpc0RTVFNoaWZ0ZWQgaXMgZGVwcmVjYXRlZC4gU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvZHN0LXNoaWZ0ZWQvIGZvciBtb3JlIGluZm9ybWF0aW9uJyxcbiAgICAgICAgaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkXG4gICAgKTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVuaXgoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0ICogMTAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW5ab25lKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5wYXJzZVpvbmUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVQYXJzZVBvc3RGb3JtYXQoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvJDEgPSBMb2NhbGUucHJvdG90eXBlO1xuXG4gICAgcHJvdG8kMS5jYWxlbmRhciA9IGNhbGVuZGFyO1xuICAgIHByb3RvJDEubG9uZ0RhdGVGb3JtYXQgPSBsb25nRGF0ZUZvcm1hdDtcbiAgICBwcm90byQxLmludmFsaWREYXRlID0gaW52YWxpZERhdGU7XG4gICAgcHJvdG8kMS5vcmRpbmFsID0gb3JkaW5hbDtcbiAgICBwcm90byQxLnByZXBhcnNlID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvJDEucG9zdGZvcm1hdCA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbiAgICBwcm90byQxLnJlbGF0aXZlVGltZSA9IHJlbGF0aXZlVGltZTtcbiAgICBwcm90byQxLnBhc3RGdXR1cmUgPSBwYXN0RnV0dXJlO1xuICAgIHByb3RvJDEuc2V0ID0gc2V0O1xuICAgIHByb3RvJDEuZXJhcyA9IGxvY2FsZUVyYXM7XG4gICAgcHJvdG8kMS5lcmFzUGFyc2UgPSBsb2NhbGVFcmFzUGFyc2U7XG4gICAgcHJvdG8kMS5lcmFzQ29udmVydFllYXIgPSBsb2NhbGVFcmFzQ29udmVydFllYXI7XG4gICAgcHJvdG8kMS5lcmFzQWJiclJlZ2V4ID0gZXJhc0FiYnJSZWdleDtcbiAgICBwcm90byQxLmVyYXNOYW1lUmVnZXggPSBlcmFzTmFtZVJlZ2V4O1xuICAgIHByb3RvJDEuZXJhc05hcnJvd1JlZ2V4ID0gZXJhc05hcnJvd1JlZ2V4O1xuXG4gICAgcHJvdG8kMS5tb250aHMgPSBsb2NhbGVNb250aHM7XG4gICAgcHJvdG8kMS5tb250aHNTaG9ydCA9IGxvY2FsZU1vbnRoc1Nob3J0O1xuICAgIHByb3RvJDEubW9udGhzUGFyc2UgPSBsb2NhbGVNb250aHNQYXJzZTtcbiAgICBwcm90byQxLm1vbnRoc1JlZ2V4ID0gbW9udGhzUmVnZXg7XG4gICAgcHJvdG8kMS5tb250aHNTaG9ydFJlZ2V4ID0gbW9udGhzU2hvcnRSZWdleDtcbiAgICBwcm90byQxLndlZWsgPSBsb2NhbGVXZWVrO1xuICAgIHByb3RvJDEuZmlyc3REYXlPZlllYXIgPSBsb2NhbGVGaXJzdERheU9mWWVhcjtcbiAgICBwcm90byQxLmZpcnN0RGF5T2ZXZWVrID0gbG9jYWxlRmlyc3REYXlPZldlZWs7XG5cbiAgICBwcm90byQxLndlZWtkYXlzID0gbG9jYWxlV2Vla2RheXM7XG4gICAgcHJvdG8kMS53ZWVrZGF5c01pbiA9IGxvY2FsZVdlZWtkYXlzTWluO1xuICAgIHByb3RvJDEud2Vla2RheXNTaG9ydCA9IGxvY2FsZVdlZWtkYXlzU2hvcnQ7XG4gICAgcHJvdG8kMS53ZWVrZGF5c1BhcnNlID0gbG9jYWxlV2Vla2RheXNQYXJzZTtcblxuICAgIHByb3RvJDEud2Vla2RheXNSZWdleCA9IHdlZWtkYXlzUmVnZXg7XG4gICAgcHJvdG8kMS53ZWVrZGF5c1Nob3J0UmVnZXggPSB3ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgcHJvdG8kMS53ZWVrZGF5c01pblJlZ2V4ID0gd2Vla2RheXNNaW5SZWdleDtcblxuICAgIHByb3RvJDEuaXNQTSA9IGxvY2FsZUlzUE07XG4gICAgcHJvdG8kMS5tZXJpZGllbSA9IGxvY2FsZU1lcmlkaWVtO1xuXG4gICAgZnVuY3Rpb24gZ2V0JDEoZm9ybWF0LCBpbmRleCwgZmllbGQsIHNldHRlcikge1xuICAgICAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCksXG4gICAgICAgICAgICB1dGMgPSBjcmVhdGVVVEMoKS5zZXQoc2V0dGVyLCBpbmRleCk7XG4gICAgICAgIHJldHVybiBsb2NhbGVbZmllbGRdKHV0YywgZm9ybWF0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQkMShmb3JtYXQsIGluZGV4LCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIG91dCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgb3V0W2ldID0gZ2V0JDEoZm9ybWF0LCBpLCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICAvLyAoKVxuICAgIC8vICg1KVxuICAgIC8vIChmbXQsIDUpXG4gICAgLy8gKGZtdClcbiAgICAvLyAodHJ1ZSlcbiAgICAvLyAodHJ1ZSwgNSlcbiAgICAvLyAodHJ1ZSwgZm10LCA1KVxuICAgIC8vICh0cnVlLCBmbXQpXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsIGZpZWxkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbG9jYWxlU29ydGVkID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBsb2NhbGVTb3J0ZWQ7XG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgIGxvY2FsZVNvcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvY2FsZSA9IGdldExvY2FsZSgpLFxuICAgICAgICAgICAgc2hpZnQgPSBsb2NhbGVTb3J0ZWQgPyBsb2NhbGUuX3dlZWsuZG93IDogMCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBvdXQgPSBbXTtcblxuICAgICAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldCQxKGZvcm1hdCwgKGluZGV4ICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIG91dFtpXSA9IGdldCQxKGZvcm1hdCwgKGkgKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdE1vbnRocyhmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdE1vbnRoc1Nob3J0KGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHNTaG9ydCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5cyhsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXMnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0V2Vla2RheXNTaG9ydChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNTaG9ydCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c01pbihsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNNaW4nKTtcbiAgICB9XG5cbiAgICBnZXRTZXRHbG9iYWxMb2NhbGUoJ2VuJywge1xuICAgICAgICBlcmFzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2luY2U6ICcwMDAxLTAxLTAxJyxcbiAgICAgICAgICAgICAgICB1bnRpbDogK0luZmluaXR5LFxuICAgICAgICAgICAgICAgIG9mZnNldDogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnQW5ubyBEb21pbmknLFxuICAgICAgICAgICAgICAgIG5hcnJvdzogJ0FEJyxcbiAgICAgICAgICAgICAgICBhYmJyOiAnQUQnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzaW5jZTogJzAwMDAtMTItMzEnLFxuICAgICAgICAgICAgICAgIHVudGlsOiAtSW5maW5pdHksXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdCZWZvcmUgQ2hyaXN0JyxcbiAgICAgICAgICAgICAgICBuYXJyb3c6ICdCQycsXG4gICAgICAgICAgICAgICAgYWJicjogJ0JDJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfSh0aHxzdHxuZHxyZCkvLFxuICAgICAgICBvcmRpbmFsOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwLFxuICAgICAgICAgICAgICAgIG91dHB1dCA9XG4gICAgICAgICAgICAgICAgICAgIHRvSW50KChudW1iZXIgJSAxMDApIC8gMTApID09PSAxXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICd0aCdcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYiA9PT0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAnc3QnXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGIgPT09IDJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJ25kJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBiID09PSAzXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICdyZCdcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJ3RoJztcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cbiAgICBob29rcy5sYW5nID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50LmxhbmcgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGUgaW5zdGVhZC4nLFxuICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGVcbiAgICApO1xuICAgIGhvb2tzLmxhbmdEYXRhID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50LmxhbmdEYXRhIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlRGF0YSBpbnN0ZWFkLicsXG4gICAgICAgIGdldExvY2FsZVxuICAgICk7XG5cbiAgICB2YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gYWJzKCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gbWF0aEFicyh0aGlzLl9taWxsaXNlY29uZHMpO1xuICAgICAgICB0aGlzLl9kYXlzID0gbWF0aEFicyh0aGlzLl9kYXlzKTtcbiAgICAgICAgdGhpcy5fbW9udGhzID0gbWF0aEFicyh0aGlzLl9tb250aHMpO1xuXG4gICAgICAgIGRhdGEubWlsbGlzZWNvbmRzID0gbWF0aEFicyhkYXRhLm1pbGxpc2Vjb25kcyk7XG4gICAgICAgIGRhdGEuc2Vjb25kcyA9IG1hdGhBYnMoZGF0YS5zZWNvbmRzKTtcbiAgICAgICAgZGF0YS5taW51dGVzID0gbWF0aEFicyhkYXRhLm1pbnV0ZXMpO1xuICAgICAgICBkYXRhLmhvdXJzID0gbWF0aEFicyhkYXRhLmhvdXJzKTtcbiAgICAgICAgZGF0YS5tb250aHMgPSBtYXRoQWJzKGRhdGEubW9udGhzKTtcbiAgICAgICAgZGF0YS55ZWFycyA9IG1hdGhBYnMoZGF0YS55ZWFycyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkU3VidHJhY3QkMShkdXJhdGlvbiwgaW5wdXQsIHZhbHVlLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlRHVyYXRpb24oaW5wdXQsIHZhbHVlKTtcblxuICAgICAgICBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9taWxsaXNlY29uZHM7XG4gICAgICAgIGR1cmF0aW9uLl9kYXlzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9kYXlzO1xuICAgICAgICBkdXJhdGlvbi5fbW9udGhzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9tb250aHM7XG5cbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uLl9idWJibGUoKTtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBhZGQoMSwgJ3MnKSBvciBhZGQoZHVyYXRpb24pXG4gICAgZnVuY3Rpb24gYWRkJDEoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhZGRTdWJ0cmFjdCQxKHRoaXMsIGlucHV0LCB2YWx1ZSwgMSk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgc3VidHJhY3QoMSwgJ3MnKSBvciBzdWJ0cmFjdChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBzdWJ0cmFjdCQxKGlucHV0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYWRkU3VidHJhY3QkMSh0aGlzLCBpbnB1dCwgdmFsdWUsIC0xKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNDZWlsKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1YmJsZSgpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzLFxuICAgICAgICAgICAgbW9udGhzID0gdGhpcy5fbW9udGhzLFxuICAgICAgICAgICAgZGF0YSA9IHRoaXMuX2RhdGEsXG4gICAgICAgICAgICBzZWNvbmRzLFxuICAgICAgICAgICAgbWludXRlcyxcbiAgICAgICAgICAgIGhvdXJzLFxuICAgICAgICAgICAgeWVhcnMsXG4gICAgICAgICAgICBtb250aHNGcm9tRGF5cztcblxuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgbWl4IG9mIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB2YWx1ZXMsIGJ1YmJsZSBkb3duIGZpcnN0XG4gICAgICAgIC8vIGNoZWNrOiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjE2NlxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAhKFxuICAgICAgICAgICAgICAgIChtaWxsaXNlY29uZHMgPj0gMCAmJiBkYXlzID49IDAgJiYgbW9udGhzID49IDApIHx8XG4gICAgICAgICAgICAgICAgKG1pbGxpc2Vjb25kcyA8PSAwICYmIGRheXMgPD0gMCAmJiBtb250aHMgPD0gMClcbiAgICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgKz0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzKSArIGRheXMpICogODY0ZTU7XG4gICAgICAgICAgICBkYXlzID0gMDtcbiAgICAgICAgICAgIG1vbnRocyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgYnViYmxlcyB1cCB2YWx1ZXMsIHNlZSB0aGUgdGVzdHMgZm9yXG4gICAgICAgIC8vIGV4YW1wbGVzIG9mIHdoYXQgdGhhdCBtZWFucy5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHMgJSAxMDAwO1xuXG4gICAgICAgIHNlY29uZHMgPSBhYnNGbG9vcihtaWxsaXNlY29uZHMgLyAxMDAwKTtcbiAgICAgICAgZGF0YS5zZWNvbmRzID0gc2Vjb25kcyAlIDYwO1xuXG4gICAgICAgIG1pbnV0ZXMgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgICAgICBkYXRhLm1pbnV0ZXMgPSBtaW51dGVzICUgNjA7XG5cbiAgICAgICAgaG91cnMgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBkYXRhLmhvdXJzID0gaG91cnMgJSAyNDtcblxuICAgICAgICBkYXlzICs9IGFic0Zsb29yKGhvdXJzIC8gMjQpO1xuXG4gICAgICAgIC8vIGNvbnZlcnQgZGF5cyB0byBtb250aHNcbiAgICAgICAgbW9udGhzRnJvbURheXMgPSBhYnNGbG9vcihkYXlzVG9Nb250aHMoZGF5cykpO1xuICAgICAgICBtb250aHMgKz0gbW9udGhzRnJvbURheXM7XG4gICAgICAgIGRheXMgLT0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzRnJvbURheXMpKTtcblxuICAgICAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgICAgIHllYXJzID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgICAgICBtb250aHMgJT0gMTI7XG5cbiAgICAgICAgZGF0YS5kYXlzID0gZGF5cztcbiAgICAgICAgZGF0YS5tb250aHMgPSBtb250aHM7XG4gICAgICAgIGRhdGEueWVhcnMgPSB5ZWFycztcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlzVG9Nb250aHMoZGF5cykge1xuICAgICAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxNDYwOTcgZGF5cyAodGFraW5nIGludG8gYWNjb3VudCBsZWFwIHllYXIgcnVsZXMpXG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDEyIG1vbnRocyA9PT0gNDgwMFxuICAgICAgICByZXR1cm4gKGRheXMgKiA0ODAwKSAvIDE0NjA5NztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aHNUb0RheXMobW9udGhzKSB7XG4gICAgICAgIC8vIHRoZSByZXZlcnNlIG9mIGRheXNUb01vbnRoc1xuICAgICAgICByZXR1cm4gKG1vbnRocyAqIDE0NjA5NykgLyA0ODAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzKHVuaXRzKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRheXMsXG4gICAgICAgICAgICBtb250aHMsXG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XG5cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgaWYgKHVuaXRzID09PSAnbW9udGgnIHx8IHVuaXRzID09PSAncXVhcnRlcicgfHwgdW5pdHMgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgIG1vbnRocyA9IHRoaXMuX21vbnRocyArIGRheXNUb01vbnRocyhkYXlzKTtcbiAgICAgICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb250aHM7XG4gICAgICAgICAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb250aHMgLyAzO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9udGhzIC8gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgbWlsbGlzZWNvbmRzIHNlcGFyYXRlbHkgYmVjYXVzZSBvZiBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyAoaXNzdWUgIzE4NjcpXG4gICAgICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyArIE1hdGgucm91bmQobW9udGhzVG9EYXlzKHRoaXMuX21vbnRocykpO1xuICAgICAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF5cyAvIDcgKyBtaWxsaXNlY29uZHMgLyA2MDQ4ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRheXMgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRheXMgKiAyNCArIG1pbGxpc2Vjb25kcyAvIDM2ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRheXMgKiAxNDQwICsgbWlsbGlzZWNvbmRzIC8gNmU0O1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXlzICogODY0MDAgKyBtaWxsaXNlY29uZHMgLyAxMDAwO1xuICAgICAgICAgICAgICAgIC8vIE1hdGguZmxvb3IgcHJldmVudHMgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgaGVyZVxuICAgICAgICAgICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoZGF5cyAqIDg2NGU1KSArIG1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdW5pdCAnICsgdW5pdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIHRoaXMuYXMoJ21zJyk/XG4gICAgZnVuY3Rpb24gdmFsdWVPZiQxKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgdGhpcy5fZGF5cyAqIDg2NGU1ICtcbiAgICAgICAgICAgICh0aGlzLl9tb250aHMgJSAxMikgKiAyNTkyZTYgK1xuICAgICAgICAgICAgdG9JbnQodGhpcy5fbW9udGhzIC8gMTIpICogMzE1MzZlNlxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VBcyhhbGlhcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXMoYWxpYXMpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBhc01pbGxpc2Vjb25kcyA9IG1ha2VBcygnbXMnKSxcbiAgICAgICAgYXNTZWNvbmRzID0gbWFrZUFzKCdzJyksXG4gICAgICAgIGFzTWludXRlcyA9IG1ha2VBcygnbScpLFxuICAgICAgICBhc0hvdXJzID0gbWFrZUFzKCdoJyksXG4gICAgICAgIGFzRGF5cyA9IG1ha2VBcygnZCcpLFxuICAgICAgICBhc1dlZWtzID0gbWFrZUFzKCd3JyksXG4gICAgICAgIGFzTW9udGhzID0gbWFrZUFzKCdNJyksXG4gICAgICAgIGFzUXVhcnRlcnMgPSBtYWtlQXMoJ1EnKSxcbiAgICAgICAgYXNZZWFycyA9IG1ha2VBcygneScpO1xuXG4gICAgZnVuY3Rpb24gY2xvbmUkMSgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldCQyKHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzW3VuaXRzICsgJ3MnXSgpIDogTmFOO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VHZXR0ZXIobmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5fZGF0YVtuYW1lXSA6IE5hTjtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgbWlsbGlzZWNvbmRzID0gbWFrZUdldHRlcignbWlsbGlzZWNvbmRzJyksXG4gICAgICAgIHNlY29uZHMgPSBtYWtlR2V0dGVyKCdzZWNvbmRzJyksXG4gICAgICAgIG1pbnV0ZXMgPSBtYWtlR2V0dGVyKCdtaW51dGVzJyksXG4gICAgICAgIGhvdXJzID0gbWFrZUdldHRlcignaG91cnMnKSxcbiAgICAgICAgZGF5cyA9IG1ha2VHZXR0ZXIoJ2RheXMnKSxcbiAgICAgICAgbW9udGhzID0gbWFrZUdldHRlcignbW9udGhzJyksXG4gICAgICAgIHllYXJzID0gbWFrZUdldHRlcigneWVhcnMnKTtcblxuICAgIGZ1bmN0aW9uIHdlZWtzKCkge1xuICAgICAgICByZXR1cm4gYWJzRmxvb3IodGhpcy5kYXlzKCkgLyA3KTtcbiAgICB9XG5cbiAgICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kLFxuICAgICAgICB0aHJlc2hvbGRzID0ge1xuICAgICAgICAgICAgc3M6IDQ0LCAvLyBhIGZldyBzZWNvbmRzIHRvIHNlY29uZHNcbiAgICAgICAgICAgIHM6IDQ1LCAvLyBzZWNvbmRzIHRvIG1pbnV0ZVxuICAgICAgICAgICAgbTogNDUsIC8vIG1pbnV0ZXMgdG8gaG91clxuICAgICAgICAgICAgaDogMjIsIC8vIGhvdXJzIHRvIGRheVxuICAgICAgICAgICAgZDogMjYsIC8vIGRheXMgdG8gbW9udGgvd2Vla1xuICAgICAgICAgICAgdzogbnVsbCwgLy8gd2Vla3MgdG8gbW9udGhcbiAgICAgICAgICAgIE06IDExLCAvLyBtb250aHMgdG8geWVhclxuICAgICAgICB9O1xuXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uIGZvciBtb21lbnQuZm4uZnJvbSwgbW9tZW50LmZuLmZyb21Ob3csIGFuZCBtb21lbnQuZHVyYXRpb24uZm4uaHVtYW5pemVcbiAgICBmdW5jdGlvbiBzdWJzdGl0dXRlVGltZUFnbyhzdHJpbmcsIG51bWJlciwgd2l0aG91dFN1ZmZpeCwgaXNGdXR1cmUsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLnJlbGF0aXZlVGltZShudW1iZXIgfHwgMSwgISF3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWxhdGl2ZVRpbWUkMShwb3NOZWdEdXJhdGlvbiwgd2l0aG91dFN1ZmZpeCwgdGhyZXNob2xkcywgbG9jYWxlKSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGNyZWF0ZUR1cmF0aW9uKHBvc05lZ0R1cmF0aW9uKS5hYnMoKSxcbiAgICAgICAgICAgIHNlY29uZHMgPSByb3VuZChkdXJhdGlvbi5hcygncycpKSxcbiAgICAgICAgICAgIG1pbnV0ZXMgPSByb3VuZChkdXJhdGlvbi5hcygnbScpKSxcbiAgICAgICAgICAgIGhvdXJzID0gcm91bmQoZHVyYXRpb24uYXMoJ2gnKSksXG4gICAgICAgICAgICBkYXlzID0gcm91bmQoZHVyYXRpb24uYXMoJ2QnKSksXG4gICAgICAgICAgICBtb250aHMgPSByb3VuZChkdXJhdGlvbi5hcygnTScpKSxcbiAgICAgICAgICAgIHdlZWtzID0gcm91bmQoZHVyYXRpb24uYXMoJ3cnKSksXG4gICAgICAgICAgICB5ZWFycyA9IHJvdW5kKGR1cmF0aW9uLmFzKCd5JykpLFxuICAgICAgICAgICAgYSA9XG4gICAgICAgICAgICAgICAgKHNlY29uZHMgPD0gdGhyZXNob2xkcy5zcyAmJiBbJ3MnLCBzZWNvbmRzXSkgfHxcbiAgICAgICAgICAgICAgICAoc2Vjb25kcyA8IHRocmVzaG9sZHMucyAmJiBbJ3NzJywgc2Vjb25kc10pIHx8XG4gICAgICAgICAgICAgICAgKG1pbnV0ZXMgPD0gMSAmJiBbJ20nXSkgfHxcbiAgICAgICAgICAgICAgICAobWludXRlcyA8IHRocmVzaG9sZHMubSAmJiBbJ21tJywgbWludXRlc10pIHx8XG4gICAgICAgICAgICAgICAgKGhvdXJzIDw9IDEgJiYgWydoJ10pIHx8XG4gICAgICAgICAgICAgICAgKGhvdXJzIDwgdGhyZXNob2xkcy5oICYmIFsnaGgnLCBob3Vyc10pIHx8XG4gICAgICAgICAgICAgICAgKGRheXMgPD0gMSAmJiBbJ2QnXSkgfHxcbiAgICAgICAgICAgICAgICAoZGF5cyA8IHRocmVzaG9sZHMuZCAmJiBbJ2RkJywgZGF5c10pO1xuXG4gICAgICAgIGlmICh0aHJlc2hvbGRzLncgIT0gbnVsbCkge1xuICAgICAgICAgICAgYSA9XG4gICAgICAgICAgICAgICAgYSB8fFxuICAgICAgICAgICAgICAgICh3ZWVrcyA8PSAxICYmIFsndyddKSB8fFxuICAgICAgICAgICAgICAgICh3ZWVrcyA8IHRocmVzaG9sZHMudyAmJiBbJ3d3Jywgd2Vla3NdKTtcbiAgICAgICAgfVxuICAgICAgICBhID0gYSB8fFxuICAgICAgICAgICAgKG1vbnRocyA8PSAxICYmIFsnTSddKSB8fFxuICAgICAgICAgICAgKG1vbnRocyA8IHRocmVzaG9sZHMuTSAmJiBbJ01NJywgbW9udGhzXSkgfHxcbiAgICAgICAgICAgICh5ZWFycyA8PSAxICYmIFsneSddKSB8fCBbJ3l5JywgeWVhcnNdO1xuXG4gICAgICAgIGFbMl0gPSB3aXRob3V0U3VmZml4O1xuICAgICAgICBhWzNdID0gK3Bvc05lZ0R1cmF0aW9uID4gMDtcbiAgICAgICAgYVs0XSA9IGxvY2FsZTtcbiAgICAgICAgcmV0dXJuIHN1YnN0aXR1dGVUaW1lQWdvLmFwcGx5KG51bGwsIGEpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgdGhlIHJvdW5kaW5nIGZ1bmN0aW9uIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbiAgICBmdW5jdGlvbiBnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZyhyb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgIGlmIChyb3VuZGluZ0Z1bmN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByb3VuZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJvdW5kaW5nRnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJvdW5kID0gcm91bmRpbmdGdW5jdGlvbjtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IGEgdGhyZXNob2xkIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbiAgICBmdW5jdGlvbiBnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQodGhyZXNob2xkLCBsaW1pdCkge1xuICAgICAgICBpZiAodGhyZXNob2xkc1t0aHJlc2hvbGRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRocmVzaG9sZHNbdGhyZXNob2xkXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJlc2hvbGRzW3RocmVzaG9sZF0gPSBsaW1pdDtcbiAgICAgICAgaWYgKHRocmVzaG9sZCA9PT0gJ3MnKSB7XG4gICAgICAgICAgICB0aHJlc2hvbGRzLnNzID0gbGltaXQgLSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGh1bWFuaXplKGFyZ1dpdGhTdWZmaXgsIGFyZ1RocmVzaG9sZHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgd2l0aFN1ZmZpeCA9IGZhbHNlLFxuICAgICAgICAgICAgdGggPSB0aHJlc2hvbGRzLFxuICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgb3V0cHV0O1xuXG4gICAgICAgIGlmICh0eXBlb2YgYXJnV2l0aFN1ZmZpeCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGFyZ1RocmVzaG9sZHMgPSBhcmdXaXRoU3VmZml4O1xuICAgICAgICAgICAgYXJnV2l0aFN1ZmZpeCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYXJnV2l0aFN1ZmZpeCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB3aXRoU3VmZml4ID0gYXJnV2l0aFN1ZmZpeDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGFyZ1RocmVzaG9sZHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aCA9IE9iamVjdC5hc3NpZ24oe30sIHRocmVzaG9sZHMsIGFyZ1RocmVzaG9sZHMpO1xuICAgICAgICAgICAgaWYgKGFyZ1RocmVzaG9sZHMucyAhPSBudWxsICYmIGFyZ1RocmVzaG9sZHMuc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoLnNzID0gYXJnVGhyZXNob2xkcy5zIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxvY2FsZSA9IHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICBvdXRwdXQgPSByZWxhdGl2ZVRpbWUkMSh0aGlzLCAhd2l0aFN1ZmZpeCwgdGgsIGxvY2FsZSk7XG5cbiAgICAgICAgaWYgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IGxvY2FsZS5wYXN0RnV0dXJlKCt0aGlzLCBvdXRwdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxvY2FsZS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgdmFyIGFicyQxID0gTWF0aC5hYnM7XG5cbiAgICBmdW5jdGlvbiBzaWduKHgpIHtcbiAgICAgICAgcmV0dXJuICh4ID4gMCkgLSAoeCA8IDApIHx8ICt4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSVNPU3RyaW5nJDEoKSB7XG4gICAgICAgIC8vIGZvciBJU08gc3RyaW5ncyB3ZSBkbyBub3QgdXNlIHRoZSBub3JtYWwgYnViYmxpbmcgcnVsZXM6XG4gICAgICAgIC8vICAqIG1pbGxpc2Vjb25kcyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgaG91cnNcbiAgICAgICAgLy8gICogZGF5cyBkbyBub3QgYnViYmxlIGF0IGFsbFxuICAgICAgICAvLyAgKiBtb250aHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIHllYXJzXG4gICAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSB0aGVyZSBpcyBubyBjb250ZXh0LWZyZWUgY29udmVyc2lvbiBiZXR3ZWVuIGhvdXJzIGFuZCBkYXlzXG4gICAgICAgIC8vICh0aGluayBvZiBjbG9jayBjaGFuZ2VzKVxuICAgICAgICAvLyBhbmQgYWxzbyBub3QgYmV0d2VlbiBkYXlzIGFuZCBtb250aHMgKDI4LTMxIGRheXMgcGVyIG1vbnRoKVxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWNvbmRzID0gYWJzJDEodGhpcy5fbWlsbGlzZWNvbmRzKSAvIDEwMDAsXG4gICAgICAgICAgICBkYXlzID0gYWJzJDEodGhpcy5fZGF5cyksXG4gICAgICAgICAgICBtb250aHMgPSBhYnMkMSh0aGlzLl9tb250aHMpLFxuICAgICAgICAgICAgbWludXRlcyxcbiAgICAgICAgICAgIGhvdXJzLFxuICAgICAgICAgICAgeWVhcnMsXG4gICAgICAgICAgICBzLFxuICAgICAgICAgICAgdG90YWwgPSB0aGlzLmFzU2Vjb25kcygpLFxuICAgICAgICAgICAgdG90YWxTaWduLFxuICAgICAgICAgICAgeW1TaWduLFxuICAgICAgICAgICAgZGF5c1NpZ24sXG4gICAgICAgICAgICBobXNTaWduO1xuXG4gICAgICAgIGlmICghdG90YWwpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIHNhbWUgYXMgQyMncyAoTm9kYSkgYW5kIHB5dGhvbiAoaXNvZGF0ZSkuLi5cbiAgICAgICAgICAgIC8vIGJ1dCBub3Qgb3RoZXIgSlMgKGdvb2cuZGF0ZSlcbiAgICAgICAgICAgIHJldHVybiAnUDBEJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDM2MDAgc2Vjb25kcyAtPiA2MCBtaW51dGVzIC0+IDEgaG91clxuICAgICAgICBtaW51dGVzID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgaG91cnMgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBzZWNvbmRzICU9IDYwO1xuICAgICAgICBtaW51dGVzICU9IDYwO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIG1vbnRocyAlPSAxMjtcblxuICAgICAgICAvLyBpbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vZG9yZGlsbGUvbW9tZW50LWlzb2R1cmF0aW9uL2Jsb2IvbWFzdGVyL21vbWVudC5pc29kdXJhdGlvbi5qc1xuICAgICAgICBzID0gc2Vjb25kcyA/IHNlY29uZHMudG9GaXhlZCgzKS5yZXBsYWNlKC9cXC4/MCskLywgJycpIDogJyc7XG5cbiAgICAgICAgdG90YWxTaWduID0gdG90YWwgPCAwID8gJy0nIDogJyc7XG4gICAgICAgIHltU2lnbiA9IHNpZ24odGhpcy5fbW9udGhzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcbiAgICAgICAgZGF5c1NpZ24gPSBzaWduKHRoaXMuX2RheXMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuICAgICAgICBobXNTaWduID0gc2lnbih0aGlzLl9taWxsaXNlY29uZHMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0b3RhbFNpZ24gK1xuICAgICAgICAgICAgJ1AnICtcbiAgICAgICAgICAgICh5ZWFycyA/IHltU2lnbiArIHllYXJzICsgJ1knIDogJycpICtcbiAgICAgICAgICAgIChtb250aHMgPyB5bVNpZ24gKyBtb250aHMgKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgKGRheXMgPyBkYXlzU2lnbiArIGRheXMgKyAnRCcgOiAnJykgK1xuICAgICAgICAgICAgKGhvdXJzIHx8IG1pbnV0ZXMgfHwgc2Vjb25kcyA/ICdUJyA6ICcnKSArXG4gICAgICAgICAgICAoaG91cnMgPyBobXNTaWduICsgaG91cnMgKyAnSCcgOiAnJykgK1xuICAgICAgICAgICAgKG1pbnV0ZXMgPyBobXNTaWduICsgbWludXRlcyArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAoc2Vjb25kcyA/IGhtc1NpZ24gKyBzICsgJ1MnIDogJycpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvJDIgPSBEdXJhdGlvbi5wcm90b3R5cGU7XG5cbiAgICBwcm90byQyLmlzVmFsaWQgPSBpc1ZhbGlkJDE7XG4gICAgcHJvdG8kMi5hYnMgPSBhYnM7XG4gICAgcHJvdG8kMi5hZGQgPSBhZGQkMTtcbiAgICBwcm90byQyLnN1YnRyYWN0ID0gc3VidHJhY3QkMTtcbiAgICBwcm90byQyLmFzID0gYXM7XG4gICAgcHJvdG8kMi5hc01pbGxpc2Vjb25kcyA9IGFzTWlsbGlzZWNvbmRzO1xuICAgIHByb3RvJDIuYXNTZWNvbmRzID0gYXNTZWNvbmRzO1xuICAgIHByb3RvJDIuYXNNaW51dGVzID0gYXNNaW51dGVzO1xuICAgIHByb3RvJDIuYXNIb3VycyA9IGFzSG91cnM7XG4gICAgcHJvdG8kMi5hc0RheXMgPSBhc0RheXM7XG4gICAgcHJvdG8kMi5hc1dlZWtzID0gYXNXZWVrcztcbiAgICBwcm90byQyLmFzTW9udGhzID0gYXNNb250aHM7XG4gICAgcHJvdG8kMi5hc1F1YXJ0ZXJzID0gYXNRdWFydGVycztcbiAgICBwcm90byQyLmFzWWVhcnMgPSBhc1llYXJzO1xuICAgIHByb3RvJDIudmFsdWVPZiA9IHZhbHVlT2YkMTtcbiAgICBwcm90byQyLl9idWJibGUgPSBidWJibGU7XG4gICAgcHJvdG8kMi5jbG9uZSA9IGNsb25lJDE7XG4gICAgcHJvdG8kMi5nZXQgPSBnZXQkMjtcbiAgICBwcm90byQyLm1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kcztcbiAgICBwcm90byQyLnNlY29uZHMgPSBzZWNvbmRzO1xuICAgIHByb3RvJDIubWludXRlcyA9IG1pbnV0ZXM7XG4gICAgcHJvdG8kMi5ob3VycyA9IGhvdXJzO1xuICAgIHByb3RvJDIuZGF5cyA9IGRheXM7XG4gICAgcHJvdG8kMi53ZWVrcyA9IHdlZWtzO1xuICAgIHByb3RvJDIubW9udGhzID0gbW9udGhzO1xuICAgIHByb3RvJDIueWVhcnMgPSB5ZWFycztcbiAgICBwcm90byQyLmh1bWFuaXplID0gaHVtYW5pemU7XG4gICAgcHJvdG8kMi50b0lTT1N0cmluZyA9IHRvSVNPU3RyaW5nJDE7XG4gICAgcHJvdG8kMi50b1N0cmluZyA9IHRvSVNPU3RyaW5nJDE7XG4gICAgcHJvdG8kMi50b0pTT04gPSB0b0lTT1N0cmluZyQxO1xuICAgIHByb3RvJDIubG9jYWxlID0gbG9jYWxlO1xuICAgIHByb3RvJDIubG9jYWxlRGF0YSA9IGxvY2FsZURhdGE7XG5cbiAgICBwcm90byQyLnRvSXNvU3RyaW5nID0gZGVwcmVjYXRlKFxuICAgICAgICAndG9Jc29TdHJpbmcoKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRvSVNPU3RyaW5nKCkgaW5zdGVhZCAobm90aWNlIHRoZSBjYXBpdGFscyknLFxuICAgICAgICB0b0lTT1N0cmluZyQxXG4gICAgKTtcbiAgICBwcm90byQyLmxhbmcgPSBsYW5nO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1gnLCAwLCAwLCAndW5peCcpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd4JywgMCwgMCwgJ3ZhbHVlT2YnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3gnLCBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWCcsIG1hdGNoVGltZXN0YW1wKTtcbiAgICBhZGRQYXJzZVRva2VuKCdYJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHBhcnNlRmxvYXQoaW5wdXQpICogMTAwMCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbigneCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSh0b0ludChpbnB1dCkpO1xuICAgIH0pO1xuXG4gICAgLy8hIG1vbWVudC5qc1xuXG4gICAgaG9va3MudmVyc2lvbiA9ICcyLjI5LjQnO1xuXG4gICAgc2V0SG9va0NhbGxiYWNrKGNyZWF0ZUxvY2FsKTtcblxuICAgIGhvb2tzLmZuID0gcHJvdG87XG4gICAgaG9va3MubWluID0gbWluO1xuICAgIGhvb2tzLm1heCA9IG1heDtcbiAgICBob29rcy5ub3cgPSBub3c7XG4gICAgaG9va3MudXRjID0gY3JlYXRlVVRDO1xuICAgIGhvb2tzLnVuaXggPSBjcmVhdGVVbml4O1xuICAgIGhvb2tzLm1vbnRocyA9IGxpc3RNb250aHM7XG4gICAgaG9va3MuaXNEYXRlID0gaXNEYXRlO1xuICAgIGhvb2tzLmxvY2FsZSA9IGdldFNldEdsb2JhbExvY2FsZTtcbiAgICBob29rcy5pbnZhbGlkID0gY3JlYXRlSW52YWxpZDtcbiAgICBob29rcy5kdXJhdGlvbiA9IGNyZWF0ZUR1cmF0aW9uO1xuICAgIGhvb2tzLmlzTW9tZW50ID0gaXNNb21lbnQ7XG4gICAgaG9va3Mud2Vla2RheXMgPSBsaXN0V2Vla2RheXM7XG4gICAgaG9va3MucGFyc2Vab25lID0gY3JlYXRlSW5ab25lO1xuICAgIGhvb2tzLmxvY2FsZURhdGEgPSBnZXRMb2NhbGU7XG4gICAgaG9va3MuaXNEdXJhdGlvbiA9IGlzRHVyYXRpb247XG4gICAgaG9va3MubW9udGhzU2hvcnQgPSBsaXN0TW9udGhzU2hvcnQ7XG4gICAgaG9va3Mud2Vla2RheXNNaW4gPSBsaXN0V2Vla2RheXNNaW47XG4gICAgaG9va3MuZGVmaW5lTG9jYWxlID0gZGVmaW5lTG9jYWxlO1xuICAgIGhvb2tzLnVwZGF0ZUxvY2FsZSA9IHVwZGF0ZUxvY2FsZTtcbiAgICBob29rcy5sb2NhbGVzID0gbGlzdExvY2FsZXM7XG4gICAgaG9va3Mud2Vla2RheXNTaG9ydCA9IGxpc3RXZWVrZGF5c1Nob3J0O1xuICAgIGhvb2tzLm5vcm1hbGl6ZVVuaXRzID0gbm9ybWFsaXplVW5pdHM7XG4gICAgaG9va3MucmVsYXRpdmVUaW1lUm91bmRpbmcgPSBnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZztcbiAgICBob29rcy5yZWxhdGl2ZVRpbWVUaHJlc2hvbGQgPSBnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQ7XG4gICAgaG9va3MuY2FsZW5kYXJGb3JtYXQgPSBnZXRDYWxlbmRhckZvcm1hdDtcbiAgICBob29rcy5wcm90b3R5cGUgPSBwcm90bztcblxuICAgIC8vIGN1cnJlbnRseSBIVE1MNSBpbnB1dCB0eXBlIG9ubHkgc3VwcG9ydHMgMjQtaG91ciBmb3JtYXRzXG4gICAgaG9va3MuSFRNTDVfRk1UID0ge1xuICAgICAgICBEQVRFVElNRV9MT0NBTDogJ1lZWVktTU0tRERUSEg6bW0nLCAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgLz5cbiAgICAgICAgREFURVRJTUVfTE9DQUxfU0VDT05EUzogJ1lZWVktTU0tRERUSEg6bW06c3MnLCAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgc3RlcD1cIjFcIiAvPlxuICAgICAgICBEQVRFVElNRV9MT0NBTF9NUzogJ1lZWVktTU0tRERUSEg6bW06c3MuU1NTJywgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIHN0ZXA9XCIwLjAwMVwiIC8+XG4gICAgICAgIERBVEU6ICdZWVlZLU1NLUREJywgLy8gPGlucHV0IHR5cGU9XCJkYXRlXCIgLz5cbiAgICAgICAgVElNRTogJ0hIOm1tJywgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgLz5cbiAgICAgICAgVElNRV9TRUNPTkRTOiAnSEg6bW06c3MnLCAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiBzdGVwPVwiMVwiIC8+XG4gICAgICAgIFRJTUVfTVM6ICdISDptbTpzcy5TU1MnLCAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiBzdGVwPVwiMC4wMDFcIiAvPlxuICAgICAgICBXRUVLOiAnR0dHRy1bV11XVycsIC8vIDxpbnB1dCB0eXBlPVwid2Vla1wiIC8+XG4gICAgICAgIE1PTlRIOiAnWVlZWS1NTScsIC8vIDxpbnB1dCB0eXBlPVwibW9udGhcIiAvPlxuICAgIH07XG5cbiAgICByZXR1cm4gaG9va3M7XG5cbn0pKSk7XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFwcCA9IHZvaWQgMDtcbmNvbnN0IHJlY29yZF8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL3JlY29yZFwiKTtcbmNvbnN0IGxpbmtfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvY29udGVudC9saW5rXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2xpYi91dGlsXCIpO1xuY29uc3QgYXBwXzEgPSByZXF1aXJlKFwiLi93bWwvYXBwXCIpO1xuY29uc3QgcGFnZXNfMSA9IHJlcXVpcmUoXCIuL3BhZ2VzXCIpO1xuY29uc3QgcGFnZXMyUGFnZXMgPSAoKSA9PiB7XG4gICAgbGV0IHRtcCA9ICgwLCByZWNvcmRfMS5ncm91cCkocGFnZXNfMS5wYWdlcywgKF8sIGspID0+IGsuc3BsaXQoJ18nKVswXSk7XG4gICAgZm9yIChsZXQgc2VjIGluIHRtcClcbiAgICAgICAgaWYgKHRtcC5oYXNPd25Qcm9wZXJ0eShzZWMpKSB7XG4gICAgICAgICAgICBsZXQgbmV3U2VjID0ge307XG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIGluIHRtcFtzZWNdKVxuICAgICAgICAgICAgICAgIGlmICh0bXBbc2VjXS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdTZWNbbmFtZS5zcGxpdCgnXycpWzFdXSA9IHRtcFtzZWNdW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRtcFtzZWNdID0gbmV3U2VjO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHRtcDtcbn07XG5jb25zdCBwYWdlczJNb2R1bGVzID0gKCkgPT4ge1xuICAgIHJldHVybiAoMCwgcmVjb3JkXzEucmVkdWNlKShwYWdlc18xLnBhZ2VzLCB7fSwgKHAsIGMsIGspID0+IHtcbiAgICAgICAgcFtrLnNwbGl0KCdfJylbMV1dID0gYztcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfSk7XG59O1xuLyoqXG4gKiBBcHAgZGlzcGxheWluZyBhbGwgdGhlIHdtbCB3aWRnZXRzLlxuICovXG5jbGFzcyBBcHAge1xuICAgIGNvbnN0cnVjdG9yKHJvb3QpIHtcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IGFwcF8xLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMuY29udGVudCA9IFtdO1xuICAgICAgICB0aGlzLnBhZ2UgPSAnJztcbiAgICAgICAgdGhpcy5wYWdlcyA9IHBhZ2VzMlBhZ2VzKCk7XG4gICAgICAgIHRoaXMubW9kdWxlcyA9IHBhZ2VzMk1vZHVsZXMoKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBpZDoge1xuICAgICAgICAgICAgICAgIGxheW91dDogJ2xheW91dCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG5hdmlnYXRlIGlzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiBhXG4gICAgICAgICAqIG5hdmlnYXRpb24gbGluay5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmF2aWdhdGUgPSAoeyBuYW1lIH0pID0+IHtcbiAgICAgICAgICAgIHRoaXMucGFnZSA9IG5hbWU7XG4gICAgICAgICAgICBpZiAodGhpcy5tb2R1bGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgKDAsIHV0aWxfMS5nZXRCeUlkKSh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLmlkLmxheW91dClcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoZCkgPT4gZC5zZXRDb250ZW50KFt0aGlzLm1vZHVsZXNbbmFtZV0udmlldy5yZW5kZXIoKV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRvZ2dsZURyYXdlclxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50b2dnbGVEcmF3ZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAoMCwgdXRpbF8xLmdldEJ5SWQpKHRoaXMudmlldywgdGhpcy52YWx1ZXMuaWQubGF5b3V0KVxuICAgICAgICAgICAgICAgIC5tYXAoKGQpID0+IGQudG9nZ2xlKCkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBydW4gdGhlIGFwcGxpY2F0aW9uLlxuICAgICAqL1xuICAgIHJ1bigpIHtcbiAgICAgICAgbGV0IHsgcm9vdCB9ID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHJvb3QubGFzdENoaWxkKVxuICAgICAgICAgICAgcm9vdC5yZW1vdmVDaGlsZChyb290Lmxhc3RDaGlsZCk7XG4gICAgICAgIHJvb3QuYXBwZW5kQ2hpbGQodGhpcy52aWV3LnJlbmRlcigpKTtcbiAgICAgICAgbGV0IHBhdGggPSB3aW5kb3cubG9jYXRpb24uaGFzaC5zcGxpdCgnIycpWzFdO1xuICAgICAgICBwYXRoID0gcGF0aCA/IHBhdGguc3BsaXQoJy8nKS5qb2luKCcnKSA6ICcnO1xuICAgICAgICB0aGlzLm5hdmlnYXRlKG5ldyBsaW5rXzEuTGlua0NsaWNrZWRFdmVudChwYXRoLCBwYXRoKSk7XG4gICAgfVxuICAgIHN0YXRpYyBtYWluKHJvb3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBcHAocm9vdCk7XG4gICAgfVxufVxuZXhwb3J0cy5BcHAgPSBBcHA7XG5BcHAubWFpbihkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYXBwJykpLnJ1bigpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZXN1bHRzID0gdm9pZCAwO1xuZXhwb3J0cy5yZXN1bHRzID0gW1xuICAgIHsgbGFiZWw6ICdBc3VzJywgdmFsdWU6ICdBc3VzJyB9LFxuICAgIHsgbGFiZWw6ICdNU0knLCB2YWx1ZTogJ01TSScgfSxcbiAgICB7IGxhYmVsOiAnR2lnYWJ5dGUnLCB2YWx1ZTogJ0dpZ2FieXRlJyB9LFxuICAgIHsgbGFiZWw6ICdHaWdhcycsIHZhbHVlOiAnR2lnYXMnIH0sXG4gICAgeyBsYWJlbDogJ0FzdXNUZWsnLCB2YWx1ZTogJ0FzdXNUZWsnIH0sXG4gICAgeyBsYWJlbDogJ0FzdXN1Z2EnLCB2YWx1ZTogJ0FzdXN1Z2EnIH0sXG4gICAgeyBsYWJlbDogJ1F1YWxjb21tJywgdmFsdWU6ICdRdWFsY29tbScgfSxcbiAgICB7IGxhYmVsOiAnUXVhbGl0YXRpdmUnLCB2YWx1ZTogJ1F1YWxpdGF0dmUnIH0sXG4gICAgeyBsYWJlbDogJ0tpcnBhbGFuaVxcJ3MnLCB2YWx1ZTogJ0tpcnBhbGFuaVxcJ3MnIH0sXG4gICAgeyBsYWJlbDogJ0FzdW5kZXInLCB2YWx1ZTogJ0FzdW5kZXInIH1cbl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXN1bHRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FbWJlZFBhZ2UgPSB2b2lkIDA7XG5jb25zdCB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9lbWJlZFwiKTtcbmNsYXNzIEVtYmVkUGFnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGpvam86ICdodHRwczovL3d3dy55b3V0dWJlLmNvbS9lbWJlZC8xYmJyNXRNdVNuYycsXG4gICAgICAgICAgICB3aW46ICdodHRwczovL3d3dy55b3V0dWJlLmNvbS9lbWJlZC9pdGdTeVB4ZnFvRScsXG4gICAgICAgICAgICBtYXg6ICdodHRwczovL3d3dy55b3V0dWJlLmNvbS9lbWJlZC85cnJ6UVNiazloSScsXG4gICAgICAgICAgICBhbGxvdzogJ2FjY2VsZXJvbWV0ZXI7IGF1dG9wbGF5OyBlbmNyeXB0ZWQtbWVkaWE7IGd5cm9zY29wZTsgJyArXG4gICAgICAgICAgICAgICAgJ3BpY3R1cmUtaW4tcGljdHVyZSdcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkVtYmVkUGFnZSA9IEVtYmVkUGFnZTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBFbWJlZFBhZ2UoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYWluID0gdm9pZCAwO1xuY29uc3QgX19kb2N1bWVudCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbmNvbnN0IG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG5jb25zdCBncmlkXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2xheW91dC9ncmlkXCIpO1xuO1xuY29uc3QgZW1iZWRfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvY29udGVudC9lbWJlZFwiKTtcbjtcbmNvbnN0IGRlbW9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi93aWRnZXRzL2RlbW9cIik7XG47XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaDEnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdFbWJlZCcpXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZ3JpZF8xLkdyaWRMYXlvdXQoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZ3JpZF8xLlJvdyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZ3JpZF8xLkNvbHVtbih7ICdzcGFuJzogNCB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZW1iZWRfMS5FbWJlZCh7ICdjbGFzc05hbWUnOiAnLWFzcGVjdC1yYXRpby0xNng5JyB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdpZnJhbWUnLCB7ICdzcmMnOiBfX2NvbnRleHQudmFsdWVzLmpvam8sICdhbGxvdyc6IF9fY29udGV4dC52YWx1ZXMuYWxsb3cgfSwgW10pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSksIHsgJ2NsYXNzTmFtZSc6ICctYXNwZWN0LXJhdGlvLTE2eDknIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSwgeyAnc3Bhbic6IDQgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBncmlkXzEuQ29sdW1uKHsgJ3NwYW4nOiA0IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBlbWJlZF8xLkVtYmVkKHsgJ2NsYXNzTmFtZSc6ICctYXNwZWN0LXJhdGlvLTR4MycgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaWZyYW1lJywgeyAnc3JjJzogX19jb250ZXh0LnZhbHVlcy53aW4sICdhbGxvdyc6IF9fY29udGV4dC52YWx1ZXMuYWxsb3cgfSwgW10pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSksIHsgJ2NsYXNzTmFtZSc6ICctYXNwZWN0LXJhdGlvLTR4MycgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLCB7ICdzcGFuJzogNCB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGdyaWRfMS5Db2x1bW4oeyAnc3Bhbic6IDQgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGVtYmVkXzEuRW1iZWQoeyAnY2xhc3NOYW1lJzogJy1hc3BlY3QtcmF0aW8tMTZ4OScgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaWZyYW1lJywgeyAnc3JjJzogX19jb250ZXh0LnZhbHVlcy5tYXgsICdhbGxvdyc6IF9fY29udGV4dC52YWx1ZXMuYWxsb3cgfSwgW10pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSksIHsgJ2NsYXNzTmFtZSc6ICctYXNwZWN0LXJhdGlvLTE2eDknIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSwgeyAnc3Bhbic6IDQgfSlcbiAgICAgICAgICAgICAgICAgICAgXSksIHt9KVxuICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgIF0pLCB7fSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW1iZWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxpbmtQYWdlID0gdm9pZCAwO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi92aWV3c1wiKTtcbmNsYXNzIExpbmtQYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgb25DbGljazogKCkgPT4gYWxlcnQoJ1lvdSBjbGlja2VkIG1lPycpXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5MaW5rUGFnZSA9IExpbmtQYWdlO1xuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IExpbmtQYWdlKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWFpbiA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuY29uc3QgbGlua18xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL2xpYi9jb250ZW50L2xpbmtcIik7XG47XG5jb25zdCBkZW1vXzEgPSByZXF1aXJlKFwiLi4vLi4vd2lkZ2V0cy9kZW1vXCIpO1xuO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9faWYgPSAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpID0+IChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0ID8gX19hbHQoKSA6IFtdO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9ySW4gPSAobGlzdCwgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2Zvck9mID0gKG8sIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHRleHQgPSBfX2RvY3VtZW50LnRleHQ7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHVuc2FmZSA9IF9fZG9jdW1lbnQudW5zYWZlO1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCBpc1NldCA9ICh2YWx1ZSkgPT4gdmFsdWUgIT0gbnVsbDtcbmNsYXNzIE1haW4ge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2gxJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnTGlua3MnKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnVGhpcyBpcyBhICcpLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBsaW5rXzEuTGluayh7ICdocmVmJzogJyNsaW5rJyB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdsaW5rJylcbiAgICAgICAgICAgICAgICAgICAgXSksIHsgJ2hyZWYnOiAnI2xpbmsnIH0pLFxuICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcuJylcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1RoaXMgaXMgYSAnKSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgbGlua18xLkxpbmsoeyAnaHJlZic6ICcjZGlzYWJsZWQnLCAnZGlzYWJsZWQnOiB0cnVlIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ2Rpc2FibGVkJylcbiAgICAgICAgICAgICAgICAgICAgXSksIHsgJ2hyZWYnOiAnI2Rpc2FibGVkJywgJ2Rpc2FibGVkJzogdHJ1ZSB9KSxcbiAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnIGxpbmsuJylcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ0xpbmtzIGNhbiBhbHNvICcpLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBsaW5rXzEuTGluayh7ICd0ZXh0JzogJ3NwZWNpZnknIH0sIFtdKSwgeyAndGV4dCc6ICdzcGVjaWZ5JyB9KSxcbiAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnIGNvbnRlbnRzIGEgdGhlIHRleHQgYXR0cmlidXRlJylcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ0xpbmtzIGNhbiBhbHNvIGhhdmUgJyksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGxpbmtfMS5MaW5rKHsgJ29uQ2xpY2snOiBfX2NvbnRleHQudmFsdWVzLm9uQ2xpY2ssICd0ZXh0JzogJ2hhbmRsZXJzJyB9LCBbXSksIHsgJ29uQ2xpY2snOiBfX2NvbnRleHQudmFsdWVzLm9uQ2xpY2ssICd0ZXh0JzogJ2hhbmRsZXJzJyB9KVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnRGlzYWJsZWQgbGluayAnKSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgbGlua18xLkxpbmsoeyAnb25DbGljayc6IF9fY29udGV4dC52YWx1ZXMub25DbGljaywgJ2Rpc2FibGVkJzogdHJ1ZSwgJ3RleHQnOiAnaGFuZGxlcnMnIH0sIFtdKSwgeyAnb25DbGljayc6IF9fY29udGV4dC52YWx1ZXMub25DbGljaywgJ2Rpc2FibGVkJzogdHJ1ZSwgJ3RleHQnOiAnaGFuZGxlcnMnIH0pLFxuICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdcXHUwMDBhICAgICBkbyBub3RoaW5nLiBcXHUwMDBhICAnKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnWW91IGNhbiByZW1vdmUgdGhlIHVuZGVybGluZSB1c2luZyB0aGUgXFx1MDAwYSAgICAgJyksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGxpbmtfMS5MaW5rKHsgJ3RleHQnOiAnLXd3LW5vLWRlY29yYXRpb24nLCAnY2xhc3NOYW1lJzogJy13dy1uby1kZWNvcmF0aW9uJyB9LCBbXSksIHsgJ3RleHQnOiAnLXd3LW5vLWRlY29yYXRpb24nLCAnY2xhc3NOYW1lJzogJy13dy1uby1kZWNvcmF0aW9uJyB9KSxcbiAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnIG1vZGlmaWVyLlxcdTAwMGEgICcpXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pLCB7fSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlld3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1lZGlhRGVzY3JpcHRpb25QYWdlID0gdm9pZCAwO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvbWVkaWEtZGVzY3JpcHRpb25cIik7XG5jbGFzcyBNZWRpYURlc2NyaXB0aW9uUGFnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHt9O1xuICAgIH1cbn1cbmV4cG9ydHMuTWVkaWFEZXNjcmlwdGlvblBhZ2UgPSBNZWRpYURlc2NyaXB0aW9uUGFnZTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBNZWRpYURlc2NyaXB0aW9uUGFnZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1haW4gPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbmNvbnN0IG1lZGlhX2Rlc2NyaXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRlbnQvbWVkaWEtZGVzY3JpcHRpb25cIik7XG47XG5jb25zdCBkZW1vXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vd2lkZ2V0cy9kZW1vXCIpO1xuO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9faWYgPSAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpID0+IChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0ID8gX19hbHQoKSA6IFtdO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9ySW4gPSAobGlzdCwgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2Zvck9mID0gKG8sIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHRleHQgPSBfX2RvY3VtZW50LnRleHQ7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHVuc2FmZSA9IF9fZG9jdW1lbnQudW5zYWZlO1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCBpc1NldCA9ICh2YWx1ZSkgPT4gdmFsdWUgIT0gbnVsbDtcbmNsYXNzIE1haW4ge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2gxJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnTWVkaWEgRGVzY3JpcHRpb24nKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IG1lZGlhX2Rlc2NyaXB0aW9uXzEuTWVkaWFEZXNjcmlwdGlvbih7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBtZWRpYV9kZXNjcmlwdGlvbl8xLk1lZGlhKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaW1nJywgeyAnYWx0JzogJ3BsYWNlaG9sZGVyJywgJ3NyYyc6ICdodHRwczovL3ZpYS5wbGFjZWhvbGRlci5jb20vMTQweDEwMCcgfSwgW10pXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IG1lZGlhX2Rlc2NyaXB0aW9uXzEuRGVzY3JpcHRpb24oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdoNCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnRGVzY3JpcHRpb24nKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnTG9jYXRlZCBhdCB0aGUgc2lkZSByZWxhdGVkIHRvIHRoZSBpbWFnZSBvbiB0aGUgbGVmdC4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgXSksIHt9KVxuICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgIF0pLCB7fSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVkaWEtZGVzY3JpcHRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk92ZXJsYXlQYWdlID0gdm9pZCAwO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvb3ZlcmxheVwiKTtcbmNsYXNzIE92ZXJsYXlQYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBtTyA9IHRoaXMudmlldy5maW5kQnlJZCgnb3ZlcmxheScpO1xuICAgICAgICAgICAgICAgIGlmIChtTy5pc0p1c3QoKSlcbiAgICAgICAgICAgICAgICAgICAgbU8uZ2V0KCkuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLk92ZXJsYXlQYWdlID0gT3ZlcmxheVBhZ2U7XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgT3ZlcmxheVBhZ2UoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYWluID0gdm9pZCAwO1xuY29uc3QgX19kb2N1bWVudCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbmNvbnN0IG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG5jb25zdCBvdmVybGF5XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRlbnQvb3ZlcmxheVwiKTtcbjtcbmNvbnN0IGRlbW9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi93aWRnZXRzL2RlbW9cIik7XG47XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaDEnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdPdmVybGF5JylcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBvdmVybGF5XzEuT3ZlcmxheSh7IHdtbDogeyAnaWQnOiAnb3ZlcmxheScgfSwgJ29uQ2xpY2snOiBfX2NvbnRleHQudmFsdWVzLm9uQ2xpY2sgfSwgW10pLCB7IHdtbDogeyAnaWQnOiAnb3ZlcmxheScgfSwgJ29uQ2xpY2snOiBfX2NvbnRleHQudmFsdWVzLm9uQ2xpY2sgfSlcbiAgICAgICAgICAgIF0pLCB7fSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3ZlcmxheS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVGFnUGFnZSA9IHZvaWQgMDtcbmNvbnN0IHZpZXdzID0gcmVxdWlyZShcIi4vd21sL3RhZ1wiKTtcbmNvbnN0IHN0eWxlXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRlbnQvc3R5bGVcIik7XG5jbGFzcyBUYWdQYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgY2FwaXRhbGl6ZTogKHMpID0+IGAke3NbMF0udG9VcHBlckNhc2UoKX0ke3Muc2xpY2UoMSl9YCxcbiAgICAgICAgICAgIHN0eWxlczogW1xuICAgICAgICAgICAgICAgIHN0eWxlXzEuU3R5bGUuRGVmYXVsdCxcbiAgICAgICAgICAgICAgICBzdHlsZV8xLlN0eWxlLlByaW1hcnksXG4gICAgICAgICAgICAgICAgc3R5bGVfMS5TdHlsZS5TdWNjZXNzLFxuICAgICAgICAgICAgICAgIHN0eWxlXzEuU3R5bGUuSW5mbyxcbiAgICAgICAgICAgICAgICBzdHlsZV8xLlN0eWxlLldhcm5pbmcsXG4gICAgICAgICAgICAgICAgc3R5bGVfMS5TdHlsZS5FcnJvclxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuVGFnUGFnZSA9IFRhZ1BhZ2U7XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgVGFnUGFnZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1haW4gPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbmNvbnN0IHRhZ18xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9jb250ZW50L3RhZ1wiKTtcbjtcbmNvbnN0IGRlbW9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi93aWRnZXRzL2RlbW9cIik7XG47XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaDEnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnVGFnJylcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdoMicsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnU3R5bGVzJylcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uX19mb3JJbihfX2NvbnRleHQudmFsdWVzLnN0eWxlcywgKHYsIF8kJGksIF8kJGFsbCkgPT4gKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyB0YWdfMS5UYWcoeyAnc3R5bGUnOiB2LCAndGV4dCc6IF9fY29udGV4dC52YWx1ZXMuY2FwaXRhbGl6ZSh2KSB9LCBbXSksIHsgJ3N0eWxlJzogdiwgJ3RleHQnOiBfX2NvbnRleHQudmFsdWVzLmNhcGl0YWxpemUodikgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLCAoKSA9PiAoW10pKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgIF0pLCB7fSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFnLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UaHVtYm5haWxQYWdlID0gdm9pZCAwO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvdGh1bWJuYWlsXCIpO1xuY2xhc3MgVGh1bWJuYWlsUGFnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IGFsZXJ0KCdZb3UgY2xpY2tlZCBpdCEnKVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuVGh1bWJuYWlsUGFnZSA9IFRodW1ibmFpbFBhZ2U7XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgVGh1bWJuYWlsUGFnZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1haW4gPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbmNvbnN0IHRodW1ibmFpbF8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9jb250ZW50L3RodW1ibmFpbFwiKTtcbjtcbmNvbnN0IGdyaWRfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvbGF5b3V0L2dyaWRcIik7XG47XG5jb25zdCBkZW1vXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vd2lkZ2V0cy9kZW1vXCIpO1xuO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9faWYgPSAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpID0+IChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0ID8gX19hbHQoKSA6IFtdO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9ySW4gPSAobGlzdCwgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2Zvck9mID0gKG8sIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHRleHQgPSBfX2RvY3VtZW50LnRleHQ7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHVuc2FmZSA9IF9fZG9jdW1lbnQudW5zYWZlO1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCBpc1NldCA9ICh2YWx1ZSkgPT4gdmFsdWUgIT0gbnVsbDtcbmNsYXNzIE1haW4ge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2gxJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnVGh1bWJuYWlsJylcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBncmlkXzEuR3JpZExheW91dCh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBncmlkXzEuUm93KHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBncmlkXzEuQ29sdW1uKHsgJ3NwYW4nOiA0IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyB0aHVtYm5haWxfMS5UaHVtYm5haWwoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2ltZycsIHsgJ2FsdCc6ICdwbGFjZWhvbGRlcicsICdzcmMnOiAnaHR0cHM6Ly92aWEucGxhY2Vob2xkZXIuY29tLzE3MXgxODAnLCAnc3R5bGUnOiAnd2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtkaXNwbGF5OmJsb2NrJyB9LCBbXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSwge30pXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSwgeyAnc3Bhbic6IDQgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBncmlkXzEuQ29sdW1uKHsgJ3NwYW4nOiA0IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyB0aHVtYm5haWxfMS5UaHVtYm5haWwoeyAnb25DbGljayc6IF9fY29udGV4dC52YWx1ZXMub25DbGljayB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdpbWcnLCB7ICdhbHQnOiAncGxhY2Vob2xkZXInLCAnc3JjJzogJ2h0dHBzOi8vdmlhLnBsYWNlaG9sZGVyLmNvbS8xNzF4MTgwJywgJ3N0eWxlJzogJ3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7ZGlzcGxheTpibG9jaycgfSwgW10pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSksIHsgJ29uQ2xpY2snOiBfX2NvbnRleHQudmFsdWVzLm9uQ2xpY2sgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLCB7ICdzcGFuJzogNCB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGdyaWRfMS5Db2x1bW4oeyAnc3Bhbic6IDQgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRodW1ibmFpbF8xLlRodW1ibmFpbCh7ICdocmVmJzogJyMnIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2ltZycsIHsgJ2FsdCc6ICdwbGFjZWhvbGRlcicsICdzcmMnOiAnaHR0cHM6Ly92aWEucGxhY2Vob2xkZXIuY29tLzE3MXgxODAnLCAnc3R5bGUnOiAnd2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtkaXNwbGF5OmJsb2NrJyB9LCBbXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSwgeyAnaHJlZic6ICcjJyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksIHsgJ3NwYW4nOiA0IH0pXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGdyaWRfMS5Sb3coe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGdyaWRfMS5Db2x1bW4oeyAnc3Bhbic6IDQgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRodW1ibmFpbF8xLlRodW1ibmFpbCh7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaW1nJywgeyAnYWx0JzogJ3BsYWNlaG9sZGVyJywgJ3NyYyc6ICdodHRwczovL3ZpYS5wbGFjZWhvbGRlci5jb20vMTcxeDE4MCcsICdzdHlsZSc6ICd3aWR0aDoxMDAlO2hlaWdodDoxMDAlO2Rpc3BsYXk6YmxvY2snIH0sIFtdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgdGh1bWJuYWlsXzEuQ2FwdGlvbih7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2g0Jywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdDYXB0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ0Rlc2NyaWJlcyB0aGUgdGh1bWJuYWlsIGluIG1pbm9yIGRldGFpbC4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSksIHt9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLCB7ICdzcGFuJzogNCB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGdyaWRfMS5Db2x1bW4oeyAnc3Bhbic6IDQgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRodW1ibmFpbF8xLlRodW1ibmFpbCh7ICdvbkNsaWNrJzogX19jb250ZXh0LnZhbHVlcy5vbkNsaWNrIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2ltZycsIHsgJ2FsdCc6ICdwbGFjZWhvbGRlcicsICdzcmMnOiAnaHR0cHM6Ly92aWEucGxhY2Vob2xkZXIuY29tLzE3MXgxODAnLCAnc3R5bGUnOiAnd2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtkaXNwbGF5OmJsb2NrJyB9LCBbXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRodW1ibmFpbF8xLkNhcHRpb24oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdoNCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnQ2FwdGlvbicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdEZXNjcmliZXMgdGhlIHRodW1ibmFpbCBpbiBtaW5vciBkZXRhaWwuJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSwgeyAnb25DbGljayc6IF9fY29udGV4dC52YWx1ZXMub25DbGljayB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksIHsgJ3NwYW4nOiA0IH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZ3JpZF8xLkNvbHVtbih7ICdzcGFuJzogNCB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgdGh1bWJuYWlsXzEuVGh1bWJuYWlsKHsgJ2hyZWYnOiAnIycgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaW1nJywgeyAnYWx0JzogJ3BsYWNlaG9sZGVyJywgJ3NyYyc6ICdodHRwczovL3ZpYS5wbGFjZWhvbGRlci5jb20vMTcxeDE4MCcsICdzdHlsZSc6ICd3aWR0aDoxMDAlO2hlaWdodDoxMDAlO2Rpc3BsYXk6YmxvY2snIH0sIFtdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgdGh1bWJuYWlsXzEuQ2FwdGlvbih7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2g0Jywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdDYXB0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ0Rlc2NyaWJlcyB0aGUgdGh1bWJuYWlsIGluIG1pbm9yIGRldGFpbC4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSksIHt9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLCB7ICdocmVmJzogJyMnIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSwgeyAnc3Bhbic6IDQgfSlcbiAgICAgICAgICAgICAgICAgICAgXSksIHt9KVxuICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgIF0pLCB7fSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGh1bWJuYWlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CdXR0b25Hcm91cFBhZ2UgPSB2b2lkIDA7XG5jb25zdCB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9idXR0b24tZ3JvdXBcIik7XG5jbGFzcyBCdXR0b25Hcm91cFBhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbih0aGlzKTtcbiAgICB9XG59XG5leHBvcnRzLkJ1dHRvbkdyb3VwUGFnZSA9IEJ1dHRvbkdyb3VwUGFnZTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBCdXR0b25Hcm91cFBhZ2UoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYWluID0gdm9pZCAwO1xuY29uc3QgX19kb2N1bWVudCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbmNvbnN0IG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG5jb25zdCBkZW1vXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vd2lkZ2V0cy9kZW1vXCIpO1xuO1xuY29uc3QgYnV0dG9uXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRyb2wvYnV0dG9uXCIpO1xuO1xuY29uc3QgYnV0dG9uX2dyb3VwXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRyb2wvYnV0dG9uLWdyb3VwXCIpO1xuO1xuY29uc3QgZHJvcF9kb3duXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRyb2wvZHJvcC1kb3duXCIpO1xuO1xuY29uc3QgbWVudV8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9tZW51L21lbnVcIik7XG47XG5jb25zdCBpdGVtXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL21lbnUvaXRlbVwiKTtcbjtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgYnV0dG9uX2dyb3VwXzEuQnV0dG9uR3JvdXAoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGJ1dHRvbl8xLkJ1dHRvbih7ICd0ZXh0JzogJ29uZScgfSwgW10pLCB7ICd0ZXh0JzogJ29uZScgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBidXR0b25fMS5CdXR0b24oeyAndGV4dCc6ICd0d28nLCAnYWN0aXZlJzogdHJ1ZSB9LCBbXSksIHsgJ3RleHQnOiAndHdvJywgJ2FjdGl2ZSc6IHRydWUgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBidXR0b25fMS5CdXR0b24oeyAndGV4dCc6ICdmb3VyJyB9LCBbXSksIHsgJ3RleHQnOiAnZm91cicgfSlcbiAgICAgICAgICAgICAgICAgICAgXSksIHt9KVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgYnV0dG9uX2dyb3VwXzEuQnV0dG9uR3JvdXAoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGJ1dHRvbl8xLkJ1dHRvbih7ICd0ZXh0JzogJ29uZScgfSwgW10pLCB7ICd0ZXh0JzogJ29uZScgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBidXR0b25fMS5CdXR0b24oeyAndGV4dCc6ICd0d28nIH0sIFtdKSwgeyAndGV4dCc6ICd0d28nIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgYnV0dG9uXzEuQnV0dG9uKHsgJ3RleHQnOiAnZm91cicgfSwgW10pLCB7ICd0ZXh0JzogJ2ZvdXInIH0pXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGJ1dHRvbl9ncm91cF8xLkJ1dHRvbkdyb3VwKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBidXR0b25fMS5CdXR0b24oeyAndGV4dCc6ICdvbmUnIH0sIFtdKSwgeyAndGV4dCc6ICdvbmUnIH0pXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGJ1dHRvbl9ncm91cF8xLkJ1dHRvbkdyb3VwKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBidXR0b25fMS5CdXR0b24oeyAndGV4dCc6ICdvbmUnIH0sIFtdKSwgeyAndGV4dCc6ICdvbmUnIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZHJvcF9kb3duXzEuRHJvcERvd24oeyAnYnV0dG9uVGV4dCc6ICd0d28nIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBtZW51XzEuTWVudSh7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBpdGVtXzEuSXRlbSh7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2EnLCB7ICdocmVmJzogJyMnIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdMaW5rJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGl0ZW1fMS5JdGVtKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnYScsIHsgJ2hyZWYnOiAnIycgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ0xpbmsnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgaXRlbV8xLkl0ZW0oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdhJywgeyAnaHJlZic6ICcjJyB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnTGluaycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSwge30pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSksIHt9KVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksIHsgJ2J1dHRvblRleHQnOiAndHdvJyB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGJ1dHRvbl8xLkJ1dHRvbih7ICd0ZXh0JzogJ3RocmVlJyB9LCBbXSksIHsgJ3RleHQnOiAndGhyZWUnIH0pXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSksIHt9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idXR0b24tZ3JvdXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJ1dHRvblNlbGVjdFBhZ2UgPSB2b2lkIDA7XG5jb25zdCB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9idXR0b24tc2VsZWN0XCIpO1xuY2xhc3MgQnV0dG9uU2VsZWN0UGFnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIG9wdGlvbnM6IFtcbiAgICAgICAgICAgICAgICB7IHRleHQ6ICdBc3VzJywgdmFsdWU6ICdBc3VzJyB9LFxuICAgICAgICAgICAgICAgIHsgdGV4dDogJ01TSScsIHZhbHVlOiAnTVNJJyB9LFxuICAgICAgICAgICAgICAgIHsgdGV4dDogJ0dpZ2FieXRlJywgdmFsdWU6ICdHaWdhYnl0ZScgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHZhbHVlOiAnTVNJJyxcbiAgICAgICAgICAgIHZhbHVlczogWydNU0knXVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gKHsgdmFsdWUsIG5hbWUgfSkgPT4ge1xuICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgICAgIC52aWV3XG4gICAgICAgICAgICAgICAgLmZpbmRCeUlkKGAke25hbWV9LWNvbnRlbnRgKVxuICAgICAgICAgICAgICAgIC5tYXAoKGUpID0+IHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZS5sYXN0Q2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIGUucmVtb3ZlQ2hpbGQoZS5sYXN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKHZhbHVlKSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25DaGFuZ2VNdWx0aSA9ICh7IHZhbHVlLCBuYW1lIH0pID0+IHtcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICAgICAudmlld1xuICAgICAgICAgICAgICAgIC5maW5kQnlJZChgJHtuYW1lfS1jb250ZW50YClcbiAgICAgICAgICAgICAgICAubWFwKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGUubGFzdENoaWxkKVxuICAgICAgICAgICAgICAgICAgICBlLnJlbW92ZUNoaWxkKGUubGFzdENoaWxkKTtcbiAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFN0cmluZyh2YWx1ZSkpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQnV0dG9uU2VsZWN0UGFnZSA9IEJ1dHRvblNlbGVjdFBhZ2U7XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgQnV0dG9uU2VsZWN0UGFnZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1haW4gPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbmNvbnN0IGRlbW9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi93aWRnZXRzL2RlbW9cIik7XG47XG5jb25zdCBidXR0b25fc2VsZWN0XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRyb2wvYnV0dG9uLXNlbGVjdFwiKTtcbjtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1lvdSBzZWxlY3RlZDogJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnYicsIHsgd21sOiB7ICdpZCc6ICdzZWxlY3QtY29udGVudCcgfSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnKE5vbmUpJylcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnLicpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBidXR0b25fc2VsZWN0XzEuQnV0dG9uU2VsZWN0KHsgd21sOiB7ICdpZCc6ICdzZWxlY3QnIH0sICduYW1lJzogJ3NlbGVjdCcsICdvcHRpb25zJzogX19jb250ZXh0LnZhbHVlcy5vcHRpb25zLCAndmFsdWUnOiBfX2NvbnRleHQudmFsdWVzLnZhbHVlLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQub25DaGFuZ2UgfSwgW10pLCB7IHdtbDogeyAnaWQnOiAnc2VsZWN0JyB9LCAnbmFtZSc6ICdzZWxlY3QnLCAnb3B0aW9ucyc6IF9fY29udGV4dC52YWx1ZXMub3B0aW9ucywgJ3ZhbHVlJzogX19jb250ZXh0LnZhbHVlcy52YWx1ZSwgJ29uQ2hhbmdlJzogX19jb250ZXh0Lm9uQ2hhbmdlIH0pXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdZb3UgY2FuIGFsc28gdXNlIE11bHRpQnV0dG9uU2VsZWN0IGluc3RlYWQ6ICcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2InLCB7IHdtbDogeyAnaWQnOiAnbXVsdGktY29udGVudCcgfSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnKE5vbmUpJylcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnLicpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBidXR0b25fc2VsZWN0XzEuTXVsdGlCdXR0b25TZWxlY3QoeyB3bWw6IHsgJ2lkJzogJ211bHRpJyB9LCAnbmFtZSc6ICdtdWx0aScsICdvcHRpb25zJzogX19jb250ZXh0LnZhbHVlcy5vcHRpb25zLCAndmFsdWUnOiBfX2NvbnRleHQudmFsdWVzLnZhbHVlcywgJ29uQ2hhbmdlJzogX19jb250ZXh0Lm9uQ2hhbmdlTXVsdGkgfSwgW10pLCB7IHdtbDogeyAnaWQnOiAnbXVsdGknIH0sICduYW1lJzogJ211bHRpJywgJ29wdGlvbnMnOiBfX2NvbnRleHQudmFsdWVzLm9wdGlvbnMsICd2YWx1ZSc6IF9fY29udGV4dC52YWx1ZXMudmFsdWVzLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQub25DaGFuZ2VNdWx0aSB9KVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgIF0pLCB7fSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnV0dG9uLXNlbGVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQnV0dG9uUGFnZSA9IHZvaWQgMDtcbmNvbnN0IHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2J1dHRvblwiKTtcbmNvbnN0IHN0eWxlXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRlbnQvc3R5bGVcIik7XG5jb25zdCBzaXplXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRlbnQvc2l6ZVwiKTtcbmNsYXNzIEJ1dHRvblBhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbih0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBjYXBpdGFsaXplOiAocykgPT4gYCR7c1swXS50b1VwcGVyQ2FzZSgpfSR7cy5zbGljZSgxKX1gLFxuICAgICAgICAgICAgc3R5bGVzOiBbXG4gICAgICAgICAgICAgICAgc3R5bGVfMS5TdHlsZS5EZWZhdWx0LFxuICAgICAgICAgICAgICAgIHN0eWxlXzEuU3R5bGUuUHJpbWFyeSxcbiAgICAgICAgICAgICAgICBzdHlsZV8xLlN0eWxlLlN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgc3R5bGVfMS5TdHlsZS5JbmZvLFxuICAgICAgICAgICAgICAgIHN0eWxlXzEuU3R5bGUuV2FybmluZyxcbiAgICAgICAgICAgICAgICBzdHlsZV8xLlN0eWxlLkVycm9yXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgc2l6ZXM6IFtcbiAgICAgICAgICAgICAgICBzaXplXzEuU2l6ZS5FeHRyYVNtYWxsLFxuICAgICAgICAgICAgICAgIHNpemVfMS5TaXplLlNtYWxsLFxuICAgICAgICAgICAgICAgIHNpemVfMS5TaXplLk1lZGl1bSxcbiAgICAgICAgICAgICAgICBzaXplXzEuU2l6ZS5MYXJnZSxcbiAgICAgICAgICAgICAgICBzaXplXzEuU2l6ZS5FeHRyYUxhcmdlXG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5CdXR0b25QYWdlID0gQnV0dG9uUGFnZTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBCdXR0b25QYWdlKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWFpbiA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuY29uc3QgZGVtb18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3dpZGdldHMvZGVtb1wiKTtcbjtcbmNvbnN0IGJ1dHRvbl8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9jb250cm9sL2J1dHRvblwiKTtcbjtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdoMScsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdCdXR0b25zJylcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdoMicsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnU3R5bGUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5fX2ZvckluKF9fY29udGV4dC52YWx1ZXMuc3R5bGVzLCAodiwgXyQkaSwgXyQkYWxsKSA9PiAoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGJ1dHRvbl8xLkJ1dHRvbih7ICduYW1lJzogdiwgJ3N0eWxlJzogdiwgJ3RleHQnOiBfX2NvbnRleHQudmFsdWVzLmNhcGl0YWxpemUodikgfSwgW10pLCB7ICduYW1lJzogdiwgJ3N0eWxlJzogdiwgJ3RleHQnOiBfX2NvbnRleHQudmFsdWVzLmNhcGl0YWxpemUodikgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLCAoKSA9PiAoW10pKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2gyJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ091dGxpbmUnKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uX19mb3JJbihfX2NvbnRleHQudmFsdWVzLnN0eWxlcywgKHN0eWxlLCBfJCRpLCBfJCRhbGwpID0+IChbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBidXR0b25fMS5CdXR0b24oeyAnc3R5bGUnOiBzdHlsZSwgJ291dGxpbmUnOiB0cnVlLCAndGV4dCc6IF9fY29udGV4dC52YWx1ZXMuY2FwaXRhbGl6ZShzdHlsZSkgfSwgW10pLCB7ICdzdHlsZSc6IHN0eWxlLCAnb3V0bGluZSc6IHRydWUsICd0ZXh0JzogX19jb250ZXh0LnZhbHVlcy5jYXBpdGFsaXplKHN0eWxlKSB9KVxuICAgICAgICAgICAgICAgICAgICBdKSwgKCkgPT4gKFtdKSlcbiAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdoMicsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnQWN0aXZlJylcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uX19mb3JJbihfX2NvbnRleHQudmFsdWVzLnN0eWxlcywgKHYsIF8kJGksIF8kJGFsbCkgPT4gKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBidXR0b25fMS5CdXR0b24oeyAnbmFtZSc6IHYsICdhY3RpdmUnOiB0cnVlLCAnc3R5bGUnOiB2LCAndGV4dCc6IF9fY29udGV4dC52YWx1ZXMuY2FwaXRhbGl6ZSh2KSB9LCBbXSksIHsgJ25hbWUnOiB2LCAnYWN0aXZlJzogdHJ1ZSwgJ3N0eWxlJzogdiwgJ3RleHQnOiBfX2NvbnRleHQudmFsdWVzLmNhcGl0YWxpemUodikgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLCAoKSA9PiAoW10pKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2gyJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdEaXNhYmxlZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLl9fZm9ySW4oX19jb250ZXh0LnZhbHVlcy5zdHlsZXMsICh2LCBfJCRpLCBfJCRhbGwpID0+IChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgYnV0dG9uXzEuQnV0dG9uKHsgJ25hbWUnOiB2LCAnZGlzYWJsZWQnOiB0cnVlLCAnc3R5bGUnOiB2LCAndGV4dCc6IF9fY29udGV4dC52YWx1ZXMuY2FwaXRhbGl6ZSh2KSB9LCBbXSksIHsgJ25hbWUnOiB2LCAnZGlzYWJsZWQnOiB0cnVlLCAnc3R5bGUnOiB2LCAndGV4dCc6IF9fY29udGV4dC52YWx1ZXMuY2FwaXRhbGl6ZSh2KSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksICgpID0+IChbXSkpXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaDInLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnU2l6ZScpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAuLi5fX2ZvckluKF9fY29udGV4dC52YWx1ZXMuc3R5bGVzLCAoc3R5bGUsIF8kJGksIF8kJGFsbCkgPT4gKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5fX2ZvckluKF9fY29udGV4dC52YWx1ZXMuc2l6ZXMsIChzaXplLCBfJCRpLCBfJCRhbGwpID0+IChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGJ1dHRvbl8xLkJ1dHRvbih7ICduYW1lJzogc2l6ZSwgJ3N0eWxlJzogc3R5bGUsICdzaXplJzogc2l6ZSwgJ3RleHQnOiBfX2NvbnRleHQudmFsdWVzLmNhcGl0YWxpemUoc2l6ZSkgfSwgW10pLCB7ICduYW1lJzogc2l6ZSwgJ3N0eWxlJzogc3R5bGUsICdzaXplJzogc2l6ZSwgJ3RleHQnOiBfX2NvbnRleHQudmFsdWVzLmNhcGl0YWxpemUoc2l6ZSkgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSwgKCkgPT4gKFtdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgIF0pLCAoKSA9PiAoW10pKVxuICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2gyJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ0Jsb2NrJylcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIC4uLl9fZm9ySW4oX19jb250ZXh0LnZhbHVlcy5zdHlsZXMsIChzdHlsZSwgXyQkaSwgXyQkYWxsKSA9PiAoW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgYnV0dG9uXzEuQnV0dG9uKHsgJ3N0eWxlJzogc3R5bGUsICdibG9jayc6IHRydWUsICd0ZXh0JzogX19jb250ZXh0LnZhbHVlcy5jYXBpdGFsaXplKHN0eWxlKSB9LCBbXSksIHsgJ3N0eWxlJzogc3R5bGUsICdibG9jayc6IHRydWUsICd0ZXh0JzogX19jb250ZXh0LnZhbHVlcy5jYXBpdGFsaXplKHN0eWxlKSB9KVxuICAgICAgICAgICAgICAgICAgICBdKSwgKCkgPT4gKFtdKSlcbiAgICAgICAgICAgICAgICBdKSwge30pXG4gICAgICAgICAgICBdKSwge30pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1dHRvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2hlY2tib3hQYWdlID0gdm9pZCAwO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvY2hlY2tib3hcIik7XG5jbGFzcyBDaGVja2JveFBhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbih0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRydWU7XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSAoeyB2YWx1ZSB9KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZmluZEJ5SWQoJ2NvbnRlbnQnKVxuICAgICAgICAgICAgICAgIC5tYXAoKGUpID0+IHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZS5maXJzdENoaWxkKVxuICAgICAgICAgICAgICAgICAgICBlLnJlbW92ZUNoaWxkKGUuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWx1ZSA9PT0gdHJ1ZSA/XG4gICAgICAgICAgICAgICAgICAgICdvbicgOlxuICAgICAgICAgICAgICAgICAgICAodmFsdWUgPT09IGZhbHNlID8gJ29mZicgOiAnZXJyb3InKSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5DaGVja2JveFBhZ2UgPSBDaGVja2JveFBhZ2U7XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgQ2hlY2tib3hQYWdlKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWFpbiA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuY29uc3QgZGVtb18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3dpZGdldHMvZGVtb1wiKTtcbjtcbmNvbnN0IGNoZWNrYm94XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRyb2wvY2hlY2tib3hcIik7XG47XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1RoZSBjaGVja2JveCBpcyAnKSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2InLCB7IHdtbDogeyAnaWQnOiAnY29udGVudCcgfSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCd1bnRvdWNoZWQnKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnLicpXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBjaGVja2JveF8xLkNoZWNrYm94KHsgJ25hbWUnOiAnY2hlY2tib3gnLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQub25DaGFuZ2UgfSwgW10pLCB7ICduYW1lJzogJ2NoZWNrYm94JywgJ29uQ2hhbmdlJzogX19jb250ZXh0Lm9uQ2hhbmdlIH0pXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pLCB7fSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlY2tib3guanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm9uQ2hhbmdlID0gZXhwb3J0cy5EYXRlRmllbGRQYWdlID0gdm9pZCAwO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvZGF0ZS1maWVsZFwiKTtcbmNvbnN0IGRhdGVfZmllbGRfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi9saWIvY29udHJvbC9kYXRlLWZpZWxkXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL2xpYi91dGlsXCIpO1xuY2xhc3MgRGF0ZUZpZWxkUGFnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGZvcm1hdHM6IHtcbiAgICAgICAgICAgICAgICBpc286IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdpc28nLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnaXNvJyxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdJU084NjAxJyxcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBkYXRlX2ZpZWxkXzEuRm9ybWF0LklTTzg2MDEsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdJU084NjAxIGRhdGUnLFxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTogKDAsIGV4cG9ydHMub25DaGFuZ2UpKHRoaXMpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdjb21tb24nLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnY29tbW9uJyxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdDb21vbicsXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogZGF0ZV9maWVsZF8xLkZvcm1hdC5DT01NT04sXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdDb21tb24gZGF0ZScsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiAoMCwgZXhwb3J0cy5vbkNoYW5nZSkodGhpcylcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHVzOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAndXMnLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAndXMnLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ1VTJyxcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBkYXRlX2ZpZWxkXzEuRm9ybWF0LlVTQSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ1VTIGRhdGUnLFxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTogKDAsIGV4cG9ydHMub25DaGFuZ2UpKHRoaXMpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0YXRlczoge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3N1Y2Nlc3MnLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ1N1Y2Nlc3MnLFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiAnU3VjY2VzcyBkYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgd2FybmluZzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBibG9jazogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiAoMCwgZXhwb3J0cy5vbkNoYW5nZSkodGhpcylcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdhcm5pbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICd3YXJuaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3dhcm5pbmcnLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ1dhcm5pbmcnLFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIHdhcm5pbmc6ICdXYXJuaW5nIGRhdGUnLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBibG9jazogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiAoMCwgZXhwb3J0cy5vbkNoYW5nZSkodGhpcylcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ0Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB3YXJuaW5nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiAnRXJyb3IgZGF0ZScsXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6ICgwLCBleHBvcnRzLm9uQ2hhbmdlKSh0aGlzKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYmxvY2s6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdibG9jaycsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdibG9jaycsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiAnQmxvY2snLFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIHdhcm5pbmc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgYmxvY2s6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiAoMCwgZXhwb3J0cy5vbkNoYW5nZSkodGhpcylcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuRGF0ZUZpZWxkUGFnZSA9IERhdGVGaWVsZFBhZ2U7XG5jb25zdCBvbkNoYW5nZSA9IChkKSA9PiAoeyBuYW1lLCB2YWx1ZSB9KSA9PiB7XG4gICAgbGV0IG1EYXRlID0gKDAsIHV0aWxfMS5nZXRCeUlkKShkLnZpZXcsIG5hbWUpO1xuICAgIGlmIChtRGF0ZS5pc0p1c3QoKSkge1xuICAgICAgICBsZXQgZCA9IG1EYXRlLmdldCgpO1xuICAgICAgICBkLnNldE1lc3NhZ2UoYFRoZSBkYXRlIGlzICR7dmFsdWV9LmApO1xuICAgIH1cbn07XG5leHBvcnRzLm9uQ2hhbmdlID0gb25DaGFuZ2U7XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgRGF0ZUZpZWxkUGFnZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1haW4gPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbmNvbnN0IGRlbW9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi93aWRnZXRzL2RlbW9cIik7XG47XG5jb25zdCBkYXRlX2ZpZWxkXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRyb2wvZGF0ZS1maWVsZFwiKTtcbjtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgIC4uLl9fZm9yT2YoX19jb250ZXh0LnZhbHVlcy5mb3JtYXRzLCAoc3BlYywgXyQkaywgXyQkYWxsKSA9PiAoW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGRhdGVfZmllbGRfMS5EYXRlRmllbGQoeyB3bWw6IHsgJ2lkJzogc3BlYy5pZCB9LCAnbmFtZSc6IHNwZWMubmFtZSwgJ2xhYmVsJzogc3BlYy5sYWJlbCwgJ2Zvcm1hdCc6IHNwZWMuZm9ybWF0LCAnbWVzc2FnZSc6IHNwZWMubWVzc2FnZSwgJ29uQ2hhbmdlJzogc3BlYy5vbkNoYW5nZSB9LCBbXSksIHsgd21sOiB7ICdpZCc6IHNwZWMuaWQgfSwgJ25hbWUnOiBzcGVjLm5hbWUsICdsYWJlbCc6IHNwZWMubGFiZWwsICdmb3JtYXQnOiBzcGVjLmZvcm1hdCwgJ21lc3NhZ2UnOiBzcGVjLm1lc3NhZ2UsICdvbkNoYW5nZSc6IHNwZWMub25DaGFuZ2UgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgICAgICBdKSwgKCkgPT4gKFtdKSksXG4gICAgICAgICAgICAgICAgLi4uX19mb3JPZihfX2NvbnRleHQudmFsdWVzLnN0YXRlcywgKHNwZWMsIF8kJGssIF8kJGFsbCkgPT4gKFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkYXRlX2ZpZWxkXzEuRGF0ZUZpZWxkKHsgd21sOiB7ICdpZCc6IHNwZWMuaWQgfSwgJ25hbWUnOiBzcGVjLm5hbWUsICdsYWJlbCc6IHNwZWMubGFiZWwsICdzdWNjZXNzJzogc3BlYy5zdWNjZXNzLCAnd2FybmluZyc6IHNwZWMud2FybmluZywgJ2Vycm9yJzogc3BlYy5lcnJvciwgJ2Jsb2NrJzogc3BlYy5ibG9jaywgJ29uQ2hhbmdlJzogc3BlYy5vbkNoYW5nZSB9LCBbXSksIHsgd21sOiB7ICdpZCc6IHNwZWMuaWQgfSwgJ25hbWUnOiBzcGVjLm5hbWUsICdsYWJlbCc6IHNwZWMubGFiZWwsICdzdWNjZXNzJzogc3BlYy5zdWNjZXNzLCAnd2FybmluZyc6IHNwZWMud2FybmluZywgJ2Vycm9yJzogc3BlYy5lcnJvciwgJ2Jsb2NrJzogc3BlYy5ibG9jaywgJ29uQ2hhbmdlJzogc3BlYy5vbkNoYW5nZSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgXSksIHt9KVxuICAgICAgICAgICAgICAgIF0pLCAoKSA9PiAoW10pKVxuICAgICAgICAgICAgXSksIHt9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRlLWZpZWxkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EaXNwbGF5RmllbGRQYWdlID0gdm9pZCAwO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvZGlzcGxheS1maWVsZFwiKTtcbmNvbnN0IHN0eWxlXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRlbnQvc3R5bGVcIik7XG5jb25zdCBnZXRTdHlsZXMgPSAoKSA9PiBbXG4gICAgc3R5bGVfMS5TdHlsZS5EZWZhdWx0LFxuICAgIHN0eWxlXzEuU3R5bGUuUHJpbWFyeSxcbiAgICBzdHlsZV8xLlN0eWxlLlN1Y2Nlc3MsXG4gICAgc3R5bGVfMS5TdHlsZS5JbmZvLFxuICAgIHN0eWxlXzEuU3R5bGUuV2FybmluZyxcbiAgICBzdHlsZV8xLlN0eWxlLkVycm9yXG5dO1xuY2xhc3MgRGlzcGxheUZpZWxkUGFnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGNhcGl0YWxpemU6IChzKSA9PiBgJHtzWzBdLnRvVXBwZXJDYXNlKCl9JHtzLnNsaWNlKDEpfWAsXG4gICAgICAgICAgICBzdHlsZXM6IGdldFN0eWxlcygpXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5EaXNwbGF5RmllbGRQYWdlID0gRGlzcGxheUZpZWxkUGFnZTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBEaXNwbGF5RmllbGRQYWdlKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWFpbiA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuY29uc3QgZGlzcGxheV9maWVsZF8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9jb250cm9sL2Rpc3BsYXktZmllbGRcIik7XG47XG5jb25zdCBkZW1vXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vd2lkZ2V0cy9kZW1vXCIpO1xuO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9faWYgPSAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpID0+IChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0ID8gX19hbHQoKSA6IFtdO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9ySW4gPSAobGlzdCwgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2Zvck9mID0gKG8sIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHRleHQgPSBfX2RvY3VtZW50LnRleHQ7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHVuc2FmZSA9IF9fZG9jdW1lbnQudW5zYWZlO1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCBpc1NldCA9ICh2YWx1ZSkgPT4gdmFsdWUgIT0gbnVsbDtcbmNsYXNzIE1haW4ge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZGlzcGxheV9maWVsZF8xLkRpc3BsYXlGaWVsZCh7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnIEl0IHdhcyBhIGNob2ljZS4nKVxuICAgICAgICAgICAgICAgICAgICBdKSwge30pXG4gICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkaXNwbGF5X2ZpZWxkXzEuRGlzcGxheUZpZWxkKHsgJ2Rpc2FibGVkJzogdHJ1ZSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdEaXNhYmxlZCcpXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7ICdkaXNhYmxlZCc6IHRydWUgfSlcbiAgICAgICAgICAgICAgICBdKSwge30pXG4gICAgICAgICAgICBdKSwge30pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpc3BsYXktZmllbGQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRyb3BEb3duUGFnZSA9IHZvaWQgMDtcbmNvbnN0IHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2Ryb3AtZG93blwiKTtcbmNsYXNzIERyb3BEb3duUGFnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLm9uQ2xpY2sgPSAobXNnKSA9PiAoZSkgPT4ge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgYWxlcnQobXNnKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkRyb3BEb3duUGFnZSA9IERyb3BEb3duUGFnZTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBEcm9wRG93blBhZ2UoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYWluID0gdm9pZCAwO1xuY29uc3QgX19kb2N1bWVudCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbmNvbnN0IG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG5jb25zdCBkZW1vXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vd2lkZ2V0cy9kZW1vXCIpO1xuO1xuY29uc3QgZHJvcF9kb3duXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRyb2wvZHJvcC1kb3duXCIpO1xuO1xuY29uc3QgbWVudV8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9tZW51L21lbnVcIik7XG47XG5jb25zdCBpdGVtXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL21lbnUvaXRlbVwiKTtcbjtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZHJvcF9kb3duXzEuRHJvcERvd24oeyAnYnV0dG9uVGV4dCc6ICdDbGljayBNZScgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgbWVudV8xLk1lbnUoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBpdGVtXzEuSXRlbSh7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnYScsIHsgJ2hyZWYnOiAnIycsICdvbmNsaWNrJzogX19jb250ZXh0Lm9uQ2xpY2soJ1lvdSBjbGlja2VkIG9uZScpIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ09uZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBpdGVtXzEuSXRlbSh7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnYScsIHsgJ2hyZWYnOiAnIycsICdvbmNsaWNrJzogX19jb250ZXh0Lm9uQ2xpY2soJ1lvdSBjbGlja2VkIHR3bycpIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1R3bycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBpdGVtXzEuRGl2aWRlcih7fSwgW10pLCB7fSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgaXRlbV8xLkl0ZW0oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2EnLCB7ICdocmVmJzogJyMnLCAnb25jbGljayc6IF9fY29udGV4dC5vbkNsaWNrKCdZb3UgY2xpY2tlZCB0aHJlZScpIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1RocmVlJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSwge30pXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSwge30pXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7ICdidXR0b25UZXh0JzogJ0NsaWNrIE1lJyB9KSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZHJvcF9kb3duXzEuRHJvcERvd24oeyAnYnV0dG9uVGV4dCc6ICdNZSBUb28nLCAnYXV0b0Nsb3NlJzogZmFsc2UgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2gxJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdBbnkgZmxvdyBjb250ZW50IGNhbiBnbyBoZXJlIScpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICBdKSwgeyAnYnV0dG9uVGV4dCc6ICdNZSBUb28nLCAnYXV0b0Nsb3NlJzogZmFsc2UgfSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGRyb3BfZG93bl8xLkRyb3BEb3duKHsgJ2J1dHRvblRleHQnOiAnQ2FuXFwndCB0b3VjaCB0aGlzIScsICdkaXNhYmxlZCc6IHRydWUgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1lvdSB3aWxsIG5ldmVyIHNlZSB0aGlzIScpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICBdKSwgeyAnYnV0dG9uVGV4dCc6ICdDYW5cXCd0IHRvdWNoIHRoaXMhJywgJ2Rpc2FibGVkJzogdHJ1ZSB9KSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZHJvcF9kb3duXzEuRHJvcERvd24oeyAnYnV0dG9uVGV4dCc6ICdJIGFtIGFuIGFuY2hvcicsICdhbmNob3InOiB0cnVlIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdiJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdDb250ZW50JylcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7ICdidXR0b25UZXh0JzogJ0kgYW0gYW4gYW5jaG9yJywgJ2FuY2hvcic6IHRydWUgfSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSksIHt9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kcm9wLWRvd24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRyb3BMaXN0RmllbGRQYWdlID0gdm9pZCAwO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvZHJvcC1saXN0LWZpZWxkXCIpO1xuY29uc3QgcmVzdWx0c18xID0gcmVxdWlyZShcIi4uLy4uL2ZpeHR1cmVzL2RhdGEvcmVzdWx0c1wiKTtcbmNvbnN0IG9wdGlvbnMgPSByZXN1bHRzXzEucmVzdWx0cztcbmNsYXNzIERyb3BMaXN0RmllbGRQYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgbm9ybWFsOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdub3JtYWwnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdub3JtYWwnLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnTm9ybWFsJyxcbiAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHRzXzEucmVzdWx0c1syXS52YWx1ZSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogZG9DaGFuZ2UodGhpcylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdWNjZXNzOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnc3VjY2VzcycsXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdTdWNjZXNzJyxcbiAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdUaGlzIGhhcyBhIHN1Y2Nlc3MgbWVzc2FnZS4nLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBkb0NoYW5nZSh0aGlzKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdhcm5pbmc6IHtcbiAgICAgICAgICAgICAgICBpZDogJ3dhcm5pbmcnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd3YXJuaW5nJyxcbiAgICAgICAgICAgICAgICBsYWJlbDogJ1dhcm5pbmcnLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1RoaXMgaGFzIGEgd2FybmluZyBtZXNzYWdlLicsXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6IGRvQ2hhbmdlKHRoaXMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgICBpZDogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnRXJyb3InLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1RoaXMgaGFzIGEgZXJyb3IgbWVzc2FnZS4nLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBkb0NoYW5nZSh0aGlzKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkRyb3BMaXN0RmllbGRQYWdlID0gRHJvcExpc3RGaWVsZFBhZ2U7XG5jb25zdCBkb0NoYW5nZSA9IChwYWdlKSA9PiAoeyBuYW1lLCB2YWx1ZSB9KSA9PiBwYWdlXG4gICAgLnZpZXdcbiAgICAuZmluZEJ5SWQobmFtZSlcbiAgICAubWFwKCgpID0+IHtcbiAgICBhbGVydChgU2VsZWN0ZWQ6ICR7bmFtZX09JHt2YWx1ZX1gKTtcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IERyb3BMaXN0RmllbGRQYWdlKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWFpbiA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuY29uc3QgZGVtb18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3dpZGdldHMvZGVtb1wiKTtcbjtcbmNvbnN0IGRyb3BfbGlzdF9maWVsZF8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9jb250cm9sL2Ryb3AtbGlzdC1maWVsZFwiKTtcbjtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdiJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ05vcm1hbCcpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkcm9wX2xpc3RfZmllbGRfMS5Ecm9wTGlzdEZpZWxkKHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMubm9ybWFsLm5hbWUgfSwgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5uYW1lLCAndmFsdWUnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC52YWx1ZSwgJ29wdGlvbnMnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5vcHRpb25zLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5vbkNoYW5nZSB9LCBbXSksIHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMubm9ybWFsLm5hbWUgfSwgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5uYW1lLCAndmFsdWUnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC52YWx1ZSwgJ29wdGlvbnMnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5vcHRpb25zLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5vbkNoYW5nZSB9KVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2InLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnU3VjY2VzcycpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkcm9wX2xpc3RfZmllbGRfMS5Ecm9wTGlzdEZpZWxkKHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuc3VjY2Vzcy5pZCB9LCAnY2xhc3NOYW1lJzogJy1zdWNjZXNzJywgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3MubmFtZSwgJ29wdGlvbnMnOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3Mub3B0aW9ucywgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5zdWNjZXNzLm9uQ2hhbmdlIH0sIFtdKSwgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5zdWNjZXNzLmlkIH0sICdjbGFzc05hbWUnOiAnLXN1Y2Nlc3MnLCAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMuc3VjY2Vzcy5uYW1lLCAnb3B0aW9ucyc6IF9fY29udGV4dC52YWx1ZXMuc3VjY2Vzcy5vcHRpb25zLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3Mub25DaGFuZ2UgfSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdiJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1dhcm5pbmcnKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZHJvcF9saXN0X2ZpZWxkXzEuRHJvcExpc3RGaWVsZCh7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcuaWQgfSwgJ2NsYXNzTmFtZSc6ICctd2FybmluZycsICduYW1lJzogX19jb250ZXh0LnZhbHVlcy53YXJuaW5nLm5hbWUsICdvcHRpb25zJzogX19jb250ZXh0LnZhbHVlcy53YXJuaW5nLm9wdGlvbnMsICdvbkNoYW5nZSc6IF9fY29udGV4dC52YWx1ZXMud2FybmluZy5vbkNoYW5nZSB9LCBbXSksIHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMud2FybmluZy5pZCB9LCAnY2xhc3NOYW1lJzogJy13YXJuaW5nJywgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcubmFtZSwgJ29wdGlvbnMnOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcub3B0aW9ucywgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy53YXJuaW5nLm9uQ2hhbmdlIH0pXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnYicsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdFcnJvcicpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkcm9wX2xpc3RfZmllbGRfMS5Ecm9wTGlzdEZpZWxkKHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuZXJyb3IuaWQgfSwgJ2NsYXNzTmFtZSc6ICctZXJyb3InLCAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMuZXJyb3IubmFtZSwgJ29wdGlvbnMnOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLm9wdGlvbnMsICdvbkNoYW5nZSc6IF9fY29udGV4dC52YWx1ZXMuZXJyb3Iub25DaGFuZ2UgfSwgW10pLCB7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLmlkIH0sICdjbGFzc05hbWUnOiAnLWVycm9yJywgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLm5hbWUsICdvcHRpb25zJzogX19jb250ZXh0LnZhbHVlcy5lcnJvci5vcHRpb25zLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLm9uQ2hhbmdlIH0pXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnYicsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdEaXNhYmxlZCcpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkcm9wX2xpc3RfZmllbGRfMS5Ecm9wTGlzdEZpZWxkKHsgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5uYW1lLCAndmFsdWUnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC52YWx1ZSwgJ29wdGlvbnMnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5vcHRpb25zLCAnZGlzYWJsZWQnOiB0cnVlLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5vbkNoYW5nZSB9LCBbXSksIHsgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5uYW1lLCAndmFsdWUnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC52YWx1ZSwgJ29wdGlvbnMnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5vcHRpb25zLCAnZGlzYWJsZWQnOiB0cnVlLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5vbkNoYW5nZSB9KVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgIF0pLCB7fSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZHJvcC1saXN0LWZpZWxkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ecm9wTGlzdFBhZ2UgPSB2b2lkIDA7XG5jb25zdCB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9kcm9wLWxpc3RcIik7XG5jb25zdCByZXN1bHRzXzEgPSByZXF1aXJlKFwiLi4vLi4vZml4dHVyZXMvZGF0YS9yZXN1bHRzXCIpO1xuY29uc3Qgb3B0aW9ucyA9IHJlc3VsdHNfMS5yZXN1bHRzO1xuY2xhc3MgRHJvcExpc3RQYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgbm9ybWFsOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdub3JtYWwnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdub3JtYWwnLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnTm9ybWFsJyxcbiAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHRzXzEucmVzdWx0c1syXS52YWx1ZSxcbiAgICAgICAgICAgICAgICBvblNlbGVjdDogZG9TZWxlY3QodGhpcylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBibG9jazoge1xuICAgICAgICAgICAgICAgIGlkOiAnYmxvY2snLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdibG9jaycsXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdCbG9jaycsXG4gICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICBvblNlbGVjdDogZG9TZWxlY3QodGhpcylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdWNjZXNzOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnc3VjY2VzcycsXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdTdWNjZXNzJyxcbiAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdUaGlzIGhhcyBhIHN1Y2Nlc3MgbWVzc2FnZS4nLFxuICAgICAgICAgICAgICAgIG9uU2VsZWN0OiBkb1NlbGVjdCh0aGlzKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdhcm5pbmc6IHtcbiAgICAgICAgICAgICAgICBpZDogJ3dhcm5pbmcnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd3YXJuaW5nJyxcbiAgICAgICAgICAgICAgICBsYWJlbDogJ1dhcm5pbmcnLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1RoaXMgaGFzIGEgd2FybmluZyBtZXNzYWdlLicsXG4gICAgICAgICAgICAgICAgb25TZWxlY3Q6IGRvU2VsZWN0KHRoaXMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgICBpZDogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnRXJyb3InLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1RoaXMgaGFzIGEgZXJyb3IgbWVzc2FnZS4nLFxuICAgICAgICAgICAgICAgIG9uU2VsZWN0OiBkb1NlbGVjdCh0aGlzKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkRyb3BMaXN0UGFnZSA9IERyb3BMaXN0UGFnZTtcbmNvbnN0IGRvU2VsZWN0ID0gKHBhZ2UpID0+ICh7IG5hbWUsIHZhbHVlIH0pID0+IHBhZ2VcbiAgICAudmlld1xuICAgIC5maW5kQnlJZChuYW1lKVxuICAgIC5tYXAoKCkgPT4ge1xuICAgIGFsZXJ0KGBTZWxlY3RlZDogJHtuYW1lfT0ke3ZhbHVlfWApO1xufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgRHJvcExpc3RQYWdlKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWFpbiA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuY29uc3QgZGVtb18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3dpZGdldHMvZGVtb1wiKTtcbjtcbmNvbnN0IGRyb3BfbGlzdF8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9jb250cm9sL2Ryb3AtbGlzdFwiKTtcbjtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdiJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ05vcm1hbCcpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkcm9wX2xpc3RfMS5Ecm9wTGlzdCh7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5uYW1lIH0sICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwubmFtZSwgJ3ZhbHVlJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwudmFsdWUsICdvcHRpb25zJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwub3B0aW9ucywgJ29uU2VsZWN0JzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwub25TZWxlY3QgfSwgW10pLCB7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5uYW1lIH0sICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwubmFtZSwgJ3ZhbHVlJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwudmFsdWUsICdvcHRpb25zJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwub3B0aW9ucywgJ29uU2VsZWN0JzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwub25TZWxlY3QgfSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdiJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1N1Y2Nlc3MnKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZHJvcF9saXN0XzEuRHJvcExpc3QoeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5zdWNjZXNzLmlkIH0sICdjbGFzc05hbWUnOiAnLXN1Y2Nlc3MnLCAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMuc3VjY2Vzcy5uYW1lLCAnb3B0aW9ucyc6IF9fY29udGV4dC52YWx1ZXMuc3VjY2Vzcy5vcHRpb25zLCAnb25TZWxlY3QnOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3Mub25TZWxlY3QgfSwgW10pLCB7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3MuaWQgfSwgJ2NsYXNzTmFtZSc6ICctc3VjY2VzcycsICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5zdWNjZXNzLm5hbWUsICdvcHRpb25zJzogX19jb250ZXh0LnZhbHVlcy5zdWNjZXNzLm9wdGlvbnMsICdvblNlbGVjdCc6IF9fY29udGV4dC52YWx1ZXMuc3VjY2Vzcy5vblNlbGVjdCB9KVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2InLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnV2FybmluZycpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkcm9wX2xpc3RfMS5Ecm9wTGlzdCh7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcuaWQgfSwgJ2NsYXNzTmFtZSc6ICctd2FybmluZycsICduYW1lJzogX19jb250ZXh0LnZhbHVlcy53YXJuaW5nLm5hbWUsICdvcHRpb25zJzogX19jb250ZXh0LnZhbHVlcy53YXJuaW5nLm9wdGlvbnMsICdvblNlbGVjdCc6IF9fY29udGV4dC52YWx1ZXMud2FybmluZy5vblNlbGVjdCB9LCBbXSksIHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMud2FybmluZy5pZCB9LCAnY2xhc3NOYW1lJzogJy13YXJuaW5nJywgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcubmFtZSwgJ29wdGlvbnMnOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcub3B0aW9ucywgJ29uU2VsZWN0JzogX19jb250ZXh0LnZhbHVlcy53YXJuaW5nLm9uU2VsZWN0IH0pXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnYicsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdFcnJvcicpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkcm9wX2xpc3RfMS5Ecm9wTGlzdCh7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLmlkIH0sICdjbGFzc05hbWUnOiAnLWVycm9yJywgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLm5hbWUsICdvcHRpb25zJzogX19jb250ZXh0LnZhbHVlcy5lcnJvci5vcHRpb25zLCAnb25TZWxlY3QnOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLm9uU2VsZWN0IH0sIFtdKSwgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5lcnJvci5pZCB9LCAnY2xhc3NOYW1lJzogJy1lcnJvcicsICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5lcnJvci5uYW1lLCAnb3B0aW9ucyc6IF9fY29udGV4dC52YWx1ZXMuZXJyb3Iub3B0aW9ucywgJ29uU2VsZWN0JzogX19jb250ZXh0LnZhbHVlcy5lcnJvci5vblNlbGVjdCB9KVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2InLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ0Rpc2FibGVkJylcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZHJvcF9saXN0XzEuRHJvcExpc3QoeyAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMubm9ybWFsLm5hbWUsICdkaXNhYmxlZCc6IHRydWUsICdvblNlbGVjdCc6IF9fY29udGV4dC52YWx1ZXMubm9ybWFsLm9uU2VsZWN0IH0sIFtdKSwgeyAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMubm9ybWFsLm5hbWUsICdkaXNhYmxlZCc6IHRydWUsICdvblNlbGVjdCc6IF9fY29udGV4dC52YWx1ZXMubm9ybWFsLm9uU2VsZWN0IH0pXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnYicsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnQmxvY2snKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkcm9wX2xpc3RfMS5Ecm9wTGlzdCh7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmJsb2NrLmlkIH0sICdjbGFzc05hbWUnOiAnLWJsb2NrJywgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLmJsb2NrLm5hbWUsICdibG9jayc6IHRydWUsICdvblNlbGVjdCc6IF9fY29udGV4dC52YWx1ZXMuYmxvY2sub25TZWxlY3QgfSwgW10pLCB7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmJsb2NrLmlkIH0sICdjbGFzc05hbWUnOiAnLWJsb2NrJywgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLmJsb2NrLm5hbWUsICdibG9jayc6IHRydWUsICdvblNlbGVjdCc6IF9fY29udGV4dC52YWx1ZXMuYmxvY2sub25TZWxlY3QgfSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKSwge30pXG4gICAgICAgICAgICBdKSwge30pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRyb3AtbGlzdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRmlsZVVwbG9hZFN1cmZhY2VQYWdlID0gdm9pZCAwO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvZmlsZS11cGxvYWQtc3VyZmFjZVwiKTtcbmNsYXNzIEZpbGVVcGxvYWRTdXJmYWNlUGFnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHt9O1xuICAgIH1cbn1cbmV4cG9ydHMuRmlsZVVwbG9hZFN1cmZhY2VQYWdlID0gRmlsZVVwbG9hZFN1cmZhY2VQYWdlO1xuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IEZpbGVVcGxvYWRTdXJmYWNlUGFnZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1haW4gPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbmNvbnN0IGRlbW9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi93aWRnZXRzL2RlbW9cIik7XG47XG5jb25zdCBmaWxlX3VwbG9hZF9zdXJmYWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRyb2wvZmlsZS11cGxvYWQtc3VyZmFjZVwiKTtcbjtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGZpbGVfdXBsb2FkX3N1cmZhY2VfMS5GaWxlVXBsb2FkU3VyZmFjZSh7fSwgW10pLCB7fSlcbiAgICAgICAgICAgIF0pLCB7fSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsZS11cGxvYWQtc3VyZmFjZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW5wdXRHcm91cFBhZ2UgPSB2b2lkIDA7XG5jb25zdCB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9pbnB1dC1ncm91cFwiKTtcbmNvbnN0IHJlc3VsdHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9maXh0dXJlcy9kYXRhL3Jlc3VsdHNcIik7XG5jbGFzcyBJbnB1dEdyb3VwUGFnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGRyb3BMaXN0OiB7IG9wdGlvbnM6IHJlc3VsdHNfMS5yZXN1bHRzIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLklucHV0R3JvdXBQYWdlID0gSW5wdXRHcm91cFBhZ2U7XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgSW5wdXRHcm91cFBhZ2UoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYWluID0gdm9pZCAwO1xuY29uc3QgX19kb2N1bWVudCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbmNvbnN0IG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG5jb25zdCB0ZXh0X2lucHV0XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRyb2wvdGV4dC1pbnB1dFwiKTtcbjtcbmNvbnN0IGlucHV0X2dyb3VwXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRyb2wvaW5wdXQtZ3JvdXBcIik7XG47XG5jb25zdCBjaGVja2JveF8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9jb250cm9sL2NoZWNrYm94XCIpO1xuO1xuY29uc3QgYnV0dG9uXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRyb2wvYnV0dG9uXCIpO1xuO1xuY29uc3QgZHJvcF9kb3duXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRyb2wvZHJvcC1kb3duXCIpO1xuO1xuY29uc3QgZHJvcF9saXN0XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRyb2wvZHJvcC1saXN0XCIpO1xuO1xuY29uc3QgbWVudV8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9tZW51L21lbnVcIik7XG47XG5jb25zdCBpdGVtXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL21lbnUvaXRlbVwiKTtcbjtcbmNvbnN0IGRlbW9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi93aWRnZXRzL2RlbW9cIik7XG47XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBpbnB1dF9ncm91cF8xLklucHV0R3JvdXAoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBpbnB1dF9ncm91cF8xLkFkZE9uKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ2h0dHAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgdGV4dF9pbnB1dF8xLlRleHRJbnB1dCh7fSwgW10pLCB7fSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGlucHV0X2dyb3VwXzEuSW5wdXRHcm91cCh7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRleHRfaW5wdXRfMS5UZXh0SW5wdXQoe30sIFtdKSwge30pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGlucHV0X2dyb3VwXzEuQWRkT24oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnLmNvbScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSksIHt9KVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksIHt9KVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgaW5wdXRfZ3JvdXBfMS5JbnB1dEdyb3VwKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgaW5wdXRfZ3JvdXBfMS5BZGRPbih7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBjaGVja2JveF8xLkNoZWNrYm94KHt9LCBbXSksIHt9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgdGV4dF9pbnB1dF8xLlRleHRJbnB1dCh7fSwgW10pLCB7fSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGlucHV0X2dyb3VwXzEuSW5wdXRHcm91cCh7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRleHRfaW5wdXRfMS5UZXh0SW5wdXQoe30sIFtdKSwge30pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGlucHV0X2dyb3VwXzEuQWRkT24oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgY2hlY2tib3hfMS5DaGVja2JveCh7fSwgW10pLCB7fSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSwge30pXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSwge30pXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBpbnB1dF9ncm91cF8xLklucHV0R3JvdXAoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBpbnB1dF9ncm91cF8xLkFkZE9uKHsgJ2J1dHRvbic6IHRydWUgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBidXR0b25fMS5CdXR0b24oeyAndGV4dCc6ICdGaW5kJyB9LCBbXSksIHsgJ3RleHQnOiAnRmluZCcgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSwgeyAnYnV0dG9uJzogdHJ1ZSB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyB0ZXh0X2lucHV0XzEuVGV4dElucHV0KHt9LCBbXSksIHt9KVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksIHt9KVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgaW5wdXRfZ3JvdXBfMS5JbnB1dEdyb3VwKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgdGV4dF9pbnB1dF8xLlRleHRJbnB1dCh7fSwgW10pLCB7fSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgaW5wdXRfZ3JvdXBfMS5BZGRPbih7ICdidXR0b24nOiB0cnVlIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgYnV0dG9uXzEuQnV0dG9uKHsgJ3RleHQnOiAnRmluZCcgfSwgW10pLCB7ICd0ZXh0JzogJ0ZpbmQnIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSksIHsgJ2J1dHRvbic6IHRydWUgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGlucHV0X2dyb3VwXzEuSW5wdXRHcm91cCh7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGlucHV0X2dyb3VwXzEuQWRkT24oeyAnYnV0dG9uJzogdHJ1ZSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGRyb3BfZG93bl8xLkRyb3BEb3duKHsgJ2J1dHRvblRleHQnOiAnQ2xpY2sgTWUnIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IG1lbnVfMS5NZW51KHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgaXRlbV8xLkl0ZW0oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2EnLCB7ICdocmVmJzogJyMnIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ09uZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBpdGVtXzEuSXRlbSh7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnYScsIHsgJ2hyZWYnOiAnIycgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnVHdvJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGl0ZW1fMS5JdGVtKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdhJywgeyAnaHJlZic6ICcjJyB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdUaHJlZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSksIHt9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSksIHt9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSwgeyAnYnV0dG9uVGV4dCc6ICdDbGljayBNZScgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSwgeyAnYnV0dG9uJzogdHJ1ZSB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyB0ZXh0X2lucHV0XzEuVGV4dElucHV0KHt9LCBbXSksIHt9KVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksIHt9KVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgaW5wdXRfZ3JvdXBfMS5JbnB1dEdyb3VwKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgdGV4dF9pbnB1dF8xLlRleHRJbnB1dCh7fSwgW10pLCB7fSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgaW5wdXRfZ3JvdXBfMS5BZGRPbih7ICdidXR0b24nOiB0cnVlIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZHJvcF9kb3duXzEuRHJvcERvd24oeyAnYnV0dG9uVGV4dCc6ICdDbGljayBNZScgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgbWVudV8xLk1lbnUoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBpdGVtXzEuSXRlbSh7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnYScsIHsgJ2hyZWYnOiAnIycgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnT25lJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGl0ZW1fMS5JdGVtKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdhJywgeyAnaHJlZic6ICcjJyB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdUd28nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgaXRlbV8xLkl0ZW0oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2EnLCB7ICdocmVmJzogJyMnIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1RocmVlJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSwge30pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSwge30pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLCB7ICdidXR0b25UZXh0JzogJ0NsaWNrIE1lJyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLCB7ICdidXR0b24nOiB0cnVlIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSwge30pXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBpbnB1dF9ncm91cF8xLklucHV0R3JvdXAoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBpbnB1dF9ncm91cF8xLkFkZE9uKHsgJ2J1dHRvbic6IHRydWUgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkcm9wX2xpc3RfMS5Ecm9wTGlzdCh7ICdvcHRpb25zJzogX19jb250ZXh0LnZhbHVlcy5kcm9wTGlzdC5vcHRpb25zIH0sIFtdKSwgeyAnb3B0aW9ucyc6IF9fY29udGV4dC52YWx1ZXMuZHJvcExpc3Qub3B0aW9ucyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLCB7ICdidXR0b24nOiB0cnVlIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRleHRfaW5wdXRfMS5UZXh0SW5wdXQoe30sIFtdKSwge30pXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSwge30pXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSksIHt9KVxuICAgICAgICAgICAgXSksIHt9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnB1dC1ncm91cC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTXVsdGlTZWxlY3RQYWdlID0gdm9pZCAwO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvbXVsdGktc2VsZWN0XCIpO1xuY29uc3QgcmVzdWx0c18xID0gcmVxdWlyZShcIi4uLy4uL2ZpeHR1cmVzL2RhdGEvcmVzdWx0c1wiKTtcbmNsYXNzIE11bHRpU2VsZWN0UGFnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIG5vcm1hbDoge1xuICAgICAgICAgICAgICAgIGlkOiAnbm9ybWFsJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnbm9ybWFsJyxcbiAgICAgICAgICAgICAgICBsYWJlbDogJ05vcm1hbCcsXG4gICAgICAgICAgICAgICAgc3RyaW5naWZpZXI6IChyKSA9PiByLnZhbHVlLFxuICAgICAgICAgICAgICAgIG9uU2VhcmNoOiBvblNlYXJjaCh0aGlzKSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogb25DaGFuZ2UodGhpcyksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3VjY2Vzczoge1xuICAgICAgICAgICAgICAgIGlkOiAnc3VjY2VzcycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3N1Y2Nlc3MnLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnU3VjY2VzcycsXG4gICAgICAgICAgICAgICAgc3RyaW5naWZpZXI6IChyKSA9PiByLnZhbHVlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdUaGlzIGhhcyBhIHN1Y2Nlc3MgbWVzc2FnZS4nLFxuICAgICAgICAgICAgICAgIG9uU2VhcmNoOiBvblNlYXJjaCh0aGlzKSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogb25DaGFuZ2UodGhpcyksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd2FybmluZzoge1xuICAgICAgICAgICAgICAgIGlkOiAnd2FybmluZycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3dhcm5pbmcnLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnV2FybmluZycsXG4gICAgICAgICAgICAgICAgc3RyaW5naWZpZXI6IChyKSA9PiByLnZhbHVlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdUaGlzIGhhcyBhIHdhcm5pbmcgbWVzc2FnZS4nLFxuICAgICAgICAgICAgICAgIG9uU2VhcmNoOiBvblNlYXJjaCh0aGlzKSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogb25DaGFuZ2UodGhpcyksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgICBpZDogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnRXJyb3InLFxuICAgICAgICAgICAgICAgIHN0cmluZ2lmaWVyOiAocikgPT4gci52YWx1ZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnVGhpcyBoYXMgYSBlcnJvciBtZXNzYWdlLicsXG4gICAgICAgICAgICAgICAgb25TZWFyY2g6IG9uU2VhcmNoKHRoaXMpLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBvbkNoYW5nZSh0aGlzKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBibG9jazoge1xuICAgICAgICAgICAgICAgIGlkOiAnYmxvY2snLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdibG9jaycsXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdCbG9jaycsXG4gICAgICAgICAgICAgICAgc3RyaW5naWZpZXI6IChyKSA9PiByLnZhbHVlLFxuICAgICAgICAgICAgICAgIG9uU2VhcmNoOiBvblNlYXJjaCh0aGlzKSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogb25DaGFuZ2UodGhpcyksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5pdDoge1xuICAgICAgICAgICAgICAgIGlkOiAnaW5pdCcsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2luaXQnLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnSW5pdCcsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdHNfMS5yZXN1bHRzLFxuICAgICAgICAgICAgICAgIHN0cmluZ2lmaWVyOiAocikgPT4gci52YWx1ZSxcbiAgICAgICAgICAgICAgICBvblNlYXJjaDogb25TZWFyY2godGhpcyksXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6IG9uQ2hhbmdlKHRoaXMpLFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuTXVsdGlTZWxlY3RQYWdlID0gTXVsdGlTZWxlY3RQYWdlO1xuY29uc3Qgb25TZWFyY2ggPSAocGFnZSkgPT4gKHsgbmFtZSwgdmFsdWUgfSkgPT4gcGFnZVxuICAgIC52aWV3XG4gICAgLmZpbmRCeUlkKG5hbWUpXG4gICAgLm1hcCgocykgPT4ge1xuICAgIGxldCBoaXQgPSByZXN1bHRzXzEucmVzdWx0cy5maWx0ZXIoYyA9PiBjLnZhbHVlLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCh2YWx1ZSkgPyB0cnVlIDogZmFsc2UpO1xuICAgIHMudXBkYXRlKGhpdCk7XG59KTtcbmNvbnN0IG9uQ2hhbmdlID0gKHBhZ2UpID0+ICh7IG5hbWUsIHZhbHVlIH0pID0+IHBhZ2VcbiAgICAudmlld1xuICAgIC5maW5kQnlJZChuYW1lKVxuICAgIC5tYXAodCA9PiB7XG4gICAgdC5zZXRNZXNzYWdlKGBDb3VudDogJHt2YWx1ZS5sZW5ndGh9YCk7XG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBNdWx0aVNlbGVjdFBhZ2UoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYWluID0gdm9pZCAwO1xuY29uc3QgX19kb2N1bWVudCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbmNvbnN0IG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG5jb25zdCBkZW1vXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vd2lkZ2V0cy9kZW1vXCIpO1xuO1xuY29uc3QgbXVsdGlfc2VsZWN0XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRyb2wvbXVsdGktc2VsZWN0XCIpO1xuO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9faWYgPSAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpID0+IChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0ID8gX19hbHQoKSA6IFtdO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9ySW4gPSAobGlzdCwgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2Zvck9mID0gKG8sIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHRleHQgPSBfX2RvY3VtZW50LnRleHQ7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHVuc2FmZSA9IF9fZG9jdW1lbnQudW5zYWZlO1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCBpc1NldCA9ICh2YWx1ZSkgPT4gdmFsdWUgIT0gbnVsbDtcbmNsYXNzIE1haW4ge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgbXVsdGlfc2VsZWN0XzEuTXVsdGlTZWxlY3QoeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwuaWQgfSwgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5uYW1lLCAnbGFiZWwnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5sYWJlbCwgJ3N0cmluZ2lmaWVyJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwuc3RyaW5naWZpZXIsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMubm9ybWFsLm9uU2VhcmNoLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5vbkNoYW5nZSB9LCBbXSksIHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMubm9ybWFsLmlkIH0sICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwubmFtZSwgJ2xhYmVsJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwubGFiZWwsICdzdHJpbmdpZmllcic6IF9fY29udGV4dC52YWx1ZXMubm9ybWFsLnN0cmluZ2lmaWVyLCAnb25TZWFyY2gnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5vblNlYXJjaCwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwub25DaGFuZ2UgfSlcbiAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IG11bHRpX3NlbGVjdF8xLk11bHRpU2VsZWN0KHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuc3VjY2Vzcy5pZCB9LCAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMuc3VjY2Vzcy5uYW1lLCAnbGFiZWwnOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3MubGFiZWwsICdzdWNjZXNzJzogX19jb250ZXh0LnZhbHVlcy5zdWNjZXNzLm1lc3NhZ2UsICdzdHJpbmdpZmllcic6IF9fY29udGV4dC52YWx1ZXMuc3VjY2Vzcy5zdHJpbmdpZmllciwgJ29uU2VhcmNoJzogX19jb250ZXh0LnZhbHVlcy5zdWNjZXNzLm9uU2VhcmNoLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3Mub25DaGFuZ2UgfSwgW10pLCB7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3MuaWQgfSwgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3MubmFtZSwgJ2xhYmVsJzogX19jb250ZXh0LnZhbHVlcy5zdWNjZXNzLmxhYmVsLCAnc3VjY2Vzcyc6IF9fY29udGV4dC52YWx1ZXMuc3VjY2Vzcy5tZXNzYWdlLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3Muc3RyaW5naWZpZXIsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMuc3VjY2Vzcy5vblNlYXJjaCwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5zdWNjZXNzLm9uQ2hhbmdlIH0pXG4gICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBtdWx0aV9zZWxlY3RfMS5NdWx0aVNlbGVjdCh7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcuaWQgfSwgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcubmFtZSwgJ2xhYmVsJzogX19jb250ZXh0LnZhbHVlcy53YXJuaW5nLmxhYmVsLCAnd2FybmluZyc6IF9fY29udGV4dC52YWx1ZXMud2FybmluZy5tZXNzYWdlLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcuc3RyaW5naWZpZXIsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMud2FybmluZy5vblNlYXJjaCwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy53YXJuaW5nLm9uQ2hhbmdlIH0sIFtdKSwgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy53YXJuaW5nLmlkIH0sICduYW1lJzogX19jb250ZXh0LnZhbHVlcy53YXJuaW5nLm5hbWUsICdsYWJlbCc6IF9fY29udGV4dC52YWx1ZXMud2FybmluZy5sYWJlbCwgJ3dhcm5pbmcnOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcubWVzc2FnZSwgJ3N0cmluZ2lmaWVyJzogX19jb250ZXh0LnZhbHVlcy53YXJuaW5nLnN0cmluZ2lmaWVyLCAnb25TZWFyY2gnOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcub25TZWFyY2gsICdvbkNoYW5nZSc6IF9fY29udGV4dC52YWx1ZXMud2FybmluZy5vbkNoYW5nZSB9KVxuICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgbXVsdGlfc2VsZWN0XzEuTXVsdGlTZWxlY3QoeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5lcnJvci5pZCB9LCAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMuZXJyb3IubmFtZSwgJ2xhYmVsJzogX19jb250ZXh0LnZhbHVlcy5lcnJvci5sYWJlbCwgJ2Vycm9yJzogX19jb250ZXh0LnZhbHVlcy5lcnJvci5tZXNzYWdlLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLnN0cmluZ2lmaWVyLCAnb25TZWFyY2gnOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLm9uU2VhcmNoLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLm9uQ2hhbmdlIH0sIFtdKSwgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5lcnJvci5pZCB9LCAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMuZXJyb3IubmFtZSwgJ2xhYmVsJzogX19jb250ZXh0LnZhbHVlcy5lcnJvci5sYWJlbCwgJ2Vycm9yJzogX19jb250ZXh0LnZhbHVlcy5lcnJvci5tZXNzYWdlLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLnN0cmluZ2lmaWVyLCAnb25TZWFyY2gnOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLm9uU2VhcmNoLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLm9uQ2hhbmdlIH0pXG4gICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBtdWx0aV9zZWxlY3RfMS5NdWx0aVNlbGVjdCh7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmJsb2NrLmlkIH0sICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5ibG9jay5uYW1lLCAnbGFiZWwnOiBfX2NvbnRleHQudmFsdWVzLmJsb2NrLmxhYmVsLCAnYmxvY2snOiB0cnVlLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLmJsb2NrLnN0cmluZ2lmaWVyLCAnb25TZWFyY2gnOiBfX2NvbnRleHQudmFsdWVzLmJsb2NrLm9uU2VhcmNoLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLmJsb2NrLm9uQ2hhbmdlIH0sIFtdKSwgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5ibG9jay5pZCB9LCAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMuYmxvY2submFtZSwgJ2xhYmVsJzogX19jb250ZXh0LnZhbHVlcy5ibG9jay5sYWJlbCwgJ2Jsb2NrJzogdHJ1ZSwgJ3N0cmluZ2lmaWVyJzogX19jb250ZXh0LnZhbHVlcy5ibG9jay5zdHJpbmdpZmllciwgJ29uU2VhcmNoJzogX19jb250ZXh0LnZhbHVlcy5ibG9jay5vblNlYXJjaCwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5ibG9jay5vbkNoYW5nZSB9KVxuICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgbXVsdGlfc2VsZWN0XzEuTXVsdGlTZWxlY3QoeyAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMubm9ybWFsLm5hbWUsICdsYWJlbCc6ICdEaXNhYmxlZCcsICdkaXNhYmxlZCc6IHRydWUsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMubm9ybWFsLm9uU2VhcmNoLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5vbkNoYW5nZSB9LCBbXSksIHsgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5uYW1lLCAnbGFiZWwnOiAnRGlzYWJsZWQnLCAnZGlzYWJsZWQnOiB0cnVlLCAnb25TZWFyY2gnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5vblNlYXJjaCwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwub25DaGFuZ2UgfSlcbiAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IG11bHRpX3NlbGVjdF8xLk11bHRpU2VsZWN0KHsgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLmluaXQubmFtZSwgJ2xhYmVsJzogJ0luaXRpYWxpemVkJywgJ3ZhbHVlJzogX19jb250ZXh0LnZhbHVlcy5pbml0LnZhbHVlLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLmluaXQuc3RyaW5naWZpZXIsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMuaW5pdC5vblNlYXJjaCwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5pbml0Lm9uQ2hhbmdlIH0sIFtdKSwgeyAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMuaW5pdC5uYW1lLCAnbGFiZWwnOiAnSW5pdGlhbGl6ZWQnLCAndmFsdWUnOiBfX2NvbnRleHQudmFsdWVzLmluaXQudmFsdWUsICdzdHJpbmdpZmllcic6IF9fY29udGV4dC52YWx1ZXMuaW5pdC5zdHJpbmdpZmllciwgJ29uU2VhcmNoJzogX19jb250ZXh0LnZhbHVlcy5pbml0Lm9uU2VhcmNoLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLmluaXQub25DaGFuZ2UgfSlcbiAgICAgICAgICAgICAgICBdKSwge30pXG4gICAgICAgICAgICBdKSwge30pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11bHRpLXNlbGVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGFnZXJQYWdlID0gdm9pZCAwO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi9wYWdlclwiKTtcbmNvbnN0IHNjZW5lcyA9IFtcbiAgICAnUGFnZSAxJyxcbiAgICAnUGFnZSAyJyxcbiAgICAnUGFnZSAzJyxcbiAgICAnUGFnZSA0JyxcbiAgICAnUGFnZSA1JyxcbiAgICAnUGFnZSA2JyxcbiAgICAnUGFnZSA3JyxcbiAgICAnUGFnZSA4JyxcbiAgICAnUGFnZSA5JyxcbiAgICAnUGFnZSAxMCdcbl07XG5jbGFzcyBQYWdlclBhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbih0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBtZXNzYWdlOiBzY2VuZXNbMF0sXG4gICAgICAgICAgICB0b3RhbDogc2NlbmVzLmxlbmd0aCxcbiAgICAgICAgICAgIGN1cnJlbnQ6IDEsXG4gICAgICAgICAgICBvbkNoYW5nZTogKGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcy5jdXJyZW50ID0gZS52YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcy5tZXNzYWdlID0gc2NlbmVzW3RoaXMudmFsdWVzLmN1cnJlbnQgLSAxXTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuaW52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuUGFnZXJQYWdlID0gUGFnZXJQYWdlO1xuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IFBhZ2VyUGFnZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1haW4gPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbmNvbnN0IGdyaWRfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi9saWIvbGF5b3V0L2dyaWRcIik7XG47XG5jb25zdCBkZW1vXzEgPSByZXF1aXJlKFwiLi4vLi4vd2lkZ2V0cy9kZW1vXCIpO1xuO1xuY29uc3QgcGFnZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi9saWIvY29udHJvbC9wYWdlclwiKTtcbjtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGdyaWRfMS5Sb3coe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZ3JpZF8xLkNvbHVtbih7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQoX19jb250ZXh0LnZhbHVlcy5tZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgXSksIHt9KVxuICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZ3JpZF8xLlJvdyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBncmlkXzEuQ29sdW1uKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBwYWdlcl8xLlBhZ2VyKHsgJ3RvdGFsJzogX19jb250ZXh0LnZhbHVlcy50b3RhbCwgJ2N1cnJlbnQnOiBfX2NvbnRleHQudmFsdWVzLmN1cnJlbnQsICdvbkNoYW5nZSc6IF9fY29udGV4dC52YWx1ZXMub25DaGFuZ2UgfSwgW10pLCB7ICd0b3RhbCc6IF9fY29udGV4dC52YWx1ZXMudG90YWwsICdjdXJyZW50JzogX19jb250ZXh0LnZhbHVlcy5jdXJyZW50LCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLm9uQ2hhbmdlIH0pXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgICAgICBdKSwge30pXG4gICAgICAgICAgICBdKSwge30pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhZ2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QYWdpbmF0b3JQYWdlID0gdm9pZCAwO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvcGFnaW5hdG9yXCIpO1xuY29uc3Qgc2NlbmVzID0gW1xuICAgICdQYWdlIDEnLFxuICAgICdQYWdlIDInLFxuICAgICdQYWdlIDMnLFxuICAgICdQYWdlIDQnLFxuICAgICdQYWdlIDUnLFxuICAgICdQYWdlIDYnLFxuICAgICdQYWdlIDcnLFxuICAgICdQYWdlIDgnLFxuICAgICdQYWdlIDknLFxuICAgICdQYWdlIDEwJ1xuXTtcbmNsYXNzIFBhZ2luYXRvclBhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbih0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBtZXNzYWdlOiBzY2VuZXNbMF0sXG4gICAgICAgICAgICBjdXJyZW50OiAxLFxuICAgICAgICAgICAgdG90YWw6IHNjZW5lcy5sZW5ndGgsXG4gICAgICAgICAgICBvbkNoYW5nZTogKGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcy5tZXNzYWdlID0gc2NlbmVzW2UudmFsdWUgLSAxXTtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcy5jdXJyZW50ID0gZS52YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuaW52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuUGFnaW5hdG9yUGFnZSA9IFBhZ2luYXRvclBhZ2U7XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgUGFnaW5hdG9yUGFnZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1haW4gPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbmNvbnN0IGRlbW9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi93aWRnZXRzL2RlbW9cIik7XG47XG5jb25zdCBwYWdpbmF0b3JfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvY29udHJvbC9wYWdpbmF0b3JcIik7XG47XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBwYWdpbmF0b3JfMS5QYWdpbmF0b3IoeyAndG90YWwnOiBfX2NvbnRleHQudmFsdWVzLnRvdGFsLCAnY3VycmVudCc6IF9fY29udGV4dC52YWx1ZXMuY3VycmVudCwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5vbkNoYW5nZSB9LCBbXSksIHsgJ3RvdGFsJzogX19jb250ZXh0LnZhbHVlcy50b3RhbCwgJ2N1cnJlbnQnOiBfX2NvbnRleHQudmFsdWVzLmN1cnJlbnQsICdvbkNoYW5nZSc6IF9fY29udGV4dC52YWx1ZXMub25DaGFuZ2UgfSksXG4gICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICB0ZXh0KF9fY29udGV4dC52YWx1ZXMubWVzc2FnZSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSksIHt9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWdpbmF0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJhbmdlZFBhZ2VyUGFnZSA9IHZvaWQgMDtcbmNvbnN0IHZpZXdzID0gcmVxdWlyZShcIi4vdmlld3NcIik7XG5jb25zdCBhcnJheV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL2FycmF5XCIpO1xuY29uc3Qgc2NlbmVzID0gW1xuICAgICdQYWdlIDEnLFxuICAgICdQYWdlIDInLFxuICAgICdQYWdlIDMnLFxuICAgICdQYWdlIDQnLFxuICAgICdQYWdlIDUnLFxuICAgICdQYWdlIDYnLFxuICAgICdQYWdlIDcnLFxuICAgICdQYWdlIDgnLFxuICAgICdQYWdlIDknLFxuICAgICdQYWdlIDEwJ1xuXTtcbmNsYXNzIFJhbmdlZFBhZ2VyUGFnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHNjZW5lczogc2NlbmVzLFxuICAgICAgICAgICAgbWVzc2FnZTogc2NlbmVzWzBdLFxuICAgICAgICAgICAgbWF4OiBzY2VuZXMubGVuZ3RoLFxuICAgICAgICAgICAgdG90YWw6IHNjZW5lcy5sZW5ndGgsXG4gICAgICAgICAgICBjdXJyZW50OiAxLFxuICAgICAgICAgICAgb25BdHRyQ2hhbmdlOiAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzW2UubmFtZV0gPSBOdW1iZXIoZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGUubmFtZSA9PT0gJ3RvdGFsJylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZXMuc2NlbmVzID0gKDAsIGFycmF5XzEubWFrZSkoTnVtYmVyKGUudmFsdWUpLCBpID0+IGBQYWdlICR7aX1gKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkNoYW5nZTogKGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcy5jdXJyZW50ID0gZS52YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcy5tZXNzYWdlID0gdGhpcy52YWx1ZXMuc2NlbmVzW3RoaXMudmFsdWVzLmN1cnJlbnQgLSAxXTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuaW52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc2V0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LmludmFsaWRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlJhbmdlZFBhZ2VyUGFnZSA9IFJhbmdlZFBhZ2VyUGFnZTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBSYW5nZWRQYWdlclBhZ2UoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYWluID0gdm9pZCAwO1xuY29uc3QgX19kb2N1bWVudCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbmNvbnN0IG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG5jb25zdCBncmlkXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbGliL2xheW91dC9ncmlkXCIpO1xuO1xuY29uc3QgdGV4dF9pbnB1dF8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL2xpYi9jb250cm9sL3RleHQtaW5wdXRcIik7XG47XG5jb25zdCByYW5nZWRfcGFnZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi9saWIvY29udHJvbC9yYW5nZWQtcGFnZXJcIik7XG47XG5jb25zdCBidXR0b25fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi9saWIvY29udHJvbC9idXR0b25cIik7XG47XG5jb25zdCBzaXplXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRlbnQvc2l6ZVwiKTtcbjtcbmNvbnN0IGRlbW9fMSA9IHJlcXVpcmUoXCIuLi8uLi93aWRnZXRzL2RlbW9cIik7XG47XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBncmlkXzEuUm93KHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGdyaWRfMS5Db2x1bW4oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdoMycsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnVXNlIHRoZSBjb250cm9scyBiZWxvdyB0byBjb25maWd1cmUgYXR0cmlidXRlcy4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnXFx1MDAwYSAgICAgICAgTWF4OiBcXHUwMDBhICAgICAgICBcXHUwMDBhICAgICAgICAnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyB0ZXh0X2lucHV0XzEuVGV4dElucHV0KHsgJ3NpemUnOiBzaXplXzEuU2l6ZS5TbWFsbCwgJ25hbWUnOiAnbWF4JywgJ3ZhbHVlJzogU3RyaW5nKF9fY29udGV4dC52YWx1ZXMubWF4KSwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5vbkF0dHJDaGFuZ2UgfSwgW10pLCB7ICdzaXplJzogc2l6ZV8xLlNpemUuU21hbGwsICduYW1lJzogJ21heCcsICd2YWx1ZSc6IFN0cmluZyhfX2NvbnRleHQudmFsdWVzLm1heCksICdvbkNoYW5nZSc6IF9fY29udGV4dC52YWx1ZXMub25BdHRyQ2hhbmdlIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1xcdTAwMGFcXHUwMDBhICAgICAgICBUb3RhbDpcXHUwMDBhXFx1MDAwYSAgICAgICAgJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgdGV4dF9pbnB1dF8xLlRleHRJbnB1dCh7ICdzaXplJzogc2l6ZV8xLlNpemUuU21hbGwsICduYW1lJzogJ3RvdGFsJywgJ3ZhbHVlJzogU3RyaW5nKF9fY29udGV4dC52YWx1ZXMudG90YWwpLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLm9uQXR0ckNoYW5nZSB9LCBbXSksIHsgJ3NpemUnOiBzaXplXzEuU2l6ZS5TbWFsbCwgJ25hbWUnOiAndG90YWwnLCAndmFsdWUnOiBTdHJpbmcoX19jb250ZXh0LnZhbHVlcy50b3RhbCksICdvbkNoYW5nZSc6IF9fY29udGV4dC52YWx1ZXMub25BdHRyQ2hhbmdlIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1xcdTAwMGFcXHUwMDBhICAgICAgICBDdXJyZW50OlxcdTAwMGFcXHUwMDBhICAgICAgICAnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyB0ZXh0X2lucHV0XzEuVGV4dElucHV0KHsgJ3NpemUnOiBzaXplXzEuU2l6ZS5TbWFsbCwgJ25hbWUnOiAnY3VycmVudCcsICd2YWx1ZSc6IFN0cmluZyhfX2NvbnRleHQudmFsdWVzLmN1cnJlbnQpLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLm9uQXR0ckNoYW5nZSB9LCBbXSksIHsgJ3NpemUnOiBzaXplXzEuU2l6ZS5TbWFsbCwgJ25hbWUnOiAnY3VycmVudCcsICd2YWx1ZSc6IFN0cmluZyhfX2NvbnRleHQudmFsdWVzLmN1cnJlbnQpLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLm9uQXR0ckNoYW5nZSB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBidXR0b25fMS5CdXR0b24oeyAndGV4dCc6ICdHbycsICdvbkNsaWNrJzogX19jb250ZXh0LnZhbHVlcy5yZXNldCB9LCBbXSksIHsgJ3RleHQnOiAnR28nLCAnb25DbGljayc6IF9fY29udGV4dC52YWx1ZXMucmVzZXQgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGdyaWRfMS5Sb3coe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZ3JpZF8xLkNvbHVtbih7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQoX19jb250ZXh0LnZhbHVlcy5tZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgXSksIHt9KVxuICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZ3JpZF8xLlJvdyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBncmlkXzEuQ29sdW1uKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyByYW5nZWRfcGFnZXJfMS5SYW5nZWRQYWdlcih7ICdtYXgnOiBfX2NvbnRleHQudmFsdWVzLm1heCwgJ3RvdGFsJzogX19jb250ZXh0LnZhbHVlcy50b3RhbCwgJ2N1cnJlbnQnOiBfX2NvbnRleHQudmFsdWVzLmN1cnJlbnQsICdvbkNoYW5nZSc6IF9fY29udGV4dC52YWx1ZXMub25DaGFuZ2UgfSwgW10pLCB7ICdtYXgnOiBfX2NvbnRleHQudmFsdWVzLm1heCwgJ3RvdGFsJzogX19jb250ZXh0LnZhbHVlcy50b3RhbCwgJ2N1cnJlbnQnOiBfX2NvbnRleHQudmFsdWVzLmN1cnJlbnQsICdvbkNoYW5nZSc6IF9fY29udGV4dC52YWx1ZXMub25DaGFuZ2UgfSlcbiAgICAgICAgICAgICAgICAgICAgXSksIHt9KVxuICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgIF0pLCB7fSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlld3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNlYXJjaFBhZ2UgPSB2b2lkIDA7XG5jb25zdCB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9zZWFyY2hcIik7XG5jb25zdCByZXN1bHRzXzEgPSByZXF1aXJlKFwiLi4vLi4vZml4dHVyZXMvZGF0YS9yZXN1bHRzXCIpO1xuY2xhc3MgU2VhcmNoUGFnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiAnc2VhcmNoJyxcbiAgICAgICAgICAgIG5hbWU6ICdzZWFyY2gnLFxuICAgICAgICAgICAgaWQyOiAnc2VhcmNoMicsXG4gICAgICAgICAgICBuYW1lMjogJ3NlYXJjaDInLFxuICAgICAgICAgICAgc3RyaW5naWZpZXI6IChyKSA9PiByLnZhbHVlLFxuICAgICAgICAgICAgb25TZWFyY2g6IG9uU2VhcmNoKHRoaXMpLFxuICAgICAgICAgICAgb25TZWxlY3Q6IG9uU2VsZWN0LFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuU2VhcmNoUGFnZSA9IFNlYXJjaFBhZ2U7XG5jb25zdCBvblNlYXJjaCA9IChwYWdlKSA9PiAoeyBuYW1lLCB2YWx1ZSB9KSA9PiBwYWdlXG4gICAgLnZpZXdcbiAgICAuZmluZEJ5SWQobmFtZSlcbiAgICAubWFwKChzKSA9PiB7XG4gICAgbGV0IGhpdCA9IHJlc3VsdHNfMS5yZXN1bHRzLmZpbHRlcihjID0+IGMudmFsdWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKHZhbHVlLnRvTG93ZXJDYXNlKCkpID8gdHJ1ZSA6IGZhbHNlKTtcbiAgICBzLnVwZGF0ZShoaXQpO1xufSk7XG5jb25zdCBvblNlbGVjdCA9ICh7IHZhbHVlIH0pID0+IGFsZXJ0KGBTZWxlY3RlZCBcIiR7dmFsdWUudmFsdWV9XCJgKTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBTZWFyY2hQYWdlKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWFpbiA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuY29uc3QgZGVtb18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3dpZGdldHMvZGVtb1wiKTtcbjtcbmNvbnN0IHNlYXJjaF8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9jb250cm9sL3NlYXJjaFwiKTtcbjtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHNlYXJjaF8xLlNlYXJjaCh7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmlkIH0sICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5uYW1lLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLnN0cmluZ2lmaWVyLCAnb25TZWFyY2gnOiBfX2NvbnRleHQudmFsdWVzLm9uU2VhcmNoLCAnb25TZWxlY3QnOiBfX2NvbnRleHQudmFsdWVzLm9uU2VsZWN0IH0sIFtdKSwgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pZCB9LCAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMubmFtZSwgJ3N0cmluZ2lmaWVyJzogX19jb250ZXh0LnZhbHVlcy5zdHJpbmdpZmllciwgJ29uU2VhcmNoJzogX19jb250ZXh0LnZhbHVlcy5vblNlYXJjaCwgJ29uU2VsZWN0JzogX19jb250ZXh0LnZhbHVlcy5vblNlbGVjdCB9KVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgc2VhcmNoXzEuU2VhcmNoKHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuaWQyIH0sICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5uYW1lMiwgJ2Jsb2NrJzogdHJ1ZSwgJ3N0cmluZ2lmaWVyJzogX19jb250ZXh0LnZhbHVlcy5zdHJpbmdpZmllciwgJ29uU2VhcmNoJzogX19jb250ZXh0LnZhbHVlcy5vblNlYXJjaCwgJ29uU2VsZWN0JzogX19jb250ZXh0LnZhbHVlcy5vblNlbGVjdCB9LCBbXSksIHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuaWQyIH0sICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5uYW1lMiwgJ2Jsb2NrJzogdHJ1ZSwgJ3N0cmluZ2lmaWVyJzogX19jb250ZXh0LnZhbHVlcy5zdHJpbmdpZmllciwgJ29uU2VhcmNoJzogX19jb250ZXh0LnZhbHVlcy5vblNlYXJjaCwgJ29uU2VsZWN0JzogX19jb250ZXh0LnZhbHVlcy5vblNlbGVjdCB9KVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2gyJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJyBEaXNhYmxlZCAnKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgc2VhcmNoXzEuU2VhcmNoKHsgJ2Rpc2FibGVkJzogdHJ1ZSwgJ3N0cmluZ2lmaWVyJzogX19jb250ZXh0LnZhbHVlcy5zdHJpbmdpZmllciwgJ29uU2VhcmNoJzogX19jb250ZXh0LnZhbHVlcy5vblNlYXJjaCwgJ29uU2VsZWN0JzogX19jb250ZXh0LnZhbHVlcy5vblNlbGVjdCB9LCBbXSksIHsgJ2Rpc2FibGVkJzogdHJ1ZSwgJ3N0cmluZ2lmaWVyJzogX19jb250ZXh0LnZhbHVlcy5zdHJpbmdpZmllciwgJ29uU2VhcmNoJzogX19jb250ZXh0LnZhbHVlcy5vblNlYXJjaCwgJ29uU2VsZWN0JzogX19jb250ZXh0LnZhbHVlcy5vblNlbGVjdCB9KVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgIF0pLCB7fSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VhcmNoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TZWxlY3RQYWdlID0gdm9pZCAwO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvc2VsZWN0XCIpO1xuY29uc3QgcmVzdWx0c18xID0gcmVxdWlyZShcIi4uLy4uL2ZpeHR1cmVzL2RhdGEvcmVzdWx0c1wiKTtcbmNsYXNzIFNlbGVjdFBhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbih0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBub3JtYWw6IHtcbiAgICAgICAgICAgICAgICBpZDogJ25vcm1hbCcsXG4gICAgICAgICAgICAgICAgbmFtZTogJ25vcm1hbCcsXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdOb3JtYWwnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHRzXzEucmVzdWx0c1syXSxcbiAgICAgICAgICAgICAgICBzdHJpbmdpZmllcjogKHIpID0+IHIudmFsdWUsXG4gICAgICAgICAgICAgICAgb25TZWFyY2g6IGRvU2VhcmNoKHRoaXMpLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBkb0NoYW5nZSh0aGlzKSxcbiAgICAgICAgICAgICAgICBvblVuc2V0OiBkb1Vuc2V0KHRoaXMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmxvY2s6IHtcbiAgICAgICAgICAgICAgICBpZDogJ2Jsb2NrJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnYmxvY2snLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnQmxvY2snLFxuICAgICAgICAgICAgICAgIHN0cmluZ2lmaWVyOiAocikgPT4gci52YWx1ZSxcbiAgICAgICAgICAgICAgICBvblNlYXJjaDogZG9TZWFyY2godGhpcyksXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6IGRvQ2hhbmdlKHRoaXMpLFxuICAgICAgICAgICAgICAgIG9uVW5zZXQ6IGRvVW5zZXQodGhpcylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdWNjZXNzOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnc3VjY2VzcycsXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdTdWNjZXNzJyxcbiAgICAgICAgICAgICAgICBzdHJpbmdpZmllcjogKHIpID0+IHIudmFsdWUsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1RoaXMgaGFzIGEgc3VjY2VzcyBtZXNzYWdlLicsXG4gICAgICAgICAgICAgICAgb25TZWFyY2g6IGRvU2VhcmNoKHRoaXMpLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBkb0NoYW5nZSh0aGlzKSxcbiAgICAgICAgICAgICAgICBvblVuc2V0OiBkb1Vuc2V0KHRoaXMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd2FybmluZzoge1xuICAgICAgICAgICAgICAgIGlkOiAnd2FybmluZycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3dhcm5pbmcnLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnV2FybmluZycsXG4gICAgICAgICAgICAgICAgc3RyaW5naWZpZXI6IChyKSA9PiByLnZhbHVlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdUaGlzIGhhcyBhIHdhcm5pbmcgbWVzc2FnZS4nLFxuICAgICAgICAgICAgICAgIG9uU2VhcmNoOiBkb1NlYXJjaCh0aGlzKSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogZG9DaGFuZ2UodGhpcyksXG4gICAgICAgICAgICAgICAgb25VbnNldDogZG9VbnNldCh0aGlzKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICBsYWJlbDogJ0Vycm9yJyxcbiAgICAgICAgICAgICAgICBzdHJpbmdpZmllcjogKHIpID0+IHIudmFsdWUsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1RoaXMgaGFzIGEgZXJyb3IgbWVzc2FnZS4nLFxuICAgICAgICAgICAgICAgIG9uU2VhcmNoOiBkb1NlYXJjaCh0aGlzKSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogZG9DaGFuZ2UodGhpcyksXG4gICAgICAgICAgICAgICAgb25VbnNldDogZG9VbnNldCh0aGlzKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlNlbGVjdFBhZ2UgPSBTZWxlY3RQYWdlO1xuY29uc3QgZG9TZWFyY2ggPSAocGFnZSkgPT4gKHsgbmFtZSwgdmFsdWUgfSkgPT4gcGFnZVxuICAgIC52aWV3XG4gICAgLmZpbmRCeUlkKG5hbWUpXG4gICAgLm1hcCgocykgPT4ge1xuICAgIGxldCBoaXQgPSByZXN1bHRzXzEucmVzdWx0cy5maWx0ZXIoYyA9PiBjLnZhbHVlLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCh2YWx1ZSkgPyB0cnVlIDogZmFsc2UpO1xuICAgIHMudXBkYXRlKGhpdCk7XG59KTtcbmNvbnN0IGRvQ2hhbmdlID0gKHBhZ2UpID0+ICh7IG5hbWUsIHZhbHVlIH0pID0+IHBhZ2VcbiAgICAudmlld1xuICAgIC5maW5kQnlJZChuYW1lKVxuICAgIC5tYXAodCA9PiB7XG4gICAgdC5zZXRNZXNzYWdlKGBTZWxlY3RlZDogJHt2YWx1ZS52YWx1ZX1gKTtcbn0pO1xuY29uc3QgZG9VbnNldCA9IChwYWdlKSA9PiAoeyBuYW1lIH0pID0+IHBhZ2VcbiAgICAudmlld1xuICAgIC5maW5kQnlJZChuYW1lKVxuICAgIC5tYXAodCA9PiB7XG4gICAgdC5zZXRNZXNzYWdlKCcnKTtcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IFNlbGVjdFBhZ2UoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYWluID0gdm9pZCAwO1xuY29uc3QgX19kb2N1bWVudCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbmNvbnN0IG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG5jb25zdCBkZW1vXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vd2lkZ2V0cy9kZW1vXCIpO1xuO1xuY29uc3Qgc2VsZWN0XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRyb2wvc2VsZWN0XCIpO1xuO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9faWYgPSAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpID0+IChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0ID8gX19hbHQoKSA6IFtdO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9ySW4gPSAobGlzdCwgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2Zvck9mID0gKG8sIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHRleHQgPSBfX2RvY3VtZW50LnRleHQ7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHVuc2FmZSA9IF9fZG9jdW1lbnQudW5zYWZlO1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCBpc1NldCA9ICh2YWx1ZSkgPT4gdmFsdWUgIT0gbnVsbDtcbmNsYXNzIE1haW4ge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgc2VsZWN0XzEuU2VsZWN0KHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMubm9ybWFsLmlkIH0sICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwubmFtZSwgJ2xhYmVsJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwubGFiZWwsICd2YWx1ZSc6IF9fY29udGV4dC52YWx1ZXMubm9ybWFsLnZhbHVlLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5zdHJpbmdpZmllciwgJ29uU2VhcmNoJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwub25TZWFyY2gsICdvbkNoYW5nZSc6IF9fY29udGV4dC52YWx1ZXMubm9ybWFsLm9uQ2hhbmdlIH0sIFtdKSwgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwuaWQgfSwgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5uYW1lLCAnbGFiZWwnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5sYWJlbCwgJ3ZhbHVlJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwudmFsdWUsICdzdHJpbmdpZmllcic6IF9fY29udGV4dC52YWx1ZXMubm9ybWFsLnN0cmluZ2lmaWVyLCAnb25TZWFyY2gnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5vblNlYXJjaCwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwub25DaGFuZ2UgfSlcbiAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHNlbGVjdF8xLlNlbGVjdCh7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3MuaWQgfSwgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3MubmFtZSwgJ2xhYmVsJzogX19jb250ZXh0LnZhbHVlcy5zdWNjZXNzLmxhYmVsLCAnc3VjY2Vzcyc6IF9fY29udGV4dC52YWx1ZXMuc3VjY2Vzcy5tZXNzYWdlLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3Muc3RyaW5naWZpZXIsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMuc3VjY2Vzcy5vblNlYXJjaCwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5zdWNjZXNzLm9uQ2hhbmdlIH0sIFtdKSwgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5zdWNjZXNzLmlkIH0sICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5zdWNjZXNzLm5hbWUsICdsYWJlbCc6IF9fY29udGV4dC52YWx1ZXMuc3VjY2Vzcy5sYWJlbCwgJ3N1Y2Nlc3MnOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3MubWVzc2FnZSwgJ3N0cmluZ2lmaWVyJzogX19jb250ZXh0LnZhbHVlcy5zdWNjZXNzLnN0cmluZ2lmaWVyLCAnb25TZWFyY2gnOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3Mub25TZWFyY2gsICdvbkNoYW5nZSc6IF9fY29udGV4dC52YWx1ZXMuc3VjY2Vzcy5vbkNoYW5nZSB9KVxuICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgc2VsZWN0XzEuU2VsZWN0KHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMud2FybmluZy5pZCB9LCAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMud2FybmluZy5uYW1lLCAnbGFiZWwnOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcubGFiZWwsICd3YXJuaW5nJzogX19jb250ZXh0LnZhbHVlcy53YXJuaW5nLm1lc3NhZ2UsICdzdHJpbmdpZmllcic6IF9fY29udGV4dC52YWx1ZXMud2FybmluZy5zdHJpbmdpZmllciwgJ29uU2VhcmNoJzogX19jb250ZXh0LnZhbHVlcy53YXJuaW5nLm9uU2VhcmNoLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcub25DaGFuZ2UgfSwgW10pLCB7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcuaWQgfSwgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcubmFtZSwgJ2xhYmVsJzogX19jb250ZXh0LnZhbHVlcy53YXJuaW5nLmxhYmVsLCAnd2FybmluZyc6IF9fY29udGV4dC52YWx1ZXMud2FybmluZy5tZXNzYWdlLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcuc3RyaW5naWZpZXIsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMud2FybmluZy5vblNlYXJjaCwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy53YXJuaW5nLm9uQ2hhbmdlIH0pXG4gICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBzZWxlY3RfMS5TZWxlY3QoeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5lcnJvci5pZCB9LCAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMuZXJyb3IubmFtZSwgJ2xhYmVsJzogX19jb250ZXh0LnZhbHVlcy5lcnJvci5sYWJlbCwgJ2Vycm9yJzogX19jb250ZXh0LnZhbHVlcy5lcnJvci5tZXNzYWdlLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLnN0cmluZ2lmaWVyLCAnb25TZWFyY2gnOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLm9uU2VhcmNoLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLm9uQ2hhbmdlIH0sIFtdKSwgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5lcnJvci5pZCB9LCAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMuZXJyb3IubmFtZSwgJ2xhYmVsJzogX19jb250ZXh0LnZhbHVlcy5lcnJvci5sYWJlbCwgJ2Vycm9yJzogX19jb250ZXh0LnZhbHVlcy5lcnJvci5tZXNzYWdlLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLnN0cmluZ2lmaWVyLCAnb25TZWFyY2gnOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLm9uU2VhcmNoLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLm9uQ2hhbmdlIH0pXG4gICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBzZWxlY3RfMS5TZWxlY3QoeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5ibG9jay5pZCB9LCAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMuYmxvY2submFtZSwgJ2xhYmVsJzogX19jb250ZXh0LnZhbHVlcy5ibG9jay5sYWJlbCwgJ2Jsb2NrJzogdHJ1ZSwgJ3N0cmluZ2lmaWVyJzogX19jb250ZXh0LnZhbHVlcy5ibG9jay5zdHJpbmdpZmllciwgJ29uU2VhcmNoJzogX19jb250ZXh0LnZhbHVlcy5ibG9jay5vblNlYXJjaCwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5ibG9jay5vbkNoYW5nZSB9LCBbXSksIHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuYmxvY2suaWQgfSwgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLmJsb2NrLm5hbWUsICdsYWJlbCc6IF9fY29udGV4dC52YWx1ZXMuYmxvY2subGFiZWwsICdibG9jayc6IHRydWUsICdzdHJpbmdpZmllcic6IF9fY29udGV4dC52YWx1ZXMuYmxvY2suc3RyaW5naWZpZXIsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMuYmxvY2sub25TZWFyY2gsICdvbkNoYW5nZSc6IF9fY29udGV4dC52YWx1ZXMuYmxvY2sub25DaGFuZ2UgfSlcbiAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHNlbGVjdF8xLlNlbGVjdCh7ICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwubmFtZSwgJ2xhYmVsJzogJ0Rpc2FibGVkJywgJ2Rpc2FibGVkJzogdHJ1ZSwgJ3N0cmluZ2lmaWVyJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwuc3RyaW5naWZpZXIsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMubm9ybWFsLm9uU2VhcmNoLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5vbkNoYW5nZSB9LCBbXSksIHsgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5uYW1lLCAnbGFiZWwnOiAnRGlzYWJsZWQnLCAnZGlzYWJsZWQnOiB0cnVlLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5zdHJpbmdpZmllciwgJ29uU2VhcmNoJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwub25TZWFyY2gsICdvbkNoYW5nZSc6IF9fY29udGV4dC52YWx1ZXMubm9ybWFsLm9uQ2hhbmdlIH0pXG4gICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBzZWxlY3RfMS5TZWxlY3QoeyAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMubm9ybWFsLm5hbWUsICdsYWJlbCc6ICdEaXNhYmxlZCB3aXRoIHZhbHVlJywgJ3ZhbHVlJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwudmFsdWUsICdkaXNhYmxlZCc6IHRydWUsICdzdHJpbmdpZmllcic6IF9fY29udGV4dC52YWx1ZXMubm9ybWFsLnN0cmluZ2lmaWVyLCAnb25TZWFyY2gnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5vblNlYXJjaCwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwub25DaGFuZ2UgfSwgW10pLCB7ICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwubmFtZSwgJ2xhYmVsJzogJ0Rpc2FibGVkIHdpdGggdmFsdWUnLCAndmFsdWUnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC52YWx1ZSwgJ2Rpc2FibGVkJzogdHJ1ZSwgJ3N0cmluZ2lmaWVyJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwuc3RyaW5naWZpZXIsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMubm9ybWFsLm9uU2VhcmNoLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5vbkNoYW5nZSB9KVxuICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgIF0pLCB7fSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VsZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdGFja1NlbGVjdFBhZ2UgPSB2b2lkIDA7XG5jb25zdCB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9zdGFjay1zZWxlY3RcIik7XG5jb25zdCByZXN1bHRzXzEgPSByZXF1aXJlKFwiLi4vLi4vZml4dHVyZXMvZGF0YS9yZXN1bHRzXCIpO1xuY2xhc3MgU3RhY2tTZWxlY3RQYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgYXNjOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdhc2MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdhc2MnLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnQXNjZW5kaW5nJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0c18xLnJlc3VsdHNbMl0sXG4gICAgICAgICAgICAgICAgc3RyaW5naWZpZXI6IChyKSA9PiByLnZhbHVlLFxuICAgICAgICAgICAgICAgIG9uU2VhcmNoOiBvblNlYXJjaCh0aGlzKSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogb25DaGFuZ2UodGhpcyksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVzYzoge1xuICAgICAgICAgICAgICAgIGlkOiAnZGVzYycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2Rlc2MnLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnRGVzY2VuZGluZycsXG4gICAgICAgICAgICAgICAgc3RyaW5naWZpZXI6IChyKSA9PiByLnZhbHVlLFxuICAgICAgICAgICAgICAgIG9uU2VhcmNoOiBvblNlYXJjaCh0aGlzKSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogb25DaGFuZ2UodGhpcyksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3VjY2Vzczoge1xuICAgICAgICAgICAgICAgIGlkOiAnc3VjY2VzcycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3N1Y2Nlc3MnLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnU3VjY2VzcycsXG4gICAgICAgICAgICAgICAgc3RyaW5naWZpZXI6IChyKSA9PiByLnZhbHVlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdUaGlzIGhhcyBhIHN1Y2Nlc3MgbWVzc2FnZS4nLFxuICAgICAgICAgICAgICAgIG9uU2VhcmNoOiBvblNlYXJjaCh0aGlzKSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogb25DaGFuZ2UodGhpcyksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd2FybmluZzoge1xuICAgICAgICAgICAgICAgIGlkOiAnd2FybmluZycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3dhcm5pbmcnLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnV2FybmluZycsXG4gICAgICAgICAgICAgICAgc3RyaW5naWZpZXI6IChyKSA9PiByLnZhbHVlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdUaGlzIGhhcyBhIHdhcm5pbmcgbWVzc2FnZS4nLFxuICAgICAgICAgICAgICAgIG9uU2VhcmNoOiBvblNlYXJjaCh0aGlzKSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogb25DaGFuZ2UodGhpcyksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgICBpZDogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnRXJyb3InLFxuICAgICAgICAgICAgICAgIHN0cmluZ2lmaWVyOiAocikgPT4gci52YWx1ZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnVGhpcyBoYXMgYSBlcnJvciBtZXNzYWdlLicsXG4gICAgICAgICAgICAgICAgb25TZWFyY2g6IG9uU2VhcmNoKHRoaXMpLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBvbkNoYW5nZSh0aGlzKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5TdGFja1NlbGVjdFBhZ2UgPSBTdGFja1NlbGVjdFBhZ2U7XG5jb25zdCBvblNlYXJjaCA9IChwYWdlKSA9PiAoeyBuYW1lLCB2YWx1ZSB9KSA9PiBwYWdlXG4gICAgLnZpZXdcbiAgICAuZmluZEJ5SWQobmFtZSlcbiAgICAubWFwKChzKSA9PiB7XG4gICAgbGV0IGhpdCA9IHJlc3VsdHNfMS5yZXN1bHRzLmZpbHRlcihjID0+IGMudmFsdWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKHZhbHVlKSA/IHRydWUgOiBmYWxzZSk7XG4gICAgcy51cGRhdGUoaGl0KTtcbn0pO1xuY29uc3Qgb25DaGFuZ2UgPSAocGFnZSkgPT4gKHsgbmFtZSwgdmFsdWUgfSkgPT4gcGFnZVxuICAgIC52aWV3XG4gICAgLmZpbmRCeUlkKG5hbWUpXG4gICAgLm1hcCh0ID0+IHtcbiAgICB0LnNldE1lc3NhZ2UoYENvdW50OiAke3ZhbHVlLmxlbmd0aH1gKTtcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IFN0YWNrU2VsZWN0UGFnZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1haW4gPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbmNvbnN0IGRlbW9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi93aWRnZXRzL2RlbW9cIik7XG47XG5jb25zdCBzdGFja19zZWxlY3RfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvY29udHJvbC9zdGFjay1zZWxlY3RcIik7XG47XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBzdGFja19zZWxlY3RfMS5TdGFja1NlbGVjdCh7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmFzYy5pZCB9LCAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMuYXNjLm5hbWUsICdsYWJlbCc6IF9fY29udGV4dC52YWx1ZXMuYXNjLmxhYmVsLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLmFzYy5zdHJpbmdpZmllciwgJ29uU2VhcmNoJzogX19jb250ZXh0LnZhbHVlcy5hc2Mub25TZWFyY2gsICdvbkNoYW5nZSc6IF9fY29udGV4dC52YWx1ZXMuYXNjLm9uQ2hhbmdlIH0sIFtdKSwgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5hc2MuaWQgfSwgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLmFzYy5uYW1lLCAnbGFiZWwnOiBfX2NvbnRleHQudmFsdWVzLmFzYy5sYWJlbCwgJ3N0cmluZ2lmaWVyJzogX19jb250ZXh0LnZhbHVlcy5hc2Muc3RyaW5naWZpZXIsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMuYXNjLm9uU2VhcmNoLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLmFzYy5vbkNoYW5nZSB9KVxuICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgc3RhY2tfc2VsZWN0XzEuU3RhY2tTZWxlY3QoeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5kZXNjLmlkIH0sICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5kZXNjLm5hbWUsICdsYWJlbCc6IF9fY29udGV4dC52YWx1ZXMuZGVzYy5sYWJlbCwgJ2Rpcic6IC0xLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLmRlc2Muc3RyaW5naWZpZXIsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMuZGVzYy5vblNlYXJjaCwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5kZXNjLm9uQ2hhbmdlIH0sIFtdKSwgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5kZXNjLmlkIH0sICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5kZXNjLm5hbWUsICdsYWJlbCc6IF9fY29udGV4dC52YWx1ZXMuZGVzYy5sYWJlbCwgJ2Rpcic6IC0xLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLmRlc2Muc3RyaW5naWZpZXIsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMuZGVzYy5vblNlYXJjaCwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5kZXNjLm9uQ2hhbmdlIH0pXG4gICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBzdGFja19zZWxlY3RfMS5TdGFja1NlbGVjdCh7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3MuaWQgfSwgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3MubmFtZSwgJ2xhYmVsJzogX19jb250ZXh0LnZhbHVlcy5zdWNjZXNzLmxhYmVsLCAnc3VjY2Vzcyc6IF9fY29udGV4dC52YWx1ZXMuc3VjY2Vzcy5tZXNzYWdlLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3Muc3RyaW5naWZpZXIsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMuc3VjY2Vzcy5vblNlYXJjaCwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5zdWNjZXNzLm9uQ2hhbmdlIH0sIFtdKSwgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5zdWNjZXNzLmlkIH0sICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5zdWNjZXNzLm5hbWUsICdsYWJlbCc6IF9fY29udGV4dC52YWx1ZXMuc3VjY2Vzcy5sYWJlbCwgJ3N1Y2Nlc3MnOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3MubWVzc2FnZSwgJ3N0cmluZ2lmaWVyJzogX19jb250ZXh0LnZhbHVlcy5zdWNjZXNzLnN0cmluZ2lmaWVyLCAnb25TZWFyY2gnOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3Mub25TZWFyY2gsICdvbkNoYW5nZSc6IF9fY29udGV4dC52YWx1ZXMuc3VjY2Vzcy5vbkNoYW5nZSB9KVxuICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgc3RhY2tfc2VsZWN0XzEuU3RhY2tTZWxlY3QoeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy53YXJuaW5nLmlkIH0sICduYW1lJzogX19jb250ZXh0LnZhbHVlcy53YXJuaW5nLm5hbWUsICdsYWJlbCc6IF9fY29udGV4dC52YWx1ZXMud2FybmluZy5sYWJlbCwgJ3dhcm5pbmcnOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcubWVzc2FnZSwgJ3N0cmluZ2lmaWVyJzogX19jb250ZXh0LnZhbHVlcy53YXJuaW5nLnN0cmluZ2lmaWVyLCAnb25TZWFyY2gnOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcub25TZWFyY2gsICdvbkNoYW5nZSc6IF9fY29udGV4dC52YWx1ZXMud2FybmluZy5vbkNoYW5nZSB9LCBbXSksIHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMud2FybmluZy5pZCB9LCAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMud2FybmluZy5uYW1lLCAnbGFiZWwnOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcubGFiZWwsICd3YXJuaW5nJzogX19jb250ZXh0LnZhbHVlcy53YXJuaW5nLm1lc3NhZ2UsICdzdHJpbmdpZmllcic6IF9fY29udGV4dC52YWx1ZXMud2FybmluZy5zdHJpbmdpZmllciwgJ29uU2VhcmNoJzogX19jb250ZXh0LnZhbHVlcy53YXJuaW5nLm9uU2VhcmNoLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcub25DaGFuZ2UgfSlcbiAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHN0YWNrX3NlbGVjdF8xLlN0YWNrU2VsZWN0KHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuZXJyb3IuaWQgfSwgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLm5hbWUsICdsYWJlbCc6IF9fY29udGV4dC52YWx1ZXMuZXJyb3IubGFiZWwsICdlcnJvcic6IF9fY29udGV4dC52YWx1ZXMuZXJyb3IubWVzc2FnZSwgJ3N0cmluZ2lmaWVyJzogX19jb250ZXh0LnZhbHVlcy5lcnJvci5zdHJpbmdpZmllciwgJ29uU2VhcmNoJzogX19jb250ZXh0LnZhbHVlcy5lcnJvci5vblNlYXJjaCwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5lcnJvci5vbkNoYW5nZSB9LCBbXSksIHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuZXJyb3IuaWQgfSwgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLm5hbWUsICdsYWJlbCc6IF9fY29udGV4dC52YWx1ZXMuZXJyb3IubGFiZWwsICdlcnJvcic6IF9fY29udGV4dC52YWx1ZXMuZXJyb3IubWVzc2FnZSwgJ3N0cmluZ2lmaWVyJzogX19jb250ZXh0LnZhbHVlcy5lcnJvci5zdHJpbmdpZmllciwgJ29uU2VhcmNoJzogX19jb250ZXh0LnZhbHVlcy5lcnJvci5vblNlYXJjaCwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5lcnJvci5vbkNoYW5nZSB9KVxuICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgc3RhY2tfc2VsZWN0XzEuU3RhY2tTZWxlY3QoeyAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMuYXNjLm5hbWUsICdsYWJlbCc6ICdEaXNhYmxlZCcsICdkaXNhYmxlZCc6IHRydWUsICdzdHJpbmdpZmllcic6IF9fY29udGV4dC52YWx1ZXMuYXNjLnN0cmluZ2lmaWVyLCAnb25TZWFyY2gnOiBfX2NvbnRleHQudmFsdWVzLmFzYy5vblNlYXJjaCwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5hc2Mub25DaGFuZ2UgfSwgW10pLCB7ICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5hc2MubmFtZSwgJ2xhYmVsJzogJ0Rpc2FibGVkJywgJ2Rpc2FibGVkJzogdHJ1ZSwgJ3N0cmluZ2lmaWVyJzogX19jb250ZXh0LnZhbHVlcy5hc2Muc3RyaW5naWZpZXIsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMuYXNjLm9uU2VhcmNoLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLmFzYy5vbkNoYW5nZSB9KVxuICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgIF0pLCB7fSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhY2stc2VsZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdGFja1BhZ2UgPSB2b2lkIDA7XG5jb25zdCB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9zdGFja1wiKTtcbmNvbnN0IF9nZXRWYWx1ZXMgPSAoKSA9PiBbXG4gICAgeyBsYWJlbDogJ0FzdXMnLCB2YWx1ZTogJ0FzdXMnIH0sXG4gICAgeyBsYWJlbDogJ01TSScsIHZhbHVlOiAnTVNJJyB9LFxuICAgIHsgbGFiZWw6ICdNU0knLCB2YWx1ZTogJ01TSScgfSxcbiAgICB7IGxhYmVsOiAnR2lnYWJ5dGUnLCB2YWx1ZTogJ0dpZ2FieXRlJyB9XG5dO1xuY29uc3QgX2dldFRleHQgPSAobSkgPT4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobS5tYXAoKHsgbGFiZWwgfSkgPT4gbGFiZWwpLmpvaW4oJywnKSk7XG5jbGFzcyBTdGFja1BhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbih0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICB2YWx1ZXM6IF9nZXRWYWx1ZXMoKSxcbiAgICAgICAgICAgIHRleHQ6IF9nZXRUZXh0KF9nZXRWYWx1ZXMoKSksXG4gICAgICAgICAgICBkZWNvcmF0b3I6IChtKSA9PiBtLmxhYmVsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSAoeyB2YWx1ZSB9KSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzLnZhbHVlcyA9IF9nZXRWYWx1ZXMoKTtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzLnRleHQgPSBfZ2V0VGV4dCh0aGlzLnZhbHVlcy52YWx1ZXMpO1xuICAgICAgICAgICAgdGhpcy52aWV3LmludmFsaWRhdGUoKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlN0YWNrUGFnZSA9IFN0YWNrUGFnZTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBTdGFja1BhZ2UoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYWluID0gdm9pZCAwO1xuY29uc3QgX19kb2N1bWVudCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbmNvbnN0IG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG5jb25zdCBkZW1vXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vd2lkZ2V0cy9kZW1vXCIpO1xuO1xuY29uc3Qgc3RhY2tfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvY29udHJvbC9zdGFja1wiKTtcbjtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnTWVtYmVyczogJyksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdiJywgeyB3bWw6IHsgJ2lkJzogJ3NlbGVjdGVkJyB9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fY29udGV4dC52YWx1ZXMudGV4dFxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnLicpXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBzdGFja18xLlN0YWNrKHsgJ25hbWUnOiAnc3RhY2snLCAndmFsdWUnOiBfX2NvbnRleHQudmFsdWVzLnZhbHVlcywgJ2RlY29yYXRvcic6IF9fY29udGV4dC52YWx1ZXMuZGVjb3JhdG9yLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQub25DaGFuZ2UgfSwgW10pLCB7ICduYW1lJzogJ3N0YWNrJywgJ3ZhbHVlJzogX19jb250ZXh0LnZhbHVlcy52YWx1ZXMsICdkZWNvcmF0b3InOiBfX2NvbnRleHQudmFsdWVzLmRlY29yYXRvciwgJ29uQ2hhbmdlJzogX19jb250ZXh0Lm9uQ2hhbmdlIH0pXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdEaXNhYmxlZCcpXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBzdGFja18xLlN0YWNrKHsgJ25hbWUnOiAnc3RhY2snLCAndmFsdWUnOiBfX2NvbnRleHQudmFsdWVzLnZhbHVlcywgJ2Rpc2FibGVkJzogdHJ1ZSwgJ2RlY29yYXRvcic6IF9fY29udGV4dC52YWx1ZXMuZGVjb3JhdG9yLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQub25DaGFuZ2UgfSwgW10pLCB7ICduYW1lJzogJ3N0YWNrJywgJ3ZhbHVlJzogX19jb250ZXh0LnZhbHVlcy52YWx1ZXMsICdkaXNhYmxlZCc6IHRydWUsICdkZWNvcmF0b3InOiBfX2NvbnRleHQudmFsdWVzLmRlY29yYXRvciwgJ29uQ2hhbmdlJzogX19jb250ZXh0Lm9uQ2hhbmdlIH0pXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pLCB7fSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhY2suanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN3aXRjaFBhZ2UgPSB2b2lkIDA7XG5jb25zdCB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9zd2l0Y2hcIik7XG5jbGFzcyBTd2l0Y2hQYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0cnVlO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gKHsgdmFsdWUgfSkgPT4ge1xuICAgICAgICAgICAgdGhpcy52aWV3LmZpbmRCeUlkKCdjb250ZW50JylcbiAgICAgICAgICAgICAgICAubWFwKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGUuZmlyc3RDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgZS5yZW1vdmVDaGlsZChlLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmFsdWUgPT09IHRydWUgP1xuICAgICAgICAgICAgICAgICAgICAnb24nIDpcbiAgICAgICAgICAgICAgICAgICAgKHZhbHVlID09PSBmYWxzZSA/ICdvZmYnIDogJ2Vycm9yJykpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuU3dpdGNoUGFnZSA9IFN3aXRjaFBhZ2U7XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgU3dpdGNoUGFnZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1haW4gPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbmNvbnN0IGRlbW9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi93aWRnZXRzL2RlbW9cIik7XG47XG5jb25zdCBzd2l0Y2hfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvY29udHJvbC9zd2l0Y2hcIik7XG47XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdUaGUgc3dpdGNoIGlzIGFscmVhZHkgc2V0LicpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBzd2l0Y2hfMS5Td2l0Y2goeyAnbmFtZSc6ICdzd2l0Y2gnLCAndmFsdWUnOiB0cnVlIH0sIFtdKSwgeyAnbmFtZSc6ICdzd2l0Y2gnLCAndmFsdWUnOiB0cnVlIH0pXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdUaGUgc3dpdGNoIGlzICcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2InLCB7IHdtbDogeyAnaWQnOiAnY29udGVudCcgfSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgndW50b3VjaGVkJylcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnLicpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBzd2l0Y2hfMS5Td2l0Y2goeyAnbmFtZSc6ICdzd2l0Y2gnLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQub25DaGFuZ2UgfSwgW10pLCB7ICduYW1lJzogJ3N3aXRjaCcsICdvbkNoYW5nZSc6IF9fY29udGV4dC5vbkNoYW5nZSB9KVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgIF0pLCB7fSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3dpdGNoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UYWJCYXJQYWdlID0gdm9pZCAwO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvdGFiLWJhclwiKTtcbmNsYXNzIFRhYkJhclBhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbih0aGlzKTtcbiAgICAgICAgdGhpcy50YWIgPSAnRmlyc3QnO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnRmlyc3QgVGFiJyk7XG4gICAgICAgIHRoaXMuY2xpY2tlZCA9ICh7IG5hbWUgfSkgPT4ge1xuICAgICAgICAgICAgdGhpcy50YWIgPSBuYW1lO1xuICAgICAgICAgICAgdGhpcy5jb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYCR7bmFtZX0gVGFiYCk7XG4gICAgICAgICAgICB0aGlzLnZpZXcuaW52YWxpZGF0ZSgpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuVGFiQmFyUGFnZSA9IFRhYkJhclBhZ2U7XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgVGFiQmFyUGFnZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1haW4gPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbmNvbnN0IGRlbW9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi93aWRnZXRzL2RlbW9cIik7XG47XG5jb25zdCB0YWJfYmFyXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRyb2wvdGFiLWJhclwiKTtcbjtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRhYl9iYXJfMS5UYWJCYXIoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRhYl9iYXJfMS5UYWIoeyAnYWN0aXZlJzogKF9fY29udGV4dC50YWIgPT09ICdGaXJzdCcpLCAndGV4dCc6ICdGaXJzdCcsICduYW1lJzogJ0ZpcnN0JywgJ29uQ2xpY2snOiBfX2NvbnRleHQuY2xpY2tlZCB9LCBbXSksIHsgJ2FjdGl2ZSc6IChfX2NvbnRleHQudGFiID09PSAnRmlyc3QnKSwgJ3RleHQnOiAnRmlyc3QnLCAnbmFtZSc6ICdGaXJzdCcsICdvbkNsaWNrJzogX19jb250ZXh0LmNsaWNrZWQgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyB0YWJfYmFyXzEuVGFiKHsgJ2FjdGl2ZSc6IChfX2NvbnRleHQudGFiID09PSAnU2Vjb25kJyksICd0ZXh0JzogJ1NlY29uZCcsICduYW1lJzogJ1NlY29uZCcsICdvbkNsaWNrJzogX19jb250ZXh0LmNsaWNrZWQgfSwgW10pLCB7ICdhY3RpdmUnOiAoX19jb250ZXh0LnRhYiA9PT0gJ1NlY29uZCcpLCAndGV4dCc6ICdTZWNvbmQnLCAnbmFtZSc6ICdTZWNvbmQnLCAnb25DbGljayc6IF9fY29udGV4dC5jbGlja2VkIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgdGFiX2Jhcl8xLlRhYih7ICdhY3RpdmUnOiAoX19jb250ZXh0LnRhYiA9PT0gJ1RoaXJkJyksICd0ZXh0JzogJ1RoaXJkJywgJ25hbWUnOiAnVGhpcmQnLCAnb25DbGljayc6IF9fY29udGV4dC5jbGlja2VkIH0sIFtdKSwgeyAnYWN0aXZlJzogKF9fY29udGV4dC50YWIgPT09ICdUaGlyZCcpLCAndGV4dCc6ICdUaGlyZCcsICduYW1lJzogJ1RoaXJkJywgJ29uQ2xpY2snOiBfX2NvbnRleHQuY2xpY2tlZCB9KVxuICAgICAgICAgICAgICAgICAgICBdKSwge30pXG4gICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyB0YWJfYmFyXzEuVGFiQmFyKHsgJ2p1c3RpZnknOiB0cnVlIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRhYl9iYXJfMS5UYWIoeyAnYWN0aXZlJzogKF9fY29udGV4dC50YWIgPT09ICdGaXJzdCcpLCAndGV4dCc6ICdGaXJzdCcsICduYW1lJzogJ0ZpcnN0JywgJ29uQ2xpY2snOiBfX2NvbnRleHQuY2xpY2tlZCB9LCBbXSksIHsgJ2FjdGl2ZSc6IChfX2NvbnRleHQudGFiID09PSAnRmlyc3QnKSwgJ3RleHQnOiAnRmlyc3QnLCAnbmFtZSc6ICdGaXJzdCcsICdvbkNsaWNrJzogX19jb250ZXh0LmNsaWNrZWQgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyB0YWJfYmFyXzEuVGFiKHsgJ2FjdGl2ZSc6IChfX2NvbnRleHQudGFiID09PSAnU2Vjb25kJyksICd0ZXh0JzogJ1NlY29uZCcsICduYW1lJzogJ1NlY29uZCcsICdvbkNsaWNrJzogX19jb250ZXh0LmNsaWNrZWQgfSwgW10pLCB7ICdhY3RpdmUnOiAoX19jb250ZXh0LnRhYiA9PT0gJ1NlY29uZCcpLCAndGV4dCc6ICdTZWNvbmQnLCAnbmFtZSc6ICdTZWNvbmQnLCAnb25DbGljayc6IF9fY29udGV4dC5jbGlja2VkIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgdGFiX2Jhcl8xLlRhYih7ICdhY3RpdmUnOiAoX19jb250ZXh0LnRhYiA9PT0gJ1RoaXJkJyksICd0ZXh0JzogJ1RoaXJkJywgJ25hbWUnOiAnVGhpcmQnLCAnb25DbGljayc6IF9fY29udGV4dC5jbGlja2VkIH0sIFtdKSwgeyAnYWN0aXZlJzogKF9fY29udGV4dC50YWIgPT09ICdUaGlyZCcpLCAndGV4dCc6ICdUaGlyZCcsICduYW1lJzogJ1RoaXJkJywgJ29uQ2xpY2snOiBfX2NvbnRleHQuY2xpY2tlZCB9KVxuICAgICAgICAgICAgICAgICAgICBdKSwgeyAnanVzdGlmeSc6IHRydWUgfSlcbiAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywgeyB3bWw6IHsgJ2lkJzogJ2NvbnRlbnQnIH0gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX19jb250ZXh0LmNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKSwge30pXG4gICAgICAgICAgICBdKSwge30pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhYi1iYXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRhZ1BhZ2UgPSB2b2lkIDA7XG5jb25zdCB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC90YWdcIik7XG5jb25zdCBzdHlsZV8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL2xpYi9jb250ZW50L3N0eWxlXCIpO1xuY29uc3QgZ2V0U3R5bGVzID0gKCkgPT4gW1xuICAgIHN0eWxlXzEuU3R5bGUuRGVmYXVsdCxcbiAgICBzdHlsZV8xLlN0eWxlLlByaW1hcnksXG4gICAgc3R5bGVfMS5TdHlsZS5TdWNjZXNzLFxuICAgIHN0eWxlXzEuU3R5bGUuSW5mbyxcbiAgICBzdHlsZV8xLlN0eWxlLldhcm5pbmcsXG4gICAgc3R5bGVfMS5TdHlsZS5FcnJvclxuXTtcbmNsYXNzIFRhZ1BhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbih0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBjYXBpdGFsaXplOiAocykgPT4gYCR7c1swXS50b1VwcGVyQ2FzZSgpfSR7cy5zbGljZSgxKX1gLFxuICAgICAgICAgICAgc3R5bGVzOiBnZXRTdHlsZXMoKSxcbiAgICAgICAgICAgIG9uRGlzbWlzczogKGUpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgaWR4ID0gdGhpcy52YWx1ZXMuc3R5bGVzLmluZGV4T2YoZS5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoaWR4ID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzLnN0eWxlcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZXMuc3R5bGVzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZXMuc3R5bGVzID0gZ2V0U3R5bGVzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LmludmFsaWRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlRhZ1BhZ2UgPSBUYWdQYWdlO1xuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IFRhZ1BhZ2UoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYWluID0gdm9pZCAwO1xuY29uc3QgX19kb2N1bWVudCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbmNvbnN0IG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG5jb25zdCB0YWdfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvY29udHJvbC90YWdcIik7XG47XG5jb25zdCBkZW1vXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vd2lkZ2V0cy9kZW1vXCIpO1xuO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9faWYgPSAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpID0+IChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0ID8gX19hbHQoKSA6IFtdO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9ySW4gPSAobGlzdCwgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2Zvck9mID0gKG8sIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHRleHQgPSBfX2RvY3VtZW50LnRleHQ7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHVuc2FmZSA9IF9fZG9jdW1lbnQudW5zYWZlO1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCBpc1NldCA9ICh2YWx1ZSkgPT4gdmFsdWUgIT0gbnVsbDtcbmNsYXNzIE1haW4ge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2gxJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1RhZycpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaDInLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1N0eWxlcycpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLl9fZm9ySW4oX19jb250ZXh0LnZhbHVlcy5zdHlsZXMsICh2LCBfJCRpLCBfJCRhbGwpID0+IChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgdGFnXzEuVGFnKHsgJ3N0eWxlJzogdiwgJ3RleHQnOiBfX2NvbnRleHQudmFsdWVzLmNhcGl0YWxpemUodiksICduYW1lJzogdiwgJ29uRGlzbWlzcyc6IF9fY29udGV4dC52YWx1ZXMub25EaXNtaXNzIH0sIFtdKSwgeyAnc3R5bGUnOiB2LCAndGV4dCc6IF9fY29udGV4dC52YWx1ZXMuY2FwaXRhbGl6ZSh2KSwgJ25hbWUnOiB2LCAnb25EaXNtaXNzJzogX19jb250ZXh0LnZhbHVlcy5vbkRpc21pc3MgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLCAoKSA9PiAoW10pKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgIF0pLCB7fSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFnLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UZXh0RmllbGRQYWdlID0gdm9pZCAwO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvdGV4dC1maWVsZFwiKTtcbmNvbnN0IGZlZWRiYWNrXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRyb2wvZmVlZGJhY2tcIik7XG5jbGFzcyBUZXh0RmllbGRQYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pZCA9ICd0ZXh0JztcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSAoeyBuYW1lLCB2YWx1ZSB9KSA9PiB7XG4gICAgICAgICAgICBsZXQgbWF5YmVGaWVsZCA9IHRoaXMudmlldy5maW5kQnlJZChuYW1lKTtcbiAgICAgICAgICAgIGlmIChtYXliZUZpZWxkLmlzSnVzdCgpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHQgPSBtYXliZUZpZWxkLmdldCgpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbmV1dHJhbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0LnNldFZhbGlkYXRpb25TdGF0ZShmZWVkYmFja18xLlZhbGlkYXRpb25TdGF0ZS5OZXV0cmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICAgICAgICAgICAgICB0LnNldFZhbGlkYXRpb25TdGF0ZShmZWVkYmFja18xLlZhbGlkYXRpb25TdGF0ZS5FcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3VjY2Vzcyc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0LnNldFZhbGlkYXRpb25TdGF0ZShmZWVkYmFja18xLlZhbGlkYXRpb25TdGF0ZS5TdWNjZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd3YXJuaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHQuc2V0VmFsaWRhdGlvblN0YXRlKGZlZWRiYWNrXzEuVmFsaWRhdGlvblN0YXRlLldhcm5pbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdC5zZXRNZXNzYWdlKGBNZXNzYWdlOiAke3ZhbHVlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuVGV4dEZpZWxkUGFnZSA9IFRleHRGaWVsZFBhZ2U7XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgVGV4dEZpZWxkUGFnZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1haW4gPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbmNvbnN0IGRlbW9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi93aWRnZXRzL2RlbW9cIik7XG47XG5jb25zdCB0ZXh0X2ZpZWxkXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRyb2wvdGV4dC1maWVsZFwiKTtcbjtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1RoZSB2YWx1ZSBvZiB0aGUgaW5wdXQgaXM6JylcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdiJywgeyB3bWw6IHsgJ2lkJzogJ2NvbnRlbnQnIH0gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ05vdGhpbmcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRleHRfZmllbGRfMS5UZXh0RmllbGQoeyB3bWw6IHsgJ2lkJzogJ3RleHQnIH0sICduYW1lJzogJ3RleHQnLCAnbWVzc2FnZSc6ICdUaGlzIGlzIHRoZSBoZWxwIG1lc3NhZ2UnLCAnZm9jdXMnOiB0cnVlLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQub25DaGFuZ2UgfSwgW10pLCB7IHdtbDogeyAnaWQnOiAndGV4dCcgfSwgJ25hbWUnOiAndGV4dCcsICdtZXNzYWdlJzogJ1RoaXMgaXMgdGhlIGhlbHAgbWVzc2FnZScsICdmb2N1cyc6IHRydWUsICdvbkNoYW5nZSc6IF9fY29udGV4dC5vbkNoYW5nZSB9KVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3N0cm9uZycsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnU3VjY2VzcycpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgdGV4dF9maWVsZF8xLlRleHRGaWVsZCh7IHdtbDogeyAnaWQnOiAnc3VjY2VzcycgfSwgJ25hbWUnOiAnc3VjY2VzcycsICdsYWJlbCc6ICdUaGlzIGlzIGEgc3VjY2VzcyBsYWJlbCcsICdzdWNjZXNzJzogJ1RoaXMgdGV4dGZpZWxkIGhhcyBhIHN1Y2Nlc3MnLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQub25DaGFuZ2UgfSwgW10pLCB7IHdtbDogeyAnaWQnOiAnc3VjY2VzcycgfSwgJ25hbWUnOiAnc3VjY2VzcycsICdsYWJlbCc6ICdUaGlzIGlzIGEgc3VjY2VzcyBsYWJlbCcsICdzdWNjZXNzJzogJ1RoaXMgdGV4dGZpZWxkIGhhcyBhIHN1Y2Nlc3MnLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQub25DaGFuZ2UgfSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdzdHJvbmcnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1dhcm5pbmcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRleHRfZmllbGRfMS5UZXh0RmllbGQoeyB3bWw6IHsgJ2lkJzogJ3dhcm5pbmcnIH0sICduYW1lJzogJ3dhcm5pbmcnLCAnbGFiZWwnOiAnVGhpcyBpcyBhIHdhcm5pbmcgbGFiZWwnLCAnd2FybmluZyc6ICdUaGlzIHRleHRmaWVsZCBoYXMgYSB3YXJuaW5nLicsICdvbkNoYW5nZSc6IF9fY29udGV4dC5vbkNoYW5nZSB9LCBbXSksIHsgd21sOiB7ICdpZCc6ICd3YXJuaW5nJyB9LCAnbmFtZSc6ICd3YXJuaW5nJywgJ2xhYmVsJzogJ1RoaXMgaXMgYSB3YXJuaW5nIGxhYmVsJywgJ3dhcm5pbmcnOiAnVGhpcyB0ZXh0ZmllbGQgaGFzIGEgd2FybmluZy4nLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQub25DaGFuZ2UgfSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdzdHJvbmcnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ0Vycm9yJylcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyB0ZXh0X2ZpZWxkXzEuVGV4dEZpZWxkKHsgd21sOiB7ICdpZCc6ICdlcnJvcicgfSwgJ25hbWUnOiAnZXJyb3InLCAnbGFiZWwnOiAnVGhpcyBpcyBhbiBlcnJvciBsYWJlbCcsICdlcnJvcic6ICdUaGlzIHRleHRmaWVsZCBoYXMgYW4gZXJyb3IuJywgJ29uQ2hhbmdlJzogX19jb250ZXh0Lm9uQ2hhbmdlIH0sIFtdKSwgeyB3bWw6IHsgJ2lkJzogJ2Vycm9yJyB9LCAnbmFtZSc6ICdlcnJvcicsICdsYWJlbCc6ICdUaGlzIGlzIGFuIGVycm9yIGxhYmVsJywgJ2Vycm9yJzogJ1RoaXMgdGV4dGZpZWxkIGhhcyBhbiBlcnJvci4nLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQub25DaGFuZ2UgfSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1RoZSBvbmUgdXNlcyByb3dzIHRvIHJlbmRlciBhIHRleHQgYXJlYTonKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgdGV4dF9maWVsZF8xLlRleHRGaWVsZCh7IHdtbDogeyAnaWQnOiAnYXJlYScgfSwgJ25hbWUnOiAnYXJlYScsICdyb3dzJzogNSwgJ2xhYmVsJzogJ1RoaXMgaXMgYSB0ZXh0YXJlYSBsYWJlbCcsICdvbkNoYW5nZSc6IF9fY29udGV4dC5vbkNoYW5nZSB9LCBbXSksIHsgd21sOiB7ICdpZCc6ICdhcmVhJyB9LCAnbmFtZSc6ICdhcmVhJywgJ3Jvd3MnOiA1LCAnbGFiZWwnOiAnVGhpcyBpcyBhIHRleHRhcmVhIGxhYmVsJywgJ29uQ2hhbmdlJzogX19jb250ZXh0Lm9uQ2hhbmdlIH0pXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSksIHt9KVxuICAgICAgICAgICAgXSksIHt9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZXh0LWZpZWxkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UZXh0SW5wdXRQYWdlID0gdm9pZCAwO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvdGV4dC1pbnB1dFwiKTtcbmNvbnN0IHNpemVfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi9saWIvY29udGVudC9zaXplXCIpO1xuY2xhc3MgVGV4dElucHV0UGFnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnNpemVzID0gW1xuICAgICAgICAgICAgc2l6ZV8xLlNpemUuRXh0cmFTbWFsbCxcbiAgICAgICAgICAgIHNpemVfMS5TaXplLlNtYWxsLFxuICAgICAgICAgICAgc2l6ZV8xLlNpemUuTWVkaXVtLFxuICAgICAgICAgICAgc2l6ZV8xLlNpemUuTGFyZ2UsXG4gICAgICAgICAgICBzaXplXzEuU2l6ZS5FeHRyYUxhcmdlXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuY29udGVudCA9ICgpID0+IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCd0aGlzJyk7XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSAoeyB2YWx1ZSB9KSA9PiB7XG4gICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICAgICAgLnZpZXdcbiAgICAgICAgICAgICAgICAuZmluZEJ5SWQoJ3R4dCcpXG4gICAgICAgICAgICAgICAgLm1hcChoID0+IGguaW5uZXJIVE1MID0gdmFsdWUpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuVGV4dElucHV0UGFnZSA9IFRleHRJbnB1dFBhZ2U7XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgVGV4dElucHV0UGFnZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1haW4gPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbmNvbnN0IHRleHRfaW5wdXRfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvY29udHJvbC90ZXh0LWlucHV0XCIpO1xuO1xuY29uc3QgZGVtb18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3dpZGdldHMvZGVtb1wiKTtcbjtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1xcdTAwMGEgICAgICBUaGlzIGlzIGEgdGV4dCBpbnB1dDogXFx1MDAwYSAgICAgICcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgdGV4dF9pbnB1dF8xLlRleHRJbnB1dCh7ICdtYXRjaCc6ICdbYS16QS1aXScsICdsZW5ndGgnOiAyMCwgJ29uQ2hhbmdlJzogX19jb250ZXh0Lm9uQ2hhbmdlIH0sIFtdKSwgeyAnbWF0Y2gnOiAnW2EtekEtWl0nLCAnbGVuZ3RoJzogMjAsICdvbkNoYW5nZSc6IF9fY29udGV4dC5vbkNoYW5nZSB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJy5cXHUwMDBhICAgICcpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdBcyB5b3UgdHlwZSAnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdiJywgeyB3bWw6IHsgJ2lkJzogJ3R4dCcgfSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgndGhpcycpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJyBjaGFuZ2VzLCBidXQgb25seSBmb3IgbGV0dGVycy4gKDIwKScpXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICAuLi5fX2ZvckluKF9fY29udGV4dC5zaXplcywgKHYsIF8kJGksIF8kJGFsbCkgPT4gKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdcXHUwMDBhICAgICAgICBTaXplICcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCh2ICsgJyBuZXV0cmFsOiAnKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgdGV4dF9pbnB1dF8xLlRleHRJbnB1dCh7ICdvbkNoYW5nZSc6IF9fY29udGV4dC5vbkNoYW5nZSwgJ3NpemUnOiB2IH0sIFtdKSwgeyAnb25DaGFuZ2UnOiBfX2NvbnRleHQub25DaGFuZ2UsICdzaXplJzogdiB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnXFx1MDAwYSAgICAgICAgU2l6ZSAnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgodiArICcgZXJyb3I6ICcpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyB0ZXh0X2lucHV0XzEuVGV4dElucHV0KHsgJ29uQ2hhbmdlJzogX19jb250ZXh0Lm9uQ2hhbmdlLCAnc2l6ZSc6IHYsICdjbGFzc05hbWUnOiAnLWVycm9yJyB9LCBbXSksIHsgJ29uQ2hhbmdlJzogX19jb250ZXh0Lm9uQ2hhbmdlLCAnc2l6ZSc6IHYsICdjbGFzc05hbWUnOiAnLWVycm9yJyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnXFx1MDAwYSAgICAgICAgU2l6ZSAnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgodiArICcgd2FybmluZzogJykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRleHRfaW5wdXRfMS5UZXh0SW5wdXQoeyAnb25DaGFuZ2UnOiBfX2NvbnRleHQub25DaGFuZ2UsICdzaXplJzogdiwgJ2NsYXNzTmFtZSc6ICctd2FybmluZycgfSwgW10pLCB7ICdvbkNoYW5nZSc6IF9fY29udGV4dC5vbkNoYW5nZSwgJ3NpemUnOiB2LCAnY2xhc3NOYW1lJzogJy13YXJuaW5nJyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnXFx1MDAwYSAgICAgICAgU2l6ZSAnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgodiArICcgc3VjY2VzczogJykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRleHRfaW5wdXRfMS5UZXh0SW5wdXQoeyAnb25DaGFuZ2UnOiBfX2NvbnRleHQub25DaGFuZ2UsICdzaXplJzogdiwgJ2NsYXNzTmFtZSc6ICctc3VjY2VzcycgfSwgW10pLCB7ICdvbkNoYW5nZSc6IF9fY29udGV4dC5vbkNoYW5nZSwgJ3NpemUnOiB2LCAnY2xhc3NOYW1lJzogJy1zdWNjZXNzJyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgXSksICgpID0+IChbXSkpXG4gICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdcXHUwMDBhICAgICAgQmxvY2s6XFx1MDAwYSAgICAgICcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgdGV4dF9pbnB1dF8xLlRleHRJbnB1dCh7ICdvbkNoYW5nZSc6IF9fY29udGV4dC5vbkNoYW5nZSwgJ2Jsb2NrJzogdHJ1ZSB9LCBbXSksIHsgJ29uQ2hhbmdlJzogX19jb250ZXh0Lm9uQ2hhbmdlLCAnYmxvY2snOiB0cnVlIH0pXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJyBUZXh0YXJlYTogJylcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICAuLi5fX2ZvckluKF9fY29udGV4dC5zaXplcywgKHYsIF8kJGksIF8kJGFsbCkgPT4gKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdcXHUwMDBhICAgICAgICBTaXplICcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCh2ICsgJyBuZXV0cmFsOiAnKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgdGV4dF9pbnB1dF8xLlRleHRJbnB1dCh7ICdvbkNoYW5nZSc6IF9fY29udGV4dC5vbkNoYW5nZSwgJ3Jvd3MnOiA1LCAnc2l6ZSc6IHYgfSwgW10pLCB7ICdvbkNoYW5nZSc6IF9fY29udGV4dC5vbkNoYW5nZSwgJ3Jvd3MnOiA1LCAnc2l6ZSc6IHYgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1xcdTAwMGEgICAgICAgIFNpemUgJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoKHYgKyAnIGVycm9yOiAnKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgdGV4dF9pbnB1dF8xLlRleHRJbnB1dCh7ICdvbkNoYW5nZSc6IF9fY29udGV4dC5vbkNoYW5nZSwgJ3NpemUnOiB2LCAncm93cyc6IDUsICdjbGFzc05hbWUnOiAnLWVycm9yJyB9LCBbXSksIHsgJ29uQ2hhbmdlJzogX19jb250ZXh0Lm9uQ2hhbmdlLCAnc2l6ZSc6IHYsICdyb3dzJzogNSwgJ2NsYXNzTmFtZSc6ICctZXJyb3InIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdcXHUwMDBhICAgICAgICBTaXplICcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCh2ICsgJyB3YXJuaW5nOiAnKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgdGV4dF9pbnB1dF8xLlRleHRJbnB1dCh7ICdvbkNoYW5nZSc6IF9fY29udGV4dC5vbkNoYW5nZSwgJ3NpemUnOiB2LCAncm93cyc6IDUsICdjbGFzc05hbWUnOiAnLXdhcm5pbmcnIH0sIFtdKSwgeyAnb25DaGFuZ2UnOiBfX2NvbnRleHQub25DaGFuZ2UsICdzaXplJzogdiwgJ3Jvd3MnOiA1LCAnY2xhc3NOYW1lJzogJy13YXJuaW5nJyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnXFx1MDAwYSAgICAgICAgU2l6ZSAnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgodiArICcgc3VjY2VzczogJykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRleHRfaW5wdXRfMS5UZXh0SW5wdXQoeyAnb25DaGFuZ2UnOiBfX2NvbnRleHQub25DaGFuZ2UsICdzaXplJzogdiwgJ3Jvd3MnOiA1LCAnY2xhc3NOYW1lJzogJy1zdWNjZXNzJyB9LCBbXSksIHsgJ29uQ2hhbmdlJzogX19jb250ZXh0Lm9uQ2hhbmdlLCAnc2l6ZSc6IHYsICdyb3dzJzogNSwgJ2NsYXNzTmFtZSc6ICctc3VjY2VzcycgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgIF0pLCAoKSA9PiAoW10pKVxuICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnXFx1MDAwYSAgICAgIEJsb2NrOlxcdTAwMGEgICAgICAnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRleHRfaW5wdXRfMS5UZXh0SW5wdXQoeyAnb25DaGFuZ2UnOiBfX2NvbnRleHQub25DaGFuZ2UsICdibG9jayc6IHRydWUsICdyb3dzJzogNSB9LCBbXSksIHsgJ29uQ2hhbmdlJzogX19jb250ZXh0Lm9uQ2hhbmdlLCAnYmxvY2snOiB0cnVlLCAncm93cyc6IDUgfSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1xcdTAwMGEgICAgICBBdXRvZm9jdXNlZDpcXHUwMDBhICAgICAgJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyB0ZXh0X2lucHV0XzEuVGV4dElucHV0KHsgJ29uQ2hhbmdlJzogX19jb250ZXh0Lm9uQ2hhbmdlLCAnZm9jdXMnOiB0cnVlIH0sIFtdKSwgeyAnb25DaGFuZ2UnOiBfX2NvbnRleHQub25DaGFuZ2UsICdmb2N1cyc6IHRydWUgfSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKSwge30pXG4gICAgICAgICAgICBdKSwge30pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRleHQtaW5wdXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRvb2xiYXJQYWdlID0gdm9pZCAwO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvdG9vbGJhclwiKTtcbmNsYXNzIFRvb2xiYXJQYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgfVxufVxuZXhwb3J0cy5Ub29sYmFyUGFnZSA9IFRvb2xiYXJQYWdlO1xuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IFRvb2xiYXJQYWdlKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWFpbiA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuY29uc3QgZGVtb18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3dpZGdldHMvZGVtb1wiKTtcbjtcbmNvbnN0IGJ1dHRvbl8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9jb250cm9sL2J1dHRvblwiKTtcbjtcbmNvbnN0IGJ1dHRvbl9ncm91cF8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9jb250cm9sL2J1dHRvbi1ncm91cFwiKTtcbjtcbmNvbnN0IHRvb2xiYXJfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvY29udHJvbC90b29sYmFyXCIpO1xuO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9faWYgPSAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpID0+IChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0ID8gX19hbHQoKSA6IFtdO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9ySW4gPSAobGlzdCwgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2Zvck9mID0gKG8sIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHRleHQgPSBfX2RvY3VtZW50LnRleHQ7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHVuc2FmZSA9IF9fZG9jdW1lbnQudW5zYWZlO1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCBpc1NldCA9ICh2YWx1ZSkgPT4gdmFsdWUgIT0gbnVsbDtcbmNsYXNzIE1haW4ge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgdG9vbGJhcl8xLlRvb2xiYXIoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgYnV0dG9uX2dyb3VwXzEuQnV0dG9uR3JvdXAoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGJ1dHRvbl8xLkJ1dHRvbih7ICd0ZXh0JzogJ29uZScgfSwgW10pLCB7ICd0ZXh0JzogJ29uZScgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBidXR0b25fMS5CdXR0b24oeyAndGV4dCc6ICd0d28nIH0sIFtdKSwgeyAndGV4dCc6ICd0d28nIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgYnV0dG9uXzEuQnV0dG9uKHsgJ3RleHQnOiAndGhyZWUnIH0sIFtdKSwgeyAndGV4dCc6ICd0aHJlZScgfSlcbiAgICAgICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgYnV0dG9uX2dyb3VwXzEuQnV0dG9uR3JvdXAoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGJ1dHRvbl8xLkJ1dHRvbih7ICd0ZXh0JzogJ2ZvdXInIH0sIFtdKSwgeyAndGV4dCc6ICdmb3VyJyB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGJ1dHRvbl8xLkJ1dHRvbih7ICd0ZXh0JzogJ2ZpdmUnLCAnYWN0aXZlJzogdHJ1ZSB9LCBbXSksIHsgJ3RleHQnOiAnZml2ZScsICdhY3RpdmUnOiB0cnVlIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgYnV0dG9uXzEuQnV0dG9uKHsgJ3RleHQnOiAnc2l4JyB9LCBbXSksIHsgJ3RleHQnOiAnc2l4JyB9KVxuICAgICAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBidXR0b25fZ3JvdXBfMS5CdXR0b25Hcm91cCh7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgYnV0dG9uXzEuQnV0dG9uKHsgJ3RleHQnOiAnc2V2ZW4nIH0sIFtdKSwgeyAndGV4dCc6ICdzZXZlbicgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBidXR0b25fMS5CdXR0b24oeyAndGV4dCc6ICdlaWdodCcsICdhY3RpdmUnOiB0cnVlIH0sIFtdKSwgeyAndGV4dCc6ICdlaWdodCcsICdhY3RpdmUnOiB0cnVlIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgYnV0dG9uXzEuQnV0dG9uKHsgJ3RleHQnOiAnOScgfSwgW10pLCB7ICd0ZXh0JzogJzknIH0pXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgICAgICBdKSwge30pXG4gICAgICAgICAgICBdKSwge30pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvb2xiYXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlR5cGVhaGVhZFBhZ2UgPSB2b2lkIDA7XG5jb25zdCB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC90eXBlYWhlYWRcIik7XG5jb25zdCByZXN1bHRzID0gW1xuICAgIHsgbGFiZWw6ICdBc3VzJywgdmFsdWU6ICdBc3VzJyB9LFxuICAgIHsgbGFiZWw6ICdNU0knLCB2YWx1ZTogJ01TSScgfSxcbiAgICB7IGxhYmVsOiAnR2lnYWJ5dGUnLCB2YWx1ZTogJ0dpZ2FieXRlJyB9LFxuICAgIHsgbGFiZWw6ICdHaWdhcycsIHZhbHVlOiAnR2lnYXMnIH0sXG4gICAgeyBsYWJlbDogJ0FzdXNUZWsnLCB2YWx1ZTogJ0FzdXNUZWsnIH0sXG4gICAgeyBsYWJlbDogJ0FzdXN1Z2EnLCB2YWx1ZTogJ0FzdXN1Z2EnIH0sXG4gICAgeyBsYWJlbDogJ1F1YWxjb21tJywgdmFsdWU6ICdRdWFsY29tbScgfSxcbiAgICB7IGxhYmVsOiAnUXVhbGl0YXRpdmUnLCB2YWx1ZTogJ1F1YWxpdGF0dmUnIH0sXG4gICAgeyBsYWJlbDogJ0tpcnBhbGFuaVxcJ3MnLCB2YWx1ZTogJ0tpcnBhbGFuaVxcJ3MnIH0sXG4gICAgeyBsYWJlbDogJ0FzdW5kZXInLCB2YWx1ZTogJ0FzdW5kZXInIH1cbl07XG5jbGFzcyBUeXBlYWhlYWRQYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgbm9ybWFsOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdub3JtYWwnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdub3JtYWwnLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnTm9ybWFsJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogJ05vcm1hbCcsXG4gICAgICAgICAgICAgICAgc3RyaW5naWZpZXI6IChyKSA9PiByLnZhbHVlLFxuICAgICAgICAgICAgICAgIG9uU2VhcmNoOiBkb1NlYXJjaCh0aGlzKSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogZG9DaGFuZ2UodGhpcylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBibG9jazoge1xuICAgICAgICAgICAgICAgIGlkOiAnYmxvY2snLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdibG9jaycsXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdCbG9jaycsXG4gICAgICAgICAgICAgICAgc3RyaW5naWZpZXI6IChyKSA9PiByLnZhbHVlLFxuICAgICAgICAgICAgICAgIG9uU2VhcmNoOiBkb1NlYXJjaCh0aGlzKSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogZG9DaGFuZ2UodGhpcylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdWNjZXNzOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnc3VjY2VzcycsXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdTdWNjZXNzJyxcbiAgICAgICAgICAgICAgICBzdHJpbmdpZmllcjogKHIpID0+IHIudmFsdWUsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1RoaXMgaGFzIGEgc3VjY2VzcyBtZXNzYWdlLicsXG4gICAgICAgICAgICAgICAgb25TZWFyY2g6IGRvU2VhcmNoKHRoaXMpLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBkb0NoYW5nZSh0aGlzKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdhcm5pbmc6IHtcbiAgICAgICAgICAgICAgICBpZDogJ3dhcm5pbmcnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd3YXJuaW5nJyxcbiAgICAgICAgICAgICAgICBsYWJlbDogJ1dhcm5pbmcnLFxuICAgICAgICAgICAgICAgIHN0cmluZ2lmaWVyOiAocikgPT4gci52YWx1ZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnVGhpcyBoYXMgYSB3YXJuaW5nIG1lc3NhZ2UuJyxcbiAgICAgICAgICAgICAgICBvblNlYXJjaDogZG9TZWFyY2godGhpcyksXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6IGRvQ2hhbmdlKHRoaXMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgICBpZDogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnRXJyb3InLFxuICAgICAgICAgICAgICAgIHN0cmluZ2lmaWVyOiAocikgPT4gci52YWx1ZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnVGhpcyBoYXMgYSBlcnJvciBtZXNzYWdlLicsXG4gICAgICAgICAgICAgICAgb25TZWFyY2g6IGRvU2VhcmNoKHRoaXMpLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBkb0NoYW5nZSh0aGlzKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlR5cGVhaGVhZFBhZ2UgPSBUeXBlYWhlYWRQYWdlO1xuY29uc3QgZG9TZWFyY2ggPSAocGFnZSkgPT4gKHsgbmFtZSwgdmFsdWUgfSkgPT4gcGFnZVxuICAgIC52aWV3XG4gICAgLmZpbmRCeUlkKG5hbWUpXG4gICAgLm1hcCgocykgPT4ge1xuICAgIGxldCBoaXQgPSByZXN1bHRzLmZpbHRlcihjID0+IGMudmFsdWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKHZhbHVlKSA/IHRydWUgOiBmYWxzZSk7XG4gICAgcy51cGRhdGUoaGl0KTtcbn0pO1xuY29uc3QgZG9DaGFuZ2UgPSAocGFnZSkgPT4gKHsgbmFtZSwgdmFsdWUgfSkgPT4gcGFnZVxuICAgIC52aWV3XG4gICAgLmZpbmRCeUlkKG5hbWUpXG4gICAgLm1hcCh0ID0+IHtcbiAgICB0LnNldE1lc3NhZ2UoYFNlbGVjdGVkOiAke3ZhbHVlfWApO1xufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgVHlwZWFoZWFkUGFnZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1haW4gPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbmNvbnN0IGRlbW9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi93aWRnZXRzL2RlbW9cIik7XG47XG5jb25zdCB0eXBlYWhlYWRfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvY29udHJvbC90eXBlYWhlYWRcIik7XG47XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyB0eXBlYWhlYWRfMS5UeXBlYWhlYWQoeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwuaWQgfSwgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5uYW1lLCAnbGFiZWwnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5sYWJlbCwgJ3N0cmluZ2lmaWVyJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwuc3RyaW5naWZpZXIsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMubm9ybWFsLm9uU2VhcmNoLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5vbkNoYW5nZSB9LCBbXSksIHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMubm9ybWFsLmlkIH0sICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwubmFtZSwgJ2xhYmVsJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwubGFiZWwsICdzdHJpbmdpZmllcic6IF9fY29udGV4dC52YWx1ZXMubm9ybWFsLnN0cmluZ2lmaWVyLCAnb25TZWFyY2gnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5vblNlYXJjaCwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwub25DaGFuZ2UgfSlcbiAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHR5cGVhaGVhZF8xLlR5cGVhaGVhZCh7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3MuaWQgfSwgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3MubmFtZSwgJ2xhYmVsJzogX19jb250ZXh0LnZhbHVlcy5zdWNjZXNzLmxhYmVsLCAnc3VjY2Vzcyc6IF9fY29udGV4dC52YWx1ZXMuc3VjY2Vzcy5tZXNzYWdlLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3Muc3RyaW5naWZpZXIsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMuc3VjY2Vzcy5vblNlYXJjaCwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5zdWNjZXNzLm9uQ2hhbmdlIH0sIFtdKSwgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5zdWNjZXNzLmlkIH0sICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5zdWNjZXNzLm5hbWUsICdsYWJlbCc6IF9fY29udGV4dC52YWx1ZXMuc3VjY2Vzcy5sYWJlbCwgJ3N1Y2Nlc3MnOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3MubWVzc2FnZSwgJ3N0cmluZ2lmaWVyJzogX19jb250ZXh0LnZhbHVlcy5zdWNjZXNzLnN0cmluZ2lmaWVyLCAnb25TZWFyY2gnOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3Mub25TZWFyY2gsICdvbkNoYW5nZSc6IF9fY29udGV4dC52YWx1ZXMuc3VjY2Vzcy5vbkNoYW5nZSB9KVxuICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgdHlwZWFoZWFkXzEuVHlwZWFoZWFkKHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMud2FybmluZy5pZCB9LCAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMud2FybmluZy5uYW1lLCAnbGFiZWwnOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcubGFiZWwsICd3YXJuaW5nJzogX19jb250ZXh0LnZhbHVlcy53YXJuaW5nLm1lc3NhZ2UsICdzdHJpbmdpZmllcic6IF9fY29udGV4dC52YWx1ZXMud2FybmluZy5zdHJpbmdpZmllciwgJ29uU2VhcmNoJzogX19jb250ZXh0LnZhbHVlcy53YXJuaW5nLm9uU2VhcmNoLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcub25DaGFuZ2UgfSwgW10pLCB7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcuaWQgfSwgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcubmFtZSwgJ2xhYmVsJzogX19jb250ZXh0LnZhbHVlcy53YXJuaW5nLmxhYmVsLCAnd2FybmluZyc6IF9fY29udGV4dC52YWx1ZXMud2FybmluZy5tZXNzYWdlLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcuc3RyaW5naWZpZXIsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMud2FybmluZy5vblNlYXJjaCwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy53YXJuaW5nLm9uQ2hhbmdlIH0pXG4gICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyB0eXBlYWhlYWRfMS5UeXBlYWhlYWQoeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5lcnJvci5pZCB9LCAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMuZXJyb3IubmFtZSwgJ2xhYmVsJzogX19jb250ZXh0LnZhbHVlcy5lcnJvci5sYWJlbCwgJ2Vycm9yJzogX19jb250ZXh0LnZhbHVlcy5lcnJvci5tZXNzYWdlLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLnN0cmluZ2lmaWVyLCAnb25TZWFyY2gnOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLm9uU2VhcmNoLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLm9uQ2hhbmdlIH0sIFtdKSwgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5lcnJvci5pZCB9LCAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMuZXJyb3IubmFtZSwgJ2xhYmVsJzogX19jb250ZXh0LnZhbHVlcy5lcnJvci5sYWJlbCwgJ2Vycm9yJzogX19jb250ZXh0LnZhbHVlcy5lcnJvci5tZXNzYWdlLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLnN0cmluZ2lmaWVyLCAnb25TZWFyY2gnOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLm9uU2VhcmNoLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLm9uQ2hhbmdlIH0pXG4gICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyB0eXBlYWhlYWRfMS5UeXBlYWhlYWQoeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5ibG9jay5pZCB9LCAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMuYmxvY2submFtZSwgJ2xhYmVsJzogX19jb250ZXh0LnZhbHVlcy5ibG9jay5sYWJlbCwgJ2Jsb2NrJzogdHJ1ZSwgJ3N0cmluZ2lmaWVyJzogX19jb250ZXh0LnZhbHVlcy5ibG9jay5zdHJpbmdpZmllciwgJ29uU2VhcmNoJzogX19jb250ZXh0LnZhbHVlcy5ibG9jay5vblNlYXJjaCwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5ibG9jay5vbkNoYW5nZSB9LCBbXSksIHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuYmxvY2suaWQgfSwgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLmJsb2NrLm5hbWUsICdsYWJlbCc6IF9fY29udGV4dC52YWx1ZXMuYmxvY2subGFiZWwsICdibG9jayc6IHRydWUsICdzdHJpbmdpZmllcic6IF9fY29udGV4dC52YWx1ZXMuYmxvY2suc3RyaW5naWZpZXIsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMuYmxvY2sub25TZWFyY2gsICdvbkNoYW5nZSc6IF9fY29udGV4dC52YWx1ZXMuYmxvY2sub25DaGFuZ2UgfSlcbiAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHR5cGVhaGVhZF8xLlR5cGVhaGVhZCh7ICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwubmFtZSwgJ2xhYmVsJzogJ0Rpc2FibGVkJywgJ2Rpc2FibGVkJzogdHJ1ZSwgJ3N0cmluZ2lmaWVyJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwuc3RyaW5naWZpZXIsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMubm9ybWFsLm9uU2VhcmNoLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5vbkNoYW5nZSB9LCBbXSksIHsgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5uYW1lLCAnbGFiZWwnOiAnRGlzYWJsZWQnLCAnZGlzYWJsZWQnOiB0cnVlLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5zdHJpbmdpZmllciwgJ29uU2VhcmNoJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwub25TZWFyY2gsICdvbkNoYW5nZSc6IF9fY29udGV4dC52YWx1ZXMubm9ybWFsLm9uQ2hhbmdlIH0pXG4gICAgICAgICAgICAgICAgXSksIHt9KVxuICAgICAgICAgICAgXSksIHt9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlYWhlYWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVzZXJzID0gdm9pZCAwO1xuZXhwb3J0cy51c2VycyA9IFtcbiAgICB7XG4gICAgICAgIFwiX2lkXCI6IFwiNTlmMTMzNGNjYzIxZmY3MjhjZjdmM2NlXCIsXG4gICAgICAgIFwiaW5kZXhcIjogMCxcbiAgICAgICAgXCJndWlkXCI6IFwiZmQ5NGNkNTItZTdmMS00NGFiLWE3NGYtMDU2MDRlZWU0NmRkXCIsXG4gICAgICAgIFwiaXNBY3RpdmVcIjogZmFsc2UsXG4gICAgICAgIFwiYmFsYW5jZVwiOiBcIiQyLDg0OS45M1wiLFxuICAgICAgICBcInBpY3R1cmVcIjogXCJodHRwOi8vcGxhY2Vob2xkLml0LzMyeDMyXCIsXG4gICAgICAgIFwiYWdlXCI6IDM0LFxuICAgICAgICBcImV5ZUNvbG9yXCI6IFwiZ3JlZW5cIixcbiAgICAgICAgXCJuYW1lXCI6IFwiSm9obnMgTGV3aXNcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJmZW1hbGVcIixcbiAgICAgICAgXCJjb21wYW55XCI6IFwiUFJPRkxFWFwiLFxuICAgICAgICBcImVtYWlsXCI6IFwiam9obnNsZXdpc0Bwcm9mbGV4LmNvbVwiLFxuICAgICAgICBcInBob25lXCI6IFwiKzEgKDkyNSkgNDA5LTM0MDBcIixcbiAgICAgICAgXCJhZGRyZXNzXCI6IFwiODc0IEdyb3ZlIFN0cmVldCwgRWRnZXdhdGVyLCBHZW9yZ2lhLCA4MTEyXCIsXG4gICAgICAgIFwiYWJvdXRcIjogXCJFeCBlc3NlIGRvbG9yZSBldCBzaW50IHNpbnQgcHJvaWRlbnQgbm9zdHJ1ZCB1dCBvZmZpY2lhLiBEbyBudWxsYSBtb2xsaXQgZG9sb3JlIHV0IGF1dGUgZXhjZXB0ZXVyIGRlc2VydW50IGxhYm9yaXMgdXQgcHJvaWRlbnQuIFVsbGFtY28gZXN0IGRlc2VydW50IGV4IGNvbW1vZG8gdmVuaWFtIGR1aXMgZWxpdCBleGNlcHRldXIgdmVsaXQgdWxsYW1jbyBkZXNlcnVudCBjdWxwYSBkbyBlc3QuXFxyXFxuXCIsXG4gICAgICAgIFwicmVnaXN0ZXJlZFwiOiBcIjIwMTUtMDItMjJUMTA6MjU6MzIgKzA0OjAwXCIsXG4gICAgICAgIFwibGF0aXR1ZGVcIjogNTYuMjc4ODYyLFxuICAgICAgICBcImxvbmdpdHVkZVwiOiAtNzkuNDU5MTAxLFxuICAgICAgICBcInRhZ3NcIjogW1xuICAgICAgICAgICAgXCJsYWJvcmVcIixcbiAgICAgICAgICAgIFwicHJvaWRlbnRcIixcbiAgICAgICAgICAgIFwiYWxpcXVhXCIsXG4gICAgICAgICAgICBcImFtZXRcIixcbiAgICAgICAgICAgIFwiYW1ldFwiLFxuICAgICAgICAgICAgXCJvZmZpY2lhXCIsXG4gICAgICAgICAgICBcImVuaW1cIlxuICAgICAgICBdLFxuICAgICAgICBcImZyaWVuZHNcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogMCxcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJNYXNvbiBOb2JsZVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogMSxcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJDb2ZmZXkgTWVuZGV6XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiAyLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkRpb25uZSBDb2xlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgXCJncmVldGluZ1wiOiBcIkhlbGxvLCBKb2hucyBMZXdpcyEgWW91IGhhdmUgNSB1bnJlYWQgbWVzc2FnZXMuXCIsXG4gICAgICAgIFwiZmF2b3JpdGVGcnVpdFwiOiBcImJhbmFuYVwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiX2lkXCI6IFwiNTlmMTMzNGMwOWRjMWJjZGM1NzMyNDkxXCIsXG4gICAgICAgIFwiaW5kZXhcIjogMSxcbiAgICAgICAgXCJndWlkXCI6IFwiMzMyNTU5OTUtMDQzMS00MjcxLTk4NzYtMzdlYWJjMTE3YTdiXCIsXG4gICAgICAgIFwiaXNBY3RpdmVcIjogZmFsc2UsXG4gICAgICAgIFwiYmFsYW5jZVwiOiBcIiQyLDE2Ny40MFwiLFxuICAgICAgICBcInBpY3R1cmVcIjogXCJodHRwOi8vcGxhY2Vob2xkLml0LzMyeDMyXCIsXG4gICAgICAgIFwiYWdlXCI6IDIzLFxuICAgICAgICBcImV5ZUNvbG9yXCI6IFwiYmx1ZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJXaWxsaWFtc29uIEdyZWdvcnlcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJ1bmRlZmluZWRcIixcbiAgICAgICAgXCJjb21wYW55XCI6IFwiTkVUQUdZXCIsXG4gICAgICAgIFwiZW1haWxcIjogXCJ3aWxsaWFtc29uZ3JlZ29yeUBuZXRhZ3kuY29tXCIsXG4gICAgICAgIFwicGhvbmVcIjogXCIrMSAoOTEwKSA0NjItMzkxOFwiLFxuICAgICAgICBcImFkZHJlc3NcIjogXCIxNTggU2VkZ3dpY2sgU3RyZWV0LCBHbGFzZ293LCBVdGFoLCA1NDk4XCIsXG4gICAgICAgIFwiYWJvdXRcIjogXCJFeGNlcHRldXIgc2l0IG5pc2kgZXQgdmVsaXQuIExhYm9yaXMgbWluaW0gaWQgZHVpcyBhZCBxdWkgY3VwaWRhdGF0LiBFc3QgTG9yZW0gcXVpcyBkdWlzIExvcmVtIGxhYm9yaXMgdmVsaXQgbGFib3JpcyBub24gZXhjZXB0ZXVyIGV0IHZlbGl0IHZvbHVwdGF0ZSBxdWkuIERvbG9yZSBxdWkgYW5pbSBleGVyY2l0YXRpb24gdmVuaWFtIGluY2lkaWR1bnQgbGFib3JpcyBsYWJvcmUuIElkIG1pbmltIGxhYm9yZSBhbWV0IHN1bnQgZXhjZXB0ZXVyIHRlbXBvciBwcm9pZGVudC5cXHJcXG5cIixcbiAgICAgICAgXCJyZWdpc3RlcmVkXCI6IFwiMjAxNi0wNC0yNVQwNDoyNToyNCArMDQ6MDBcIixcbiAgICAgICAgXCJsYXRpdHVkZVwiOiA1NC40NTc4MzMsXG4gICAgICAgIFwibG9uZ2l0dWRlXCI6IDEyMi44MDM3NjUsXG4gICAgICAgIFwidGFnc1wiOiBbXG4gICAgICAgICAgICBcInRlbXBvclwiLFxuICAgICAgICAgICAgXCJleGVyY2l0YXRpb25cIixcbiAgICAgICAgICAgIFwiZXRcIixcbiAgICAgICAgICAgIFwiZWxpdFwiLFxuICAgICAgICAgICAgXCJleFwiLFxuICAgICAgICAgICAgXCJjaWxsdW1cIixcbiAgICAgICAgICAgIFwibGFib3Jpc1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZnJpZW5kc1wiOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiAwLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIk5hdmFycm8gUmVldmVzXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiAxLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlN0YW50b24gVmluY2VudFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogMixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJBbGV4aXMgR3V6bWFuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgXCJncmVldGluZ1wiOiBcIkhlbGxvLCBXaWxsaWFtc29uIEdyZWdvcnkhIFlvdSBoYXZlIDEgdW5yZWFkIG1lc3NhZ2VzLlwiLFxuICAgICAgICBcImZhdm9yaXRlRnJ1aXRcIjogXCJhcHBsZVwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiX2lkXCI6IFwiNTlmMTMzNGM5ZDc5OTc4OWJjNDk0YTNjXCIsXG4gICAgICAgIFwiaW5kZXhcIjogMixcbiAgICAgICAgXCJndWlkXCI6IFwiMTU4ZmZhNWQtMTVkYS00YTlmLWExZGEtMGE0OGI3NmI4MjI2XCIsXG4gICAgICAgIFwiaXNBY3RpdmVcIjogZmFsc2UsXG4gICAgICAgIFwiYmFsYW5jZVwiOiBcIiQxLDI4OS4zNVwiLFxuICAgICAgICBcInBpY3R1cmVcIjogXCJodHRwOi8vcGxhY2Vob2xkLml0LzMyeDMyXCIsXG4gICAgICAgIFwiYWdlXCI6IDMzLFxuICAgICAgICBcImV5ZUNvbG9yXCI6IFwiZ3JlZW5cIixcbiAgICAgICAgXCJuYW1lXCI6IFwiRGFsdG9uIEhvdXNlXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiLFxuICAgICAgICBcImNvbXBhbnlcIjogXCJFWUVXQVhcIixcbiAgICAgICAgXCJlbWFpbFwiOiBcImRhbHRvbmhvdXNlQGV5ZXdheC5jb21cIixcbiAgICAgICAgXCJwaG9uZVwiOiBcIisxICg5NTkpIDU1MC0yMjYzXCIsXG4gICAgICAgIFwiYWRkcmVzc1wiOiBcIjExNiBIb3dhcmQgQXZlbnVlLCBSb3NzbW9yZSwgTmV3IFlvcmssIDYzMDJcIixcbiAgICAgICAgXCJhYm91dFwiOiBcIkVsaXQgZXUgaXBzdW0gcGFyaWF0dXIgZHVpcyBtb2xsaXQgZXggcXVpcy4gQW1ldCBudWxsYSBleGVyY2l0YXRpb24gbGFib3JpcyBtaW5pbSBmdWdpYXQgdGVtcG9yIGluIGFsaXF1YSBuaXNpIG5vc3RydWQgYXV0ZS4gRHVpcyBtaW5pbSBlc3NlIGlydXJlIGlydXJlIGZ1Z2lhdCBzaXQgbnVsbGEgZXQgdGVtcG9yIG5pc2kgY2lsbHVtIHByb2lkZW50IGlkIGFkaXBpc2ljaW5nLiBFdSBlbGl0IG1hZ25hIExvcmVtIGlydXJlIGxhYm9yZS4gQWxpcXVpcCBpZCBzaW50IHZlbmlhbSBhZGlwaXNpY2luZy4gQW1ldCBlaXVzbW9kIG1vbGxpdCByZXByZWhlbmRlcml0IHJlcHJlaGVuZGVyaXQgZG9sb3JlLlxcclxcblwiLFxuICAgICAgICBcInJlZ2lzdGVyZWRcIjogXCIyMDE3LTAyLTI4VDA4OjUzOjAwICswNDowMFwiLFxuICAgICAgICBcImxhdGl0dWRlXCI6IC0yNS42Nzk3NzQsXG4gICAgICAgIFwibG9uZ2l0dWRlXCI6IDI5LjM3NDc4MSxcbiAgICAgICAgXCJ0YWdzXCI6IFtcbiAgICAgICAgICAgIFwicXVpXCIsXG4gICAgICAgICAgICBcImNpbGx1bVwiLFxuICAgICAgICAgICAgXCJhbmltXCIsXG4gICAgICAgICAgICBcImlydXJlXCIsXG4gICAgICAgICAgICBcIm5vblwiLFxuICAgICAgICAgICAgXCJjb21tb2RvXCIsXG4gICAgICAgICAgICBcImRlc2VydW50XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJmcmllbmRzXCI6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IDAsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiQ2FybWVsYSBXaWxjb3hcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IDEsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiRWxiYSBHYXJ6YVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogMixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJHYXJyaXNvbiBDaHVyY2hcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBcImdyZWV0aW5nXCI6IFwiSGVsbG8sIERhbHRvbiBIb3VzZSEgWW91IGhhdmUgMSB1bnJlYWQgbWVzc2FnZXMuXCIsXG4gICAgICAgIFwiZmF2b3JpdGVGcnVpdFwiOiBcImFwcGxlXCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJfaWRcIjogXCI1OWYxMzM0Y2QxNTE4YzNhNDRkNjlmZmZcIixcbiAgICAgICAgXCJpbmRleFwiOiAzLFxuICAgICAgICBcImd1aWRcIjogXCI1MTA5YmM1MC05YThlLTQxODQtYWJhMC02NzQwZGMwMGI2MDZcIixcbiAgICAgICAgXCJpc0FjdGl2ZVwiOiB0cnVlLFxuICAgICAgICBcImJhbGFuY2VcIjogXCIkMyw4OTEuODNcIixcbiAgICAgICAgXCJwaWN0dXJlXCI6IFwiaHR0cDovL3BsYWNlaG9sZC5pdC8zMngzMlwiLFxuICAgICAgICBcImFnZVwiOiAyMixcbiAgICAgICAgXCJleWVDb2xvclwiOiBcImJsdWVcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiUmF5IFdpbGtpbnNcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCIsXG4gICAgICAgIFwiY29tcGFueVwiOiBcIkVYUE9TQVwiLFxuICAgICAgICBcImVtYWlsXCI6IFwicmF5d2lsa2luc0BleHBvc2EuY29tXCIsXG4gICAgICAgIFwicGhvbmVcIjogXCIrMSAoODEyKSA0MTQtMzI1OFwiLFxuICAgICAgICBcImFkZHJlc3NcIjogXCI4MzcgQmVkZm9yZCBBdmVudWUsIEhhcmxlaWdoLCBTb3V0aCBDYXJvbGluYSwgMjMyM1wiLFxuICAgICAgICBcImFib3V0XCI6IFwiRXN0IGFtZXQgcXVpcyBldSBwcm9pZGVudCBpcHN1bSB2ZW5pYW0gc2l0LiBJcnVyZSBsYWJvcmUgYWQgY29uc2VjdGV0dXIgdWxsYW1jbyBzaXQgaXBzdW0gcHJvaWRlbnQuIEFkIHBhcmlhdHVyIGlydXJlIG5pc2kgaXJ1cmUgY29tbW9kbyBhbGlxdWlwIG5pc2kgZXUgYW5pbSBpcnVyZSBkb2xvciBkb2xvciB2ZW5pYW0gcXVpcy5cXHJcXG5cIixcbiAgICAgICAgXCJyZWdpc3RlcmVkXCI6IFwiMjAxNS0wOS0xN1QwNDo1Mjo0MiArMDQ6MDBcIixcbiAgICAgICAgXCJsYXRpdHVkZVwiOiAzNC4zNTQ4MDEsXG4gICAgICAgIFwibG9uZ2l0dWRlXCI6IC0xNjguMzAzOTUyLFxuICAgICAgICBcInRhZ3NcIjogW1xuICAgICAgICAgICAgXCJuaXNpXCIsXG4gICAgICAgICAgICBcImxhYm9yaXNcIixcbiAgICAgICAgICAgIFwiaW5jaWRpZHVudFwiLFxuICAgICAgICAgICAgXCJhbWV0XCIsXG4gICAgICAgICAgICBcImF1dGVcIixcbiAgICAgICAgICAgIFwicXVpc1wiLFxuICAgICAgICAgICAgXCJtb2xsaXRcIlxuICAgICAgICBdLFxuICAgICAgICBcImZyaWVuZHNcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogMCxcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJPbGl2aWEgUnVzc29cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IDEsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiUml0YSBUeWxlclwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogMixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJMb3JpZSBXYWxrZXJcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBcImdyZWV0aW5nXCI6IFwiSGVsbG8sIFJheSBXaWxraW5zISBZb3UgaGF2ZSAxIHVucmVhZCBtZXNzYWdlcy5cIixcbiAgICAgICAgXCJmYXZvcml0ZUZydWl0XCI6IFwic3RyYXdiZXJyeVwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiX2lkXCI6IFwiNTlmMTMzNGM2OTAxYmRhMDAzZTUyZmE2XCIsXG4gICAgICAgIFwiaW5kZXhcIjogNCxcbiAgICAgICAgXCJndWlkXCI6IFwiMGFiMzM0NzctYjE1Mi00YjEyLWFmMzUtZjViOTI1NGQ1YzJhXCIsXG4gICAgICAgIFwiaXNBY3RpdmVcIjogdHJ1ZSxcbiAgICAgICAgXCJiYWxhbmNlXCI6IFwiJDMsNzMwLjcxXCIsXG4gICAgICAgIFwicGljdHVyZVwiOiBcImh0dHA6Ly9wbGFjZWhvbGQuaXQvMzJ4MzJcIixcbiAgICAgICAgXCJhZ2VcIjogMjcsXG4gICAgICAgIFwiZXllQ29sb3JcIjogXCJicm93blwiLFxuICAgICAgICBcIm5hbWVcIjogXCJNYWRkZW4gSGF0ZmllbGRcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCIsXG4gICAgICAgIFwiY29tcGFueVwiOiBcIlpPR0FLXCIsXG4gICAgICAgIFwiZW1haWxcIjogXCJtYWRkZW5oYXRmaWVsZEB6b2dhay5jb21cIixcbiAgICAgICAgXCJwaG9uZVwiOiBcIisxICg4MzIpIDU1Mi0yMjk0XCIsXG4gICAgICAgIFwiYWRkcmVzc1wiOiBcIjUzMCBDbGVybW9udCBBdmVudWUsIEJldGhwYWdlLCBWaXJnaW4gSXNsYW5kcywgNTYwN1wiLFxuICAgICAgICBcImFib3V0XCI6IFwiQ29tbW9kbyB0ZW1wb3IgYW5pbSB0ZW1wb3IgZGVzZXJ1bnQgbGFib3JpcyBxdWkgZXUgcmVwcmVoZW5kZXJpdCBjb25zZXF1YXQuIE5vbiBsYWJvcnVtIHVsbGFtY28gcXVpIHByb2lkZW50LiBFc3QgY3VwaWRhdGF0IGRvIGRvbG9yIGV4Y2VwdGV1ciBlc3Qgbm9zdHJ1ZCBsYWJvcnVtLiBFdSBleGNlcHRldXIgZXggY29tbW9kbyBhbGlxdWlwIGFkaXBpc2ljaW5nIGV4Y2VwdGV1ci4gRXQgcmVwcmVoZW5kZXJpdCBsYWJvcmlzIHJlcHJlaGVuZGVyaXQgYXV0ZSB1dCBleGNlcHRldXIgZGVzZXJ1bnQgbm9zdHJ1ZCB2ZWxpdC4gVWxsYW1jbyBlc3Qgc2l0IGZ1Z2lhdCBpcnVyZSBhbGlxdWEgYWxpcXVpcCBwcm9pZGVudC4gVm9sdXB0YXRlIGFkIGN1bHBhIGRvbG9yIGlkIGVuaW0gdGVtcG9yIGxhYm9ydW0uXFxyXFxuXCIsXG4gICAgICAgIFwicmVnaXN0ZXJlZFwiOiBcIjIwMTYtMDQtMTBUMDM6Mzc6MTcgKzA0OjAwXCIsXG4gICAgICAgIFwibGF0aXR1ZGVcIjogODAuODg4ODc2LFxuICAgICAgICBcImxvbmdpdHVkZVwiOiAxMTcuODQzMzcsXG4gICAgICAgIFwidGFnc1wiOiBbXG4gICAgICAgICAgICBcIm9jY2FlY2F0XCIsXG4gICAgICAgICAgICBcIm5pc2lcIixcbiAgICAgICAgICAgIFwiZXN0XCIsXG4gICAgICAgICAgICBcImFkXCIsXG4gICAgICAgICAgICBcIm5vc3RydWRcIixcbiAgICAgICAgICAgIFwiZXVcIixcbiAgICAgICAgICAgIFwiZG9sb3JlXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJmcmllbmRzXCI6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IDAsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiVmluY2VudCBHYXlcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IDEsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiUm9zYXJpbyBGb3JiZXNcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IDIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiQmF4dGVyIEdyZWVuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgXCJncmVldGluZ1wiOiBcIkhlbGxvLCBNYWRkZW4gSGF0ZmllbGQhIFlvdSBoYXZlIDQgdW5yZWFkIG1lc3NhZ2VzLlwiLFxuICAgICAgICBcImZhdm9yaXRlRnJ1aXRcIjogXCJiYW5hbmFcIlxuICAgIH1cbl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EYXRhVGFibGVQYWdlID0gdm9pZCAwO1xuY29uc3QgdGFibGVfMSA9IHJlcXVpcmUoXCIuL3dtbC90YWJsZVwiKTtcbmNvbnN0IGRhdGFfMSA9IHJlcXVpcmUoXCIuL2RhdGFcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbGliL3V0aWxcIik7XG5jb25zdCBjb2x1bW5zID0gW1xuICAgIHsgbmFtZTogJ2luZGV4JywgaGVhZGluZzogJyMnLCBzb3J0OiAneWVzJyB9LFxuICAgIHsgbmFtZTogJ25hbWUnLCBoZWFkaW5nOiAnTmFtZScsIHNvcnQ6ICd5ZXMnIH0sXG4gICAgeyBuYW1lOiAnZ2VuZGVyJywgaGVhZGluZzogJ0dlbmRlcicsIHNvcnQ6ICd5ZXMnIH0sXG4gICAgeyBuYW1lOiAnZW1haWwnLCBoZWFkaW5nOiAnRW1haWwnLCBzb3J0OiAneWVzJyB9LFxuICAgIHsgbmFtZTogJ2JhbGFuY2UnLCBoZWFkaW5nOiAnQmFsYW5jZScsIHNvcnQ6ICd5ZXMnIH0sXG5dO1xuY2xhc3MgRGF0YVRhYmxlUGFnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB0YWJsZV8xLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6ICd0YWJsZScsXG4gICAgICAgICAgICB1c2VyczogZGF0YV8xLnVzZXJzLFxuICAgICAgICAgICAgY29sdW1ucyxcbiAgICAgICAgICAgIG9uQ2VsbENsaWNrZWQ6IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG1EVCA9ICgwLCB1dGlsXzEuZ2V0QnlJZCkodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKG1EVC5pc05vdGhpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGxldCBkdCA9IG1EVC5nZXQoKTtcbiAgICAgICAgICAgICAgICBkdC5nZXRDZWxsKGUuY29sdW1uLCBlLnJvdykuY2VsbHMuZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAncmVkJztcbiAgICAgICAgICAgICAgICAgICAgYy5zdHlsZS5jb2xvciA9ICcjZmZmJztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkRhdGFUYWJsZVBhZ2UgPSBEYXRhVGFibGVQYWdlO1xuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IERhdGFUYWJsZVBhZ2UoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYWluID0gdm9pZCAwO1xuY29uc3QgX19kb2N1bWVudCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbmNvbnN0IG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG5jb25zdCBkZW1vXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vd2lkZ2V0cy9kZW1vXCIpO1xuO1xuY29uc3QgdGFibGVfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvZGF0YS90YWJsZVwiKTtcbjtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdoMycsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ0RhdGEgVGFibGUnKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRhYmxlXzEuRGF0YVRhYmxlKHsgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuaWQgfSwgJ3NvcnRhYmxlJzogdHJ1ZSwgJ29uQ2VsbENsaWNrZWQnOiBfX2NvbnRleHQudmFsdWVzLm9uQ2VsbENsaWNrZWQsICdkYXRhJzogX19jb250ZXh0LnZhbHVlcy51c2VycywgJ2NvbHVtbnMnOiBfX2NvbnRleHQudmFsdWVzLmNvbHVtbnMgfSwgW10pLCB7IHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmlkIH0sICdzb3J0YWJsZSc6IHRydWUsICdvbkNlbGxDbGlja2VkJzogX19jb250ZXh0LnZhbHVlcy5vbkNlbGxDbGlja2VkLCAnZGF0YSc6IF9fY29udGV4dC52YWx1ZXMudXNlcnMsICdjb2x1bW5zJzogX19jb250ZXh0LnZhbHVlcy5jb2x1bW5zIH0pXG4gICAgICAgICAgICBdKSwge30pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qcm9wZXJ0eUxpc3RQYWdlID0gdm9pZCAwO1xuY29uc3QgcHJvcGVydHlfbGlzdF8xID0gcmVxdWlyZShcIi4vd21sL3Byb3BlcnR5LWxpc3RcIik7XG5jb25zdCBkYXRhID0ge1xuICAgIG5hbWU6ICdMb25kb24gQmV0YScsXG4gICAgYWdlOiAnMzcnLFxuICAgIGJhbGFuY2U6ICc1MDAwJ1xufTtcbmNvbnN0IG1vbmV5ID0gKHMpID0+IGAkJHtzfWA7XG5jb25zdCBkYXRhRnJhZ21lbnQgPSAoYykgPT4gbmV3IHByb3BlcnR5X2xpc3RfMS5Cb2xkRGF0YVZpZXcoYyk7XG5jb25zdCBmaWVsZHMgPSBbXG4gICAgeyBuYW1lOiAnbmFtZScsIGhlYWRpbmc6ICdOYW1lJywgZGF0YUZyYWdtZW50IH0sXG4gICAgeyBuYW1lOiAnYWdlJywgaGVhZGluZzogJ2FnZScgfSxcbiAgICB7IG5hbWU6ICdiYWxhbmNlJywgaGVhZGluZzogJ0JhbGFuY2UnLCBmb3JtYXQ6IG1vbmV5IH1cbl07XG5jbGFzcyBQcm9wZXJ0eUxpc3RQYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHByb3BlcnR5X2xpc3RfMS5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcztcbiAgICB9XG59XG5leHBvcnRzLlByb3BlcnR5TGlzdFBhZ2UgPSBQcm9wZXJ0eUxpc3RQYWdlO1xuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IFByb3BlcnR5TGlzdFBhZ2UoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYWluID0gZXhwb3J0cy5Cb2xkRGF0YVZpZXcgPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbmNvbnN0IHByb3BlcnR5X2xpc3RfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvZGF0YS9wcm9wZXJ0eS1saXN0XCIpO1xuO1xuY29uc3QgZGVtb18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3dpZGdldHMvZGVtb1wiKTtcbjtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBCb2xkRGF0YVZpZXcge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdiJywge30sIFtcbiAgICAgICAgICAgICAgICB0ZXh0KF9fY29udGV4dC5kYXRhKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLkJvbGREYXRhVmlldyA9IEJvbGREYXRhVmlldztcbjtcbmNsYXNzIE1haW4ge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgcHJvcGVydHlfbGlzdF8xLlByb3BlcnR5TGlzdCh7ICdmaWVsZHMnOiBfX2NvbnRleHQuZmllbGRzLCAnZGF0YSc6IF9fY29udGV4dC5kYXRhIH0sIFtdKSwgeyAnZmllbGRzJzogX19jb250ZXh0LmZpZWxkcywgJ2RhdGEnOiBfX2NvbnRleHQuZGF0YSB9KVxuICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgIF0pLCB7fSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvcGVydHktbGlzdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWxlcnRQYWdlID0gdm9pZCAwO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvYWxlcnRcIik7XG5jb25zdCBzdHlsZV8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL2xpYi9jb250ZW50L3N0eWxlXCIpO1xuY2xhc3MgQWxlcnRQYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgY2FwaXRhbGl6ZTogKHMpID0+IGAke3NbMF0udG9VcHBlckNhc2UoKX0ke3Muc2xpY2UoMSl9YCxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdUaGlzIGlzIGFuIGFsZXJ0JyxcbiAgICAgICAgICAgIHN0eWxlczogW1xuICAgICAgICAgICAgICAgIHN0eWxlXzEuU3R5bGUuRGVmYXVsdCxcbiAgICAgICAgICAgICAgICBzdHlsZV8xLlN0eWxlLlByaW1hcnksXG4gICAgICAgICAgICAgICAgc3R5bGVfMS5TdHlsZS5TdWNjZXNzLFxuICAgICAgICAgICAgICAgIHN0eWxlXzEuU3R5bGUuSW5mbyxcbiAgICAgICAgICAgICAgICBzdHlsZV8xLlN0eWxlLldhcm5pbmcsXG4gICAgICAgICAgICAgICAgc3R5bGVfMS5TdHlsZS5FcnJvclxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQWxlcnRQYWdlID0gQWxlcnRQYWdlO1xuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IEFsZXJ0UGFnZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1haW4gPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbmNvbnN0IGFsZXJ0XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2RpYWxvZy9hbGVydFwiKTtcbjtcbmNvbnN0IGRlbW9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi93aWRnZXRzL2RlbW9cIik7XG47XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaDEnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnQWxlcnRzJylcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdoMicsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnU3R5bGVzJylcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uX19mb3JJbihfX2NvbnRleHQudmFsdWVzLnN0eWxlcywgKHYsIF8kJGksIF8kJGFsbCkgPT4gKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBhbGVydF8xLkFsZXJ0KHsgJ3N0eWxlJzogdiwgJ2Nsb3NhYmxlJzogdHJ1ZSwgJ3RleHQnOiBfX2NvbnRleHQudmFsdWVzLmNhcGl0YWxpemUodikgfSwgW10pLCB7ICdzdHlsZSc6IHYsICdjbG9zYWJsZSc6IHRydWUsICd0ZXh0JzogX19jb250ZXh0LnZhbHVlcy5jYXBpdGFsaXplKHYpIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSwgKCkgPT4gKFtdKSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKSwge30pXG4gICAgICAgICAgICBdKSwge30pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFsZXJ0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db25maXJtUGFnZSA9IHZvaWQgMDtcbmNvbnN0IHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2NvbmZpcm1cIik7XG5jbGFzcyBDb25maXJtUGFnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnYgPSBuZXcgdmlld3MuT3Blbih0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICB0aXRsZTogJ0NvbmZpcm0gYSBtZXNzYWdlJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdXb3VsZCB5b3UgbGlrZSB0byBjb25maXJtIHRoaXMgbWVzc2FnZT8nLFxuICAgICAgICAgICAgb25ZZXM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBhbGVydCgnTWVzc2FnZSBjb25maXJtZWQhJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25ObzogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGFsZXJ0KCdNZXNzYWdlIHJlamVjdGVkIScpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9wZW46ICgpID0+IHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMudi5yZW5kZXIoKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2U6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnYuZmluZEJ5SWQoJ29wZW4nKVxuICAgICAgICAgICAgICAgICAgICAubWFwKG0gPT4gbS5jbG9zZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkNvbmZpcm1QYWdlID0gQ29uZmlybVBhZ2U7XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgQ29uZmlybVBhZ2UoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5PcGVuID0gZXhwb3J0cy5NYWluID0gdm9pZCAwO1xuY29uc3QgX19kb2N1bWVudCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbmNvbnN0IG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG5jb25zdCBjb25maXJtXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2RpYWxvZy9jb25maXJtXCIpO1xuO1xuY29uc3QgZGVtb18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3dpZGdldHMvZGVtb1wiKTtcbjtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdoMScsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ0NvbmZpcm0nKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2J1dHRvbicsIHsgJ29uY2xpY2snOiBfX2NvbnRleHQudmFsdWVzLm9wZW4gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnT3BlbicpXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pLCB7fSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk1haW4gPSBNYWluO1xuO1xuY2xhc3MgT3BlbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChuZXcgY29uZmlybV8xLkNvbmZpcm0oeyB3bWw6IHsgJ2lkJzogJ29wZW4nIH0sICd0aXRsZSc6IF9fY29udGV4dC52YWx1ZXMudGl0bGUsICdvbk5vJzogX19jb250ZXh0LnZhbHVlcy5vbk5vLCAnb25ZZXMnOiBfX2NvbnRleHQudmFsdWVzLm9uWWVzIH0sIFtcbiAgICAgICAgICAgICAgICB0ZXh0KF9fY29udGV4dC52YWx1ZXMubWVzc2FnZSlcbiAgICAgICAgICAgIF0pLCB7IHdtbDogeyAnaWQnOiAnb3BlbicgfSwgJ3RpdGxlJzogX19jb250ZXh0LnZhbHVlcy50aXRsZSwgJ29uTm8nOiBfX2NvbnRleHQudmFsdWVzLm9uTm8sICdvblllcyc6IF9fY29udGV4dC52YWx1ZXMub25ZZXMgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk9wZW4gPSBPcGVuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uZmlybS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW5mb3JtUGFnZSA9IHZvaWQgMDtcbmNvbnN0IHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2luZm9ybVwiKTtcbmNsYXNzIEluZm9ybVBhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbih0aGlzKTtcbiAgICAgICAgdGhpcy52ID0gbmV3IHZpZXdzLk9wZW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgdGl0bGU6ICdTb21ldGhpbmcgaGFwcGVuZWQnLFxuICAgICAgICAgICAgbWVzc2FnZTogJ1ppbmchIFNvbWV0aGluZyB5b3UgaGFwcGVuZWQhJyxcbiAgICAgICAgICAgIG9uQ2xvc2U6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBhbGVydCgnQnVoIEJ5ZScpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9wZW46ICgpID0+IHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMudi5yZW5kZXIoKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2U6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnYuZmluZEJ5SWQoJ29wZW4nKVxuICAgICAgICAgICAgICAgICAgICAubWFwKG0gPT4gbS5jbG9zZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkluZm9ybVBhZ2UgPSBJbmZvcm1QYWdlO1xuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IEluZm9ybVBhZ2UoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5PcGVuID0gZXhwb3J0cy5NYWluID0gdm9pZCAwO1xuY29uc3QgX19kb2N1bWVudCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbmNvbnN0IG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG5jb25zdCBpbmZvcm1fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvZGlhbG9nL2luZm9ybVwiKTtcbjtcbmNvbnN0IGRlbW9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi93aWRnZXRzL2RlbW9cIik7XG47XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaDEnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdJbmZvcm0nKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2J1dHRvbicsIHsgJ29uY2xpY2snOiBfX2NvbnRleHQudmFsdWVzLm9wZW4gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnT3BlbicpXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pLCB7fSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk1haW4gPSBNYWluO1xuO1xuY2xhc3MgT3BlbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChuZXcgaW5mb3JtXzEuSW5mb3JtKHsgd21sOiB7ICdpZCc6ICdvcGVuJyB9LCAndGl0bGUnOiBfX2NvbnRleHQudmFsdWVzLnRpdGxlLCAnb25DbG9zZSc6IF9fY29udGV4dC52YWx1ZXMub25DbG9zZSB9LCBbXG4gICAgICAgICAgICAgICAgdGV4dChfX2NvbnRleHQudmFsdWVzLm1lc3NhZ2UpXG4gICAgICAgICAgICBdKSwgeyB3bWw6IHsgJ2lkJzogJ29wZW4nIH0sICd0aXRsZSc6IF9fY29udGV4dC52YWx1ZXMudGl0bGUsICdvbkNsb3NlJzogX19jb250ZXh0LnZhbHVlcy5vbkNsb3NlIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5PcGVuID0gT3Blbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZm9ybS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTW9kYWxQYWdlID0gdm9pZCAwO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvbW9kYWxcIik7XG5jbGFzcyBNb2RhbFBhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbih0aGlzKTtcbiAgICAgICAgdGhpcy52ID0gbmV3IHZpZXdzLk9wZW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgb3BlbjogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy52LnJlbmRlcigpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudi5maW5kQnlJZCgnb3BlbicpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAobSA9PiBtLmNsb3NlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuTW9kYWxQYWdlID0gTW9kYWxQYWdlO1xuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IE1vZGFsUGFnZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk9wZW4gPSBleHBvcnRzLk1haW4gPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbmNvbnN0IG1vZGFsXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2RpYWxvZy9tb2RhbFwiKTtcbjtcbmNvbnN0IGRlbW9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi93aWRnZXRzL2RlbW9cIik7XG47XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaDEnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdNb2RhbHMnKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2J1dHRvbicsIHsgJ29uY2xpY2snOiBfX2NvbnRleHQudmFsdWVzLm9wZW4gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnT3BlbicpXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pLCB7fSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk1haW4gPSBNYWluO1xuO1xuY2xhc3MgT3BlbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChuZXcgbW9kYWxfMS5Nb2RhbCh7IHdtbDogeyAnaWQnOiAnb3BlbicgfSB9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgbW9kYWxfMS5Nb2RhbEhlYWRlcih7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdPcGVuJylcbiAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IG1vZGFsXzEuTW9kYWxCb2R5KHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ0NsaWNrIHRoaXMgJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnYnV0dG9uJywgeyAnb25jbGljayc6IF9fY29udGV4dC52YWx1ZXMuY2xvc2UgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ2J1dHRvbicpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJyB0byBjbG9zZS4nKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgbW9kYWxfMS5Nb2RhbEZvb3Rlcih7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnYnV0dG9uJywgeyAnb25jbGljayc6IF9fY29udGV4dC52YWx1ZXMuY2xvc2UgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnY2FuY2VsJylcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKSwge30pXG4gICAgICAgICAgICBdKSwgeyB3bWw6IHsgJ2lkJzogJ29wZW4nIH0gfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk9wZW4gPSBPcGVuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kYWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlByb21wdFBhZ2UgPSB2b2lkIDA7XG5jb25zdCB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9wcm9tcHRcIik7XG5jbGFzcyBQcm9tcHRQYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudiA9IG5ldyB2aWV3cy5PcGVuKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHZhbHVlOiAnQ2xpY2sgdGhlIGJ1dHRvbiBiZWxsb3cgdG8gY2hhbmdlIHRoaXMgdGV4dC4nLFxuICAgICAgICAgICAgdGl0bGU6ICdDaGFuZ2UgdGhlIHRleHQnLFxuICAgICAgICAgICAgb25DaGFuZ2U6IChlKSA9PiB0aGlzLnZhbHVlcy52YWx1ZSA9IGUudmFsdWUsXG4gICAgICAgICAgICBvblNhdmU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuaW52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQ2FuY2VsOiAoKSA9PiB7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3BlbjogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy52LnJlbmRlcigpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudi5maW5kQnlJZCgnb3BlbicpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAobSA9PiBtLmNsb3NlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuUHJvbXB0UGFnZSA9IFByb21wdFBhZ2U7XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgUHJvbXB0UGFnZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk9wZW4gPSBleHBvcnRzLk1haW4gPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbmNvbnN0IHRleHRfZmllbGRfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvY29udHJvbC90ZXh0LWZpZWxkXCIpO1xuO1xuY29uc3QgcHJvbXB0XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2RpYWxvZy9wcm9tcHRcIik7XG47XG5jb25zdCBkZW1vXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vd2lkZ2V0cy9kZW1vXCIpO1xuO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9faWYgPSAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpID0+IChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0ID8gX19hbHQoKSA6IFtdO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9ySW4gPSAobGlzdCwgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2Zvck9mID0gKG8sIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHRleHQgPSBfX2RvY3VtZW50LnRleHQ7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHVuc2FmZSA9IF9fZG9jdW1lbnQudW5zYWZlO1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCBpc1NldCA9ICh2YWx1ZSkgPT4gdmFsdWUgIT0gbnVsbDtcbmNsYXNzIE1haW4ge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2gxJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnUHJvbXB0JylcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIHRleHQoX19jb250ZXh0LnZhbHVlcy52YWx1ZSlcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdidXR0b24nLCB7ICdvbmNsaWNrJzogX19jb250ZXh0LnZhbHVlcy5vcGVuIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ09wZW4nKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKSwge30pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5NYWluID0gTWFpbjtcbjtcbmNsYXNzIE9wZW4ge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQobmV3IHByb21wdF8xLlByb21wdCh7IHdtbDogeyAnaWQnOiAnb3BlbicgfSwgJ3RpdGxlJzogX19jb250ZXh0LnZhbHVlcy50aXRsZSwgJ29uU2F2ZSc6IF9fY29udGV4dC52YWx1ZXMub25TYXZlLCAnb25DYW5jZWwnOiBfX2NvbnRleHQudmFsdWVzLm9uQ2FuY2VsIH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyB0ZXh0X2ZpZWxkXzEuVGV4dEZpZWxkKHsgJ3ZhbHVlJzogX19jb250ZXh0LnZhbHVlcy52YWx1ZSwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5vbkNoYW5nZSB9LCBbXSksIHsgJ3ZhbHVlJzogX19jb250ZXh0LnZhbHVlcy52YWx1ZSwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5vbkNoYW5nZSB9KVxuICAgICAgICAgICAgXSksIHsgd21sOiB7ICdpZCc6ICdvcGVuJyB9LCAndGl0bGUnOiBfX2NvbnRleHQudmFsdWVzLnRpdGxlLCAnb25TYXZlJzogX19jb250ZXh0LnZhbHVlcy5vblNhdmUsICdvbkNhbmNlbCc6IF9fY29udGV4dC52YWx1ZXMub25DYW5jZWwgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk9wZW4gPSBPcGVuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvbXB0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DYWxsb3V0UGFnZSA9IHZvaWQgMDtcbmNvbnN0IHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2NhbGxvdXRcIik7XG5jb25zdCBzdHlsZV8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL2xpYi9jb250ZW50L3N0eWxlXCIpO1xuY2xhc3MgQ2FsbG91dFBhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbih0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBjYXBpdGFsaXplOiAocykgPT4gYCR7c1swXS50b1VwcGVyQ2FzZSgpfSR7cy5zbGljZSgxKX1gLFxuICAgICAgICAgICAgc3R5bGVzOiBbXG4gICAgICAgICAgICAgICAgc3R5bGVfMS5TdHlsZS5EZWZhdWx0LFxuICAgICAgICAgICAgICAgIHN0eWxlXzEuU3R5bGUuUHJpbWFyeSxcbiAgICAgICAgICAgICAgICBzdHlsZV8xLlN0eWxlLlN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgc3R5bGVfMS5TdHlsZS5JbmZvLFxuICAgICAgICAgICAgICAgIHN0eWxlXzEuU3R5bGUuV2FybmluZyxcbiAgICAgICAgICAgICAgICBzdHlsZV8xLlN0eWxlLkVycm9yXG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5DYWxsb3V0UGFnZSA9IENhbGxvdXRQYWdlO1xuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IENhbGxvdXRQYWdlKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWFpbiA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuY29uc3QgY2FsbG91dF8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9sYXlvdXQvY2FsbG91dFwiKTtcbjtcbmNvbnN0IGRlbW9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi93aWRnZXRzL2RlbW9cIik7XG47XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaDEnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnQ2FsbG91dCcpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaDInLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1N0eWxlcycpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLl9fZm9ySW4oX19jb250ZXh0LnZhbHVlcy5zdHlsZXMsICh2LCBfJCRpLCBfJCRhbGwpID0+IChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgY2FsbG91dF8xLkNhbGxvdXQoeyAnc3R5bGUnOiB2IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnXFx1MDAwYVxcdTAwMGEgICAgICAgICAgICBUaGlzIGlzIGEgY2FsbG91dCB3aXRoIHN0eWxlIG9uIGRpc3BsYXkuXFx1MDAwYVxcdTAwMGEgICAgICAgICAgJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSwgeyAnc3R5bGUnOiB2IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSwgKCkgPT4gKFtdKSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKSwge30pXG4gICAgICAgICAgICBdKSwge30pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhbGxvdXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRlc2NyaXB0aW9uTGlzdFBhZ2UgPSB2b2lkIDA7XG5jb25zdCBkZXNjcmlwdGlvbl9saXN0XzEgPSByZXF1aXJlKFwiLi93bWwvZGVzY3JpcHRpb24tbGlzdFwiKTtcbmNsYXNzIERlc2NyaXB0aW9uTGlzdFBhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgZGVzY3JpcHRpb25fbGlzdF8xLk1haW4odGhpcyk7XG4gICAgfVxufVxuZXhwb3J0cy5EZXNjcmlwdGlvbkxpc3RQYWdlID0gRGVzY3JpcHRpb25MaXN0UGFnZTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBEZXNjcmlwdGlvbkxpc3RQYWdlKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWFpbiA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuY29uc3QgZGVtb18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3dpZGdldHMvZGVtb1wiKTtcbjtcbmNvbnN0IGRlc2NyaXB0aW9uX2xpc3RfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvbGF5b3V0L2Rlc2NyaXB0aW9uLWxpc3RcIik7XG47XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZXNjcmlwdGlvbl9saXN0XzEuRGVzY3JpcHRpb25MaXN0KHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZXNjcmlwdGlvbl9saXN0XzEuVGl0bGUoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdQaG9uZScpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZGVzY3JpcHRpb25fbGlzdF8xLkRhdGEoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCc2Mzg1NTMyJylcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZXNjcmlwdGlvbl9saXN0XzEuVGl0bGUoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdFbWFpbCcpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZGVzY3JpcHRpb25fbGlzdF8xLkRhdGEoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdoZWxAbG8uY29tJylcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZXNjcmlwdGlvbl9saXN0XzEuVGl0bGUoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdXZWJzaXRlJylcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZXNjcmlwdGlvbl9saXN0XzEuRGF0YSh7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ2V4YW1wbGUuY29tJylcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgICAgICAgICAgXSksIHt9KVxuICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZGVzY3JpcHRpb25fbGlzdF8xLkRlc2NyaXB0aW9uTGlzdCh7ICdob3Jpem9udGFsJzogdHJ1ZSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZXNjcmlwdGlvbl9saXN0XzEuVGl0bGUoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdQaG9uZScpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZGVzY3JpcHRpb25fbGlzdF8xLkRhdGEoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCc2Mzg1NTMyJylcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZXNjcmlwdGlvbl9saXN0XzEuVGl0bGUoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdFbWFpbCcpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZGVzY3JpcHRpb25fbGlzdF8xLkRhdGEoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdoZWxAbG8uY29tJylcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZXNjcmlwdGlvbl9saXN0XzEuVGl0bGUoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdXZWJzaXRlJylcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZXNjcmlwdGlvbl9saXN0XzEuRGF0YSh7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ2V4YW1wbGUuY29tJylcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgICAgICAgICAgXSksIHsgJ2hvcml6b250YWwnOiB0cnVlIH0pXG4gICAgICAgICAgICAgICAgXSksIHt9KVxuICAgICAgICAgICAgXSksIHt9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXNjcmlwdGlvbi1saXN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5HcmlkTGF5b3V0UGFnZSA9IHZvaWQgMDtcbmNvbnN0IHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2dyaWRcIik7XG5jbGFzcyBHcmlkTGF5b3V0UGFnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdncmlkLWxheW91dC1leGFtcGxlJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuR3JpZExheW91dFBhZ2UgPSBHcmlkTGF5b3V0UGFnZTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBHcmlkTGF5b3V0UGFnZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1haW4gPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbmNvbnN0IGdyaWRfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvbGF5b3V0L2dyaWRcIik7XG47XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChuZXcgZ3JpZF8xLkdyaWRMYXlvdXQoeyAnY2xhc3NOYW1lJzogX19jb250ZXh0LnZhbHVlcy5yb290LmNsYXNzTmFtZSB9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZ3JpZF8xLlJvdyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBncmlkXzEuQ29sdW1uKHsgJ3NwYW4nOiAxIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1NwYW4gMScpXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7ICdzcGFuJzogMSB9KSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZ3JpZF8xLkNvbHVtbih7ICdzcGFuJzogMSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdTcGFuIDEnKVxuICAgICAgICAgICAgICAgICAgICBdKSwgeyAnc3Bhbic6IDEgfSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGdyaWRfMS5Db2x1bW4oeyAnc3Bhbic6IDEgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnU3BhbiAxJylcbiAgICAgICAgICAgICAgICAgICAgXSksIHsgJ3NwYW4nOiAxIH0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBncmlkXzEuQ29sdW1uKHsgJ3NwYW4nOiAxIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1NwYW4gMScpXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7ICdzcGFuJzogMSB9KSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZ3JpZF8xLkNvbHVtbih7ICdzcGFuJzogMSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdTcGFuIDEnKVxuICAgICAgICAgICAgICAgICAgICBdKSwgeyAnc3Bhbic6IDEgfSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGdyaWRfMS5Db2x1bW4oeyAnc3Bhbic6IDEgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnU3BhbiAxJylcbiAgICAgICAgICAgICAgICAgICAgXSksIHsgJ3NwYW4nOiAxIH0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBncmlkXzEuQ29sdW1uKHsgJ3NwYW4nOiAxIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1NwYW4gMScpXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7ICdzcGFuJzogMSB9KSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZ3JpZF8xLkNvbHVtbih7ICdzcGFuJzogMSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdTcGFuIDEnKVxuICAgICAgICAgICAgICAgICAgICBdKSwgeyAnc3Bhbic6IDEgfSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGdyaWRfMS5Db2x1bW4oeyAnc3Bhbic6IDEgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnU3BhbiAxJylcbiAgICAgICAgICAgICAgICAgICAgXSksIHsgJ3NwYW4nOiAxIH0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBncmlkXzEuQ29sdW1uKHsgJ3NwYW4nOiAxIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1NwYW4gMScpXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7ICdzcGFuJzogMSB9KSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZ3JpZF8xLkNvbHVtbih7ICdzcGFuJzogMSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdTcGFuIDEnKVxuICAgICAgICAgICAgICAgICAgICBdKSwgeyAnc3Bhbic6IDEgfSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGdyaWRfMS5Db2x1bW4oeyAnc3Bhbic6IDEgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnU3BhbiAxJylcbiAgICAgICAgICAgICAgICAgICAgXSksIHsgJ3NwYW4nOiAxIH0pXG4gICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBncmlkXzEuUm93KHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGdyaWRfMS5Db2x1bW4oeyAnc3Bhbic6IDggfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnU3BhbiA4JylcbiAgICAgICAgICAgICAgICAgICAgXSksIHsgJ3NwYW4nOiA4IH0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBncmlkXzEuQ29sdW1uKHsgJ3NwYW4nOiA0IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1NwYW4gNCcpXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7ICdzcGFuJzogNCB9KVxuICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZ3JpZF8xLlJvdyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBncmlkXzEuQ29sdW1uKHsgJ3NwYW4nOiA0IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1NwYW4gNCcpXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7ICdzcGFuJzogNCB9KSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZ3JpZF8xLkNvbHVtbih7ICdzcGFuJzogNCB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdTcGFuIDQnKVxuICAgICAgICAgICAgICAgICAgICBdKSwgeyAnc3Bhbic6IDQgfSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGdyaWRfMS5Db2x1bW4oeyAnc3Bhbic6IDQgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnU3BhbiA0JylcbiAgICAgICAgICAgICAgICAgICAgXSksIHsgJ3NwYW4nOiA0IH0pXG4gICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBncmlkXzEuUm93KHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGdyaWRfMS5Db2x1bW4oeyAnc3Bhbic6IDYgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnU3BhbiA2JylcbiAgICAgICAgICAgICAgICAgICAgXSksIHsgJ3NwYW4nOiA2IH0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBncmlkXzEuQ29sdW1uKHsgJ3NwYW4nOiA2IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1NwYW4gNicpXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7ICdzcGFuJzogNiB9KVxuICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZ3JpZF8xLlJvdyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBncmlkXzEuQ29sdW1uKHsgJ3NwYW4nOiA2IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1NwYW4gNicpXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7ICdzcGFuJzogNiB9KSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZ3JpZF8xLkNvbHVtbih7ICdzcGFuJzogNiB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdTcGFuIDYnKVxuICAgICAgICAgICAgICAgICAgICBdKSwgeyAnc3Bhbic6IDYgfSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGdyaWRfMS5Db2x1bW4oeyAnc3Bhbic6IDYgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnU3BhbiA2JylcbiAgICAgICAgICAgICAgICAgICAgXSksIHsgJ3NwYW4nOiA2IH0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBncmlkXzEuQ29sdW1uKHsgJ3NwYW4nOiA2IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1NwYW4gNicpXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7ICdzcGFuJzogNiB9KVxuICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZ3JpZF8xLlJvdyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBncmlkXzEuQ29sdW1uKHsgJ3NwYW4nOiAxMiB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdTcGFuIDEyJylcbiAgICAgICAgICAgICAgICAgICAgXSksIHsgJ3NwYW4nOiAxMiB9KVxuICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgIF0pLCB7ICdjbGFzc05hbWUnOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NOYW1lIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyaWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkhvcml6b250YWxMYXlvdXRQYWdlID0gdm9pZCAwO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvaG9yaXpvbnRhbFwiKTtcbmNsYXNzIEhvcml6b250YWxMYXlvdXRQYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgfVxufVxuZXhwb3J0cy5Ib3Jpem9udGFsTGF5b3V0UGFnZSA9IEhvcml6b250YWxMYXlvdXRQYWdlO1xuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IEhvcml6b250YWxMYXlvdXRQYWdlKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWFpbiA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuY29uc3QgZGVtb18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3dpZGdldHMvZGVtb1wiKTtcbjtcbmNvbnN0IGhvcml6b250YWxfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvbGF5b3V0L2hvcml6b250YWxcIik7XG47XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBob3Jpem9udGFsXzEuSG9yaXpvbnRhbExheW91dCh7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3RleHRhcmVhJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdBcmVhIDEnKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgndGV4dGFyZWEnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ0FyZWEgMicpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCd0ZXh0YXJlYScsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnQXJlYSAzJylcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGhvcml6b250YWxfMS5Ib3Jpem9udGFsTGF5b3V0KHsgJ29yaWVudGF0aW9uJzogaG9yaXpvbnRhbF8xLkhvcml6b250YWxMYXlvdXRPcmllbnRhdGlvbi5MZWZ0IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1xcdTAwMGEgICAgICBUaGlzIGlzIG9yaWVudGVkIHRvIHRoZSBsZWZ0LlxcdTAwMGEgICAgJylcbiAgICAgICAgICAgICAgICAgICAgXSksIHsgJ29yaWVudGF0aW9uJzogaG9yaXpvbnRhbF8xLkhvcml6b250YWxMYXlvdXRPcmllbnRhdGlvbi5MZWZ0IH0pXG4gICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBob3Jpem9udGFsXzEuSG9yaXpvbnRhbExheW91dCh7ICdvcmllbnRhdGlvbic6IGhvcml6b250YWxfMS5Ib3Jpem9udGFsTGF5b3V0T3JpZW50YXRpb24uUmlnaHQgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnXFx1MDAwYSAgICAgIFRoaXMgaXMgb3JpZW50ZWQgdG8gdGhlIHJpZ2h0LlxcdTAwMGEgICAgJylcbiAgICAgICAgICAgICAgICAgICAgXSksIHsgJ29yaWVudGF0aW9uJzogaG9yaXpvbnRhbF8xLkhvcml6b250YWxMYXlvdXRPcmllbnRhdGlvbi5SaWdodCB9KVxuICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgIF0pLCB7fSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG9yaXpvbnRhbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGlzdExheW91dFBhZ2UgPSB2b2lkIDA7XG5jb25zdCBsaXN0XzEgPSByZXF1aXJlKFwiLi93bWwvbGlzdFwiKTtcbmNsYXNzIExpc3RMYXlvdXRQYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IGxpc3RfMS5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLml0ZW1zID0ge1xuICAgICAgICAgICAgJ1RoaXMgaXMgdGhlIGZpcnN0IGl0ZW0uJzogZmFsc2UsXG4gICAgICAgICAgICAnVGhpcyBpcyB0aGUgc2Vjb25kIGl0ZW0uJzogdHJ1ZSxcbiAgICAgICAgICAgICdUaGlzIGlzIHRoZSB0aGlyZCBpdGVtLic6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2xpY2sgPSAoa2V5KSA9PiB0aGlzXG4gICAgICAgICAgICAudmlld1xuICAgICAgICAgICAgLmZpbmRCeUlkKGtleSlcbiAgICAgICAgICAgIC5tYXAobCA9PiBsLnRvZ2dsZUFjdGl2ZSgpKVxuICAgICAgICAgICAgLm9ySnVzdCgoKSA9PiBhbGVydChgQ2Fubm90IGZpbmQgZWxlbWVudCBieSBpZCBcIiR7a2V5fVwiIWApKTtcbiAgICB9XG59XG5leHBvcnRzLkxpc3RMYXlvdXRQYWdlID0gTGlzdExheW91dFBhZ2U7XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgTGlzdExheW91dFBhZ2UoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYWluID0gdm9pZCAwO1xuY29uc3QgX19kb2N1bWVudCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbmNvbnN0IG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG5jb25zdCBkZW1vXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vd2lkZ2V0cy9kZW1vXCIpO1xuO1xuY29uc3QgbGlzdF8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9sYXlvdXQvbGlzdFwiKTtcbjtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGxpc3RfMS5MaXN0TGF5b3V0KHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIC4uLl9fZm9yT2YoX19jb250ZXh0Lml0ZW1zLCAoeWVzLCBrZXksIF8kJGFsbCkgPT4gKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGxpc3RfMS5MaXN0TGF5b3V0SXRlbSh7IHdtbDogeyAnaWQnOiBrZXkgfSwgJ25hbWUnOiBrZXksICdhY3RpdmUnOiB5ZXMsICdvbkNsaWNrJzogX19jb250ZXh0LmNsaWNrIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGtleSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksIHsgd21sOiB7ICdpZCc6IGtleSB9LCAnbmFtZSc6IGtleSwgJ2FjdGl2ZSc6IHllcywgJ29uQ2xpY2snOiBfX2NvbnRleHQuY2xpY2sgfSlcbiAgICAgICAgICAgICAgICAgICAgXSksICgpID0+IChbXSkpXG4gICAgICAgICAgICAgICAgXSksIHt9KVxuICAgICAgICAgICAgXSksIHt9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saXN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NZXRlclBhZ2UgPSB2b2lkIDA7XG5jb25zdCB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9tZXRlclwiKTtcbmNsYXNzIE1ldGVyUGFnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdUaGlzIGlzIGFuIGFsZXJ0JyxcbiAgICAgICAgICAgIGJhcnM6IFtcbiAgICAgICAgICAgICAgICB7IHZhbHVlOiAxMCwgY29sb3I6ICdyZWQnIH0sXG4gICAgICAgICAgICAgICAgeyB2YWx1ZTogNTAsIGNvbG9yOiAnZ3JlZW4nIH0sXG4gICAgICAgICAgICAgICAgeyB2YWx1ZTogNDAsIGNvbG9yOiAnYmx1ZScgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGluYzogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBtID0gdGhpcy52aWV3LmZpbmRCeUlkKCdzaW5nbGUnKTtcbiAgICAgICAgICAgICAgICBpZiAobS5pc0p1c3QoKSlcbiAgICAgICAgICAgICAgICAgICAgbS5nZXQoKS5pbmNyZWFzZSgxMCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVjOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG0gPSB0aGlzLnZpZXcuZmluZEJ5SWQoJ3NpbmdsZScpO1xuICAgICAgICAgICAgICAgIGlmIChtLmlzSnVzdCgpKVxuICAgICAgICAgICAgICAgICAgICBtLmdldCgpLmRlY3JlYXNlKDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLk1ldGVyUGFnZSA9IE1ldGVyUGFnZTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBNZXRlclBhZ2UoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYWluID0gdm9pZCAwO1xuY29uc3QgX19kb2N1bWVudCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbmNvbnN0IG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG5jb25zdCBtZXRlcl8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9sYXlvdXQvbWV0ZXJcIik7XG47XG5jb25zdCBkZW1vXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vd2lkZ2V0cy9kZW1vXCIpO1xuO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9faWYgPSAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpID0+IChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0ID8gX19hbHQoKSA6IFtdO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9ySW4gPSAobGlzdCwgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2Zvck9mID0gKG8sIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHRleHQgPSBfX2RvY3VtZW50LnRleHQ7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHVuc2FmZSA9IF9fZG9jdW1lbnQudW5zYWZlO1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCBpc1NldCA9ICh2YWx1ZSkgPT4gdmFsdWUgIT0gbnVsbDtcbmNsYXNzIE1haW4ge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2gxJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnTWV0ZXInKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdoMicsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdTaW5nbGUnKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2J1dHRvbicsIHsgJ29uY2xpY2snOiBfX2NvbnRleHQudmFsdWVzLmRlYyB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnLScpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdidXR0b24nLCB7ICdvbmNsaWNrJzogX19jb250ZXh0LnZhbHVlcy5pbmMgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJysnKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IG1ldGVyXzEuTWV0ZXIoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IG1ldGVyXzEuTWV0ZXJCYXIoeyB3bWw6IHsgJ2lkJzogJ3NpbmdsZScgfSwgJ3ZhbHVlJzogNzUsICdjb2xvcic6ICd5ZWxsb3cnIH0sIFtdKSwgeyB3bWw6IHsgJ2lkJzogJ3NpbmdsZScgfSwgJ3ZhbHVlJzogNzUsICdjb2xvcic6ICd5ZWxsb3cnIH0pXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdoMicsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnQ29tYmluZWQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBtZXRlcl8xLk1ldGVyKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uX19mb3JJbihfX2NvbnRleHQudmFsdWVzLmJhcnMsICh2LCBfJCRpLCBfJCRhbGwpID0+IChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IG1ldGVyXzEuTWV0ZXJCYXIoeyAndmFsdWUnOiB2LnZhbHVlLCAnY29sb3InOiB2LmNvbG9yIH0sIFtdKSwgeyAndmFsdWUnOiB2LnZhbHVlLCAnY29sb3InOiB2LmNvbG9yIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSksICgpID0+IChbXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSwge30pXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSksIHt9KVxuICAgICAgICAgICAgXSksIHt9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGFuZWxQYWdlID0gdm9pZCAwO1xuY29uc3QgcGFuZWxfMSA9IHJlcXVpcmUoXCIuL3dtbC9wYW5lbFwiKTtcbmNsYXNzIFBhbmVsUGFnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyBwYW5lbF8xLk1haW4odGhpcyk7XG4gICAgfVxufVxuZXhwb3J0cy5QYW5lbFBhZ2UgPSBQYW5lbFBhZ2U7XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgUGFuZWxQYWdlKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWFpbiA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuY29uc3QgZ3JpZF8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9sYXlvdXQvZ3JpZFwiKTtcbjtcbmNvbnN0IHBhbmVsXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2xheW91dC9wYW5lbFwiKTtcbjtcbmNvbnN0IHN0eWxlXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRlbnQvc3R5bGVcIik7XG47XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChuZXcgZ3JpZF8xLkdyaWRMYXlvdXQoe30sIFtcbiAgICAgICAgICAgICAgICAuLi5fX2ZvckluKHN0eWxlXzEuc3R5bGVzLCAoc3R5bGUsIF8kJGksIF8kJGFsbCkgPT4gKFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZ3JpZF8xLlJvdyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZ3JpZF8xLkNvbHVtbih7ICdzcGFuJzogNCB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgcGFuZWxfMS5QYW5lbCh7ICdzdHlsZSc6IHN0eWxlIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgcGFuZWxfMS5QYW5lbEJvZHkoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1xcdTAwMGEgICAgICAgICAgICBQYW5lbEJvZHkgb25seS5cXHUwMDBhICAgICAgICAgICcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSwgeyAnc3R5bGUnOiBzdHlsZSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksIHsgJ3NwYW4nOiA0IH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZ3JpZF8xLkNvbHVtbih7ICdzcGFuJzogNCB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgcGFuZWxfMS5QYW5lbCh7ICdzdHlsZSc6IHN0eWxlIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgcGFuZWxfMS5QYW5lbEhlYWRlcih7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnXFx1MDAwYSAgICAgICAgICAgIFdpdGggUGFuZWxIZWFkZXJcXHUwMDBhICAgICAgICAgICcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHBhbmVsXzEuUGFuZWxCb2R5KHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdcXHUwMDBhICAgICAgICAgICAgTG9yZW0gaW1wc3VtIGRpbGl1bSBuZXQgc2V0LlxcdTAwMGEgICAgICAgICAgJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSksIHt9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLCB7ICdzdHlsZSc6IHN0eWxlIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSwgeyAnc3Bhbic6IDQgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBncmlkXzEuQ29sdW1uKHsgJ3NwYW4nOiA0IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBwYW5lbF8xLlBhbmVsKHsgJ3N0eWxlJzogc3R5bGUgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBwYW5lbF8xLlBhbmVsSGVhZGVyKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdXaXRoIFBhbmVsRm9vdGVyJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgcGFuZWxfMS5QYW5lbEJvZHkoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ0xvcmVtIGltcHN1bSBkaWxpdW0gbmV0IHNldC4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBwYW5lbF8xLlBhbmVsRm9vdGVyKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdNZWggZm9vdC4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSwge30pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSksIHsgJ3N0eWxlJzogc3R5bGUgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLCB7ICdzcGFuJzogNCB9KVxuICAgICAgICAgICAgICAgICAgICBdKSwge30pXG4gICAgICAgICAgICAgICAgXSksICgpID0+IChbXSkpXG4gICAgICAgICAgICBdKSwge30pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhbmVsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UYWJMYXlvdXRQYWdlID0gdm9pZCAwO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvdGFiXCIpO1xuY2xhc3MgVGFiTGF5b3V0UGFnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnRhYnMgPSB7XG4gICAgICAgICAgICBmaXJzdDoge1xuICAgICAgICAgICAgICAgIHRleHQ6ICdGaXJzdCcsXG4gICAgICAgICAgICAgICAgY29udGVudEZ1bjogdmlld3MuZmlyc3RUYWJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWNvbmQ6IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiAnU2Vjb25kJyxcbiAgICAgICAgICAgICAgICBjb250ZW50RnVuOiB2aWV3cy5zZWNvbmRUYWJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aGlyZDoge1xuICAgICAgICAgICAgICAgIHRleHQ6ICdUaGlyZCcsXG4gICAgICAgICAgICAgICAgY29udGVudEZ1bjogdmlld3MudGhpcmRUYWJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlRhYkxheW91dFBhZ2UgPSBUYWJMYXlvdXRQYWdlO1xuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IFRhYkxheW91dFBhZ2UoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYWluID0gZXhwb3J0cy50aGlyZFRhYiA9IGV4cG9ydHMuc2Vjb25kVGFiID0gZXhwb3J0cy5maXJzdFRhYiA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuY29uc3QgZGVtb18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3dpZGdldHMvZGVtb1wiKTtcbjtcbmNvbnN0IHRhYl8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9sYXlvdXQvdGFiXCIpO1xuO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9faWYgPSAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpID0+IChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0ID8gX19hbHQoKSA6IFtdO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9ySW4gPSAobGlzdCwgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2Zvck9mID0gKG8sIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHRleHQgPSBfX2RvY3VtZW50LnRleHQ7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHVuc2FmZSA9IF9fZG9jdW1lbnQudW5zYWZlO1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCBpc1NldCA9ICh2YWx1ZSkgPT4gdmFsdWUgIT0gbnVsbDtcbmNvbnN0IGZpcnN0VGFiID0gKF8pID0+IChfX3RoaXMpID0+IHtcbiAgICByZXR1cm4gW1xuICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdDbGljayBhIHRhYiB0byBjaGFuZ2UgY29udGVudC4nKVxuICAgICAgICBdKVxuICAgIF07XG59O1xuZXhwb3J0cy5maXJzdFRhYiA9IGZpcnN0VGFiO1xuO1xuY29uc3Qgc2Vjb25kVGFiID0gKF8pID0+IChfX3RoaXMpID0+IHtcbiAgICByZXR1cm4gW1xuICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdTZWNvbmQgdGFiLicpXG4gICAgICAgIF0pXG4gICAgXTtcbn07XG5leHBvcnRzLnNlY29uZFRhYiA9IHNlY29uZFRhYjtcbjtcbmNvbnN0IHRoaXJkVGFiID0gKF8pID0+IChfX3RoaXMpID0+IHtcbiAgICByZXR1cm4gW1xuICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdUaGlyZCB0YWIuJylcbiAgICAgICAgXSlcbiAgICBdO1xufTtcbmV4cG9ydHMudGhpcmRUYWIgPSB0aGlyZFRhYjtcbjtcbmNsYXNzIE1haW4ge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgdGFiXzEuVGFiTGF5b3V0KHsgJ3RhYnMnOiBfX2NvbnRleHQudGFicywgJ2FjdGl2ZSc6ICdmaXJzdCcgfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdDbGljayBhIHRhYiB0byBjaGFuZ2UgY29udGVudC4nKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pLCB7ICd0YWJzJzogX19jb250ZXh0LnRhYnMsICdhY3RpdmUnOiAnZmlyc3QnIH0pXG4gICAgICAgICAgICBdKSwge30pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhYi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVGFibGVMYXlvdXRQYWdlID0gdm9pZCAwO1xuY29uc3QgdGFibGVfMSA9IHJlcXVpcmUoXCIuL3dtbC90YWJsZVwiKTtcbmNsYXNzIFRhYmxlTGF5b3V0UGFnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB0YWJsZV8xLk1haW4odGhpcyk7XG4gICAgfVxufVxuZXhwb3J0cy5UYWJsZUxheW91dFBhZ2UgPSBUYWJsZUxheW91dFBhZ2U7XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgVGFibGVMYXlvdXRQYWdlKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWFpbiA9IGV4cG9ydHMuRm9vdGVyVmlldyA9IGV4cG9ydHMuQm9keVZpZXcgPSBleHBvcnRzLkhlYWRlclZpZXcgPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbmNvbnN0IGRlbW9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi93aWRnZXRzL2RlbW9cIik7XG47XG5jb25zdCB0YWJsZV8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9sYXlvdXQvdGFibGVcIik7XG47XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgSGVhZGVyVmlldyB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChuZXcgdGFibGVfMS5UYWJsZUhlYWRlcih7fSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRhYmxlXzEuVGFibGVSb3coe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgdGFibGVfMS5UYWJsZUhlYWRpbmcoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ05hbWUnKVxuICAgICAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyB0YWJsZV8xLlRhYmxlSGVhZGluZyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnRW1haWwnKVxuICAgICAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyB0YWJsZV8xLlRhYmxlSGVhZGluZyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnQmFsYW5jZScpXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRhYmxlXzEuVGFibGVIZWFkaW5nKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdVc2VybmFtZScpXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRhYmxlXzEuVGFibGVIZWFkaW5nKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdTdGF0dXMnKVxuICAgICAgICAgICAgICAgICAgICBdKSwge30pXG4gICAgICAgICAgICAgICAgXSksIHt9KVxuICAgICAgICAgICAgXSksIHt9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuSGVhZGVyVmlldyA9IEhlYWRlclZpZXc7XG47XG5jbGFzcyBCb2R5VmlldyB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChuZXcgdGFibGVfMS5UYWJsZUJvZHkoe30sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyB0YWJsZV8xLlRhYmxlUm93KHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRhYmxlXzEuVGFibGVDZWxsKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdMZW5ndGggV2lzZScpXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRhYmxlXzEuVGFibGVDZWxsKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdsd0B0aGVlbWFpbHBsYWNlLmNvbScpXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRhYmxlXzEuVGFibGVDZWxsKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCckNTAwMCcpXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRhYmxlXzEuVGFibGVDZWxsKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdsdycpXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRhYmxlXzEuVGFibGVDZWxsKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdBY3RpdmUnKVxuICAgICAgICAgICAgICAgICAgICBdKSwge30pXG4gICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyB0YWJsZV8xLlRhYmxlUm93KHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRhYmxlXzEuVGFibGVDZWxsKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdGaXJzdCBDaGFuY2UnKVxuICAgICAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyB0YWJsZV8xLlRhYmxlQ2VsbCh7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnZmNoYWNuZUBsaXZlLnR0JylcbiAgICAgICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgdGFibGVfMS5UYWJsZUNlbGwoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJyQxLjAwJylcbiAgICAgICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgdGFibGVfMS5UYWJsZUNlbGwoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ2NoYW5jZScpXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRhYmxlXzEuVGFibGVDZWxsKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdJbmFjdGl2ZScpXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRhYmxlXzEuVGFibGVSb3coe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgdGFibGVfMS5UYWJsZUNlbGwoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ0R1IFBlYXInKVxuICAgICAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyB0YWJsZV8xLlRhYmxlQ2VsbCh7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnZHVwZWFyQGdtYWlsLmNvbScpXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRhYmxlXzEuVGFibGVDZWxsKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCckMTAsMDAwLjAwJylcbiAgICAgICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgdGFibGVfMS5UYWJsZUNlbGwoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ3BlYXJib3knKVxuICAgICAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyB0YWJsZV8xLlRhYmxlQ2VsbCh7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnQWN0aXZlJylcbiAgICAgICAgICAgICAgICAgICAgXSksIHt9KVxuICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgdGFibGVfMS5UYWJsZVJvdyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyB0YWJsZV8xLlRhYmxlQ2VsbCh7ICdyb3dzcGFuJzogMiwgJ2NvbHNwYW4nOiA1IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1RoaXMgc3BhbnMgMiByb3dzIDUgY29sdW1ucy4nKVxuICAgICAgICAgICAgICAgICAgICBdKSwgeyAncm93c3Bhbic6IDIsICdjb2xzcGFuJzogNSB9KVxuICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgIF0pLCB7fSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLkJvZHlWaWV3ID0gQm9keVZpZXc7XG47XG5jbGFzcyBGb290ZXJWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KG5ldyB0YWJsZV8xLlRhYmxlRm9vdGVyKHt9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgdGFibGVfMS5UYWJsZVJvdyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyB0YWJsZV8xLlRhYmxlQ2VsbCh7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnMScpXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRhYmxlXzEuVGFibGVDZWxsKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcyJylcbiAgICAgICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgdGFibGVfMS5UYWJsZUNlbGwoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJzMnKVxuICAgICAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyB0YWJsZV8xLlRhYmxlQ2VsbCh7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnNCcpXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRhYmxlXzEuVGFibGVDZWxsKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCc1JylcbiAgICAgICAgICAgICAgICAgICAgXSksIHt9KVxuICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgIF0pLCB7fSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLkZvb3RlclZpZXcgPSBGb290ZXJWaWV3O1xuO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaDMnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnTm9ybWFsJylcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRhYmxlXzEuVGFibGVMYXlvdXQoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5yZWdpc3RlclZpZXcobmV3IEhlYWRlclZpZXcoX19jb250ZXh0KSkucmVuZGVyKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMucmVnaXN0ZXJWaWV3KG5ldyBCb2R5VmlldyhfX2NvbnRleHQpKS5yZW5kZXIoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5yZWdpc3RlclZpZXcobmV3IEZvb3RlclZpZXcoX19jb250ZXh0KSkucmVuZGVyKClcbiAgICAgICAgICAgICAgICAgICAgXSksIHt9KVxuICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2gzJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJyBBbHRlcm5hdGUnKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgdGFibGVfMS5UYWJsZUxheW91dCh7ICdhbHRlcm5hdGUnOiB0cnVlIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5yZWdpc3RlclZpZXcobmV3IEhlYWRlclZpZXcoX19jb250ZXh0KSkucmVuZGVyKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMucmVnaXN0ZXJWaWV3KG5ldyBCb2R5VmlldyhfX2NvbnRleHQpKS5yZW5kZXIoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5yZWdpc3RlclZpZXcobmV3IEZvb3RlclZpZXcoX19jb250ZXh0KSkucmVuZGVyKClcbiAgICAgICAgICAgICAgICAgICAgXSksIHsgJ2FsdGVybmF0ZSc6IHRydWUgfSlcbiAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdoMycsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdCb3JkZXJlZCcpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyB0YWJsZV8xLlRhYmxlTGF5b3V0KHsgJ2JvcmRlcmVkJzogdHJ1ZSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMucmVnaXN0ZXJWaWV3KG5ldyBIZWFkZXJWaWV3KF9fY29udGV4dCkpLnJlbmRlcigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLnJlZ2lzdGVyVmlldyhuZXcgQm9keVZpZXcoX19jb250ZXh0KSkucmVuZGVyKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMucmVnaXN0ZXJWaWV3KG5ldyBGb290ZXJWaWV3KF9fY29udGV4dCkpLnJlbmRlcigpXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7ICdib3JkZXJlZCc6IHRydWUgfSlcbiAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdoMycsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdIb3ZlcmFibGUnKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgdGFibGVfMS5UYWJsZUxheW91dCh7ICdob3ZlcmFibGUnOiB0cnVlIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5yZWdpc3RlclZpZXcobmV3IEhlYWRlclZpZXcoX19jb250ZXh0KSkucmVuZGVyKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMucmVnaXN0ZXJWaWV3KG5ldyBCb2R5VmlldyhfX2NvbnRleHQpKS5yZW5kZXIoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5yZWdpc3RlclZpZXcobmV3IEZvb3RlclZpZXcoX19jb250ZXh0KSkucmVuZGVyKClcbiAgICAgICAgICAgICAgICAgICAgXSksIHsgJ2hvdmVyYWJsZSc6IHRydWUgfSlcbiAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdoMycsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdDb21wYWN0JylcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRhYmxlXzEuVGFibGVMYXlvdXQoeyAnY29tcGFjdCc6IHRydWUgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLnJlZ2lzdGVyVmlldyhuZXcgSGVhZGVyVmlldyhfX2NvbnRleHQpKS5yZW5kZXIoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5yZWdpc3RlclZpZXcobmV3IEJvZHlWaWV3KF9fY29udGV4dCkpLnJlbmRlcigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLnJlZ2lzdGVyVmlldyhuZXcgRm9vdGVyVmlldyhfX2NvbnRleHQpKS5yZW5kZXIoKVxuICAgICAgICAgICAgICAgICAgICBdKSwgeyAnY29tcGFjdCc6IHRydWUgfSlcbiAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRhYmxlXzEuVGFibGVXaW5kb3coe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IHRhYmxlXzEuVGFibGVMYXlvdXQoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMucmVnaXN0ZXJWaWV3KG5ldyBIZWFkZXJWaWV3KF9fY29udGV4dCkpLnJlbmRlcigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5yZWdpc3RlclZpZXcobmV3IEJvZHlWaWV3KF9fY29udGV4dCkpLnJlbmRlcigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5yZWdpc3RlclZpZXcobmV3IEZvb3RlclZpZXcoX19jb250ZXh0KSkucmVuZGVyKClcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgICAgICAgICAgXSksIHt9KVxuICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgIF0pLCB7fSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldlbGxQYWdlID0gdm9pZCAwO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvd2VsbFwiKTtcbmNsYXNzIFdlbGxQYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge307XG4gICAgfVxufVxuZXhwb3J0cy5XZWxsUGFnZSA9IFdlbGxQYWdlO1xuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IFdlbGxQYWdlKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWFpbiA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuY29uc3Qgd2VsbF8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9sYXlvdXQvd2VsbFwiKTtcbjtcbmNvbnN0IGRlbW9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi93aWRnZXRzL2RlbW9cIik7XG47XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaDEnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnV2VsbCcpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyB3ZWxsXzEuV2VsbCh7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1RoaXMgaXMgaW4gYSB3ZWxsLicpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSwge30pXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyB3ZWxsXzEuV2VsbCh7ICdjbGFzc05hbWUnOiAnLXNtYWxsJyB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnVGhpcyBpcyBhIHNtYWxsIHdlbGwuJylcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLCB7ICdjbGFzc05hbWUnOiAnLXNtYWxsJyB9KVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgd2VsbF8xLldlbGwoeyAnY2xhc3NOYW1lJzogJy1sYXJnZScgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1RoaXMgaXMgYSBzbWFsbCB3ZWxsLicpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSwgeyAnY2xhc3NOYW1lJzogJy1sYXJnZScgfSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKSwge30pXG4gICAgICAgICAgICBdKSwge30pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlbGwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1lbnVQYWdlID0gdm9pZCAwO1xuY29uc3QgbWVudV8xID0gcmVxdWlyZShcIi4vd21sL21lbnVcIik7XG5jbGFzcyBNZW51UGFnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyBtZW51XzEuTWFpbih0aGlzKTtcbiAgICB9XG59XG5leHBvcnRzLk1lbnVQYWdlID0gTWVudVBhZ2U7XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgTWVudVBhZ2UoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYWluID0gdm9pZCAwO1xuY29uc3QgX19kb2N1bWVudCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sL2xpYi9kb21cIik7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbmNvbnN0IG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG5jb25zdCBkZW1vXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vd2lkZ2V0cy9kZW1vXCIpO1xuO1xuY29uc3QgbWVudV8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9tZW51L21lbnVcIik7XG47XG5jb25zdCBpdGVtXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL21lbnUvaXRlbVwiKTtcbjtcbmNvbnN0IGxpbmtfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvY29udGVudC9saW5rXCIpO1xuO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9faWYgPSAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpID0+IChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0ID8gX19hbHQoKSA6IFtdO1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9ySW4gPSAobGlzdCwgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2Zvck9mID0gKG8sIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHRleHQgPSBfX2RvY3VtZW50LnRleHQ7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IHVuc2FmZSA9IF9fZG9jdW1lbnQudW5zYWZlO1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCBpc1NldCA9ICh2YWx1ZSkgPT4gdmFsdWUgIT0gbnVsbDtcbmNsYXNzIE1haW4ge1xuICAgIGNvbnN0cnVjdG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKF9fdGhpcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQobmV3IGRlbW9fMS5EZW1vKHt9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgbWVudV8xLk1lbnUoe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgaXRlbV8xLkl0ZW0oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdoNicsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnTWVudScpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBpdGVtXzEuSXRlbSh7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgbGlua18xLkxpbmsoeyAnZGlzYWJsZWQnOiB0cnVlLCAndGV4dCc6ICdCYWNrJyB9LCBbXSksIHsgJ2Rpc2FibGVkJzogdHJ1ZSwgJ3RleHQnOiAnQmFjaycgfSlcbiAgICAgICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgaXRlbV8xLkl0ZW0oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGxpbmtfMS5MaW5rKHsgJ2Rpc2FibGVkJzogdHJ1ZSwgJ3RleHQnOiAnUmVmcmVzaCcgfSwgW10pLCB7ICdkaXNhYmxlZCc6IHRydWUsICd0ZXh0JzogJ1JlZnJlc2gnIH0pXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGl0ZW1fMS5EaXZpZGVyKHt9LCBbXSksIHt9KSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgaXRlbV8xLkl0ZW0oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdhJywgeyAnaHJlZic6ICcjL21lbnUnIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdRdWl0JylcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgICAgICBdKSwge30pXG4gICAgICAgICAgICBdKSwge30pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lbnUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5hdlBhZ2UgPSB2b2lkIDA7XG5jb25zdCBuYXZfMSA9IHJlcXVpcmUoXCIuL3dtbC9uYXZcIik7XG5jbGFzcyBOYXZQYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IG5hdl8xLk1haW4odGhpcyk7XG4gICAgfVxufVxuZXhwb3J0cy5OYXZQYWdlID0gTmF2UGFnZTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBOYXZQYWdlKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWFpbiA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuY29uc3QgZGVtb18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3dpZGdldHMvZGVtb1wiKTtcbjtcbmNvbnN0IG5hdl8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9tZW51L25hdlwiKTtcbjtcbmNvbnN0IGl0ZW1fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvbWVudS9pdGVtXCIpO1xuO1xuY29uc3QgbGlua18xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9jb250ZW50L2xpbmtcIik7XG47XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBkZW1vXzEuRGVtbyh7fSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaDMnLCB7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnVGhpcyBpcyBhIGhvcml6b250YWwgbmF2LicpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBuYXZfMS5OYXZNZW51KHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBpdGVtXzEuSXRlbSh7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGxpbmtfMS5MaW5rKHsgJ3RleHQnOiAnSG9tZScgfSwgW10pLCB7ICd0ZXh0JzogJ0hvbWUnIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgaXRlbV8xLkl0ZW0oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBsaW5rXzEuTGluayh7ICdkaXNhYmxlZCc6IHRydWUsICd0ZXh0JzogJ1VzZXJzJyB9LCBbXSksIHsgJ2Rpc2FibGVkJzogdHJ1ZSwgJ3RleHQnOiAnVXNlcnMnIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSwge30pLFxuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgaXRlbV8xLkl0ZW0oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBsaW5rXzEuTGluayh7ICd0ZXh0JzogJ0xvZ291dCcgfSwgW10pLCB7ICd0ZXh0JzogJ0xvZ291dCcgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgICAgICAgICAgXSksIHt9KVxuICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgZGVtb18xLkRlbW8oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2gzJywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1RoaXMgaXMgYSB2ZXJ0aWNhbCBuYXYuJylcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IG5hdl8xLk5hdk1lbnUoeyAndmVydGljYWwnOiB0cnVlIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGl0ZW1fMS5JdGVtKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgbGlua18xLkxpbmsoeyAndGV4dCc6ICdIb21lJyB9LCBbXSksIHsgJ3RleHQnOiAnSG9tZScgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBpdGVtXzEuSXRlbSh7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGxpbmtfMS5MaW5rKHsgJ2Rpc2FibGVkJzogdHJ1ZSwgJ3RleHQnOiAnVXNlcnMnIH0sIFtdKSwgeyAnZGlzYWJsZWQnOiB0cnVlLCAndGV4dCc6ICdVc2VycycgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLCB7fSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBpdGVtXzEuSXRlbSh7fSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGxpbmtfMS5MaW5rKHsgJ3RleHQnOiAnTG9nb3V0JyB9LCBbXSksIHsgJ3RleHQnOiAnTG9nb3V0JyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksIHt9KVxuICAgICAgICAgICAgICAgICAgICBdKSwgeyAndmVydGljYWwnOiB0cnVlIH0pXG4gICAgICAgICAgICAgICAgXSksIHt9KVxuICAgICAgICAgICAgXSksIHt9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uYXYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhZ2VzID0gdm9pZCAwO1xuZXhwb3J0cy5wYWdlcyA9IHtcbiAgICAnY29udGVudF9lbWJlZCc6IHJlcXVpcmUoJy4vcGFnZS9jb250ZW50X2VtYmVkJykuZGVmYXVsdCxcbiAgICAnY29udGVudF9saW5rJzogcmVxdWlyZSgnLi9wYWdlL2NvbnRlbnRfbGluaycpLmRlZmF1bHQsXG4gICAgJ2NvbnRlbnRfbWVkaWEtZGVzY3JpcHRpb24nOiByZXF1aXJlKCcuL3BhZ2UvY29udGVudF9tZWRpYS1kZXNjcmlwdGlvbicpLmRlZmF1bHQsXG4gICAgJ2NvbnRlbnRfb3ZlcmxheSc6IHJlcXVpcmUoJy4vcGFnZS9jb250ZW50X292ZXJsYXknKS5kZWZhdWx0LFxuICAgICdjb250ZW50X3RhZyc6IHJlcXVpcmUoJy4vcGFnZS9jb250ZW50X3RhZycpLmRlZmF1bHQsXG4gICAgJ2NvbnRlbnRfdGh1bWJuYWlsJzogcmVxdWlyZSgnLi9wYWdlL2NvbnRlbnRfdGh1bWJuYWlsJykuZGVmYXVsdCxcbiAgICAnY29udHJvbF9idXR0b24nOiByZXF1aXJlKCcuL3BhZ2UvY29udHJvbF9idXR0b24nKS5kZWZhdWx0LFxuICAgICdjb250cm9sX2J1dHRvbi1ncm91cCc6IHJlcXVpcmUoJy4vcGFnZS9jb250cm9sX2J1dHRvbi1ncm91cCcpLmRlZmF1bHQsXG4gICAgJ2NvbnRyb2xfYnV0dG9uLXNlbGVjdCc6IHJlcXVpcmUoJy4vcGFnZS9jb250cm9sX2J1dHRvbi1zZWxlY3QnKS5kZWZhdWx0LFxuICAgICdjb250cm9sX2NoZWNrYm94JzogcmVxdWlyZSgnLi9wYWdlL2NvbnRyb2xfY2hlY2tib3gnKS5kZWZhdWx0LFxuICAgICdjb250cm9sX2RhdGUtZmllbGQnOiByZXF1aXJlKCcuL3BhZ2UvY29udHJvbF9kYXRlLWZpZWxkJykuZGVmYXVsdCxcbiAgICAnY29udHJvbF9kaXNwbGF5LWZpZWxkJzogcmVxdWlyZSgnLi9wYWdlL2NvbnRyb2xfZGlzcGxheS1maWVsZCcpLmRlZmF1bHQsXG4gICAgJ2NvbnRyb2xfZHJvcC1kb3duJzogcmVxdWlyZSgnLi9wYWdlL2NvbnRyb2xfZHJvcC1kb3duJykuZGVmYXVsdCxcbiAgICAnY29udHJvbF9kcm9wLWxpc3QnOiByZXF1aXJlKCcuL3BhZ2UvY29udHJvbF9kcm9wLWxpc3QnKS5kZWZhdWx0LFxuICAgICdjb250cm9sX2Ryb3AtbGlzdC1maWVsZCc6IHJlcXVpcmUoJy4vcGFnZS9jb250cm9sX2Ryb3AtbGlzdC1maWVsZCcpLmRlZmF1bHQsXG4gICAgJ2NvbnRyb2xfZmlsZS11cGxvYWQtc3VyZmFjZSc6IHJlcXVpcmUoJy4vcGFnZS9jb250cm9sX2ZpbGUtdXBsb2FkLXN1cmZhY2UnKS5kZWZhdWx0LFxuICAgICdjb250cm9sX2lucHV0LWdyb3VwJzogcmVxdWlyZSgnLi9wYWdlL2NvbnRyb2xfaW5wdXQtZ3JvdXAnKS5kZWZhdWx0LFxuICAgICdjb250cm9sX211bHRpLXNlbGVjdCc6IHJlcXVpcmUoJy4vcGFnZS9jb250cm9sX211bHRpLXNlbGVjdCcpLmRlZmF1bHQsXG4gICAgJ2NvbnRyb2xfcGFnZXInOiByZXF1aXJlKCcuL3BhZ2UvY29udHJvbF9wYWdlcicpLmRlZmF1bHQsXG4gICAgJ2NvbnRyb2xfcGFnaW5hdG9yJzogcmVxdWlyZSgnLi9wYWdlL2NvbnRyb2xfcGFnaW5hdG9yJykuZGVmYXVsdCxcbiAgICAnY29udHJvbF9yYW5nZWQtcGFnZXInOiByZXF1aXJlKCcuL3BhZ2UvY29udHJvbF9yYW5nZWQtcGFnZXInKS5kZWZhdWx0LFxuICAgICdjb250cm9sX3NlYXJjaCc6IHJlcXVpcmUoJy4vcGFnZS9jb250cm9sX3NlYXJjaCcpLmRlZmF1bHQsXG4gICAgJ2NvbnRyb2xfc2VsZWN0JzogcmVxdWlyZSgnLi9wYWdlL2NvbnRyb2xfc2VsZWN0JykuZGVmYXVsdCxcbiAgICAnY29udHJvbF9zdGFjayc6IHJlcXVpcmUoJy4vcGFnZS9jb250cm9sX3N0YWNrJykuZGVmYXVsdCxcbiAgICAnY29udHJvbF9zdGFjay1zZWxlY3QnOiByZXF1aXJlKCcuL3BhZ2UvY29udHJvbF9zdGFjay1zZWxlY3QnKS5kZWZhdWx0LFxuICAgICdjb250cm9sX3N3aXRjaCc6IHJlcXVpcmUoJy4vcGFnZS9jb250cm9sX3N3aXRjaCcpLmRlZmF1bHQsXG4gICAgJ2NvbnRyb2xfdGFiLWJhcic6IHJlcXVpcmUoJy4vcGFnZS9jb250cm9sX3RhYi1iYXInKS5kZWZhdWx0LFxuICAgICdjb250cm9sX3RhZy1jb250cm9sJzogcmVxdWlyZSgnLi9wYWdlL2NvbnRyb2xfdGFnLWNvbnRyb2wnKS5kZWZhdWx0LFxuICAgICdjb250cm9sX3RleHQtZmllbGQnOiByZXF1aXJlKCcuL3BhZ2UvY29udHJvbF90ZXh0LWZpZWxkJykuZGVmYXVsdCxcbiAgICAnY29udHJvbF90ZXh0LWlucHV0JzogcmVxdWlyZSgnLi9wYWdlL2NvbnRyb2xfdGV4dC1pbnB1dCcpLmRlZmF1bHQsXG4gICAgJ2NvbnRyb2xfdG9vbGJhcic6IHJlcXVpcmUoJy4vcGFnZS9jb250cm9sX3Rvb2xiYXInKS5kZWZhdWx0LFxuICAgICdjb250cm9sX3R5cGVhaGVhZCc6IHJlcXVpcmUoJy4vcGFnZS9jb250cm9sX3R5cGVhaGVhZCcpLmRlZmF1bHQsXG4gICAgJ2RhdGFfZGF0YS10YWJsZSc6IHJlcXVpcmUoJy4vcGFnZS9kYXRhX2RhdGEtdGFibGUnKS5kZWZhdWx0LFxuICAgICdkYXRhX3Byb3BlcnR5LWxpc3QnOiByZXF1aXJlKCcuL3BhZ2UvZGF0YV9wcm9wZXJ0eS1saXN0JykuZGVmYXVsdCxcbiAgICAnZGlhbG9nX2FsZXJ0JzogcmVxdWlyZSgnLi9wYWdlL2RpYWxvZ19hbGVydCcpLmRlZmF1bHQsXG4gICAgJ2RpYWxvZ19jb25maXJtJzogcmVxdWlyZSgnLi9wYWdlL2RpYWxvZ19jb25maXJtJykuZGVmYXVsdCxcbiAgICAnZGlhbG9nX2luZm9ybSc6IHJlcXVpcmUoJy4vcGFnZS9kaWFsb2dfaW5mb3JtJykuZGVmYXVsdCxcbiAgICAnZGlhbG9nX21vZGFsJzogcmVxdWlyZSgnLi9wYWdlL2RpYWxvZ19tb2RhbCcpLmRlZmF1bHQsXG4gICAgJ2RpYWxvZ19wcm9tcHQnOiByZXF1aXJlKCcuL3BhZ2UvZGlhbG9nX3Byb21wdCcpLmRlZmF1bHQsXG4gICAgJ2xheW91dF9jYWxsb3V0JzogcmVxdWlyZSgnLi9wYWdlL2xheW91dF9jYWxsb3V0JykuZGVmYXVsdCxcbiAgICAnbGF5b3V0X2Rlc2NyaXB0aW9uLWxpc3QnOiByZXF1aXJlKCcuL3BhZ2UvbGF5b3V0X2Rlc2NyaXB0aW9uLWxpc3QnKS5kZWZhdWx0LFxuICAgICdsYXlvdXRfZ3JpZCc6IHJlcXVpcmUoJy4vcGFnZS9sYXlvdXRfZ3JpZCcpLmRlZmF1bHQsXG4gICAgJ2xheW91dF9ob3Jpem9udGFsJzogcmVxdWlyZSgnLi9wYWdlL2xheW91dF9ob3Jpem9udGFsJykuZGVmYXVsdCxcbiAgICAnbGF5b3V0X2xpc3QnOiByZXF1aXJlKCcuL3BhZ2UvbGF5b3V0X2xpc3QnKS5kZWZhdWx0LFxuICAgICdsYXlvdXRfbWV0ZXInOiByZXF1aXJlKCcuL3BhZ2UvbGF5b3V0X21ldGVyJykuZGVmYXVsdCxcbiAgICAnbGF5b3V0X3BhbmVsJzogcmVxdWlyZSgnLi9wYWdlL2xheW91dF9wYW5lbCcpLmRlZmF1bHQsXG4gICAgJ2xheW91dF90YWInOiByZXF1aXJlKCcuL3BhZ2UvbGF5b3V0X3RhYicpLmRlZmF1bHQsXG4gICAgJ2xheW91dF90YWJsZSc6IHJlcXVpcmUoJy4vcGFnZS9sYXlvdXRfdGFibGUnKS5kZWZhdWx0LFxuICAgICdsYXlvdXRfd2VsbCc6IHJlcXVpcmUoJy4vcGFnZS9sYXlvdXRfd2VsbCcpLmRlZmF1bHQsXG4gICAgJ21lbnVfbWVudSc6IHJlcXVpcmUoJy4vcGFnZS9tZW51X21lbnUnKS5kZWZhdWx0LFxuICAgICdtZW51X25hdic6IHJlcXVpcmUoJy4vcGFnZS9tZW51X25hdicpLmRlZmF1bHQsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFnZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRlbW8gPSB2b2lkIDA7XG5jb25zdCB3bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbmNvbnN0IHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2RlbW9cIik7XG5jbGFzcyBEZW1vIGV4dGVuZHMgd21sLkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHNpemU6IHRoaXMuYXR0cnMuc2l6ZSxcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy5hdHRycy5vZmZzZXRcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkRlbW8gPSBEZW1vO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1haW4gPSB2b2lkIDA7XG5jb25zdCBfX2RvY3VtZW50ID0gcmVxdWlyZShcIkBxdWVuay93bWwvbGliL2RvbVwiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxuY29uc3QgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbmNvbnN0IGdyaWRfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvbGF5b3V0L2dyaWRcIik7XG47XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19pZiA9IChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkgPT4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQgPyBfX2FsdCgpIDogW107XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JJbiA9IChsaXN0LCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbmNvbnN0IF9fZm9yT2YgPSAobywgZiwgYWx0KSA9PiB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdGV4dCA9IF9fZG9jdW1lbnQudGV4dDtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgdW5zYWZlID0gX19kb2N1bWVudC51bnNhZmU7XG4vLyBAdHMtaWdub3JlIDYxOTJcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsO1xuY2xhc3MgTWFpbiB7XG4gICAgY29uc3RydWN0b3IoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoX190aGlzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChuZXcgZ3JpZF8xLkdyaWRMYXlvdXQoe30sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBncmlkXzEuUm93KHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGdyaWRfMS5Db2x1bW4oeyAnc3Bhbic6IF9fY29udGV4dC52YWx1ZXMuc2l6ZSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi4oX19jb250ZXh0LmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgICAgICBdKSwgeyAnc3Bhbic6IF9fY29udGV4dC52YWx1ZXMuc2l6ZSB9KVxuICAgICAgICAgICAgICAgIF0pLCB7fSlcbiAgICAgICAgICAgIF0pLCB7fSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyVmlldyh2KSB7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGUsIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyc01hcCA9IGF0dHJzO1xuICAgICAgICBpZiAoYXR0cnNNYXAud21sKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgZ3JvdXAgfSA9IGF0dHJzTWFwLndtbDtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgaWQgJyR7aWR9JyBkZXRlY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIG5vZGUodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGUgPSBfX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19kb2N1bWVudC5pc0Jyb3dzZXIgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIF9fZG9jdW1lbnQuV01MRE9NVGV4dCkge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0biA9IF9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBhZG9wdCBjaGlsZCAke2N9IG9mIHR5cGUgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgd2lkZ2V0KHcsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfVxuICAgIGZpbmRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtVyA9ICgwLCBtYXliZV8xLmZyb21OdWxsYWJsZSkodGhpcy5pZHNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5SWQoaWQpLCBtVyk7XG4gICAgfVxuICAgIGZpbmRCeUdyb3VwKG5hbWUpIHtcbiAgICAgICAgbGV0IG1Hcm91cCA9ICgwLCBtYXliZV8xLmZyb21BcnJheSkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlHcm91cChuYW1lKSwgbUdyb3VwKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgdHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdNaXNzaW5nIERPTSB0cmVlIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRhdGUoKTogY2Fubm90IGludmFsaWRhdGUgdGhpcyB2aWV3LCBpdCBoYXMgbm8gcGFyZW50IG5vZGUhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9XG59XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVtby5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWFpbiA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuY29uc3QgZHJhd2VyXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vbGliL2xheW91dC9kcmF3ZXJcIik7XG47XG5jb25zdCBhY3Rpb25fYmFyXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vbGliL2xheW91dC9hY3Rpb24tYmFyXCIpO1xuO1xuY29uc3QgbGlua18xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2xpYi9jb250ZW50L2xpbmtcIik7XG47XG5jb25zdCBtZW51X2ljb25fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9saWIvY29udGVudC9tZW51LWljb25cIik7XG47XG5jb25zdCBtYWluXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vbGliL2xheW91dC9tYWluXCIpO1xuO1xuO1xuY29uc3QgbmF2aWdhdGlvbl8xID0gcmVxdWlyZShcIi4vbmF2aWdhdGlvblwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KG5ldyBkcmF3ZXJfMS5EcmF3ZXJMYXlvdXQoeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pZC5sYXlvdXQgfSwgJ2RyYXdlcic6ICduYXYnLCAnY29udGVudCc6ICdtYWluJywgJ29wZW4nOiB0cnVlIH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMucmVnaXN0ZXJWaWV3KG5ldyBuYXZpZ2F0aW9uXzEuTmF2aWdhdGlvbihfX2NvbnRleHQpKS5yZW5kZXIoKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBhY3Rpb25fYmFyXzEuQWN0aW9uQmFyKHsgJ2lkJzogJ2FwcEJhcicgfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBsaW5rXzEuTGluayh7ICdvbkNsaWNrJzogX19jb250ZXh0LnRvZ2dsZURyYXdlciB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBtZW51X2ljb25fMS5NZW51SWNvbih7fSwgW10pLCB7fSlcbiAgICAgICAgICAgICAgICAgICAgXSksIHsgJ29uQ2xpY2snOiBfX2NvbnRleHQudG9nZ2xlRHJhd2VyIH0pXG4gICAgICAgICAgICAgICAgXSksIHsgJ2lkJzogJ2FwcEJhcicgfSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgbWFpbl8xLk1haW5MYXlvdXQoeyAnaWQnOiAnbWFpbicgfSwgW1xuICAgICAgICAgICAgICAgICAgICAuLi4oX19jb250ZXh0LmNvbnRlbnQpXG4gICAgICAgICAgICAgICAgXSksIHsgJ2lkJzogJ21haW4nIH0pXG4gICAgICAgICAgICBdKSwgeyB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pZC5sYXlvdXQgfSwgJ2RyYXdlcic6ICduYXYnLCAnY29udGVudCc6ICdtYWluJywgJ29wZW4nOiB0cnVlIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclZpZXcodikge1xuICAgICAgICB0aGlzLnZpZXdzLnB1c2godik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZWdpc3RlcihlLCBhdHRycykge1xuICAgICAgICBsZXQgYXR0cnNNYXAgPSBhdHRycztcbiAgICAgICAgaWYgKGF0dHJzTWFwLndtbCkge1xuICAgICAgICAgICAgbGV0IHsgaWQsIGdyb3VwIH0gPSBhdHRyc01hcC53bWw7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGlkICcke2lkfScgZGV0ZWN0ZWQhYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBub2RlKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fZG9jdW1lbnQuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBfX2RvY3VtZW50LldNTERPTVRleHQpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdG4gPSBfX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgYWRvcHQgY2hpbGQgJHtjfSBvZiB0eXBlICR7dHlwZW9mIGN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHdpZGdldCh3LCBhdHRycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH1cbiAgICBmaW5kQnlJZChpZCkge1xuICAgICAgICBsZXQgbVcgPSAoMCwgbWF5YmVfMS5mcm9tTnVsbGFibGUpKHRoaXMuaWRzW2lkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUlkKGlkKSwgbVcpO1xuICAgIH1cbiAgICBmaW5kQnlHcm91cChuYW1lKSB7XG4gICAgICAgIGxldCBtR3JvdXAgPSAoMCwgbWF5YmVfMS5mcm9tQXJyYXkpKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MucmVkdWNlKChwLCBjKSA9PiBwLmlzSnVzdCgpID8gcCA6IGMuZmluZEJ5R3JvdXAobmFtZSksIG1Hcm91cCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCB7IHRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnTWlzc2luZyBET00gdHJlZSEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkYXRlKCk6IGNhbm5vdCBpbnZhbGlkYXRlIHRoaXMgdmlldywgaXQgaGFzIG5vIHBhcmVudCBub2RlIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW1vdmVkKCkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVuZGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTmF2aWdhdGlvbiA9IHZvaWQgMDtcbmNvbnN0IF9fZG9jdW1lbnQgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC9saWIvZG9tXCIpO1xuLy9AdHMtaWdub3JlOiA2MTkyXG5jb25zdCBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuO1xuY29uc3QgbmF2XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vbGliL21lbnUvbmF2XCIpO1xuO1xuY29uc3QgaXRlbV8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2xpYi9tZW51L2l0ZW1cIik7XG47XG5jb25zdCBoZWFkZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9saWIvbWVudS9oZWFkZXJcIik7XG47XG5jb25zdCBsaW5rXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vbGliL2NvbnRlbnQvbGlua1wiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2lmID0gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSA9PiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCA/IF9fYWx0KCkgOiBbXTtcbi8vQHRzLWlnbm9yZTo2MTkyXG5jb25zdCBfX2ZvckluID0gKGxpc3QsIGYsIGFsdCkgPT4ge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxuY29uc3QgX19mb3JPZiA9IChvLCBmLCBhbHQpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB0ZXh0ID0gX19kb2N1bWVudC50ZXh0O1xuLy8gQHRzLWlnbm9yZSA2MTkyXG5jb25zdCB1bnNhZmUgPSBfX2RvY3VtZW50LnVuc2FmZTtcbi8vIEB0cy1pZ25vcmUgNjE5MlxuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGw7XG5jbGFzcyBOYXZpZ2F0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IChfX3RoaXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KG5ldyBuYXZfMS5OYXZNZW51KHsgJ2lkJzogJ25hdicsICd2ZXJ0aWNhbCc6IHRydWUgfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGl0ZW1fMS5JdGVtKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGxpbmtfMS5MaW5rKHsgd21sOiB7ICdncm91cCc6ICdsaW5rcycgfSwgJ2FjdGl2ZSc6IChfX2NvbnRleHQucGFnZSA9PT0gJ2hvbWUnKSwgJ25hbWUnOiAnaG9tZScsICdocmVmJzogJyMnLCAnb25DbGljayc6IF9fY29udGV4dC5uYXZpZ2F0ZSwgJ3RleHQnOiAnSG9tZScgfSwgW10pLCB7IHdtbDogeyAnZ3JvdXAnOiAnbGlua3MnIH0sICdhY3RpdmUnOiAoX19jb250ZXh0LnBhZ2UgPT09ICdob21lJyksICduYW1lJzogJ2hvbWUnLCAnaHJlZic6ICcjJywgJ29uQ2xpY2snOiBfX2NvbnRleHQubmF2aWdhdGUsICd0ZXh0JzogJ0hvbWUnIH0pXG4gICAgICAgICAgICAgICAgXSksIHt9KSxcbiAgICAgICAgICAgICAgICAuLi5fX2Zvck9mKF9fY29udGV4dC5wYWdlcywgKGl0ZW1zLCBzZWN0aW9uLCBfJCRhbGwpID0+IChbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGl0ZW1fMS5JdGVtKHt9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBoZWFkZXJfMS5NZW51SGVhZGVyKHsgJ3RleHQnOiBzZWN0aW9uIH0sIFtdKSwgeyAndGV4dCc6IHNlY3Rpb24gfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5ldyBuYXZfMS5OYXZNZW51KHsgJ3ZlcnRpY2FsJzogdHJ1ZSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uX19mb3JPZihpdGVtcywgKF8sIG5hbWUsIF8kJGFsbCkgPT4gKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuZXcgaXRlbV8xLkl0ZW0oe30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobmV3IGxpbmtfMS5MaW5rKHsgd21sOiB7ICdncm91cCc6ICdsaW5rcycgfSwgJ25hbWUnOiBuYW1lLCAnaHJlZic6ICgnIy8nICsgbmFtZSksICdvbkNsaWNrJzogX19jb250ZXh0Lm5hdmlnYXRlLCAnYWN0aXZlJzogKF9fY29udGV4dC5wYWdlID09PSBuYW1lKSwgJ3RleHQnOiBuYW1lIH0sIFtdKSwgeyB3bWw6IHsgJ2dyb3VwJzogJ2xpbmtzJyB9LCAnbmFtZSc6IG5hbWUsICdocmVmJzogKCcjLycgKyBuYW1lKSwgJ29uQ2xpY2snOiBfX2NvbnRleHQubmF2aWdhdGUsICdhY3RpdmUnOiAoX19jb250ZXh0LnBhZ2UgPT09IG5hbWUpLCAndGV4dCc6IG5hbWUgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSksIHt9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLCAoKSA9PiAoW10pKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksIHsgJ3ZlcnRpY2FsJzogdHJ1ZSB9KVxuICAgICAgICAgICAgICAgICAgICBdKSwge30pXG4gICAgICAgICAgICAgICAgXSksICgpID0+IChbXSkpXG4gICAgICAgICAgICBdKSwgeyAnaWQnOiAnbmF2JywgJ3ZlcnRpY2FsJzogdHJ1ZSB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJWaWV3KHYpIHtcbiAgICAgICAgdGhpcy52aWV3cy5wdXNoKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSwgYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHJzTWFwID0gYXR0cnM7XG4gICAgICAgIGlmIChhdHRyc01hcC53bWwpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBncm91cCB9ID0gYXR0cnNNYXAud21sO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBpZCAnJHtpZH0nIGRldGVjdGVkIWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgbm9kZSh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgZSA9IF9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX2RvY3VtZW50LmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgX19kb2N1bWVudC5XTUxET01UZXh0KSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuID0gX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IGFkb3B0IGNoaWxkICR7Y30gb2YgdHlwZSAke3R5cGVvZiBjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB3aWRnZXQodywgYXR0cnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1XID0gKDAsIG1heWJlXzEuZnJvbU51bGxhYmxlKSh0aGlzLmlkc1tpZF0pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5yZWR1Y2UoKHAsIGMpID0+IHAuaXNKdXN0KCkgPyBwIDogYy5maW5kQnlJZChpZCksIG1XKTtcbiAgICB9XG4gICAgZmluZEJ5R3JvdXAobmFtZSkge1xuICAgICAgICBsZXQgbUdyb3VwID0gKDAsIG1heWJlXzEuZnJvbUFycmF5KSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLnJlZHVjZSgocCwgYykgPT4gcC5pc0p1c3QoKSA/IHAgOiBjLmZpbmRCeUdyb3VwKG5hbWUpLCBtR3JvdXApO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICBsZXQgeyB0cmVlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ01pc3NpbmcgRE9NIHRyZWUhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZGF0ZSgpOiBjYW5ub3QgaW52YWxpZGF0ZSB0aGlzIHZpZXcsIGl0IGhhcyBubyBwYXJlbnQgbm9kZSEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3ID0+IHcucmVtb3ZlZCgpKTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbmRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH1cbn1cbmV4cG9ydHMuTmF2aWdhdGlvbiA9IE5hdmlnYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uYXZpZ2F0aW9uLmpzLm1hcCJdfQ==
