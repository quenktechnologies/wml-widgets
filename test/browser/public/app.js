(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/caret");
var wml_1 = require("@quenk/wml");
var util_1 = require("../../util");
///classNames:begin
exports.CARET = 'ww-caret';
/**
 * Caret
 */
var Caret = /** @class */ (function (_super) {
    __extends(Caret, _super);
    function Caret() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: {
                id: (_this.attrs.ww && _this.attrs.ww.id) ? _this.attrs.ww.id : '',
                className: util_1.concat(exports.CARET, (_this.attrs.ww && _this.attrs.ww.className) ?
                    _this.attrs.ww.className : '')
            }
        };
        return _this;
    }
    return Caret;
}(wml_1.Component));
exports.Caret = Caret;

},{"../../util":138,"./wml/caret":2,"@quenk/wml":145}],2:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('span', { html: { 'id': __context.values.root.id, 'class': __context.values.root.className }, wml: {} }, []);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":141}],3:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/close");
var wml_1 = require("@quenk/wml");
var util_1 = require("../../util");
///classNames:begin
exports.CLOSE = 'ww-close';
/**
 * Close
 */
var Close = /** @class */ (function (_super) {
    __extends(Close, _super);
    function Close() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            id: (_this.attrs.ww && _this.attrs.ww.id) ?
                _this.attrs.ww.id : '',
            className: util_1.concat(exports.CLOSE, (_this.attrs.ww && _this.attrs.ww.className) ?
                _this.attrs.ww.className : ''),
            onClick: (_this.attrs.ww && _this.attrs.ww.onClick) ?
                _this.attrs.ww.onClick : function () { }
        };
        return _this;
    }
    return Close;
}(wml_1.Component));
exports.Close = Close;

},{"../../util":138,"./wml/close":4,"@quenk/wml":145}],4:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('span', { html: { 'id': __context.values.id, 'class': __context.values.className, 'onclick': __context.values.onClick }, wml: {} }, [
                document.createTextNode("\u00D7")
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":141}],5:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml_1 = require("@quenk/wml");
var util_1 = require("../../util");
var __1 = require("../../");
var embed_1 = require("./wml/embed");
///classNames:begin
exports.EMBED = 'ww-embed';
/**
 * Embed
 */
var Embed = /** @class */ (function (_super) {
    __extends(Embed, _super);
    function Embed() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new embed_1.Main(_this);
        _this.values = {
            wml: {
                id: 'embed'
            },
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.EMBED, __1.getClassName(_this.attrs)),
        };
        return _this;
    }
    return Embed;
}(wml_1.Component));
exports.Embed = Embed;

},{"../../":101,"../../util":138,"./wml/embed":6,"@quenk/wml":145}],6:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'id': __context.values.id, 'class': __context.values.className }, wml: {} }, __spreadArrays((__context.children)));
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":141}],7:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml = require("@quenk/wml");
var views = require("./wml/link");
var util_1 = require("../../util");
var active_1 = require("../state/active");
///classNames:begin
/**
 * LINK
 */
exports.LINK = 'ww-link';
/**
 * LinkClickedEvent indicates an Link has been clicked.
 */
var LinkClickedEvent = /** @class */ (function () {
    function LinkClickedEvent(name, href) {
        this.name = name;
        this.href = href;
    }
    return LinkClickedEvent;
}());
exports.LinkClickedEvent = LinkClickedEvent;
/**
 * Link generates an <a> element.
 */
var Link = /** @class */ (function (_super) {
    __extends(Link, _super);
    function Link() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        /**
         * name assigned to this Link.
         */
        _this.name = (_this.attrs.ww && _this.attrs.ww.name) ?
            _this.attrs.ww.name : '';
        /**
         * title assigned to this Link.
         */
        _this.title = (_this.attrs.ww && _this.attrs.ww.title) ?
            _this.attrs.ww.title : '';
        /**
         * href assigned to this Link
         */
        _this.href = (_this.attrs.ww && _this.attrs.ww.href) ?
            _this.attrs.ww.href : '';
        _this.values = {
            a: {
                id: (_this.attrs.ww && _this.attrs.ww.id) ?
                    _this.attrs.ww.id : '',
                disabled: (_this.attrs.ww && _this.attrs.ww.disabled) ?
                    _this.attrs.ww.disabled : null,
                className: util_1.concat(exports.LINK, (_this.attrs.ww && _this.attrs.ww.className) ?
                    _this.attrs.ww.className : '', (_this.attrs.ww && _this.attrs.ww.active) ?
                    active_1.ACTIVE : ''),
                title: (_this.attrs.ww && _this.attrs.ww.title) ?
                    _this.attrs.ww.title : null,
                name: (_this.attrs.ww && _this.attrs.ww.name) ?
                    _this.attrs.ww.name : null,
                href: (_this.attrs.ww && _this.attrs.ww.href) ?
                    _this.attrs.ww.href : '#',
                active: (_this.attrs.ww && _this.attrs.ww.active) ?
                    _this.attrs.ww.active : false,
                //TODO: move to dom lib
                content: (_this.attrs.ww && _this.attrs.ww.text) ?
                    [document.createTextNode(_this.attrs.ww.text)] :
                    _this.children,
                clicked: function (e) {
                    if (_this.attrs.ww) {
                        var _a = _this.attrs.ww, name_1 = _a.name, href = _a.href, onClick = _a.onClick;
                        if (!href)
                            e.preventDefault();
                        if (onClick)
                            onClick(new LinkClickedEvent(name_1, href));
                    }
                }
            }
        };
        return _this;
    }
    /**
      * activate this nav list Item.
      */
    Link.prototype.activate = function () {
        var m = util_1.getById(this.view, this.values.a.id);
        if (m.isJust()) {
            var e = m.get();
            e.classList.remove(active_1.ACTIVE);
            e.classList.add(active_1.ACTIVE);
        }
        return this;
    };
    /**
     * deactivate this nav list item.
     */
    Link.prototype.deactivate = function () {
        var m = util_1.getById(this.view, this.values.a.id);
        if (m.isJust())
            m.get().classList.remove(active_1.ACTIVE);
        return this;
    };
    return Link;
}(wml.Component));
exports.Link = Link;

},{"../../util":138,"../state/active":17,"./wml/link":8,"@quenk/wml":145}],8:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('a', { html: { 'id': __context.values.a.id, 'class': __context.values.a.className, 'href': __context.values.a.href, 'title': __context.values.a.title, 'disabled': __context.values.a.disabled, 'onclick': __context.values.a.clicked }, wml: {} }, __spreadArrays((__context.values.a.content)));
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":141}],9:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/media-description");
var wml_1 = require("@quenk/wml");
var util_1 = require("../../util");
var __1 = require("../../");
///classNames:begin
exports.MEDIA_DESCRIPTION = 'ww-media-description';
exports.MEDIA_DESCRIPTION_MEDIA = 'ww-media-description__media';
exports.MEDIA_DESCRIPTION_DESCRIPTION = 'ww-media-description__description';
/**
 * MediaDescription
 */
var MediaDescription = /** @class */ (function (_super) {
    __extends(MediaDescription, _super);
    function MediaDescription() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.MediaDescription(_this);
        _this.values = {
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.MEDIA_DESCRIPTION, __1.getClassName(_this.attrs))
        };
        return _this;
    }
    return MediaDescription;
}(wml_1.Component));
exports.MediaDescription = MediaDescription;
/**
 * Media
 */
var Media = /** @class */ (function (_super) {
    __extends(Media, _super);
    function Media() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Media(_this);
        _this.values = {
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.MEDIA_DESCRIPTION_MEDIA, __1.getClassName(_this.attrs))
        };
        return _this;
    }
    return Media;
}(wml_1.Component));
exports.Media = Media;
/**
 * Description
 */
var Description = /** @class */ (function (_super) {
    __extends(Description, _super);
    function Description() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Description(_this);
        _this.values = {
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.MEDIA_DESCRIPTION_DESCRIPTION, __1.getClassName(_this.attrs))
        };
        return _this;
    }
    return Description;
}(wml_1.Component));
exports.Description = Description;

},{"../../":101,"../../util":138,"./wml/media-description":10,"@quenk/wml":145}],10:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var MediaDescription = /** @class */ (function () {
    function MediaDescription(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'id': __context.values.id, 'class': __context.values.className }, wml: {} }, __spreadArrays((__context.children)));
        };
    }
    MediaDescription.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    MediaDescription.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    MediaDescription.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    MediaDescription.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    MediaDescription.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    MediaDescription.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    MediaDescription.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return MediaDescription;
}());
exports.MediaDescription = MediaDescription;
;
var Media = /** @class */ (function () {
    function Media(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'id': __context.values.id, 'class': __context.values.className }, wml: {} }, __spreadArrays((__context.children)));
        };
    }
    Media.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Media.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Media.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Media.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Media.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Media.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Media.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Media;
}());
exports.Media = Media;
;
var Description = /** @class */ (function () {
    function Description(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'id': __context.values.id, 'class': __context.values.className }, wml: {} }, __spreadArrays((__context.children)));
        };
    }
    Description.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Description.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Description.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Description.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Description.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Description.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Description.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Description;
}());
exports.Description = Description;

},{"@quenk/noni/lib/data/maybe":141}],11:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/menu-icon");
var wml_1 = require("@quenk/wml");
var util_1 = require("../../util");
///classNames:begin
exports.MENU_ICON = 'ww-menu-icon';
exports.MENU_ICON_DASH = 'ww-menu-icon__dash';
/**
 * MenuIcon provides a css implement icon normally used
 * to toggle a side menu.
 */
var MenuIcon = /** @class */ (function (_super) {
    __extends(MenuIcon, _super);
    function MenuIcon() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: {
                id: (_this.attrs.ww && _this.attrs.ww.id) ?
                    _this.attrs.ww.id : '',
                className: util_1.concat(exports.MENU_ICON, (_this.attrs.ww && _this.attrs.ww.id) ?
                    _this.attrs.ww.id : '')
            },
            dash: {
                id: 'dash',
                class: exports.MENU_ICON_DASH
            }
        };
        return _this;
    }
    return MenuIcon;
}(wml_1.Component));
exports.MenuIcon = MenuIcon;

},{"../../util":138,"./wml/menu-icon":12,"@quenk/wml":145}],12:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('span', { html: { 'id': __context.values.root.id, 'class': __context.values.root.className }, wml: {} }, [
                __this.node('span', { html: { 'class': __context.values.dash.class }, wml: {} }, []),
                __this.node('span', { html: { 'class': __context.values.dash.class }, wml: {} }, []),
                __this.node('span', { html: { 'class': __context.values.dash.class }, wml: {} }, [])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":141}],13:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
///classNames:begin
/**
 * VERTICAL indicates an element is vertical rendererd.
 */
exports.VERTICAL = '-vertical';
/**
 * PUSHABLE indicates an element supports being pushed
 * and can have styles added to it around the concept.
 */
exports.PUSHABLE = '-pushable';
/**
 * POSITIONED indicates an element is positioned and responds
 * to the left,right etc. properties.
 */
exports.POSITIONED = '-positioned';
/**
 * BLOCK indicates an element should be block displayed.
 */
exports.BLOCK = '-block';
/**
 * CLEARFIX hack.
 */
exports.CLEARFIX = '-clearfix';
/**
 * JUSTIFIED content.
 */
exports.JUSTIFIED = '-justified';
/**
 * LEFT indicates content floated or positioned to the left.
 */
exports.LEFT = '-left';
/**
 * RIGHT indicates content floated or positioned to the right.
 */
exports.RIGHT = '-right';
/**
 * HORIZONTAL indicates a horizontal alignment.
 */
exports.HORIZONTAL = '-horizontal';
exports.MIDDLE = '-middle';
exports.BOTTOM = '-bottom';
///classNames:end
/**
 * getBlockClassName provides the __BLOCK__ class name if the attribute
 * value is set to true.
 */
exports.getBlockClassName = function (attrs) {
    return (attrs.ww && (attrs.ww.block === true)) ? exports.BLOCK : '';
};

},{}],14:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml_1 = require("@quenk/wml");
var util_1 = require("../../util");
var __1 = require("../../");
var overlay_1 = require("./wml/overlay");
///classNames:begin
exports.OVERLAY = 'ww-overlay';
/**
 * Overlay
 */
var Overlay = /** @class */ (function (_super) {
    __extends(Overlay, _super);
    function Overlay() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new overlay_1.Main(_this);
        _this.values = {
            wml: {
                id: 'root'
            },
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.OVERLAY, __1.getClassName(_this.attrs)),
            onclick: function () {
                if (_this.attrs.ww && _this.attrs.ww.onClick)
                    _this.attrs.ww.onClick();
            }
        };
        return _this;
    }
    /**
     * close the overlay.
     */
    Overlay.prototype.close = function () {
        var mO = util_1.getById(this.view, this.values.wml.id);
        if (mO.isJust()) {
            var n = mO.get();
            if (n.parentNode)
                n.parentNode.removeChild(n);
        }
    };
    return Overlay;
}(wml_1.Component));
exports.Overlay = Overlay;

},{"../../":101,"../../util":138,"./wml/overlay":15,"@quenk/wml":145}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'id': __context.values.id, 'class': __context.values.className, 'onclick': __context.values.onclick }, wml: { 'id': __context.values.wml.id } }, []);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":141}],16:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
///classNames:begin
exports.EXTRA_SMALL = '-extra-small';
exports.SMALL = '-small';
exports.MEDIUM = '-medium';
exports.LARGE = '-large';
exports.EXTRA_LARGE = '-extra-large';
///classNames:end
/**
 * Size
 */
var Size;
(function (Size) {
    Size["ExtraSmall"] = "extra-small";
    Size["Small"] = "small";
    Size["Medium"] = "medium";
    Size["Large"] = "large";
    Size["ExtraLarge"] = "extra-large";
})(Size = exports.Size || (exports.Size = {}));
/**
 * getSizeClassName
 */
exports.getSizeClassName = function (s) {
    if (s === Size.ExtraSmall)
        return exports.EXTRA_SMALL;
    else if (s === Size.Small)
        return exports.SMALL;
    else if (s === Size.Medium)
        return exports.MEDIUM;
    else if (s === Size.Large)
        return exports.LARGE;
    else if (s === Size.ExtraLarge)
        return exports.EXTRA_LARGE;
    return '';
};

},{}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../../util");
///classNames:begin
/**
 * ACTIVE
 */
exports.ACTIVE = '-active';
/**
 * activate helper.
 *
 * Adds the ACTIVE class.
 */
exports.activate = function (view, id) {
    return util_1.getById(view, id)
        .map(function (e) {
        e.classList.remove(exports.ACTIVE);
        e.classList.add(exports.ACTIVE);
    });
};
/**
 * deactivate helper.
 *
 * Removes the ACTIVE class.
 */
exports.deactivate = function (view, id) {
    return util_1.getById(view, id)
        .map(function (e) { return e.classList.remove(exports.ACTIVE); });
};
/**
 * isActive helpder
 *
 * Queries whether the ACTIVE class is present.
 */
exports.isActive = function (view, id) {
    return util_1.getById(view, id)
        .map(function (e) { return e.classList.contains(exports.ACTIVE); })
        .orJust(function () { return false; })
        .get();
};

},{"../../util":138}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../../util");
///classNames:begin
/**
 * HIDDEN means an element should not be visible but not removed
 * from the DOM.
 */
exports.HIDDEN = '-ww-hidden';
/**
 * isHidden helper.
 *
 * Retrieves an HTMLElement by id and checks whether
 * it has the hidden class attached.
 */
exports.isHidden = function (view, id) {
    var m = view.findById(id);
    if (m.isNothing()) {
        util_1.warnMissing(view, id);
        return true;
    }
    else {
        return m.get().classList.contains(exports.HIDDEN);
    }
};
/**
 * hide helper.
 *
 * Attempts to add HIDDEN to the target elements class name.
 */
exports.hide = function (view, id) {
    var m = view.findById(id);
    if (m.isNothing()) {
        return util_1.warnMissing(view, id);
    }
    else {
        var e = m.get();
        e.classList.remove(exports.HIDDEN);
        e.classList.add(exports.HIDDEN);
    }
};
/**
 * show helper.
 *
 * Attempts to remove the HIDDEN class name from the target element.
 */
exports.show = function (view, id) {
    var m = view.findById(id);
    if (m.isNothing()) {
        return util_1.warnMissing(view, id);
    }
    else {
        m.get().classList.remove(exports.HIDDEN);
    }
};
/**
 * toggle helper.
 *
 * Attempts to toggle the HIDDEN class name from the target element
 * classList.
 */
exports.toggle = function (view, id) {
    var m = view.findById(id);
    if (m.isNothing()) {
        return util_1.warnMissing(view, id);
    }
    else {
        m.get().classList.toggle(exports.HIDDEN);
    }
};

},{"../../util":138}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
///classNames:begin
/**
 * DEFAULT style.
 */
exports.DEFAULT = '-default';
/**
 * PRIMARY style.
 */
exports.PRIMARY = '-primary';
/**
 * SUCCESS style.
 */
exports.SUCCESS = '-success';
/**
 * INFO style.
 */
exports.INFO = '-info';
/**
 * WARNING style.
 */
exports.WARNING = '-warning';
/**
 * ERROR style.
 */
exports.ERROR = '-error';
/**
 * OUTLINE style.
 */
exports.OUTLINE = '-outline';
///classNames:end
/**
 * Style enum.
 */
var Style;
(function (Style) {
    Style["Default"] = "default";
    Style["Primary"] = "primary";
    Style["Success"] = "success";
    Style["Info"] = "info";
    Style["Warning"] = "warning";
    Style["Error"] = "error";
})(Style = exports.Style || (exports.Style = {}));
exports.styles = [
    Style.Default,
    Style.Success,
    Style.Info,
    Style.Warning,
    Style.Error
];
/**
 * getStyleClassName
 */
exports.getStyleClassName = function (s) {
    switch (s) {
        case Style.Default:
            return exports.DEFAULT;
        case Style.Primary:
            return exports.PRIMARY;
        case Style.Success:
            return exports.SUCCESS;
        case Style.Info:
            return exports.INFO;
        case Style.Warning:
            return exports.WARNING;
        case Style.Error:
            return exports.ERROR;
    }
    return exports.DEFAULT;
};

},{}],20:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml_1 = require("@quenk/wml");
var style_1 = require("../../content/style");
exports.Style = style_1.Style;
var util_1 = require("../../util");
var __1 = require("../../");
var tag_1 = require("./wml/tag");
///classNames:begin
exports.TAG = 'ww-tag';
/**
 * Tag
 */
var Tag = /** @class */ (function (_super) {
    __extends(Tag, _super);
    function Tag() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new tag_1.Main(_this);
        _this.values = {
            wml: {
                id: 'tag'
            },
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.TAG, __1.getClassName(_this.attrs), (_this.attrs.ww && _this.attrs.ww.style) ?
                style_1.getStyleClassName(_this.attrs.ww.style) :
                style_1.DEFAULT),
            onclick: function (_) {
                if (_this.attrs.ww && _this.attrs.ww.onClick)
                    _this.attrs.ww.onClick();
            },
            content: (_this.attrs.ww && _this.attrs.ww.text) ?
                [__1.text(_this.attrs.ww.text)] : _this.children
        };
        return _this;
    }
    return Tag;
}(wml_1.Component));
exports.Tag = Tag;

},{"../../":101,"../../content/style":19,"../../util":138,"./wml/tag":21,"@quenk/wml":145}],21:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('span', { html: { 'id': __context.values.id, 'class': __context.values.className, 'onclick': __context.values.onclick }, wml: { 'id': __context.values.wml.id } }, __spreadArrays((__context.values.content)));
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":141}],22:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/thumbnail");
var wml_1 = require("@quenk/wml");
var util_1 = require("../../util");
var __1 = require("../../");
///classNames:begin
exports.THUMBNAIL = 'ww-thumbnail';
exports.THUMBNAIL_CAPTION = 'ww-thumbnail__caption';
/**
 * Thumbnail
 */
var Thumbnail = /** @class */ (function (_super) {
    __extends(Thumbnail, _super);
    function Thumbnail() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = (_this.attrs.ww && _this.attrs.ww.href) ?
            new views.Anchor(_this) : new views.Thumbnail(_this);
        _this.values = {
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.THUMBNAIL, __1.getClassName(_this.attrs)),
            href: (_this.attrs.ww && _this.attrs.ww.href) ?
                _this.attrs.ww.href : '',
            onclick: function (e) {
                if (_this.attrs.ww && _this.attrs.ww.onClick) {
                    e.preventDefault();
                    _this.attrs.ww.onClick();
                }
            }
        };
        return _this;
    }
    return Thumbnail;
}(wml_1.Component));
exports.Thumbnail = Thumbnail;
/**
 * Caption
 */
var Caption = /** @class */ (function (_super) {
    __extends(Caption, _super);
    function Caption() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Caption(_this);
        _this.values = {
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.THUMBNAIL_CAPTION, __1.getClassName(_this.attrs))
        };
        return _this;
    }
    return Caption;
}(wml_1.Component));
exports.Caption = Caption;

},{"../../":101,"../../util":138,"./wml/thumbnail":23,"@quenk/wml":145}],23:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Thumbnail = /** @class */ (function () {
    function Thumbnail(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'id': __context.values.id, 'class': __context.values.className, 'onclick': __context.values.onclick }, wml: {} }, __spreadArrays((__context.children)));
        };
    }
    Thumbnail.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Thumbnail.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Thumbnail.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Thumbnail.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Thumbnail.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Thumbnail.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Thumbnail.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Thumbnail;
}());
exports.Thumbnail = Thumbnail;
;
var Anchor = /** @class */ (function () {
    function Anchor(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('a', { html: { 'id': __context.values.id, 'class': __context.values.className, 'href': __context.values.href, 'onclick': __context.values.onclick }, wml: {} }, __spreadArrays((__context.children)));
        };
    }
    Anchor.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Anchor.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Anchor.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Anchor.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Anchor.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Anchor.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Anchor.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Anchor;
}());
exports.Anchor = Anchor;
;
var Caption = /** @class */ (function () {
    function Caption(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'id': __context.values.id, 'class': __context.values.className }, wml: {} }, __spreadArrays((__context.children)));
        };
    }
    Caption.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Caption.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Caption.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Caption.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Caption.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Caption.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Caption.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Caption;
}());
exports.Caption = Caption;

},{"@quenk/noni/lib/data/maybe":141}],24:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/button-group");
var wml_1 = require("@quenk/wml");
var util_1 = require("../../util");
var toolbar_1 = require("../toolbar");
var __1 = require("../../");
///classNames:begin
exports.BUTTON_GROUP = 'ww-button-group';
/**
 * ButtonGroup groups multiple buttons into one element.
 */
var ButtonGroup = /** @class */ (function (_super) {
    __extends(ButtonGroup, _super);
    function ButtonGroup() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: {
                id: __1.getId(_this.attrs),
                className: util_1.concat(exports.BUTTON_GROUP, toolbar_1.TOOLBAR_COMPAT, __1.getClassName(_this.attrs))
            }
        };
        return _this;
    }
    return ButtonGroup;
}(wml_1.Component));
exports.ButtonGroup = ButtonGroup;

},{"../../":101,"../../util":138,"../toolbar":80,"./wml/button-group":25,"@quenk/wml":145}],25:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'id': __context.values.root.id, 'class': __context.values.root.className }, wml: {} }, __spreadArrays((__context.children)));
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":141}],26:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/button-select");
var style_1 = require("../../content/style");
var util_1 = require("../../util");
var __1 = require("../../");
var __2 = require("../");
///className:begin
exports.BUTTON_SELECT = 'ww-button-select';
exports.BUTTON_SELECT_OPTION = 'ww-button-select__option';
/**
 * ButtonChangedEvent
 */
var ButtonChangedEvent = /** @class */ (function (_super) {
    __extends(ButtonChangedEvent, _super);
    function ButtonChangedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ButtonChangedEvent;
}(__2.Event));
exports.ButtonChangedEvent = ButtonChangedEvent;
/**
 * ButtonSelect
 */
var ButtonSelect = /** @class */ (function (_super) {
    __extends(ButtonSelect, _super);
    function ButtonSelect() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: {
                id: __1.getId(_this.attrs),
                className: util_1.concat(exports.BUTTON_SELECT, __1.getClassName(_this.attrs))
            },
            buttons: {
                current: -1,
                options: (_this.attrs.ww && _this.attrs.ww.options) ?
                    _this.attrs.ww.options : [],
                click: function (idx) {
                    _this.values.buttons.current = idx;
                    if ((_this.attrs.ww && _this.attrs.ww.onChange))
                        _this.attrs.ww.onChange(new ButtonChangedEvent(_this.attrs.ww.name, _this.values.buttons.options[idx].value));
                    _this.view.invalidate();
                },
                getStyle: function () { return (_this.attrs.ww && _this.attrs.ww.style) ?
                    _this.attrs.ww.style : style_1.Style.Default; },
                getActive: function (n) { return _this.values.buttons.current === n; },
                getClassNames: function (n) {
                    return util_1.concat(exports.BUTTON_SELECT_OPTION, _this.values.buttons.options[n].className);
                }
            }
        };
        return _this;
    }
    return ButtonSelect;
}(__2.AbstractControl));
exports.ButtonSelect = ButtonSelect;
/**
 * MultiButtonSelect
 */
var MultiButtonSelect = /** @class */ (function (_super) {
    __extends(MultiButtonSelect, _super);
    function MultiButtonSelect() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: {
                id: __1.getId(_this.attrs),
                className: util_1.concat(exports.BUTTON_SELECT, __1.getClassName(_this.attrs))
            },
            buttons: {
                values: [],
                options: (_this.attrs.ww && _this.attrs.ww.options) ?
                    _this.attrs.ww.options : [],
                click: function (n) {
                    var values = _this.values.buttons.values;
                    var pos = values.indexOf(n);
                    if (pos > -1)
                        values.splice(pos, 1);
                    else
                        values.push(n);
                    if (_this.attrs.ww && _this.attrs.ww.onChange)
                        _this.attrs.ww.onChange(new ButtonChangedEvent(_this.attrs.ww.name, values.map(function (n) { return _this.values.buttons.options[n].value; })));
                    _this.view.invalidate();
                },
                getStyle: function () { return (_this.attrs.ww && _this.attrs.ww.style) ?
                    _this.attrs.ww.style : style_1.Style.Default; },
                getActive: function (n) { return _this.values.buttons.values.indexOf(n) > -1; },
                getClassNames: function (n) {
                    return util_1.concat(exports.BUTTON_SELECT_OPTION, _this.values.buttons.options[n].className);
                }
            }
        };
        return _this;
    }
    return MultiButtonSelect;
}(__2.AbstractControl));
exports.MultiButtonSelect = MultiButtonSelect;

},{"../":53,"../../":101,"../../content/style":19,"../../util":138,"./wml/button-select":27}],27:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var button_group_1 = require("../../button-group");
;
var button_1 = require("../../button");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(button_group_1.ButtonGroup, { html: { 'id': __context.values.root.id, 'class': __context.values.root.className }, wml: {} }, __spreadArrays(__forIn(__context.values.buttons.options, function (opt, idx, _$$all) {
                return ([
                    __this.widget(button_1.Button, { html: {}, wml: {}, ww: { 'class': __context.values.buttons.getClassNames(idx), 'active': __context.values.buttons.getActive(idx), 'style': __context.values.buttons.getStyle(), 'onClick': function () { return __context.values.buttons.click(idx); }, 'text': opt.text } }, [])
                ]);
            }, function () { return ([]); })));
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../button":28,"../../button-group":24,"@quenk/noni/lib/data/maybe":141}],28:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/button");
var toolbar_1 = require("../toolbar");
var active_1 = require("../../content/state/active");
var orientation_1 = require("../../content/orientation");
var style_1 = require("../../content/style");
exports.Style = style_1.Style;
var size_1 = require("../../content/size");
var util_1 = require("../../util");
var __1 = require("../../");
var __2 = require("../");
///classNames:begin
exports.BUTTON = 'ww-button';
;
/**
 * ButtonClickedEvent
 */
var ButtonClickedEvent = /** @class */ (function (_super) {
    __extends(ButtonClickedEvent, _super);
    function ButtonClickedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ButtonClickedEvent;
}(__2.Event));
exports.ButtonClickedEvent = ButtonClickedEvent;
/**
 * Button is an improvement over HTMLButtionElement
 */
var Button = /** @class */ (function (_super) {
    __extends(Button, _super);
    function Button() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            button: {
                wml: {
                    id: 'button'
                },
                id: __1.getId(_this.attrs),
                className: util_1.concat(exports.BUTTON, __1.getClassName(_this.attrs), toolbar_1.TOOLBAR_COMPAT, (_this.attrs.ww && _this.attrs.ww.style) ?
                    style_1.getStyleClassName(_this.attrs.ww.style) :
                    style_1.DEFAULT, (_this.attrs.ww && _this.attrs.ww.size) ?
                    size_1.getSizeClassName(_this.attrs.ww.size) : '', (_this.attrs.ww && _this.attrs.ww.outline) ?
                    style_1.OUTLINE : '', (_this.attrs.ww && _this.attrs.ww.block) ?
                    orientation_1.BLOCK : '', (_this.attrs.ww && _this.attrs.ww.active) ?
                    active_1.ACTIVE : ''),
                type: (_this.attrs.ww && _this.attrs.ww.type) ?
                    _this.attrs.ww.type : 'button',
                name: (_this.attrs.ww && _this.attrs.ww.name) ? _this.attrs.ww.name : '',
                disabled: (_this.attrs.ww && _this.attrs.ww.disabled) ? true : null,
                onclick: function () { return _this.attrs.ww &&
                    _this.attrs.ww.onClick &&
                    _this.attrs.ww.onClick(new ButtonClickedEvent((_this.attrs.ww && _this.attrs.ww.name) ?
                        _this.attrs.ww.name : '', _this.attrs.ww.value)); },
                content: function () { return (_this.attrs.ww && _this.attrs.ww.text) ?
                    [__1.text(_this.attrs.ww.text)] : _this.children; }
            }
        };
        return _this;
    }
    /**
     * disable this button.
     */
    Button.prototype.disable = function () {
        util_1.getById(this.view, this.values.button.wml.id)
            .map(function (b) { return b.setAttribute('disabled', 'disabled'); });
    };
    /**
     * enable this button.
     */
    Button.prototype.enable = function () {
        util_1.getById(this.view, this.values.button.wml.id)
            .map(function (b) { return b.removeAttribute('disabled'); });
    };
    /**
     * toggle the disabled state of this button.
     */
    Button.prototype.toggle = function () {
        var _this = this;
        util_1.getById(this.view, this.values.button.wml.id)
            .map(function (b) { return b.hasAttribute('disabled') ?
            _this.enable() : _this.disable(); });
    };
    return Button;
}(__2.AbstractControl));
exports.Button = Button;

},{"../":53,"../../":101,"../../content/orientation":13,"../../content/size":16,"../../content/state/active":17,"../../content/style":19,"../../util":138,"../toolbar":80,"./wml/button":29}],29:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('button', { html: { 'id': __context.values.button.id, 'type': __context.values.button.type, 'name': __context.values.button.name, 'disabled': __context.values.button.disabled, 'class': __context.values.button.className, 'onclick': __context.values.button.onclick }, wml: { 'id': __context.values.button.wml.id } }, __spreadArrays((__context.values.button.content())));
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":141}],30:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var checkbox_1 = require("./wml/checkbox");
var util_1 = require("../../util");
var __1 = require("../");
var __2 = require("../../");
///classNames:begin
exports.CHECKBOX = 'ww-checkbox';
/**
 * CheckChangedEvent signals the user has changed the checkbox state.
 */
var CheckChangedEvent = /** @class */ (function (_super) {
    __extends(CheckChangedEvent, _super);
    function CheckChangedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return CheckChangedEvent;
}(__1.Event));
exports.CheckChangedEvent = CheckChangedEvent;
/**
 * Checkbox control.
 *
 * This is an alternative to the native checkbox that can be styled.
 */
var Checkbox = /** @class */ (function (_super) {
    __extends(Checkbox, _super);
    function Checkbox() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new checkbox_1.Main(_this);
        _this.values = {
            root: {
                id: __2.getId(_this.attrs),
                className: util_1.concat(exports.CHECKBOX, __2.getClassName(_this.attrs))
            },
            input: {
                name: __1.getName(_this.attrs),
                value: (_this.attrs.ww && _this.attrs.ww.value) ?
                    _this.attrs.ww.value : null,
                onChange: function () {
                    _this.values.input.value = (!_this.values.input.value) || null;
                    if (_this.attrs.ww && _this.attrs.ww.onChange)
                        _this.attrs.ww.onChange(new CheckChangedEvent(_this.values.input.name, _this.values.input.value || false));
                }
            }
        };
        return _this;
    }
    return Checkbox;
}(__1.AbstractControl));
exports.Checkbox = Checkbox;

},{"../":53,"../../":101,"../../util":138,"./wml/checkbox":31}],31:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'id': __context.values.root.id, 'class': __context.values.root.className }, wml: {} }, [
                __this.node('label', { html: {}, wml: {} }, __spreadArrays([
                    __this.node('input', { html: { 'type': "checkbox", 'name': __context.values.input.name, 'checked': __context.values.input.value, 'onchange': __context.values.input.onChange }, wml: {} }, [])
                ], (__context.children)))
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":141}],32:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml_1 = require("@quenk/wml");
var util_1 = require("../../util");
var __1 = require("../../");
var close_button_1 = require("./wml/close-button");
///classNames:begin
exports.CLOSE_BUTTON = 'ww-close-button';
;
/**
 * CloseButton used to display the "x" on dialogs etc.
 */
var CloseButton = /** @class */ (function (_super) {
    __extends(CloseButton, _super);
    function CloseButton() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new close_button_1.Main(_this);
        _this.values = {
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.CLOSE_BUTTON, __1.getClassName(_this.attrs)),
            wml: {
                id: 'close-button'
            },
            onclick: function () {
                if (_this.attrs.ww && _this.attrs.ww.onClick)
                    _this.attrs.ww.onClick();
            }
        };
        return _this;
    }
    return CloseButton;
}(wml_1.Component));
exports.CloseButton = CloseButton;

},{"../../":101,"../../util":138,"./wml/close-button":33,"@quenk/wml":145}],33:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var close_1 = require("../../../content/close");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('button', { html: { 'id': __context.values.id, 'class': __context.values.className, 'onclick': __context.values.onclick }, wml: {} }, [
                __this.widget(close_1.Close, { html: {}, wml: {} }, [])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../content/close":3,"@quenk/noni/lib/data/maybe":141}],34:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/date-field");
var moment = require("moment");
var maybe_1 = require("@quenk/noni/lib/data/maybe");
var util_1 = require("../../util");
var feedback_1 = require("../feedback");
var form_1 = require("../form");
var __1 = require("../../");
var __2 = require("../");
var orientation_1 = require("../../content/orientation");
///classNames:begin
exports.DATE_FIELD = 'ww-date-field';
exports.DATE_FIELD_INPUT = 'ww-date-field__input';
///classNames:end
exports.DEFAULT_INPUT_FORMAT = moment.ISO_8601;
exports.DEFAULT_INPUT_PLACEHOLDER = 'YYYY-MM-DD';
exports.DEFAULT_INPUT_DISPLAY = 'YYYY-MM-DD';
exports.VALUE_FORMAT = 'YYYY-MM-DD';
exports.DELAY = 200;
exports.TODAY = 'today';
exports.NOW = 'now';
exports.YESTERDAY = 'yesterday';
exports.iso8601Formats = [
    'YYYY-MM-DD',
    'YYYY-MM-D',
    'YYYY-M-DD',
    'YYYY-M-D',
    'YY-MM-DD',
    'YY-MM-D',
    'YY-M-DD',
    'YY-M-D',
    'YYYY/MM/DD',
    'YYYY/MM/D',
    'YYYY/M/DD',
    'YYYY/M/D',
    'YY/MM/DD',
    'YY/MM/D',
    'YY/M/DD',
    'YY/M/D',
    'YYYY MM DD',
    'YYYY MM D',
    'YYYY M DD',
    'YYYY M D',
    'YY MM DD',
    'YY MM D',
    'YY M DD',
    'YY M D',
    'YYYYMMDD',
    'YYYYMMD',
    'YYYYMDD',
    'YYYYMD',
    'YYMMDD',
    'YYMMD',
    'YYMDD',
    'YYMD',
];
exports.commonFormats = [
    'DD-MM-YYYY',
    'D-MM-YYYY',
    'DD-M-YYYY',
    'D-M-YYYY',
    'DD-MM-YY',
    'D-MM-YY',
    'DD-M-YY',
    'D-M-YY',
    'DD/MM/YYYY',
    'D/MM/YYYY',
    'DD/M/YYYY',
    'D/M/YYYY',
    'DD/MM/YY',
    'D/MM/YY',
    'DD/M/YY',
    'D/M/YY',
    'DD MM YYYY',
    'D MM YYYY',
    'DD M YYYY',
    'D M YYYY',
    'DD MM YY',
    'D MM YY',
    'DD M YY',
    'D M YY',
    'DDMMYYYY',
    'DMMYYYY',
    'DDMYYYY',
    'DMYYYY',
    'DDMMYY',
    'DMMYY',
    'DDMYY',
    'DMYY',
];
exports.usFormats = [
    'MM-DD-YYYY',
    'MM-D-YYYY',
    'M-DD-YYYY',
    'M-D-YYYY',
    'MM-DD-YY',
    'MM-D-YY',
    'M-DD-YY',
    'M-D-YY',
    'MM/DD/YYYY',
    'MM/D/YYYY',
    'M/DD/YYYY',
    'M/D/YYYY',
    'MM/DD/YY',
    'MM/D/YY',
    'M/DD/YY',
    'M/D/YY',
    'MM DD YYYY',
    'MM D YYYY',
    'M DD YYYY',
    'M D YYYY',
    'MM DD YY',
    'MM D YY',
    'M DD YY',
    'M D YY',
    'MMDDYYYY',
    'MMDYYYY',
    'MDDYYYY',
    'MDYYYY',
    'MMDDYY',
    'MMDYY',
    'MDDYY',
    'MDYY',
];
/**
 * Format is used to determine what format input should be parsed as.
 */
var Format;
(function (Format) {
    Format[Format["ISO8601"] = 1] = "ISO8601";
    Format[Format["COMMON"] = 2] = "COMMON";
    Format[Format["USA"] = 3] = "USA";
})(Format = exports.Format || (exports.Format = {}));
/**
 * DateChangedEvent is generated when a valid date has been entered.
 *
 * The value is a truncated ISO8601 string consisting of the date part alone.
 */
var DateChangedEvent = /** @class */ (function (_super) {
    __extends(DateChangedEvent, _super);
    function DateChangedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return DateChangedEvent;
}(__2.Event));
exports.DateChangedEvent = DateChangedEvent;
/**
 * DateField provides a text field for entering dates.
 *
 * It will only fire change events when the date input matches one
 * of the 3 format sets (ISO8601,Common,US).
 *
 * If the user removes focus and the entry is not valid, it will be ignored
 * and no change event will be fired. Once a valid date has been entered,
 * the value displayed can be formated using the format specified in the
 * "display" attribute. This does not affect the actual value provided
 * to onChange handlers.
 */
var DateField = /** @class */ (function (_super) {
    __extends(DateField, _super);
    function DateField() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: {
                wml: { id: 'root' },
                id: __1.getId(_this.attrs),
                className: util_1.concat(exports.DATE_FIELD, __1.getClassName(_this.attrs), orientation_1.getBlockClassName(_this.attrs), feedback_1.getValidityClassName(_this.attrs)),
            },
            control: {
                wml: { id: 'input' },
                id: __1.getId(_this.attrs)
            },
            label: {
                id: (_this.attrs.ww && _this.attrs.ww.name) || '',
                text: (_this.attrs.ww && _this.attrs.ww.label) || ''
            },
            messages: {
                wml: {
                    id: 'messages'
                },
                text: feedback_1.getMessage(_this.attrs)
            },
            input: {
                wml: { id: 'input' },
                className: exports.DATE_FIELD_INPUT,
                name: __2.getName(_this.attrs),
                format: getFormat(_this.attrs),
                placeholder: getPlaceholder(_this.attrs),
                display: getDisplay(_this.attrs),
                moment: ((_this.attrs.ww && _this.attrs.ww.value) ?
                    maybe_1.just(parseDate(getValue(_this.attrs), getFormat(_this.attrs))) :
                    maybe_1.nothing()),
                value: function () { return (_this.values.input.moment.isJust() &&
                    _this.values.input.moment.get().isValid()) ?
                    _this.values.input.moment.get().format(_this.values.input.display) : ''; },
                disabled: (_this.attrs.ww && _this.attrs.ww.disabled === true) ?
                    true : null,
                onfocus: function (e) {
                    e.target.select();
                },
                oninput: function (e) {
                    e.target.oninput = null;
                    _this.values.input.onkeyup(e);
                },
                onkeyup: util_1.debounce(function (e) {
                    var value = e.target.value;
                    var m = parseDate(value, _this.values.input.format);
                    if (m.isValid()) {
                        _this.values.input.moment = maybe_1.just(m);
                        _this.fireChange();
                    }
                }, exports.DELAY),
                onblur: function () {
                    _this.view.invalidate();
                }
            }
        };
        return _this;
    }
    /**
     * @private
     */
    DateField.prototype.fireChange = function () {
        if (this.values.input.moment.isJust()) {
            var m = this.values.input.moment.get();
            if (m.isValid() && (this.attrs.ww && this.attrs.ww.onChange))
                this.attrs.ww.onChange(new DateChangedEvent(this.attrs.ww.name || '', m.format(exports.VALUE_FORMAT)));
        }
    };
    DateField.prototype.setMessage = function (msg) {
        this.values.messages.text = msg;
        form_1.setMessage(this.view, this.values.messages.wml.id, msg);
        return this;
    };
    DateField.prototype.removeMessage = function () {
        this.values.messages.text = '';
        form_1.removeMessage(this.view, this.values.messages.wml.id);
        return this;
    };
    return DateField;
}(form_1.AbstractFormControl));
exports.DateField = DateField;
var parseDate = function (d, formats) {
    var str = d.toLowerCase();
    if ((str === exports.TODAY) || (str === exports.NOW)) {
        return moment.utc();
    }
    else if (str === exports.YESTERDAY) {
        return moment.utc().subtract(1, 'd');
    }
    else {
        return moment.utc(d, formats, true);
    }
};
var getValue = function (attrs) {
    return (attrs.ww && attrs.ww.value) ? attrs.ww.value : '';
};
var getFormat = function (attrs) {
    if (attrs.ww && attrs.ww.format) {
        switch (attrs.ww.format) {
            case 2:
                return exports.commonFormats;
            case 3:
                return exports.usFormats;
            default:
                break;
        }
    }
    return exports.iso8601Formats;
};
var getPlaceholder = function (attrs) {
    if (attrs.ww && attrs.ww.placeholder)
        return attrs.ww.placeholder;
    if (attrs.ww && attrs.ww.format) {
        switch (attrs.ww.format) {
            case 2:
                return 'DD-MM-YYYY';
            case 3:
                return 'MM-DD-YYYY';
            default:
                return 'YYYY-MM-DD';
        }
    }
    return '';
};
var getDisplay = function (attrs) {
    return (attrs.ww && attrs.ww.display) ? attrs.ww.display : exports.DEFAULT_INPUT_DISPLAY;
};

},{"../":53,"../../":101,"../../content/orientation":13,"../../util":138,"../feedback":44,"../form":50,"./wml/date-field":35,"@quenk/noni/lib/data/maybe":141,"moment":146}],35:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var label_1 = require("../../label");
;
var help_1 = require("../../help");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'id': __context.values.root.id, 'class': __context.values.root.className }, wml: {} }, [
                __this.widget(label_1.Label, { html: {}, wml: {}, ww: { 'for': __context.values.root.id, 'text': __context.values.label.text } }, []),
                __this.node('input', { html: { 'name': __context.values.input.wml.id, 'onfocus': __context.values.input.onfocus, 'oninput': __context.values.input.oninput, 'onkeyup': __context.values.input.onkeyup, 'onblur': __context.values.input.onblur, 'value': __context.values.input.value(), 'disabled': __context.values.input.disabled, 'class': __context.values.input.className, 'placeholder': __context.values.input.placeholder }, wml: { 'id': __context.values.input.wml.id } }, []),
                __this.widget(help_1.Help, { html: {}, wml: { 'id': __context.values.messages.wml.id }, ww: { 'text': __context.values.messages.text } }, [])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../help":51,"../../label":54,"@quenk/noni/lib/data/maybe":141}],36:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml_1 = require("@quenk/wml");
var toolbar_1 = require("../toolbar");
var orientation_1 = require("../../content/orientation");
var style_1 = require("../../content/style");
exports.Style = style_1.Style;
var size_1 = require("../../content/size");
var util_1 = require("../../util");
var __1 = require("../../");
var display_field_1 = require("./wml/display-field");
///classNames:begin
exports.DISPLAY_FIELD = 'ww-display-field';
exports.DISPLAY_FIELD_CONTENT = 'ww-display-field__content';
;
/**
 * DisplayField is used to display a value in a text field like box.
 */
var DisplayField = /** @class */ (function (_super) {
    __extends(DisplayField, _super);
    function DisplayField() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new display_field_1.Main(_this);
        _this.values = {
            wml: {
                id: 'display'
            },
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.DISPLAY_FIELD, __1.getClassName(_this.attrs), toolbar_1.TOOLBAR_COMPAT, (_this.attrs.ww && _this.attrs.ww.style) ?
                style_1.getStyleClassName(_this.attrs.ww.style) :
                style_1.DEFAULT, (_this.attrs.ww && _this.attrs.ww.size) ?
                size_1.getSizeClassName(_this.attrs.ww.size) : '', (_this.attrs.ww && _this.attrs.ww.block) ?
                orientation_1.BLOCK : ''),
            onclick: function (e) {
                e.stopPropagation(); //prevent a bug when used with ResultsMenu
                if (_this.attrs.ww && _this.attrs.ww.onClick)
                    _this.attrs.ww.onClick();
            },
            content: {
                className: exports.DISPLAY_FIELD_CONTENT
            }
        };
        return _this;
    }
    return DisplayField;
}(wml_1.Component));
exports.DisplayField = DisplayField;

},{"../../":101,"../../content/orientation":13,"../../content/size":16,"../../content/style":19,"../../util":138,"../toolbar":80,"./wml/display-field":37,"@quenk/wml":145}],37:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'id': __context.values.id, 'class': __context.values.className, 'onclick': __context.values.onclick }, wml: {} }, [
                __this.node('div', { html: { 'class': __context.values.content.className }, wml: {} }, __spreadArrays((__context.children)))
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":141}],38:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/drop-down");
var hidden = require("../../content/state/hidden");
var style = require("../../content/style");
var wml_1 = require("@quenk/wml");
var style_1 = require("../../content/style");
var util_1 = require("../../util");
var __1 = require("../../");
///classNames:begin
exports.DROP_DOWN = 'ww-drop-down-menu';
exports.DROP_DOWN_TOGGLE = 'ww-drop-down-menu__toggle';
exports.DROP_DOWN_CONTENT = 'ww-drop-down__content';
/**
 * DropDown provides a component for displaying a pop up menu.
 *
 *
 *    +--------+
 *    |  Menu  |
 *    +--------+
 *    +-------------------------+
 *    |                         |
 *    | ----------------------- |
 *    |                         |
 *    | ----------------------- |
 *    |                         |
 *    | ----------------------- |
 *    |                         |
 *    +-------------------------+
 */
var DropDown = /** @class */ (function (_super) {
    __extends(DropDown, _super);
    function DropDown() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: {
                wml: {
                    id: 'root'
                },
                id: __1.getId(_this.attrs),
                className: util_1.concat(exports.DROP_DOWN, __1.getClassName(_this.attrs))
            },
            button: {
                text: (_this.attrs.ww && _this.attrs.ww.buttonText) ?
                    _this.attrs.ww.buttonText : '',
                style: (_this.attrs.ww && _this.attrs.ww.buttonStyle) ?
                    _this.attrs.ww.buttonStyle : style_1.Style.Default,
                className: util_1.concat(exports.DROP_DOWN_TOGGLE, style.DEFAULT, (_this.attrs.ww && _this.attrs.ww.buttonClassName) ?
                    _this.attrs.ww.buttonClassName : ''),
                template: function () {
                    return (_this.attrs.ww && _this.attrs.ww.buttonTemplate) ?
                        _this.attrs.ww.buttonTemplate : views.button;
                },
                onClick: function () {
                    var mayRoot = util_1.getById(_this.view, _this.values.root.wml.id);
                    if (mayRoot.isJust()) {
                        var e = mayRoot.get();
                        if (_this.values.content.autoClose) {
                            var hide = _this.values.content.hide;
                            //intercept clicks on button and content sections
                            for (var i = 0; i < e.children.length; i++) {
                                //prevent doubling up handlers.
                                e.children[i]
                                    .removeEventListener('click', hide);
                                e.children[i].addEventListener('click', hide);
                            }
                        }
                        _this.toggle();
                        window.addEventListener('click', _this);
                    }
                }
            },
            content: {
                wml: {
                    id: 'content'
                },
                className: util_1.concat(exports.DROP_DOWN_CONTENT, hidden.HIDDEN),
                autoClose: (_this.attrs.ww && _this.attrs.ww.autoClose === false) ?
                    false : true,
                render: function () { return _this.children; },
                hide: function () { return _this.hide(); }
            }
        };
        return _this;
    }
    DropDown.prototype.isHidden = function () {
        return hidden.isHidden(this.view, this.values.content.wml.id);
    };
    DropDown.prototype.hide = function () {
        hidden.hide(this.view, this.values.content.wml.id);
        return this;
    };
    DropDown.prototype.show = function () {
        hidden.show(this.view, this.values.content.wml.id);
        return this;
    };
    DropDown.prototype.toggle = function () {
        hidden.toggle(this.view, this.values.content.wml.id);
        return this;
    };
    DropDown.prototype.handleEvent = function (e) {
        var _this = this;
        util_1.getById(this.view, this.values.root.wml.id)
            .map(function (root) {
            if (!document.body.contains(root))
                document.removeEventListener('click', _this);
            if ((!root.contains(e.target)))
                _this.hide();
        });
    };
    return DropDown;
}(wml_1.Component));
exports.DropDown = DropDown;

},{"../../":101,"../../content/state/hidden":18,"../../content/style":19,"../../util":138,"./wml/drop-down":39,"@quenk/wml":145}],39:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var button_1 = require("../../button");
;
var caret_1 = require("../../../content/caret");
;
var __1 = require("../../../");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
exports.button = function (d) { return function (__this) {
    return [
        __this.widget(button_1.Button, { html: {}, wml: {}, ww: { 'class': d.values.button.className, 'style': d.values.button.style, 'onClick': d.values.button.onClick } }, [
            __1.text((d.values.button.text + " ")),
            __this.widget(caret_1.Caret, { html: {}, wml: {} }, [])
        ])
    ];
}; };
;
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'class': __context.values.root.className }, wml: { 'id': __context.values.root.wml.id } }, __spreadArrays((__context.values.button.template()(__context)(__this)), [
                __this.node('div', { html: { 'class': __context.values.content.className }, wml: { 'id': __context.values.content.wml.id } }, __spreadArrays((__context.values.content.render())))
            ]));
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../":101,"../../../content/caret":1,"../../button":28,"@quenk/noni/lib/data/maybe":141}],40:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../../util");
var feedback_1 = require("../feedback");
var select_1 = require("../select");
exports.ItemChangedEvent = select_1.ItemChangedEvent;
var form_1 = require("../form");
var __1 = require("../../");
var __2 = require("../");
var drop_list_field_1 = require("./wml/drop-list-field");
///classNames:begin
exports.DROP_LIST_FIELD = 'ww-drop-list-field';
/**
 * DropListField
 */
var DropListField = /** @class */ (function (_super) {
    __extends(DropListField, _super);
    function DropListField() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new drop_list_field_1.Main(_this);
        _this.values = {
            root: {
                wml: {
                    id: 'root'
                },
                id: __1.getId(_this.attrs),
                className: util_1.concat(exports.DROP_LIST_FIELD, __1.getClassName(_this.attrs), feedback_1.getValidityClassName(_this.attrs))
            },
            messages: {
                wml: {
                    id: 'message'
                },
                text: feedback_1.getMessage(_this.attrs)
            },
            label: {
                id: __2.getName(_this.attrs),
                text: form_1.getLabel(_this.attrs)
            },
            control: {
                wml: {
                    id: 'control'
                },
                name: __2.getName(_this.attrs),
                className: feedback_1.getValidityClassName(_this.attrs),
                block: true,
                placeholder: (_this.attrs.ww && _this.attrs.ww.placeholder),
                value: (_this.attrs.ww && _this.attrs.ww.value),
                options: (_this.attrs.ww && _this.attrs.ww.options) ?
                    _this.attrs.ww.options : [],
                stringifier: _this.attrs.ww && _this.attrs.ww.stringifier,
                itemTemplate: (_this.attrs.ww && _this.attrs.ww.itemTemplate) ?
                    _this.attrs.ww.itemTemplate : undefined,
                noItemsTemplate: (_this.attrs.ww && _this.attrs.ww.noItemsTemplate) ?
                    _this.attrs.ww.noItemsTemplate : undefined,
                onSelect: function (e) {
                    if (_this.attrs.ww && _this.attrs.ww.onChange)
                        _this.attrs.ww.onChange(new select_1.ItemChangedEvent(e.name, e.value));
                },
            }
        };
        return _this;
    }
    DropListField.prototype.setMessage = function (msg) {
        getHelp(this).map(function (h) { return h.setMessage(msg); });
        return this;
    };
    DropListField.prototype.removeMessage = function () {
        getHelp(this).map(function (h) { return h.removeMessage(); });
        return this;
    };
    return DropListField;
}(form_1.AbstractFormControl));
exports.DropListField = DropListField;
var getHelp = function (t) {
    return util_1.getById(t.view, t.values.messages.wml.id);
};

},{"../":53,"../../":101,"../../util":138,"../feedback":44,"../form":50,"../select":64,"./wml/drop-list-field":41}],41:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var label_1 = require("../../label");
;
var help_1 = require("../../help");
;
var drop_list_1 = require("../../drop-list");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'id': __context.values.root.id, 'class': __context.values.root.className }, wml: { 'id': __context.values.root.wml.id } }, [
                __this.widget(label_1.Label, { html: {}, wml: {}, ww: { 'for': __context.values.root.id, 'text': __context.values.label.text } }, []),
                __this.widget(drop_list_1.DropList, { html: {}, wml: {}, ww: { 'className': __context.values.control.className, 'name': __context.values.control.name, 'placeholder': __context.values.control.placeholder, 'block': __context.values.control.block, 'value': __context.values.control.value, 'options': __context.values.control.options, 'onSelect': __context.values.control.onSelect, 'noItemsTemplate': __context.values.control.noItemsTemplate, 'itemsTemplate': __context.values.control.itemTemplate, 'stringifier': __context.values.control.stringifier } }, []),
                __this.widget(help_1.Help, { html: {}, wml: { 'id': __context.values.messages.wml.id }, ww: { 'text': __context.values.messages.text } }, [])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../drop-list":42,"../../help":51,"../../label":54,"@quenk/noni/lib/data/maybe":141}],42:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/drop-list");
var util_1 = require("../../util");
var size_1 = require("../../content/size");
var orientation_1 = require("../../content/orientation");
var results_menu_1 = require("../results-menu");
exports.ItemSelectedEvent = results_menu_1.ItemSelectedEvent;
var search_1 = require("../search");
var __1 = require("../../");
var __2 = require("../");
///classNames:begin
exports.DROP_LIST = 'ww-drop-list';
/**
 * DropList provides a control for making a selection from a list of choices.
 */
var DropList = /** @class */ (function (_super) {
    __extends(DropList, _super);
    function DropList() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.DROP_LIST, __1.getClassName(_this.attrs), (_this.attrs.ww && _this.attrs.ww.size) ?
                size_1.getSizeClassName(_this.attrs.ww.size) : '', (_this.attrs.ww && _this.attrs.ww.block) ?
                orientation_1.BLOCK : ''),
            name: __2.getName(_this.attrs),
            value: (_this.attrs.ww && _this.attrs.ww.value),
            control: {
                wml: {
                    id: 'drop-list'
                }
            },
            messages: {
                wml: {
                    id: 'messages'
                }
            },
            display: {
                placeholder: function () {
                    if (_this.attrs.ww) {
                        if (_this.attrs.ww.options && _this.values.value)
                            return getCurrent(_this.attrs.ww.options, _this.values.value);
                        return _this.attrs.ww.placeholder || 'Select one';
                    }
                },
                onClick: function () {
                    if (_this.values.menu.open) {
                        _this.close();
                    }
                    else {
                        search_1.updateMenu(_this.view, _this.values.menu.wml.id, _this.attrs.ww && _this.attrs.ww.options || []);
                    }
                }
            },
            menu: {
                wml: {
                    id: 'menu'
                },
                name: (_this.attrs.ww && _this.attrs.ww.name) ?
                    _this.attrs.ww.name : '',
                block: (_this.attrs.ww && _this.attrs.ww.block) ?
                    _this.attrs.ww.block : false,
                open: false,
                onSelect: function (e) {
                    if (_this.attrs.ww && _this.attrs.ww.onSelect)
                        _this.attrs.ww.onSelect(new results_menu_1.ItemSelectedEvent(e.name, e.value.value));
                    _this.values.value = e.value.value;
                    _this.view.invalidate();
                },
                itemTemplate: (_this.attrs.ww && _this.attrs.ww.itemTemplate) ?
                    _this.attrs.ww.itemTemplate : undefined,
                noItemsTemplate: (_this.attrs.ww && _this.attrs.ww.noItemsTemplate) ?
                    _this.attrs.ww.noItemsTemplate : undefined,
                stringifier: (_this.attrs.ww && _this.attrs.ww.stringifier) ?
                    _this.attrs.ww.stringifier : function (v) { return v.label; }
            }
        };
        return _this;
    }
    /**
     * open the results menu.
     */
    DropList.prototype.open = function () {
        this.values.menu.open = true;
        search_1.openMenu(this.view, this.values.menu.wml.id);
        return this;
    };
    /**
     * close the results menu.
     */
    DropList.prototype.close = function () {
        this.values.menu.open = false;
        search_1.closeMenu(this.view, this.values.menu.wml.id);
        return this;
    };
    return DropList;
}(__2.AbstractControl));
exports.DropList = DropList;
var getCurrent = function (opts, value, text) {
    if (text === void 0) { text = 'Select one'; }
    return opts.reduce(function (p, c) { return c.value === value ? c.label : p; }, text);
};

},{"../":53,"../../":101,"../../content/orientation":13,"../../content/size":16,"../../util":138,"../results-menu":60,"../search":62,"./wml/drop-list":43}],43:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var caret_1 = require("../../../content/caret");
;
var results_menu_1 = require("../../results-menu");
;
var display_field_1 = require("../../display-field");
;
var __1 = require("../../../");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'id': __context.values.id, 'class': __context.values.className }, wml: {} }, [
                __this.widget(display_field_1.DisplayField, { html: {}, wml: {}, ww: { 'onClick': __context.values.display.onClick } }, [
                    __1.text(__context.values.display.placeholder()),
                    __this.widget(caret_1.Caret, { html: {}, wml: {} }, [])
                ]),
                __this.widget(results_menu_1.ResultsMenu, { html: {}, wml: { 'id': __context.values.menu.wml.id }, ww: { 'block': __context.values.menu.block, 'name': __context.values.menu.name, 'onSelect': __context.values.menu.onSelect, 'noItemsTemplate': __context.values.menu.noItemsTemplate, 'itemsTemplate': __context.values.menu.itemTemplate, 'stringifier': __context.values.menu.stringifier } }, [])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../":101,"../../../content/caret":1,"../../display-field":36,"../../results-menu":60,"@quenk/noni/lib/data/maybe":141}],44:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var style = require("../content/style");
var util_1 = require("../util");
var control_1 = require("../control");
/**
 * ValidationState
 */
var ValidationState;
(function (ValidationState) {
    ValidationState["Neutral"] = "neutral";
    ValidationState["Error"] = "error";
    ValidationState["Success"] = "success";
    ValidationState["Warning"] = "warning";
})(ValidationState = exports.ValidationState || (exports.ValidationState = {}));
/**
 * AbstractFeedbackControl
 *
 * Provides a default implementaion of the interface methods.
 */
var AbstractFeedbackControl = /** @class */ (function (_super) {
    __extends(AbstractFeedbackControl, _super);
    function AbstractFeedbackControl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AbstractFeedbackControl.prototype.setMessage = function (msg) {
        exports.setMessage(this.view, this.values.messages.wml.id, msg);
        return this;
    };
    AbstractFeedbackControl.prototype.removeMessage = function () {
        exports.removeMessage(this.view, this.values.messages.wml.id);
        return this;
    };
    AbstractFeedbackControl.prototype.setValidationState = function (state) {
        exports.setValidationState(this.view, this.values.control.wml.id, state);
        return this;
    };
    AbstractFeedbackControl.prototype.removeValidationState = function () {
        exports.removeValidationState(this.view, this.values.control.wml.id);
        return this;
    };
    AbstractFeedbackControl.prototype.getValidationState = function () {
        return exports.getValidationState(this.view, this.values.control.wml.id);
    };
    return AbstractFeedbackControl;
}(control_1.AbstractControl));
exports.AbstractFeedbackControl = AbstractFeedbackControl;
/**
 * setMessage helper.
 */
exports.setMessage = function (view, id, msg) {
    return util_1.getById(view, id)
        .map(function (messages) {
        var node = document.createTextNode(msg);
        while (messages.lastChild)
            messages.removeChild(messages.lastChild);
        messages.appendChild(node);
    });
};
/**
 * removeMessage
 */
exports.removeMessage = function (view, id) {
    return util_1.getById(view, id)
        .map(function (messages) {
        while (messages.lastChild)
            messages.removeChild(messages.lastChild);
    });
};
/**
 * setValidationState helper.
 */
exports.setValidationState = function (view, id, state) {
    exports.removeValidationState(view, id);
    if (state !== ValidationState.Neutral)
        util_1.getById(view, id)
            .map(function (e) { return e.classList.add(exports.validationState2ClassName(state)); });
};
/**
 * removeValidationState helper.
 */
exports.removeValidationState = function (view, id) {
    util_1.getById(view, id)
        .map(function (h) {
        h.classList.remove(style.SUCCESS);
        h.classList.remove(style.ERROR);
        h.classList.remove(style.WARNING);
    });
};
/**
 * getValidationState calculates the ValidationState of an HTMLElement
 * (identified by id) by analysing its class list.
 */
exports.getValidationState = function (view, id) {
    return util_1.getById(view, id)
        .map(function (h) {
        if (h.classList.contains(style.SUCCESS))
            return ValidationState.Success;
        else if (h.classList.contains(style.WARNING))
            return ValidationState.Warning;
        else if (h.classList.contains(style.ERROR))
            return ValidationState.Error;
        else
            return ValidationState.Neutral;
    })
        .get();
};
/**
 * getValidityClassName provides the applicable style class by checking
 * the validity properties of FeedbackControAttrs.
 */
exports.getValidityClassName = function (attrs) {
    if (attrs.ww) {
        if (attrs.ww.error && (attrs.ww.error != ''))
            return style.ERROR;
        if (attrs.ww.warning && (attrs.ww.warning != ''))
            return style.WARNING;
        if (attrs.ww.success && (attrs.ww.success != ''))
            return style.SUCCESS;
    }
    return '';
};
/**
 * getMessage
 */
exports.getMessage = function (attrs) {
    if (attrs.ww) {
        if (attrs.ww.error && (attrs.ww.error != ''))
            return attrs.ww.error;
        if (attrs.ww.warning && (attrs.ww.warning != ''))
            return attrs.ww.warning;
        if (attrs.ww.success && (attrs.ww.success != ''))
            return attrs.ww.success;
        if (attrs.ww.message && (attrs.ww.message != ''))
            return attrs.ww.message;
    }
    return '';
};
/**
 * validationState2ClassName transforms a ValidationState into
 * the corresponding class name (if any).
 */
exports.validationState2ClassName = function (state) {
    if (state === ValidationState.Success)
        return style.SUCCESS;
    else if (state === ValidationState.Warning)
        return style.WARNING;
    else if (state === ValidationState.Error)
        return style.ERROR;
    else
        return '';
};

},{"../content/style":19,"../control":53,"../util":138}],45:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../../util");
var __1 = require("../../");
var __2 = require("../");
var file_input_1 = require("./wml/file-input");
///classNames:begin
exports.FILE_INPUT = 'ww-file-input';
/**
 * FileChangedEvent is fired when
 */
var FileChangedEvent = /** @class */ (function (_super) {
    __extends(FileChangedEvent, _super);
    function FileChangedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return FileChangedEvent;
}(__2.Event));
exports.FileChangedEvent = FileChangedEvent;
/**
 * FileInput provides a surface for file selection.
 *
 * It supports drag and drop of the files as input.
 */
var FileInput = /** @class */ (function (_super) {
    __extends(FileInput, _super);
    function FileInput() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new file_input_1.FileInputView(_this);
        _this.values = {
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.FILE_INPUT, __1.getClassName(_this.attrs)),
            name: __2.getName(_this.attrs),
            accept: (_this.attrs.ww && _this.attrs.ww.accept) ?
                _this.attrs.ww.accept : '',
            change: function (e) {
                var input = e.target;
                if ((input.files != null) &&
                    (input.files.length > 0) &&
                    _this.attrs.ww &&
                    _this.attrs.ww.onChange) {
                    _this.attrs.ww.onChange(new FileChangedEvent(input.name, input.files[0]));
                }
            }
        };
        return _this;
    }
    return FileInput;
}(__2.AbstractControl));
exports.FileInput = FileInput;

},{"../":53,"../../":101,"../../util":138,"./wml/file-input":46}],46:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var FileInputView = /** @class */ (function () {
    function FileInputView(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('input', { html: { 'id': __context.values.id, 'class': __context.values.className, 'name': __context.values.name, 'type': "file", 'accept': __context.values.accept, 'onchange': __context.values.change }, wml: {} }, []);
        };
    }
    FileInputView.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    FileInputView.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    FileInputView.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    FileInputView.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    FileInputView.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    FileInputView.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    FileInputView.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return FileInputView;
}());
exports.FileInputView = FileInputView;

},{"@quenk/noni/lib/data/maybe":141}],47:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../../util");
var file_input_1 = require("../file-input");
exports.FileChangedEvent = file_input_1.FileChangedEvent;
var __1 = require("../../");
var __2 = require("../");
var file_upload_surface_1 = require("./wml/file-upload-surface");
exports.INSTRUCTION_TEXT = 'Choose a file';
///classNames:begin
exports.FILE_UPLOAD_SURFACE = 'ww-file-upload-surface';
exports.FILE_UPLOAD_SURFACE_INPUT = 'ww-file-upload-surface__input';
exports.FILE_UPLOAD_SURFACE_TEXT = 'ww-file-upload-surface__text';
/**
 * FileUploadSurface provides a surface for file selection.
 *
 * It supports drag and drop of the files as input.
 */
var FileUploadSurface = /** @class */ (function (_super) {
    __extends(FileUploadSurface, _super);
    function FileUploadSurface() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new file_upload_surface_1.FileUploadSurfaceView(_this);
        _this.values = {
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.FILE_UPLOAD_SURFACE, __1.getClassName(_this.attrs)),
            stop: function (e) {
                e.stopPropagation();
                e.preventDefault();
            },
            drop: function (e) {
                e.stopPropagation();
                e.preventDefault();
                var name = (_this.attrs.ww && _this.attrs.ww.name) ?
                    _this.attrs.ww.name : '';
                if (e.dataTransfer && e.dataTransfer.files.length > 0)
                    _this.values.input.onChange(new file_input_1.FileChangedEvent(name, e.dataTransfer.files[0]));
            },
            input: {
                className: exports.FILE_UPLOAD_SURFACE_INPUT,
                name: __2.getName(_this.attrs),
                accept: (_this.attrs.ww && _this.attrs.ww.accept) ?
                    _this.attrs.ww.accept : '',
                onChange: function (e) {
                    _this.values.text.value = e.value.name;
                    if (_this.attrs.ww && _this.attrs.ww.onChange)
                        _this.attrs.ww.onChange(e);
                    _this.view.invalidate();
                }
            },
            text: {
                className: exports.FILE_UPLOAD_SURFACE_TEXT,
                value: (_this.attrs.ww && _this.attrs.ww.text) ?
                    _this.attrs.ww.text : exports.INSTRUCTION_TEXT
            }
        };
        return _this;
    }
    return FileUploadSurface;
}(__2.AbstractControl));
exports.FileUploadSurface = FileUploadSurface;

},{"../":53,"../../":101,"../../util":138,"../file-input":45,"./wml/file-upload-surface":48}],48:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var __1 = require("../../../");
;
var file_input_1 = require("../../file-input");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var FileUploadSurfaceView = /** @class */ (function () {
    function FileUploadSurfaceView(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'id': __context.values.id, 'class': __context.values.className, 'ondragenter': __context.values.stop, 'ondragover': __context.values.stop, 'ondrop': __context.values.drop }, wml: {} }, [
                __this.widget(file_input_1.FileInput, { html: {}, wml: {}, ww: { 'className': __context.values.input.className, 'name': __context.values.input.name, 'accept': __context.values.input.accept, 'onChange': __context.values.input.onChange } }, []),
                __this.node('div', { html: { 'class': __context.values.text.className }, wml: {} }, [
                    __this.node('h3', { html: {}, wml: {} }, [
                        __1.text(__context.values.text.value)
                    ])
                ])
            ]);
        };
    }
    FileUploadSurfaceView.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    FileUploadSurfaceView.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    FileUploadSurfaceView.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    FileUploadSurfaceView.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    FileUploadSurfaceView.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    FileUploadSurfaceView.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    FileUploadSurfaceView.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return FileUploadSurfaceView;
}());
exports.FileUploadSurfaceView = FileUploadSurfaceView;

},{"../../../":101,"../../file-input":45,"@quenk/noni/lib/data/maybe":141}],49:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
/**
 * FocusGainedEvent
 */
var FocusGainedEvent = /** @class */ (function () {
    function FocusGainedEvent(name) {
        this.name = name;
    }
    return FocusGainedEvent;
}());
exports.FocusGainedEvent = FocusGainedEvent;
/**
 * FocusLostEvent
 */
var FocusLostEvent = /** @class */ (function () {
    function FocusLostEvent(name) {
        this.name = name;
    }
    return FocusLostEvent;
}());
exports.FocusLostEvent = FocusLostEvent;
/**
 * focus DOM helper.
 */
exports.focus = function (view, id) {
    util_1.getById(view, id)
        .map(function (e) { return e.focus(); });
};

},{"../util":138}],50:[function(require,module,exports){
"use strict";
/**
 * The form module deals with controls specifically for accepting user input.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var feedback_1 = require("./feedback");
/**
 * AbstractFormControl provides a base implementation of a
 * FormControl.
 */
var AbstractFormControl = /** @class */ (function (_super) {
    __extends(AbstractFormControl, _super);
    function AbstractFormControl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return AbstractFormControl;
}(feedback_1.AbstractFeedbackControl));
exports.AbstractFormControl = AbstractFormControl;
/**
 * getLabel extracts the label value from FromControlAttrs.
 */
exports.getLabel = function (attrs) { return (attrs.ww && attrs.ww.label) ? attrs.ww.label : ''; };
/**
 * setMessage helper.
 *
 * Sets the message on the Help widget.
 */
exports.setMessage = function (view, id, msg) {
    util_1.getById(view, id).map(function (h) { h.setMessage(msg); });
};
/**
 * removeMessage helper.
 *
 * Removes the message from the Help widget.
 */
exports.removeMessage = function (view, id) {
    util_1.getById(view, id).map(function (h) { h.removeMessage(); });
};

},{"../util":138,"./feedback":44}],51:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml_1 = require("@quenk/wml");
var util_1 = require("../../util");
var feedback_1 = require("../feedback");
var __1 = require("../../");
var help_1 = require("./wml/help");
///classNames:begin
exports.HELP = 'ww-help';
/**
 * Help
 */
var Help = /** @class */ (function (_super) {
    __extends(Help, _super);
    function Help() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new help_1.Main(_this);
        _this.values = {
            help: {
                wml: {
                    id: 'help'
                },
                id: (_this.attrs.ww && _this.attrs.ww.id) ?
                    _this.attrs.ww.id : '',
                className: util_1.concat(exports.HELP, __1.getClassName(_this.attrs)),
                text: (_this.attrs.ww && _this.attrs.ww.text) ?
                    [document.createTextNode(_this.attrs.ww.text)] : _this.children
            }
        };
        return _this;
    }
    Help.prototype.setMessage = function (msg) {
        feedback_1.setMessage(this.view, this.values.help.wml.id, msg);
        return this;
    };
    Help.prototype.removeMessage = function () {
        feedback_1.removeMessage(this.view, this.values.help.wml.id);
        return this;
    };
    return Help;
}(wml_1.Component));
exports.Help = Help;

},{"../../":101,"../../util":138,"../feedback":44,"./wml/help":52,"@quenk/wml":145}],52:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('span', { html: { 'id': __context.values.help.id, 'class': __context.values.help.className }, wml: { 'id': __context.values.help.wml.id } }, __spreadArrays((__context.values.help.text)));
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":141}],53:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This module provides the parent interfaces for most of the
 * widgets considered 'controls'.
 *
 * Controls allow users to manipulate the state of an application
 * by interacting with widgets on screen. In simpler terms,
 * they are the widgets that accept user input or trigger
 * reactions when the user manipulates them.
 *
 * Generally, we use a streaming based workflow, that is
 * as the user preforms a supported action and event is generated
 * each and every time and some handler is applied to the event.
 */
/** @imports */
var wml_1 = require("@quenk/wml");
var maybe_1 = require("@quenk/noni/lib/data/maybe");
/**
 * Event is the parent class of all events generated by controls.
 */
var Event = /** @class */ (function () {
    function Event(name, value) {
        this.name = name;
        this.value = value;
    }
    return Event;
}());
exports.Event = Event;
/**
 * AbstractControl implements the methods of the Control interface.
 */
var AbstractControl = /** @class */ (function (_super) {
    __extends(AbstractControl, _super);
    function AbstractControl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return AbstractControl;
}(wml_1.Component));
exports.AbstractControl = AbstractControl;
/**
 * getName
 */
exports.getName = function (attrs) {
    return (attrs.ww && attrs.ww.name) ? attrs.ww.name : '';
};
/**
 * getDisabled
 */
exports.getDisabled = function (attrs) {
    return (attrs.ww && attrs.ww.disabled) ? attrs.ww.disabled : undefined;
};
/**
 * getValue
 */
exports.getValue = function (attrs) {
    return (attrs.ww && attrs.ww.value) ? maybe_1.just(attrs.ww.value) : maybe_1.nothing();
};

},{"@quenk/noni/lib/data/maybe":141,"@quenk/wml":145}],54:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml_1 = require("@quenk/wml");
var util_1 = require("../../util");
var __1 = require("../../");
var label_1 = require("./wml/label");
///classNames:begin
exports.LABEL = 'ww-label';
/**
 * Label
 */
var Label = /** @class */ (function (_super) {
    __extends(Label, _super);
    function Label() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new label_1.Main(_this);
        _this.values = {
            label: {
                className: util_1.concat(exports.LABEL, __1.getClassName(_this.attrs)),
                for: (_this.attrs.ww && _this.attrs.ww.for) ?
                    _this.attrs.ww.for : '',
                text: (_this.attrs.ww && _this.attrs.ww.text) ?
                    [document.createTextNode(_this.attrs.ww.text)] : _this.children
            }
        };
        return _this;
    }
    return Label;
}(wml_1.Component));
exports.Label = Label;

},{"../../":101,"../../util":138,"./wml/label":55,"@quenk/wml":145}],55:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('label', { html: { 'for': __context.values.label.for, 'class': __context.values.label.className }, wml: {} }, __spreadArrays((__context.values.label.text)));
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":141}],56:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/multi-select");
var orientation_1 = require("../../content/orientation");
var form_1 = require("../form");
var search_1 = require("../search");
exports.TermChangedEvent = search_1.TermChangedEvent;
var util_1 = require("../../util");
var __1 = require("../../");
var __2 = require("../");
var feedback_1 = require("../feedback");
var active_1 = require("../../content/state/active");
///classNames:begin
exports.MULTI_SELECT = 'ww-multi-select';
exports.MULTI_SELECT_CONTENT = 'ww-multi-select__content';
exports.MULTI_SELECT_INPUT = 'ww-multi-select__input';
exports.MULTI_SELECT_TAG = 'ww-multi-select__tag';
///classNames:end
exports.DEFAULT_INPUT_WIDTH = 50;
exports.DEFAULT_FONT_INCREMENT = 7;
/**
 * ItemsChangedEvent
 */
var ItemsChangedEvent = /** @class */ (function (_super) {
    __extends(ItemsChangedEvent, _super);
    function ItemsChangedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ItemsChangedEvent;
}(__2.Event));
exports.ItemsChangedEvent = ItemsChangedEvent;
/**
 * MultiSelect
 */
var MultiSelect = /** @class */ (function (_super) {
    __extends(MultiSelect, _super);
    function MultiSelect() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: {
                wml: {
                    id: 'root'
                },
                id: __1.getId(_this.attrs),
                className: util_1.concat(exports.MULTI_SELECT, __1.getClassName(_this.attrs), feedback_1.getValidityClassName(_this.attrs), orientation_1.getBlockClassName(_this.attrs))
            },
            control: {
                wml: {
                    id: 'root'
                }
            },
            label: {
                wml: {
                    id: 'label'
                },
                text: form_1.getLabel(_this.attrs)
            },
            search: {
                wml: {
                    id: 'search'
                },
                block: _this.attrs.ww && _this.attrs.ww.block || undefined,
                itemTemplate: (_this.attrs.ww && _this.attrs.ww.itemTemplate) ?
                    _this.attrs.ww.itemTemplate : undefined,
                noItemsTemplate: (_this.attrs.ww && _this.attrs.ww.noItemsTemplate) ?
                    _this.attrs.ww.noItemsTemplate : undefined,
                onSearch: function (evt) {
                    if (_this.attrs.ww && _this.attrs.ww.onSearch)
                        _this.attrs.ww.onSearch(evt);
                },
                onSelect: function (_a) {
                    var value = _a.value;
                    _this.push(value);
                    _this.fireChange();
                    _this.redraw();
                }
            },
            messages: {
                wml: {
                    id: 'message'
                },
                text: feedback_1.getMessage(_this.attrs)
            },
            content: {
                className: exports.MULTI_SELECT_CONTENT,
                onfocus: function () { return _this.focus(); }
            },
            tags: {
                className: util_1.concat(exports.MULTI_SELECT_TAG, feedback_1.getValidityClassName(_this.attrs)),
                value: [],
                has: function () { return _this.values.tags.value.length > 0; },
                getText: (_this.attrs.ww && _this.attrs.ww.stringifier) ?
                    _this.attrs.ww.stringifier : function (v) { return String(v); },
                onDismiss: function (e) {
                    var idx = Number(e.name);
                    _this.values.tags.value.splice(idx, 1);
                    _this.fireChange();
                    _this.redraw();
                }
            },
            input: {
                wml: {
                    id: 'input'
                },
                className: exports.MULTI_SELECT_INPUT,
                name: __2.getName(_this.attrs),
                inputWidth: (_this.attrs.ww && _this.attrs.ww.inputWidth) ?
                    _this.attrs.ww.inputWidth : exports.DEFAULT_INPUT_WIDTH,
                fontIncrement: (_this.attrs.ww && _this.attrs.ww.fontIncrement) ?
                    _this.attrs.ww.fontIncrement : exports.DEFAULT_FONT_INCREMENT,
                onSearch: function (e) {
                    _this.grow(e.value.length + 1);
                    if (_this.attrs.ww && _this.attrs.ww.onSearch)
                        _this.attrs.ww.onSearch(e);
                }
            },
            menu: {
                wml: { id: 'menu' },
                name: __2.getName(_this.attrs),
                block: true,
                onSelect: function (e) {
                    _this.close();
                    _this.values.tags.value.push(e.value);
                    _this.fireChange();
                    _this.redraw();
                },
                itemTemplate: (_this.attrs.ww && _this.attrs.ww.itemTemplate) ?
                    _this.attrs.ww.itemTemplate : undefined,
                noItemsTemplate: (_this.attrs.ww && _this.attrs.ww.noItemsTemplate) ?
                    _this.attrs.ww.noItemsTemplate : undefined,
                stringifier: (_this.attrs.ww && _this.attrs.ww.stringifier) ?
                    _this.attrs.ww.stringifier : undefined
            }
        };
        return _this;
    }
    /**
     * @private
     */
    MultiSelect.prototype.fireChange = function () {
        if (this.attrs.ww && this.attrs.ww.onChange)
            this.attrs.ww.onChange(new ItemsChangedEvent(__2.getName(this.attrs), this.values.tags.value.slice()));
    };
    /**
     * @private
     */
    MultiSelect.prototype.grow = function (n) {
        var mInput = util_1.getById(this.view, this.values.input.wml.id);
        if (mInput.isNothing())
            return;
        var i = mInput.get();
        var mDom = util_1.getById(i.view, i.values.wml.id);
        if (mDom.isNothing())
            return;
        var dom = mDom.get();
        dom.style.width = n * this.values.input.fontIncrement + "px";
    };
    /**
     * @private
     */
    MultiSelect.prototype.redraw = function () {
        this.view.invalidate();
        this.focus();
        return this;
    };
    MultiSelect.prototype.setMessage = function (msg) {
        form_1.setMessage(this.view, this.values.messages.wml.id, msg);
        return this;
    };
    MultiSelect.prototype.removeMessage = function () {
        form_1.removeMessage(this.view, this.values.messages.wml.id);
        return this;
    };
    MultiSelect.prototype.update = function (results) {
        search_1.updateMenu(this.view, this.values.menu.wml.id, results);
        return this;
    };
    MultiSelect.prototype.open = function () {
        search_1.openMenu(this.view, this.values.menu.wml.id);
        return this;
    };
    MultiSelect.prototype.close = function () {
        search_1.closeMenu(this.view, this.values.menu.wml.id);
        return this;
    };
    MultiSelect.prototype.focus = function () {
        getInput(this).map(function (i) { return i.focus(); });
        getRoot(this).map(function (e) { return e.classList.add(active_1.ACTIVE); });
        return this;
    };
    /**
     * push a value onto the end of the internal stack.
     */
    MultiSelect.prototype.push = function (value) {
        this.values.tags.value.push(value);
        this.fireChange();
        return this;
    };
    return MultiSelect;
}(form_1.AbstractFormControl));
exports.MultiSelect = MultiSelect;
var getInput = function (m) {
    return util_1.getById(m.view, m.values.input.wml.id);
};
var getRoot = function (m) {
    return util_1.getById(m.view, m.values.root.wml.id);
};

},{"../":53,"../../":101,"../../content/orientation":13,"../../content/state/active":17,"../../util":138,"../feedback":44,"../form":50,"../search":62,"./wml/multi-select":57}],57:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var label_1 = require("../../label");
;
var help_1 = require("../../help");
;
var tag_1 = require("../../tag");
;
var search_1 = require("../../search");
;
var results_menu_1 = require("../../results-menu");
;
var __1 = require("../../../");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'id': __context.values.root.id, 'class': __context.values.root.className }, wml: {} }, [
                __this.widget(label_1.Label, { html: {}, wml: {}, ww: { 'for': __context.values.root.id, 'text': __context.values.label.text } }, []),
                __this.node('div', { html: { 'onclick': __context.values.content.onfocus, 'class': __context.values.content.className }, wml: {} }, __spreadArrays((__if(__context.values.tags.has(), function () { return (__spreadArrays(__forIn(__context.values.tags.value, function (value, idx, _$$all) {
                    return ([
                        __this.widget(tag_1.Tag, { html: {}, wml: {}, ww: { 'name': String(idx), 'text': __context.values.tags.getText(value), 'className': __context.values.tags.className, 'onDismiss': __context.values.tags.onDismiss } }, [])
                    ]);
                }, function () { return ([]); }))); }, function () { return ([
                    __1.text("")
                ]); })), [
                    __this.widget(search_1.Input, { html: {}, wml: { 'id': __context.values.input.wml.id }, ww: { 'className': __context.values.input.className, 'name': __context.values.input.name, 'onSearch': __context.values.input.onSearch } }, [])
                ])),
                __this.widget(results_menu_1.ResultsMenu, { html: {}, wml: { 'id': __context.values.menu.wml.id }, ww: { 'block': __context.values.menu.block, 'onSelect': __context.values.menu.onSelect, 'noItemsTemplate': __context.values.menu.noItemsTemplate, 'itemsTemplate': __context.values.menu.itemTemplate, 'stringifier': __context.values.menu.stringifier } }, []),
                __this.widget(help_1.Help, { html: {}, wml: { 'id': __context.values.messages.wml.id }, ww: { 'text': __context.values.messages.text } }, [])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../":101,"../../help":51,"../../label":54,"../../results-menu":60,"../../search":62,"../../tag":74,"@quenk/noni/lib/data/maybe":141}],58:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml_1 = require("@quenk/wml");
var util_1 = require("../../util");
var __1 = require("../../");
var __2 = require("../");
var paginator_1 = require("./wml/paginator");
///classNames:begin
exports.PAGINATOR = 'ww-paginator';
exports.PAGINATOR_FIRST = 'ww-paginator__first';
exports.PAGINATOR_PREVIOUS = 'ww-paginator__previous';
exports.PAGINATOR_POSITION = 'ww-paginator__position';
exports.PAGINATOR_NEXT = 'ww-paginator__next';
exports.PAGINATOR_LAST = 'ww-paginator__last';
/**
 * PageChangedEvent indicating the current page has been changed.
 */
var PageChangedEvent = /** @class */ (function (_super) {
    __extends(PageChangedEvent, _super);
    function PageChangedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return PageChangedEvent;
}(__2.Event));
exports.PageChangedEvent = PageChangedEvent;
/**
 * Paginator provides a control for navigating paged data, results, view etc.
 */
var Paginator = /** @class */ (function (_super) {
    __extends(Paginator, _super);
    function Paginator() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new paginator_1.Main(_this);
        _this.values = {
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.PAGINATOR, __1.getClassName(_this.attrs)),
            current: {
                value: (_this.attrs.ww && _this.attrs.ww.current) ?
                    _this.attrs.ww.current : 1,
                asString: function () { return '' + _this.values.current.value; }
            },
            total: (_this.attrs.ww && _this.attrs.ww.total) ?
                _this.attrs.ww.total : 1,
            first: {
                className: exports.PAGINATOR_FIRST,
                isDisabled: function () { return (_this.values.current.value <= 1); },
                onclick: function (e) {
                    e.preventDefault();
                    _this.values.current.value = 1;
                    _this.fire();
                }
            },
            previous: {
                className: exports.PAGINATOR_PREVIOUS,
                isDisabled: function () { return (_this.values.current.value <= 1); },
                onclick: function (e) {
                    e.preventDefault();
                    _this.values.current.value = _this.values.current.value - 1;
                    _this.fire();
                }
            },
            position: {
                className: exports.PAGINATOR_POSITION
            },
            next: {
                className: exports.PAGINATOR_NEXT,
                isDisabled: function () { return (_this.values.current.value >= _this.values.total); },
                onclick: function (e) {
                    e.preventDefault();
                    _this.values.current.value = _this.values.current.value + 1;
                    _this.fire();
                }
            },
            last: {
                className: exports.PAGINATOR_LAST,
                isDisabled: function () { return (_this.values.current.value >= _this.values.total); },
                onclick: function (e) {
                    e.preventDefault();
                    _this.values.current.value = _this.values.total;
                    _this.fire();
                }
            }
        };
        return _this;
    }
    /**
     * @private
     */
    Paginator.prototype.fire = function () {
        if (this.attrs.ww && this.attrs.ww.onChange)
            this.attrs.ww.onChange(new PageChangedEvent(this.attrs.ww.name || '', this.values.current.value));
        this.view.invalidate();
    };
    return Paginator;
}(wml_1.Component));
exports.Paginator = Paginator;

},{"../":53,"../../":101,"../../util":138,"./wml/paginator":59,"@quenk/wml":145}],59:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var __1 = require("../../../");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('ul', { html: { 'id': __context.values.id, 'class': __context.values.className }, wml: {} }, [
                __this.node('li', { html: { 'class': __context.values.first.className }, wml: {} }, __spreadArrays((__if(__context.values.first.isDisabled(), function () { return ([
                    __this.node('span', { html: {}, wml: {} }, [])
                ]); }, function () { return ([
                    __this.node('a', { html: { 'href': "#", 'onclick': __context.values.first.onclick }, wml: {} }, [])
                ]); })))),
                __this.node('li', { html: { 'class': __context.values.previous.className }, wml: {} }, __spreadArrays((__if(__context.values.previous.isDisabled(), function () { return ([
                    __this.node('span', { html: {}, wml: {} }, [])
                ]); }, function () { return ([
                    __this.node('a', { html: { 'href': "#", 'onclick': __context.values.previous.onclick }, wml: {} }, [])
                ]); })))),
                __this.node('li', { html: { 'class': __context.values.position.className }, wml: {} }, [
                    __this.node('span', { html: {}, wml: {} }, [
                        document.createTextNode("Page "),
                        __this.node('input', { html: { 'value': __context.values.current.asString() }, wml: {} }, []),
                        document.createTextNode(" of "),
                        __1.text(__context.values.total)
                    ])
                ]),
                __this.node('li', { html: { 'class': __context.values.next.className }, wml: {} }, __spreadArrays((__if(__context.values.next.isDisabled(), function () { return ([
                    __this.node('span', { html: {}, wml: {} }, [])
                ]); }, function () { return ([
                    __this.node('a', { html: { 'href': "#", 'onclick': __context.values.next.onclick }, wml: {} }, [])
                ]); })))),
                __this.node('li', { html: { 'class': __context.values.last.className }, wml: {} }, __spreadArrays((__if(__context.values.last.isDisabled(), function () { return ([
                    __this.node('span', { html: {}, wml: {} }, [])
                ]); }, function () { return ([
                    __this.node('a', { html: { 'href': "#", 'onclick': __context.values.last.onclick }, wml: {} }, [])
                ]); }))))
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../":101,"@quenk/noni/lib/data/maybe":141}],60:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var maybe_1 = require("@quenk/noni/lib/data/maybe");
var wml_1 = require("@quenk/wml");
var util_1 = require("../../util");
var __1 = require("../");
var results_menu_1 = require("./wml/results-menu");
/**
 * ItemSelectedEvent
 */
var ItemSelectedEvent = /** @class */ (function (_super) {
    __extends(ItemSelectedEvent, _super);
    function ItemSelectedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ItemSelectedEvent;
}(__1.Event));
exports.ItemSelectedEvent = ItemSelectedEvent;
/**
 * ResultsMenu used to display results in select styled controls.
 */
var ResultsMenu = /** @class */ (function (_super) {
    __extends(ResultsMenu, _super);
    function ResultsMenu() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new results_menu_1.Main(_this);
        _this.values = {
            wml: {
                id: 'menu'
            },
            tree: maybe_1.nothing(),
            results: [],
            name: (_this.attrs.ww && _this.attrs.ww.name) ?
                _this.attrs.ww.name : '',
            block: (_this.attrs.ww && _this.attrs.ww.block) ?
                _this.attrs.ww.block : false,
            hidden: true,
            item: {
                stringifier: (_this.attrs.ww && _this.attrs.ww.stringifier) ?
                    _this.attrs.ww.stringifier : function (v) { return Object.toString.call(v); },
                click: function (index) {
                    if (_this.attrs.ww && _this.attrs.ww.onSelect)
                        _this.attrs.ww.onSelect(new ItemSelectedEvent(_this.attrs.ww && _this.attrs.ww.name || '', _this.values.results[index]));
                },
                template: function () {
                    return (_this.attrs.ww && _this.attrs.ww.itemTemplate) ?
                        _this.attrs.ww.itemTemplate : results_menu_1.itemTemplate(_this);
                },
                noItemsTemplate: function () {
                    return (_this.attrs.ww && _this.attrs.ww.noItemsTemplate) ?
                        _this.attrs.ww.noItemsTemplate : results_menu_1.noItemsTemplate();
                },
            }
        };
        return _this;
    }
    ResultsMenu.prototype.open = function () {
        util_1.getById(this.view, this.values.wml.id)
            .map(function (m) { return m.show(); });
        this.values.hidden = false;
        return this;
    };
    ResultsMenu.prototype.close = function () {
        util_1.getById(this.view, this.values.wml.id)
            .map(function (m) { return m.hide(); });
        this.values.hidden = true;
        return this;
    };
    ResultsMenu.prototype.handleEvent = function (e) {
        if (this.values.tree.isJust()) {
            var root = this.values.tree.get();
            if (!document.body.contains(root))
                document.removeEventListener('click', this);
            if ((!root.contains(e.target)))
                this.close();
        }
    };
    /**
     * update will cause the menu to be displayed.
     */
    ResultsMenu.prototype.update = function (results) {
        this.values.results = results;
        window.removeEventListener('click', this);
        window.addEventListener('click', this);
        this.values.hidden = false;
        this.view.invalidate();
        return this;
    };
    ResultsMenu.prototype.render = function () {
        this.values.tree = maybe_1.just(this.view.render());
        return this.values.tree.get();
    };
    return ResultsMenu;
}(wml_1.Component));
exports.ResultsMenu = ResultsMenu;

},{"../":53,"../../util":138,"./wml/results-menu":61,"@quenk/noni/lib/data/maybe":141,"@quenk/wml":145}],61:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var __1 = require("../../../");
;
var link_1 = require("../../../content/link");
;
var menu_1 = require("../../../menu/menu");
;
var item_1 = require("../../../menu/item");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
exports.itemTemplate = function (r) { return function (option) { return function (_index) { return function (__this) {
    return [
        __1.text(r.values.item.stringifier(option))
    ];
}; }; }; };
;
exports.noItemsTemplate = function () { return function (__this) {
    return [
        __this.node('b', { html: {}, wml: {} }, [
            document.createTextNode("No results to display.")
        ])
    ];
}; };
;
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(menu_1.Menu, { html: {}, wml: { 'id': __context.values.wml.id }, ww: { 'name': __context.values.name, 'block': __context.values.block, 'hidden': __context.values.hidden } }, __spreadArrays(__forIn(__context.values.results, function (result, index, _$$all) {
                return ([
                    __this.widget(item_1.Item, { html: {}, wml: {}, ww: { 'name': ("" + index) } }, [
                        __this.widget(link_1.Link, { html: {}, wml: {}, ww: { 'onClick': function () { return __context.values.item.click(index); } } }, __spreadArrays((__context.values.item.template()(result)(index)(__this))))
                    ])
                ]);
            }, function () { return (__spreadArrays((__context.values.item.noItemsTemplate()(__this)))); })));
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../":101,"../../../content/link":7,"../../../menu/item":131,"../../../menu/menu":133,"@quenk/noni/lib/data/maybe":141}],62:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/search");
var orientation_1 = require("../../content/orientation");
var util_1 = require("../../util");
var results_menu_1 = require("../results-menu");
exports.ItemSelectedEvent = results_menu_1.ItemSelectedEvent;
var __1 = require("../../");
var __2 = require("../");
/**
 * ESCAPE key code.
 */
exports.ESCAPE = 27;
///classNames:begin
exports.SEARCH = 'ww-search';
exports.SEARCH_INPUT = 'ww-search__input';
/**
 * TermChangedEvent signals the search term has changed.
 */
var TermChangedEvent = /** @class */ (function (_super) {
    __extends(TermChangedEvent, _super);
    function TermChangedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return TermChangedEvent;
}(__2.Event));
exports.TermChangedEvent = TermChangedEvent;
/**
 * FocusGainedEvent signals the user as given focus to the control.
 */
var FocusGainedEvent = /** @class */ (function () {
    function FocusGainedEvent(name) {
        this.name = name;
    }
    return FocusGainedEvent;
}());
exports.FocusGainedEvent = FocusGainedEvent;
/**
 * FocusLostEvent signals the user has removed focus from the control.
 */
var FocusLostEvent = /** @class */ (function () {
    function FocusLostEvent(name) {
        this.name = name;
    }
    return FocusLostEvent;
}());
exports.FocusLostEvent = FocusLostEvent;
/**
 * EscapeEvent signals the user has pressed the escape key while typing.
 */
var EscapeEvent = /** @class */ (function () {
    function EscapeEvent(name) {
        this.name = name;
    }
    return EscapeEvent;
}());
exports.EscapeEvent = EscapeEvent;
/**
 * Input provides the input part of a Search control.
 *
 * This is here mostly for code re-use.
 */
var Input = /** @class */ (function (_super) {
    __extends(Input, _super);
    function Input() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.InputView(_this);
        _this.values = {
            wml: { id: 'root' },
            className: util_1.concat(exports.SEARCH_INPUT, __1.getClassName(_this.attrs)),
            placeholder: (_this.attrs.ww && _this.attrs.ww.placeholder) ?
                _this.attrs.ww.placeholder : '',
            readOnly: (_this.attrs.ww && _this.attrs.ww.readOnly) || undefined,
            autocomplete: 'do not enable please',
            size: String((_this.attrs.ww && _this.attrs.ww.size) ?
                _this.attrs.ww.size : 20),
            value: (_this.attrs.ww && _this.attrs.ww.value) ?
                _this.attrs.ww.value : '',
            onfocus: function (e) {
                var target = e.target;
                if (_this.attrs.ww && _this.attrs.ww.onFocus)
                    _this.attrs.ww.onFocus(new FocusGainedEvent(_this.attrs.ww && _this.attrs.ww.name || ''));
                target.value = target.value;
            },
            onkeydown: function (e) {
                if (e.keyCode !== exports.ESCAPE)
                    if (_this.attrs.ww && _this.attrs.ww.onSearch) {
                        var name_1 = '' + _this.attrs.ww.name;
                        var value = e.target.value;
                        _this.attrs.ww.onSearch(new TermChangedEvent(name_1, value));
                    }
            },
            onkeyup: function (e) {
                if (e.keyCode === exports.ESCAPE)
                    if (_this.attrs.ww && _this.attrs.ww.onEscape)
                        _this.attrs.ww.onEscape(new EscapeEvent(_this.attrs.ww.name || ''));
            },
            oninput: function (e) {
                //For compatability reasons
                e.target.oninput = null;
                _this.values.onkeydown(e);
            },
            onblur: function () {
                if (_this.attrs.ww && _this.attrs.ww.onBlur)
                    _this.attrs.ww.onBlur(new FocusLostEvent(_this.attrs.ww && _this.attrs.ww.name || ''));
            }
        };
        return _this;
    }
    /**
     * focus steals user focus to the Input.
     */
    Input.prototype.focus = function () {
        getInput(this).map(function (i) { return i.focus(); });
        return this;
    };
    /**
     * setSize sets the size of the input.
     */
    Input.prototype.setSize = function (n) {
        this.values.size = String(n);
        getInput(this).map(function (i) { return i.setAttribute('size', String(n)); });
        return this;
    };
    /**
     * getSize returns the size of the (internally tracked) size
     * of the Input.
     */
    Input.prototype.getSize = function () {
        return Number(this.values.size);
    };
    return Input;
}(__2.AbstractControl));
exports.Input = Input;
/**
 * Search provides an input that can be used in the ui for a search engine.
 */
var Search = /** @class */ (function (_super) {
    __extends(Search, _super);
    function Search() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: {
                wml: {
                    id: 'root'
                },
                id: __1.getId(_this.attrs),
                className: util_1.concat(exports.SEARCH, __1.getClassName(_this.attrs), orientation_1.getBlockClassName(_this.attrs))
            },
            input: {
                wml: {
                    id: 'input'
                },
                name: __2.getName(_this.attrs),
                placeholder: (_this.attrs.ww && _this.attrs.ww.placeholder) ?
                    _this.attrs.ww.placeholder : '',
                readOnly: (_this.attrs.ww && _this.attrs.ww.readOnly) || undefined,
                value: (_this.attrs.ww && _this.attrs.ww.term) ?
                    _this.attrs.ww.term :
                    (_this.attrs.ww &&
                        _this.attrs.ww.stringifier &&
                        _this.attrs.ww.value) ?
                        _this.attrs.ww.stringifier(_this.attrs.ww.value) : '',
                onFocus: _this.attrs.ww && _this.attrs.ww.onFocus || undefined,
                onSearch: (_this.attrs.ww && _this.attrs.ww.onSearch) ?
                    _this.attrs.ww.onSearch : undefined,
                onEscape: function () { return _this.close(); },
                onBlur: (_this.attrs.ww && _this.attrs.ww.onBlur) ?
                    _this.attrs.ww.onBlur : undefined
            },
            menu: {
                wml: {
                    id: 'menu'
                },
                name: (_this.attrs.ww && _this.attrs.ww.name) ?
                    _this.attrs.ww.name : '',
                block: (_this.attrs.ww && _this.attrs.ww.block) ?
                    _this.attrs.ww.block : false,
                onSelect: function (e) {
                    _this.close();
                    if (_this.attrs.ww && _this.attrs.ww.onSelect)
                        _this.attrs.ww.onSelect(e);
                },
                itemTemplate: (_this.attrs.ww && _this.attrs.ww.itemTemplate) ?
                    _this.attrs.ww.itemTemplate : undefined,
                noItemsTemplate: (_this.attrs.ww && _this.attrs.ww.noItemsTemplate) ?
                    _this.attrs.ww.noItemsTemplate : undefined,
                stringifier: (_this.attrs.ww && _this.attrs.ww.stringifier) ?
                    _this.attrs.ww.stringifier : undefined
            }
        };
        return _this;
    }
    Search.prototype.set = function (value) {
        util_1.getById(this.view, this.values.root.wml.id)
            .map(function (e) { e.value = value; });
        return this;
    };
    /**
     * update the Select with new item options to
     * present to the user.
     */
    Search.prototype.update = function (results) {
        exports.updateMenu(this.view, this.values.menu.wml.id, results);
        return this;
    };
    /**
     * open the results menu.
     */
    Search.prototype.open = function () {
        exports.openMenu(this.view, this.values.menu.wml.id);
        return this;
    };
    /**
     * close the results menu.
     */
    Search.prototype.close = function () {
        exports.closeMenu(this.view, this.values.menu.wml.id);
        return this;
    };
    return Search;
}(__2.AbstractControl));
exports.Search = Search;
var getInput = function (i) {
    return util_1.getById(i.view, i.values.wml.id);
};
/**
 * updateMenu will cause the menu to be displayed with new items.
 */
exports.updateMenu = function (view, id, results) {
    var mMenu = util_1.getById(view, id);
    if (mMenu.isJust())
        mMenu.get().update(results);
};
/**
 * openMenu will cause the menu to be displayed with whatever contents
 * were previously set.
 */
exports.openMenu = function (view, id) {
    util_1.getById(view, id)
        .map(function (m) { return m.open(); });
};
/**
 * closeMenu will cause the menu to no longer be displayed.
 */
exports.closeMenu = function (view, id) {
    util_1.getById(view, id)
        .map(function (m) { return m.close(); });
};

},{"../":53,"../../":101,"../../content/orientation":13,"../../util":138,"../results-menu":60,"./wml/search":63}],63:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var results_menu_1 = require("../../results-menu");
;
var __1 = require("../");
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var InputView = /** @class */ (function () {
    function InputView(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('input', { html: { 'class': __context.values.className, 'onkeydown': __context.values.onkeydown, 'onkeyup': __context.values.onkeyup, 'oninput': __context.values.oninput, 'onfocus': __context.values.onfocus, 'onblur': __context.values.onblur, 'autocomplete': __context.values.autocomplete, 'size': __context.values.size, 'placeholder': __context.values.placeholder, 'readOnly': __context.values.readOnly, 'value': __context.values.value }, wml: { 'id': __context.values.wml.id } }, []);
        };
    }
    InputView.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    InputView.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    InputView.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    InputView.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    InputView.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    InputView.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    InputView.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return InputView;
}());
exports.InputView = InputView;
;
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'id': __context.values.root.id, 'class': __context.values.root.className }, wml: { 'id': __context.values.root.wml.id } }, [
                __this.widget(__1.Input, { html: {}, wml: { 'id': __context.values.input.wml.id }, ww: { 'name': __context.values.input.name, 'onFocus': __context.values.input.onFocus, 'onSearch': __context.values.input.onSearch, 'onEscape': __context.values.input.onEscape, 'onBlur': __context.values.input.onBlur, 'placeholder': __context.values.input.placeholder, 'readOnly': __context.values.input.readOnly, 'value': __context.values.input.value } }, []),
                __this.widget(results_menu_1.ResultsMenu, { html: {}, wml: { 'id': __context.values.menu.wml.id }, ww: { 'block': __context.values.menu.block, 'onSelect': __context.values.menu.onSelect, 'noItemsTemplate': __context.values.menu.noItemsTemplate, 'itemsTemplate': __context.values.menu.itemTemplate, 'stringifier': __context.values.menu.stringifier } }, [])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../":62,"../../results-menu":60,"@quenk/noni/lib/data/maybe":141}],64:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/select");
var maybe_1 = require("@quenk/noni/lib/data/maybe");
var orientation_1 = require("../../content/orientation");
var util_1 = require("../../util");
var feedback_1 = require("../feedback");
var form_1 = require("../form");
var __1 = require("../../");
var __2 = require("../");
var search_1 = require("../search");
exports.TermChangedEvent = search_1.TermChangedEvent;
exports.ItemSelectedEvent = search_1.ItemSelectedEvent;
///classNames:begin
exports.SELECT = 'ww-select';
/**
 * ItemChangedEvent
 */
var ItemChangedEvent = /** @class */ (function (_super) {
    __extends(ItemChangedEvent, _super);
    function ItemChangedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ItemChangedEvent;
}(__2.Event));
exports.ItemChangedEvent = ItemChangedEvent;
/**
 * ItemUnsetEvent
 */
var ItemUnsetEvent = /** @class */ (function (_super) {
    __extends(ItemUnsetEvent, _super);
    function ItemUnsetEvent(name) {
        var _this = _super.call(this, name, undefined) || this;
        _this.name = name;
        return _this;
    }
    return ItemUnsetEvent;
}(__2.Event));
exports.ItemUnsetEvent = ItemUnsetEvent;
/**
 * RootSection
 */
var RootSection = /** @class */ (function () {
    function RootSection(attrs) {
        this.attrs = attrs;
        this.wml = { id: 'root' };
        this.id = __1.getId(this.attrs);
        this.className = util_1.concat(exports.SELECT, __1.getClassName(this.attrs), feedback_1.getValidityClassName(this.attrs), orientation_1.getBlockClassName(this.attrs));
    }
    return RootSection;
}());
exports.RootSection = RootSection;
/**
 * ControlSection
 */
var ControlSection = /** @class */ (function () {
    function ControlSection() {
        this.wml = { id: 'root' };
    }
    return ControlSection;
}());
exports.ControlSection = ControlSection;
/**
 * MessagesSection
 */
var MessagesSection = /** @class */ (function () {
    function MessagesSection(attrs) {
        this.attrs = attrs;
        this.wml = { id: 'message' };
        this.text = feedback_1.getMessage(this.attrs);
    }
    return MessagesSection;
}());
exports.MessagesSection = MessagesSection;
/**
 * LabelSection
 */
var LabelSection = /** @class */ (function () {
    function LabelSection(attrs) {
        this.attrs = attrs;
        this.id = __2.getName(this.attrs);
        this.text = form_1.getLabel(this.attrs);
    }
    return LabelSection;
}());
exports.LabelSection = LabelSection;
/**
 * InputSection
 */
var InputSection = /** @class */ (function () {
    function InputSection(attrs) {
        this.attrs = attrs;
        this.wml = { id: 'input' };
    }
    return InputSection;
}());
exports.InputSection = InputSection;
/**
 * SearchSection
 */
var SearchSection = /** @class */ (function () {
    function SearchSection(attrs, close, onSelect) {
        this.attrs = attrs;
        this.close = close;
        this.onSelect = onSelect;
        this.wml = { id: 'search' };
        this.name = __2.getName(this.attrs);
        this.className = (this.attrs.ww && this.attrs.ww.inputClassName) ?
            this.attrs.ww.inputClassName : '';
        this.placeholder = (this.attrs.ww && this.attrs.ww.placeholder) ?
            this.attrs.ww.placeholder : '';
        this.block = (this.attrs.ww && this.attrs.ww.block) ?
            this.attrs.ww.block : false;
        this.value = (this.attrs.ww && this.attrs.ww.value) ?
            this.attrs.ww.value : undefined;
        this.readOnly = (this.attrs.ww && this.attrs.ww.readOnly);
        this.itemTemplate = (this.attrs.ww && this.attrs.ww.itemTemplate) ?
            this.attrs.ww.itemTemplate : undefined;
        this.noItemsTemplate = (this.attrs.ww && this.attrs.ww.noItemsTemplate) ?
            this.attrs.ww.noItemsTemplate : undefined;
        this.stringifier = (this.attrs.ww && this.attrs.ww.stringifier) ?
            this.attrs.ww.stringifier : undefined;
        this.onSearch = (this.attrs.ww && this.attrs.ww.onSearch) ?
            this.attrs.ww.onSearch : function () { };
    }
    return SearchSection;
}());
exports.SearchSection = SearchSection;
/**
 * Select provides an control for selecting an item from a
 * list.
 */
var Select = /** @class */ (function (_super) {
    __extends(Select, _super);
    function Select() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: new RootSection(_this.attrs),
            control: new ControlSection(),
            messages: new MessagesSection(_this.attrs),
            label: new LabelSection(_this.attrs),
            input: new InputSection(_this.attrs),
            search: new SearchSection(_this.attrs, function () { return _this.close(); }, function (e) {
                _this.close();
                _this.values.tag.value = maybe_1.just(e.value);
                if (_this.attrs.ww && _this.attrs.ww.onChange)
                    _this.attrs.ww.onChange(new ItemChangedEvent('' + _this.attrs.ww.name, e.value));
                _this.view.invalidate();
            }),
            tag: {
                className: feedback_1.getValidityClassName(_this.attrs),
                value: ((_this.attrs.ww &&
                    (_this.attrs.ww.value != undefined)) ?
                    maybe_1.just(_this.attrs.ww.value) : maybe_1.nothing()),
                isSet: function () { return _this.values.tag.value.isJust(); },
                getText: function () {
                    if (_this.attrs.ww && _this.attrs.ww.stringifier)
                        return _this.attrs.ww.stringifier(_this.values.tag.value.get());
                    return '';
                },
                dismiss: function () {
                    _this.values.tag.value = maybe_1.nothing();
                    if (_this.attrs.ww && _this.attrs.ww.onUnset)
                        _this.attrs.ww.onUnset(new ItemUnsetEvent(_this.attrs.ww.name + ''));
                    _this.view.invalidate();
                }
            }
        };
        return _this;
    }
    Select.prototype.open = function () {
        exports.open(this.view, this.values.search.wml.id);
        return this;
    };
    Select.prototype.close = function () {
        exports.close(this.view, this.values.search.wml.id);
        return this;
    };
    Select.prototype.setMessage = function (msg) {
        this.values.messages.text = msg;
        form_1.setMessage(this.view, this.values.messages.wml.id, msg);
        return this;
    };
    Select.prototype.removeMessage = function () {
        this.values.messages.text = '';
        form_1.removeMessage(this.view, this.values.messages.wml.id);
        return this;
    };
    /**
     * update the Select with new item options to
     * present to the user.
     */
    Select.prototype.update = function (results) {
        exports.update(this.view, this.values.search.wml.id, results);
        return this;
    };
    return Select;
}(form_1.AbstractFormControl));
exports.Select = Select;
/**
 * open helper.
 *
 * Invokes the open method on the Search widget.
 */
exports.open = function (view, id) {
    util_1.getById(view, id)
        .map(function (m) { return m.open(); });
};
/**
 * close helper.
 *
 * Invokes the close method on the Search widget.
 */
exports.close = function (view, id) {
    util_1.getById(view, id)
        .map(function (m) { return m.close(); });
};
/**
 * update helper.
 *
 * Invokes the update method on the Search widget.
 */
exports.update = function (view, id, results) {
    var mSearch = util_1.getById(view, id);
    if (mSearch.isJust())
        mSearch.get().update(results);
};

},{"../":53,"../../":101,"../../content/orientation":13,"../../util":138,"../feedback":44,"../form":50,"../search":62,"./wml/select":65,"@quenk/noni/lib/data/maybe":141}],65:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var search_1 = require("../../search");
;
var label_1 = require("../../label");
;
var help_1 = require("../../help");
;
var tag_1 = require("../../tag");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'id': __context.values.root.id, 'class': __context.values.root.className }, wml: {} }, __spreadArrays([
                __this.widget(label_1.Label, { html: {}, wml: {}, ww: { 'for': __context.values.root.id, 'text': __context.values.label.text } }, [])
            ], (__if(__context.values.tag.isSet(), function () { return ([
                __this.widget(tag_1.Tag, { html: {}, wml: {}, ww: { 'text': __context.values.tag.getText(), 'className': __context.values.tag.className, 'onDismiss': __context.values.tag.dismiss } }, [])
            ]); }, function () { return ([
                __this.widget(search_1.Search, { html: {}, wml: { 'id': __context.values.search.wml.id }, ww: { 'name': __context.values.search.name, 'className': __context.values.search.className, 'block': __context.values.search.block, 'placeholder': __context.values.search.placeholder, 'readOnly': __context.values.search.readOnly, 'itemTemplate': __context.values.search.itemTemplate, 'noItemsTemplate': __context.values.search.noItemsTemplate, 'stringifier': __context.values.search.stringifier, 'onSearch': __context.values.search.onSearch, 'onSelect': __context.values.search.onSelect } }, [])
            ]); })), [
                __this.widget(help_1.Help, { html: {}, wml: { 'id': __context.values.messages.wml.id }, ww: { 'text': __context.values.messages.text } }, [])
            ]));
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../help":51,"../../label":54,"../../search":62,"../../tag":74,"@quenk/noni/lib/data/maybe":141}],66:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/stack-select");
var orientation_1 = require("../../content/orientation");
var form_1 = require("../form");
var search_1 = require("../search");
exports.TermChangedEvent = search_1.TermChangedEvent;
var select_1 = require("../select");
var util_1 = require("../../util");
var __1 = require("../../");
var __2 = require("../");
var feedback_1 = require("../feedback");
///classNames:begin
exports.STACK_SELECT = 'ww-stack-select';
/**
 * ItemsChangedEvent
 */
var ItemsChangedEvent = /** @class */ (function (_super) {
    __extends(ItemsChangedEvent, _super);
    function ItemsChangedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ItemsChangedEvent;
}(__2.Event));
exports.ItemsChangedEvent = ItemsChangedEvent;
/**
 * StackSelect provides a control for allowing a user to select
 * multiple items from a list.
 *
 * It use a stack to display the selected items.
 *
 *     +=========================+
 *     |  <select>               |
 *     +=========================+
 *     +-------------------------+
 *     |   <item>              x |
 *     +-------------------------+
 *     +-------------------------+
 *     |   <item>              x |
 *     +-------------------------+
 *     +-------------------------+
 *     |   <item>              x |
 *     +-------------------------+
 */
var StackSelect = /** @class */ (function (_super) {
    __extends(StackSelect, _super);
    function StackSelect() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: {
                wml: {
                    id: 'root'
                },
                id: __1.getId(_this.attrs),
                className: util_1.concat(exports.STACK_SELECT, __1.getClassName(_this.attrs), feedback_1.getValidityClassName(_this.attrs), (_this.attrs.ww && _this.attrs.ww.block) ? orientation_1.BLOCK : ''),
                dir: (_this.attrs.ww && _this.attrs.ww.dir) ?
                    _this.attrs.ww.dir : 1
            },
            control: {
                wml: {
                    id: 'root'
                }
            },
            label: {
                wml: {
                    id: 'label'
                },
                text: form_1.getLabel(_this.attrs)
            },
            search: {
                wml: {
                    id: 'search'
                },
                name: (_this.attrs.ww && _this.attrs.ww.name) ?
                    _this.attrs.ww.name : '',
                value: undefined,
                block: true,
                onSearch: function (evt) {
                    if (_this.attrs.ww && _this.attrs.ww.onSearch)
                        _this.attrs.ww.onSearch(evt);
                },
                onSelect: function (_a) {
                    var value = _a.value;
                    return _this.push(value);
                }
            },
            messages: {
                wml: {
                    id: 'message'
                },
                text: feedback_1.getMessage(_this.attrs)
            },
            stack: {
                wml: {
                    id: 'stack'
                },
                name: __2.getName(_this.attrs),
                value: (_this.attrs.ww && _this.attrs.ww.value) ?
                    _this.attrs.ww.value : [],
                decorator: (_this.attrs.ww && _this.attrs.ww.stringifier) ?
                    _this.attrs.ww.stringifier : function (v) { return String(v); },
                onChange: function (e) {
                    if (_this.attrs.ww && _this.attrs.ww.onChange)
                        _this.attrs.ww.onChange(e);
                }
            }
        };
        return _this;
    }
    StackSelect.prototype.setMessage = function (msg) {
        form_1.setMessage(this.view, this.values.messages.wml.id, msg);
        return this;
    };
    StackSelect.prototype.removeMessage = function () {
        form_1.removeMessage(this.view, this.values.messages.wml.id);
        return this;
    };
    /**
     * update the list of available options displayed to the user.
     */
    StackSelect.prototype.update = function (list) {
        select_1.update(this.view, this.values.search.wml.id, list);
        return this;
    };
    /**
     * push a value onto the stack.
     */
    StackSelect.prototype.push = function (v) {
        this
            .view
            .findById(this.values.stack.wml.id)
            .map(function (s) { return s.push(v); });
        return this;
    };
    return StackSelect;
}(form_1.AbstractFormControl));
exports.StackSelect = StackSelect;

},{"../":53,"../../":101,"../../content/orientation":13,"../../util":138,"../feedback":44,"../form":50,"../search":62,"../select":64,"./wml/stack-select":67}],67:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var search_1 = require("../../search");
;
var stack_1 = require("../../stack");
;
var label_1 = require("../../label");
;
var help_1 = require("../../help");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'id': __context.values.root.id, 'class': __context.values.root.className }, wml: {} }, __spreadArrays((__if((__context.values.root.dir === -1), function () { return ([
                __this.widget(label_1.Label, { html: {}, wml: {}, ww: { 'for': __context.values.root.id, 'text': __context.values.label.text } }, []),
                __this.widget(search_1.Search, { html: {}, wml: { 'id': __context.values.search.wml.id }, ww: { 'name': __context.values.search.name, 'value': __context.values.search.value, 'block': __context.values.search.block, 'stringifier': __context.values.stack.decorator, 'onSearch': __context.values.search.onSearch, 'onSelect': __context.values.search.onSelect } }, []),
                __this.widget(stack_1.Stack, { html: {}, wml: { 'id': __context.values.stack.wml.id }, ww: { 'name': __context.values.stack.name, 'value': __context.values.stack.value, 'decorator': __context.values.stack.decorator, 'onChange': __context.values.stack.onChange } }, []),
                __this.widget(help_1.Help, { html: {}, wml: { 'id': __context.values.messages.wml.id }, ww: { 'text': __context.values.messages.text } }, [])
            ]); }, function () { return ([
                __this.widget(label_1.Label, { html: {}, wml: {}, ww: { 'for': __context.values.root.id, 'text': __context.values.label.text } }, []),
                __this.widget(stack_1.Stack, { html: {}, wml: { 'id': __context.values.stack.wml.id }, ww: { 'name': __context.values.stack.name, 'value': __context.values.stack.value, 'decorator': __context.values.stack.decorator, 'onChange': __context.values.stack.onChange } }, []),
                __this.widget(search_1.Search, { html: {}, wml: { 'id': __context.values.search.wml.id }, ww: { 'name': __context.values.search.name, 'value': __context.values.search.value, 'block': __context.values.search.block, 'stringifier': __context.values.stack.decorator, 'onSearch': __context.values.search.onSearch, 'onSelect': __context.values.search.onSelect } }, []),
                __this.widget(help_1.Help, { html: {}, wml: { 'id': __context.values.messages.wml.id }, ww: { 'text': __context.values.messages.text } }, [])
            ]); }))));
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../help":51,"../../label":54,"../../search":62,"../../stack":68,"@quenk/noni/lib/data/maybe":141}],68:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/stack");
var util_1 = require("../../util");
var __1 = require("../../");
var __2 = require("../");
///classNames:begin
exports.STACK = 'ww-stack';
exports.STACK_ELEMENT = 'ww-stack__element';
exports.STACK_ELEMENT_CONTENT = 'ww-stack__element__content';
exports.STACK_CLOSE_BUTTON = 'ww-stack__button';
/**
 * StackChangedEvent is generated when the user removes an item from the stack.
 */
var StackChangedEvent = /** @class */ (function (_super) {
    __extends(StackChangedEvent, _super);
    function StackChangedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return StackChangedEvent;
}(__2.Event));
exports.StackChangedEvent = StackChangedEvent;
/**
 * Stack displays a list of items that can be modified
 * by releasing one or more at a time.
 */
var Stack = /** @class */ (function (_super) {
    __extends(Stack, _super);
    function Stack() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: {
                id: __1.getId(_this.attrs),
                className: util_1.concat(exports.STACK, __1.getClassName(_this.attrs)),
                value: (_this.attrs.ww && _this.attrs.ww.value) ?
                    _this.attrs.ww.value : [],
                fire: function () {
                    if (_this.attrs.ww && _this.attrs.ww.onChange)
                        _this.attrs.ww.onChange(new StackChangedEvent(_this.attrs.ww.name, _this.values.root.value.slice()));
                    _this.view.invalidate();
                }
            },
            element: {
                className: exports.STACK_ELEMENT,
                template: function (v) { return function (idx) {
                    return (_this.attrs.ww && _this.attrs.ww.elementTemplate) ?
                        _this.attrs.ww.elementTemplate(_this)(v)(idx)(_this.view) :
                        views.content(_this)(v)(idx)(_this.view);
                }; },
                content: {
                    className: exports.STACK_ELEMENT_CONTENT
                },
                close: function (index) { return function () {
                    _this.values.root.value.splice(Number(index), 1);
                    _this.values.root.fire();
                }; },
                decorator: function (v) {
                    return __1.text((_this.attrs.ww && _this.attrs.ww.decorator) ?
                        _this.attrs.ww.decorator(v) : v + '');
                }
            },
            close: {
                className: exports.STACK_CLOSE_BUTTON
            }
        };
        return _this;
    }
    /**
     * push a new member onto the stack.
     */
    Stack.prototype.push = function (value) {
        this.values.root.value.push(value);
        this.values.root.fire();
        return this;
    };
    return Stack;
}(__2.AbstractControl));
exports.Stack = Stack;

},{"../":53,"../../":101,"../../util":138,"./wml/stack":69}],69:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
exports.content = function (s) { return function (v) { return function (_) { return function (__this) {
    return [
        __this.node('div', { html: { 'class': s.values.element.content.className }, wml: {} }, [
            s.values.element.decorator(v)
        ])
    ];
}; }; }; };
;
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('ul', { html: { 'id': __context.values.root.id, 'class': __context.values.root.className }, wml: {} }, __spreadArrays(__forIn(__context.values.root.value, function (v, index, _$$all) {
                return ([
                    __this.node('li', { html: { 'class': __context.values.element.className }, wml: {} }, __spreadArrays((__context.values.element.template(v)(index)), [
                        __this.node('button', { html: { 'class': __context.values.close.className, 'onclick': __context.values.element.close(index) }, wml: {} }, [
                            document.createTextNode("\u00D7")
                        ])
                    ]))
                ]);
            }, function () { return ([]); })));
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":141}],70:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../../util");
var __1 = require("../../");
var __2 = require("../");
var switch_1 = require("./wml/switch");
///classNames:begin
exports.SWITCH = 'ww-switch';
exports.SWITCH_SLIDER = 'ww-switch__slider';
/**
 * SwitchChangedEvent signals the user has changed the switch.
 */
var SwitchChangedEvent = /** @class */ (function (_super) {
    __extends(SwitchChangedEvent, _super);
    function SwitchChangedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return SwitchChangedEvent;
}(__2.Event));
exports.SwitchChangedEvent = SwitchChangedEvent;
/**
 * Switch allows the user to select between one or two values.
 */
var Switch = /** @class */ (function (_super) {
    __extends(Switch, _super);
    function Switch() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new switch_1.Main(_this);
        _this.values = {
            root: {
                id: __1.getId(_this.attrs),
                className: util_1.concat(exports.SWITCH, __1.getClassName(_this.attrs))
            },
            slider: {
                className: exports.SWITCH_SLIDER
            },
            input: {
                name: __2.getName(_this.attrs),
                value: (_this.attrs.ww && _this.attrs.ww.value) ?
                    _this.attrs.ww.value : false,
                checked: function () { return _this.values.input.value ? true : undefined; },
                disabled: __2.getDisabled(_this.attrs),
                onChange: function () {
                    _this.values.input.value = (!_this.values.input.value);
                    if ((_this.attrs.ww && _this.attrs.ww.onChange))
                        _this.attrs.ww.onChange(new SwitchChangedEvent(_this.values.input.name, _this.values.input.value));
                }
            }
        };
        return _this;
    }
    return Switch;
}(__2.AbstractControl));
exports.Switch = Switch;

},{"../":53,"../../":101,"../../util":138,"./wml/switch":71}],71:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('label', { html: { 'id': __context.values.root.id, 'class': __context.values.root.className }, wml: {} }, [
                __this.node('input', { html: { 'type': "checkbox", 'name': __context.values.input.name, 'checked': __context.values.input.checked(), 'disabled': __context.values.input.disabled, 'onchange': __context.values.input.onChange }, wml: {} }, []),
                __this.node('div', { html: { 'class': __context.values.slider.className }, wml: {} }, [])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":141}],72:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/tab-bar");
var wml_1 = require("@quenk/wml");
var active_1 = require("../../content/state/active");
var orientation_1 = require("../../content/orientation");
var util_1 = require("../../util");
var __1 = require("../../");
var __2 = require("../");
///classNames:begin
/**
 * TAB
 */
exports.TAB = 'ww-tab';
/**
 * TAB_BAR
 */
exports.TAB_BAR = 'ww-tab-bar';
/**
 * TabClickedEvent is fired when a user clicks on a tab.
 *
 * It contains information about the tab that was clicked.
 */
var TabClickedEvent = /** @class */ (function (_super) {
    __extends(TabClickedEvent, _super);
    function TabClickedEvent(name) {
        var _this = _super.call(this, name, name) || this;
        _this.name = name;
        return _this;
    }
    return TabClickedEvent;
}(__2.Event));
exports.TabClickedEvent = TabClickedEvent;
/**
 * Tab provides a single tab item.
 *
 * When a tab is clicked, it attempts to remove the active class from
 * it's siblings and apply it to itself. Therefore the sibling of a
 * tab should always be a Tab.
 */
var Tab = /** @class */ (function (_super) {
    __extends(Tab, _super);
    function Tab() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Tab(_this);
        _this.values = {
            root: {
                wml: {
                    id: 'root'
                },
                id: __1.getId(_this.attrs),
                className: util_1.concat(exports.TAB, __1.getClassName(_this.attrs), (_this.attrs.ww && _this.attrs.ww.active) ? active_1.ACTIVE : ''),
            },
            a: {
                wml: {
                    id: 'link'
                },
                content: (_this.attrs.ww && _this.attrs.ww.text) ?
                    [__1.text(_this.attrs.ww.text)] : _this.children,
                clicked: function (e) {
                    e.preventDefault();
                    var maybeRoot = util_1.getById(_this.view, _this.values.root.wml.id);
                    if (maybeRoot.isNothing())
                        return;
                    var root = maybeRoot.get();
                    var parent = root.parentNode;
                    var sibs = parent.children;
                    for (var i = 0; i < sibs.length; i++)
                        sibs[i].classList.remove(active_1.ACTIVE);
                    root.classList.add(active_1.ACTIVE);
                    if (_this.attrs.ww && _this.attrs.ww.onClick)
                        _this.attrs.ww.onClick(new TabClickedEvent("" + _this.attrs.ww.name));
                }
            }
        };
        return _this;
    }
    /**
     * click this Tab
     */
    Tab.prototype.click = function () {
        util_1.getById(this.view, this.values.root.wml.id)
            .map(function (e) { return e.click(); });
        return this;
    };
    return Tab;
}(__2.AbstractControl));
exports.Tab = Tab;
/**
 * TabBar acts as a parent container for a group of Tab.
 *
 * Use it to create a tabbed navigation or view for main layout,
 * sub views or forms etc.
 */
var TabBar = /** @class */ (function (_super) {
    __extends(TabBar, _super);
    function TabBar() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.TabBar(_this);
        _this.values = {
            root: {
                id: __1.getId(_this.attrs),
                className: util_1.concat(exports.TAB_BAR, __1.getClassName(_this.attrs), (_this.attrs.ww && _this.attrs.ww.justify) ? orientation_1.JUSTIFIED : '')
            }
        };
        return _this;
    }
    return TabBar;
}(wml_1.Component));
exports.TabBar = TabBar;

},{"../":53,"../../":101,"../../content/orientation":13,"../../content/state/active":17,"../../util":138,"./wml/tab-bar":73,"@quenk/wml":145}],73:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var TabBar = /** @class */ (function () {
    function TabBar(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('ul', { html: { 'id': __context.values.root.id, 'class': __context.values.root.className }, wml: {} }, __spreadArrays((__context.children)));
        };
    }
    TabBar.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    TabBar.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    TabBar.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    TabBar.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    TabBar.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    TabBar.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    TabBar.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return TabBar;
}());
exports.TabBar = TabBar;
;
var Tab = /** @class */ (function () {
    function Tab(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('li', { html: { 'id': __context.values.root.id, 'class': __context.values.root.className }, wml: { 'id': __context.values.root.wml.id } }, [
                __this.node('a', { html: { 'href': "#", 'onclick': __context.values.a.clicked }, wml: { 'id': __context.values.a.wml.id } }, __spreadArrays((__context.values.a.content)))
            ]);
        };
    }
    Tab.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Tab.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Tab.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Tab.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Tab.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Tab.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Tab.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Tab;
}());
exports.Tab = Tab;

},{"@quenk/noni/lib/data/maybe":141}],74:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var style_1 = require("../../content/style");
var util_1 = require("../../util");
var __1 = require("../../");
var __2 = require("../");
var tag_1 = require("./wml/tag");
///classNames:begin
exports.TAG_CONTROL = 'ww-tag-control';
exports.TAG_CONTROL_TEXT = 'ww-tag-control__text';
exports.TAG_CONTROL_DISMISS = 'ww-tag-control__dismiss';
/**
 * DismissEvent is generated when the close button us clicked.
 */
var DismissEvent = /** @class */ (function (_super) {
    __extends(DismissEvent, _super);
    function DismissEvent(name) {
        var _this = _super.call(this, name, undefined) || this;
        _this.name = name;
        return _this;
    }
    return DismissEvent;
}(__2.Event));
exports.DismissEvent = DismissEvent;
/**
 * Tag displays some text in a dismissable tag.
 *
 * The difference between this Tag and the one from the content
 * module is that this one is primarily meant to be used as a control
 * or as part of a more complicated control.
 */
var Tag = /** @class */ (function (_super) {
    __extends(Tag, _super);
    function Tag() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new tag_1.Main(_this);
        _this.values = {
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.TAG_CONTROL, __1.getClassName(_this.attrs)),
            style: (_this.attrs.ww && _this.attrs.ww.style) ?
                _this.attrs.ww.style : style_1.Style.Default,
            text: {
                className: exports.TAG_CONTROL_TEXT,
                value: (_this.attrs.ww && _this.attrs.ww.text) ?
                    _this.attrs.ww.text : undefined,
            },
            dismiss: {
                className: exports.TAG_CONTROL_DISMISS,
                onClick: function () {
                    if (_this.attrs.ww && _this.attrs.ww.onDismiss)
                        _this.attrs.ww.onDismiss(new DismissEvent(_this.attrs.ww && _this.attrs.ww.name || ''));
                }
            }
        };
        return _this;
    }
    return Tag;
}(__2.AbstractControl));
exports.Tag = Tag;

},{"../":53,"../../":101,"../../content/style":19,"../../util":138,"./wml/tag":75}],75:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var t = require("../../../content/tag");
;
var __1 = require("../../../");
;
var close_1 = require("../../../content/close");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(t.Tag, { html: {}, wml: {}, ww: { 'id': __context.values.id, 'className': __context.values.className, 'style': __context.values.style } }, __spreadArrays((__if((__context.values.text.value !== ""), function () { return ([
                __this.node('span', { html: { 'class': __context.values.text.className }, wml: {} }, [
                    __1.text(__context.values.text.value)
                ])
            ]); }, function () { return ([
                __1.text("")
            ]); })), (__context.children), [
                __this.widget(close_1.Close, { html: {}, wml: {}, ww: { 'class': __context.values.dismiss.className, 'onClick': __context.values.dismiss.onClick } }, [])
            ]));
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../":101,"../../../content/close":3,"../../../content/tag":20,"@quenk/noni/lib/data/maybe":141}],76:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/text-field");
var util_1 = require("../../util");
var feedback_1 = require("../feedback");
var form_1 = require("../form");
var text_input_1 = require("../text-input");
exports.TextChangedEvent = text_input_1.TextChangedEvent;
var __1 = require("../../");
var __2 = require("../");
///classNames:begin
exports.TEXT_FIELD = 'ww-text-field';
/**
 * TextField provides a wrapped native text input control.
 */
var TextField = /** @class */ (function (_super) {
    __extends(TextField, _super);
    function TextField() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: {
                wml: {
                    id: 'root'
                },
                className: util_1.concat(exports.TEXT_FIELD, __1.getClassName(_this.attrs), feedback_1.getValidityClassName(_this.attrs))
            },
            messages: {
                wml: {
                    id: 'message'
                },
                text: feedback_1.getMessage(_this.attrs)
            },
            label: {
                id: __2.getName(_this.attrs),
                text: form_1.getLabel(_this.attrs)
            },
            control: {
                wml: {
                    id: 'control'
                },
                id: __1.getId(_this.attrs),
                name: __2.getName(_this.attrs),
                type: (_this.attrs.ww && _this.attrs.ww.type) ?
                    _this.attrs.ww.type : 'text',
                focus: (_this.attrs.ww && _this.attrs.ww.focus) ?
                    _this.attrs.ww.focus : undefined,
                placeholder: (_this.attrs.ww && _this.attrs.ww.placeholder) ?
                    _this.attrs.ww.placeholder : '',
                value: (_this.attrs.ww && _this.attrs.ww.value) ?
                    _this.attrs.ww.value : '',
                disabled: (_this.attrs.ww && _this.attrs.ww.disabled) ? true : undefined,
                readOnly: (_this.attrs.ww && _this.attrs.ww.readOnly) ?
                    true : undefined,
                rows: (_this.attrs.ww && _this.attrs.ww.rows) ?
                    _this.attrs.ww.rows : 1,
                oninput: (_this.attrs.ww && _this.attrs.ww.onChange) ?
                    oninput(_this) : function () { },
                onChange: (_this.attrs.ww && _this.attrs.ww.onChange) ?
                    _this.attrs.ww.onChange : function () { }
            }
        };
        return _this;
    }
    TextField.prototype.setMessage = function (msg) {
        getHelp(this).map(function (h) { return h.setMessage(msg); });
        return this;
    };
    TextField.prototype.removeMessage = function () {
        getHelp(this).map(function (h) { return h.removeMessage(); });
        return this;
    };
    return TextField;
}(form_1.AbstractFormControl));
exports.TextField = TextField;
var getHelp = function (t) {
    return util_1.getById(t.view, t.values.messages.wml.id);
};
var oninput = function (f) { return function (e) {
    if (f.attrs.ww && f.attrs.ww && f.attrs.ww.onChange)
        f.attrs.ww.onChange(new text_input_1.TextChangedEvent((f.attrs.ww && f.attrs.ww.name) ?
            f.attrs.ww.name : '', e.target.value));
}; };

},{"../":53,"../../":101,"../../util":138,"../feedback":44,"../form":50,"../text-input":78,"./wml/text-field":77}],77:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var label_1 = require("../../label");
;
var help_1 = require("../../help");
;
var text_input_1 = require("../../text-input");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'class': __context.values.root.className }, wml: { 'id': __context.values.root.wml.id } }, [
                __this.widget(label_1.Label, { html: {}, wml: {}, ww: { 'for': __context.values.control.id, 'text': __context.values.label.text } }, []),
                __this.widget(text_input_1.TextInput, { html: {}, wml: {}, ww: { 'id': __context.values.control.id, 'name': __context.values.control.name, 'focus': __context.values.control.focus, 'placeholder': __context.values.control.placeholder, 'onChange': __context.values.control.onChange, 'block': true, 'type': __context.values.control.type, 'value': __context.values.control.value, 'rows': __context.values.control.rows, 'disabled': __context.values.control.disabled, 'readOnly': __context.values.control.readOnly } }, []),
                __this.widget(help_1.Help, { html: {}, wml: { 'id': __context.values.messages.wml.id }, ww: { 'text': __context.values.messages.text } }, [])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../help":51,"../../label":54,"../../text-input":78,"@quenk/noni/lib/data/maybe":141}],78:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/text-input");
var util_1 = require("../../util");
var orientation_1 = require("../../content/orientation");
var size_1 = require("../../content/size");
var focus_1 = require("../focus");
var __1 = require("../../");
var __2 = require("../");
///classNames:begin
exports.TEXT_INPUT = 'ww-text-input';
/**
 * TextChangedEvent
 */
var TextChangedEvent = /** @class */ (function (_super) {
    __extends(TextChangedEvent, _super);
    function TextChangedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return TextChangedEvent;
}(__2.Event));
exports.TextChangedEvent = TextChangedEvent;
/**
 * TextInput provides some extra styling to the native input.
 */
var TextInput = /** @class */ (function (_super) {
    __extends(TextInput, _super);
    function TextInput() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = (_this.attrs.ww && _this.attrs.ww.rows && _this.attrs.ww.rows > 1) ?
            new views.Textarea(_this) : new views.Input(_this);
        _this.values = {
            control: {
                wml: {
                    id: 'root'
                }
            },
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.TEXT_INPUT, __1.getClassName(_this.attrs), (_this.attrs.ww && _this.attrs.ww.size) ?
                size_1.getSizeClassName(_this.attrs.ww.size) : '', (_this.attrs.ww && _this.attrs.ww.block) ?
                orientation_1.BLOCK : ''),
            name: __2.getName(_this.attrs),
            type: (_this.attrs.ww && _this.attrs.ww.type) ?
                _this.attrs.ww.type : 'text',
            placeholder: (_this.attrs.ww && _this.attrs.ww.placeholder) ?
                _this.attrs.ww.placeholder : '',
            value: (_this.attrs.ww && _this.attrs.ww.value) ?
                _this.attrs.ww.value : '',
            rows: (_this.attrs.ww && _this.attrs.ww.rows) ?
                _this.attrs.ww.rows : 1,
            disabled: (_this.attrs.ww && _this.attrs.ww.disabled === true) ?
                true : null,
            readOnly: (_this.attrs.ww && _this.attrs.ww.readOnly === true) ?
                true : null,
            oninput: dispatchInput(_this),
            focus: (_this.attrs.ww && _this.attrs.ww.focus) ? true : undefined,
            onfocus: function () {
                if (_this.attrs.ww && _this.attrs.ww.onFocusGained)
                    _this.attrs.ww.onFocusGained(new focus_1.FocusGainedEvent(__2.getName(_this.attrs)));
            },
            onblur: function () {
                if (_this.attrs.ww && _this.attrs.ww.onFocusLost)
                    _this.attrs.ww.onFocusLost(new focus_1.FocusLostEvent(__2.getName(_this.attrs)));
            }
        };
        return _this;
    }
    TextInput.prototype.focus = function () {
        return focus_1.focus(this.view, this.values.control.wml.id);
    };
    return TextInput;
}(__2.AbstractControl));
exports.TextInput = TextInput;
/**
 * dispatchInput when the user inputs some text.
 */
var dispatchInput = function (i) { return function (e) {
    if (i.attrs.ww && i.attrs.ww.onChange)
        i.attrs.ww.onChange(new TextChangedEvent((i.attrs && i.attrs.ww.name) ?
            i.attrs.ww.name : '', e.target.value));
}; };

},{"../":53,"../../":101,"../../content/orientation":13,"../../content/size":16,"../../util":138,"../focus":49,"./wml/text-input":79}],79:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Textarea = /** @class */ (function () {
    function Textarea(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('textarea', { html: { 'id': __context.values.id, 'name': __context.values.name, 'placeholder': __context.values.placeholder, 'oninput': __context.values.oninput, 'value': __context.values.value, 'disabled': __context.values.disabled, 'readonly': __context.values.readOnly, 'rows': __context.values.rows, 'class': __context.values.className }, wml: { 'id': __context.values.control.wml.id } }, [
                document.createTextNode(__context.values.value)
            ]);
        };
    }
    Textarea.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Textarea.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Textarea.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Textarea.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Textarea.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Textarea.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Textarea.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Textarea;
}());
exports.Textarea = Textarea;
;
var Input = /** @class */ (function () {
    function Input(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('input', { html: { 'id': __context.values.id, 'name': __context.values.name, 'type': __context.values.type, 'placeholder': __context.values.placeholder, 'oninput': __context.values.oninput, 'value': __context.values.value, 'disabled': __context.values.disabled, 'readonly': __context.values.readOnly, 'class': __context.values.className }, wml: { 'id': __context.values.control.wml.id } }, []);
        };
    }
    Input.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Input.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Input.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Input.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Input.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Input.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Input.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Input;
}());
exports.Input = Input;

},{"@quenk/noni/lib/data/maybe":141}],80:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/toolbar");
var wml_1 = require("@quenk/wml");
var util_1 = require("../../util");
var __1 = require("../../");
///classNames:begin
exports.TOOLBAR = 'ww-toolbar';
exports.TOOLBAR_COMPAT = '-toolbar-compat';
/**
 * Toolbar provides a widget for grouping related controls into a
 * single row.
 */
var Toolbar = /** @class */ (function (_super) {
    __extends(Toolbar, _super);
    function Toolbar() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: {
                id: __1.getId(_this.attrs),
                className: util_1.concat(exports.TOOLBAR, __1.getClassName(_this.attrs))
            }
        };
        return _this;
    }
    return Toolbar;
}(wml_1.Component));
exports.Toolbar = Toolbar;

},{"../../":101,"../../util":138,"./wml/toolbar":81,"@quenk/wml":145}],81:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'id': __context.values.root.id, 'class': __context.values.root.className }, wml: {} }, __spreadArrays((__context.children)));
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":141}],82:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/typeahead");
var util_1 = require("../../util");
var form_1 = require("../form");
var search_1 = require("../search");
exports.TermChangedEvent = search_1.TermChangedEvent;
var text_field_1 = require("../text-field");
exports.TextChangedEvent = text_field_1.TextChangedEvent;
var select_1 = require("../select");
exports.ItemSelectedEvent = select_1.ItemSelectedEvent;
///classNames:begin
exports.TYPEAHEAD = 'ww-typeahead';
/**
 * Typeahead provides an text input field that can suggests values
 * as the user types.
 */
var Typeahead = /** @class */ (function (_super) {
    __extends(Typeahead, _super);
    function Typeahead() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: new select_1.RootSection(_this.attrs),
            control: new select_1.ControlSection(),
            messages: new select_1.MessagesSection(_this.attrs),
            label: new select_1.LabelSection(_this.attrs),
            search: new select_1.SearchSection(_this.attrs, function () { return _this.close(); }, function (e) {
                _this.close();
                var mSearch = util_1.getById(_this.view, _this.values.search.wml.id);
                if (mSearch.isJust()) {
                    var s = mSearch.get();
                    var str = (_this.values.search.stringifier) ?
                        _this.values.search.stringifier(e.value) : e.value + '';
                    s.set(str);
                    if (_this.attrs.ww && _this.attrs.ww.onChange)
                        _this.attrs.ww.onChange(new text_field_1.TextChangedEvent('' + _this.attrs.ww.name, str));
                }
            })
        };
        return _this;
    }
    Typeahead.prototype.open = function () {
        select_1.open(this.view, this.values.search.wml.id);
        return this;
    };
    Typeahead.prototype.close = function () {
        select_1.close(this.view, this.values.search.wml.id);
        return this;
    };
    Typeahead.prototype.setMessage = function (msg) {
        this.values.messages.text = msg;
        form_1.setMessage(this.view, this.values.messages.wml.id, msg);
        return this;
    };
    Typeahead.prototype.removeMessage = function () {
        this.values.messages.text = '';
        form_1.removeMessage(this.view, this.values.messages.wml.id);
        return this;
    };
    Typeahead.prototype.update = function (results) {
        select_1.update(this.view, this.values.search.wml.id, results);
        return this;
    };
    return Typeahead;
}(form_1.AbstractFormControl));
exports.Typeahead = Typeahead;

},{"../../util":138,"../form":50,"../search":62,"../select":64,"../text-field":76,"./wml/typeahead":83}],83:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var search_1 = require("../../search");
;
var label_1 = require("../../label");
;
var help_1 = require("../../help");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'id': __context.values.root.id, 'class': __context.values.root.className }, wml: {} }, [
                __this.widget(label_1.Label, { html: {}, wml: {}, ww: { 'for': __context.values.root.id, 'text': __context.values.label.text } }, []),
                __this.widget(search_1.Search, { html: {}, wml: { 'id': __context.values.search.wml.id }, ww: { 'name': __context.values.search.name, 'className': __context.values.search.className, 'block': __context.values.search.block, 'placeholder': __context.values.search.placeholder, 'readOnly': __context.values.search.readOnly, 'itemTemplate': __context.values.search.itemTemplate, 'noItemsTemplate': __context.values.search.noItemsTemplate, 'stringifier': __context.values.search.stringifier, 'onSearch': __context.values.search.onSearch, 'onSelect': __context.values.search.onSelect } }, []),
                __this.widget(help_1.Help, { html: {}, wml: { 'id': __context.values.messages.wml.id }, ww: { 'text': __context.values.messages.text } }, [])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../help":51,"../../label":54,"../../search":62,"@quenk/noni/lib/data/maybe":141}],84:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml_1 = require("@quenk/wml");
var path_1 = require("@quenk/noni/lib/data/record/path");
var util_1 = require("../../util");
var __1 = require("../../");
var property_list_1 = require("./wml/property-list");
///classNames:begin
exports.PROPERTY_LIST = 'ww-property-list';
/**
 * PropertyList generates a description list using the properties of
 * an object.
 */
var PropertyList = /** @class */ (function (_super) {
    __extends(PropertyList, _super);
    function PropertyList() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new property_list_1.Main(_this);
        _this.values = {
            root: {
                className: util_1.concat(exports.PROPERTY_LIST, __1.getClassName(_this.attrs))
            },
            fields: ((_this.attrs.ww && _this.attrs.ww.fields) ?
                _this.attrs.ww.fields : []),
            data: {
                value: ((_this.attrs.ww && _this.attrs.ww.data) ?
                    _this.attrs.ww.data : {}),
                get: function (f) {
                    var mData = path_1.get(f.name, _this.values.data.value);
                    if (mData.isNothing())
                        return [__1.text('-')];
                    var d = mData.get();
                    if (f.dataFragment)
                        return f.dataFragment(d, f.name, _this.values.data.value)(_this.view);
                    if (f.format)
                        return [__1.text('' + f.format(d))];
                    return [__1.text('' + d)];
                }
            }
        };
        return _this;
    }
    /**
     * setData to be displayed.
     */
    PropertyList.prototype.setData = function (data) {
        this.values.data.value = data;
        this.view.invalidate();
        return this;
    };
    return PropertyList;
}(wml_1.Component));
exports.PropertyList = PropertyList;

},{"../../":101,"../../util":138,"./wml/property-list":85,"@quenk/noni/lib/data/record/path":143,"@quenk/wml":145}],85:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
;
var __1 = require("../../../");
;
var description_list_1 = require("../../../layout/description-list");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(description_list_1.DescriptionList, { html: {}, wml: {}, ww: { 'className': __context.values.root.className } }, __spreadArrays(__forIn(__context.values.fields, function (field, _$$i, _$$all) {
                return ([
                    __this.widget(description_list_1.Title, { html: {}, wml: {} }, [
                        __1.text(field.heading)
                    ]),
                    __this.widget(description_list_1.Data, { html: {}, wml: {} }, __spreadArrays((__context.values.data.get(field))))
                ]);
            }, function () { return ([]); })));
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../":101,"../../../layout/description-list":106,"@quenk/noni/lib/data/maybe":141}],86:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var path_1 = require("@quenk/noni/lib/data/record/path");
var sort_1 = require("@quenk/noni/lib/data/array/sort");
/**
 * SortRequest contains the info needed to preform a sort.
 */
var SortRequest = /** @class */ (function () {
    function SortRequest(column, data, key) {
        this.column = column;
        this.data = data;
        this.key = key;
    }
    return SortRequest;
}());
exports.SortRequest = SortRequest;
/**
 * sortById sorts a dataset by a column using the columns id.
 *
 * Data is only sorted by one column at a time.
 */
exports.sortById = function (cols, key, data, id) {
    var spec = cols[id];
    var current = data[0], original = data[1];
    if (spec === undefined)
        return [current, key];
    if (!spec.sort)
        return [current, key];
    if (key[0] === id) {
        return [current.reverse(), [key[0], key[1] * -1]];
    }
    else {
        var strategy = getSortStrategy(spec.sort);
        var alias = spec.alias ? spec.alias : spec.name;
        return [doSort(original.slice(), strategy, alias), [id, -1]];
    }
};
var getSortStrategy = function (s) {
    if (typeof s === 'function')
        return s;
    if (s === 'date')
        return sort_1.date;
    if (s === 'number')
        return sort_1.number;
    if (s === 'string')
        return sort_1.string;
    return sort_1.natural;
};
var doSort = function (data, s, alias) {
    return data.sort(function (a, b) { return s(getAny(alias, a), getAny(alias, b)); });
};
var getAny = function (path, src) {
    return path_1.getDefault(path, src, undefined);
};

},{"@quenk/noni/lib/data/array/sort":140,"@quenk/noni/lib/data/record/path":143}],87:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * HeadingClickedEvent is triggered when the user clicks on
 * one of the column headings.
 */
var HeadingClickedEvent = /** @class */ (function () {
    function HeadingClickedEvent(column) {
        this.column = column;
    }
    return HeadingClickedEvent;
}());
exports.HeadingClickedEvent = HeadingClickedEvent;
/**
 * CellClickedEvent triggered when a cell is clicked on.
 */
var CellClickedEvent = /** @class */ (function () {
    function CellClickedEvent(column, row) {
        this.column = column;
        this.row = row;
    }
    return CellClickedEvent;
}());
exports.CellClickedEvent = CellClickedEvent;
/**
 * DataChangedEvent generated when the internal representation of the data
 * changes.
 */
var DataChangedEvent = /** @class */ (function () {
    function DataChangedEvent(data, key) {
        this.data = data;
        this.key = key;
    }
    return DataChangedEvent;
}());
exports.DataChangedEvent = DataChangedEvent;

},{}],88:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/table");
var wml_1 = require("@quenk/wml");
var array_1 = require("@quenk/noni/lib/data/array");
var path_1 = require("@quenk/noni/lib/data/record/path");
var util_1 = require("../../util");
var __1 = require("../../");
var sort_1 = require("./column/sort");
exports.SortRequest = sort_1.SortRequest;
var event_1 = require("./event");
exports.DataChangedEvent = event_1.DataChangedEvent;
exports.CellClickedEvent = event_1.CellClickedEvent;
exports.HeadingClickedEvent = event_1.HeadingClickedEvent;
var range_1 = require("./range");
///classNames:begin
exports.DATA_TABLE = 'ww-data-table';
exports.DATA_TABLE_HEAD = 'ww-data-table__head';
exports.DATA_TABLE_HEADING = 'ww-data-table__heading';
exports.DATA_TABLE_BODY = 'ww-data-table__body';
exports.DATA_TABLE_CELL = 'ww-data-table__cell';
exports.ASC = '-asc';
exports.DESC = '-desc';
/**
 * NewHeadContext
 */
var NewHeadContext = /** @class */ (function () {
    function NewHeadContext(table) {
        var _this = this;
        this.table = table;
        this.className = util_1.concat(exports.DATA_TABLE_HEAD, (this.table.attrs.ww && this.table.attrs.ww.headClassName || ''));
        this.columns = this.table.values.columns;
        this.data = this.table.values.dataset[0];
        this.heading = function (c) { return function (i) {
            return getHeadingView(_this.table, new NewHeadingContext(_this.table, _this, c, i), c).render();
        }; };
    }
    return NewHeadContext;
}());
exports.NewHeadContext = NewHeadContext;
/**
 * NewHeadingContext
 */
var NewHeadingContext = /** @class */ (function () {
    function NewHeadingContext(table, headContext, column, index) {
        var _this = this;
        this.table = table;
        this.headContext = headContext;
        this.column = column;
        this.index = index;
        this.className = util_1.concat(exports.DATA_TABLE_HEADING, (this.table.attrs.ww && this.table.attrs.ww.headingClassName || ''), this.column.headingClassName, getSortClassName(this.table.values.sortKey, this.index));
        this.onclick = function (_) {
            if (_this.column.sort)
                _this.table.values.sort(_this.index);
            if (_this.column.onHeadingClicked)
                _this.column.onHeadingClicked(new event_1.HeadingClickedEvent(_this.index));
            if (_this.table.attrs.ww && _this.table.attrs.ww.onHeadingClicked)
                _this.table.attrs.ww.onHeadingClicked(new event_1.HeadingClickedEvent(_this.index));
        };
    }
    return NewHeadingContext;
}());
exports.NewHeadingContext = NewHeadingContext;
/**
 * NewBodyContext
 */
var NewBodyContext = /** @class */ (function () {
    function NewBodyContext(table) {
        var _this = this;
        this.table = table;
        this.className = util_1.concat(exports.DATA_TABLE_BODY, (this.table.attrs.ww && this.table.attrs.ww.bodyClassName || ''));
        this.columns = this.table.values.columns;
        this.data = this.table.values.dataset[0];
        this.cell = function (c) { return function (id) { return function (row) {
            return getCellView(_this.table, new NewCellContext(_this.table, _this, c, id, row), c).render();
        }; }; };
    }
    return NewBodyContext;
}());
exports.NewBodyContext = NewBodyContext;
/**
 * NewCellContext
 */
var NewCellContext = /** @class */ (function () {
    function NewCellContext(table, bodyContext, spec, column, row) {
        var _this = this;
        this.table = table;
        this.bodyContext = bodyContext;
        this.spec = spec;
        this.column = column;
        this.row = row;
        this.id = cellId(this.column, this.row);
        this.className = util_1.concat(exports.DATA_TABLE_CELL, (this.table.attrs.ww && this.table.attrs.ww.cellClassName || ''), this.spec.cellClassName, getSortClassName(this.table.values.sortKey, this.column));
        this.value = path_1.unsafeGet(this.spec.name, this.table.values.dataset[0][this.row]);
        this.datum = this.table.values.dataset[0][this.row];
        this.format = this.spec.format ? this.spec.format : function (c) { return String(c); };
        this.onclick = function () {
            if (_this.spec.onCellClicked)
                _this.spec.onCellClicked(new event_1.CellClickedEvent(_this.column, _this.row));
            if (_this.table.attrs.ww && _this.table.attrs.ww.onCellClicked)
                _this.table.attrs.ww.onCellClicked(new event_1.CellClickedEvent(_this.column, _this.row));
        };
    }
    return NewCellContext;
}());
exports.NewCellContext = NewCellContext;
/**
 * DataTable can be used for displaying sortable
 * tabular data.
 */
var DataTable = /** @class */ (function (_super) {
    __extends(DataTable, _super);
    function DataTable() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.theadView = new views.EmptyView({});
        _this.tbodyView = new views.EmptyView({});
        _this.values = {
            wml: { id: 'table' },
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.DATA_TABLE, __1.getClassName(_this.attrs)),
            sortable: (_this.attrs.ww && (_this.attrs.ww.sortable != null)) ?
                _this.attrs.ww.sortable : true,
            sortKey: ((_this.attrs.ww && _this.attrs.ww.sortKey) ?
                _this.attrs.ww.sortKey : [-1, 1]),
            sort: function (col) {
                if (_this.values.sortable) {
                    if (_this.attrs.ww && _this.attrs.ww.sortDelegate)
                        _this.attrs.ww.sortDelegate(new sort_1.SortRequest(col, _this.values.dataset[1], _this.values.sortKey));
                    else
                        _this.sort(col);
                }
            },
            dataset: ((_this.attrs.ww && _this.attrs.ww.data) ?
                [_this.attrs.ww.data.slice(), _this.attrs.ww.data.slice()] :
                [[], []]),
            columns: (_this.attrs.ww && _this.attrs.ww.columns) ?
                _this.attrs.ww.columns : [],
            thead: function () {
                _this.theadView = getHeadView(_this, new NewHeadContext(_this));
                return _this.theadView.render();
            },
            tbody: function () {
                _this.tbodyView = getBodyView(_this, new NewBodyContext(_this));
                return _this.tbodyView.render();
            }
        };
        return _this;
    }
    /**
     * @private
     */
    DataTable.prototype.fireChange = function () {
        if (this.attrs.ww && this.attrs.ww.onChange)
            this.attrs.ww.onChange(new event_1.DataChangedEvent(this.values.dataset[0].slice(), this.values.sortKey.slice()));
    };
    /**
     * update the data displayed with a new data.
     */
    DataTable.prototype.update = function (data) {
        this.values.dataset = [data.slice(), data.slice()];
        this.view.invalidate();
        this.fireChange();
        return this;
    };
    /**
     * updateWithSortKey is like update but will set the sort key as well.
     */
    DataTable.prototype.updateWithSortKey = function (data, key) {
        this.values.dataset = [data.slice(), data.slice()];
        this.values.sortKey = key;
        this.view.invalidate();
        this.fireChange();
        return this;
    };
    /**
     * sort the table data by the column id specified.
     *
     * The data can only be sorted by one column at a time and that column
     * must specify the "sort" key.
     *
     * This method causes a repaint.
     */
    DataTable.prototype.sort = function (id) {
        var _a = this.values, columns = _a.columns, sortKey = _a.sortKey, dataset = _a.dataset;
        var _b = sort_1.sortById(columns, sortKey, dataset, id), data = _b[0], key = _b[1];
        this.values.dataset[0] = data;
        this.values.sortKey = key;
        this.view.invalidate();
        this.fireChange();
        return this;
    };
    /**
     * getRow returns a Range of HTMLTableCellElements for the row
     * that matches the provided id.
     *
     * If no rows are found by that id, the Range will be empty.
     * In order for this method to work the body view MUST include
     * the wml:id on each <tr> element that represents a row of data.
     */
    DataTable.prototype.getRow = function (row) {
        var mTr = util_1.getById(this.tbodyView, "" + row);
        if (mTr.isNothing())
            return new range_1.RangeInstance([]);
        var tr = mTr.get();
        return new range_1.RangeInstance(array_1.make(tr.cells.length, function (n) { return tr.cells[n]; }));
    };
    /**
     * getCell provides a Range containing a cell located at the
     * intersection of the column and row.
     */
    DataTable.prototype.getCell = function (column, row) {
        var cells = this.getRow(row).cells;
        if (!cells[column])
            return new range_1.RangeInstance([]);
        return new range_1.RangeInstance([cells[column]]);
    };
    return DataTable;
}(wml_1.Component));
exports.DataTable = DataTable;
var getHeadView = function (table, ctx) {
    return (table.attrs.ww && table.attrs.ww.headFragment) ?
        table.attrs.ww.headFragment(ctx) : new views.HeadView(ctx);
};
var getHeadingView = function (table, ctx, c) {
    return c.headingFragment ? c.headingFragment(ctx) :
        (table.attrs.ww && table.attrs.ww.headingFragment) ?
            table.attrs.ww.headingFragment(ctx) : new views.HeadingView(ctx);
};
var getBodyView = function (table, ctx) {
    return (table.attrs.ww && table.attrs.ww.bodyFragment) ?
        table.attrs.ww.bodyFragment(ctx) :
        new views.BodyView(ctx);
};
var getCellView = function (table, ctx, c) {
    return c.cellFragment ? c.cellFragment(ctx) :
        (table.attrs.ww && table.attrs.ww.cellFragment) ?
            table.attrs.ww.cellFragment(ctx) :
            new views.CellView(ctx);
};
var getSortClassName = function (key, index) {
    return (key[0] === index) ? (key[1] === 1) ? exports.ASC : exports.DESC : '';
};
var cellId = function (column, row) { return column + "," + row; };

},{"../../":101,"../../util":138,"./column/sort":86,"./event":87,"./range":89,"./wml/table":90,"@quenk/noni/lib/data/array":139,"@quenk/noni/lib/data/record/path":143,"@quenk/wml":145}],89:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * RangeInstance
 */
var RangeInstance = /** @class */ (function () {
    function RangeInstance(cells) {
        this.cells = cells;
    }
    return RangeInstance;
}());
exports.RangeInstance = RangeInstance;

},{}],90:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
;
var table_1 = require("../../../layout/table");
;
var __1 = require("../../../");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var EmptyView = /** @class */ (function () {
    function EmptyView(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: {}, wml: {} }, []);
        };
    }
    EmptyView.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    EmptyView.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    EmptyView.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    EmptyView.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    EmptyView.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    EmptyView.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    EmptyView.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return EmptyView;
}());
exports.EmptyView = EmptyView;
;
var HeadView = /** @class */ (function () {
    function HeadView(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('thead', { html: { 'class': __context.className }, wml: {} }, [
                __this.node('tr', { html: {}, wml: {} }, __spreadArrays(__forIn(__context.columns, function (col, idx, _$$all) {
                    return ([
                        __context.heading(col)(idx)
                    ]);
                }, function () { return ([]); })))
            ]);
        };
    }
    HeadView.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    HeadView.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    HeadView.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    HeadView.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    HeadView.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    HeadView.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    HeadView.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return HeadView;
}());
exports.HeadView = HeadView;
;
var HeadingView = /** @class */ (function () {
    function HeadingView(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('th', { html: { 'class': __context.className, 'onclick': __context.onclick }, wml: {} }, [
                __1.text(__context.column.heading)
            ]);
        };
    }
    HeadingView.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    HeadingView.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    HeadingView.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    HeadingView.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    HeadingView.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    HeadingView.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    HeadingView.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return HeadingView;
}());
exports.HeadingView = HeadingView;
;
var BodyView = /** @class */ (function () {
    function BodyView(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('tbody', { html: { 'class': __context.className }, wml: {} }, __spreadArrays(__forIn(__context.data, function (_, row, _$$all) {
                return ([
                    __this.node('tr', { html: {}, wml: { 'id': String(row) } }, __spreadArrays(__forIn(__context.columns, function (col, idx, _$$all) {
                        return ([
                            __context.cell(col)(idx)(row)
                        ]);
                    }, function () { return ([]); })))
                ]);
            }, function () { return ([]); })));
        };
    }
    BodyView.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    BodyView.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    BodyView.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    BodyView.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    BodyView.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    BodyView.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    BodyView.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return BodyView;
}());
exports.BodyView = BodyView;
;
var CellView = /** @class */ (function () {
    function CellView(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('td', { html: { 'class': __context.className, 'onclick': __context.onclick }, wml: { 'id': __context.id } }, [
                __1.text(__context.format(__context.value))
            ]);
        };
    }
    CellView.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    CellView.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    CellView.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    CellView.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    CellView.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    CellView.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    CellView.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return CellView;
}());
exports.CellView = CellView;
;
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(table_1.TableLayout, { html: {}, wml: { 'id': __context.values.wml.id }, ww: { 'id': __context.values.id, 'className': __context.values.className } }, [
                __context.values.thead(),
                __context.values.tbody()
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../":101,"../../../layout/table":125,"@quenk/noni/lib/data/maybe":141}],91:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml_1 = require("@quenk/wml");
var style_1 = require("../../content/style");
exports.Style = style_1.Style;
var util_1 = require("../../util");
var __1 = require("../../");
var alert_1 = require("./wml/alert");
///classNames:begin
exports.ALERT = 'ww-alert';
/**
 * Alert is used for displaying important messages to users.
 */
var Alert = /** @class */ (function (_super) {
    __extends(Alert, _super);
    function Alert() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new alert_1.Main(_this);
        _this.values = {
            wml: {
                id: 'alert'
            },
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.ALERT, __1.getClassName(_this.attrs), (_this.attrs.ww && _this.attrs.ww.style) ?
                style_1.getStyleClassName(_this.attrs.ww.style) :
                style_1.DEFAULT),
            closable: (_this.attrs.ww && _this.attrs.ww.closable) ?
                _this.attrs.ww.closable : false,
            content: (_this.attrs.ww && _this.attrs.ww.text) ?
                [__1.text(_this.attrs.ww.text)] : _this.children
        };
        return _this;
    }
    /**
     * close the alert.
     */
    Alert.prototype.close = function () {
        var mRoot = util_1.getById(this.view, this.values.wml.id);
        if (mRoot.isJust()) {
            var root = mRoot.get();
            if (root.parentNode)
                root.parentNode.removeChild(root);
        }
    };
    return Alert;
}(wml_1.Component));
exports.Alert = Alert;

},{"../../":101,"../../content/style":19,"../../util":138,"./wml/alert":92,"@quenk/wml":145}],92:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var close_1 = require("../../../content/close");
;
var __1 = require("../../../");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'id': __context.values.id, 'class': __context.values.className }, wml: { 'id': __context.values.wml.id } }, __spreadArrays((__context.values.content), (__if(__context.values.closable, function () { return ([
                __this.widget(close_1.Close, { html: {}, wml: {}, ww: { 'onClick': function () { return __context.close(); } } }, [])
            ]); }, function () { return ([
                __1.text("")
            ]); }))));
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../":101,"../../../content/close":3,"@quenk/noni/lib/data/maybe":141}],93:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml_1 = require("@quenk/wml");
var util_1 = require("../../util");
var __1 = require("../../");
var prompt_1 = require("../prompt");
var confirm_1 = require("./wml/confirm");
///classNames:begin
exports.CONFIRM = 'ww-confirm';
exports.CONFIRM_NO = 'ww-confirm__no';
exports.CONFIRM_YES = 'ww-prompt__yes';
///classNames:end
/**
 * Primary indicates whether the yes or no button should be highlighted.
 */
var Primary;
(function (Primary) {
    Primary["No"] = "no";
    Primary["Yes"] = "yes";
})(Primary = exports.Primary || (exports.Primary = {}));
/**
 * Confirm displays a dialog for confirming an action.
 */
var Confirm = /** @class */ (function (_super) {
    __extends(Confirm, _super);
    function Confirm() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new confirm_1.Main(_this);
        _this.values = {
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.CONFIRM, __1.getClassName(_this.attrs)),
            wml: {
                id: 'modal'
            },
            header: {
                title: (_this.attrs.ww && _this.attrs.ww.title) ?
                    _this.attrs.ww.title : ''
            },
            footer: {
                no: {
                    text: (_this.attrs.ww && _this.attrs.ww.noText) ?
                        _this.attrs.ww.noText : 'No',
                    className: util_1.concat(exports.CONFIRM_NO, (_this.attrs.ww &&
                        _this.attrs.ww.primary &&
                        _this.attrs.ww.primary === Primary.No) ? '-primary' : ''),
                    onClick: function () {
                        if (_this.attrs.ww && _this.attrs.ww.onNo)
                            _this.attrs.ww.onNo();
                        _this.close();
                    }
                },
                yes: {
                    text: (_this.attrs.ww && _this.attrs.ww.yesText) ?
                        _this.attrs.ww.yesText : 'Yes',
                    wml: {
                        id: 'yes'
                    },
                    className: util_1.concat(exports.CONFIRM_YES, (_this.attrs.ww &&
                        _this.attrs.ww.primary &&
                        _this.attrs.ww.primary === Primary.No) ? '' : '-primary'),
                    onClick: function () {
                        if (_this.attrs.ww && _this.attrs.ww.onYes)
                            _this.attrs.ww.onYes();
                        _this.close();
                    }
                }
            }
        };
        return _this;
    }
    Confirm.prototype.close = function () {
        prompt_1.close(this.view, this.values.wml.id);
        return this;
    };
    return Confirm;
}(wml_1.Component));
exports.Confirm = Confirm;

},{"../../":101,"../../util":138,"../prompt":99,"./wml/confirm":94,"@quenk/wml":145}],94:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var button_1 = require("../../../control/button");
;
var close_button_1 = require("../../../control/close-button");
;
var __1 = require("../../../");
;
var modal_1 = require("../../modal");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(modal_1.Modal, { html: {}, wml: { 'id': __context.values.wml.id }, ww: { 'className': __context.values.className } }, [
                __this.widget(modal_1.ModalHeader, { html: {}, wml: {} }, [
                    __this.widget(close_button_1.CloseButton, { html: {}, wml: {}, ww: { 'onClick': __context.values.footer.no.onClick } }, []),
                    __1.text(__context.values.header.title)
                ]),
                __this.widget(modal_1.ModalBody, { html: {}, wml: {} }, __spreadArrays((__context.children))),
                __this.widget(modal_1.ModalFooter, { html: {}, wml: {} }, [
                    __this.widget(button_1.Button, { html: {}, wml: {}, ww: { 'text': __context.values.footer.no.text, 'className': __context.values.footer.no.className, 'onClick': __context.values.footer.no.onClick } }, []),
                    __this.widget(button_1.Button, { html: {}, wml: {}, ww: { 'text': __context.values.footer.yes.text, 'className': __context.values.footer.yes.className, 'onClick': __context.values.footer.yes.onClick } }, [])
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../":101,"../../../control/button":28,"../../../control/close-button":32,"../../modal":97,"@quenk/noni/lib/data/maybe":141}],95:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml_1 = require("@quenk/wml");
var util_1 = require("../../util");
var __1 = require("../../");
var prompt_1 = require("../prompt");
var inform_1 = require("./wml/inform");
///classNames:begin
exports.INFORM = 'ww-inform';
exports.INFORM_OK = 'ww-inform__ok';
/**
 * Inform displays a message to the user.
 */
var Inform = /** @class */ (function (_super) {
    __extends(Inform, _super);
    function Inform() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new inform_1.Main(_this);
        _this.values = {
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.INFORM, __1.getClassName(_this.attrs)),
            wml: {
                id: 'modal'
            },
            header: {
                title: (_this.attrs.ww && _this.attrs.ww.title) ?
                    _this.attrs.ww.title : ''
            },
            footer: {
                ok: {
                    text: (_this.attrs.ww && _this.attrs.ww.buttonText) ?
                        _this.attrs.ww.buttonText : 'Ok',
                    wml: {
                        id: 'ok'
                    },
                    className: util_1.concat(exports.INFORM_OK, '-primary'),
                    onClick: function () {
                        if (_this.attrs.ww && _this.attrs.ww.onClose)
                            _this.attrs.ww.onClose();
                        _this.close();
                    }
                }
            }
        };
        return _this;
    }
    Inform.prototype.close = function () {
        prompt_1.close(this.view, this.values.wml.id);
        return this;
    };
    return Inform;
}(wml_1.Component));
exports.Inform = Inform;

},{"../../":101,"../../util":138,"../prompt":99,"./wml/inform":96,"@quenk/wml":145}],96:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var button_1 = require("../../../control/button");
;
var close_button_1 = require("../../../control/close-button");
;
var __1 = require("../../../");
;
var modal_1 = require("../../modal");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(modal_1.Modal, { html: {}, wml: { 'id': __context.values.wml.id }, ww: { 'className': __context.values.className } }, [
                __this.widget(modal_1.ModalHeader, { html: {}, wml: {} }, [
                    __this.widget(close_button_1.CloseButton, { html: {}, wml: {}, ww: { 'onClick': __context.values.footer.ok.onClick } }, []),
                    __1.text(__context.values.header.title)
                ]),
                __this.widget(modal_1.ModalBody, { html: {}, wml: {} }, __spreadArrays((__context.children))),
                __this.widget(modal_1.ModalFooter, { html: {}, wml: {} }, [
                    __this.widget(button_1.Button, { html: {}, wml: {}, ww: { 'text': __context.values.footer.ok.text, 'className': __context.values.footer.ok.className, 'onClick': __context.values.footer.ok.onClick } }, [])
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../":101,"../../../control/button":28,"../../../control/close-button":32,"../../modal":97,"@quenk/noni/lib/data/maybe":141}],97:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/modal");
var wml_1 = require("@quenk/wml");
var util_1 = require("../../util");
var __1 = require("../../");
///classNames:begin
exports.MODAL = 'ww-modal';
exports.MODAL_POSITION = 'ww-modal__position';
exports.MODAL_CONTENT = 'ww-modal__content';
exports.MODAL_HEADER = 'ww-modal__header';
exports.MODAL_BODY = 'ww-modal__body';
exports.MODAL_FOOTER = 'ww-modal__footer';
/**
 * Modal
 */
var Modal = /** @class */ (function (_super) {
    __extends(Modal, _super);
    function Modal() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Modal(_this);
        _this.values = {
            wml: {
                id: 'root'
            },
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.MODAL, __1.getClassName(_this.attrs)),
            content: {
                className: exports.MODAL_CONTENT
            },
            position: {
                className: exports.MODAL_POSITION
            }
        };
        return _this;
    }
    /**
     * close the modal.
     */
    Modal.prototype.close = function () {
        var mO = util_1.getById(this.view, this.values.wml.id);
        if (mO.isJust()) {
            var n = mO.get();
            if (n.parentNode)
                n.parentNode.removeChild(n);
        }
    };
    return Modal;
}(wml_1.Component));
exports.Modal = Modal;
/**
 * ModalHeader
 */
var ModalHeader = /** @class */ (function (_super) {
    __extends(ModalHeader, _super);
    function ModalHeader() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.ModalHeader(_this);
        _this.values = {
            wml: {
                id: 'root'
            },
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.MODAL_HEADER, __1.getClassName(_this.attrs)),
        };
        return _this;
    }
    return ModalHeader;
}(wml_1.Component));
exports.ModalHeader = ModalHeader;
/**
 * ModalBodyAttrs
 */
var ModalBody = /** @class */ (function (_super) {
    __extends(ModalBody, _super);
    function ModalBody() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.ModalBody(_this);
        _this.values = {
            wml: {
                id: 'root'
            },
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.MODAL_BODY, __1.getClassName(_this.attrs)),
        };
        return _this;
    }
    return ModalBody;
}(wml_1.Component));
exports.ModalBody = ModalBody;
/**
 * ModalFooter
 */
var ModalFooter = /** @class */ (function (_super) {
    __extends(ModalFooter, _super);
    function ModalFooter() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.ModalFooter(_this);
        _this.values = {
            wml: {
                id: 'root'
            },
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.MODAL_FOOTER, __1.getClassName(_this.attrs)),
        };
        return _this;
    }
    return ModalFooter;
}(wml_1.Component));
exports.ModalFooter = ModalFooter;

},{"../../":101,"../../util":138,"./wml/modal":98,"@quenk/wml":145}],98:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Modal = /** @class */ (function () {
    function Modal(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'id': __context.values.id, 'class': __context.values.className }, wml: { 'id': __context.values.wml.id } }, [
                __this.node('div', { html: { 'class': __context.values.position.className }, wml: {} }, [
                    __this.node('div', { html: { 'class': __context.values.content.className }, wml: {} }, __spreadArrays((__context.children)))
                ])
            ]);
        };
    }
    Modal.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Modal.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Modal.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Modal.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Modal.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Modal.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Modal.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Modal;
}());
exports.Modal = Modal;
;
var ModalHeader = /** @class */ (function () {
    function ModalHeader(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'id': __context.values.id, 'class': __context.values.className }, wml: { 'id': __context.values.wml.id } }, __spreadArrays((__context.children)));
        };
    }
    ModalHeader.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    ModalHeader.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    ModalHeader.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    ModalHeader.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    ModalHeader.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    ModalHeader.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    ModalHeader.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return ModalHeader;
}());
exports.ModalHeader = ModalHeader;
;
var ModalBody = /** @class */ (function () {
    function ModalBody(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'id': __context.values.id, 'class': __context.values.className }, wml: { 'id': __context.values.wml.id } }, __spreadArrays((__context.children)));
        };
    }
    ModalBody.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    ModalBody.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    ModalBody.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    ModalBody.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    ModalBody.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    ModalBody.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    ModalBody.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return ModalBody;
}());
exports.ModalBody = ModalBody;
;
var ModalFooter = /** @class */ (function () {
    function ModalFooter(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'id': __context.values.id, 'class': __context.values.className }, wml: { 'id': __context.values.wml.id } }, __spreadArrays((__context.children)));
        };
    }
    ModalFooter.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    ModalFooter.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    ModalFooter.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    ModalFooter.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    ModalFooter.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    ModalFooter.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    ModalFooter.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return ModalFooter;
}());
exports.ModalFooter = ModalFooter;

},{"@quenk/noni/lib/data/maybe":141}],99:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml_1 = require("@quenk/wml");
var util_1 = require("../../util");
var __1 = require("../../");
var prompt_1 = require("./wml/prompt");
///classNames:begin
exports.PROMPT = 'ww-prompt';
exports.PROMPT_CLOSE = 'ww-prompt__close';
exports.PROMPT_SAVE = 'ww-prompt__save';
/**
 * Prompt displays a dialog to the user suitable for collecting data
 * input.
 */
var Prompt = /** @class */ (function (_super) {
    __extends(Prompt, _super);
    function Prompt() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new prompt_1.Main(_this);
        _this.values = {
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.PROMPT, __1.getClassName(_this.attrs)),
            wml: {
                id: 'modal'
            },
            header: {
                title: (_this.attrs.ww && _this.attrs.ww.title) ?
                    _this.attrs.ww.title : ''
            },
            footer: {
                close: {
                    text: (_this.attrs.ww && _this.attrs.ww.closeText) ?
                        _this.attrs.ww.closeText : 'Close',
                    className: exports.PROMPT_CLOSE,
                    onClick: function () {
                        if (_this.attrs.ww && _this.attrs.ww.onCancel)
                            _this.attrs.ww.onCancel();
                        _this.close();
                    }
                },
                save: {
                    text: (_this.attrs.ww && _this.attrs.ww.saveText) ?
                        _this.attrs.ww.saveText : 'Save',
                    wml: {
                        id: 'save'
                    },
                    className: util_1.concat('-primary', exports.PROMPT_SAVE),
                    disabled: (_this.attrs.ww && _this.attrs.ww.disabled) ?
                        true : false,
                    onClick: function () {
                        if (_this.attrs.ww && _this.attrs.ww.onSave)
                            _this.attrs.ww.onSave();
                        _this.close();
                    }
                }
            }
        };
        return _this;
    }
    Prompt.prototype.close = function () {
        exports.close(this.view, this.values.wml.id);
        return this;
    };
    /**
     * enable saving.
     */
    Prompt.prototype.enable = function () {
        getSave(this).map(function (b) { return b.enable(); });
        return this;
    };
    /**
     * disable saving.
     */
    Prompt.prototype.disable = function () {
        getSave(this).map(function (b) { return b.disable(); });
        return this;
    };
    return Prompt;
}(wml_1.Component));
exports.Prompt = Prompt;
var getSave = function (p) {
    return util_1.getById(p.view, p.values.footer.save.wml.id);
};
/**
 * close the Modal in a view.
 */
exports.close = function (view, id) {
    return util_1.getById(view, id).map(function (m) { return m.close(); });
};

},{"../../":101,"../../util":138,"./wml/prompt":100,"@quenk/wml":145}],100:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var button_1 = require("../../../control/button");
;
var close_button_1 = require("../../../control/close-button");
;
var __1 = require("../../../");
;
var modal_1 = require("../../modal");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(modal_1.Modal, { html: {}, wml: { 'id': __context.values.wml.id }, ww: { 'className': __context.values.className } }, [
                __this.widget(modal_1.ModalHeader, { html: {}, wml: {} }, [
                    __this.widget(close_button_1.CloseButton, { html: {}, wml: {}, ww: { 'onClick': __context.values.footer.close.onClick } }, []),
                    __1.text(__context.values.header.title)
                ]),
                __this.widget(modal_1.ModalBody, { html: {}, wml: {} }, __spreadArrays((__context.children))),
                __this.widget(modal_1.ModalFooter, { html: {}, wml: {} }, [
                    __this.widget(button_1.Button, { html: {}, wml: {}, ww: { 'text': __context.values.footer.close.text, 'className': __context.values.footer.close.className, 'onClick': __context.values.footer.close.onClick } }, []),
                    __this.widget(button_1.Button, { html: {}, wml: {}, ww: { 'text': __context.values.footer.save.text, 'className': __context.values.footer.save.className, 'disabled': __context.values.footer.save.disabled, 'onClick': __context.values.footer.save.onClick } }, [])
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../":101,"../../../control/button":28,"../../../control/close-button":32,"../../modal":97,"@quenk/noni/lib/data/maybe":141}],101:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * getId from a widget's passed attributes.
 */
exports.getId = function (attrs) {
    return (attrs.ww && attrs.ww.id) ? attrs.ww.id : '';
};
/**
 * getClassName from a widget's passed attributes.
 */
exports.getClassName = function (attrs) {
    return (attrs.ww && attrs.ww.className) ? attrs.ww.className : '';
};
/**
 * text constructor.
 */
exports.text = function (str) {
    return document.createTextNode(String((str == null) ? '' : str));
};

},{}],102:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../../util");
var orientation = require("../../content/orientation");
var __1 = require("../");
var action_bar_1 = require("./wml/action-bar");
///classNames:begin
/**
 * ACTION_BAR class name. for the ActionBar root.
 */
exports.ACTION_BAR = 'ww-action-bar';
/**
 * ACTION_BAR_CONTENT class name.
 */
exports.ACTION_BAR_CONTENT = 'ww-action-bar__content';
/**
 * ActionBar provides a bar across the screen that can be
 * used as a toolbar, navigation menu or something simillar.
 */
var ActionBar = /** @class */ (function (_super) {
    __extends(ActionBar, _super);
    function ActionBar() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new action_bar_1.Main(_this);
        _this.values = {
            root: {
                wml: {
                    id: 'root',
                },
                id: (_this.attrs.ww && _this.attrs.ww.id) ?
                    _this.attrs.ww.id : '',
                class: util.combine([
                    exports.ACTION_BAR,
                    __1.LAYOUT,
                    orientation.POSITIONED
                ])
            },
            content: {
                wml: {
                    id: 'content'
                },
                class: exports.ACTION_BAR_CONTENT
            }
        };
        return _this;
    }
    return ActionBar;
}(__1.AbstractLayout));
exports.ActionBar = ActionBar;

},{"../":114,"../../content/orientation":13,"../../util":138,"./wml/action-bar":103}],103:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'id': __context.values.root.id, 'class': __context.values.root.class }, wml: { 'id': __context.values.root.wml.id } }, [
                __this.node('div', { html: { 'class': __context.values.content.class }, wml: { 'id': __context.values.content.wml.id } }, __spreadArrays((__context.children)))
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":141}],104:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml_1 = require("@quenk/wml");
var style_1 = require("../../content/style");
exports.Style = style_1.Style;
var util_1 = require("../../util");
var __1 = require("../../");
var callout_1 = require("./wml/callout");
///classNames:begin
exports.CALLOUT = 'ww-callout';
/**
 * Callout
 */
var Callout = /** @class */ (function (_super) {
    __extends(Callout, _super);
    function Callout() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new callout_1.Main(_this);
        _this.values = {
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.CALLOUT, __1.getClassName(_this.attrs), (_this.attrs.ww && _this.attrs.ww.style) ?
                style_1.getStyleClassName(_this.attrs.ww.style) :
                style_1.DEFAULT)
        };
        return _this;
    }
    return Callout;
}(wml_1.Component));
exports.Callout = Callout;

},{"../../":101,"../../content/style":19,"../../util":138,"./wml/callout":105,"@quenk/wml":145}],105:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'class': __context.values.className }, wml: {} }, __spreadArrays((__context.children)));
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":141}],106:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/description-list");
var wml_1 = require("@quenk/wml");
var orientation_1 = require("../../content/orientation");
var util_1 = require("../../util");
var __1 = require("../../");
///classNames:begin
exports.DESCRIPTION_LIST = 'ww-description-list';
exports.DESCRIPTION_LIST_TITLE = 'ww-description-list__title';
exports.DESCRIPTION_LIST_DATA = 'ww-description-list__data';
/**
 * DescriptionList layout.
 */
var DescriptionList = /** @class */ (function (_super) {
    __extends(DescriptionList, _super);
    function DescriptionList() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.DescriptionList(_this);
        _this.values = {
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.DESCRIPTION_LIST, __1.getClassName(_this.attrs), (_this.attrs.ww && _this.attrs.ww.horizontal) ? orientation_1.HORIZONTAL : '')
        };
        return _this;
    }
    return DescriptionList;
}(wml_1.Component));
exports.DescriptionList = DescriptionList;
/**
 * Title
 */
var Title = /** @class */ (function (_super) {
    __extends(Title, _super);
    function Title() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Title(_this);
        _this.values = {
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.DESCRIPTION_LIST_TITLE, __1.getClassName(_this.attrs))
        };
        return _this;
    }
    return Title;
}(wml_1.Component));
exports.Title = Title;
/**
 * Data
 */
var Data = /** @class */ (function (_super) {
    __extends(Data, _super);
    function Data() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Data(_this);
        _this.values = {
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.DESCRIPTION_LIST_DATA, __1.getClassName(_this.attrs))
        };
        return _this;
    }
    return Data;
}(wml_1.Component));
exports.Data = Data;

},{"../../":101,"../../content/orientation":13,"../../util":138,"./wml/description-list":107,"@quenk/wml":145}],107:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var DescriptionList = /** @class */ (function () {
    function DescriptionList(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('dl', { html: { 'id': __context.values.id, 'class': __context.values.className }, wml: {} }, __spreadArrays((__context.children)));
        };
    }
    DescriptionList.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    DescriptionList.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    DescriptionList.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    DescriptionList.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    DescriptionList.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    DescriptionList.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    DescriptionList.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return DescriptionList;
}());
exports.DescriptionList = DescriptionList;
;
var Title = /** @class */ (function () {
    function Title(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('dt', { html: { 'id': __context.values.id, 'class': __context.values.className }, wml: {} }, __spreadArrays((__context.children)));
        };
    }
    Title.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Title.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Title.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Title.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Title.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Title.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Title.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Title;
}());
exports.Title = Title;
;
var Data = /** @class */ (function () {
    function Data(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('dd', { html: { 'id': __context.values.id, 'class': __context.values.className }, wml: {} }, __spreadArrays((__context.children)));
        };
    }
    Data.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Data.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Data.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Data.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Data.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Data.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Data.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Data;
}());
exports.Data = Data;

},{"@quenk/noni/lib/data/maybe":141}],108:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/drawer");
var wml_1 = require("@quenk/wml");
var hidden_1 = require("../../content/state/hidden");
var util_1 = require("../../util");
var __1 = require("../");
///classNames:begin
/**
 * DRAWER_LAYOUT
 */
exports.DRAWER_LAYOUT = 'ww-drawer-layout';
;
/**
 * DrawerLayout provides a 1 column application layout with a drawer that can
 * be shown or hidden upon requests.
 *
 * The drawer takes up most of the screen on mobile and about roughly 1/6 - 1/8
 * on a desktop (not fact checked yet).
 *
 *  Mobile:
 *  +---------------------------------------------------------------------+
 *  |                                            |                        |
 *  |                                            |                        |
 *  |                                            |                        |
 *  |   <drawer>                                 |                        |
 *  |                                            |                        |
 *  |                                            |                        |
 *  |                                            |                        |
 *  |                                            |                        |
 *  |                                            |                        |
 *  |                                            |                        |
 *  |                                            |                        |
 *  |                                            |                        |
 *  |                                            |                        |
 *  |                                            |                        |
 *  +---------------------------------------------------------------------+
 *
 *  Desktop:
 *  +---------------------------------------------------------------------+
 *  |             |                                                       |
 *  |             |                                                       |
 *  |             |                                                       |
 *  |             |                                                       |
 *  |             |                                                       |
 *  |   <drawer>  |                                                       |
 *  |             |                                                       |
 *  |             |                                                       |
 *  |             |                                                       |
 *  |             |                                                       |
 *  |             |                                                       |
 *  |             |                                                       |
 *  |             |                                                       |
 *  |             |                                                       |
 *  |             |                                                       |
 *  +---------------------------------------------------------------------+
 */
var DrawerLayout = /** @class */ (function (_super) {
    __extends(DrawerLayout, _super);
    function DrawerLayout() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.DrawerLayout(_this);
        /**
         * values is a hash of values used in the template.
         */
        _this.values = {
            root: {
                wml: {
                    id: 'layout'
                },
                id: _this.attrs.ww && _this.attrs.ww.id,
                className: util_1.concat(exports.DRAWER_LAYOUT, __1.LAYOUT, (_this.attrs.ww && _this.attrs.ww.className) ?
                    _this.attrs.ww.className : '')
            },
            drawer: {
                wml: {
                    id: 'drawer'
                },
                hidden: (_this.attrs.ww && _this.attrs.ww.drawerHidden) ?
                    _this.attrs.ww.drawerHidden : false,
                content: (_this.attrs.ww && _this.attrs.ww.drawerContent) ?
                    _this.attrs.ww.drawerContent : []
            },
            content: {
                id: 'content',
                value: _this.children
            }
        };
        return _this;
    }
    DrawerLayout.prototype.isHidden = function () {
        var m = getDrawer(this);
        if (m.isNothing())
            return true;
        return m.get().isHidden();
    };
    DrawerLayout.prototype.hide = function () {
        var m = getDrawer(this);
        if (m.isJust()) {
            m.get().hide();
            hidden_1.hide(this.view, this.values.root.wml.id);
        }
        return this;
    };
    DrawerLayout.prototype.show = function () {
        var m = getDrawer(this);
        if (m.isJust()) {
            m.get().show();
            hidden_1.show(this.view, this.values.root.wml.id);
        }
        return this;
    };
    DrawerLayout.prototype.toggle = function () {
        var m = getDrawer(this);
        if (m.isJust()) {
            m.get().toggle();
            hidden_1.toggle(this.view, this.values.root.wml.id);
        }
        return this;
    };
    DrawerLayout.prototype.setContent = function (c) {
        this.values.content.value = c;
        this.view.invalidate();
        return this;
    };
    DrawerLayout.prototype.removeContent = function () {
        this.values.content.value = [];
        return this;
    };
    return DrawerLayout;
}(wml_1.Component));
exports.DrawerLayout = DrawerLayout;
var getDrawer = function (dl) {
    var m = dl.view.findById(dl.values.drawer.wml.id);
    if (m.isNothing())
        util_1.warnMissing(dl.view, dl.values.drawer.wml.id);
    return m;
};

},{"../":114,"../../content/state/hidden":18,"../../util":138,"./wml/drawer":109,"@quenk/wml":145}],109:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var drawer_1 = require("../../../menu/drawer");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var DrawerLayout = /** @class */ (function () {
    function DrawerLayout(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'id': __context.values.root.id, 'class': __context.values.root.className }, wml: { 'id': __context.values.root.wml.id } }, __spreadArrays([
                __this.widget(drawer_1.Drawer, { html: {}, wml: { 'id': __context.values.drawer.wml.id }, ww: { 'hidden': __context.values.drawer.hidden, 'content': __context.values.drawer.content } }, [])
            ], (__context.values.content.value)));
        };
    }
    DrawerLayout.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    DrawerLayout.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    DrawerLayout.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    DrawerLayout.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    DrawerLayout.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    DrawerLayout.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    DrawerLayout.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return DrawerLayout;
}());
exports.DrawerLayout = DrawerLayout;

},{"../../../menu/drawer":127,"@quenk/noni/lib/data/maybe":141}],110:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/grid");
var util_1 = require("../../util");
var __1 = require("../");
///classNames:begin
exports.GRID_LAYOUT = 'ww-grid-layout';
exports.GRID_LAYOUT_ROW = 'ww-grid-layout__row';
exports.GRID_LAYOUT_COLUMN = 'ww-grid-layout__column';
;
/**
 * GridLayout
 */
var GridLayout = /** @class */ (function (_super) {
    __extends(GridLayout, _super);
    function GridLayout() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.GridLayout(_this);
        _this.values = {
            content: {
                id: _this.attrs.ww && _this.attrs.ww.id,
                wml: {
                    id: 'root',
                },
                className: function () {
                    var c = (_this.attrs.ww && _this.attrs.ww.className) ?
                        _this.attrs.ww.className : '';
                    return util_1.concat(exports.GRID_LAYOUT, __1.LAYOUT, c);
                }
            }
        };
        return _this;
    }
    return GridLayout;
}(__1.AbstractLayout));
exports.GridLayout = GridLayout;
/**
 * Row
 */
var Row = /** @class */ (function (_super) {
    __extends(Row, _super);
    function Row() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Row(_this);
        _this.values = {
            content: {
                id: _this.attrs.ww && _this.attrs.ww.id,
                wml: {
                    id: 'row',
                },
                className: function () {
                    var c = (_this.attrs.ww && _this.attrs.ww.className) ?
                        _this.attrs.ww.className : '';
                    return util_1.concat(exports.GRID_LAYOUT_ROW, c);
                }
            }
        };
        return _this;
    }
    return Row;
}(__1.AbstractLayout));
exports.Row = Row;
/**
 * Column
 */
var Column = /** @class */ (function (_super) {
    __extends(Column, _super);
    function Column() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Column(_this);
        _this.values = {
            content: {
                id: _this.attrs.ww && _this.attrs.ww.id,
                wml: {
                    id: 'column'
                },
                className: function () {
                    if (_this.attrs.ww != null) {
                        return util_1.concat(exports.GRID_LAYOUT_COLUMN, _this.attrs.ww.span ?
                            "-span" + _this.attrs.ww.span :
                            '-span12', _this.attrs.ww.offset ?
                            "-offset" + _this.attrs.ww.offset :
                            '', _this.attrs.ww.className);
                    }
                    else {
                        return util_1.concat(exports.GRID_LAYOUT_COLUMN, '-span12');
                    }
                }
            }
        };
        return _this;
    }
    return Column;
}(__1.AbstractLayout));
exports.Column = Column;

},{"../":114,"../../util":138,"./wml/grid":111}],111:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var GridLayout = /** @class */ (function () {
    function GridLayout(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'id': __context.values.content.id, 'class': __context.values.content.className() }, wml: { 'id': __context.values.content.wml.id } }, __spreadArrays((__context.children)));
        };
    }
    GridLayout.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    GridLayout.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    GridLayout.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    GridLayout.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    GridLayout.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    GridLayout.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    GridLayout.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return GridLayout;
}());
exports.GridLayout = GridLayout;
;
var Row = /** @class */ (function () {
    function Row(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'id': __context.values.content.id, 'class': __context.values.content.className() }, wml: { 'id': __context.values.content.wml.id } }, __spreadArrays((__context.children)));
        };
    }
    Row.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Row.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Row.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Row.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Row.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Row.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Row.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Row;
}());
exports.Row = Row;
;
var Column = /** @class */ (function () {
    function Column(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'id': __context.values.content.id, 'class': __context.values.content.className() }, wml: { 'id': __context.values.content.wml.id } }, __spreadArrays((__context.children)));
        };
    }
    Column.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Column.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Column.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Column.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Column.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Column.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Column.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Column;
}());
exports.Column = Column;

},{"@quenk/noni/lib/data/maybe":141}],112:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml = require("@quenk/wml");
var views = require("./wml/horizontal");
var orientation_1 = require("../../content/orientation");
var util_1 = require("../../util");
var __1 = require("../../");
///classNames:begin
exports.HORIZONTAL_LAYOUT = 'ww-horizontal-layout';
///classNames:end
/**
 * HorizontalLayoutOrientation
 */
var HorizontalLayoutOrientation;
(function (HorizontalLayoutOrientation) {
    HorizontalLayoutOrientation["Left"] = "left";
    HorizontalLayoutOrientation["Right"] = "right";
})(HorizontalLayoutOrientation = exports.HorizontalLayoutOrientation || (exports.HorizontalLayoutOrientation = {}));
/**
 * HorizontalLayout uses the css flexbox to provide a container
 * where all items are laid out in a single row.
 */
var HorizontalLayout = /** @class */ (function (_super) {
    __extends(HorizontalLayout, _super);
    function HorizontalLayout() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: {
                id: (_this.attrs.ww && _this.attrs.ww.id) ? _this.attrs.ww.id : '',
                className: util_1.concat(exports.HORIZONTAL_LAYOUT, __1.getClassName(_this.attrs), getOrientation(_this.attrs))
            }
        };
        return _this;
    }
    return HorizontalLayout;
}(wml.Component));
exports.HorizontalLayout = HorizontalLayout;
var getOrientation = function (attrs) {
    return (attrs.ww && attrs.ww.orientation) ?
        attrs.ww.orientation === HorizontalLayoutOrientation.Right ?
            orientation_1.RIGHT : orientation_1.LEFT : '';
};

},{"../../":101,"../../content/orientation":13,"../../util":138,"./wml/horizontal":113,"@quenk/wml":145}],113:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'class': __context.values.root.className }, wml: {} }, __spreadArrays((__context.children)));
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":141}],114:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml_1 = require("@quenk/wml");
var util_1 = require("../util");
///classNames:begin
exports.LAYOUT = '-layout';
/**
 * AbstractLayout provides an implementation of Layout.
 */
var AbstractLayout = /** @class */ (function (_super) {
    __extends(AbstractLayout, _super);
    function AbstractLayout() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AbstractLayout.prototype.setContent = function (c) {
        exports.doSetContent(this.view, this.values.content.wml.id, c);
        return this;
    };
    AbstractLayout.prototype.removeContent = function () {
        exports.doRemoveContent(this.view, this.values.content.wml.id);
        return this;
    };
    return AbstractLayout;
}(wml_1.Component));
exports.AbstractLayout = AbstractLayout;
/**
 * doSetContent on a Node found in a view.
 */
exports.doSetContent = function (view, id, content) {
    var maybeRoot = view.findById(id);
    if (maybeRoot.isNothing())
        return util_1.warnMissing(view, id);
    var n = maybeRoot.get();
    while (n.firstChild)
        n.removeChild(n.firstChild);
    for (var i = 0; i < content.length; i++)
        n.appendChild(content[i]);
};
/**
 * doRemoveContent from a View.
 */
exports.doRemoveContent = function (view, id) {
    var maybeNode = view.findById(id);
    if (maybeNode.isNothing())
        return util_1.warnMissing(view, id);
    var n = maybeNode.get();
    while (n.firstChild)
        n.removeChild(n.firstChild);
};

},{"../util":138,"@quenk/wml":145}],115:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/list");
var util_1 = require("../../util");
var active_1 = require("../../content/state/active");
var __1 = require("../");
///classNames:begin
exports.LIST_LAYOUT = 'ww-list-layout';
exports.LIST_LAYOUT_ITEM = 'ww-list-layout__item';
/**
 * ListLayoutItem
 */
var ListLayoutItem = /** @class */ (function (_super) {
    __extends(ListLayoutItem, _super);
    function ListLayoutItem() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.ListLayoutItem(_this);
        _this.values = {
            content: {
                wml: {
                    id: 'item'
                },
                id: (_this.attrs.ww && _this.attrs.ww.id) ? _this.attrs.ww.id : '',
                className: util_1.concat(exports.LIST_LAYOUT_ITEM, (_this.attrs.ww && _this.attrs.ww.active) ? active_1.ACTIVE : ''),
                name: (_this.attrs.ww && _this.attrs.ww.name) ? _this.attrs.ww.name : '',
                onclick: function () {
                    if (_this.attrs.ww && _this.attrs.ww.onClick)
                        _this.attrs.ww.onClick(_this.attrs.ww &&
                            _this.attrs.ww.name || '');
                }
            }
        };
        return _this;
    }
    ListLayoutItem.prototype.isActive = function () {
        return active_1.isActive(this.view, this.values.content.wml.id);
    };
    ListLayoutItem.prototype.activate = function () {
        active_1.activate(this.view, this.values.content.wml.id);
        return this;
    };
    ListLayoutItem.prototype.deactivate = function () {
        active_1.deactivate(this.view, this.values.content.wml.id);
        return this;
    };
    ListLayoutItem.prototype.toggleActive = function () {
        if (this.isActive())
            this.deactivate();
        else
            this.activate();
        return this;
    };
    return ListLayoutItem;
}(__1.AbstractLayout));
exports.ListLayoutItem = ListLayoutItem;
/**
 * ListLayout is used to create a vertical list of content.
 *
 * Children must be ListGroupItems.
 */
var ListLayout = /** @class */ (function (_super) {
    __extends(ListLayout, _super);
    function ListLayout() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.ListLayout(_this);
        _this.values = {
            content: {
                wml: {
                    id: 'list'
                },
                id: _this.attrs.ww && _this.attrs.ww.id,
                className: util_1.concat(exports.LIST_LAYOUT, __1.LAYOUT, (_this.attrs.ww && _this.attrs.ww.className) ?
                    _this.attrs.ww.className : '')
            }
        };
        return _this;
    }
    return ListLayout;
}(__1.AbstractLayout));
exports.ListLayout = ListLayout;

},{"../":114,"../../content/state/active":17,"../../util":138,"./wml/list":116}],116:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var ListLayoutItem = /** @class */ (function () {
    function ListLayoutItem(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('li', { html: { 'id': __context.values.content.id, 'class': __context.values.content.className, 'onclick': __context.values.content.onclick }, wml: { 'id': __context.values.content.wml.id } }, __spreadArrays((__context.children)));
        };
    }
    ListLayoutItem.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    ListLayoutItem.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    ListLayoutItem.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    ListLayoutItem.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    ListLayoutItem.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    ListLayoutItem.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    ListLayoutItem.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return ListLayoutItem;
}());
exports.ListLayoutItem = ListLayoutItem;
;
var ListLayout = /** @class */ (function () {
    function ListLayout(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('ul', { html: { 'id': __context.values.content.id, 'class': __context.values.content.className }, wml: { 'id': __context.values.content.wml.id } }, __spreadArrays((__context.children)));
        };
    }
    ListLayout.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    ListLayout.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    ListLayout.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    ListLayout.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    ListLayout.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    ListLayout.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    ListLayout.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return ListLayout;
}());
exports.ListLayout = ListLayout;

},{"@quenk/noni/lib/data/maybe":141}],117:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/main");
var util_1 = require("../../util");
var __1 = require("../");
///classNames:begin
exports.MAIN_LAYOUT = 'ww-main-layout';
/**
 * MainLayout provides a container for the main content of an application.
 */
var MainLayout = /** @class */ (function (_super) {
    __extends(MainLayout, _super);
    function MainLayout() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            content: {
                wml: {
                    id: 'main'
                },
                id: (_this.attrs && _this.attrs.ww) ? _this.attrs.ww.id : '',
                className: util_1.concat(exports.MAIN_LAYOUT, __1.LAYOUT, (_this.attrs && _this.attrs.ww) ?
                    _this.attrs.ww.className : '')
            }
        };
        return _this;
    }
    return MainLayout;
}(__1.AbstractLayout));
exports.MainLayout = MainLayout;

},{"../":114,"../../util":138,"./wml/main":118}],118:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'id': __context.values.content.id, 'class': __context.values.content.className }, wml: { 'id': __context.values.content.wml.id } }, __spreadArrays((__context.children)));
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":141}],119:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/meter");
var wml_1 = require("@quenk/wml");
var util_1 = require("../../util");
var __1 = require("../../");
///classNames:begin
exports.METER = 'ww-meter';
exports.METER_BAR = 'ww-meter__bar';
/**
 * Meter
 */
var Meter = /** @class */ (function (_super) {
    __extends(Meter, _super);
    function Meter() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Meter(_this);
        _this.values = {
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.METER, __1.getClassName(_this.attrs))
        };
        return _this;
    }
    return Meter;
}(wml_1.Component));
exports.Meter = Meter;
/**
 * MeterBar
 */
var MeterBar = /** @class */ (function (_super) {
    __extends(MeterBar, _super);
    function MeterBar() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.MeterBar(_this);
        _this.values = {
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.METER_BAR, __1.getClassName(_this.attrs)),
            value: (_this.attrs.ww && _this.attrs.ww.value) ?
                _this.attrs.ww.value : 0,
            color: (_this.attrs.ww && _this.attrs.ww.color) ?
                _this.attrs.ww.color : '',
            style: function () {
                var list = [];
                if (_this.values.color)
                    list.push("background-color:" + _this.values.color);
                if (_this.values.value)
                    list.push("width:" + _this.values.value + "%");
                return list.join(';');
            }
        };
        return _this;
    }
    /**
     * setValue sets the value of the MeterBar.
     */
    MeterBar.prototype.setValue = function (value) {
        this.values.value = value;
        this.view.invalidate();
        return this;
    };
    /**
     * increase the value by the specified amount.
     */
    MeterBar.prototype.increase = function (value) {
        this.values.value = this.values.value + value;
        this.view.invalidate();
        return this;
    };
    /**
     * decrease the value by the specified amount.
     */
    MeterBar.prototype.decrease = function (value) {
        this.values.value = this.values.value - value;
        this.view.invalidate();
        return this;
    };
    /**
     * setColor of the MeterBar.
     */
    MeterBar.prototype.setColor = function (color) {
        this.values.color = color;
        this.view.invalidate();
        return this;
    };
    return MeterBar;
}(wml_1.Component));
exports.MeterBar = MeterBar;

},{"../../":101,"../../util":138,"./wml/meter":120,"@quenk/wml":145}],120:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Meter = /** @class */ (function () {
    function Meter(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'id': __context.values.id, 'class': __context.values.className }, wml: {} }, __spreadArrays((__context.children)));
        };
    }
    Meter.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Meter.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Meter.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Meter.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Meter.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Meter.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Meter.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Meter;
}());
exports.Meter = Meter;
;
var MeterBar = /** @class */ (function () {
    function MeterBar(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'id': __context.values.id, 'class': __context.values.className, 'style': __context.values.style() }, wml: {} }, []);
        };
    }
    MeterBar.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    MeterBar.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    MeterBar.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    MeterBar.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    MeterBar.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    MeterBar.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    MeterBar.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return MeterBar;
}());
exports.MeterBar = MeterBar;

},{"@quenk/noni/lib/data/maybe":141}],121:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var style = require("../../content/style");
var views = require("./wml/panel");
var util_1 = require("../../util");
var __1 = require("..");
///classNames:begin
/**
 * PANEL wrapper class.
 */
exports.PANEL = 'ww-panel';
/**
 * PANEL_HEADER class name.
 */
exports.PANEL_HEADER = 'ww-panel__header';
/**
 * PANEL_BODY class name.
 */
exports.PANEL_BODY = 'ww-panel__body';
/**
 * PANEL_FOOTER class name.
 */
exports.PANEL_FOOTER = 'ww-panel__footer';
/**
 * Panel provides a rectangular container for visually seperating
 * content by context.
 */
var Panel = /** @class */ (function (_super) {
    __extends(Panel, _super);
    function Panel() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Panel(_this);
        /**
         * values
         */
        _this.values = {
            /**
             * root values.
             */
            content: {
                id: _this.attrs.ww && _this.attrs.ww.id,
                wml: {
                    id: 'panel',
                },
                className: util_1.concat(exports.PANEL, __1.LAYOUT, (_this.attrs.ww && _this.attrs.ww.style) ?
                    "-" + _this.attrs.ww.style : style.DEFAULT, _this.attrs.ww && _this.attrs.ww.className ?
                    _this.attrs.ww.className : '')
            }
        };
        return _this;
    }
    return Panel;
}(__1.AbstractLayout));
exports.Panel = Panel;
/**
 * PanelHeader
 */
var PanelHeader = /** @class */ (function (_super) {
    __extends(PanelHeader, _super);
    function PanelHeader() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.PanelHeader(_this);
        /**
         * values
         */
        _this.values = {
            content: {
                wml: {
                    id: 'header'
                },
                id: _this.attrs.ww && _this.attrs.ww.id,
                className: util_1.concat(exports.PANEL_HEADER, __1.LAYOUT, _this.attrs.ww && _this.attrs.ww.className ?
                    _this.attrs.ww.className : '')
            }
        };
        return _this;
    }
    return PanelHeader;
}(__1.AbstractLayout));
exports.PanelHeader = PanelHeader;
/**
 * PanelBody
 */
var PanelBody = /** @class */ (function (_super) {
    __extends(PanelBody, _super);
    function PanelBody() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.PanelBody(_this);
        /**
         * values
         */
        _this.values = {
            content: {
                wml: {
                    id: 'body'
                },
                id: _this.attrs.ww && _this.attrs.ww.id,
                className: util_1.concat(exports.PANEL_BODY, __1.LAYOUT, _this.attrs.ww && _this.attrs.ww.className ?
                    _this.attrs.ww.className : '')
            }
        };
        return _this;
    }
    return PanelBody;
}(__1.AbstractLayout));
exports.PanelBody = PanelBody;
/**
 * PanelFooter
 */
var PanelFooter = /** @class */ (function (_super) {
    __extends(PanelFooter, _super);
    function PanelFooter() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.PanelFooter(_this);
        /**
         * values
         */
        _this.values = {
            content: {
                wml: {
                    id: 'footer'
                },
                id: _this.attrs.ww && _this.attrs.ww.id,
                className: util_1.concat(exports.PANEL_FOOTER, __1.LAYOUT, _this.attrs.ww && _this.attrs.ww.className ?
                    _this.attrs.ww.className : '')
            }
        };
        return _this;
    }
    return PanelFooter;
}(__1.AbstractLayout));
exports.PanelFooter = PanelFooter;

},{"..":114,"../../content/style":19,"../../util":138,"./wml/panel":122}],122:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Panel = /** @class */ (function () {
    function Panel(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'class': __context.values.content.className }, wml: { 'id': __context.values.content.id } }, __spreadArrays((__context.children)));
        };
    }
    Panel.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Panel.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Panel.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Panel.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Panel.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Panel.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Panel.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Panel;
}());
exports.Panel = Panel;
;
var PanelHeader = /** @class */ (function () {
    function PanelHeader(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'class': __context.values.content.className }, wml: { 'id': __context.values.content.id } }, __spreadArrays((__context.children)));
        };
    }
    PanelHeader.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    PanelHeader.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    PanelHeader.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    PanelHeader.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    PanelHeader.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    PanelHeader.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    PanelHeader.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return PanelHeader;
}());
exports.PanelHeader = PanelHeader;
;
var PanelBody = /** @class */ (function () {
    function PanelBody(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'class': __context.values.content.className }, wml: { 'id': __context.values.content.id } }, __spreadArrays((__context.children)));
        };
    }
    PanelBody.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    PanelBody.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    PanelBody.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    PanelBody.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    PanelBody.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    PanelBody.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    PanelBody.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return PanelBody;
}());
exports.PanelBody = PanelBody;
;
var PanelFooter = /** @class */ (function () {
    function PanelFooter(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'class': __context.values.content.className }, wml: { 'id': __context.values.content.id } }, __spreadArrays((__context.children)));
        };
    }
    PanelFooter.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    PanelFooter.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    PanelFooter.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    PanelFooter.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    PanelFooter.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    PanelFooter.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    PanelFooter.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return PanelFooter;
}());
exports.PanelFooter = PanelFooter;

},{"@quenk/noni/lib/data/maybe":141}],123:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/tab");
var wml_1 = require("@quenk/wml");
var maybe_1 = require("@quenk/noni/lib/data/maybe");
var util_1 = require("../../util");
var __1 = require("../../");
var __2 = require("../");
///classNames:begin
exports.TAB_LAYOUT = 'ww-tab-layout';
/**
 * TabLayout provides a layout whose displayed content can be changed via tabs.
 *
 * ----------------------------------------------------------------------------
 * |                                                                          |
 * | Tab1  |  Tab2  | Tab2                                                    |
 * |                                                                          |
 * ----------------------------------------------------------------------------
 * |                                                                          |
 * |                                                                          |
 * |                             <Content>                                    |
 * |                                                                          |
 * |                                                                          |
 * |                                                                          |
 * |                                                                          |
 * |__________________________________________________________________________|
 */
var TabLayout = /** @class */ (function (_super) {
    __extends(TabLayout, _super);
    function TabLayout() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: {
                id: __1.getId(_this.attrs),
                className: util_1.concat(exports.TAB_LAYOUT, __2.LAYOUT, __1.getClassName(_this.attrs)),
                content: function () {
                    if ((_this.attrs.ww && _this.attrs.ww.active)) {
                        var maybeActive = maybe_1.fromNullable(_this.values.tabs.data[_this.attrs.ww.active]);
                        if (maybeActive.isJust())
                            return maybeActive
                                .get()
                                .contentFun(_this)(_this.view);
                    }
                    return _this.children;
                }
            },
            tabs: {
                current: (_this.attrs.ww && _this.attrs.ww.active) ?
                    _this.attrs.ww.active : '',
                data: (_this.attrs.ww && _this.attrs.ww.tabs) ?
                    _this.attrs.ww.tabs : {},
                content: function (t) {
                    if (t.tabFun)
                        return t.tabFun(_this)(_this.view);
                    if (t.text)
                        return [__1.text(t.text)];
                    return [];
                },
                onClick: function (e) {
                    if (_this.values.tabs.current !== e.name)
                        _this.values.tabs.current = e.name;
                    var tab = maybe_1.fromNullable(_this.values.tabs.data[e.name]).get();
                    _this.values.root.content = function () {
                        return tab.contentFun(_this)(_this.view);
                    };
                    _this.view.invalidate();
                }
            }
        };
        return _this;
    }
    TabLayout.prototype.setContent = function (c) {
        this.values.root.content = function () { return c; };
        this.view.invalidate();
        return this;
    };
    TabLayout.prototype.removeContent = function () {
        this.values.root.content = function () { return []; };
        this.view.invalidate();
        return this;
    };
    return TabLayout;
}(wml_1.Component));
exports.TabLayout = TabLayout;

},{"../":114,"../../":101,"../../util":138,"./wml/tab":124,"@quenk/noni/lib/data/maybe":141,"@quenk/wml":145}],124:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var tab_bar_1 = require("../../../control/tab-bar");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'id': __context.values.root.id, 'class': __context.values.root.className }, wml: {} }, __spreadArrays([
                __this.widget(tab_bar_1.TabBar, { html: {}, wml: {} }, __spreadArrays(__forOf(__context.values.tabs.data, function (tab, name, _$$all) {
                    return ([
                        __this.widget(tab_bar_1.Tab, { html: {}, wml: {}, ww: { 'name': name, 'active': (__context.values.tabs.current === name), 'onClick': __context.values.tabs.onClick } }, __spreadArrays((__context.values.tabs.content(tab))))
                    ]);
                }, function () { return ([]); })))
            ], (__context.values.root.content())));
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../control/tab-bar":72,"@quenk/noni/lib/data/maybe":141}],125:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/table");
var wml_1 = require("@quenk/wml");
var util_1 = require("../../util");
var __1 = require("../../");
///classNames:begin
exports.TABLE_HEADER = 'ww-table-layout__header';
exports.TABLE_BODY = 'ww-table-layout__body';
exports.TABLE_FOOTER = 'ww-table-layout__footer';
exports.TABLE_ROW = 'ww-table-layout__row';
exports.TABLE_HEADING = 'ww-table-layout _heading';
exports.TABLE_CELL = 'ww-table-layout__cell';
exports.TABLE_LAYOUT = 'ww-table-layout';
exports.TABLE_WINDOW = 'ww-table-window';
exports.BORDERED = '-bordered';
exports.COMPACT = '-compact';
exports.ALTERNATE = '-alternate';
exports.HOVERABLE = '-hoverable';
/**
 * TableHeader (<thead>)
 */
var TableHeader = /** @class */ (function (_super) {
    __extends(TableHeader, _super);
    function TableHeader() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.TableHeader(_this);
        _this.values = {
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.TABLE_HEADER, __1.getClassName(_this.attrs))
        };
        return _this;
    }
    return TableHeader;
}(wml_1.Component));
exports.TableHeader = TableHeader;
/**
 * TableBody
 */
var TableBody = /** @class */ (function (_super) {
    __extends(TableBody, _super);
    function TableBody() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.TableBody(_this);
        _this.values = {
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.TABLE_BODY, __1.getClassName(_this.attrs))
        };
        return _this;
    }
    return TableBody;
}(wml_1.Component));
exports.TableBody = TableBody;
/**
 * TableFooter
 */
var TableFooter = /** @class */ (function (_super) {
    __extends(TableFooter, _super);
    function TableFooter() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.TableFooter(_this);
        _this.values = {
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.TABLE_FOOTER, __1.getClassName(_this.attrs))
        };
        return _this;
    }
    return TableFooter;
}(wml_1.Component));
exports.TableFooter = TableFooter;
/**
 * TableRow
 */
var TableRow = /** @class */ (function (_super) {
    __extends(TableRow, _super);
    function TableRow() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.TableRow(_this);
        _this.values = {
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.TABLE_ROW, __1.getClassName(_this.attrs)),
            onclick: (_this.attrs.ww && _this.attrs.ww.onclick) ?
                _this.attrs.ww.onclick : undefined
        };
        return _this;
    }
    return TableRow;
}(wml_1.Component));
exports.TableRow = TableRow;
/**
 * TableHeading
 */
var TableHeading = /** @class */ (function (_super) {
    __extends(TableHeading, _super);
    function TableHeading() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.TableHeading(_this);
        _this.values = {
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.TABLE_HEADING, __1.getClassName(_this.attrs)),
            onclick: (_this.attrs.ww && _this.attrs.ww.onclick) ?
                _this.attrs.ww.onclick : undefined
        };
        return _this;
    }
    return TableHeading;
}(wml_1.Component));
exports.TableHeading = TableHeading;
/**
 * TableCell
 */
var TableCell = /** @class */ (function (_super) {
    __extends(TableCell, _super);
    function TableCell() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.TableCell(_this);
        _this.values = {
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.TABLE_CELL, __1.getClassName(_this.attrs)),
            colspan: (_this.attrs.ww && _this.attrs.ww.colspan) ?
                _this.attrs.ww.colspan : 1,
            rowspan: (_this.attrs.ww && _this.attrs.ww.rowspan) ?
                _this.attrs.ww.rowspan : 1,
            onclick: (_this.attrs.ww && _this.attrs.ww.onclick) ?
                _this.attrs.ww.onclick : undefined
        };
        return _this;
    }
    return TableCell;
}(wml_1.Component));
exports.TableCell = TableCell;
/**
 * TableWindow allows a TableLayout to be scrolled on smaller screens.
 */
var TableWindow = /** @class */ (function (_super) {
    __extends(TableWindow, _super);
    function TableWindow() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.TableWindow(_this);
        _this.values = {
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.TABLE_WINDOW, __1.getClassName(_this.attrs))
        };
        return _this;
    }
    return TableWindow;
}(wml_1.Component));
exports.TableWindow = TableWindow;
/**
 * TableLayout provides a <table> based layout.
 */
var TableLayout = /** @class */ (function (_super) {
    __extends(TableLayout, _super);
    function TableLayout() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.TableLayout(_this);
        _this.values = {
            wml: {
                id: 'table'
            },
            id: __1.getId(_this.attrs),
            className: util_1.concat(exports.TABLE_LAYOUT, __1.getClassName(_this.attrs), (_this.attrs.ww && _this.attrs.ww.alternate) ? exports.ALTERNATE : '', (_this.attrs.ww && _this.attrs.ww.bordered) ? exports.BORDERED : '', (_this.attrs.ww && _this.attrs.ww.compact) ? exports.COMPACT : '', (_this.attrs.ww && _this.attrs.ww.hoverable) ? exports.HOVERABLE : ''),
        };
        return _this;
    }
    return TableLayout;
}(wml_1.Component));
exports.TableLayout = TableLayout;

},{"../../":101,"../../util":138,"./wml/table":126,"@quenk/wml":145}],126:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var TableHeader = /** @class */ (function () {
    function TableHeader(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('thead', { html: { 'id': __context.values.id, 'class': __context.values.className }, wml: {} }, __spreadArrays((__context.children)));
        };
    }
    TableHeader.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    TableHeader.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    TableHeader.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    TableHeader.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    TableHeader.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    TableHeader.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    TableHeader.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return TableHeader;
}());
exports.TableHeader = TableHeader;
;
var TableBody = /** @class */ (function () {
    function TableBody(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('tbody', { html: { 'id': __context.values.id, 'class': __context.values.className }, wml: {} }, __spreadArrays((__context.children)));
        };
    }
    TableBody.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    TableBody.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    TableBody.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    TableBody.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    TableBody.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    TableBody.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    TableBody.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return TableBody;
}());
exports.TableBody = TableBody;
;
var TableFooter = /** @class */ (function () {
    function TableFooter(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('tfoot', { html: { 'id': __context.values.id, 'class': __context.values.className }, wml: {} }, __spreadArrays((__context.children)));
        };
    }
    TableFooter.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    TableFooter.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    TableFooter.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    TableFooter.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    TableFooter.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    TableFooter.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    TableFooter.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return TableFooter;
}());
exports.TableFooter = TableFooter;
;
var TableRow = /** @class */ (function () {
    function TableRow(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('tr', { html: { 'id': __context.values.id, 'class': __context.values.className, 'onclick': __context.values.onclick }, wml: {} }, __spreadArrays((__context.children)));
        };
    }
    TableRow.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    TableRow.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    TableRow.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    TableRow.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    TableRow.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    TableRow.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    TableRow.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return TableRow;
}());
exports.TableRow = TableRow;
;
var TableHeading = /** @class */ (function () {
    function TableHeading(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('th', { html: { 'id': __context.values.id, 'class': __context.values.className, 'onclick': __context.values.onclick }, wml: {} }, __spreadArrays((__context.children)));
        };
    }
    TableHeading.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    TableHeading.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    TableHeading.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    TableHeading.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    TableHeading.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    TableHeading.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    TableHeading.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return TableHeading;
}());
exports.TableHeading = TableHeading;
;
var TableCell = /** @class */ (function () {
    function TableCell(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('td', { html: { 'id': __context.values.id, 'class': __context.values.className, 'colspan': String(__context.values.colspan), 'rowspan': String(__context.values.rowspan), 'onclick': __context.values.onclick }, wml: {} }, __spreadArrays((__context.children)));
        };
    }
    TableCell.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    TableCell.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    TableCell.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    TableCell.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    TableCell.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    TableCell.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    TableCell.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return TableCell;
}());
exports.TableCell = TableCell;
;
var TableWindow = /** @class */ (function () {
    function TableWindow(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'id': __context.values.id, 'class': __context.values.className }, wml: {} }, __spreadArrays((__context.children)));
        };
    }
    TableWindow.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    TableWindow.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    TableWindow.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    TableWindow.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    TableWindow.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    TableWindow.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    TableWindow.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return TableWindow;
}());
exports.TableWindow = TableWindow;
;
var TableLayout = /** @class */ (function () {
    function TableLayout(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('table', { html: { 'id': __context.values.id, 'class': __context.values.className }, wml: {} }, __spreadArrays((__context.children)));
        };
    }
    TableLayout.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    TableLayout.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    TableLayout.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    TableLayout.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    TableLayout.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    TableLayout.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    TableLayout.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return TableLayout;
}());
exports.TableLayout = TableLayout;

},{"@quenk/noni/lib/data/maybe":141}],127:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var hidden_1 = require("../../content/state/hidden");
var layout_1 = require("../../layout");
var util_1 = require("../../util");
var drawer_1 = require("./wml/drawer");
///classNames:begin
exports.DRAWER = 'ww-drawer';
exports.DRAWER_CONTENT = 'ww-drawer__content';
/**
 * Drawer provides a widget for displaying navigation and other sidebar content.
 *
 * It's api allows for toggling between hidden and shown states as well as
 * querying the current state.
 *
 * This widget's style intentionally gives it a high z-index so that it appears
 * in-front  of other content. Adjust the respective style variables to change.
 */
var Drawer = /** @class */ (function (_super) {
    __extends(Drawer, _super);
    function Drawer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new drawer_1.Main(_this);
        _this.values = {
            root: {
                id: _this.attrs.ww && _this.attrs.ww.id,
                className: util_1.concat(exports.DRAWER, (_this.attrs.ww && _this.attrs.ww.hidden) ?
                    hidden_1.HIDDEN : ''),
                wml: {
                    id: 'root'
                }
            },
            content: {
                wml: {
                    id: 'content'
                },
                className: exports.DRAWER_CONTENT,
                value: (_this.attrs.ww && _this.attrs.ww.content) ?
                    _this.attrs.ww.content : _this.children
            }
        };
        return _this;
    }
    Drawer.prototype.isHidden = function () {
        return hidden_1.isHidden(this.view, this.values.root.wml.id);
    };
    Drawer.prototype.hide = function () {
        hidden_1.hide(this.view, this.values.root.wml.id);
        return this;
    };
    Drawer.prototype.show = function () {
        hidden_1.show(this.view, this.values.root.wml.id);
        return this;
    };
    Drawer.prototype.toggle = function () {
        hidden_1.toggle(this.view, this.values.root.wml.id);
        return this;
    };
    return Drawer;
}(layout_1.AbstractLayout));
exports.Drawer = Drawer;

},{"../../content/state/hidden":18,"../../layout":114,"../../util":138,"./wml/drawer":128}],128:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('div', { html: { 'id': __context.values.root.id, 'class': __context.values.root.className }, wml: { 'id': __context.values.root.wml.id } }, [
                __this.node('div', { html: { 'class': __context.values.content.className }, wml: { 'id': __context.values.content.wml.id } }, __spreadArrays((__context.values.content.value)))
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":141}],129:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml = require("@quenk/wml");
var views = require("./wml/header");
var util_1 = require("../../util");
///classNames:begin
/**
 * MENU_HEADER
 */
exports.MENU_HEADER = 'ww-menu-header';
/**
 * MenuHeader can be used to display non-clickable heading text in a nav menu.
 */
var MenuHeader = /** @class */ (function (_super) {
    __extends(MenuHeader, _super);
    function MenuHeader() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            span: {
                id: (_this.attrs.ww && _this.attrs.ww.id) ? _this.attrs.ww.id : '',
                className: util_1.concat(exports.MENU_HEADER, (_this.attrs.ww && _this.attrs.ww.className) ?
                    _this.attrs.ww.className : '')
            },
            text: (_this.attrs.ww && _this.attrs.ww.text) ?
                [document.createTextNode(_this.attrs.ww.text)] : _this.children
        };
        return _this;
    }
    return MenuHeader;
}(wml.Component));
exports.MenuHeader = MenuHeader;

},{"../../util":138,"./wml/header":130,"@quenk/wml":145}],130:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('span', { html: { 'id': __context.values.span.id, 'class': __context.values.span.className }, wml: {} }, __spreadArrays((__context.values.text)));
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":141}],131:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml = require("@quenk/wml");
var views = require("./wml/item");
var active_1 = require("../../content/state/active");
var active_2 = require("../../content/state/active");
var util_1 = require("../../util");
///classNames:begin
exports.ITEM = 'ww-menu-item';
exports.DIVIDER = '-divider';
/**
 * ItemClickedEvent is fired when the user clicks on an item in
 * a nav list.
 */
var ItemClickedEvent = /** @class */ (function () {
    function ItemClickedEvent(name) {
        this.name = name;
    }
    return ItemClickedEvent;
}());
exports.ItemClickedEvent = ItemClickedEvent;
/**
 * Item wraps content in a navigation list.
 *
 * Items should not have any siblings that are not other Items.
 */
var Item = /** @class */ (function (_super) {
    __extends(Item, _super);
    function Item() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: {
                wml: {
                    id: 'root'
                },
                id: (_this.attrs.ww && _this.attrs.ww.id) ? _this.attrs.ww.id : '',
                className: util_1.concat(exports.ITEM, (_this.attrs.ww && _this.attrs.ww.active) ? active_2.ACTIVE : '', (_this.attrs.ww && _this.attrs.ww.divider) ? exports.DIVIDER : ''),
                content: {
                    render: function () {
                        if (_this.attrs.ww && _this.attrs.ww.divider)
                            return [];
                        else if (_this.attrs.ww && _this.attrs.ww.text)
                            return [document.createTextNode(_this.attrs.ww.text)];
                        else
                            return _this.children;
                    }
                }
            }
        };
        return _this;
    }
    Item.prototype.activate = function () {
        active_1.activate(this.view, this.values.root.wml.id);
        return this;
    };
    Item.prototype.deactivate = function () {
        active_1.deactivate(this.view, this.values.root.wml.id);
        return this;
    };
    return Item;
}(wml.Component));
exports.Item = Item;

},{"../../content/state/active":17,"../../util":138,"./wml/item":132,"@quenk/wml":145}],132:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('li', { html: { 'id': __context.values.root.id, 'class': __context.values.root.className }, wml: { 'id': __context.values.root.wml.id } }, __spreadArrays((__context.values.root.content.render())));
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":141}],133:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var hidden = require("../../content/state/hidden");
var headerViews = require("./wml/header");
var wml_1 = require("@quenk/wml");
var util_1 = require("../../util");
var orientation_1 = require("../../content/orientation");
var __1 = require("../../");
var menu_1 = require("./wml/menu");
///classNames:begin
exports.MENU = 'ww-menu';
exports.MENU_HEADER_ITEM = 'ww-menu__header-item';
///classNames:end
exports.NAV_MODE = 'nav';
exports.CONTENT_MODE = 'content';
/**
 * HeaderItem
 */
var HeaderItem = /** @class */ (function (_super) {
    __extends(HeaderItem, _super);
    function HeaderItem() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new headerViews.Main(_this);
        _this.values = {
            root: {
                className: util_1.concat(exports.MENU_HEADER_ITEM, __1.getClassName(_this.attrs)),
                content: (_this.attrs.ww && _this.attrs.ww.text) ?
                    [__1.text(_this.attrs.ww.text)] : _this.children
            }
        };
        return _this;
    }
    return HeaderItem;
}(wml_1.Component));
exports.HeaderItem = HeaderItem;
/**
 * Menu provides a DOM container for rendering
 * a dropdown style menu.
 */
var Menu = /** @class */ (function (_super) {
    __extends(Menu, _super);
    function Menu() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new menu_1.Main(_this);
        _this.values = {
            root: {
                wml: {
                    id: 'root'
                },
                id: __1.getId(_this.attrs),
                className: util_1.concat(exports.MENU, __1.getClassName(_this.attrs), (_this.attrs.ww && _this.attrs.ww.hidden) ? hidden.HIDDEN : '', (_this.attrs.ww && _this.attrs.ww.block) ? orientation_1.BLOCK : '')
            },
            menu: {
                id: 'menu'
            },
            content: function () { return _this.children; }
        };
        return _this;
    }
    Menu.prototype.isHidden = function () {
        return hidden.isHidden(this.view, this.values.root.wml.id);
    };
    Menu.prototype.hide = function () {
        hidden.hide(this.view, this.values.root.wml.id);
        return this;
    };
    Menu.prototype.show = function () {
        hidden.show(this.view, this.values.root.wml.id);
        return this;
    };
    Menu.prototype.toggle = function () {
        hidden.toggle(this.view, this.values.root.wml.id);
        return this;
    };
    Menu.prototype.setContent = function (content) {
        this.values.content = function () { return content; };
        this.view.invalidate();
        this.show();
        return this;
    };
    return Menu;
}(wml_1.Component));
exports.Menu = Menu;

},{"../../":101,"../../content/orientation":13,"../../content/state/hidden":18,"../../util":138,"./wml/header":134,"./wml/menu":135,"@quenk/wml":145}],134:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('li', { html: { 'class': __context.values.root.className }, wml: {} }, __spreadArrays((__context.values.root.content)));
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":141}],135:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('ul', { html: { 'id': __context.values.root.id, 'class': __context.values.root.className }, wml: { 'id': __context.values.root.wml.id } }, __spreadArrays((__context.values.content())));
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":141}],136:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml = require("@quenk/wml");
var util = require("../../util");
var views = require("./wml/nav");
var orientation_1 = require("../../content/orientation");
var item_1 = require("../item");
exports.Item = item_1.Item;
var link_1 = require("../../content/link");
exports.Link = link_1.Link;
///classNames:begin
/**
 * NAV
 */
exports.NAV = 'ww-nav';
/**
 * Nav provides styling for displaying a list of anchor links.
 */
var Nav = /** @class */ (function (_super) {
    __extends(Nav, _super);
    function Nav() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: {
                id: (_this.attrs.ww && _this.attrs.ww.id) ? _this.attrs.ww.id : '',
                className: util.concat(exports.NAV, (_this.attrs.ww && _this.attrs.ww.className) ?
                    _this.attrs.ww.className : '', (_this.attrs.ww && _this.attrs.ww.vertical) ?
                    orientation_1.VERTICAL : '')
            }
        };
        return _this;
    }
    return Nav;
}(wml.Component));
exports.Nav = Nav;

},{"../../content/link":7,"../../content/orientation":13,"../../util":138,"../item":131,"./wml/nav":137,"@quenk/wml":145}],137:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.node('ul', { html: { 'id': __context.values.root.id, 'class': __context.values.root.className }, wml: {} }, __spreadArrays((__context.children)));
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"@quenk/noni/lib/data/maybe":141}],138:[function(require,module,exports){
"use strict";
/**
 * This module provides utility functions and constants used
 * through out the wml-widgets module.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * getById retreives an WMLElement from a view by its id.
 *
 * If the WMLElement is not found a warning is logged to console.
 */
exports.getById = function (view, id) {
    var m = view.findById(id);
    if (m.isNothing()) {
        exports.warnMissing(view, id);
    }
    return m;
};
/**
 * warn via console that an element is missing.
 */
exports.warnMissing = function (view, id) {
    console.warn('The view ', view, " does not have an id \"" + id + "\"!");
};
/**
 * combine the members of an array into one string.
 */
exports.combine = function (str, joiner) {
    if (joiner === void 0) { joiner = ' '; }
    return str.filter(function (s) { return ((s != null) || s != ''); }).join(joiner);
};
/**
 * concat joins various strings together to form an html class attribute value.
 *
 * Removes empty strings, null and undefined values.
 */
exports.concat = function () {
    var str = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        str[_i] = arguments[_i];
    }
    return str.filter(function (s) { return ((s == null) || (s == '')) ? false : true; })
        .map(function (s) { return s.trim(); }).join(' ');
};
/**
 * noop
 */
exports.noop = function () { };
/**
 * replaceContent
 */
exports.replaceContent = function (r, node) {
    while (node.lastChild)
        node.removeChild(node.lastChild);
    node.appendChild(r.render());
};
/**
 * debounce a function so that it is only called once after
 * a period of time.
 */
exports.debounce = function (f, delay) {
    var timer = -1;
    return delay === 0 ? f : function (a) {
        if (timer === -1) {
            timer = window.setTimeout(function () { return f(a); }, delay);
        }
        else {
            clearTimeout(timer);
            timer = window.setTimeout(function () { return f(a); }, delay);
        }
    };
};

},{}],139:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The array module provides helper functions
 * for working with JS arrays.
 */
var record_1 = require("../record");
var math_1 = require("../../math");
/**
 * head returns the item at index 0 of an array
 */
exports.head = function (list) { return list[0]; };
/**
 * tail returns the last item in an array
 */
exports.tail = function (list) { return list[list.length - 1]; };
/**
 * empty indicates whether an array is empty or not.
 */
exports.empty = function (list) { return (list.length === 0); };
/**
 * contains indicates whether an element exists in an array.
 */
exports.contains = function (list) { return function (a) { return (list.indexOf(a) > -1); }; };
/**
 * map is a curried version of the Array#map method.
 */
exports.map = function (list) { return function (f) { return list.map(f); }; };
/**
 * concat concatenates an element to an array without destructuring
 * the element if itself is an array.
 */
exports.concat = function (list, a) { return __spreadArrays(list, [a]); };
/**
 * partition an array into two using a partitioning function.
 *
 * The first array contains values that return true and the second false.
 */
exports.partition = function (list) { return function (f) { return exports.empty(list) ?
    [[], []] :
    list.reduce(function (_a, c, i) {
        var yes = _a[0], no = _a[1];
        return (f(c, i, list) ?
            [exports.concat(yes, c), no] :
            [yes, exports.concat(no, c)]);
    }, [[], []]); }; };
/**
 * group the elements of an array into a Record where each property
 * is an array of elements assigned to it's property name.
 */
exports.group = function (list) { return function (f) {
    return list.reduce(function (p, c, i) {
        var _a;
        var g = f(c, i, list);
        return record_1.merge(p, (_a = {},
            _a[g] = Array.isArray(p[g]) ?
                exports.concat(p[g], c) : [c],
            _a));
    }, {});
}; };
/**
 * distribute breaks an array into an array of equally (approximate) sized
 * smaller arrays.
 */
exports.distribute = function (list, size) {
    var r = list.reduce(function (p, c, i) {
        return math_1.isMultipleOf(size, i + 1) ?
            [exports.concat(p[0], exports.concat(p[1], c)), []] :
            [p[0], exports.concat(p[1], c)];
    }, [[], []]);
    return (r[1].length === 0) ? r[0] : exports.concat(r[0], r[1]);
};
/**
 * dedupe an array by filtering out elements
 * that appear twice.
 */
exports.dedupe = function (list) {
    return list.filter(function (e, i, l) { return l.indexOf(e) === i; });
};
/**
 * remove an element from an array returning a new copy with the element
 * removed.
 */
exports.remove = function (list, target) {
    var idx = list.indexOf(target);
    if (idx === -1) {
        return list.slice();
    }
    else {
        var a = list.slice();
        a.splice(idx, 1);
        return a;
    }
};
/**
 * removeAt removes an element at the specified index returning a copy
 * of the original array with the element removed.
 */
exports.removeAt = function (list, idx) {
    if ((list.length > idx) && (idx > -1)) {
        var a = list.slice();
        a.splice(idx, 1);
        return a;
    }
    else {
        return list.slice();
    }
};
/**
 * make an array of elements of a given size using a function to provide
 * each element.
 *
 * The function receives the index number for each step.
 */
exports.make = function (size, f) {
    var a = new Array(size);
    for (var i = 0; i < size; i++)
        a[i] = f(i);
    return a;
};

},{"../../math":144,"../record":142}],140:[function(require,module,exports){
"use strict";
/**
 * Useful functions for sorting data in an array.
 *
 * The functions are expected to be passed to Array#sort.
 * Defaults to ascending order unless specified otherwise.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * date sorts two strings representing dates.
 *
 * The dates are passed to the date constructor.
 */
exports.date = function (a, b) {
    var na = new Date(a).getTime();
    var nb = new Date(b).getTime();
    return na > nb ? -1 : na < nb ? 1 : 0;
};
/**
 * string sorts two strings by first lower casing them.
 */
exports.string = function (a, b) {
    var la = String(a).replace(/\s+/, '').toLowerCase();
    var lb = String(b).replace(/\s+/, '').toLowerCase();
    return (la > lb) ? -1 : (la < lb) ? 1 : 0;
};
/**
 * number sort
 */
exports.number = function (a, b) {
    var na = parseFloat(a);
    var nb = parseFloat(b);
    na = (isNaN(a)) ? -Infinity : a;
    nb = (isNaN(b)) ? -Infinity : b;
    return (na > nb) ? -1 : (na < nb) ? 1 : 0;
};
/**
 * natural sort impelmentation.
 */
exports.natural = function (a, b) {
    if (a === void 0) { a = ''; }
    if (b === void 0) { b = ''; }
    var reA = /[^a-zA-Z]/g;
    var reN = /[^0-9]/g;
    var aInt = parseInt(a, 10);
    var bInt = parseInt(b, 10);
    if (isNaN(aInt) && isNaN(bInt)) {
        var aA = String(a).replace(reA, '');
        var bA = String(b).replace(reA, '');
        if (aA === bA) {
            var aN = parseInt(String(a).replace(reN, ''), 10);
            var bN = parseInt(String(b).replace(reN, ''), 10);
            return aN === bN ? 0 : aN > bN ? -1 : 1;
        }
        else {
            return aA > bA ? -1 : 1;
        }
    }
    else if (isNaN(aInt)) { //A is not an Int
        return -1; //to make alphanumeric sort first return -1 here
    }
    else if (isNaN(bInt)) { //B is not an Int
        return 1; //to make alphanumeric sort first return 1 here
    }
    else {
        return aInt > bInt ? -1 : 1;
    }
};

},{}],141:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Nothing represents the absence of a usable value.
 */
var Nothing = /** @class */ (function () {
    function Nothing() {
    }
    /**
     * map simply returns a Nothing<A>
     */
    Nothing.prototype.map = function (_) {
        return new Nothing();
    };
    /**
     * ap allows for a function wrapped in a Just to apply
     * to value present in this Just.
     */
    Nothing.prototype.ap = function (_) {
        return new Nothing();
    };
    /**
     * of wraps a value in a Just.
     */
    Nothing.prototype.of = function (a) {
        return new Just(a);
    };
    /**
     * chain simply returns a Nothing<A>.
     */
    Nothing.prototype.chain = function (_) {
        return new Nothing();
    };
    /**
     * alt will prefer whatever Maybe instance provided.
     */
    Nothing.prototype.alt = function (a) {
        return a;
    };
    /**
     * empty provides a default Maybe.
     * Maybe.empty() = new Nothing()
     */
    Nothing.prototype.empty = function () {
        return new Nothing();
    };
    /**
     * extend returns a Nothing<A>.
     */
    Nothing.prototype.extend = function (_) {
        return new Nothing();
    };
    /**
     * eq returns true if compared to another Nothing instance.
     */
    Nothing.prototype.eq = function (m) {
        return m instanceof Nothing;
    };
    /**
     * orJust converts a Nothing<A> to a Just
     * using the value from the provided function.
     */
    Nothing.prototype.orJust = function (f) {
        return new Just(f());
    };
    /**
     * orElse allows an alternative Maybe value
     * to be provided since this one is Nothing<A>.
     */
    Nothing.prototype.orElse = function (f) {
        return f();
    };
    Nothing.prototype.isNothing = function () {
        return true;
    };
    Nothing.prototype.isJust = function () {
        return false;
    };
    /**
     * get throws an error because there
     * is nothing here to get.
     */
    Nothing.prototype.get = function () {
        throw new TypeError('Cannot get a value from Nothing!');
    };
    return Nothing;
}());
exports.Nothing = Nothing;
/**
 * Just represents the presence of a usable value.
 */
var Just = /** @class */ (function () {
    function Just(value) {
        this.value = value;
    }
    /**
     * map over the value present in the Just.
     */
    Just.prototype.map = function (f) {
        return new Just(f(this.value));
    };
    /**
     * ap allows for a function wrapped in a Just to apply
     * to value present in this Just.
     */
    Just.prototype.ap = function (mb) {
        var _this = this;
        return mb.map(function (f) { return f(_this.value); });
    };
    /**
     * of wraps a value in a Just.
     */
    Just.prototype.of = function (a) {
        return new Just(a);
    };
    /**
     * chain allows the sequencing of functions that return a Maybe.
     */
    Just.prototype.chain = function (f) {
        return f(this.value);
    };
    /**
     * alt will prefer the first Just encountered (this).
     */
    Just.prototype.alt = function (_) {
        return this;
    };
    /**
     * empty provides a default Maybe.
     * Maybe.empty() = new Nothing()
     */
    Just.prototype.empty = function () {
        return new Nothing();
    };
    /**
     * extend allows sequencing of Maybes with
     * functions that unwrap into non Maybe types.
     */
    Just.prototype.extend = function (f) {
        return new Just(f(this));
    };
    /**
     * eq tests the value of two Justs.
     */
    Just.prototype.eq = function (m) {
        return ((m instanceof Just) && (m.value === this.value));
    };
    /**
     * orJust returns this Just.
     */
    Just.prototype.orJust = function (_) {
        return this;
    };
    /**
     * orElse returns this Just
     */
    Just.prototype.orElse = function (_) {
        return this;
    };
    Just.prototype.isNothing = function () {
        return false;
    };
    Just.prototype.isJust = function () {
        return true;
    };
    /**
     * get the value of this Just.
     */
    Just.prototype.get = function () {
        return this.value;
    };
    return Just;
}());
exports.Just = Just;
/**
 * of
 */
exports.of = function (a) { return new Just(a); };
/**
 * nothing convenience constructor
 */
exports.nothing = function () { return new Nothing(); };
/**
 * just convenience constructor
 */
exports.just = function (a) { return new Just(a); };
/**
 * fromNullable constructs a Maybe from a value that may be null.
 */
exports.fromNullable = function (a) { return a == null ?
    new Nothing() : new Just(a); };
/**
 * fromArray checks an array to see if it's empty
 *
 * Returns [[Nothing]] if it is, [[Just]] otherwise.
 */
exports.fromArray = function (a) {
    return (a.length === 0) ? new Nothing() : new Just(a);
};
/**
 * fromObject uses Object.keys to turn see if an object
 * has any own properties.
 */
exports.fromObject = function (o) {
    return Object.keys(o).length === 0 ? new Nothing() : new Just(o);
};
/**
 * fromString constructs Nothing<A> if the string is empty or Just<A> otherwise.
 */
exports.fromString = function (s) {
    return (s === '') ? new Nothing() : new Just(s);
};
/**
 * fromBoolean constructs Nothing if b is false, Just<A> otherwise
 */
exports.fromBoolean = function (b) {
    return (b === false) ? new Nothing() : new Just(b);
};
/**
 * fromNumber constructs Nothing if n is 0 Just<A> otherwise.
 */
exports.fromNumber = function (n) {
    return (n === 0) ? new Nothing() : new Just(n);
};
/**
 * fromNaN constructs Nothing if a value is not a number or
 * Just<A> otherwise.
 */
exports.fromNaN = function (n) {
    return isNaN(n) ? new Nothing() : new Just(n);
};

},{}],142:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The record module provides functions for treating ES objects as records.
 *
 * Some of the functions provided here are inherently unsafe (tsc will not
 * be able track integrity and may result in runtime errors if not used carefully.
 */
var array_1 = require("../array");
/**
 * assign polyfill.
 */
function assign(target) {
    var _varArgs = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        _varArgs[_i - 1] = arguments[_i];
    }
    if (target == null)
        throw new TypeError('Cannot convert undefined or null to object');
    var to = Object(target);
    for (var index = 1; index < arguments.length; index++) {
        var nextSource = arguments[index];
        if (nextSource != null) {
            for (var nextKey in nextSource) {
                // Avoid bugs when hasOwnProperty is shadowed
                if (Object.prototype.hasOwnProperty.call(nextSource, nextKey))
                    to[nextKey] = nextSource[nextKey];
            }
        }
    }
    return to;
}
exports.assign = assign;
/**
 * isRecord tests whether a value is a record.
 *
 * This is a typeof check that excludes arrays.
 *
 * Unsafe.
 */
exports.isRecord = function (value) {
    return (typeof value === 'object') && (!Array.isArray(value));
};
/**
 * keys produces a list of property names from a Record.
 */
exports.keys = function (value) { return Object.keys(value); };
/**
 * map over a Record's properties producing a new record.
 *
 * The order of keys processed is not guaranteed.
 */
exports.map = function (o, f) {
    return exports.keys(o).reduce(function (p, k) {
        var _a;
        return exports.merge(p, (_a = {}, _a[k] = f(o[k], k, o), _a));
    }, {});
};
/**
 * reduce a Record's keys to a single value.
 *
 * The initial value (accum) must be supplied to avoid errors when
 * there are no properites on the Record.
 * The order of keys processed is not guaranteed.
 */
exports.reduce = function (o, accum, f) {
    return exports.keys(o).reduce(function (p, k) { return f(p, o[k], k); }, accum);
};
/**
 * filter the keys of a record using a filter function.
 */
exports.filter = function (o, f) {
    return exports.keys(o).reduce(function (p, k) {
        var _a;
        return f(o[k], k, o) ? exports.merge(p, (_a = {}, _a[k] = o[k], _a)) : p;
    }, {});
};
/**
 * merge two objects into one.
 *
 * The return value's type is the product of the two types supplied.
 * This function may be unsafe.
 */
exports.merge = function (left, right) { return assign({}, left, right); };
/**
 * merge3 merges 3 records into one.
 */
exports.merge3 = function (a, b, c) { return assign({}, a, b, c); };
/**
 * merge4 merges 4 records into one.
 */
exports.merge4 = function (a, b, c, d) {
    return assign({}, a, b, c, d);
};
/**
 * merge5 merges 5 records into one.
 */
exports.merge5 = function (a, b, c, d, e) { return assign({}, a, b, c, d, e); };
/**
 * rmerge merges 2 records recursively.
 *
 * This function may be unsafe.
 */
exports.rmerge = function (left, right) {
    return exports.reduce(right, left, deepMerge);
};
/**
 * rmerge3 merges 3 records recursively.
 */
exports.rmerge3 = function (r, s, t) {
    return [s, t]
        .reduce(function (p, c) {
        return exports.reduce(c, (p), deepMerge);
    }, r);
};
/**
 * rmerge4 merges 4 records recursively.
 */
exports.rmerge4 = function (r, s, t, u) {
    return [s, t, u]
        .reduce(function (p, c) {
        return exports.reduce(c, (p), deepMerge);
    }, r);
};
/**
 * rmerge5 merges 5 records recursively.
 */
exports.rmerge5 = function (r, s, t, u, v) {
    return [s, t, u, v]
        .reduce(function (p, c) {
        return exports.reduce(c, (p), deepMerge);
    }, r);
};
var deepMerge = function (pre, curr, key) {
    var _a, _b;
    return exports.isRecord(curr) ?
        exports.merge(pre, (_a = {},
            _a[key] = exports.isRecord(pre[key]) ?
                exports.rmerge(pre[key], curr) :
                curr,
            _a)) :
        exports.merge(pre, (_b = {}, _b[key] = curr, _b));
};
/**
 * exclude removes the specified properties from a Record.
 */
exports.exclude = function (o, keys) {
    var list = Array.isArray(keys) ? keys : [keys];
    return exports.reduce(o, {}, function (p, c, k) {
        var _a;
        return list.indexOf(k) > -1 ? p : exports.merge(p, (_a = {}, _a[k] = c, _a));
    });
};
/**
 * partition a Record into two sub-records using a separating function.
 *
 * This function produces an array where the first element is a record
 * of passing values and the second the failing values.
 */
exports.partition = function (r, f) {
    return exports.reduce(r, [{}, {}], function (_a, c, k) {
        var _b, _c;
        var yes = _a[0], no = _a[1];
        return f(c, k, r) ?
            [exports.merge(yes, (_b = {}, _b[k] = c, _b)), no] :
            [yes, exports.merge(no, (_c = {}, _c[k] = c, _c))];
    });
};
/**
 * group the properties of a Record into another Record using a grouping
 * function.
 */
exports.group = function (r, f) {
    return exports.reduce(r, {}, function (p, c, k) {
        var _a, _b, _c;
        var g = f(c, k, r);
        return exports.merge(p, (_a = {},
            _a[g] = exports.isRecord(p[g]) ?
                exports.merge(p[g], (_b = {}, _b[k] = c, _b)) : (_c = {}, _c[k] = c, _c),
            _a));
    });
};
/**
 * values returns a shallow array of the values of a record.
 */
exports.values = function (r) {
    return exports.reduce(r, [], function (p, c) { return array_1.concat(p, c); });
};
/**
 * contains indicates whether a Record has a given key.
 */
exports.contains = function (r, key) {
    return Object.hasOwnProperty.call(r, key);
};
/**
 * clone a Record.
 *
 * Breaks references and deep clones arrays.
 * This function should only be used on Records or objects that
 * are not class instances.
 */
exports.clone = function (r) {
    return exports.reduce(r, {}, function (p, c, k) { p[k] = _clone(c); return p; });
};
var _clone = function (a) {
    if (Array.isArray(a))
        return a.map(_clone);
    else if (typeof a === 'object')
        return exports.clone(a);
    else
        return a;
};

},{"../array":139}],143:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This module provides a syntax and associated functions for
 * getting and setting values on ES objects easily.
 *
 * Given a path, a value can either be retrieved or set on an object.
 *
 * The path syntax follows typical ES dot notation, bracket notation or a mixture
 * of both.
 *
 * Note that quotes are not used when describing a path via bracket notation.
 *
 * If you need to use a dot or square brackets in your paths, prefix them with
 * the "\" (backslash) character.
 */
/** imports **/
var maybe_1 = require("../maybe");
var _1 = require("./");
var TOKEN_DOT = '.';
var TOKEN_BRACKET_LEFT = '[';
var TOKEN_BRACKET_RIGHT = ']';
var TOKEN_ESCAPE = '\\';
/**
 * tokenize a path into a list of sequential property names.
 */
exports.tokenize = function (str) {
    var i = 0;
    var buf = '';
    var curr = '';
    var next = '';
    var tokens = [];
    while (i < str.length) {
        curr = str[i];
        next = str[i + 1];
        if (curr === TOKEN_ESCAPE) {
            //escape sequence
            buf = "" + buf + next;
            i++;
        }
        else if (curr === TOKEN_DOT) {
            if (buf !== '')
                tokens.push(buf); //recognize a path and push a new token
            buf = '';
        }
        else if ((curr === TOKEN_BRACKET_LEFT) &&
            next === TOKEN_BRACKET_RIGHT) {
            //intercept empty bracket paths
            i++;
        }
        else if (curr === TOKEN_BRACKET_LEFT) {
            var bracketBuf = '';
            var firstDot = -1;
            var firstDotBuf = '';
            i++;
            while (true) {
                //everything between brackets is treated as a path
                //if no closing bracket is found, we back track to the first dot
                //if there is no dot the whole buffer is treated as a path
                curr = str[i];
                next = str[i + 1];
                if ((curr === TOKEN_BRACKET_RIGHT) &&
                    (next === TOKEN_BRACKET_RIGHT)) {
                    //escaped right bracket
                    bracketBuf = "" + bracketBuf + TOKEN_BRACKET_RIGHT;
                    i++;
                }
                else if (curr === TOKEN_BRACKET_RIGHT) {
                    //successfully tokenized the path
                    if (buf !== '')
                        tokens.push(buf); //save the previous path
                    tokens.push(bracketBuf); //save the current path
                    buf = '';
                    break;
                }
                else if (curr == null) {
                    //no closing bracket found and we ran out of string to search
                    if (firstDot !== -1) {
                        //backtrack to the first dot encountered
                        i = firstDot;
                        //save the paths so far
                        tokens.push("" + buf + TOKEN_BRACKET_LEFT + firstDotBuf);
                        buf = '';
                        break;
                    }
                    else {
                        //else if no dots were found treat the current buffer
                        // and rest of the string as part of one path.
                        buf = "" + buf + TOKEN_BRACKET_LEFT + bracketBuf;
                        break;
                    }
                }
                if ((curr === TOKEN_DOT) && (firstDot === -1)) {
                    //take note of the location and tokens between 
                    //the opening bracket and first dot.
                    //If there is no closing bracket, we use this info to
                    //lex properly.
                    firstDot = i;
                    firstDotBuf = bracketBuf;
                }
                bracketBuf = "" + bracketBuf + curr;
                i++;
            }
        }
        else {
            buf = "" + buf + curr;
        }
        i++;
    }
    if ((buf.length > 0))
        tokens.push(buf);
    return tokens;
};
/**
 * unsafeGet retrieves a value at the specified path
 * on any ES object.
 *
 * This function does not check if getting the value succeeded or not.
 */
exports.unsafeGet = function (path, src) {
    if (src == null)
        return undefined;
    var toks = exports.tokenize(path);
    var head = src[toks.shift()];
    return toks.reduce(function (p, c) { return (p == null) ? p : p[c]; }, head);
};
/**
 * get a value from a Record given its path safely.
 */
exports.get = function (path, src) {
    return maybe_1.fromNullable(exports.unsafeGet(path, src));
};
/**
 * getDefault is like get but takes a default value to return if
 * the path is not found.
 */
exports.getDefault = function (path, src, def) {
    return exports.get(path, src).orJust(function () { return def; }).get();
};
/**
 * getString casts the resulting value to a string.
 *
 * An empty string is provided if the path is not found.
 */
exports.getString = function (path, src) {
    return exports.get(path, src).map(function (v) { return String(v); }).orJust(function () { return ''; }).get();
};
/**
 * set sets a value on an object given a path.
 */
exports.set = function (p, v, r) {
    var toks = exports.tokenize(p);
    return _set(r, v, toks);
};
var _set = function (r, value, toks) {
    var o;
    if (toks.length === 0)
        return value;
    o = _1.isRecord(r) ? _1.clone(r) : {};
    o[toks[0]] = _set(o[toks[0]], value, toks.slice(1));
    return o;
};
/**
 * escape a path so that occurences of dots are not interpreted as paths.
 *
 * This function escapes dots and dots only.
 */
exports.escape = function (p) {
    var i = 0;
    var buf = '';
    var curr = '';
    while (i < p.length) {
        curr = p[i];
        if ((curr === TOKEN_ESCAPE) || (curr === TOKEN_DOT))
            buf = "" + buf + TOKEN_ESCAPE + curr;
        else
            buf = "" + buf + curr;
        i++;
    }
    return buf;
};
/**
 * unescape a path that has been previously escaped.
 */
exports.unescape = function (p) {
    var i = 0;
    var curr = '';
    var next = '';
    var buf = '';
    while (i < p.length) {
        curr = p[i];
        next = p[i + 1];
        if (curr === TOKEN_ESCAPE) {
            buf = "" + buf + next;
            i++;
        }
        else {
            buf = "" + buf + curr;
        }
        i++;
    }
    return buf;
};
/**
 * escapeRecord escapes each property of a record recursively.
 */
exports.escapeRecord = function (r) {
    return _1.reduce(r, {}, function (p, c, k) {
        if (typeof c === 'object')
            p[exports.escape(k)] = exports.escapeRecord(c);
        else
            p[exports.escape(k)] = c;
        return p;
    });
};
/**
 * unescapeRecord unescapes each property of a record recursively.
 */
exports.unescapeRecord = function (r) {
    return _1.reduce(r, {}, function (p, c, k) {
        if (_1.isRecord(c))
            p[exports.unescape(k)] = exports.unescapeRecord(c);
        else
            p[exports.unescape(k)] = c;
        return p;
    });
};
/**
 * flatten an object into a Record where each key is a path to a non-complex
 * value or array.
 *
 * If any of the paths contain dots, they will be escaped.
 */
exports.flatten = function (r) {
    return (flatImpl('')({})(r));
};
var flatImpl = function (pfix) { return function (prev) {
    return function (r) {
        return _1.reduce(r, prev, function (p, c, k) {
            var _a;
            return _1.isRecord(c) ?
                (flatImpl(prefix(pfix, k))(p)(c)) :
                _1.merge(p, (_a = {}, _a[prefix(pfix, k)] = c, _a));
        });
    };
}; };
var prefix = function (pfix, key) { return (pfix === '') ?
    exports.escape(key) : pfix + "." + exports.escape(key); };
/**
 * unflatten a flattened Record so that any nested paths are expanded
 * to their full representation.
 */
exports.unflatten = function (r) {
    return _1.reduce(r, {}, function (p, c, k) { return exports.set(k, c, p); });
};
/**
 * intersect set operation between the keys of two records.
 *
 * All the properties of the left record that have matching property
 * names in the right are retained.
 */
exports.intersect = function (a, b) {
    return _1.reduce(a, {}, function (p, c, k) {
        if (b.hasOwnProperty(k))
            p[k] = c;
        return p;
    });
};
/**
 * difference set operation between the keys of two records.
 *
 * All the properties on the left record that do not have matching
 * property names in the right are retained.
 */
exports.difference = function (a, b) {
    return _1.reduce(a, {}, function (p, c, k) {
        if (!b.hasOwnProperty(k))
            p[k] = c;
        return p;
    });
};
/**
 * map over the property names of a record.
 */
exports.map = function (a, f) {
    return _1.reduce(a, {}, function (p, c, k) {
        p[f(k)] = c;
        return p;
    });
};
/**
 * project a Record according to the field specification given.
 *
 * Only properties that appear in the spec and set to true will be retained.
 * This function is not safe. It may leave undefined values in the resulting
 * record.
 */
exports.project = function (spec, rec) {
    return _1.reduce(spec, {}, function (p, c, k) {
        return (c === true) ? exports.set(k, exports.unsafeGet(k, rec), p) : p;
    });
};

},{"../maybe":141,"./":142}],144:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * isMultipleOf tests whether the Integer 'y' is a multiple of x.
 */
exports.isMultipleOf = function (x, y) { return ((y % x) === 0); };

},{}],145:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
;
/**
 * Component is an abstract Widget implementation
 * that can be used instead of manually implementing the whole interface.
 */
var Component = /** @class */ (function () {
    /**
     * @param {A} attrs is the attributes this Component excepts.
     * @param {Content[]} children is an array of content for Component.
     */
    function Component(attrs, children) {
        this.attrs = attrs;
        this.children = children;
    }
    Component.prototype.rendered = function () { };
    Component.prototype.removed = function () { };
    Component.prototype.render = function () { return this.view.render(); };
    return Component;
}());
exports.Component = Component;
;

},{}],146:[function(require,module,exports){
//! moment.js

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

    var hookCallback;

    function hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isObject(input) {
        // IE8 will treat undefined and null as object if it wasn't for
        // input != null
        return input != null && Object.prototype.toString.call(input) === '[object Object]';
    }

    function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
            return (Object.getOwnPropertyNames(obj).length === 0);
        } else {
            var k;
            for (k in obj) {
                if (obj.hasOwnProperty(k)) {
                    return false;
                }
            }
            return true;
        }
    }

    function isUndefined(input) {
        return input === void 0;
    }

    function isNumber(input) {
        return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false,
            parsedDateParts : [],
            meridiem        : null,
            rfc2822         : false,
            weekdayMismatch : false
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this);
            var len = t.length >>> 0;

            for (var i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            var parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
            });
            var isNowValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.weekdayMismatch &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated &&
                (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                isNowValid = isNowValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }

            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            }
            else {
                return isNowValid;
            }
        }
        return m._isValid;
    }

    function createInvalid (flags) {
        var m = createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i = 0; i < momentProperties.length; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false &&
                (typeof console !==  'undefined') && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [];
                var arg;
                for (var i = 0; i < arguments.length; i++) {
                    arg = '';
                    if (typeof arguments[i] === 'object') {
                        arg += '\n[' + i + '] ';
                        for (var key in arguments[0]) {
                            arg += key + ': ' + arguments[0][key] + ', ';
                        }
                        arg = arg.slice(0, -2); // Remove trailing comma and space
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (isFunction(prop)) {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
        // TODO: Remove "ordinalParse" fallback in next major release.
        this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                '|' + (/\d{1,2}/).source);
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) &&
                    !hasOwnProp(childConfig, prop) &&
                    isObject(parentConfig[prop])) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i, res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function calendar (key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        ss : '%d seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (isFunction(output)) ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
        var units = [];
        for (var u in unitsObj) {
            units.push({unit: u, priority: priorities[u]});
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '', i;
            for (i = 0; i < length; i++) {
                output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months
    var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;

    var regexes = {};

    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (isNumber(callback)) {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PRIORITIES

    addUnitPriority('year', 1);

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                set$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get(this, unit);
            }
        };
    }

    function get (mom, unit) {
        return mom.isValid() ?
            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function set$1 (mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
            if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
            }
            else {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
            }
        }
    }

    // MOMENTS

    function stringGet (units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }


    function stringSet (units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units);
            for (var i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    function mod(n, x) {
        return ((n % x) + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
            return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PRIORITY

    addUnitPriority('month', 8);

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m, format) {
        if (!m) {
            return isArray(this._months) ? this._months :
                this._months['standalone'];
        }
        return isArray(this._months) ? this._months[m.month()] :
            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m, format) {
        if (!m) {
            return isArray(this._monthsShort) ? this._monthsShort :
                this._monthsShort['standalone'];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (!isNumber(value)) {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
        } else {
            return get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;
    function monthsShortRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ?
                this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }

    var defaultMonthsRegex = matchWord;
    function monthsRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ?
                this._monthsStrictRegex : this._monthsRegex;
        }
    }

    function computeMonthsParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    function createDate (y, m, d, h, M, s, ms) {
        // can't just apply() to create a date:
        // https://stackoverflow.com/q/181348
        var date;
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
                date.setFullYear(y);
            }
        } else {
            date = new Date(y, m, d, h, M, s, ms);
        }

        return date;
    }

    function createUTCDate (y) {
        var date;
        // the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            var args = Array.prototype.slice.call(arguments);
            // preserve leap years using a full 400 year cycle, then reset
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
                date.setUTCFullYear(y);
            }
        } else {
            date = new Date(Date.UTC.apply(null, arguments));
        }

        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear, resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek, resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 6th is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PRIORITY
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd',   function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd',   function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES
    function shiftWeekdays (ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
    }

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m, format) {
        var weekdays = isArray(this._weekdays) ? this._weekdays :
            this._weekdays[(m && m !== true && this._weekdays.isFormat.test(format)) ? 'format' : 'standalone'];
        return (m === true) ? shiftWeekdays(weekdays, this._week.dow)
            : (m) ? weekdays[m.day()] : weekdays;
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return (m === true) ? shiftWeekdays(this._weekdaysShort, this._week.dow)
            : (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return (m === true) ? shiftWeekdays(this._weekdaysMin, this._week.dow)
            : (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse (weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    var defaultWeekdaysRegex = matchWord;
    function weekdaysRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ?
                this._weekdaysStrictRegex : this._weekdaysRegex;
        }
    }

    var defaultWeekdaysShortRegex = matchWord;
    function weekdaysShortRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ?
                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
    }

    var defaultWeekdaysMinRegex = matchWord;
    function weekdaysMinRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ?
                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
    }


    function computeWeekdaysParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);
            minp = this.weekdaysMin(mom, '');
            shortp = this.weekdaysShort(mom, '');
            longp = this.weekdays(mom, '');
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 7; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PRIORITY
    addUnitPriority('hour', 13);

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('k',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour they want. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse
    };

    // internal storage for locale config files
    var locales = {};
    var localeFamilies = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return globalLocale;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && (typeof module !== 'undefined') &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                var aliasedRequire = require;
                aliasedRequire('./locale/' + name);
                getSetGlobalLocale(oldLocale);
            } catch (e) {}
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
            else {
                if ((typeof console !==  'undefined') && console.warn) {
                    //warn user if arguments are passed but the locale could not be set
                    console.warn('Locale ' + key +  ' not found. Did you forget to load it?');
                }
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, config) {
        if (config !== null) {
            var locale, parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple('defineLocaleOverride',
                        'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    locale = loadLocale(config.parentLocale);
                    if (locale != null) {
                        parentConfig = locale._config;
                    } else {
                        if (!localeFamilies[config.parentLocale]) {
                            localeFamilies[config.parentLocale] = [];
                        }
                        localeFamilies[config.parentLocale].push({
                            name: name,
                            config: config
                        });
                        return null;
                    }
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            if (localeFamilies[name]) {
                localeFamilies[name].forEach(function (x) {
                    defineLocale(x.name, x.config);
                });
            }

            // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won't end up with the child locale set.
            getSetGlobalLocale(name);


            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale, tmpLocale, parentConfig = baseConfig;
            // MERGE
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;

            // backwards compat for now: also set the locale
            getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function listLocales() {
        return keys(locales);
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }

        // check for mismatching day of week
        if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
            getParsingFlags(config).weekdayMismatch = true;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            var curWeek = weekOfYear(createLocal(), dow, doy);

            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

            // Default to current week.
            week = defaults(w.w, curWeek.week);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from beginning of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to beginning of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
        ['YYYY-DDD', /\d{4}-\d{3}/],
        ['YYYY-MM', /\d{4}-\d\d/, false],
        ['YYYYYYMMDD', /[+-]\d{10}/],
        ['YYYYMMDD', /\d{8}/],
        // YYYYMM is NOT allowed by the standard
        ['GGGG[W]WWE', /\d{4}W\d{3}/],
        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
        ['YYYYDDD', /\d{7}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
        ['HH:mm', /\d\d:\d\d/],
        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
        ['HHmmss', /\d\d\d\d\d\d/],
        ['HHmm', /\d\d\d\d/],
        ['HH', /\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime, dateFormat, timeFormat, tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10)
        ];

        if (secondStr) {
            result.push(parseInt(secondStr, 10));
        }

        return result;
    }

    function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
            return 2000 + year;
        } else if (year <= 999) {
            return 1900 + year;
        }
        return year;
    }

    function preprocessRFC2822(s) {
        // Remove comments and folding whitespace and replace multiple-spaces with a single space
        return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
            // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
            if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
            }
        }
        return true;
    }

    var obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
    };

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
            return obsOffsets[obsOffset];
        } else if (militaryOffset) {
            // the only allowed military tz is Z
            return 0;
        } else {
            var hm = parseInt(numOffset, 10);
            var m = hm % 100, h = (hm - m) / 100;
            return h * 60 + m;
        }
    }

    // date and time from ref 2822 format
    function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i));
        if (match) {
            var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
            if (!checkWeekday(match[1], parsedArray, config)) {
                return;
            }

            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);

            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

            getParsingFlags(config).rfc2822 = true;
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        configFromRFC2822(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        // Final attempt, use Input Fallback
        hooks.createFromInputFallback(config);
    }

    hooks.createFromInputFallback = deprecate(
        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
        'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
        'discouraged and will be removed in an upcoming major release. Please refer to ' +
        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // constant that refers to the ISO standard
    hooks.ISO_8601 = function () {};

    // constant that refers to the RFC 2822 form
    hooks.RFC_2822 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            // console.log('token', token, 'parsedInput', parsedInput,
            //         'regex', getParseRegexForToken(token, config));
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
        });

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
            config._d = input;
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        }  else {
            configFromInput(config);
        }

        if (!isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
            config._d = new Date(hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (isObject(input)) {
            configFromObject(config);
        } else if (isNumber(input)) {
            // from milliseconds
            config._d = new Date(input);
        } else {
            hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
        }

        if ((isObject(input) && isObjectEmpty(input)) ||
                (isArray(input) && input.length === 0)) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other < this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other > this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +(new Date());
    };

    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

    function isDurationValid(m) {
        for (var key in m) {
            if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
                return false;
            }
        }

        var unitHasDecimal = false;
        for (var i = 0; i < ordering.length; ++i) {
            if (m[ordering[i]]) {
                if (unitHasDecimal) {
                    return false; // only allow non-integers for smallest unit
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                    unitHasDecimal = true;
                }
            }
        }

        return true;
    }

    function isValid$1() {
        return this._isValid;
    }

    function createInvalid$1() {
        return createDuration(NaN);
    }

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        this._isValid = isDurationValid(normalizedInput);

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible to translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    function absRound (number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // FORMATTING

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher);

        if (matches === null) {
            return null;
        }

        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return minutes === 0 ?
          0 :
          parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
        } else {
            return createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                    return this;
                }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    addSubtract(this, createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
                this.utcOffset(tZone);
            }
            else {
                this.utcOffset(0, true);
            }
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset () {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc () {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day
    var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (isNumber(input)) {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])                         * sign,
                h  : toInt(match[HOUR])                         * sign,
                m  : toInt(match[MINUTE])                       * sign,
                s  : toInt(match[SECOND])                       * sign,
                ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
            };
        } else if (!!(match = isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                w : parseIso(match[4], sign),
                d : parseIso(match[5], sign),
                h : parseIso(match[6], sign),
                m : parseIso(match[7], sign),
                s : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return {milliseconds: 0, months: 0};
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
        };
    }

    function addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
        }
        if (days) {
            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
        }
        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
            hooks.updateOffset(mom, days || months);
        }
    }

    var add      = createAdder(1, 'add');
    var subtract = createAdder(-1, 'subtract');

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
    }

    function calendar$1 (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = hooks.calendarFormat(this, sod) || 'sameElse';

        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween (from, to, units, inclusivity) {
        var localFrom = isMoment(from) ? from : createLocal(from),
            localTo = isMoment(to) ? to : createLocal(to);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
        }
        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) &&
            (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }

    function isSame (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
    }

    function isSameOrAfter (input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
    }

    function isSameOrBefore (input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
    }

    function diff (input, units, asFloat) {
        var that,
            zoneDelta,
            output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        switch (units) {
            case 'year': output = monthDiff(this, that) / 12; break;
            case 'month': output = monthDiff(this, that); break;
            case 'quarter': output = monthDiff(this, that) / 3; break;
            case 'second': output = (this - that) / 1e3; break; // 1000
            case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
            case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
            case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
            case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
            default: output = this - that;
        }

        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
        if (!this.isValid()) {
            return null;
        }
        var utc = keepOffset !== true;
        var m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
        }
        if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            if (utc) {
                return this.toDate().toISOString();
            } else {
                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
            }
        }
        return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }

    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */
    function inspect () {
        if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
        }
        var func = 'moment';
        var zone = '';
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
        }
        var prefix = '[' + func + '("]';
        var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
        var datetime = '-MM-DD[T]HH:mm:ss.SSS';
        var suffix = zone + '[")]';

        return this.format(prefix + year + datetime + suffix);
    }

    function format (inputString) {
        if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow (withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow (withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    var MS_PER_SECOND = 1000;
    var MS_PER_MINUTE = 60 * MS_PER_SECOND;
    var MS_PER_HOUR = 60 * MS_PER_MINUTE;
    var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

    // actual modulo - handles negative numbers (for dates before 1970):
    function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
    }

    function localStartOfDate(y, m, d) {
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return new Date(y, m, d).valueOf();
        }
    }

    function utcStartOfDate(y, m, d) {
        // Date.UTC remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return Date.UTC(y, m, d);
        }
    }

    function startOf (units) {
        var time;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year(), 0, 1);
                break;
            case 'quarter':
                time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
                break;
            case 'month':
                time = startOfDate(this.year(), this.month(), 1);
                break;
            case 'week':
                time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
                break;
            case 'isoWeek':
                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date());
                break;
            case 'hour':
                time = this._d.valueOf();
                time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
                break;
            case 'minute':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_MINUTE);
                break;
            case 'second':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_SECOND);
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function endOf (units) {
        var time;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year() + 1, 0, 1) - 1;
                break;
            case 'quarter':
                time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
                break;
            case 'month':
                time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                break;
            case 'week':
                time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
                break;
            case 'isoWeek':
                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                break;
            case 'hour':
                time = this._d.valueOf();
                time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
                break;
            case 'minute':
                time = this._d.valueOf();
                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                break;
            case 'second':
                time = this._d.valueOf();
                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function valueOf () {
        return this._d.valueOf() - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate () {
        return new Date(this.valueOf());
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function toJSON () {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2 () {
        return isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);


    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy);
    }

    function getSetISOWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PRIORITY

    addUnitPriority('quarter', 7);

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PRIORITY
    addUnitPriority('date', 9);

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        // TODO: Remove "ordinalParse" fallback in next major release.
        return isStrict ?
          (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
          locale._dayOfMonthOrdinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PRIORITY
    addUnitPriority('dayOfYear', 4);

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PRIORITY

    addUnitPriority('minute', 14);

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PRIORITY

    addUnitPriority('second', 15);

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PRIORITY

    addUnitPriority('millisecond', 16);

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto = Moment.prototype;

    proto.add               = add;
    proto.calendar          = calendar$1;
    proto.clone             = clone;
    proto.diff              = diff;
    proto.endOf             = endOf;
    proto.format            = format;
    proto.from              = from;
    proto.fromNow           = fromNow;
    proto.to                = to;
    proto.toNow             = toNow;
    proto.get               = stringGet;
    proto.invalidAt         = invalidAt;
    proto.isAfter           = isAfter;
    proto.isBefore          = isBefore;
    proto.isBetween         = isBetween;
    proto.isSame            = isSame;
    proto.isSameOrAfter     = isSameOrAfter;
    proto.isSameOrBefore    = isSameOrBefore;
    proto.isValid           = isValid$2;
    proto.lang              = lang;
    proto.locale            = locale;
    proto.localeData        = localeData;
    proto.max               = prototypeMax;
    proto.min               = prototypeMin;
    proto.parsingFlags      = parsingFlags;
    proto.set               = stringSet;
    proto.startOf           = startOf;
    proto.subtract          = subtract;
    proto.toArray           = toArray;
    proto.toObject          = toObject;
    proto.toDate            = toDate;
    proto.toISOString       = toISOString;
    proto.inspect           = inspect;
    proto.toJSON            = toJSON;
    proto.toString          = toString;
    proto.unix              = unix;
    proto.valueOf           = valueOf;
    proto.creationData      = creationData;
    proto.year       = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear    = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month       = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week           = proto.weeks        = getSetWeek;
    proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
    proto.weeksInYear    = getWeeksInYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.date       = getSetDayOfMonth;
    proto.day        = proto.days             = getSetDayOfWeek;
    proto.weekday    = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear  = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset            = getSetOffset;
    proto.utc                  = setOffsetToUTC;
    proto.local                = setOffsetToLocal;
    proto.parseZone            = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST                = isDaylightSavingTime;
    proto.isLocal              = isLocal;
    proto.isUtcOffset          = isUtcOffset;
    proto.isUtc                = isUtc;
    proto.isUTC                = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

    function createUnix (input) {
        return createLocal(input * 1000);
    }

    function createInZone () {
        return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat (string) {
        return string;
    }

    var proto$1 = Locale.prototype;

    proto$1.calendar        = calendar;
    proto$1.longDateFormat  = longDateFormat;
    proto$1.invalidDate     = invalidDate;
    proto$1.ordinal         = ordinal;
    proto$1.preparse        = preParsePostFormat;
    proto$1.postformat      = preParsePostFormat;
    proto$1.relativeTime    = relativeTime;
    proto$1.pastFuture      = pastFuture;
    proto$1.set             = set;

    proto$1.months            =        localeMonths;
    proto$1.monthsShort       =        localeMonthsShort;
    proto$1.monthsParse       =        localeMonthsParse;
    proto$1.monthsRegex       = monthsRegex;
    proto$1.monthsShortRegex  = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;

    proto$1.weekdays       =        localeWeekdays;
    proto$1.weekdaysMin    =        localeWeekdaysMin;
    proto$1.weekdaysShort  =        localeWeekdaysShort;
    proto$1.weekdaysParse  =        localeWeekdaysParse;

    proto$1.weekdaysRegex       =        weekdaysRegex;
    proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
    proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1 (format, index, field, setter) {
        var locale = getLocale();
        var utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl (format, index, field) {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return get$1(format, index, field, 'month');
        }

        var i;
        var out = [];
        for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl (localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0;

        if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
        }

        var i;
        var out = [];
        for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function listMonths (format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort (format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports

    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

    var mathAbs = Math.abs;

    function abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function addSubtract$1 (duration, input, value, direction) {
        var other = createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function add$1 (input, value) {
        return addSubtract$1(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function subtract$1 (input, value) {
        return addSubtract$1(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        if (!this.isValid()) {
            return NaN;
        }
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'quarter' || units === 'year') {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            switch (units) {
                case 'month':   return months;
                case 'quarter': return months / 3;
                case 'year':    return months / 12;
            }
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function valueOf$1 () {
        if (!this.isValid()) {
            return NaN;
        }
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asQuarters     = makeAs('Q');
    var asYears        = makeAs('y');

    function clone$1 () {
        return createDuration(this);
    }

    function get$2 (units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
        return function () {
            return this.isValid() ? this._data[name] : NaN;
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        ss: 44,         // a few seconds to seconds
        s : 45,         // seconds to minute
        m : 45,         // minutes to hour
        h : 22,         // hours to day
        d : 26,         // days to month
        M : 11          // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
        var duration = createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds <= thresholds.ss && ['s', seconds]  ||
                seconds < thresholds.s   && ['ss', seconds] ||
                minutes <= 1             && ['m']           ||
                minutes < thresholds.m   && ['mm', minutes] ||
                hours   <= 1             && ['h']           ||
                hours   < thresholds.h   && ['hh', hours]   ||
                days    <= 1             && ['d']           ||
                days    < thresholds.d   && ['dd', days]    ||
                months  <= 1             && ['M']           ||
                months  < thresholds.M   && ['MM', months]  ||
                years   <= 1             && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function getSetRelativeTimeRounding (roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof(roundingFunction) === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === 's') {
            thresholds.ss = limit - 1;
        }
        return true;
    }

    function humanize (withSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var locale = this.localeData();
        var output = relativeTime$1(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
        return ((x > 0) - (x < 0)) || +x;
    }

    function toISOString$1() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var seconds = abs$1(this._milliseconds) / 1000;
        var days         = abs$1(this._days);
        var months       = abs$1(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        var totalSign = total < 0 ? '-' : '';
        var ymSign = sign(this._months) !== sign(total) ? '-' : '';
        var daysSign = sign(this._days) !== sign(total) ? '-' : '';
        var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

        return totalSign + 'P' +
            (Y ? ymSign + Y + 'Y' : '') +
            (M ? ymSign + M + 'M' : '') +
            (D ? daysSign + D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? hmsSign + h + 'H' : '') +
            (m ? hmsSign + m + 'M' : '') +
            (s ? hmsSign + s + 'S' : '');
    }

    var proto$2 = Duration.prototype;

    proto$2.isValid        = isValid$1;
    proto$2.abs            = abs;
    proto$2.add            = add$1;
    proto$2.subtract       = subtract$1;
    proto$2.as             = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds      = asSeconds;
    proto$2.asMinutes      = asMinutes;
    proto$2.asHours        = asHours;
    proto$2.asDays         = asDays;
    proto$2.asWeeks        = asWeeks;
    proto$2.asMonths       = asMonths;
    proto$2.asQuarters     = asQuarters;
    proto$2.asYears        = asYears;
    proto$2.valueOf        = valueOf$1;
    proto$2._bubble        = bubble;
    proto$2.clone          = clone$1;
    proto$2.get            = get$2;
    proto$2.milliseconds   = milliseconds;
    proto$2.seconds        = seconds;
    proto$2.minutes        = minutes;
    proto$2.hours          = hours;
    proto$2.days           = days;
    proto$2.weeks          = weeks;
    proto$2.months         = months;
    proto$2.years          = years;
    proto$2.humanize       = humanize;
    proto$2.toISOString    = toISOString$1;
    proto$2.toString       = toISOString$1;
    proto$2.toJSON         = toISOString$1;
    proto$2.locale         = locale;
    proto$2.localeData     = localeData;

    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
    proto$2.lang = lang;

    // Side effect imports

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    hooks.version = '2.24.0';

    setHookCallback(createLocal);

    hooks.fn                    = proto;
    hooks.min                   = min;
    hooks.max                   = max;
    hooks.now                   = now;
    hooks.utc                   = createUTC;
    hooks.unix                  = createUnix;
    hooks.months                = listMonths;
    hooks.isDate                = isDate;
    hooks.locale                = getSetGlobalLocale;
    hooks.invalid               = createInvalid;
    hooks.duration              = createDuration;
    hooks.isMoment              = isMoment;
    hooks.weekdays              = listWeekdays;
    hooks.parseZone             = createInZone;
    hooks.localeData            = getLocale;
    hooks.isDuration            = isDuration;
    hooks.monthsShort           = listMonthsShort;
    hooks.weekdaysMin           = listWeekdaysMin;
    hooks.defineLocale          = defineLocale;
    hooks.updateLocale          = updateLocale;
    hooks.locales               = listLocales;
    hooks.weekdaysShort         = listWeekdaysShort;
    hooks.normalizeUnits        = normalizeUnits;
    hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat        = getCalendarFormat;
    hooks.prototype             = proto;

    // currently HTML5 input type only supports 24-hour formats
    hooks.HTML5_FMT = {
        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type="datetime-local" step="0.001" />
        DATE: 'YYYY-MM-DD',                             // <input type="date" />
        TIME: 'HH:mm',                                  // <input type="time" />
        TIME_SECONDS: 'HH:mm:ss',                       // <input type="time" step="1" />
        TIME_MS: 'HH:mm:ss.SSS',                        // <input type="time" step="0.001" />
        WEEK: 'GGGG-[W]WW',                             // <input type="week" />
        MONTH: 'YYYY-MM'                                // <input type="month" />
    };

    return hooks;

})));

},{}],147:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var record_1 = require("@quenk/noni/lib/data/record");
var util_1 = require("../../../lib/util");
var app_1 = require("./wml/app");
var pages_1 = require("./pages");
var pages2Pages = function () {
    var tmp = record_1.group(pages_1.pages, function (_, k) { return k.split('_')[0]; });
    for (var sec in tmp)
        if (tmp.hasOwnProperty(sec)) {
            var newSec = {};
            for (var name_1 in tmp[sec])
                if (tmp[sec].hasOwnProperty(name_1)) {
                    newSec[name_1.split('_')[1]] = tmp[sec][name_1];
                }
            tmp[sec] = newSec;
        }
    return tmp;
};
var pages2Modules = function () {
    return record_1.reduce(pages_1.pages, {}, function (p, c, k) {
        p[k.split('_')[1]] = c;
        return p;
    });
};
/**
 * App displaying all the wml widgets.
 */
var App = /** @class */ (function () {
    function App(root) {
        var _this = this;
        this.root = root;
        this.view = new app_1.Main(this);
        this.content = [];
        this.page = '';
        this.pages = pages2Pages();
        this.modules = pages2Modules();
        this.values = {
            id: {
                layout: 'layout'
            }
        };
        /**
         * navigate is called when the user clicks on a
         * navigation link.
         */
        this.navigate = function (_a) {
            var name = _a.name;
            _this.page = name;
            if (_this.modules.hasOwnProperty(name)) {
                _this.content = [_this.modules[name].view.render()];
                _this.view.invalidate();
            }
        };
        /**
         * toggleDrawer
         */
        this.toggleDrawer = function () {
            util_1.getById(_this.view, _this.values.id.layout)
                .map(function (d) { return d.toggle(); });
        };
    }
    /**
     * run the application.
     */
    App.prototype.run = function () {
        var root = this.root;
        while (root.lastChild)
            root.removeChild(root.lastChild);
        root.appendChild(this.view.render());
        var path = window.location.hash.split('#')[1];
        path = path ? path.split('/').join('') : '';
    };
    App.main = function (root) {
        return new App(root);
    };
    return App;
}());
exports.App = App;
App.main(document.getElementById('app')).run();

},{"../../../lib/util":138,"./pages":240,"./wml/app":243,"@quenk/noni/lib/data/record":142}],148:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.results = [
    { label: 'Asus', value: 'Asus' },
    { label: 'MSI', value: 'MSI' },
    { label: 'Gigabyte', value: 'Gigabyte' },
    { label: 'Gigas', value: 'Gigas' },
    { label: 'AsusTek', value: 'AsusTek' },
    { label: 'Asusuga', value: 'Asusuga' },
    { label: 'Qualcomm', value: 'Qualcomm' },
    { label: 'Qualitative', value: 'Qualitatve' },
    { label: 'Kirpalani\'s', value: 'Kirpalani\'s' },
    { label: 'Asunder', value: 'Asunder' }
];

},{}],149:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/embed");
var EmbedPage = /** @class */ (function () {
    function EmbedPage() {
        this.view = new views.Main(this);
        this.values = {
            jojo: 'https://www.youtube.com/embed/1bbr5tMuSnc',
            win: 'https://www.youtube.com/embed/itgSyPxfqoE',
            max: 'https://www.youtube.com/embed/9rrzQSbk9hI',
            allow: 'accelerometer; autoplay; encrypted-media; gyroscope; ' +
                'picture-in-picture'
        };
    }
    return EmbedPage;
}());
exports.EmbedPage = EmbedPage;
exports.default = new EmbedPage();

},{"./wml/embed":150}],150:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var grid_1 = require("../../../../../../lib/layout/grid");
;
var embed_1 = require("../../../../../../lib/content/embed");
;
var demo_1 = require("../../../widgets/demo");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.node('h1', { html: {}, wml: {} }, [
                    document.createTextNode("Embed")
                ]),
                __this.widget(grid_1.GridLayout, { html: {}, wml: {} }, [
                    __this.widget(grid_1.Row, { html: {}, wml: {} }, [
                        __this.widget(grid_1.Column, { html: {}, wml: {}, ww: { 'span': 4 } }, [
                            __this.widget(embed_1.Embed, { html: {}, wml: {}, ww: { 'className': "-aspect-ratio-16x9" } }, [
                                __this.node('iframe', { html: { 'src': __context.values.jojo, 'allow': __context.values.allow }, wml: {} }, [])
                            ])
                        ]),
                        __this.widget(grid_1.Column, { html: {}, wml: {}, ww: { 'span': 4 } }, [
                            __this.widget(embed_1.Embed, { html: {}, wml: {}, ww: { 'className': "-aspect-ratio-4x3" } }, [
                                __this.node('iframe', { html: { 'src': __context.values.win, 'allow': __context.values.allow }, wml: {} }, [])
                            ])
                        ]),
                        __this.widget(grid_1.Column, { html: {}, wml: {}, ww: { 'span': 4 } }, [
                            __this.widget(embed_1.Embed, { html: {}, wml: {}, ww: { 'className': "-aspect-ratio-16x9" } }, [
                                __this.node('iframe', { html: { 'src': __context.values.max, 'allow': __context.values.allow }, wml: {} }, [])
                            ])
                        ])
                    ])
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/content/embed":5,"../../../../../../lib/layout/grid":110,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],151:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/media-description");
var MediaDescriptionPage = /** @class */ (function () {
    function MediaDescriptionPage() {
        this.view = new views.Main(this);
        this.values = {};
    }
    return MediaDescriptionPage;
}());
exports.MediaDescriptionPage = MediaDescriptionPage;
exports.default = new MediaDescriptionPage();

},{"./wml/media-description":152}],152:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var media_description_1 = require("../../../../../../lib/content/media-description");
;
var demo_1 = require("../../../widgets/demo");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.node('h1', { html: {}, wml: {} }, [
                    document.createTextNode("Media Description")
                ]),
                __this.widget(media_description_1.MediaDescription, { html: {}, wml: {} }, [
                    __this.widget(media_description_1.Media, { html: {}, wml: {} }, [
                        __this.node('img', { html: { 'alt': "placeholder", 'src': "https://via.placeholder.com/140x100" }, wml: {} }, [])
                    ]),
                    __this.widget(media_description_1.Description, { html: {}, wml: {} }, [
                        __this.node('h4', { html: {}, wml: {} }, [
                            document.createTextNode("Description")
                        ]),
                        __this.node('p', { html: {}, wml: {} }, [
                            document.createTextNode("Located at the side related to the image on the left.")
                        ])
                    ])
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/content/media-description":9,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],153:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/overlay");
var OverlayPage = /** @class */ (function () {
    function OverlayPage() {
        var _this = this;
        this.view = new views.Main(this);
        this.values = {
            onClick: function () {
                var mO = _this.view.findById('overlay');
                if (mO.isJust())
                    mO.get().close();
            }
        };
    }
    return OverlayPage;
}());
exports.OverlayPage = OverlayPage;
exports.default = new OverlayPage();

},{"./wml/overlay":154}],154:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var overlay_1 = require("../../../../../../lib/content/overlay");
;
var demo_1 = require("../../../widgets/demo");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.node('h1', { html: {}, wml: {} }, [
                    document.createTextNode("Overlay")
                ]),
                __this.widget(overlay_1.Overlay, { html: {}, wml: { 'id': "overlay" }, ww: { 'onClick': __context.values.onClick } }, [])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/content/overlay":14,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],155:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/tag");
var style_1 = require("../../../../../lib/content/style");
var TagPage = /** @class */ (function () {
    function TagPage() {
        this.view = new views.Main(this);
        this.values = {
            capitalize: function (s) { return "" + s[0].toUpperCase() + s.slice(1); },
            styles: [
                style_1.Style.Default,
                style_1.Style.Primary,
                style_1.Style.Success,
                style_1.Style.Info,
                style_1.Style.Warning,
                style_1.Style.Error
            ]
        };
    }
    return TagPage;
}());
exports.TagPage = TagPage;
exports.default = new TagPage();

},{"../../../../../lib/content/style":19,"./wml/tag":156}],156:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var tag_1 = require("../../../../../../lib/content/tag");
;
var demo_1 = require("../../../widgets/demo");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('h1', { html: {}, wml: {} }, [
                        document.createTextNode("Tag")
                    ]),
                    __this.node('p', { html: {}, wml: {} }, __spreadArrays([
                        __this.node('h2', { html: {}, wml: {} }, [
                            document.createTextNode("Styles")
                        ])
                    ], __forIn(__context.values.styles, function (v, _$$i, _$$all) {
                        return ([
                            __this.widget(tag_1.Tag, { html: {}, wml: {}, ww: { 'style': v, 'text': __context.values.capitalize(v) } }, [])
                        ]);
                    }, function () { return ([]); })))
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/content/tag":20,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],157:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/thumbnail");
var ThumbnailPage = /** @class */ (function () {
    function ThumbnailPage() {
        this.view = new views.Main(this);
        this.values = {
            onClick: function () { return alert('You clicked it!'); }
        };
    }
    return ThumbnailPage;
}());
exports.ThumbnailPage = ThumbnailPage;
exports.default = new ThumbnailPage();

},{"./wml/thumbnail":158}],158:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var thumbnail_1 = require("../../../../../../lib/content/thumbnail");
;
var grid_1 = require("../../../../../../lib/layout/grid");
;
var demo_1 = require("../../../widgets/demo");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.node('h1', { html: {}, wml: {} }, [
                    document.createTextNode("Thumbnail")
                ]),
                __this.widget(grid_1.GridLayout, { html: {}, wml: {} }, [
                    __this.widget(grid_1.Row, { html: {}, wml: {} }, [
                        __this.widget(grid_1.Column, { html: {}, wml: {}, ww: { 'span': 4 } }, [
                            __this.widget(thumbnail_1.Thumbnail, { html: {}, wml: {} }, [
                                __this.node('img', { html: { 'alt': "placeholder", 'src': "https://via.placeholder.com/171x180", 'style': "width:100%;height:100%;display:block" }, wml: {} }, [])
                            ])
                        ]),
                        __this.widget(grid_1.Column, { html: {}, wml: {}, ww: { 'span': 4 } }, [
                            __this.widget(thumbnail_1.Thumbnail, { html: {}, wml: {}, ww: { 'onClick': __context.values.onClick } }, [
                                __this.node('img', { html: { 'alt': "placeholder", 'src': "https://via.placeholder.com/171x180", 'style': "width:100%;height:100%;display:block" }, wml: {} }, [])
                            ])
                        ]),
                        __this.widget(grid_1.Column, { html: {}, wml: {}, ww: { 'span': 4 } }, [
                            __this.widget(thumbnail_1.Thumbnail, { html: {}, wml: {}, ww: { 'href': "#" } }, [
                                __this.node('img', { html: { 'alt': "placeholder", 'src': "https://via.placeholder.com/171x180", 'style': "width:100%;height:100%;display:block" }, wml: {} }, [])
                            ])
                        ])
                    ]),
                    __this.widget(grid_1.Row, { html: {}, wml: {} }, [
                        __this.widget(grid_1.Column, { html: {}, wml: {}, ww: { 'span': 4 } }, [
                            __this.widget(thumbnail_1.Thumbnail, { html: {}, wml: {} }, [
                                __this.node('img', { html: { 'alt': "placeholder", 'src': "https://via.placeholder.com/171x180", 'style': "width:100%;height:100%;display:block" }, wml: {} }, []),
                                __this.widget(thumbnail_1.Caption, { html: {}, wml: {} }, [
                                    __this.node('h4', { html: {}, wml: {} }, [
                                        document.createTextNode("Caption")
                                    ]),
                                    __this.node('p', { html: {}, wml: {} }, [
                                        document.createTextNode("Describes the thumbnail in minor detail.")
                                    ])
                                ])
                            ])
                        ]),
                        __this.widget(grid_1.Column, { html: {}, wml: {}, ww: { 'span': 4 } }, [
                            __this.widget(thumbnail_1.Thumbnail, { html: {}, wml: {}, ww: { 'onClick': __context.values.onClick } }, [
                                __this.node('img', { html: { 'alt': "placeholder", 'src': "https://via.placeholder.com/171x180", 'style': "width:100%;height:100%;display:block" }, wml: {} }, []),
                                __this.widget(thumbnail_1.Caption, { html: {}, wml: {} }, [
                                    __this.node('h4', { html: {}, wml: {} }, [
                                        document.createTextNode("Caption")
                                    ]),
                                    __this.node('p', { html: {}, wml: {} }, [
                                        document.createTextNode("Describes the thumbnail in minor detail.")
                                    ])
                                ])
                            ])
                        ]),
                        __this.widget(grid_1.Column, { html: {}, wml: {}, ww: { 'span': 4 } }, [
                            __this.widget(thumbnail_1.Thumbnail, { html: {}, wml: {}, ww: { 'href': "#" } }, [
                                __this.node('img', { html: { 'alt': "placeholder", 'src': "https://via.placeholder.com/171x180", 'style': "width:100%;height:100%;display:block" }, wml: {} }, []),
                                __this.widget(thumbnail_1.Caption, { html: {}, wml: {} }, [
                                    __this.node('h4', { html: {}, wml: {} }, [
                                        document.createTextNode("Caption")
                                    ]),
                                    __this.node('p', { html: {}, wml: {} }, [
                                        document.createTextNode("Describes the thumbnail in minor detail.")
                                    ])
                                ])
                            ])
                        ])
                    ])
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/content/thumbnail":22,"../../../../../../lib/layout/grid":110,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],159:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/button-group");
var ButtonGroupPage = /** @class */ (function () {
    function ButtonGroupPage() {
        this.view = new views.Main(this);
    }
    return ButtonGroupPage;
}());
exports.ButtonGroupPage = ButtonGroupPage;
exports.default = new ButtonGroupPage();

},{"./wml/button-group":160}],160:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var demo_1 = require("../../../widgets/demo");
;
var button_1 = require("../../../../../../lib/control/button");
;
var button_group_1 = require("../../../../../../lib/control/button-group");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.widget(button_group_1.ButtonGroup, { html: {}, wml: {} }, [
                    __this.widget(button_1.Button, { html: {}, wml: {}, ww: { 'text': "one" } }, []),
                    __this.widget(button_1.Button, { html: {}, wml: {}, ww: { 'text': "three", 'active': true } }, []),
                    __this.widget(button_1.Button, { html: {}, wml: {}, ww: { 'text': "four" } }, [])
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/control/button":28,"../../../../../../lib/control/button-group":24,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],161:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/button-select");
var ButtonSelectPage = /** @class */ (function () {
    function ButtonSelectPage() {
        var _this = this;
        this.view = new views.Main(this);
        this.values = {
            options: [
                { text: 'Asus', value: 'Asus' },
                { text: 'MSI', value: 'MSI' },
                { text: 'Gigabyte', value: 'Gigabyte' }
            ]
        };
        this.onChange = function (_a) {
            var value = _a.value, name = _a.name;
            _this
                .view
                .findById(name + "-content")
                .map(function (e) {
                while (e.lastChild)
                    e.removeChild(e.lastChild);
                e.appendChild(document.createTextNode(String(value)));
            });
        };
        this.onChangeMulti = function (_a) {
            var value = _a.value, name = _a.name;
            _this
                .view
                .findById(name + "-content")
                .map(function (e) {
                while (e.lastChild)
                    e.removeChild(e.lastChild);
                e.appendChild(document.createTextNode(String(value)));
            });
        };
    }
    return ButtonSelectPage;
}());
exports.ButtonSelectPage = ButtonSelectPage;
exports.default = new ButtonSelectPage();

},{"./wml/button-select":162}],162:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var demo_1 = require("../../../widgets/demo");
;
var style_1 = require("../../../../../../lib/content/style");
;
var button_select_1 = require("../../../../../../lib/control/button-select");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('p', { html: {}, wml: {} }, [
                        document.createTextNode("You selected: "),
                        __this.node('b', { html: {}, wml: { 'id': "select-content" } }, [
                            document.createTextNode("(None)")
                        ]),
                        document.createTextNode(".")
                    ]),
                    __this.node('p', { html: {}, wml: {} }, [
                        __this.widget(button_select_1.ButtonSelect, { html: {}, wml: { 'id': "select" }, ww: { 'name': "select", 'style': style_1.Style.Primary, 'options': __context.values.options, 'onChange': __context.onChange } }, [])
                    ])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('p', { html: {}, wml: {} }, [
                        document.createTextNode("You can also use MultiButtonSelect instead: "),
                        __this.node('b', { html: {}, wml: { 'id': "multi-content" } }, [
                            document.createTextNode("(None)")
                        ]),
                        document.createTextNode(".")
                    ]),
                    __this.node('p', { html: {}, wml: {} }, [
                        __this.widget(button_select_1.MultiButtonSelect, { html: {}, wml: { 'id': "multi" }, ww: { 'name': "multi", 'style': style_1.Style.Warning, 'options': __context.values.options, 'onChange': __context.onChangeMulti } }, [])
                    ])
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/content/style":19,"../../../../../../lib/control/button-select":26,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],163:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/button");
var style_1 = require("../../../../../lib/content/style");
var size_1 = require("../../../../../lib/content/size");
var ButtonPage = /** @class */ (function () {
    function ButtonPage() {
        this.view = new views.Main(this);
        this.values = {
            capitalize: function (s) { return "" + s[0].toUpperCase() + s.slice(1); },
            styles: [
                style_1.Style.Default,
                style_1.Style.Primary,
                style_1.Style.Success,
                style_1.Style.Info,
                style_1.Style.Warning,
                style_1.Style.Error
            ],
            sizes: [
                size_1.Size.ExtraSmall,
                size_1.Size.Small,
                size_1.Size.Medium,
                size_1.Size.Large,
                size_1.Size.ExtraLarge
            ]
        };
    }
    return ButtonPage;
}());
exports.ButtonPage = ButtonPage;
exports.default = new ButtonPage();

},{"../../../../../lib/content/size":16,"../../../../../lib/content/style":19,"./wml/button":164}],164:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var demo_1 = require("../../../widgets/demo");
;
var button_1 = require("../../../../../../lib/control/button");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('h1', { html: {}, wml: {} }, [
                        document.createTextNode("Buttons")
                    ]),
                    __this.node('p', { html: {}, wml: {} }, __spreadArrays([
                        __this.node('h2', { html: {}, wml: {} }, [
                            document.createTextNode("Style")
                        ])
                    ], __forIn(__context.values.styles, function (v, _$$i, _$$all) {
                        return ([
                            __this.widget(button_1.Button, { html: {}, wml: {}, ww: { 'name': v, 'style': v, 'text': __context.values.capitalize(v) } }, [])
                        ]);
                    }, function () { return ([]); })))
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, __spreadArrays([
                    __this.node('h2', { html: {}, wml: {} }, [
                        document.createTextNode("Outline")
                    ])
                ], __forIn(__context.values.styles, function (style, _$$i, _$$all) {
                    return ([
                        __this.widget(button_1.Button, { html: {}, wml: {}, ww: { 'style': style, 'outline': true, 'text': __context.values.capitalize(style) } }, [])
                    ]);
                }, function () { return ([]); }))),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('p', { html: {}, wml: {} }, __spreadArrays([
                        __this.node('h2', { html: {}, wml: {} }, [
                            document.createTextNode("Active")
                        ])
                    ], __forIn(__context.values.styles, function (v, _$$i, _$$all) {
                        return ([
                            __this.widget(button_1.Button, { html: {}, wml: {}, ww: { 'name': v, 'active': true, 'style': v, 'text': __context.values.capitalize(v) } }, [])
                        ]);
                    }, function () { return ([]); })))
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('p', { html: {}, wml: {} }, __spreadArrays([
                        __this.node('h2', { html: {}, wml: {} }, [
                            document.createTextNode("Disabled")
                        ])
                    ], __forIn(__context.values.styles, function (v, _$$i, _$$all) {
                        return ([
                            __this.widget(button_1.Button, { html: {}, wml: {}, ww: { 'name': v, 'disabled': true, 'style': v, 'text': __context.values.capitalize(v) } }, [])
                        ]);
                    }, function () { return ([]); })))
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, __spreadArrays([
                    __this.node('h2', { html: {}, wml: {} }, [
                        document.createTextNode("Size")
                    ])
                ], __forIn(__context.values.styles, function (style, _$$i, _$$all) {
                    return ([
                        __this.node('p', { html: {}, wml: {} }, __spreadArrays(__forIn(__context.values.sizes, function (size, _$$i, _$$all) {
                            return ([
                                __this.widget(button_1.Button, { html: {}, wml: {}, ww: { 'name': size, 'style': style, 'size': size, 'text': __context.values.capitalize(size) } }, [])
                            ]);
                        }, function () { return ([]); })))
                    ]);
                }, function () { return ([]); }))),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, __spreadArrays([
                    __this.node('h2', { html: {}, wml: {} }, [
                        document.createTextNode("Block")
                    ])
                ], __forIn(__context.values.styles, function (style, _$$i, _$$all) {
                    return ([
                        __this.widget(button_1.Button, { html: {}, wml: {}, ww: { 'style': style, 'block': true, 'text': __context.values.capitalize(style) } }, [])
                    ]);
                }, function () { return ([]); })))
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/control/button":28,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],165:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/checkbox");
var CheckboxPage = /** @class */ (function () {
    function CheckboxPage() {
        var _this = this;
        this.view = new views.Main(this);
        this.value = true;
        this.onChange = function (_a) {
            var value = _a.value;
            _this.view.findById('content')
                .map(function (e) {
                while (e.firstChild)
                    e.removeChild(e.firstChild);
                e.appendChild(document.createTextNode(value === true ?
                    'on' :
                    (value === false ? 'off' : 'error')));
            });
        };
    }
    return CheckboxPage;
}());
exports.CheckboxPage = CheckboxPage;
exports.default = new CheckboxPage();

},{"./wml/checkbox":166}],166:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var demo_1 = require("../../../widgets/demo");
;
var checkbox_1 = require("../../../../../../lib/control/checkbox");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.node('p', { html: {}, wml: {} }, [
                    document.createTextNode("The checkbox is "),
                    __this.node('b', { html: {}, wml: { 'id': "content" } }, [
                        document.createTextNode("untouched")
                    ]),
                    document.createTextNode(".")
                ]),
                __this.node('p', { html: {}, wml: {} }, [
                    __this.widget(checkbox_1.Checkbox, { html: {}, wml: {}, ww: { 'name': "checkbox", 'onChange': __context.onChange } }, [])
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/control/checkbox":30,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],167:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/date-field");
var date_field_1 = require("../../../../../lib/control/date-field");
var util_1 = require("../../../../../lib/util");
var DateFieldPage = /** @class */ (function () {
    function DateFieldPage() {
        this.view = new views.Main(this);
        this.values = {
            formats: {
                iso: {
                    id: 'iso',
                    name: 'iso',
                    label: 'ISO8601',
                    format: date_field_1.Format.ISO8601,
                    message: 'ISO8601 date',
                    onChange: exports.onChange(this)
                },
                common: {
                    id: 'common',
                    name: 'common',
                    label: 'Comon',
                    format: date_field_1.Format.COMMON,
                    message: 'Common date',
                    onChange: exports.onChange(this)
                },
                us: {
                    id: 'us',
                    name: 'us',
                    label: 'US',
                    format: date_field_1.Format.USA,
                    message: 'US date',
                    onChange: exports.onChange(this)
                }
            },
            states: {
                success: {
                    id: 'success',
                    name: 'success',
                    label: 'Success',
                    success: 'Success date',
                    warning: undefined,
                    error: undefined,
                    block: false,
                    onChange: exports.onChange(this)
                },
                warning: {
                    id: 'warning',
                    name: 'warning',
                    label: 'Warning',
                    success: undefined,
                    warning: 'Warning date',
                    error: undefined,
                    block: false,
                    onChange: exports.onChange(this)
                },
                error: {
                    id: 'error',
                    name: 'error',
                    label: 'Error',
                    success: undefined,
                    warning: undefined,
                    error: 'Error date',
                    block: false,
                    onChange: exports.onChange(this)
                },
                block: {
                    id: 'block',
                    name: 'block',
                    label: 'Block',
                    success: undefined,
                    warning: undefined,
                    error: undefined,
                    block: true,
                    onChange: exports.onChange(this)
                },
            }
        };
    }
    return DateFieldPage;
}());
exports.DateFieldPage = DateFieldPage;
exports.onChange = function (d) { return function (_a) {
    var name = _a.name, value = _a.value;
    var mDate = util_1.getById(d.view, name);
    if (mDate.isJust()) {
        var d_1 = mDate.get();
        d_1.setMessage("The date is " + value + ".");
    }
}; };
exports.default = new DateFieldPage();

},{"../../../../../lib/control/date-field":34,"../../../../../lib/util":138,"./wml/date-field":168}],168:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var demo_1 = require("../../../widgets/demo");
;
var date_field_1 = require("../../../../../../lib/control/date-field");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, __spreadArrays(__forOf(__context.values.formats, function (spec, _$$k, _$$all) {
                return ([
                    __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                        __this.node('p', { html: {}, wml: {} }, [
                            __this.widget(date_field_1.DateField, { html: {}, wml: { 'id': spec.id }, ww: { 'name': spec.name, 'label': spec.label, 'format': spec.format, 'message': spec.message, 'onChange': spec.onChange } }, [])
                        ])
                    ])
                ]);
            }, function () { return ([]); }), __forOf(__context.values.states, function (spec, _$$k, _$$all) {
                return ([
                    __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                        __this.node('p', { html: {}, wml: {} }, [
                            __this.widget(date_field_1.DateField, { html: {}, wml: { 'id': spec.id }, ww: { 'name': spec.name, 'label': spec.label, 'success': spec.success, 'warning': spec.warning, 'error': spec.error, 'block': spec.block, 'onChange': spec.onChange } }, [])
                        ])
                    ])
                ]);
            }, function () { return ([]); })));
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/control/date-field":34,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],169:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/display-field");
var style_1 = require("../../../../../lib/content/style");
var getStyles = function () { return [
    style_1.Style.Default,
    style_1.Style.Primary,
    style_1.Style.Success,
    style_1.Style.Info,
    style_1.Style.Warning,
    style_1.Style.Error
]; };
var DisplayFieldPage = /** @class */ (function () {
    function DisplayFieldPage() {
        this.view = new views.Main(this);
        this.values = {
            capitalize: function (s) { return "" + s[0].toUpperCase() + s.slice(1); },
            styles: getStyles()
        };
    }
    return DisplayFieldPage;
}());
exports.DisplayFieldPage = DisplayFieldPage;
exports.default = new DisplayFieldPage();

},{"../../../../../lib/content/style":19,"./wml/display-field":170}],170:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var display_field_1 = require("../../../../../../lib/control/display-field");
;
var demo_1 = require("../../../widgets/demo");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.widget(display_field_1.DisplayField, { html: {}, wml: {} }, [
                        document.createTextNode(" It was a choice.")
                    ])
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/control/display-field":36,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],171:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/drop-down");
var DropDownPage = /** @class */ (function () {
    function DropDownPage() {
        this.view = new views.Main(this);
        this.onClick = function (msg) { return function (e) {
            e.preventDefault();
            alert(msg);
        }; };
    }
    return DropDownPage;
}());
exports.DropDownPage = DropDownPage;
exports.default = new DropDownPage();

},{"./wml/drop-down":172}],172:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var demo_1 = require("../../../widgets/demo");
;
var drop_down_1 = require("../../../../../../lib/control/drop-down");
;
var menu_1 = require("../../../../../../lib/menu/menu");
;
var item_1 = require("../../../../../../lib/menu/item");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.node('p', { html: {}, wml: {} }, [
                    __this.widget(drop_down_1.DropDown, { html: {}, wml: {}, ww: { 'buttonText': "Click Me" } }, [
                        __this.widget(menu_1.Menu, { html: {}, wml: {} }, [
                            __this.widget(item_1.Item, { html: {}, wml: {} }, [
                                __this.node('a', { html: { 'href': "#", 'onclick': __context.onClick("You clicked one") }, wml: {} }, [
                                    document.createTextNode("One")
                                ])
                            ]),
                            __this.widget(item_1.Item, { html: {}, wml: {} }, [
                                __this.node('a', { html: { 'href': "#", 'onclick': __context.onClick("You clicked two") }, wml: {} }, [
                                    document.createTextNode("Two")
                                ])
                            ]),
                            __this.widget(item_1.Item, { html: {}, wml: {} }, [
                                __this.node('a', { html: { 'href': "#", 'onclick': __context.onClick("You clicked three") }, wml: {} }, [
                                    document.createTextNode("Three")
                                ])
                            ])
                        ])
                    ]),
                    __this.widget(drop_down_1.DropDown, { html: {}, wml: {}, ww: { 'buttonText': "Me Too", 'autoClose': false } }, [
                        __this.node('h1', { html: {}, wml: {} }, [
                            document.createTextNode("Any flow content can go here!")
                        ])
                    ])
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/control/drop-down":38,"../../../../../../lib/menu/item":131,"../../../../../../lib/menu/menu":133,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],173:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/drop-list-field");
var results_1 = require("../../fixtures/data/results");
var options = results_1.results;
var DropListFieldPage = /** @class */ (function () {
    function DropListFieldPage() {
        this.view = new views.Main(this);
        this.values = {
            normal: {
                id: 'normal',
                name: 'normal',
                label: 'Normal',
                options: options,
                value: results_1.results[2].value,
                onChange: doChange(this)
            },
            success: {
                id: 'success',
                name: 'success',
                label: 'Success',
                options: options,
                message: 'This has a success message.',
                onChange: doChange(this)
            },
            warning: {
                id: 'warning',
                name: 'warning',
                label: 'Warning',
                options: options,
                message: 'This has a warning message.',
                onChange: doChange(this)
            },
            error: {
                id: 'error',
                name: 'error',
                label: 'Error',
                options: options,
                message: 'This has a error message.',
                onChange: doChange(this)
            },
        };
    }
    return DropListFieldPage;
}());
exports.DropListFieldPage = DropListFieldPage;
var doChange = function (page) { return function (_a) {
    var name = _a.name, value = _a.value;
    return page
        .view
        .findById(name)
        .map(function () {
        alert("Selected: " + name + "=" + value);
    });
}; };
exports.default = new DropListFieldPage();

},{"../../fixtures/data/results":148,"./wml/drop-list-field":174}],174:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var demo_1 = require("../../../widgets/demo");
;
var drop_list_field_1 = require("../../../../../../lib/control/drop-list-field");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('b', { html: {}, wml: {} }, [
                        document.createTextNode("Normal")
                    ]),
                    __this.node('p', { html: {}, wml: {} }, [
                        __this.widget(drop_list_field_1.DropListField, { html: {}, wml: { 'id': __context.values.normal.name }, ww: { 'name': __context.values.normal.name, 'value': __context.values.normal.value, 'options': __context.values.normal.options, 'onChange': __context.values.normal.onChange } }, [])
                    ])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('b', { html: {}, wml: {} }, [
                        document.createTextNode("Success")
                    ]),
                    __this.node('p', { html: {}, wml: {} }, [
                        __this.widget(drop_list_field_1.DropListField, { html: {}, wml: { 'id': __context.values.success.id }, ww: { 'className': "-success", 'name': __context.values.success.name, 'options': __context.values.success.options, 'onChange': __context.values.success.onChange } }, [])
                    ])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('b', { html: {}, wml: {} }, [
                        document.createTextNode("Warning")
                    ]),
                    __this.node('p', { html: {}, wml: {} }, [
                        __this.widget(drop_list_field_1.DropListField, { html: {}, wml: { 'id': __context.values.warning.id }, ww: { 'className': "-warning", 'name': __context.values.warning.name, 'options': __context.values.warning.options, 'onChange': __context.values.warning.onChange } }, [])
                    ])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('b', { html: {}, wml: {} }, [
                        document.createTextNode("Error")
                    ]),
                    __this.node('p', { html: {}, wml: {} }, [
                        __this.widget(drop_list_field_1.DropListField, { html: {}, wml: { 'id': __context.values.error.id }, ww: { 'className': "-error", 'name': __context.values.error.name, 'options': __context.values.error.options, 'onChange': __context.values.error.onChange } }, [])
                    ])
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/control/drop-list-field":40,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],175:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/drop-list");
var results_1 = require("../../fixtures/data/results");
var options = results_1.results;
var DropListPage = /** @class */ (function () {
    function DropListPage() {
        this.view = new views.Main(this);
        this.values = {
            normal: {
                id: 'normal',
                name: 'normal',
                label: 'Normal',
                options: options,
                value: results_1.results[2].value,
                onSelect: doSelect(this)
            },
            block: {
                id: 'block',
                name: 'block',
                label: 'Block',
                options: options,
                onSelect: doSelect(this)
            },
            success: {
                id: 'success',
                name: 'success',
                label: 'Success',
                options: options,
                message: 'This has a success message.',
                onSelect: doSelect(this)
            },
            warning: {
                id: 'warning',
                name: 'warning',
                label: 'Warning',
                options: options,
                message: 'This has a warning message.',
                onSelect: doSelect(this)
            },
            error: {
                id: 'error',
                name: 'error',
                label: 'Error',
                options: options,
                message: 'This has a error message.',
                onSelect: doSelect(this)
            },
        };
    }
    return DropListPage;
}());
exports.DropListPage = DropListPage;
var doSelect = function (page) { return function (_a) {
    var name = _a.name, value = _a.value;
    return page
        .view
        .findById(name)
        .map(function () {
        alert("Selected: " + name + "=" + value);
    });
}; };
exports.default = new DropListPage();

},{"../../fixtures/data/results":148,"./wml/drop-list":176}],176:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var demo_1 = require("../../../widgets/demo");
;
var drop_list_1 = require("../../../../../../lib/control/drop-list");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('b', { html: {}, wml: {} }, [
                        document.createTextNode("Normal")
                    ]),
                    __this.node('p', { html: {}, wml: {} }, [
                        __this.widget(drop_list_1.DropList, { html: {}, wml: { 'id': __context.values.normal.name }, ww: { 'name': __context.values.normal.name, 'value': __context.values.normal.value, 'options': __context.values.normal.options, 'onSelect': __context.values.normal.onSelect } }, [])
                    ])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('b', { html: {}, wml: {} }, [
                        document.createTextNode("Success")
                    ]),
                    __this.node('p', { html: {}, wml: {} }, [
                        __this.widget(drop_list_1.DropList, { html: {}, wml: { 'id': __context.values.success.id }, ww: { 'className': "-success", 'name': __context.values.success.name, 'options': __context.values.success.options, 'onSelect': __context.values.success.onSelect } }, [])
                    ])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('b', { html: {}, wml: {} }, [
                        document.createTextNode("Warning")
                    ]),
                    __this.node('p', { html: {}, wml: {} }, [
                        __this.widget(drop_list_1.DropList, { html: {}, wml: { 'id': __context.values.warning.id }, ww: { 'className': "-warning", 'name': __context.values.warning.name, 'options': __context.values.warning.options, 'onSelect': __context.values.warning.onSelect } }, [])
                    ])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('b', { html: {}, wml: {} }, [
                        document.createTextNode("Error")
                    ]),
                    __this.node('p', { html: {}, wml: {} }, [
                        __this.widget(drop_list_1.DropList, { html: {}, wml: { 'id': __context.values.error.id }, ww: { 'className': "-error", 'name': __context.values.error.name, 'options': __context.values.error.options, 'onSelect': __context.values.error.onSelect } }, [])
                    ])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('p', { html: {}, wml: {} }, [
                        __this.node('b', { html: {}, wml: {} }, [
                            document.createTextNode("Block")
                        ]),
                        __this.widget(drop_list_1.DropList, { html: {}, wml: { 'id': __context.values.block.id }, ww: { 'className': "-block", 'name': __context.values.block.name, 'block': true, 'onSelect': __context.values.block.onSelect } }, [])
                    ])
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/control/drop-list":42,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],177:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/file-upload-surface");
var FileUploadSurfacePage = /** @class */ (function () {
    function FileUploadSurfacePage() {
        this.view = new views.Main(this);
        this.values = {};
    }
    return FileUploadSurfacePage;
}());
exports.FileUploadSurfacePage = FileUploadSurfacePage;
exports.default = new FileUploadSurfacePage();

},{"./wml/file-upload-surface":178}],178:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var demo_1 = require("../../../widgets/demo");
;
var file_upload_surface_1 = require("../../../../../../lib/control/file-upload-surface");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.widget(file_upload_surface_1.FileUploadSurface, { html: {}, wml: {} }, [])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/control/file-upload-surface":47,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],179:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/multi-select");
var results_1 = require("../../fixtures/data/results");
var MultiSelectPage = /** @class */ (function () {
    function MultiSelectPage() {
        this.view = new views.Main(this);
        this.values = {
            normal: {
                id: 'normal',
                name: 'normal',
                label: 'Normal',
                value: results_1.results[2],
                stringifier: function (r) { return r.value; },
                onSearch: onSearch(this),
                onChange: onChange(this),
            },
            success: {
                id: 'success',
                name: 'success',
                label: 'Success',
                stringifier: function (r) { return r.value; },
                message: 'This has a success message.',
                onSearch: onSearch(this),
                onChange: onChange(this),
            },
            warning: {
                id: 'warning',
                name: 'warning',
                label: 'Warning',
                stringifier: function (r) { return r.value; },
                message: 'This has a warning message.',
                onSearch: onSearch(this),
                onChange: onChange(this),
            },
            error: {
                id: 'error',
                name: 'error',
                label: 'Error',
                stringifier: function (r) { return r.value; },
                message: 'This has a error message.',
                onSearch: onSearch(this),
                onChange: onChange(this),
            },
            block: {
                id: 'block',
                name: 'block',
                label: 'Block',
                stringifier: function (r) { return r.value; },
                onSearch: onSearch(this),
                onChange: onChange(this),
            },
        };
    }
    return MultiSelectPage;
}());
exports.MultiSelectPage = MultiSelectPage;
var onSearch = function (page) { return function (_a) {
    var name = _a.name, value = _a.value;
    return page
        .view
        .findById(name)
        .map(function (s) {
        var hit = results_1.results.filter(function (c) {
            return c.value.toLowerCase().startsWith(value) ? true : false;
        });
        s.update(hit);
    });
}; };
var onChange = function (page) { return function (_a) {
    var name = _a.name, value = _a.value;
    return page
        .view
        .findById(name)
        .map(function (t) {
        t.setMessage("Count: " + value.length);
    });
}; };
exports.default = new MultiSelectPage();

},{"../../fixtures/data/results":148,"./wml/multi-select":180}],180:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var demo_1 = require("../../../widgets/demo");
;
var multi_select_1 = require("../../../../../../lib/control/multi-select");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.widget(multi_select_1.MultiSelect, { html: {}, wml: { 'id': __context.values.normal.id }, ww: { 'name': __context.values.normal.name, 'label': __context.values.normal.label, 'stringifier': __context.values.normal.stringifier, 'onSearch': __context.values.normal.onSearch, 'onChange': __context.values.normal.onChange } }, [])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.widget(multi_select_1.MultiSelect, { html: {}, wml: { 'id': __context.values.success.id }, ww: { 'name': __context.values.success.name, 'label': __context.values.success.label, 'success': __context.values.success.message, 'stringifier': __context.values.success.stringifier, 'onSearch': __context.values.success.onSearch, 'onChange': __context.values.success.onChange } }, [])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.widget(multi_select_1.MultiSelect, { html: {}, wml: { 'id': __context.values.warning.id }, ww: { 'name': __context.values.warning.name, 'label': __context.values.warning.label, 'warning': __context.values.warning.message, 'stringifier': __context.values.warning.stringifier, 'onSearch': __context.values.warning.onSearch, 'onChange': __context.values.warning.onChange } }, [])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.widget(multi_select_1.MultiSelect, { html: {}, wml: { 'id': __context.values.error.id }, ww: { 'name': __context.values.error.name, 'label': __context.values.error.label, 'error': __context.values.error.message, 'stringifier': __context.values.error.stringifier, 'onSearch': __context.values.error.onSearch, 'onChange': __context.values.error.onChange } }, [])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.widget(multi_select_1.MultiSelect, { html: {}, wml: { 'id': __context.values.block.id }, ww: { 'name': __context.values.block.name, 'label': __context.values.block.label, 'block': true, 'stringifier': __context.values.block.stringifier, 'onSearch': __context.values.block.onSearch, 'onChange': __context.values.block.onChange } }, [])
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/control/multi-select":56,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],181:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/paginator");
var scenes = [
    'Page 1',
    'Page 2',
    'Page 3',
    'Page 4',
    'Page 5',
    'Page 6',
    'Page 7',
    'Page 8',
    'Page 9',
    'Page 10'
];
var PaginatorPage = /** @class */ (function () {
    function PaginatorPage() {
        var _this = this;
        this.view = new views.Main(this);
        this.values = {
            message: scenes[0],
            current: 1,
            total: scenes.length,
            onChange: function (e) {
                _this.values.message = scenes[e.value - 1];
                _this.values.current = e.value;
                _this.view.invalidate();
            }
        };
    }
    return PaginatorPage;
}());
exports.PaginatorPage = PaginatorPage;
exports.default = new PaginatorPage();

},{"./wml/paginator":182}],182:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var demo_1 = require("../../../widgets/demo");
;
var paginator_1 = require("../../../../../../lib/control/paginator");
;
var lib_1 = require("../../../../../../lib");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.widget(paginator_1.Paginator, { html: {}, wml: {}, ww: { 'total': __context.values.total, 'current': __context.values.current, 'onChange': __context.values.onChange } }, []),
                __this.node('p', { html: {}, wml: {} }, [
                    lib_1.text(__context.values.message)
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib":101,"../../../../../../lib/control/paginator":58,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],183:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/search");
var results_1 = require("../../fixtures/data/results");
var SearchPage = /** @class */ (function () {
    function SearchPage() {
        this.view = new views.Main(this);
        this.values = {
            id: 'search',
            name: 'search',
            id2: 'search2',
            name2: 'search2',
            stringifier: function (r) { return r.value; },
            onSearch: onSearch(this),
            onSelect: onSelect,
        };
    }
    return SearchPage;
}());
exports.SearchPage = SearchPage;
var onSearch = function (page) { return function (_a) {
    var name = _a.name, value = _a.value;
    return page
        .view
        .findById(name)
        .map(function (s) {
        var hit = results_1.results.filter(function (c) {
            return c.value.toLowerCase().startsWith(value.toLowerCase()) ? true : false;
        });
        s.update(hit);
    });
}; };
var onSelect = function (_a) {
    var value = _a.value;
    return alert("Selected \"" + value.value + "\"");
};
exports.default = new SearchPage();

},{"../../fixtures/data/results":148,"./wml/search":184}],184:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var demo_1 = require("../../../widgets/demo");
;
var search_1 = require("../../../../../../lib/control/search");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('p', { html: {}, wml: {} }, [
                        __this.widget(search_1.Search, { html: {}, wml: { 'id': __context.values.id }, ww: { 'name': __context.values.name, 'stringifier': __context.values.stringifier, 'onSearch': __context.values.onSearch, 'onSelect': __context.values.onSelect } }, [])
                    ])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('p', { html: {}, wml: {} }, [
                        __this.widget(search_1.Search, { html: {}, wml: { 'id': __context.values.id2 }, ww: { 'name': __context.values.name2, 'block': true, 'stringifier': __context.values.stringifier, 'onSearch': __context.values.onSearch, 'onSelect': __context.values.onSelect } }, [])
                    ])
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/control/search":62,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],185:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/select");
var results_1 = require("../../fixtures/data/results");
var SelectPage = /** @class */ (function () {
    function SelectPage() {
        this.view = new views.Main(this);
        this.values = {
            normal: {
                id: 'normal',
                name: 'normal',
                label: 'Normal',
                value: results_1.results[2],
                stringifier: function (r) { return r.value; },
                onSearch: doSearch(this),
                onChange: doChange(this),
                onUnset: doUnset(this)
            },
            block: {
                id: 'block',
                name: 'block',
                label: 'Block',
                stringifier: function (r) { return r.value; },
                onSearch: doSearch(this),
                onChange: doChange(this),
                onUnset: doUnset(this)
            },
            success: {
                id: 'success',
                name: 'success',
                label: 'Success',
                stringifier: function (r) { return r.value; },
                message: 'This has a success message.',
                onSearch: doSearch(this),
                onChange: doChange(this),
                onUnset: doUnset(this)
            },
            warning: {
                id: 'warning',
                name: 'warning',
                label: 'Warning',
                stringifier: function (r) { return r.value; },
                message: 'This has a warning message.',
                onSearch: doSearch(this),
                onChange: doChange(this),
                onUnset: doUnset(this)
            },
            error: {
                id: 'error',
                name: 'error',
                label: 'Error',
                stringifier: function (r) { return r.value; },
                message: 'This has a error message.',
                onSearch: doSearch(this),
                onChange: doChange(this),
                onUnset: doUnset(this)
            },
        };
    }
    return SelectPage;
}());
exports.SelectPage = SelectPage;
var doSearch = function (page) { return function (_a) {
    var name = _a.name, value = _a.value;
    return page
        .view
        .findById(name)
        .map(function (s) {
        var hit = results_1.results.filter(function (c) {
            return c.value.toLowerCase().startsWith(value) ? true : false;
        });
        s.update(hit);
    });
}; };
var doChange = function (page) { return function (_a) {
    var name = _a.name, value = _a.value;
    return page
        .view
        .findById(name)
        .map(function (t) {
        t.setMessage("Selected: " + value.value);
    });
}; };
var doUnset = function (page) { return function (_a) {
    var name = _a.name;
    return page
        .view
        .findById(name)
        .map(function (t) {
        t.setMessage('');
    });
}; };
exports.default = new SelectPage();

},{"../../fixtures/data/results":148,"./wml/select":186}],186:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var demo_1 = require("../../../widgets/demo");
;
var select_1 = require("../../../../../../lib/control/select");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.widget(select_1.Select, { html: {}, wml: { 'id': __context.values.normal.id }, ww: { 'name': __context.values.normal.name, 'label': __context.values.normal.label, 'value': __context.values.normal.value, 'stringifier': __context.values.normal.stringifier, 'onSearch': __context.values.normal.onSearch, 'onChange': __context.values.normal.onChange } }, [])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.widget(select_1.Select, { html: {}, wml: { 'id': __context.values.success.id }, ww: { 'name': __context.values.success.name, 'label': __context.values.success.label, 'success': __context.values.success.message, 'stringifier': __context.values.success.stringifier, 'onSearch': __context.values.success.onSearch, 'onChange': __context.values.success.onChange } }, [])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.widget(select_1.Select, { html: {}, wml: { 'id': __context.values.warning.id }, ww: { 'name': __context.values.warning.name, 'label': __context.values.warning.label, 'warning': __context.values.warning.message, 'stringifier': __context.values.warning.stringifier, 'onSearch': __context.values.warning.onSearch, 'onChange': __context.values.warning.onChange } }, [])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.widget(select_1.Select, { html: {}, wml: { 'id': __context.values.error.id }, ww: { 'name': __context.values.error.name, 'label': __context.values.error.label, 'error': __context.values.error.message, 'stringifier': __context.values.error.stringifier, 'onSearch': __context.values.error.onSearch, 'onChange': __context.values.error.onChange } }, [])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.widget(select_1.Select, { html: {}, wml: { 'id': __context.values.block.id }, ww: { 'name': __context.values.block.name, 'label': __context.values.block.label, 'block': true, 'stringifier': __context.values.block.stringifier, 'onSearch': __context.values.block.onSearch, 'onChange': __context.values.block.onChange } }, [])
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/control/select":64,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],187:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/stack-select");
var results_1 = require("../../fixtures/data/results");
var StackSelectPage = /** @class */ (function () {
    function StackSelectPage() {
        this.view = new views.Main(this);
        this.values = {
            asc: {
                id: 'asc',
                name: 'asc',
                label: 'Ascending',
                value: results_1.results[2],
                stringifier: function (r) { return r.value; },
                onSearch: onSearch(this),
                onChange: onChange(this),
            },
            desc: {
                id: 'desc',
                name: 'desc',
                label: 'Descending',
                stringifier: function (r) { return r.value; },
                onSearch: onSearch(this),
                onChange: onChange(this),
            },
            success: {
                id: 'success',
                name: 'success',
                label: 'Success',
                stringifier: function (r) { return r.value; },
                message: 'This has a success message.',
                onSearch: onSearch(this),
                onChange: onChange(this),
            },
            warning: {
                id: 'warning',
                name: 'warning',
                label: 'Warning',
                stringifier: function (r) { return r.value; },
                message: 'This has a warning message.',
                onSearch: onSearch(this),
                onChange: onChange(this),
            },
            error: {
                id: 'error',
                name: 'error',
                label: 'Error',
                stringifier: function (r) { return r.value; },
                message: 'This has a error message.',
                onSearch: onSearch(this),
                onChange: onChange(this),
            },
        };
    }
    return StackSelectPage;
}());
exports.StackSelectPage = StackSelectPage;
var onSearch = function (page) { return function (_a) {
    var name = _a.name, value = _a.value;
    return page
        .view
        .findById(name)
        .map(function (s) {
        var hit = results_1.results.filter(function (c) {
            return c.value.toLowerCase().startsWith(value) ? true : false;
        });
        s.update(hit);
    });
}; };
var onChange = function (page) { return function (_a) {
    var name = _a.name, value = _a.value;
    return page
        .view
        .findById(name)
        .map(function (t) {
        t.setMessage("Count: " + value.length);
    });
}; };
exports.default = new StackSelectPage();

},{"../../fixtures/data/results":148,"./wml/stack-select":188}],188:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var demo_1 = require("../../../widgets/demo");
;
var stack_select_1 = require("../../../../../../lib/control/stack-select");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.widget(stack_select_1.StackSelect, { html: {}, wml: { 'id': __context.values.asc.id }, ww: { 'name': __context.values.asc.name, 'label': __context.values.asc.label, 'stringifier': __context.values.asc.stringifier, 'onSearch': __context.values.asc.onSearch, 'onChange': __context.values.asc.onChange } }, [])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.widget(stack_select_1.StackSelect, { html: {}, wml: { 'id': __context.values.desc.id }, ww: { 'name': __context.values.desc.name, 'label': __context.values.desc.label, 'dir': -1, 'stringifier': __context.values.desc.stringifier, 'onSearch': __context.values.desc.onSearch, 'onChange': __context.values.desc.onChange } }, [])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.widget(stack_select_1.StackSelect, { html: {}, wml: { 'id': __context.values.success.id }, ww: { 'name': __context.values.success.name, 'label': __context.values.success.label, 'success': __context.values.success.message, 'stringifier': __context.values.success.stringifier, 'onSearch': __context.values.success.onSearch, 'onChange': __context.values.success.onChange } }, [])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.widget(stack_select_1.StackSelect, { html: {}, wml: { 'id': __context.values.warning.id }, ww: { 'name': __context.values.warning.name, 'label': __context.values.warning.label, 'warning': __context.values.warning.message, 'stringifier': __context.values.warning.stringifier, 'onSearch': __context.values.warning.onSearch, 'onChange': __context.values.warning.onChange } }, [])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.widget(stack_select_1.StackSelect, { html: {}, wml: { 'id': __context.values.error.id }, ww: { 'name': __context.values.error.name, 'label': __context.values.error.label, 'error': __context.values.error.message, 'stringifier': __context.values.error.stringifier, 'onSearch': __context.values.error.onSearch, 'onChange': __context.values.error.onChange } }, [])
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/control/stack-select":66,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],189:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/stack");
var _getValues = function () { return [
    { label: 'Asus', value: 'Asus' },
    { label: 'MSI', value: 'MSI' },
    { label: 'MSI', value: 'MSI' },
    { label: 'Gigabyte', value: 'Gigabyte' }
]; };
var _getText = function (m) {
    return document.createTextNode(m.map(function (_a) {
        var label = _a.label;
        return label;
    }).join(','));
};
var StackPage = /** @class */ (function () {
    function StackPage() {
        var _this = this;
        this.view = new views.Main(this);
        this.values = {
            values: _getValues(),
            text: _getText(_getValues()),
            decorator: function (m) { return m.label; }
        };
        this.onChange = function (_a) {
            var value = _a.value;
            if (value.length === 0)
                _this.values.values = _getValues();
            _this.values.text = _getText(_this.values.values);
            _this.view.invalidate();
        };
    }
    return StackPage;
}());
exports.StackPage = StackPage;
exports.default = new StackPage();

},{"./wml/stack":190}],190:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var demo_1 = require("../../../widgets/demo");
;
var stack_1 = require("../../../../../../lib/control/stack");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.node('p', { html: {}, wml: {} }, [
                    document.createTextNode("Members: "),
                    __this.node('b', { html: {}, wml: { 'id': "selected" } }, [
                        __context.values.text
                    ]),
                    document.createTextNode(".")
                ]),
                __this.node('p', { html: {}, wml: {} }, [
                    __this.widget(stack_1.Stack, { html: {}, wml: {}, ww: { 'name': "stack", 'value': __context.values.values, 'decorator': __context.values.decorator, 'onChange': __context.onChange } }, [])
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/control/stack":68,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],191:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/switch");
var SwitchPage = /** @class */ (function () {
    function SwitchPage() {
        var _this = this;
        this.view = new views.Main(this);
        this.value = true;
        this.onChange = function (_a) {
            var value = _a.value;
            _this.view.findById('content')
                .map(function (e) {
                while (e.firstChild)
                    e.removeChild(e.firstChild);
                e.appendChild(document.createTextNode(value === true ?
                    'on' :
                    (value === false ? 'off' : 'error')));
            });
        };
    }
    return SwitchPage;
}());
exports.SwitchPage = SwitchPage;
exports.default = new SwitchPage();

},{"./wml/switch":192}],192:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var demo_1 = require("../../../widgets/demo");
;
var switch_1 = require("../../../../../../lib/control/switch");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('p', { html: {}, wml: {} }, [
                        document.createTextNode("The switch is already set.")
                    ]),
                    __this.node('p', { html: {}, wml: {} }, [
                        __this.widget(switch_1.Switch, { html: {}, wml: {}, ww: { 'name': "switch", 'value': true } }, [])
                    ])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('p', { html: {}, wml: {} }, [
                        document.createTextNode("The switch is "),
                        __this.node('b', { html: {}, wml: { 'id': "content" } }, [
                            document.createTextNode("untouched")
                        ]),
                        document.createTextNode(".")
                    ]),
                    __this.node('p', { html: {}, wml: {} }, [
                        __this.widget(switch_1.Switch, { html: {}, wml: {}, ww: { 'name': "switch", 'onChange': __context.onChange } }, [])
                    ])
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/control/switch":70,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],193:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/tab-bar");
var TabBarPage = /** @class */ (function () {
    function TabBarPage() {
        var _this = this;
        this.view = new views.Main(this);
        this.tab = 'First';
        this.content = document.createTextNode('First Tab');
        this.clicked = function (_a) {
            var name = _a.name;
            _this.tab = name;
            _this.content = document.createTextNode(name + " Tab");
            _this.view.invalidate();
        };
    }
    return TabBarPage;
}());
exports.TabBarPage = TabBarPage;
exports.default = new TabBarPage();

},{"./wml/tab-bar":194}],194:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var demo_1 = require("../../../widgets/demo");
;
var tab_bar_1 = require("../../../../../../lib/control/tab-bar");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.widget(tab_bar_1.TabBar, { html: {}, wml: {} }, [
                        __this.widget(tab_bar_1.Tab, { html: {}, wml: {}, ww: { 'active': (__context.tab === "First"), 'text': "First", 'name': "First", 'onClick': __context.clicked } }, []),
                        __this.widget(tab_bar_1.Tab, { html: {}, wml: {}, ww: { 'active': (__context.tab === "Second"), 'text': "Second", 'name': "Second", 'onClick': __context.clicked } }, []),
                        __this.widget(tab_bar_1.Tab, { html: {}, wml: {}, ww: { 'active': (__context.tab === "Third"), 'text': "Third", 'name': "Third", 'onClick': __context.clicked } }, [])
                    ])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.widget(tab_bar_1.TabBar, { html: {}, wml: {}, ww: { 'justify': true } }, [
                        __this.widget(tab_bar_1.Tab, { html: {}, wml: {}, ww: { 'active': (__context.tab === "First"), 'text': "First", 'name': "First", 'onClick': __context.clicked } }, []),
                        __this.widget(tab_bar_1.Tab, { html: {}, wml: {}, ww: { 'active': (__context.tab === "Second"), 'text': "Second", 'name': "Second", 'onClick': __context.clicked } }, []),
                        __this.widget(tab_bar_1.Tab, { html: {}, wml: {}, ww: { 'active': (__context.tab === "Third"), 'text': "Third", 'name': "Third", 'onClick': __context.clicked } }, [])
                    ])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('p', { html: {}, wml: { 'id': "content" } }, [
                        __context.content
                    ])
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/control/tab-bar":72,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],195:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/tag");
var style_1 = require("../../../../../lib/content/style");
var getStyles = function () { return [
    style_1.Style.Default,
    style_1.Style.Primary,
    style_1.Style.Success,
    style_1.Style.Info,
    style_1.Style.Warning,
    style_1.Style.Error
]; };
var TagPage = /** @class */ (function () {
    function TagPage() {
        var _this = this;
        this.view = new views.Main(this);
        this.values = {
            capitalize: function (s) { return "" + s[0].toUpperCase() + s.slice(1); },
            styles: getStyles(),
            onDismiss: function (e) {
                var idx = _this.values.styles.indexOf(e.name);
                if (idx > -1)
                    _this.values.styles.splice(idx, 1);
                if (_this.values.styles.length === 0)
                    _this.values.styles = getStyles();
                _this.view.invalidate();
            }
        };
    }
    return TagPage;
}());
exports.TagPage = TagPage;
exports.default = new TagPage();

},{"../../../../../lib/content/style":19,"./wml/tag":196}],196:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var tag_1 = require("../../../../../../lib/control/tag");
;
var demo_1 = require("../../../widgets/demo");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('h1', { html: {}, wml: {} }, [
                        document.createTextNode("Tag")
                    ]),
                    __this.node('p', { html: {}, wml: {} }, __spreadArrays([
                        __this.node('h2', { html: {}, wml: {} }, [
                            document.createTextNode("Styles")
                        ])
                    ], __forIn(__context.values.styles, function (v, _$$i, _$$all) {
                        return ([
                            __this.widget(tag_1.Tag, { html: {}, wml: {}, ww: { 'style': v, 'text': __context.values.capitalize(v), 'name': v, 'onDismiss': __context.values.onDismiss } }, [])
                        ]);
                    }, function () { return ([]); })))
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/control/tag":74,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],197:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/text-field");
var feedback_1 = require("../../../../../lib/control/feedback");
var TextFieldPage = /** @class */ (function () {
    function TextFieldPage() {
        var _this = this;
        this.id = 'text';
        this.view = new views.Main(this);
        this.onChange = function (_a) {
            var name = _a.name, value = _a.value;
            var maybeField = _this.view.findById(name);
            if (maybeField.isJust()) {
                var t = maybeField.get();
                switch (value) {
                    case 'neutral':
                        t.setValidationState(feedback_1.ValidationState.Neutral);
                        break;
                    case 'error':
                        t.setValidationState(feedback_1.ValidationState.Error);
                        break;
                    case 'success':
                        t.setValidationState(feedback_1.ValidationState.Success);
                        break;
                    case 'warning':
                        t.setValidationState(feedback_1.ValidationState.Warning);
                        break;
                    default:
                        break;
                }
                t.setMessage("Message: " + value);
            }
        };
    }
    return TextFieldPage;
}());
exports.TextFieldPage = TextFieldPage;
exports.default = new TextFieldPage();

},{"../../../../../lib/control/feedback":44,"./wml/text-field":198}],198:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var demo_1 = require("../../../widgets/demo");
;
var feedback_1 = require("../../../../../../lib/control/feedback");
;
var text_field_1 = require("../../../../../../lib/control/text-field");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('p', { html: {}, wml: {} }, [
                        document.createTextNode("The value of the input is:")
                    ]),
                    __this.node('p', { html: {}, wml: {} }, [
                        __this.node('b', { html: {}, wml: { 'id': "content" } }, [
                            document.createTextNode("Nothing")
                        ])
                    ]),
                    __this.node('p', { html: {}, wml: {} }, [
                        __this.widget(text_field_1.TextField, { html: {}, wml: { 'id': "text" }, ww: { 'name': "text", 'message': "This is the help message", 'onChange': __context.onChange } }, [])
                    ])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('p', { html: {}, wml: {} }, [
                        __this.node('strong', { html: {}, wml: {} }, [
                            document.createTextNode("Success")
                        ])
                    ]),
                    __this.node('p', { html: {}, wml: {} }, [
                        __this.widget(text_field_1.TextField, { html: {}, wml: { 'id': "success" }, ww: { 'name': "success", 'validationState': feedback_1.ValidationState.Success, 'label': "This is a success label", 'success': "This textfield has a success", 'onChange': __context.onChange } }, [])
                    ])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('p', { html: {}, wml: {} }, [
                        __this.node('strong', { html: {}, wml: {} }, [
                            document.createTextNode("Warning")
                        ])
                    ]),
                    __this.node('p', { html: {}, wml: {} }, [
                        __this.widget(text_field_1.TextField, { html: {}, wml: { 'id': "warning" }, ww: { 'name': "warning", 'validationState': feedback_1.ValidationState.Warning, 'label': "This is a warning label", 'warning': "This textfield has a warning.", 'onChange': __context.onChange } }, [])
                    ])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('p', { html: {}, wml: {} }, [
                        __this.node('strong', { html: {}, wml: {} }, [
                            document.createTextNode("Error")
                        ])
                    ]),
                    __this.node('p', { html: {}, wml: {} }, [
                        __this.widget(text_field_1.TextField, { html: {}, wml: { 'id': "error" }, ww: { 'name': "error", 'validationState': feedback_1.ValidationState.Error, 'label': "This is an error label", 'error': "This textfield has an error.", 'onChange': __context.onChange } }, [])
                    ])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('p', { html: {}, wml: {} }, [
                        document.createTextNode("The one uses rows to render a text area:")
                    ]),
                    __this.node('p', { html: {}, wml: {} }, [
                        __this.widget(text_field_1.TextField, { html: {}, wml: { 'id': "area" }, ww: { 'name': "area", 'rows': 5, 'label': "This is a textarea label", 'onChange': __context.onChange } }, [])
                    ])
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/control/feedback":44,"../../../../../../lib/control/text-field":76,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],199:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/text-input");
var size_1 = require("../../../../../lib/content/size");
var TextInputPage = /** @class */ (function () {
    function TextInputPage() {
        var _this = this;
        this.view = new views.Main(this);
        this.sizes = [
            size_1.Size.ExtraSmall,
            size_1.Size.Small,
            size_1.Size.Medium,
            size_1.Size.Large,
            size_1.Size.ExtraLarge
        ];
        this.content = function () { return document.createTextNode('this'); };
        this.onChange = function (_a) {
            var value = _a.value;
            _this
                .view
                .findById('txt')
                .map(function (h) { return h.innerHTML = value; });
        };
    }
    return TextInputPage;
}());
exports.TextInputPage = TextInputPage;
exports.default = new TextInputPage();

},{"../../../../../lib/content/size":16,"./wml/text-input":200}],200:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var text_input_1 = require("../../../../../../lib/control/text-input");
;
var demo_1 = require("../../../widgets/demo");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('p', { html: {}, wml: {} }, [
                        document.createTextNode("This is a text input: "),
                        __this.widget(text_input_1.TextInput, { html: {}, wml: {}, ww: { 'onChange': __context.onChange } }, []),
                        document.createTextNode(".")
                    ]),
                    __this.node('p', { html: {}, wml: {} }, [
                        document.createTextNode("As you type "),
                        __this.node('b', { html: {}, wml: { 'id': "txt" } }, [
                            document.createTextNode("this")
                        ]),
                        document.createTextNode(" changes.")
                    ])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, __spreadArrays(__forIn(__context.sizes, function (v, _$$i, _$$all) {
                    return ([
                        __this.node('p', { html: {}, wml: {} }, [
                            document.createTextNode("\n        Size "),
                            document.createTextNode((v + " neutral: ")),
                            __this.widget(text_input_1.TextInput, { html: {}, wml: {}, ww: { 'onChange': __context.onChange, 'size': v } }, [])
                        ]),
                        __this.node('p', { html: {}, wml: {} }, [
                            document.createTextNode("\n        Size "),
                            document.createTextNode((v + " error: ")),
                            __this.widget(text_input_1.TextInput, { html: {}, wml: {}, ww: { 'onChange': __context.onChange, 'size': v, 'className': "-error" } }, [])
                        ]),
                        __this.node('p', { html: {}, wml: {} }, [
                            document.createTextNode("\n        Size "),
                            document.createTextNode((v + " warning: ")),
                            __this.widget(text_input_1.TextInput, { html: {}, wml: {}, ww: { 'onChange': __context.onChange, 'size': v, 'className': "-warning" } }, [])
                        ]),
                        __this.node('p', { html: {}, wml: {} }, [
                            document.createTextNode("\n        Size "),
                            document.createTextNode((v + " success: ")),
                            __this.widget(text_input_1.TextInput, { html: {}, wml: {}, ww: { 'onChange': __context.onChange, 'size': v, 'className': "-success" } }, [])
                        ])
                    ]);
                }, function () { return ([]); }))),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('p', { html: {}, wml: {} }, [
                        document.createTextNode("\n      Block:\n      "),
                        __this.widget(text_input_1.TextInput, { html: {}, wml: {}, ww: { 'onChange': __context.onChange, 'block': true } }, [])
                    ])
                ]),
                __this.node('p', { html: {}, wml: {} }, [
                    document.createTextNode(" Textarea: ")
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, __spreadArrays(__forIn(__context.sizes, function (v, _$$i, _$$all) {
                    return ([
                        __this.node('p', { html: {}, wml: {} }, [
                            document.createTextNode("\n        Size "),
                            document.createTextNode((v + " neutral: ")),
                            __this.widget(text_input_1.TextInput, { html: {}, wml: {}, ww: { 'onChange': __context.onChange, 'rows': 5, 'size': v } }, [])
                        ]),
                        __this.node('p', { html: {}, wml: {} }, [
                            document.createTextNode("\n        Size "),
                            document.createTextNode((v + " error: ")),
                            __this.widget(text_input_1.TextInput, { html: {}, wml: {}, ww: { 'onChange': __context.onChange, 'size': v, 'rows': 5, 'className': "-error" } }, [])
                        ]),
                        __this.node('p', { html: {}, wml: {} }, [
                            document.createTextNode("\n        Size "),
                            document.createTextNode((v + " warning: ")),
                            __this.widget(text_input_1.TextInput, { html: {}, wml: {}, ww: { 'onChange': __context.onChange, 'size': v, 'rows': 5, 'className': "-warning" } }, [])
                        ]),
                        __this.node('p', { html: {}, wml: {} }, [
                            document.createTextNode("\n        Size "),
                            document.createTextNode((v + " success: ")),
                            __this.widget(text_input_1.TextInput, { html: {}, wml: {}, ww: { 'onChange': __context.onChange, 'size': v, 'rows': 5, 'className': "-success" } }, [])
                        ])
                    ]);
                }, function () { return ([]); }))),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('p', { html: {}, wml: {} }, [
                        document.createTextNode("\n      Block:\n      "),
                        __this.widget(text_input_1.TextInput, { html: {}, wml: {}, ww: { 'onChange': __context.onChange, 'block': true, 'rows': 5 } }, [])
                    ])
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/control/text-input":78,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],201:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/typeahead");
var results = [
    { label: 'Asus', value: 'Asus' },
    { label: 'MSI', value: 'MSI' },
    { label: 'Gigabyte', value: 'Gigabyte' },
    { label: 'Gigas', value: 'Gigas' },
    { label: 'AsusTek', value: 'AsusTek' },
    { label: 'Asusuga', value: 'Asusuga' },
    { label: 'Qualcomm', value: 'Qualcomm' },
    { label: 'Qualitative', value: 'Qualitatve' },
    { label: 'Kirpalani\'s', value: 'Kirpalani\'s' },
    { label: 'Asunder', value: 'Asunder' }
];
var TypeaheadPage = /** @class */ (function () {
    function TypeaheadPage() {
        this.view = new views.Main(this);
        this.values = {
            normal: {
                id: 'normal',
                name: 'normal',
                label: 'Normal',
                value: 'Normal',
                stringifier: function (r) { return r.value; },
                onSearch: doSearch(this),
                onChange: doChange(this)
            },
            block: {
                id: 'block',
                name: 'block',
                label: 'Block',
                stringifier: function (r) { return r.value; },
                onSearch: doSearch(this),
                onChange: doChange(this)
            },
            success: {
                id: 'success',
                name: 'success',
                label: 'Success',
                stringifier: function (r) { return r.value; },
                message: 'This has a success message.',
                onSearch: doSearch(this),
                onChange: doChange(this)
            },
            warning: {
                id: 'warning',
                name: 'warning',
                label: 'Warning',
                stringifier: function (r) { return r.value; },
                message: 'This has a warning message.',
                onSearch: doSearch(this),
                onChange: doChange(this)
            },
            error: {
                id: 'error',
                name: 'error',
                label: 'Error',
                stringifier: function (r) { return r.value; },
                message: 'This has a error message.',
                onSearch: doSearch(this),
                onChange: doChange(this)
            },
        };
    }
    return TypeaheadPage;
}());
exports.TypeaheadPage = TypeaheadPage;
var doSearch = function (page) { return function (_a) {
    var name = _a.name, value = _a.value;
    return page
        .view
        .findById(name)
        .map(function (s) {
        var hit = results.filter(function (c) {
            return c.value.toLowerCase().startsWith(value) ? true : false;
        });
        s.update(hit);
    });
}; };
var doChange = function (page) { return function (_a) {
    var name = _a.name, value = _a.value;
    return page
        .view
        .findById(name)
        .map(function (t) {
        t.setMessage("Selected: " + value);
    });
}; };
exports.default = new TypeaheadPage();

},{"./wml/typeahead":202}],202:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var demo_1 = require("../../../widgets/demo");
;
var typeahead_1 = require("../../../../../../lib/control/typeahead");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.widget(typeahead_1.Typeahead, { html: {}, wml: { 'id': __context.values.normal.id }, ww: { 'name': __context.values.normal.name, 'label': __context.values.normal.label, 'stringifier': __context.values.normal.stringifier, 'onSearch': __context.values.normal.onSearch, 'onChange': __context.values.normal.onChange } }, [])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.widget(typeahead_1.Typeahead, { html: {}, wml: { 'id': __context.values.success.id }, ww: { 'name': __context.values.success.name, 'label': __context.values.success.label, 'success': __context.values.success.message, 'stringifier': __context.values.success.stringifier, 'onSearch': __context.values.success.onSearch, 'onChange': __context.values.success.onChange } }, [])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.widget(typeahead_1.Typeahead, { html: {}, wml: { 'id': __context.values.warning.id }, ww: { 'name': __context.values.warning.name, 'label': __context.values.warning.label, 'warning': __context.values.warning.message, 'stringifier': __context.values.warning.stringifier, 'onSearch': __context.values.warning.onSearch, 'onChange': __context.values.warning.onChange } }, [])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.widget(typeahead_1.Typeahead, { html: {}, wml: { 'id': __context.values.error.id }, ww: { 'name': __context.values.error.name, 'label': __context.values.error.label, 'error': __context.values.error.message, 'stringifier': __context.values.error.stringifier, 'onSearch': __context.values.error.onSearch, 'onChange': __context.values.error.onChange } }, [])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.widget(typeahead_1.Typeahead, { html: {}, wml: { 'id': __context.values.block.id }, ww: { 'name': __context.values.block.name, 'label': __context.values.block.label, 'block': true, 'stringifier': __context.values.block.stringifier, 'onSearch': __context.values.block.onSearch, 'onChange': __context.values.block.onChange } }, [])
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/control/typeahead":82,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],203:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.users = [
    {
        "_id": "59f1334ccc21ff728cf7f3ce",
        "index": 0,
        "guid": "fd94cd52-e7f1-44ab-a74f-05604eee46dd",
        "isActive": false,
        "balance": "$2,849.93",
        "picture": "http://placehold.it/32x32",
        "age": 34,
        "eyeColor": "green",
        "name": "Johns Lewis",
        "gender": "female",
        "company": "PROFLEX",
        "email": "johnslewis@proflex.com",
        "phone": "+1 (925) 409-3400",
        "address": "874 Grove Street, Edgewater, Georgia, 8112",
        "about": "Ex esse dolore et sint sint proident nostrud ut officia. Do nulla mollit dolore ut aute excepteur deserunt laboris ut proident. Ullamco est deserunt ex commodo veniam duis elit excepteur velit ullamco deserunt culpa do est.\r\n",
        "registered": "2015-02-22T10:25:32 +04:00",
        "latitude": 56.278862,
        "longitude": -79.459101,
        "tags": [
            "labore",
            "proident",
            "aliqua",
            "amet",
            "amet",
            "officia",
            "enim"
        ],
        "friends": [
            {
                "id": 0,
                "name": "Mason Noble"
            },
            {
                "id": 1,
                "name": "Coffey Mendez"
            },
            {
                "id": 2,
                "name": "Dionne Cole"
            }
        ],
        "greeting": "Hello, Johns Lewis! You have 5 unread messages.",
        "favoriteFruit": "banana"
    },
    {
        "_id": "59f1334c09dc1bcdc5732491",
        "index": 1,
        "guid": "33255995-0431-4271-9876-37eabc117a7b",
        "isActive": false,
        "balance": "$2,167.40",
        "picture": "http://placehold.it/32x32",
        "age": 23,
        "eyeColor": "blue",
        "name": "Williamson Gregory",
        "gender": "undefined",
        "company": "NETAGY",
        "email": "williamsongregory@netagy.com",
        "phone": "+1 (910) 462-3918",
        "address": "158 Sedgwick Street, Glasgow, Utah, 5498",
        "about": "Excepteur sit nisi et velit. Laboris minim id duis ad qui cupidatat. Est Lorem quis duis Lorem laboris velit laboris non excepteur et velit voluptate qui. Dolore qui anim exercitation veniam incididunt laboris labore. Id minim labore amet sunt excepteur tempor proident.\r\n",
        "registered": "2016-04-25T04:25:24 +04:00",
        "latitude": 54.457833,
        "longitude": 122.803765,
        "tags": [
            "tempor",
            "exercitation",
            "et",
            "elit",
            "ex",
            "cillum",
            "laboris"
        ],
        "friends": [
            {
                "id": 0,
                "name": "Navarro Reeves"
            },
            {
                "id": 1,
                "name": "Stanton Vincent"
            },
            {
                "id": 2,
                "name": "Alexis Guzman"
            }
        ],
        "greeting": "Hello, Williamson Gregory! You have 1 unread messages.",
        "favoriteFruit": "apple"
    },
    {
        "_id": "59f1334c9d799789bc494a3c",
        "index": 2,
        "guid": "158ffa5d-15da-4a9f-a1da-0a48b76b8226",
        "isActive": false,
        "balance": "$1,289.35",
        "picture": "http://placehold.it/32x32",
        "age": 33,
        "eyeColor": "green",
        "name": "Dalton House",
        "gender": "male",
        "company": "EYEWAX",
        "email": "daltonhouse@eyewax.com",
        "phone": "+1 (959) 550-2263",
        "address": "116 Howard Avenue, Rossmore, New York, 6302",
        "about": "Elit eu ipsum pariatur duis mollit ex quis. Amet nulla exercitation laboris minim fugiat tempor in aliqua nisi nostrud aute. Duis minim esse irure irure fugiat sit nulla et tempor nisi cillum proident id adipisicing. Eu elit magna Lorem irure labore. Aliquip id sint veniam adipisicing. Amet eiusmod mollit reprehenderit reprehenderit dolore.\r\n",
        "registered": "2017-02-28T08:53:00 +04:00",
        "latitude": -25.679774,
        "longitude": 29.374781,
        "tags": [
            "qui",
            "cillum",
            "anim",
            "irure",
            "non",
            "commodo",
            "deserunt"
        ],
        "friends": [
            {
                "id": 0,
                "name": "Carmela Wilcox"
            },
            {
                "id": 1,
                "name": "Elba Garza"
            },
            {
                "id": 2,
                "name": "Garrison Church"
            }
        ],
        "greeting": "Hello, Dalton House! You have 1 unread messages.",
        "favoriteFruit": "apple"
    },
    {
        "_id": "59f1334cd1518c3a44d69fff",
        "index": 3,
        "guid": "5109bc50-9a8e-4184-aba0-6740dc00b606",
        "isActive": true,
        "balance": "$3,891.83",
        "picture": "http://placehold.it/32x32",
        "age": 22,
        "eyeColor": "blue",
        "name": "Ray Wilkins",
        "gender": "male",
        "company": "EXPOSA",
        "email": "raywilkins@exposa.com",
        "phone": "+1 (812) 414-3258",
        "address": "837 Bedford Avenue, Harleigh, South Carolina, 2323",
        "about": "Est amet quis eu proident ipsum veniam sit. Irure labore ad consectetur ullamco sit ipsum proident. Ad pariatur irure nisi irure commodo aliquip nisi eu anim irure dolor dolor veniam quis.\r\n",
        "registered": "2015-09-17T04:52:42 +04:00",
        "latitude": 34.354801,
        "longitude": -168.303952,
        "tags": [
            "nisi",
            "laboris",
            "incididunt",
            "amet",
            "aute",
            "quis",
            "mollit"
        ],
        "friends": [
            {
                "id": 0,
                "name": "Olivia Russo"
            },
            {
                "id": 1,
                "name": "Rita Tyler"
            },
            {
                "id": 2,
                "name": "Lorie Walker"
            }
        ],
        "greeting": "Hello, Ray Wilkins! You have 1 unread messages.",
        "favoriteFruit": "strawberry"
    },
    {
        "_id": "59f1334c6901bda003e52fa6",
        "index": 4,
        "guid": "0ab33477-b152-4b12-af35-f5b9254d5c2a",
        "isActive": true,
        "balance": "$3,730.71",
        "picture": "http://placehold.it/32x32",
        "age": 27,
        "eyeColor": "brown",
        "name": "Madden Hatfield",
        "gender": "male",
        "company": "ZOGAK",
        "email": "maddenhatfield@zogak.com",
        "phone": "+1 (832) 552-2294",
        "address": "530 Clermont Avenue, Bethpage, Virgin Islands, 5607",
        "about": "Commodo tempor anim tempor deserunt laboris qui eu reprehenderit consequat. Non laborum ullamco qui proident. Est cupidatat do dolor excepteur est nostrud laborum. Eu excepteur ex commodo aliquip adipisicing excepteur. Et reprehenderit laboris reprehenderit aute ut excepteur deserunt nostrud velit. Ullamco est sit fugiat irure aliqua aliquip proident. Voluptate ad culpa dolor id enim tempor laborum.\r\n",
        "registered": "2016-04-10T03:37:17 +04:00",
        "latitude": 80.888876,
        "longitude": 117.84337,
        "tags": [
            "occaecat",
            "nisi",
            "est",
            "ad",
            "nostrud",
            "eu",
            "dolore"
        ],
        "friends": [
            {
                "id": 0,
                "name": "Vincent Gay"
            },
            {
                "id": 1,
                "name": "Rosario Forbes"
            },
            {
                "id": 2,
                "name": "Baxter Green"
            }
        ],
        "greeting": "Hello, Madden Hatfield! You have 4 unread messages.",
        "favoriteFruit": "banana"
    }
];

},{}],204:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var table_1 = require("./wml/table");
var data_1 = require("./data");
var util_1 = require("../../../../../lib/util");
var columns = [
    { name: 'index', heading: '#', sort: 'yes' },
    { name: 'name', heading: 'Name', sort: 'yes' },
    { name: 'gender', heading: 'Gender', sort: 'yes' },
    { name: 'email', heading: 'Email', sort: 'yes' },
    { name: 'balance', heading: 'Balance', sort: 'yes' },
];
var DataTablePage = /** @class */ (function () {
    function DataTablePage() {
        var _this = this;
        this.view = new table_1.Main(this);
        this.values = {
            id: 'table',
            users: data_1.users,
            columns: columns,
            onCellClicked: function (e) {
                var mDT = util_1.getById(_this.view, _this.values.id);
                if (mDT.isNothing())
                    return;
                var dt = mDT.get();
                dt.getCell(e.column, e.row).cells.forEach(function (c) {
                    c.style.backgroundColor = 'red';
                    c.style.color = '#fff';
                });
            }
        };
    }
    return DataTablePage;
}());
exports.DataTablePage = DataTablePage;
exports.default = new DataTablePage();

},{"../../../../../lib/util":138,"./data":203,"./wml/table":205}],205:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var demo_1 = require("../../../widgets/demo");
;
var table_1 = require("../../../../../../lib/data/table");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.node('h3', { html: {}, wml: {} }, [
                    document.createTextNode("Data Table")
                ]),
                __this.widget(table_1.DataTable, { html: {}, wml: { 'id': __context.values.id }, ww: { 'sortable': true, 'onCellClicked': __context.values.onCellClicked, 'data': __context.values.users, 'columns': __context.values.columns } }, [])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/data/table":88,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],206:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var property_list_1 = require("./wml/property-list");
var data = {
    name: 'London Beta',
    age: '37',
    balance: '5000'
};
var money = function (s) { return "$" + s; };
var fields = [
    { name: 'name', heading: 'Name' },
    { name: 'age', heading: 'age' },
    { name: 'balance', heading: 'Balance', format: money }
];
var PropertyListPage = /** @class */ (function () {
    function PropertyListPage() {
        this.view = new property_list_1.Main(this);
        this.data = data;
        this.fields = fields;
    }
    return PropertyListPage;
}());
exports.PropertyListPage = PropertyListPage;
exports.default = new PropertyListPage();

},{"./wml/property-list":207}],207:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var demo_1 = require("../../../widgets/demo");
;
var property_list_1 = require("../../../../../../lib/data/property-list");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.widget(property_list_1.PropertyList, { html: {}, wml: {}, ww: { 'fields': __context.fields, 'data': __context.data } }, [])
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/data/property-list":84,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],208:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/alert");
var style_1 = require("../../../../../lib/content/style");
var AlertPage = /** @class */ (function () {
    function AlertPage() {
        this.view = new views.Main(this);
        this.values = {
            capitalize: function (s) { return "" + s[0].toUpperCase() + s.slice(1); },
            message: 'This is an alert',
            styles: [
                style_1.Style.Default,
                style_1.Style.Primary,
                style_1.Style.Success,
                style_1.Style.Info,
                style_1.Style.Warning,
                style_1.Style.Error
            ]
        };
    }
    return AlertPage;
}());
exports.AlertPage = AlertPage;
exports.default = new AlertPage();

},{"../../../../../lib/content/style":19,"./wml/alert":209}],209:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var alert_1 = require("../../../../../../lib/dialog/alert");
;
var demo_1 = require("../../../widgets/demo");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('h1', { html: {}, wml: {} }, [
                        document.createTextNode("Alerts")
                    ]),
                    __this.node('p', { html: {}, wml: {} }, __spreadArrays([
                        __this.node('h2', { html: {}, wml: {} }, [
                            document.createTextNode("Styles")
                        ])
                    ], __forIn(__context.values.styles, function (v, _$$i, _$$all) {
                        return ([
                            __this.widget(alert_1.Alert, { html: {}, wml: {}, ww: { 'style': v, 'closable': true, 'text': __context.values.capitalize(v) } }, [])
                        ]);
                    }, function () { return ([]); })))
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/dialog/alert":91,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],210:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/confirm");
var ConfirmPage = /** @class */ (function () {
    function ConfirmPage() {
        var _this = this;
        this.view = new views.Main(this);
        this.v = new views.Open(this);
        this.values = {
            title: 'Confirm a message',
            message: 'Would you like to confirm this message?',
            onYes: function () {
                alert('Message confirmed!');
            },
            onNo: function () {
                alert('Message rejected!');
            },
            open: function () {
                document.body.appendChild(_this.v.render());
            },
            close: function () {
                _this.v.findById('open')
                    .map(function (m) { return m.close(); });
            }
        };
    }
    return ConfirmPage;
}());
exports.ConfirmPage = ConfirmPage;
exports.default = new ConfirmPage();

},{"./wml/confirm":211}],211:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var confirm_1 = require("../../../../../../lib/dialog/confirm");
;
var lib_1 = require("../../../../../../lib");
;
var demo_1 = require("../../../widgets/demo");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.node('h1', { html: {}, wml: {} }, [
                    document.createTextNode("Confirm")
                ]),
                __this.node('p', { html: {}, wml: {} }, [
                    __this.node('button', { html: { 'onclick': __context.values.open }, wml: {} }, [
                        document.createTextNode("Open")
                    ])
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;
;
var Open = /** @class */ (function () {
    function Open(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(confirm_1.Confirm, { html: {}, wml: { 'id': "open" }, ww: { 'title': __context.values.title, 'onNo': __context.values.onNo, 'onYes': __context.values.onYes } }, [
                lib_1.text(__context.values.message)
            ]);
        };
    }
    Open.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Open.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Open.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Open.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Open.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Open.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Open.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Open;
}());
exports.Open = Open;

},{"../../../../../../lib":101,"../../../../../../lib/dialog/confirm":93,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],212:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/inform");
var InformPage = /** @class */ (function () {
    function InformPage() {
        var _this = this;
        this.view = new views.Main(this);
        this.v = new views.Open(this);
        this.values = {
            title: 'Something happened',
            message: 'Zing! Something you happened!',
            onClose: function () {
                alert('Buh Bye');
            },
            open: function () {
                document.body.appendChild(_this.v.render());
            },
            close: function () {
                _this.v.findById('open')
                    .map(function (m) { return m.close(); });
            }
        };
    }
    return InformPage;
}());
exports.InformPage = InformPage;
exports.default = new InformPage();

},{"./wml/inform":213}],213:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var inform_1 = require("../../../../../../lib/dialog/inform");
;
var lib_1 = require("../../../../../../lib");
;
var demo_1 = require("../../../widgets/demo");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.node('h1', { html: {}, wml: {} }, [
                    document.createTextNode("Inform")
                ]),
                __this.node('p', { html: {}, wml: {} }, [
                    __this.node('button', { html: { 'onclick': __context.values.open }, wml: {} }, [
                        document.createTextNode("Open")
                    ])
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;
;
var Open = /** @class */ (function () {
    function Open(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(inform_1.Inform, { html: {}, wml: { 'id': "open" }, ww: { 'title': __context.values.title, 'onClose': __context.values.onClose } }, [
                lib_1.text(__context.values.message)
            ]);
        };
    }
    Open.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Open.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Open.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Open.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Open.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Open.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Open.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Open;
}());
exports.Open = Open;

},{"../../../../../../lib":101,"../../../../../../lib/dialog/inform":95,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],214:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/modal");
var ModalPage = /** @class */ (function () {
    function ModalPage() {
        var _this = this;
        this.view = new views.Main(this);
        this.v = new views.Open(this);
        this.values = {
            open: function () {
                document.body.appendChild(_this.v.render());
            },
            close: function () {
                _this.v.findById('open')
                    .map(function (m) { return m.close(); });
            }
        };
    }
    return ModalPage;
}());
exports.ModalPage = ModalPage;
exports.default = new ModalPage();

},{"./wml/modal":215}],215:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var modal_1 = require("../../../../../../lib/dialog/modal");
;
var demo_1 = require("../../../widgets/demo");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.node('h1', { html: {}, wml: {} }, [
                    document.createTextNode("Modals")
                ]),
                __this.node('p', { html: {}, wml: {} }, [
                    __this.node('button', { html: { 'onclick': __context.values.open }, wml: {} }, [
                        document.createTextNode("Open")
                    ])
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;
;
var Open = /** @class */ (function () {
    function Open(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(modal_1.Modal, { html: {}, wml: { 'id': "open" } }, [
                __this.widget(modal_1.ModalHeader, { html: {}, wml: {} }, [
                    document.createTextNode("Open")
                ]),
                __this.widget(modal_1.ModalBody, { html: {}, wml: {} }, [
                    __this.node('p', { html: {}, wml: {} }, [
                        document.createTextNode("Click this "),
                        __this.node('button', { html: { 'onclick': __context.values.close }, wml: {} }, [
                            document.createTextNode("button")
                        ]),
                        document.createTextNode(" to close.")
                    ])
                ]),
                __this.widget(modal_1.ModalFooter, { html: {}, wml: {} }, [
                    __this.node('button', { html: { 'onclick': __context.values.close }, wml: {} }, [
                        document.createTextNode("cancel")
                    ])
                ])
            ]);
        };
    }
    Open.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Open.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Open.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Open.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Open.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Open.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Open.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Open;
}());
exports.Open = Open;

},{"../../../../../../lib/dialog/modal":97,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],216:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/prompt");
var PromptPage = /** @class */ (function () {
    function PromptPage() {
        var _this = this;
        this.view = new views.Main(this);
        this.v = new views.Open(this);
        this.values = {
            value: 'Click the button bellow to change this text.',
            title: 'Change the text',
            onChange: function (e) { return _this.values.value = e.value; },
            onSave: function () {
                _this.view.invalidate();
            },
            onCancel: function () {
            },
            open: function () {
                document.body.appendChild(_this.v.render());
            },
            close: function () {
                _this.v.findById('open')
                    .map(function (m) { return m.close(); });
            }
        };
    }
    return PromptPage;
}());
exports.PromptPage = PromptPage;
exports.default = new PromptPage();

},{"./wml/prompt":217}],217:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var text_field_1 = require("../../../../../../lib/control/text-field");
;
var prompt_1 = require("../../../../../../lib/dialog/prompt");
;
var lib_1 = require("../../../../../../lib");
;
var demo_1 = require("../../../widgets/demo");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.node('h1', { html: {}, wml: {} }, [
                    document.createTextNode("Prompt")
                ]),
                __this.node('p', { html: {}, wml: {} }, [
                    lib_1.text(__context.values.value)
                ]),
                __this.node('p', { html: {}, wml: {} }, [
                    __this.node('button', { html: { 'onclick': __context.values.open }, wml: {} }, [
                        document.createTextNode("Open")
                    ])
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;
;
var Open = /** @class */ (function () {
    function Open(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(prompt_1.Prompt, { html: {}, wml: { 'id': "open" }, ww: { 'title': __context.values.title, 'onSave': __context.values.onSave, 'onCancel': __context.values.onCancel } }, [
                __this.widget(text_field_1.TextField, { html: {}, wml: {}, ww: { 'value': __context.values.value, 'onChange': __context.values.onChange } }, [])
            ]);
        };
    }
    Open.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Open.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Open.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Open.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Open.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Open.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Open.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Open;
}());
exports.Open = Open;

},{"../../../../../../lib":101,"../../../../../../lib/control/text-field":76,"../../../../../../lib/dialog/prompt":99,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],218:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/callout");
var style_1 = require("../../../../../lib/content/style");
var CalloutPage = /** @class */ (function () {
    function CalloutPage() {
        this.view = new views.Main(this);
        this.values = {
            capitalize: function (s) { return "" + s[0].toUpperCase() + s.slice(1); },
            styles: [
                style_1.Style.Default,
                style_1.Style.Primary,
                style_1.Style.Success,
                style_1.Style.Info,
                style_1.Style.Warning,
                style_1.Style.Error
            ]
        };
    }
    return CalloutPage;
}());
exports.CalloutPage = CalloutPage;
exports.default = new CalloutPage();

},{"../../../../../lib/content/style":19,"./wml/callout":219}],219:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var callout_1 = require("../../../../../../lib/layout/callout");
;
var demo_1 = require("../../../widgets/demo");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('h1', { html: {}, wml: {} }, [
                        document.createTextNode("Callout")
                    ]),
                    __this.node('p', { html: {}, wml: {} }, __spreadArrays([
                        __this.node('h2', { html: {}, wml: {} }, [
                            document.createTextNode("Styles")
                        ])
                    ], __forIn(__context.values.styles, function (v, _$$i, _$$all) {
                        return ([
                            __this.widget(callout_1.Callout, { html: {}, wml: {}, ww: { 'style': v } }, [
                                document.createTextNode("\n\n            This is a callout with style on display.\n\n          ")
                            ])
                        ]);
                    }, function () { return ([]); })))
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/layout/callout":104,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],220:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var description_list_1 = require("./wml/description-list");
var DescriptionListPage = /** @class */ (function () {
    function DescriptionListPage() {
        this.view = new description_list_1.Main(this);
    }
    return DescriptionListPage;
}());
exports.DescriptionListPage = DescriptionListPage;
exports.default = new DescriptionListPage();

},{"./wml/description-list":221}],221:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var demo_1 = require("../../../widgets/demo");
;
var description_list_1 = require("../../../../../../lib/layout/description-list");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.widget(description_list_1.DescriptionList, { html: {}, wml: {} }, [
                        __this.widget(description_list_1.Title, { html: {}, wml: {} }, [
                            document.createTextNode("Phone")
                        ]),
                        __this.widget(description_list_1.Data, { html: {}, wml: {} }, [
                            document.createTextNode("6385532")
                        ]),
                        __this.widget(description_list_1.Title, { html: {}, wml: {} }, [
                            document.createTextNode("Email")
                        ]),
                        __this.widget(description_list_1.Data, { html: {}, wml: {} }, [
                            document.createTextNode("hel@lo.com")
                        ]),
                        __this.widget(description_list_1.Title, { html: {}, wml: {} }, [
                            document.createTextNode("Website")
                        ]),
                        __this.widget(description_list_1.Data, { html: {}, wml: {} }, [
                            document.createTextNode("example.com")
                        ])
                    ])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.widget(description_list_1.DescriptionList, { html: {}, wml: {}, ww: { 'horizontal': true } }, [
                        __this.widget(description_list_1.Title, { html: {}, wml: {} }, [
                            document.createTextNode("Phone")
                        ]),
                        __this.widget(description_list_1.Data, { html: {}, wml: {} }, [
                            document.createTextNode("6385532")
                        ]),
                        __this.widget(description_list_1.Title, { html: {}, wml: {} }, [
                            document.createTextNode("Email")
                        ]),
                        __this.widget(description_list_1.Data, { html: {}, wml: {} }, [
                            document.createTextNode("hel@lo.com")
                        ]),
                        __this.widget(description_list_1.Title, { html: {}, wml: {} }, [
                            document.createTextNode("Website")
                        ]),
                        __this.widget(description_list_1.Data, { html: {}, wml: {} }, [
                            document.createTextNode("example.com")
                        ])
                    ])
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/layout/description-list":106,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],222:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/grid");
var GridLayoutPage = /** @class */ (function () {
    function GridLayoutPage() {
        this.view = new views.Main(this);
        this.values = {
            root: {
                className: 'grid-layout-example'
            }
        };
    }
    return GridLayoutPage;
}());
exports.GridLayoutPage = GridLayoutPage;
exports.default = new GridLayoutPage();

},{"./wml/grid":223}],223:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var grid_1 = require("../../../../../../lib/layout/grid");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(grid_1.GridLayout, { html: {}, wml: {}, ww: { 'className': __context.values.root.className } }, [
                __this.widget(grid_1.Row, { html: {}, wml: {} }, [
                    __this.widget(grid_1.Column, { html: {}, wml: {}, ww: { 'span': 1 } }, [
                        document.createTextNode("Span 1")
                    ]),
                    __this.widget(grid_1.Column, { html: {}, wml: {}, ww: { 'span': 1 } }, [
                        document.createTextNode("Span 1")
                    ]),
                    __this.widget(grid_1.Column, { html: {}, wml: {}, ww: { 'span': 1 } }, [
                        document.createTextNode("Span 1")
                    ]),
                    __this.widget(grid_1.Column, { html: {}, wml: {}, ww: { 'span': 1 } }, [
                        document.createTextNode("Span 1")
                    ]),
                    __this.widget(grid_1.Column, { html: {}, wml: {}, ww: { 'span': 1 } }, [
                        document.createTextNode("Span 1")
                    ]),
                    __this.widget(grid_1.Column, { html: {}, wml: {}, ww: { 'span': 1 } }, [
                        document.createTextNode("Span 1")
                    ]),
                    __this.widget(grid_1.Column, { html: {}, wml: {}, ww: { 'span': 1 } }, [
                        document.createTextNode("Span 1")
                    ]),
                    __this.widget(grid_1.Column, { html: {}, wml: {}, ww: { 'span': 1 } }, [
                        document.createTextNode("Span 1")
                    ]),
                    __this.widget(grid_1.Column, { html: {}, wml: {}, ww: { 'span': 1 } }, [
                        document.createTextNode("Span 1")
                    ]),
                    __this.widget(grid_1.Column, { html: {}, wml: {}, ww: { 'span': 1 } }, [
                        document.createTextNode("Span 1")
                    ]),
                    __this.widget(grid_1.Column, { html: {}, wml: {}, ww: { 'span': 1 } }, [
                        document.createTextNode("Span 1")
                    ]),
                    __this.widget(grid_1.Column, { html: {}, wml: {}, ww: { 'span': 1 } }, [
                        document.createTextNode("Span 1")
                    ])
                ]),
                __this.widget(grid_1.Row, { html: {}, wml: {} }, [
                    __this.widget(grid_1.Column, { html: {}, wml: {}, ww: { 'span': 8 } }, [
                        document.createTextNode("Span 8")
                    ]),
                    __this.widget(grid_1.Column, { html: {}, wml: {}, ww: { 'span': 4 } }, [
                        document.createTextNode("Span 4")
                    ])
                ]),
                __this.widget(grid_1.Row, { html: {}, wml: {} }, [
                    __this.widget(grid_1.Column, { html: {}, wml: {}, ww: { 'span': 4 } }, [
                        document.createTextNode("Span 4")
                    ]),
                    __this.widget(grid_1.Column, { html: {}, wml: {}, ww: { 'span': 4 } }, [
                        document.createTextNode("Span 4")
                    ]),
                    __this.widget(grid_1.Column, { html: {}, wml: {}, ww: { 'span': 4 } }, [
                        document.createTextNode("Span 4")
                    ])
                ]),
                __this.widget(grid_1.Row, { html: {}, wml: {} }, [
                    __this.widget(grid_1.Column, { html: {}, wml: {}, ww: { 'span': 6 } }, [
                        document.createTextNode("Span 6")
                    ]),
                    __this.widget(grid_1.Column, { html: {}, wml: {}, ww: { 'span': 6 } }, [
                        document.createTextNode("Span 6")
                    ])
                ]),
                __this.widget(grid_1.Row, { html: {}, wml: {} }, [
                    __this.widget(grid_1.Column, { html: {}, wml: {}, ww: { 'span': 6 } }, [
                        document.createTextNode("Span 6")
                    ]),
                    __this.widget(grid_1.Column, { html: {}, wml: {}, ww: { 'span': 6 } }, [
                        document.createTextNode("Span 6")
                    ]),
                    __this.widget(grid_1.Column, { html: {}, wml: {}, ww: { 'span': 6 } }, [
                        document.createTextNode("Span 6")
                    ]),
                    __this.widget(grid_1.Column, { html: {}, wml: {}, ww: { 'span': 6 } }, [
                        document.createTextNode("Span 6")
                    ])
                ]),
                __this.widget(grid_1.Row, { html: {}, wml: {} }, [
                    __this.widget(grid_1.Column, { html: {}, wml: {}, ww: { 'span': 12 } }, [
                        document.createTextNode("Span 12")
                    ])
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/layout/grid":110,"@quenk/noni/lib/data/maybe":141}],224:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/horizontal");
var HorizontalLayoutPage = /** @class */ (function () {
    function HorizontalLayoutPage() {
        this.view = new views.Main(this);
    }
    return HorizontalLayoutPage;
}());
exports.HorizontalLayoutPage = HorizontalLayoutPage;
exports.default = new HorizontalLayoutPage();

},{"./wml/horizontal":225}],225:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var demo_1 = require("../../../widgets/demo");
;
var horizontal_1 = require("../../../../../../lib/layout/horizontal");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.widget(horizontal_1.HorizontalLayout, { html: {}, wml: {} }, [
                        __this.node('textarea', { html: {}, wml: {} }, [
                            document.createTextNode("Area 1")
                        ]),
                        __this.node('textarea', { html: {}, wml: {} }, [
                            document.createTextNode("Area 2")
                        ]),
                        __this.node('textarea', { html: {}, wml: {} }, [
                            document.createTextNode("Area 3")
                        ])
                    ])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.widget(horizontal_1.HorizontalLayout, { html: {}, wml: {}, ww: { 'orientation': horizontal_1.HorizontalLayoutOrientation.Left } }, [
                        document.createTextNode("\n      This is oriented to the left.\n    ")
                    ])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.widget(horizontal_1.HorizontalLayout, { html: {}, wml: {}, ww: { 'orientation': horizontal_1.HorizontalLayoutOrientation.Right } }, [
                        document.createTextNode("\n      This is oriented to the right.\n    ")
                    ])
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/layout/horizontal":112,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],226:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var list_1 = require("./wml/list");
var ListLayoutPage = /** @class */ (function () {
    function ListLayoutPage() {
        var _this = this;
        this.view = new list_1.Main(this);
        this.items = {
            'This is the first item.': false,
            'This is the second item.': true,
            'This is the third item.': false
        };
        this.click = function (key) {
            return _this
                .view
                .findById(key)
                .map(function (l) { return l.toggleActive(); })
                .orJust(function () { return alert("Cannot find element by id \"" + key + "\"!"); });
        };
    }
    return ListLayoutPage;
}());
exports.ListLayoutPage = ListLayoutPage;
exports.default = new ListLayoutPage();

},{"./wml/list":227}],227:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var demo_1 = require("../../../widgets/demo");
;
var list_1 = require("../../../../../../lib/layout/list");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.widget(list_1.ListLayout, { html: {}, wml: {} }, __spreadArrays(__forOf(__context.items, function (yes, key, _$$all) {
                    return ([
                        __this.widget(list_1.ListLayoutItem, { html: {}, wml: { 'id': key }, ww: { 'name': key, 'active': yes, 'onClick': __context.click } }, [
                            __this.node('p', { html: {}, wml: {} }, [
                                document.createTextNode(key)
                            ])
                        ])
                    ]);
                }, function () { return ([]); })))
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/layout/list":115,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],228:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/meter");
var MeterPage = /** @class */ (function () {
    function MeterPage() {
        var _this = this;
        this.view = new views.Main(this);
        this.values = {
            message: 'This is an alert',
            bars: [
                { value: 10, color: 'red' },
                { value: 50, color: 'green' },
                { value: 40, color: 'blue' }
            ],
            inc: function () {
                var m = _this.view.findById('single');
                if (m.isJust())
                    m.get().increase(10);
            },
            dec: function () {
                var m = _this.view.findById('single');
                if (m.isJust())
                    m.get().decrease(10);
            }
        };
    }
    return MeterPage;
}());
exports.MeterPage = MeterPage;
exports.default = new MeterPage();

},{"./wml/meter":229}],229:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var meter_1 = require("../../../../../../lib/layout/meter");
;
var demo_1 = require("../../../widgets/demo");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.node('h1', { html: {}, wml: {} }, [
                    document.createTextNode("Meter")
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('h2', { html: {}, wml: {} }, [
                        document.createTextNode("Single")
                    ]),
                    __this.node('p', { html: {}, wml: {} }, [
                        __this.node('button', { html: { 'onclick': __context.values.dec }, wml: {} }, [
                            document.createTextNode("-")
                        ]),
                        __this.node('button', { html: { 'onclick': __context.values.inc }, wml: {} }, [
                            document.createTextNode("+")
                        ])
                    ]),
                    __this.widget(meter_1.Meter, { html: {}, wml: {} }, [
                        __this.widget(meter_1.MeterBar, { html: {}, wml: { 'id': "single" }, ww: { 'value': 75, 'color': "yellow" } }, [])
                    ])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('p', { html: {}, wml: {} }, [
                        __this.node('h2', { html: {}, wml: {} }, [
                            document.createTextNode("Combined")
                        ]),
                        __this.widget(meter_1.Meter, { html: {}, wml: {} }, __spreadArrays(__forIn(__context.values.bars, function (v, _$$i, _$$all) {
                            return ([
                                __this.widget(meter_1.MeterBar, { html: {}, wml: {}, ww: { 'value': v.value, 'color': v.color } }, [])
                            ]);
                        }, function () { return ([]); })))
                    ])
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/layout/meter":119,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],230:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var panel_1 = require("./wml/panel");
var PanelPage = /** @class */ (function () {
    function PanelPage() {
        this.view = new panel_1.Main(this);
    }
    return PanelPage;
}());
exports.PanelPage = PanelPage;
exports.default = new PanelPage();

},{"./wml/panel":231}],231:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var grid_1 = require("../../../../../../lib/layout/grid");
;
var panel_1 = require("../../../../../../lib/layout/panel");
;
var style_1 = require("../../../../../../lib/content/style");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(grid_1.GridLayout, { html: {}, wml: {} }, __spreadArrays(__forIn(style_1.styles, function (style, _$$i, _$$all) {
                return ([
                    __this.widget(grid_1.Row, { html: {}, wml: {} }, [
                        __this.widget(grid_1.Column, { html: {}, wml: {}, ww: { 'span': 4 } }, [
                            __this.widget(panel_1.Panel, { html: {}, wml: {}, ww: { 'style': style } }, [
                                __this.widget(panel_1.PanelBody, { html: {}, wml: {} }, [
                                    document.createTextNode("\n            PanelBody only.\n          ")
                                ])
                            ])
                        ]),
                        __this.widget(grid_1.Column, { html: {}, wml: {}, ww: { 'span': 4 } }, [
                            __this.widget(panel_1.Panel, { html: {}, wml: {}, ww: { 'style': style } }, [
                                __this.widget(panel_1.PanelHeader, { html: {}, wml: {} }, [
                                    document.createTextNode("\n            With PanelHeader\n          ")
                                ]),
                                __this.widget(panel_1.PanelBody, { html: {}, wml: {} }, [
                                    document.createTextNode("\n            Lorem impsum dilium net set.\n          ")
                                ])
                            ])
                        ]),
                        __this.widget(grid_1.Column, { html: {}, wml: {}, ww: { 'span': 4 } }, [
                            __this.widget(panel_1.Panel, { html: {}, wml: {}, ww: { 'style': style } }, [
                                __this.widget(panel_1.PanelHeader, { html: {}, wml: {} }, [
                                    document.createTextNode("With PanelFooter")
                                ]),
                                __this.widget(panel_1.PanelBody, { html: {}, wml: {} }, [
                                    document.createTextNode("Lorem impsum dilium net set.")
                                ]),
                                __this.widget(panel_1.PanelFooter, { html: {}, wml: {} }, [
                                    document.createTextNode("Meh foot.")
                                ])
                            ])
                        ])
                    ])
                ]);
            }, function () { return ([]); })));
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/content/style":19,"../../../../../../lib/layout/grid":110,"../../../../../../lib/layout/panel":121,"@quenk/noni/lib/data/maybe":141}],232:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/tab");
var TabLayoutPage = /** @class */ (function () {
    function TabLayoutPage() {
        this.view = new views.Main(this);
        this.tabs = {
            first: {
                text: 'First',
                contentFun: views.firstTab
            },
            second: {
                text: 'Second',
                contentFun: views.secondTab
            },
            third: {
                text: 'Third',
                contentFun: views.thirdTab
            }
        };
    }
    return TabLayoutPage;
}());
exports.TabLayoutPage = TabLayoutPage;
exports.default = new TabLayoutPage();

},{"./wml/tab":233}],233:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var demo_1 = require("../../../widgets/demo");
;
var tab_1 = require("../../../../../../lib/layout/tab");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
exports.firstTab = function (_) { return function (__this) {
    return [
        __this.node('p', { html: {}, wml: {} }, [
            document.createTextNode("Click a tab to change content.")
        ])
    ];
}; };
;
exports.secondTab = function (_) { return function (__this) {
    return [
        __this.node('p', { html: {}, wml: {} }, [
            document.createTextNode("Second tab.")
        ])
    ];
}; };
;
exports.thirdTab = function (_) { return function (__this) {
    return [
        __this.node('p', { html: {}, wml: {} }, [
            document.createTextNode("Third tab.")
        ])
    ];
}; };
;
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.widget(tab_1.TabLayout, { html: {}, wml: {}, ww: { 'tabs': __context.tabs, 'active': "first" } }, [
                    __this.node('p', { html: {}, wml: {} }, [
                        document.createTextNode("Click a tab to change content.")
                    ])
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/layout/tab":123,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],234:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var table_1 = require("./wml/table");
var TableLayoutPage = /** @class */ (function () {
    function TableLayoutPage() {
        this.view = new table_1.Main(this);
    }
    return TableLayoutPage;
}());
exports.TableLayoutPage = TableLayoutPage;
exports.default = new TableLayoutPage();

},{"./wml/table":235}],235:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var demo_1 = require("../../../widgets/demo");
;
var table_1 = require("../../../../../../lib/layout/table");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
exports.content = function () { return function (__this) {
    return [
        __this.widget(table_1.TableHeader, { html: {}, wml: {} }, [
            __this.widget(table_1.TableRow, { html: {}, wml: {} }, [
                __this.widget(table_1.TableHeading, { html: {}, wml: {} }, [
                    document.createTextNode("Name")
                ]),
                __this.widget(table_1.TableHeading, { html: {}, wml: {} }, [
                    document.createTextNode("Email")
                ]),
                __this.widget(table_1.TableHeading, { html: {}, wml: {} }, [
                    document.createTextNode("Balance")
                ]),
                __this.widget(table_1.TableHeading, { html: {}, wml: {} }, [
                    document.createTextNode("Username")
                ]),
                __this.widget(table_1.TableHeading, { html: {}, wml: {} }, [
                    document.createTextNode("Status")
                ])
            ])
        ]),
        __this.widget(table_1.TableBody, { html: {}, wml: {} }, [
            __this.widget(table_1.TableRow, { html: {}, wml: {} }, [
                __this.widget(table_1.TableCell, { html: {}, wml: {} }, [
                    document.createTextNode("Length Wise")
                ]),
                __this.widget(table_1.TableCell, { html: {}, wml: {} }, [
                    document.createTextNode("lw@theemailplace.com")
                ]),
                __this.widget(table_1.TableCell, { html: {}, wml: {} }, [
                    document.createTextNode("$5000")
                ]),
                __this.widget(table_1.TableCell, { html: {}, wml: {} }, [
                    document.createTextNode("lw")
                ]),
                __this.widget(table_1.TableCell, { html: {}, wml: {} }, [
                    document.createTextNode("Active")
                ])
            ]),
            __this.widget(table_1.TableRow, { html: {}, wml: {} }, [
                __this.widget(table_1.TableCell, { html: {}, wml: {} }, [
                    document.createTextNode("First Chance")
                ]),
                __this.widget(table_1.TableCell, { html: {}, wml: {} }, [
                    document.createTextNode("fchacne@live.tt")
                ]),
                __this.widget(table_1.TableCell, { html: {}, wml: {} }, [
                    document.createTextNode("$1.00")
                ]),
                __this.widget(table_1.TableCell, { html: {}, wml: {} }, [
                    document.createTextNode("chance")
                ]),
                __this.widget(table_1.TableCell, { html: {}, wml: {} }, [
                    document.createTextNode("Inactive")
                ])
            ]),
            __this.widget(table_1.TableRow, { html: {}, wml: {} }, [
                __this.widget(table_1.TableCell, { html: {}, wml: {} }, [
                    document.createTextNode("Du Pear")
                ]),
                __this.widget(table_1.TableCell, { html: {}, wml: {} }, [
                    document.createTextNode("dupear@gmail.com")
                ]),
                __this.widget(table_1.TableCell, { html: {}, wml: {} }, [
                    document.createTextNode("$10,000.00")
                ]),
                __this.widget(table_1.TableCell, { html: {}, wml: {} }, [
                    document.createTextNode("pearboy")
                ]),
                __this.widget(table_1.TableCell, { html: {}, wml: {} }, [
                    document.createTextNode("Active")
                ])
            ]),
            __this.widget(table_1.TableRow, { html: {}, wml: {} }, [
                __this.widget(table_1.TableCell, { html: {}, wml: {}, ww: { 'rowspan': 2, 'colspan': 5 } }, [
                    document.createTextNode("This spans 2 rows 5 columns.")
                ])
            ])
        ]),
        __this.widget(table_1.TableFooter, { html: {}, wml: {} }, [
            __this.widget(table_1.TableRow, { html: {}, wml: {} }, [
                __this.widget(table_1.TableCell, { html: {}, wml: {} }, [
                    document.createTextNode("1")
                ]),
                __this.widget(table_1.TableCell, { html: {}, wml: {} }, [
                    document.createTextNode("2")
                ]),
                __this.widget(table_1.TableCell, { html: {}, wml: {} }, [
                    document.createTextNode("3")
                ]),
                __this.widget(table_1.TableCell, { html: {}, wml: {} }, [
                    document.createTextNode("4")
                ]),
                __this.widget(table_1.TableCell, { html: {}, wml: {} }, [
                    document.createTextNode("5")
                ])
            ])
        ])
    ];
}; };
;
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('h3', { html: {}, wml: {} }, [
                        document.createTextNode("Normal")
                    ]),
                    __this.widget(table_1.TableLayout, { html: {}, wml: {} }, __spreadArrays((exports.content()(__this))))
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('h3', { html: {}, wml: {} }, [
                        document.createTextNode(" Alternate")
                    ]),
                    __this.widget(table_1.TableLayout, { html: {}, wml: {}, ww: { 'alternate': true } }, __spreadArrays((exports.content()(__this))))
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('h3', { html: {}, wml: {} }, [
                        document.createTextNode("Bordered")
                    ]),
                    __this.widget(table_1.TableLayout, { html: {}, wml: {}, ww: { 'bordered': true } }, __spreadArrays((exports.content()(__this))))
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('h3', { html: {}, wml: {} }, [
                        document.createTextNode("Hoverable")
                    ]),
                    __this.widget(table_1.TableLayout, { html: {}, wml: {}, ww: { 'hoverable': true } }, __spreadArrays((exports.content()(__this))))
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('h3', { html: {}, wml: {} }, [
                        document.createTextNode("Compact")
                    ]),
                    __this.widget(table_1.TableLayout, { html: {}, wml: {}, ww: { 'compact': true } }, __spreadArrays((exports.content()(__this))))
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.widget(table_1.TableWindow, { html: {}, wml: {} }, [
                        __this.widget(table_1.TableLayout, { html: {}, wml: {} }, __spreadArrays((exports.content()(__this))))
                    ])
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/layout/table":125,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],236:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var menu_1 = require("./wml/menu");
var MenuPage = /** @class */ (function () {
    function MenuPage() {
        this.view = new menu_1.Main(this);
    }
    return MenuPage;
}());
exports.MenuPage = MenuPage;
exports.default = new MenuPage();

},{"./wml/menu":237}],237:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var demo_1 = require("../../../widgets/demo");
;
var menu_1 = require("../../../../../../lib/menu/menu");
;
var item_1 = require("../../../../../../lib/menu/item");
;
var link_1 = require("../../../../../../lib/content/link");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.widget(menu_1.Menu, { html: {}, wml: {} }, [
                    __this.widget(item_1.Item, { html: {}, wml: {} }, [
                        __this.node('h6', { html: {}, wml: {} }, [
                            document.createTextNode("Menu")
                        ])
                    ]),
                    __this.widget(item_1.Item, { html: {}, wml: {} }, [
                        __this.widget(link_1.Link, { html: {}, wml: {}, ww: { 'disabled': true, 'text': "Back" } }, [])
                    ]),
                    __this.widget(item_1.Item, { html: {}, wml: {} }, [
                        __this.widget(link_1.Link, { html: {}, wml: {}, ww: { 'disabled': true, 'text': "Refresh" } }, [])
                    ]),
                    __this.widget(item_1.Item, { html: {}, wml: {}, ww: { 'divider': true } }, []),
                    __this.widget(item_1.Item, { html: {}, wml: {} }, [
                        __this.node('a', { html: { 'href': "#/menu" }, wml: {} }, [
                            document.createTextNode("Quit")
                        ])
                    ])
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/content/link":7,"../../../../../../lib/menu/item":131,"../../../../../../lib/menu/menu":133,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],238:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var nav_1 = require("./wml/nav");
var NavPage = /** @class */ (function () {
    function NavPage() {
        this.view = new nav_1.Main(this);
    }
    return NavPage;
}());
exports.NavPage = NavPage;
exports.default = new NavPage();

},{"./wml/nav":239}],239:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var demo_1 = require("../../../widgets/demo");
;
var nav_1 = require("../../../../../../lib/menu/nav");
;
var item_1 = require("../../../../../../lib/menu/item");
;
var link_1 = require("../../../../../../lib/content/link");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('h3', { html: {}, wml: {} }, [
                        document.createTextNode("This is a horizontal nav.")
                    ]),
                    __this.widget(nav_1.Nav, { html: {}, wml: {} }, [
                        __this.widget(item_1.Item, { html: {}, wml: {} }, [
                            __this.widget(link_1.Link, { html: {}, wml: {}, ww: { 'text': "Home" } }, [])
                        ]),
                        __this.widget(item_1.Item, { html: {}, wml: {} }, [
                            __this.widget(link_1.Link, { html: {}, wml: {}, ww: { 'disabled': true, 'text': "Users" } }, [])
                        ]),
                        __this.widget(item_1.Item, { html: {}, wml: {} }, [
                            __this.widget(link_1.Link, { html: {}, wml: {}, ww: { 'text': "Logout" } }, [])
                        ])
                    ])
                ]),
                __this.widget(demo_1.Demo, { html: {}, wml: {} }, [
                    __this.node('h3', { html: {}, wml: {} }, [
                        document.createTextNode("This is a vertical nav.")
                    ]),
                    __this.widget(nav_1.Nav, { html: {}, wml: {}, ww: { 'vertical': true } }, [
                        __this.widget(item_1.Item, { html: {}, wml: {} }, [
                            __this.widget(link_1.Link, { html: {}, wml: {}, ww: { 'text': "Home" } }, [])
                        ]),
                        __this.widget(item_1.Item, { html: {}, wml: {} }, [
                            __this.widget(link_1.Link, { html: {}, wml: {}, ww: { 'disabled': true, 'text': "Users" } }, [])
                        ]),
                        __this.widget(item_1.Item, { html: {}, wml: {} }, [
                            __this.widget(link_1.Link, { html: {}, wml: {}, ww: { 'text': "Logout" } }, [])
                        ])
                    ])
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/content/link":7,"../../../../../../lib/menu/item":131,"../../../../../../lib/menu/nav":136,"../../../widgets/demo":241,"@quenk/noni/lib/data/maybe":141}],240:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pages = {
    'content_embed': require('./page/content_embed').default,
    'content_media-description': require('./page/content_media-description').default,
    'content_overlay': require('./page/content_overlay').default,
    'content_tag': require('./page/content_tag').default,
    'content_thumbnail': require('./page/content_thumbnail').default,
    'control_button': require('./page/control_button').default,
    'control_button-group': require('./page/control_button-group').default,
    'control_button-select': require('./page/control_button-select').default,
    'control_checkbox': require('./page/control_checkbox').default,
    'control_date-field': require('./page/control_date-field').default,
    'control_display-field': require('./page/control_display-field').default,
    'control_drop-down': require('./page/control_drop-down').default,
    'control_drop-list': require('./page/control_drop-list').default,
    'control_drop-list-field': require('./page/control_drop-list-field').default,
    'control_file-upload-surface': require('./page/control_file-upload-surface').default,
    'control_multi-select': require('./page/control_multi-select').default,
    'control_paginator': require('./page/control_paginator').default,
    'control_search': require('./page/control_search').default,
    'control_select': require('./page/control_select').default,
    'control_stack': require('./page/control_stack').default,
    'control_stack-select': require('./page/control_stack-select').default,
    'control_switch': require('./page/control_switch').default,
    'control_tab-bar': require('./page/control_tab-bar').default,
    'control_tag-control': require('./page/control_tag-control').default,
    'control_text-field': require('./page/control_text-field').default,
    'control_text-input': require('./page/control_text-input').default,
    'control_typeahead': require('./page/control_typeahead').default,
    'data_data-table': require('./page/data_data-table').default,
    'data_property-list': require('./page/data_property-list').default,
    'dialog_alert': require('./page/dialog_alert').default,
    'dialog_confirm': require('./page/dialog_confirm').default,
    'dialog_inform': require('./page/dialog_inform').default,
    'dialog_modal': require('./page/dialog_modal').default,
    'dialog_prompt': require('./page/dialog_prompt').default,
    'layout_callout': require('./page/layout_callout').default,
    'layout_description-list': require('./page/layout_description-list').default,
    'layout_grid': require('./page/layout_grid').default,
    'layout_horizontal': require('./page/layout_horizontal').default,
    'layout_list': require('./page/layout_list').default,
    'layout_meter': require('./page/layout_meter').default,
    'layout_panel': require('./page/layout_panel').default,
    'layout_tab': require('./page/layout_tab').default,
    'layout_table': require('./page/layout_table').default,
    'menu_menu': require('./page/menu_menu').default,
    'menu_nav': require('./page/menu_nav').default,
};

},{"./page/content_embed":149,"./page/content_media-description":151,"./page/content_overlay":153,"./page/content_tag":155,"./page/content_thumbnail":157,"./page/control_button":163,"./page/control_button-group":159,"./page/control_button-select":161,"./page/control_checkbox":165,"./page/control_date-field":167,"./page/control_display-field":169,"./page/control_drop-down":171,"./page/control_drop-list":175,"./page/control_drop-list-field":173,"./page/control_file-upload-surface":177,"./page/control_multi-select":179,"./page/control_paginator":181,"./page/control_search":183,"./page/control_select":185,"./page/control_stack":189,"./page/control_stack-select":187,"./page/control_switch":191,"./page/control_tab-bar":193,"./page/control_tag-control":195,"./page/control_text-field":197,"./page/control_text-input":199,"./page/control_typeahead":201,"./page/data_data-table":204,"./page/data_property-list":206,"./page/dialog_alert":208,"./page/dialog_confirm":210,"./page/dialog_inform":212,"./page/dialog_modal":214,"./page/dialog_prompt":216,"./page/layout_callout":218,"./page/layout_description-list":220,"./page/layout_grid":222,"./page/layout_horizontal":224,"./page/layout_list":226,"./page/layout_meter":228,"./page/layout_panel":230,"./page/layout_tab":232,"./page/layout_table":234,"./page/menu_menu":236,"./page/menu_nav":238}],241:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml = require("@quenk/wml");
var views = require("./wml/demo");
var Demo = /** @class */ (function (_super) {
    __extends(Demo, _super);
    function Demo() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            size: _this.attrs.size,
            offset: _this.attrs.offset
        };
        return _this;
    }
    return Demo;
}(wml.Component));
exports.Demo = Demo;

},{"./wml/demo":242,"@quenk/wml":145}],242:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var grid_1 = require("../../../../../../lib/layout/grid");
;
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(grid_1.GridLayout, { html: {}, wml: {} }, [
                __this.widget(grid_1.Row, { html: {}, wml: {} }, [
                    __this.widget(grid_1.Column, { html: {}, wml: {}, ww: { 'span': __context.values.size } }, __spreadArrays((__context.children)))
                ])
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../../../lib/layout/grid":110,"@quenk/noni/lib/data/maybe":141}],243:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var drawer_1 = require("../../../../lib/layout/drawer");
;
var action_bar_1 = require("../../../../lib/layout/action-bar");
;
;
var link_1 = require("../../../../lib/content/link");
;
var menu_icon_1 = require("../../../../lib/content/menu-icon");
;
var main_1 = require("../../../../lib/layout/main");
;
var navigation_1 = require("./navigation");
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Main = /** @class */ (function () {
    function Main(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(drawer_1.DrawerLayout, { html: {}, wml: { 'id': __context.values.id.layout }, ww: { 'drawerContent': [
                        (new navigation_1.Navigation(__context)).render()
                    ] } }, [
                __this.widget(action_bar_1.ActionBar, { html: {}, wml: {} }, [
                    __this.widget(link_1.Link, { html: {}, wml: {}, ww: { 'onClick': __context.toggleDrawer } }, [
                        __this.widget(menu_icon_1.MenuIcon, { html: {}, wml: {} }, [])
                    ])
                ]),
                __this.widget(main_1.MainLayout, { html: {}, wml: {} }, __spreadArrays((__context.content)))
            ]);
        };
    }
    Main.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Main.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Main.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Main.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Main.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Main.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Main.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Main;
}());
exports.Main = Main;

},{"../../../../lib/content/link":7,"../../../../lib/content/menu-icon":11,"../../../../lib/layout/action-bar":102,"../../../../lib/layout/drawer":108,"../../../../lib/layout/main":117,"./navigation":244,"@quenk/noni/lib/data/maybe":141}],244:[function(require,module,exports){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
;
var nav_1 = require("../../../../lib/menu/nav");
;
var item_1 = require("../../../../lib/menu/item");
;
var header_1 = require("../../../../lib/menu/header");
;
var link_1 = require("../../../../lib/content/link");
//@ts-ignore: 6192
var maybe_1 = require("@quenk/noni/lib/data/maybe");
//@ts-ignore:6192
var __if = function (__expr, __conseq, __alt) {
    return (__expr) ? __conseq() : __alt();
};
//@ts-ignore:6192
var __forIn = function (list, f, alt) {
    var ret = [];
    for (var i = 0; i < list.length; i++)
        ret = ret.concat(f(list[i], i, list));
    return ret.length === 0 ? alt() : ret;
};
//@ts-ignore:6192
var __forOf = function (o, f, alt) {
    var ret = [];
    for (var key in o)
        if (o.hasOwnProperty(key))
            ret = ret.concat(f((o)[key], key, o));
    return ret.length === 0 ? alt() : ret;
};
var Navigation = /** @class */ (function () {
    function Navigation(__context) {
        this.ids = {};
        this.groups = {};
        this.widgets = [];
        this.tree = document.createElement('div');
        this.template = function (__this) {
            return __this.widget(nav_1.Nav, { html: {}, wml: {}, ww: { 'vertical': true } }, __spreadArrays([
                __this.widget(item_1.Item, { html: {}, wml: {} }, [
                    __this.widget(link_1.Link, { html: {}, wml: { 'group': "links" }, ww: { 'active': (__context.page === "home"), 'name': "home", 'href': "#", 'onClick': __context.navigate, 'text': "Home" } }, [])
                ])
            ], __forOf(__context.pages, function (items, section, _$$all) {
                return ([
                    __this.widget(item_1.Item, { html: {}, wml: {} }, [
                        __this.widget(header_1.MenuHeader, { html: {}, wml: {}, ww: { 'text': section } }, []),
                        __this.widget(nav_1.Nav, { html: {}, wml: {}, ww: { 'vertical': true } }, __spreadArrays(__forOf(items, function (_, name, _$$all) {
                            return ([
                                __this.widget(item_1.Item, { html: {}, wml: {} }, [
                                    __this.widget(link_1.Link, { html: {}, wml: { 'group': "links" }, ww: { 'name': name, 'href': ("#/" + name), 'onClick': __context.navigate, 'active': (__context.page === name), 'text': name } }, [])
                                ])
                            ]);
                        }, function () { return ([]); })))
                    ])
                ]);
            }, function () { return ([]); })));
        };
    }
    Navigation.prototype.register = function (e, attrs) {
        var id = attrs.wml.id;
        var group = attrs.wml.group;
        if (id != null) {
            if (this.ids.hasOwnProperty(id))
                throw new Error("Duplicate id '" + id + "' detected!");
            this.ids[id] = e;
        }
        if (group != null) {
            this.groups[group] = this.groups[group] || [];
            this.groups[group].push(e);
        }
        return e;
    };
    Navigation.prototype.node = function (tag, attrs, children) {
        var e = document.createElement(tag);
        if (typeof attrs['html'] === 'object')
            Object.keys(attrs['html']).forEach(function (key) {
                var value = attrs['html'][key];
                if (typeof value === 'function') {
                    e[key] = value;
                }
                else if (typeof value === 'string') {
                    //prevent setting things like disabled=''
                    if (value !== '')
                        e.setAttribute(key, value);
                }
                else if (typeof value === 'boolean') {
                    e.setAttribute(key, "" + value);
                }
            });
        children.forEach(function (c) {
            switch (typeof c) {
                case 'string':
                case 'number':
                case 'boolean':
                    var tn = document.createTextNode('' + c);
                    e.appendChild(tn);
                case 'object':
                    e.appendChild(c);
                    break;
                default:
                    throw new TypeError("Can not adopt child " + c + " of type " + typeof c);
            }
        });
        this.register(e, attrs);
        return e;
    };
    Navigation.prototype.widget = function (C, attrs, children) {
        var w = new C(attrs, children);
        this.register(w, attrs);
        this.widgets.push(w);
        return w.render();
    };
    Navigation.prototype.findById = function (id) {
        return maybe_1.fromNullable(this.ids[id]);
    };
    Navigation.prototype.findByGroup = function (name) {
        return maybe_1.fromArray(this.groups.hasOwnProperty(name) ?
            this.groups[name] :
            []);
    };
    Navigation.prototype.invalidate = function () {
        var tree = this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): ' + 'Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new Error('Cannot invalidate a view  that has not been rendered!');
        parent.replaceChild(this.render(), tree);
    };
    Navigation.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ?
            this.ids['root'] :
            this.tree;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return Navigation;
}());
exports.Navigation = Navigation;

},{"../../../../lib/content/link":7,"../../../../lib/menu/header":129,"../../../../lib/menu/item":131,"../../../../lib/menu/nav":136,"@quenk/noni/lib/data/maybe":141}]},{},[147])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsaWIvY29udGVudC9jYXJldC9pbmRleC5qcyIsImxpYi9jb250ZW50L2NhcmV0L3dtbC9jYXJldC5qcyIsImxpYi9jb250ZW50L2Nsb3NlL2luZGV4LmpzIiwibGliL2NvbnRlbnQvY2xvc2Uvd21sL2Nsb3NlLmpzIiwibGliL2NvbnRlbnQvZW1iZWQvaW5kZXguanMiLCJsaWIvY29udGVudC9lbWJlZC93bWwvZW1iZWQuanMiLCJsaWIvY29udGVudC9saW5rL2luZGV4LmpzIiwibGliL2NvbnRlbnQvbGluay93bWwvbGluay5qcyIsImxpYi9jb250ZW50L21lZGlhLWRlc2NyaXB0aW9uL2luZGV4LmpzIiwibGliL2NvbnRlbnQvbWVkaWEtZGVzY3JpcHRpb24vd21sL21lZGlhLWRlc2NyaXB0aW9uLmpzIiwibGliL2NvbnRlbnQvbWVudS1pY29uL2luZGV4LmpzIiwibGliL2NvbnRlbnQvbWVudS1pY29uL3dtbC9tZW51LWljb24uanMiLCJsaWIvY29udGVudC9vcmllbnRhdGlvbi5qcyIsImxpYi9jb250ZW50L292ZXJsYXkvaW5kZXguanMiLCJsaWIvY29udGVudC9vdmVybGF5L3dtbC9vdmVybGF5LmpzIiwibGliL2NvbnRlbnQvc2l6ZS5qcyIsImxpYi9jb250ZW50L3N0YXRlL2FjdGl2ZS5qcyIsImxpYi9jb250ZW50L3N0YXRlL2hpZGRlbi5qcyIsImxpYi9jb250ZW50L3N0eWxlL2luZGV4LmpzIiwibGliL2NvbnRlbnQvdGFnL2luZGV4LmpzIiwibGliL2NvbnRlbnQvdGFnL3dtbC90YWcuanMiLCJsaWIvY29udGVudC90aHVtYm5haWwvaW5kZXguanMiLCJsaWIvY29udGVudC90aHVtYm5haWwvd21sL3RodW1ibmFpbC5qcyIsImxpYi9jb250cm9sL2J1dHRvbi1ncm91cC9pbmRleC5qcyIsImxpYi9jb250cm9sL2J1dHRvbi1ncm91cC93bWwvYnV0dG9uLWdyb3VwLmpzIiwibGliL2NvbnRyb2wvYnV0dG9uLXNlbGVjdC9pbmRleC5qcyIsImxpYi9jb250cm9sL2J1dHRvbi1zZWxlY3Qvd21sL2J1dHRvbi1zZWxlY3QuanMiLCJsaWIvY29udHJvbC9idXR0b24vaW5kZXguanMiLCJsaWIvY29udHJvbC9idXR0b24vd21sL2J1dHRvbi5qcyIsImxpYi9jb250cm9sL2NoZWNrYm94L2luZGV4LmpzIiwibGliL2NvbnRyb2wvY2hlY2tib3gvd21sL2NoZWNrYm94LmpzIiwibGliL2NvbnRyb2wvY2xvc2UtYnV0dG9uL2luZGV4LmpzIiwibGliL2NvbnRyb2wvY2xvc2UtYnV0dG9uL3dtbC9jbG9zZS1idXR0b24uanMiLCJsaWIvY29udHJvbC9kYXRlLWZpZWxkL2luZGV4LmpzIiwibGliL2NvbnRyb2wvZGF0ZS1maWVsZC93bWwvZGF0ZS1maWVsZC5qcyIsImxpYi9jb250cm9sL2Rpc3BsYXktZmllbGQvaW5kZXguanMiLCJsaWIvY29udHJvbC9kaXNwbGF5LWZpZWxkL3dtbC9kaXNwbGF5LWZpZWxkLmpzIiwibGliL2NvbnRyb2wvZHJvcC1kb3duL2luZGV4LmpzIiwibGliL2NvbnRyb2wvZHJvcC1kb3duL3dtbC9kcm9wLWRvd24uanMiLCJsaWIvY29udHJvbC9kcm9wLWxpc3QtZmllbGQvaW5kZXguanMiLCJsaWIvY29udHJvbC9kcm9wLWxpc3QtZmllbGQvd21sL2Ryb3AtbGlzdC1maWVsZC5qcyIsImxpYi9jb250cm9sL2Ryb3AtbGlzdC9pbmRleC5qcyIsImxpYi9jb250cm9sL2Ryb3AtbGlzdC93bWwvZHJvcC1saXN0LmpzIiwibGliL2NvbnRyb2wvZmVlZGJhY2suanMiLCJsaWIvY29udHJvbC9maWxlLWlucHV0L2luZGV4LmpzIiwibGliL2NvbnRyb2wvZmlsZS1pbnB1dC93bWwvZmlsZS1pbnB1dC5qcyIsImxpYi9jb250cm9sL2ZpbGUtdXBsb2FkLXN1cmZhY2UvaW5kZXguanMiLCJsaWIvY29udHJvbC9maWxlLXVwbG9hZC1zdXJmYWNlL3dtbC9maWxlLXVwbG9hZC1zdXJmYWNlLmpzIiwibGliL2NvbnRyb2wvZm9jdXMuanMiLCJsaWIvY29udHJvbC9mb3JtLmpzIiwibGliL2NvbnRyb2wvaGVscC9pbmRleC5qcyIsImxpYi9jb250cm9sL2hlbHAvd21sL2hlbHAuanMiLCJsaWIvY29udHJvbC9pbmRleC5qcyIsImxpYi9jb250cm9sL2xhYmVsL2luZGV4LmpzIiwibGliL2NvbnRyb2wvbGFiZWwvd21sL2xhYmVsLmpzIiwibGliL2NvbnRyb2wvbXVsdGktc2VsZWN0L2luZGV4LmpzIiwibGliL2NvbnRyb2wvbXVsdGktc2VsZWN0L3dtbC9tdWx0aS1zZWxlY3QuanMiLCJsaWIvY29udHJvbC9wYWdpbmF0b3IvaW5kZXguanMiLCJsaWIvY29udHJvbC9wYWdpbmF0b3Ivd21sL3BhZ2luYXRvci5qcyIsImxpYi9jb250cm9sL3Jlc3VsdHMtbWVudS9pbmRleC5qcyIsImxpYi9jb250cm9sL3Jlc3VsdHMtbWVudS93bWwvcmVzdWx0cy1tZW51LmpzIiwibGliL2NvbnRyb2wvc2VhcmNoL2luZGV4LmpzIiwibGliL2NvbnRyb2wvc2VhcmNoL3dtbC9zZWFyY2guanMiLCJsaWIvY29udHJvbC9zZWxlY3QvaW5kZXguanMiLCJsaWIvY29udHJvbC9zZWxlY3Qvd21sL3NlbGVjdC5qcyIsImxpYi9jb250cm9sL3N0YWNrLXNlbGVjdC9pbmRleC5qcyIsImxpYi9jb250cm9sL3N0YWNrLXNlbGVjdC93bWwvc3RhY2stc2VsZWN0LmpzIiwibGliL2NvbnRyb2wvc3RhY2svaW5kZXguanMiLCJsaWIvY29udHJvbC9zdGFjay93bWwvc3RhY2suanMiLCJsaWIvY29udHJvbC9zd2l0Y2gvaW5kZXguanMiLCJsaWIvY29udHJvbC9zd2l0Y2gvd21sL3N3aXRjaC5qcyIsImxpYi9jb250cm9sL3RhYi1iYXIvaW5kZXguanMiLCJsaWIvY29udHJvbC90YWItYmFyL3dtbC90YWItYmFyLmpzIiwibGliL2NvbnRyb2wvdGFnL2luZGV4LmpzIiwibGliL2NvbnRyb2wvdGFnL3dtbC90YWcuanMiLCJsaWIvY29udHJvbC90ZXh0LWZpZWxkL2luZGV4LmpzIiwibGliL2NvbnRyb2wvdGV4dC1maWVsZC93bWwvdGV4dC1maWVsZC5qcyIsImxpYi9jb250cm9sL3RleHQtaW5wdXQvaW5kZXguanMiLCJsaWIvY29udHJvbC90ZXh0LWlucHV0L3dtbC90ZXh0LWlucHV0LmpzIiwibGliL2NvbnRyb2wvdG9vbGJhci9pbmRleC5qcyIsImxpYi9jb250cm9sL3Rvb2xiYXIvd21sL3Rvb2xiYXIuanMiLCJsaWIvY29udHJvbC90eXBlYWhlYWQvaW5kZXguanMiLCJsaWIvY29udHJvbC90eXBlYWhlYWQvd21sL3R5cGVhaGVhZC5qcyIsImxpYi9kYXRhL3Byb3BlcnR5LWxpc3QvaW5kZXguanMiLCJsaWIvZGF0YS9wcm9wZXJ0eS1saXN0L3dtbC9wcm9wZXJ0eS1saXN0LmpzIiwibGliL2RhdGEvdGFibGUvY29sdW1uL3NvcnQuanMiLCJsaWIvZGF0YS90YWJsZS9ldmVudC5qcyIsImxpYi9kYXRhL3RhYmxlL2luZGV4LmpzIiwibGliL2RhdGEvdGFibGUvcmFuZ2UuanMiLCJsaWIvZGF0YS90YWJsZS93bWwvdGFibGUuanMiLCJsaWIvZGlhbG9nL2FsZXJ0L2luZGV4LmpzIiwibGliL2RpYWxvZy9hbGVydC93bWwvYWxlcnQuanMiLCJsaWIvZGlhbG9nL2NvbmZpcm0vaW5kZXguanMiLCJsaWIvZGlhbG9nL2NvbmZpcm0vd21sL2NvbmZpcm0uanMiLCJsaWIvZGlhbG9nL2luZm9ybS9pbmRleC5qcyIsImxpYi9kaWFsb2cvaW5mb3JtL3dtbC9pbmZvcm0uanMiLCJsaWIvZGlhbG9nL21vZGFsL2luZGV4LmpzIiwibGliL2RpYWxvZy9tb2RhbC93bWwvbW9kYWwuanMiLCJsaWIvZGlhbG9nL3Byb21wdC9pbmRleC5qcyIsImxpYi9kaWFsb2cvcHJvbXB0L3dtbC9wcm9tcHQuanMiLCJsaWIvaW5kZXguanMiLCJsaWIvbGF5b3V0L2FjdGlvbi1iYXIvaW5kZXguanMiLCJsaWIvbGF5b3V0L2FjdGlvbi1iYXIvd21sL2FjdGlvbi1iYXIuanMiLCJsaWIvbGF5b3V0L2NhbGxvdXQvaW5kZXguanMiLCJsaWIvbGF5b3V0L2NhbGxvdXQvd21sL2NhbGxvdXQuanMiLCJsaWIvbGF5b3V0L2Rlc2NyaXB0aW9uLWxpc3QvaW5kZXguanMiLCJsaWIvbGF5b3V0L2Rlc2NyaXB0aW9uLWxpc3Qvd21sL2Rlc2NyaXB0aW9uLWxpc3QuanMiLCJsaWIvbGF5b3V0L2RyYXdlci9pbmRleC5qcyIsImxpYi9sYXlvdXQvZHJhd2VyL3dtbC9kcmF3ZXIuanMiLCJsaWIvbGF5b3V0L2dyaWQvaW5kZXguanMiLCJsaWIvbGF5b3V0L2dyaWQvd21sL2dyaWQuanMiLCJsaWIvbGF5b3V0L2hvcml6b250YWwvaW5kZXguanMiLCJsaWIvbGF5b3V0L2hvcml6b250YWwvd21sL2hvcml6b250YWwuanMiLCJsaWIvbGF5b3V0L2luZGV4LmpzIiwibGliL2xheW91dC9saXN0L2luZGV4LmpzIiwibGliL2xheW91dC9saXN0L3dtbC9saXN0LmpzIiwibGliL2xheW91dC9tYWluL2luZGV4LmpzIiwibGliL2xheW91dC9tYWluL3dtbC9tYWluLmpzIiwibGliL2xheW91dC9tZXRlci9pbmRleC5qcyIsImxpYi9sYXlvdXQvbWV0ZXIvd21sL21ldGVyLmpzIiwibGliL2xheW91dC9wYW5lbC9pbmRleC5qcyIsImxpYi9sYXlvdXQvcGFuZWwvd21sL3BhbmVsLmpzIiwibGliL2xheW91dC90YWIvaW5kZXguanMiLCJsaWIvbGF5b3V0L3RhYi93bWwvdGFiLmpzIiwibGliL2xheW91dC90YWJsZS9pbmRleC5qcyIsImxpYi9sYXlvdXQvdGFibGUvd21sL3RhYmxlLmpzIiwibGliL21lbnUvZHJhd2VyL2luZGV4LmpzIiwibGliL21lbnUvZHJhd2VyL3dtbC9kcmF3ZXIuanMiLCJsaWIvbWVudS9oZWFkZXIvaW5kZXguanMiLCJsaWIvbWVudS9oZWFkZXIvd21sL2hlYWRlci5qcyIsImxpYi9tZW51L2l0ZW0vaW5kZXguanMiLCJsaWIvbWVudS9pdGVtL3dtbC9pdGVtLmpzIiwibGliL21lbnUvbWVudS9pbmRleC5qcyIsImxpYi9tZW51L21lbnUvd21sL2hlYWRlci5qcyIsImxpYi9tZW51L21lbnUvd21sL21lbnUuanMiLCJsaWIvbWVudS9uYXYvaW5kZXguanMiLCJsaWIvbWVudS9uYXYvd21sL25hdi5qcyIsImxpYi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL0BxdWVuay9ub25pL2xpYi9kYXRhL2FycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BxdWVuay9ub25pL2xpYi9kYXRhL2FycmF5L3NvcnQuanMiLCJub2RlX21vZHVsZXMvQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmUuanMiLCJub2RlX21vZHVsZXMvQHF1ZW5rL25vbmkvbGliL2RhdGEvcmVjb3JkL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BxdWVuay9ub25pL2xpYi9kYXRhL3JlY29yZC9wYXRoLmpzIiwibm9kZV9tb2R1bGVzL0BxdWVuay9ub25pL2xpYi9tYXRoLmpzIiwibm9kZV9tb2R1bGVzL0BxdWVuay93bWwvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vbWVudC9tb21lbnQuanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9hcHAuanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9maXh0dXJlcy9kYXRhL3Jlc3VsdHMuanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRlbnRfZW1iZWQvaW5kZXguanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRlbnRfZW1iZWQvd21sL2VtYmVkLmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9jb250ZW50X21lZGlhLWRlc2NyaXB0aW9uL2luZGV4LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9jb250ZW50X21lZGlhLWRlc2NyaXB0aW9uL3dtbC9tZWRpYS1kZXNjcmlwdGlvbi5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udGVudF9vdmVybGF5L2luZGV4LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9jb250ZW50X292ZXJsYXkvd21sL292ZXJsYXkuanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRlbnRfdGFnL2luZGV4LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9jb250ZW50X3RhZy93bWwvdGFnLmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9jb250ZW50X3RodW1ibmFpbC9pbmRleC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udGVudF90aHVtYm5haWwvd21sL3RodW1ibmFpbC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udHJvbF9idXR0b24tZ3JvdXAvaW5kZXguanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRyb2xfYnV0dG9uLWdyb3VwL3dtbC9idXR0b24tZ3JvdXAuanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRyb2xfYnV0dG9uLXNlbGVjdC9pbmRleC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udHJvbF9idXR0b24tc2VsZWN0L3dtbC9idXR0b24tc2VsZWN0LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9jb250cm9sX2J1dHRvbi9pbmRleC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udHJvbF9idXR0b24vd21sL2J1dHRvbi5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udHJvbF9jaGVja2JveC9pbmRleC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udHJvbF9jaGVja2JveC93bWwvY2hlY2tib3guanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRyb2xfZGF0ZS1maWVsZC9pbmRleC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udHJvbF9kYXRlLWZpZWxkL3dtbC9kYXRlLWZpZWxkLmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9jb250cm9sX2Rpc3BsYXktZmllbGQvaW5kZXguanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRyb2xfZGlzcGxheS1maWVsZC93bWwvZGlzcGxheS1maWVsZC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udHJvbF9kcm9wLWRvd24vaW5kZXguanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRyb2xfZHJvcC1kb3duL3dtbC9kcm9wLWRvd24uanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRyb2xfZHJvcC1saXN0LWZpZWxkL2luZGV4LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9jb250cm9sX2Ryb3AtbGlzdC1maWVsZC93bWwvZHJvcC1saXN0LWZpZWxkLmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9jb250cm9sX2Ryb3AtbGlzdC9pbmRleC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udHJvbF9kcm9wLWxpc3Qvd21sL2Ryb3AtbGlzdC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udHJvbF9maWxlLXVwbG9hZC1zdXJmYWNlL2luZGV4LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9jb250cm9sX2ZpbGUtdXBsb2FkLXN1cmZhY2Uvd21sL2ZpbGUtdXBsb2FkLXN1cmZhY2UuanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRyb2xfbXVsdGktc2VsZWN0L2luZGV4LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9jb250cm9sX211bHRpLXNlbGVjdC93bWwvbXVsdGktc2VsZWN0LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9jb250cm9sX3BhZ2luYXRvci9pbmRleC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udHJvbF9wYWdpbmF0b3Ivd21sL3BhZ2luYXRvci5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udHJvbF9zZWFyY2gvaW5kZXguanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRyb2xfc2VhcmNoL3dtbC9zZWFyY2guanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRyb2xfc2VsZWN0L2luZGV4LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9jb250cm9sX3NlbGVjdC93bWwvc2VsZWN0LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9jb250cm9sX3N0YWNrLXNlbGVjdC9pbmRleC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udHJvbF9zdGFjay1zZWxlY3Qvd21sL3N0YWNrLXNlbGVjdC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udHJvbF9zdGFjay9pbmRleC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udHJvbF9zdGFjay93bWwvc3RhY2suanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRyb2xfc3dpdGNoL2luZGV4LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9jb250cm9sX3N3aXRjaC93bWwvc3dpdGNoLmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9jb250cm9sX3RhYi1iYXIvaW5kZXguanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRyb2xfdGFiLWJhci93bWwvdGFiLWJhci5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udHJvbF90YWctY29udHJvbC9pbmRleC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udHJvbF90YWctY29udHJvbC93bWwvdGFnLmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9jb250cm9sX3RleHQtZmllbGQvaW5kZXguanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRyb2xfdGV4dC1maWVsZC93bWwvdGV4dC1maWVsZC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvY29udHJvbF90ZXh0LWlucHV0L2luZGV4LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9jb250cm9sX3RleHQtaW5wdXQvd21sL3RleHQtaW5wdXQuanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2NvbnRyb2xfdHlwZWFoZWFkL2luZGV4LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9jb250cm9sX3R5cGVhaGVhZC93bWwvdHlwZWFoZWFkLmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9kYXRhX2RhdGEtdGFibGUvZGF0YS5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvZGF0YV9kYXRhLXRhYmxlL2luZGV4LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9kYXRhX2RhdGEtdGFibGUvd21sL3RhYmxlLmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9kYXRhX3Byb3BlcnR5LWxpc3QvaW5kZXguanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2RhdGFfcHJvcGVydHktbGlzdC93bWwvcHJvcGVydHktbGlzdC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvZGlhbG9nX2FsZXJ0L2luZGV4LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9kaWFsb2dfYWxlcnQvd21sL2FsZXJ0LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9kaWFsb2dfY29uZmlybS9pbmRleC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvZGlhbG9nX2NvbmZpcm0vd21sL2NvbmZpcm0uanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2RpYWxvZ19pbmZvcm0vaW5kZXguanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2RpYWxvZ19pbmZvcm0vd21sL2luZm9ybS5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvZGlhbG9nX21vZGFsL2luZGV4LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9kaWFsb2dfbW9kYWwvd21sL21vZGFsLmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9kaWFsb2dfcHJvbXB0L2luZGV4LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9kaWFsb2dfcHJvbXB0L3dtbC9wcm9tcHQuanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2xheW91dF9jYWxsb3V0L2luZGV4LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9sYXlvdXRfY2FsbG91dC93bWwvY2FsbG91dC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvbGF5b3V0X2Rlc2NyaXB0aW9uLWxpc3QvaW5kZXguanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2xheW91dF9kZXNjcmlwdGlvbi1saXN0L3dtbC9kZXNjcmlwdGlvbi1saXN0LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9sYXlvdXRfZ3JpZC9pbmRleC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvbGF5b3V0X2dyaWQvd21sL2dyaWQuanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2xheW91dF9ob3Jpem9udGFsL2luZGV4LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9sYXlvdXRfaG9yaXpvbnRhbC93bWwvaG9yaXpvbnRhbC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvbGF5b3V0X2xpc3QvaW5kZXguanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2xheW91dF9saXN0L3dtbC9saXN0LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9sYXlvdXRfbWV0ZXIvaW5kZXguanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2xheW91dF9tZXRlci93bWwvbWV0ZXIuanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2xheW91dF9wYW5lbC9pbmRleC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvbGF5b3V0X3BhbmVsL3dtbC9wYW5lbC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvbGF5b3V0X3RhYi9pbmRleC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvbGF5b3V0X3RhYi93bWwvdGFiLmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9sYXlvdXRfdGFibGUvaW5kZXguanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL2xheW91dF90YWJsZS93bWwvdGFibGUuanMiLCJ0ZXN0L2Jyb3dzZXIvZGVzdC9wYWdlL21lbnVfbWVudS9pbmRleC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvbWVudV9tZW51L3dtbC9tZW51LmpzIiwidGVzdC9icm93c2VyL2Rlc3QvcGFnZS9tZW51X25hdi9pbmRleC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2UvbWVudV9uYXYvd21sL25hdi5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3BhZ2VzLmpzIiwidGVzdC9icm93c2VyL2Rlc3Qvd2lkZ2V0cy9kZW1vL2luZGV4LmpzIiwidGVzdC9icm93c2VyL2Rlc3Qvd2lkZ2V0cy9kZW1vL3dtbC9kZW1vLmpzIiwidGVzdC9icm93c2VyL2Rlc3Qvd21sL2FwcC5qcyIsInRlc3QvYnJvd3Nlci9kZXN0L3dtbC9uYXZpZ2F0aW9uLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9TQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2bkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2phQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzd4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMS9JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2NhcmV0XCIpO1xudmFyIHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLkNBUkVUID0gJ3d3LWNhcmV0Jztcbi8qKlxuICogQ2FyZXRcbiAqL1xudmFyIENhcmV0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDYXJldCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYXJldCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgICAgICBpZDogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmlkKSA/IF90aGlzLmF0dHJzLnd3LmlkIDogJycsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiB1dGlsXzEuY29uY2F0KGV4cG9ydHMuQ0FSRVQsIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5jbGFzc05hbWUpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuY2xhc3NOYW1lIDogJycpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENhcmV0O1xufSh3bWxfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuQ2FyZXQgPSBDYXJldDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy9AdHMtaWdub3JlOiA2MTkyXG52YXIgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19pZiA9IGZ1bmN0aW9uIChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkge1xuICAgIHJldHVybiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCgpO1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JJbiA9IGZ1bmN0aW9uIChsaXN0LCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2Zvck9mID0gZnVuY3Rpb24gKG8sIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYWluKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX190aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ3NwYW4nLCB7IGh0bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5yb290LmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NOYW1lIH0sIHdtbDoge30gfSwgW10pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBNYWluLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gTWFpbjtcbn0oKSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FyZXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9jbG9zZVwiKTtcbnZhciB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5DTE9TRSA9ICd3dy1jbG9zZSc7XG4vKipcbiAqIENsb3NlXG4gKi9cbnZhciBDbG9zZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2xvc2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2xvc2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBpZDogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmlkKSA/XG4gICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuaWQgOiAnJyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogdXRpbF8xLmNvbmNhdChleHBvcnRzLkNMT1NFLCAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuY2xhc3NOYW1lKSA/XG4gICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuY2xhc3NOYW1lIDogJycpLFxuICAgICAgICAgICAgb25DbGljazogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm9uQ2xpY2spID9cbiAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5vbkNsaWNrIDogZnVuY3Rpb24gKCkgeyB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENsb3NlO1xufSh3bWxfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuQ2xvc2UgPSBDbG9zZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy9AdHMtaWdub3JlOiA2MTkyXG52YXIgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19pZiA9IGZ1bmN0aW9uIChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkge1xuICAgIHJldHVybiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCgpO1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JJbiA9IGZ1bmN0aW9uIChsaXN0LCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2Zvck9mID0gZnVuY3Rpb24gKG8sIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYWluKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX190aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ3NwYW4nLCB7IGh0bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jbGFzc05hbWUsICdvbmNsaWNrJzogX19jb250ZXh0LnZhbHVlcy5vbkNsaWNrIH0sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFx1MDBEN1wiKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbG9zZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgX18xID0gcmVxdWlyZShcIi4uLy4uL1wiKTtcbnZhciBlbWJlZF8xID0gcmVxdWlyZShcIi4vd21sL2VtYmVkXCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5FTUJFRCA9ICd3dy1lbWJlZCc7XG4vKipcbiAqIEVtYmVkXG4gKi9cbnZhciBFbWJlZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRW1iZWQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRW1iZWQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IGVtYmVkXzEuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgIGlkOiAnZW1iZWQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWQ6IF9fMS5nZXRJZChfdGhpcy5hdHRycyksXG4gICAgICAgICAgICBjbGFzc05hbWU6IHV0aWxfMS5jb25jYXQoZXhwb3J0cy5FTUJFRCwgX18xLmdldENsYXNzTmFtZShfdGhpcy5hdHRycykpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBFbWJlZDtcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLkVtYmVkID0gRW1iZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3NwcmVhZEFycmF5cyA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheXMpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxuICAgICAgICAgICAgcltrXSA9IGFbal07XG4gICAgcmV0dXJuIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy9AdHMtaWdub3JlOiA2MTkyXG52YXIgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19pZiA9IGZ1bmN0aW9uIChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkge1xuICAgIHJldHVybiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCgpO1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JJbiA9IGZ1bmN0aW9uIChsaXN0LCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2Zvck9mID0gZnVuY3Rpb24gKG8sIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYWluKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX190aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ2RpdicsIHsgaHRtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmNsYXNzTmFtZSB9LCB3bWw6IHt9IH0sIF9fc3ByZWFkQXJyYXlzKChfX2NvbnRleHQuY2hpbGRyZW4pKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbWJlZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHdtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2xpbmtcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgYWN0aXZlXzEgPSByZXF1aXJlKFwiLi4vc3RhdGUvYWN0aXZlXCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuLyoqXG4gKiBMSU5LXG4gKi9cbmV4cG9ydHMuTElOSyA9ICd3dy1saW5rJztcbi8qKlxuICogTGlua0NsaWNrZWRFdmVudCBpbmRpY2F0ZXMgYW4gTGluayBoYXMgYmVlbiBjbGlja2VkLlxuICovXG52YXIgTGlua0NsaWNrZWRFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMaW5rQ2xpY2tlZEV2ZW50KG5hbWUsIGhyZWYpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5ocmVmID0gaHJlZjtcbiAgICB9XG4gICAgcmV0dXJuIExpbmtDbGlja2VkRXZlbnQ7XG59KCkpO1xuZXhwb3J0cy5MaW5rQ2xpY2tlZEV2ZW50ID0gTGlua0NsaWNrZWRFdmVudDtcbi8qKlxuICogTGluayBnZW5lcmF0ZXMgYW4gPGE+IGVsZW1lbnQuXG4gKi9cbnZhciBMaW5rID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMaW5rLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpbmsoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogbmFtZSBhc3NpZ25lZCB0byB0aGlzIExpbmsuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5uYW1lID0gKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm5hbWUpID9cbiAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3Lm5hbWUgOiAnJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRpdGxlIGFzc2lnbmVkIHRvIHRoaXMgTGluay5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnRpdGxlID0gKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnRpdGxlKSA/XG4gICAgICAgICAgICBfdGhpcy5hdHRycy53dy50aXRsZSA6ICcnO1xuICAgICAgICAvKipcbiAgICAgICAgICogaHJlZiBhc3NpZ25lZCB0byB0aGlzIExpbmtcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmhyZWYgPSAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuaHJlZikgP1xuICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuaHJlZiA6ICcnO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgICAgaWQ6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5pZCkgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5pZCA6ICcnLFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuZGlzYWJsZWQpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuZGlzYWJsZWQgOiBudWxsLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogdXRpbF8xLmNvbmNhdChleHBvcnRzLkxJTkssIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5jbGFzc05hbWUpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuY2xhc3NOYW1lIDogJycsIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5hY3RpdmUpID9cbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlXzEuQUNUSVZFIDogJycpLFxuICAgICAgICAgICAgICAgIHRpdGxlOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cudGl0bGUpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cudGl0bGUgOiBudWxsLFxuICAgICAgICAgICAgICAgIG5hbWU6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5uYW1lKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3Lm5hbWUgOiBudWxsLFxuICAgICAgICAgICAgICAgIGhyZWY6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5ocmVmKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LmhyZWYgOiAnIycsXG4gICAgICAgICAgICAgICAgYWN0aXZlOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuYWN0aXZlKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LmFjdGl2ZSA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIC8vVE9ETzogbW92ZSB0byBkb20gbGliXG4gICAgICAgICAgICAgICAgY29udGVudDogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnRleHQpID9cbiAgICAgICAgICAgICAgICAgICAgW2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKF90aGlzLmF0dHJzLnd3LnRleHQpXSA6XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNoaWxkcmVuLFxuICAgICAgICAgICAgICAgIGNsaWNrZWQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hdHRycy53dykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMuYXR0cnMud3csIG5hbWVfMSA9IF9hLm5hbWUsIGhyZWYgPSBfYS5ocmVmLCBvbkNsaWNrID0gX2Eub25DbGljaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaHJlZilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob25DbGljaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrKG5ldyBMaW5rQ2xpY2tlZEV2ZW50KG5hbWVfMSwgaHJlZikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAgKiBhY3RpdmF0ZSB0aGlzIG5hdiBsaXN0IEl0ZW0uXG4gICAgICAqL1xuICAgIExpbmsucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbSA9IHV0aWxfMS5nZXRCeUlkKHRoaXMudmlldywgdGhpcy52YWx1ZXMuYS5pZCk7XG4gICAgICAgIGlmIChtLmlzSnVzdCgpKSB7XG4gICAgICAgICAgICB2YXIgZSA9IG0uZ2V0KCk7XG4gICAgICAgICAgICBlLmNsYXNzTGlzdC5yZW1vdmUoYWN0aXZlXzEuQUNUSVZFKTtcbiAgICAgICAgICAgIGUuY2xhc3NMaXN0LmFkZChhY3RpdmVfMS5BQ1RJVkUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZGVhY3RpdmF0ZSB0aGlzIG5hdiBsaXN0IGl0ZW0uXG4gICAgICovXG4gICAgTGluay5wcm90b3R5cGUuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG0gPSB1dGlsXzEuZ2V0QnlJZCh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLmEuaWQpO1xuICAgICAgICBpZiAobS5pc0p1c3QoKSlcbiAgICAgICAgICAgIG0uZ2V0KCkuY2xhc3NMaXN0LnJlbW92ZShhY3RpdmVfMS5BQ1RJVkUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBMaW5rO1xufSh3bWwuQ29tcG9uZW50KSk7XG5leHBvcnRzLkxpbmsgPSBMaW5rO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19zcHJlYWRBcnJheXMgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xuICAgIHJldHVybiByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdhJywgeyBodG1sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuYS5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5hLmNsYXNzTmFtZSwgJ2hyZWYnOiBfX2NvbnRleHQudmFsdWVzLmEuaHJlZiwgJ3RpdGxlJzogX19jb250ZXh0LnZhbHVlcy5hLnRpdGxlLCAnZGlzYWJsZWQnOiBfX2NvbnRleHQudmFsdWVzLmEuZGlzYWJsZWQsICdvbmNsaWNrJzogX19jb250ZXh0LnZhbHVlcy5hLmNsaWNrZWQgfSwgd21sOiB7fSB9LCBfX3NwcmVhZEFycmF5cygoX19jb250ZXh0LnZhbHVlcy5hLmNvbnRlbnQpKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW5rLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvbWVkaWEtZGVzY3JpcHRpb25cIik7XG52YXIgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBfXzEgPSByZXF1aXJlKFwiLi4vLi4vXCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5NRURJQV9ERVNDUklQVElPTiA9ICd3dy1tZWRpYS1kZXNjcmlwdGlvbic7XG5leHBvcnRzLk1FRElBX0RFU0NSSVBUSU9OX01FRElBID0gJ3d3LW1lZGlhLWRlc2NyaXB0aW9uX19tZWRpYSc7XG5leHBvcnRzLk1FRElBX0RFU0NSSVBUSU9OX0RFU0NSSVBUSU9OID0gJ3d3LW1lZGlhLWRlc2NyaXB0aW9uX19kZXNjcmlwdGlvbic7XG4vKipcbiAqIE1lZGlhRGVzY3JpcHRpb25cbiAqL1xudmFyIE1lZGlhRGVzY3JpcHRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lZGlhRGVzY3JpcHRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVkaWFEZXNjcmlwdGlvbigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWVkaWFEZXNjcmlwdGlvbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiBfXzEuZ2V0SWQoX3RoaXMuYXR0cnMpLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiB1dGlsXzEuY29uY2F0KGV4cG9ydHMuTUVESUFfREVTQ1JJUFRJT04sIF9fMS5nZXRDbGFzc05hbWUoX3RoaXMuYXR0cnMpKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNZWRpYURlc2NyaXB0aW9uO1xufSh3bWxfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuTWVkaWFEZXNjcmlwdGlvbiA9IE1lZGlhRGVzY3JpcHRpb247XG4vKipcbiAqIE1lZGlhXG4gKi9cbnZhciBNZWRpYSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVkaWEsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVkaWEoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1lZGlhKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6IF9fMS5nZXRJZChfdGhpcy5hdHRycyksXG4gICAgICAgICAgICBjbGFzc05hbWU6IHV0aWxfMS5jb25jYXQoZXhwb3J0cy5NRURJQV9ERVNDUklQVElPTl9NRURJQSwgX18xLmdldENsYXNzTmFtZShfdGhpcy5hdHRycykpXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1lZGlhO1xufSh3bWxfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuTWVkaWEgPSBNZWRpYTtcbi8qKlxuICogRGVzY3JpcHRpb25cbiAqL1xudmFyIERlc2NyaXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEZXNjcmlwdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZXNjcmlwdGlvbigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuRGVzY3JpcHRpb24oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBpZDogX18xLmdldElkKF90aGlzLmF0dHJzKSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogdXRpbF8xLmNvbmNhdChleHBvcnRzLk1FRElBX0RFU0NSSVBUSU9OX0RFU0NSSVBUSU9OLCBfXzEuZ2V0Q2xhc3NOYW1lKF90aGlzLmF0dHJzKSlcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gRGVzY3JpcHRpb247XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5EZXNjcmlwdGlvbiA9IERlc2NyaXB0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19zcHJlYWRBcnJheXMgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xuICAgIHJldHVybiByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1lZGlhRGVzY3JpcHRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVkaWFEZXNjcmlwdGlvbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdkaXYnLCB7IGh0bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jbGFzc05hbWUgfSwgd21sOiB7fSB9LCBfX3NwcmVhZEFycmF5cygoX19jb250ZXh0LmNoaWxkcmVuKSkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBNZWRpYURlc2NyaXB0aW9uLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWVkaWFEZXNjcmlwdGlvbi5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWVkaWFEZXNjcmlwdGlvbi5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBNZWRpYURlc2NyaXB0aW9uLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIE1lZGlhRGVzY3JpcHRpb24ucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIE1lZGlhRGVzY3JpcHRpb24ucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgTWVkaWFEZXNjcmlwdGlvbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gTWVkaWFEZXNjcmlwdGlvbjtcbn0oKSk7XG5leHBvcnRzLk1lZGlhRGVzY3JpcHRpb24gPSBNZWRpYURlc2NyaXB0aW9uO1xuO1xudmFyIE1lZGlhID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1lZGlhKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX190aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ2RpdicsIHsgaHRtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmNsYXNzTmFtZSB9LCB3bWw6IHt9IH0sIF9fc3ByZWFkQXJyYXlzKChfX2NvbnRleHQuY2hpbGRyZW4pKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1lZGlhLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWVkaWEucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1lZGlhLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1lZGlhLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIE1lZGlhLnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBNZWRpYS5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNZWRpYS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gTWVkaWE7XG59KCkpO1xuZXhwb3J0cy5NZWRpYSA9IE1lZGlhO1xuO1xudmFyIERlc2NyaXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlc2NyaXB0aW9uKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX190aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ2RpdicsIHsgaHRtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmNsYXNzTmFtZSB9LCB3bWw6IHt9IH0sIF9fc3ByZWFkQXJyYXlzKChfX2NvbnRleHQuY2hpbGRyZW4pKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIERlc2NyaXB0aW9uLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgRGVzY3JpcHRpb24ucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIERlc2NyaXB0aW9uLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIERlc2NyaXB0aW9uLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIERlc2NyaXB0aW9uLnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBEZXNjcmlwdGlvbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBEZXNjcmlwdGlvbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gRGVzY3JpcHRpb247XG59KCkpO1xuZXhwb3J0cy5EZXNjcmlwdGlvbiA9IERlc2NyaXB0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVkaWEtZGVzY3JpcHRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9tZW51LWljb25cIik7XG52YXIgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuTUVOVV9JQ09OID0gJ3d3LW1lbnUtaWNvbic7XG5leHBvcnRzLk1FTlVfSUNPTl9EQVNIID0gJ3d3LW1lbnUtaWNvbl9fZGFzaCc7XG4vKipcbiAqIE1lbnVJY29uIHByb3ZpZGVzIGEgY3NzIGltcGxlbWVudCBpY29uIG5vcm1hbGx5IHVzZWRcbiAqIHRvIHRvZ2dsZSBhIHNpZGUgbWVudS5cbiAqL1xudmFyIE1lbnVJY29uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZW51SWNvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZW51SWNvbigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgICAgICBpZDogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmlkKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LmlkIDogJycsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiB1dGlsXzEuY29uY2F0KGV4cG9ydHMuTUVOVV9JQ09OLCAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuaWQpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuaWQgOiAnJylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkYXNoOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdkYXNoJyxcbiAgICAgICAgICAgICAgICBjbGFzczogZXhwb3J0cy5NRU5VX0lDT05fREFTSFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNZW51SWNvbjtcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLk1lbnVJY29uID0gTWVudUljb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdzcGFuJywgeyBodG1sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMucm9vdC5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5yb290LmNsYXNzTmFtZSB9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnc3BhbicsIHsgaHRtbDogeyAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmRhc2guY2xhc3MgfSwgd21sOiB7fSB9LCBbXSksXG4gICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3NwYW4nLCB7IGh0bWw6IHsgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5kYXNoLmNsYXNzIH0sIHdtbDoge30gfSwgW10pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdzcGFuJywgeyBodG1sOiB7ICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuZGFzaC5jbGFzcyB9LCB3bWw6IHt9IH0sIFtdKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZW51LWljb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG4vKipcbiAqIFZFUlRJQ0FMIGluZGljYXRlcyBhbiBlbGVtZW50IGlzIHZlcnRpY2FsIHJlbmRlcmVyZC5cbiAqL1xuZXhwb3J0cy5WRVJUSUNBTCA9ICctdmVydGljYWwnO1xuLyoqXG4gKiBQVVNIQUJMRSBpbmRpY2F0ZXMgYW4gZWxlbWVudCBzdXBwb3J0cyBiZWluZyBwdXNoZWRcbiAqIGFuZCBjYW4gaGF2ZSBzdHlsZXMgYWRkZWQgdG8gaXQgYXJvdW5kIHRoZSBjb25jZXB0LlxuICovXG5leHBvcnRzLlBVU0hBQkxFID0gJy1wdXNoYWJsZSc7XG4vKipcbiAqIFBPU0lUSU9ORUQgaW5kaWNhdGVzIGFuIGVsZW1lbnQgaXMgcG9zaXRpb25lZCBhbmQgcmVzcG9uZHNcbiAqIHRvIHRoZSBsZWZ0LHJpZ2h0IGV0Yy4gcHJvcGVydGllcy5cbiAqL1xuZXhwb3J0cy5QT1NJVElPTkVEID0gJy1wb3NpdGlvbmVkJztcbi8qKlxuICogQkxPQ0sgaW5kaWNhdGVzIGFuIGVsZW1lbnQgc2hvdWxkIGJlIGJsb2NrIGRpc3BsYXllZC5cbiAqL1xuZXhwb3J0cy5CTE9DSyA9ICctYmxvY2snO1xuLyoqXG4gKiBDTEVBUkZJWCBoYWNrLlxuICovXG5leHBvcnRzLkNMRUFSRklYID0gJy1jbGVhcmZpeCc7XG4vKipcbiAqIEpVU1RJRklFRCBjb250ZW50LlxuICovXG5leHBvcnRzLkpVU1RJRklFRCA9ICctanVzdGlmaWVkJztcbi8qKlxuICogTEVGVCBpbmRpY2F0ZXMgY29udGVudCBmbG9hdGVkIG9yIHBvc2l0aW9uZWQgdG8gdGhlIGxlZnQuXG4gKi9cbmV4cG9ydHMuTEVGVCA9ICctbGVmdCc7XG4vKipcbiAqIFJJR0hUIGluZGljYXRlcyBjb250ZW50IGZsb2F0ZWQgb3IgcG9zaXRpb25lZCB0byB0aGUgcmlnaHQuXG4gKi9cbmV4cG9ydHMuUklHSFQgPSAnLXJpZ2h0Jztcbi8qKlxuICogSE9SSVpPTlRBTCBpbmRpY2F0ZXMgYSBob3Jpem9udGFsIGFsaWdubWVudC5cbiAqL1xuZXhwb3J0cy5IT1JJWk9OVEFMID0gJy1ob3Jpem9udGFsJztcbmV4cG9ydHMuTUlERExFID0gJy1taWRkbGUnO1xuZXhwb3J0cy5CT1RUT00gPSAnLWJvdHRvbSc7XG4vLy9jbGFzc05hbWVzOmVuZFxuLyoqXG4gKiBnZXRCbG9ja0NsYXNzTmFtZSBwcm92aWRlcyB0aGUgX19CTE9DS19fIGNsYXNzIG5hbWUgaWYgdGhlIGF0dHJpYnV0ZVxuICogdmFsdWUgaXMgc2V0IHRvIHRydWUuXG4gKi9cbmV4cG9ydHMuZ2V0QmxvY2tDbGFzc05hbWUgPSBmdW5jdGlvbiAoYXR0cnMpIHtcbiAgICByZXR1cm4gKGF0dHJzLnd3ICYmIChhdHRycy53dy5ibG9jayA9PT0gdHJ1ZSkpID8gZXhwb3J0cy5CTE9DSyA6ICcnO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9yaWVudGF0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBfXzEgPSByZXF1aXJlKFwiLi4vLi4vXCIpO1xudmFyIG92ZXJsYXlfMSA9IHJlcXVpcmUoXCIuL3dtbC9vdmVybGF5XCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5PVkVSTEFZID0gJ3d3LW92ZXJsYXknO1xuLyoqXG4gKiBPdmVybGF5XG4gKi9cbnZhciBPdmVybGF5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPdmVybGF5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE92ZXJsYXkoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IG92ZXJsYXlfMS5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdyb290J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlkOiBfXzEuZ2V0SWQoX3RoaXMuYXR0cnMpLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiB1dGlsXzEuY29uY2F0KGV4cG9ydHMuT1ZFUkxBWSwgX18xLmdldENsYXNzTmFtZShfdGhpcy5hdHRycykpLFxuICAgICAgICAgICAgb25jbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5vbkNsaWNrKVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5vbkNsaWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogY2xvc2UgdGhlIG92ZXJsYXkuXG4gICAgICovXG4gICAgT3ZlcmxheS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtTyA9IHV0aWxfMS5nZXRCeUlkKHRoaXMudmlldywgdGhpcy52YWx1ZXMud21sLmlkKTtcbiAgICAgICAgaWYgKG1PLmlzSnVzdCgpKSB7XG4gICAgICAgICAgICB2YXIgbiA9IG1PLmdldCgpO1xuICAgICAgICAgICAgaWYgKG4ucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICBuLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBPdmVybGF5O1xufSh3bWxfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuT3ZlcmxheSA9IE92ZXJsYXk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdkaXYnLCB7IGh0bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jbGFzc05hbWUsICdvbmNsaWNrJzogX19jb250ZXh0LnZhbHVlcy5vbmNsaWNrIH0sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLndtbC5pZCB9IH0sIFtdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgTWFpbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIE1haW47XG59KCkpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW92ZXJsYXkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLkVYVFJBX1NNQUxMID0gJy1leHRyYS1zbWFsbCc7XG5leHBvcnRzLlNNQUxMID0gJy1zbWFsbCc7XG5leHBvcnRzLk1FRElVTSA9ICctbWVkaXVtJztcbmV4cG9ydHMuTEFSR0UgPSAnLWxhcmdlJztcbmV4cG9ydHMuRVhUUkFfTEFSR0UgPSAnLWV4dHJhLWxhcmdlJztcbi8vL2NsYXNzTmFtZXM6ZW5kXG4vKipcbiAqIFNpemVcbiAqL1xudmFyIFNpemU7XG4oZnVuY3Rpb24gKFNpemUpIHtcbiAgICBTaXplW1wiRXh0cmFTbWFsbFwiXSA9IFwiZXh0cmEtc21hbGxcIjtcbiAgICBTaXplW1wiU21hbGxcIl0gPSBcInNtYWxsXCI7XG4gICAgU2l6ZVtcIk1lZGl1bVwiXSA9IFwibWVkaXVtXCI7XG4gICAgU2l6ZVtcIkxhcmdlXCJdID0gXCJsYXJnZVwiO1xuICAgIFNpemVbXCJFeHRyYUxhcmdlXCJdID0gXCJleHRyYS1sYXJnZVwiO1xufSkoU2l6ZSA9IGV4cG9ydHMuU2l6ZSB8fCAoZXhwb3J0cy5TaXplID0ge30pKTtcbi8qKlxuICogZ2V0U2l6ZUNsYXNzTmFtZVxuICovXG5leHBvcnRzLmdldFNpemVDbGFzc05hbWUgPSBmdW5jdGlvbiAocykge1xuICAgIGlmIChzID09PSBTaXplLkV4dHJhU21hbGwpXG4gICAgICAgIHJldHVybiBleHBvcnRzLkVYVFJBX1NNQUxMO1xuICAgIGVsc2UgaWYgKHMgPT09IFNpemUuU21hbGwpXG4gICAgICAgIHJldHVybiBleHBvcnRzLlNNQUxMO1xuICAgIGVsc2UgaWYgKHMgPT09IFNpemUuTWVkaXVtKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5NRURJVU07XG4gICAgZWxzZSBpZiAocyA9PT0gU2l6ZS5MYXJnZSlcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuTEFSR0U7XG4gICAgZWxzZSBpZiAocyA9PT0gU2l6ZS5FeHRyYUxhcmdlKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5FWFRSQV9MQVJHRTtcbiAgICByZXR1cm4gJyc7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2l6ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbi8qKlxuICogQUNUSVZFXG4gKi9cbmV4cG9ydHMuQUNUSVZFID0gJy1hY3RpdmUnO1xuLyoqXG4gKiBhY3RpdmF0ZSBoZWxwZXIuXG4gKlxuICogQWRkcyB0aGUgQUNUSVZFIGNsYXNzLlxuICovXG5leHBvcnRzLmFjdGl2YXRlID0gZnVuY3Rpb24gKHZpZXcsIGlkKSB7XG4gICAgcmV0dXJuIHV0aWxfMS5nZXRCeUlkKHZpZXcsIGlkKVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUuY2xhc3NMaXN0LnJlbW92ZShleHBvcnRzLkFDVElWRSk7XG4gICAgICAgIGUuY2xhc3NMaXN0LmFkZChleHBvcnRzLkFDVElWRSk7XG4gICAgfSk7XG59O1xuLyoqXG4gKiBkZWFjdGl2YXRlIGhlbHBlci5cbiAqXG4gKiBSZW1vdmVzIHRoZSBBQ1RJVkUgY2xhc3MuXG4gKi9cbmV4cG9ydHMuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uICh2aWV3LCBpZCkge1xuICAgIHJldHVybiB1dGlsXzEuZ2V0QnlJZCh2aWV3LCBpZClcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5jbGFzc0xpc3QucmVtb3ZlKGV4cG9ydHMuQUNUSVZFKTsgfSk7XG59O1xuLyoqXG4gKiBpc0FjdGl2ZSBoZWxwZGVyXG4gKlxuICogUXVlcmllcyB3aGV0aGVyIHRoZSBBQ1RJVkUgY2xhc3MgaXMgcHJlc2VudC5cbiAqL1xuZXhwb3J0cy5pc0FjdGl2ZSA9IGZ1bmN0aW9uICh2aWV3LCBpZCkge1xuICAgIHJldHVybiB1dGlsXzEuZ2V0QnlJZCh2aWV3LCBpZClcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5jbGFzc0xpc3QuY29udGFpbnMoZXhwb3J0cy5BQ1RJVkUpOyB9KVxuICAgICAgICAub3JKdXN0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9KVxuICAgICAgICAuZ2V0KCk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWN0aXZlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuLyoqXG4gKiBISURERU4gbWVhbnMgYW4gZWxlbWVudCBzaG91bGQgbm90IGJlIHZpc2libGUgYnV0IG5vdCByZW1vdmVkXG4gKiBmcm9tIHRoZSBET00uXG4gKi9cbmV4cG9ydHMuSElEREVOID0gJy13dy1oaWRkZW4nO1xuLyoqXG4gKiBpc0hpZGRlbiBoZWxwZXIuXG4gKlxuICogUmV0cmlldmVzIGFuIEhUTUxFbGVtZW50IGJ5IGlkIGFuZCBjaGVja3Mgd2hldGhlclxuICogaXQgaGFzIHRoZSBoaWRkZW4gY2xhc3MgYXR0YWNoZWQuXG4gKi9cbmV4cG9ydHMuaXNIaWRkZW4gPSBmdW5jdGlvbiAodmlldywgaWQpIHtcbiAgICB2YXIgbSA9IHZpZXcuZmluZEJ5SWQoaWQpO1xuICAgIGlmIChtLmlzTm90aGluZygpKSB7XG4gICAgICAgIHV0aWxfMS53YXJuTWlzc2luZyh2aWV3LCBpZCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG0uZ2V0KCkuY2xhc3NMaXN0LmNvbnRhaW5zKGV4cG9ydHMuSElEREVOKTtcbiAgICB9XG59O1xuLyoqXG4gKiBoaWRlIGhlbHBlci5cbiAqXG4gKiBBdHRlbXB0cyB0byBhZGQgSElEREVOIHRvIHRoZSB0YXJnZXQgZWxlbWVudHMgY2xhc3MgbmFtZS5cbiAqL1xuZXhwb3J0cy5oaWRlID0gZnVuY3Rpb24gKHZpZXcsIGlkKSB7XG4gICAgdmFyIG0gPSB2aWV3LmZpbmRCeUlkKGlkKTtcbiAgICBpZiAobS5pc05vdGhpbmcoKSkge1xuICAgICAgICByZXR1cm4gdXRpbF8xLndhcm5NaXNzaW5nKHZpZXcsIGlkKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBlID0gbS5nZXQoKTtcbiAgICAgICAgZS5jbGFzc0xpc3QucmVtb3ZlKGV4cG9ydHMuSElEREVOKTtcbiAgICAgICAgZS5jbGFzc0xpc3QuYWRkKGV4cG9ydHMuSElEREVOKTtcbiAgICB9XG59O1xuLyoqXG4gKiBzaG93IGhlbHBlci5cbiAqXG4gKiBBdHRlbXB0cyB0byByZW1vdmUgdGhlIEhJRERFTiBjbGFzcyBuYW1lIGZyb20gdGhlIHRhcmdldCBlbGVtZW50LlxuICovXG5leHBvcnRzLnNob3cgPSBmdW5jdGlvbiAodmlldywgaWQpIHtcbiAgICB2YXIgbSA9IHZpZXcuZmluZEJ5SWQoaWQpO1xuICAgIGlmIChtLmlzTm90aGluZygpKSB7XG4gICAgICAgIHJldHVybiB1dGlsXzEud2Fybk1pc3NpbmcodmlldywgaWQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbS5nZXQoKS5jbGFzc0xpc3QucmVtb3ZlKGV4cG9ydHMuSElEREVOKTtcbiAgICB9XG59O1xuLyoqXG4gKiB0b2dnbGUgaGVscGVyLlxuICpcbiAqIEF0dGVtcHRzIHRvIHRvZ2dsZSB0aGUgSElEREVOIGNsYXNzIG5hbWUgZnJvbSB0aGUgdGFyZ2V0IGVsZW1lbnRcbiAqIGNsYXNzTGlzdC5cbiAqL1xuZXhwb3J0cy50b2dnbGUgPSBmdW5jdGlvbiAodmlldywgaWQpIHtcbiAgICB2YXIgbSA9IHZpZXcuZmluZEJ5SWQoaWQpO1xuICAgIGlmIChtLmlzTm90aGluZygpKSB7XG4gICAgICAgIHJldHVybiB1dGlsXzEud2Fybk1pc3NpbmcodmlldywgaWQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbS5nZXQoKS5jbGFzc0xpc3QudG9nZ2xlKGV4cG9ydHMuSElEREVOKTtcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGlkZGVuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuLyoqXG4gKiBERUZBVUxUIHN0eWxlLlxuICovXG5leHBvcnRzLkRFRkFVTFQgPSAnLWRlZmF1bHQnO1xuLyoqXG4gKiBQUklNQVJZIHN0eWxlLlxuICovXG5leHBvcnRzLlBSSU1BUlkgPSAnLXByaW1hcnknO1xuLyoqXG4gKiBTVUNDRVNTIHN0eWxlLlxuICovXG5leHBvcnRzLlNVQ0NFU1MgPSAnLXN1Y2Nlc3MnO1xuLyoqXG4gKiBJTkZPIHN0eWxlLlxuICovXG5leHBvcnRzLklORk8gPSAnLWluZm8nO1xuLyoqXG4gKiBXQVJOSU5HIHN0eWxlLlxuICovXG5leHBvcnRzLldBUk5JTkcgPSAnLXdhcm5pbmcnO1xuLyoqXG4gKiBFUlJPUiBzdHlsZS5cbiAqL1xuZXhwb3J0cy5FUlJPUiA9ICctZXJyb3InO1xuLyoqXG4gKiBPVVRMSU5FIHN0eWxlLlxuICovXG5leHBvcnRzLk9VVExJTkUgPSAnLW91dGxpbmUnO1xuLy8vY2xhc3NOYW1lczplbmRcbi8qKlxuICogU3R5bGUgZW51bS5cbiAqL1xudmFyIFN0eWxlO1xuKGZ1bmN0aW9uIChTdHlsZSkge1xuICAgIFN0eWxlW1wiRGVmYXVsdFwiXSA9IFwiZGVmYXVsdFwiO1xuICAgIFN0eWxlW1wiUHJpbWFyeVwiXSA9IFwicHJpbWFyeVwiO1xuICAgIFN0eWxlW1wiU3VjY2Vzc1wiXSA9IFwic3VjY2Vzc1wiO1xuICAgIFN0eWxlW1wiSW5mb1wiXSA9IFwiaW5mb1wiO1xuICAgIFN0eWxlW1wiV2FybmluZ1wiXSA9IFwid2FybmluZ1wiO1xuICAgIFN0eWxlW1wiRXJyb3JcIl0gPSBcImVycm9yXCI7XG59KShTdHlsZSA9IGV4cG9ydHMuU3R5bGUgfHwgKGV4cG9ydHMuU3R5bGUgPSB7fSkpO1xuZXhwb3J0cy5zdHlsZXMgPSBbXG4gICAgU3R5bGUuRGVmYXVsdCxcbiAgICBTdHlsZS5TdWNjZXNzLFxuICAgIFN0eWxlLkluZm8sXG4gICAgU3R5bGUuV2FybmluZyxcbiAgICBTdHlsZS5FcnJvclxuXTtcbi8qKlxuICogZ2V0U3R5bGVDbGFzc05hbWVcbiAqL1xuZXhwb3J0cy5nZXRTdHlsZUNsYXNzTmFtZSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgc3dpdGNoIChzKSB7XG4gICAgICAgIGNhc2UgU3R5bGUuRGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkRFRkFVTFQ7XG4gICAgICAgIGNhc2UgU3R5bGUuUHJpbWFyeTpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLlBSSU1BUlk7XG4gICAgICAgIGNhc2UgU3R5bGUuU3VjY2VzczpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLlNVQ0NFU1M7XG4gICAgICAgIGNhc2UgU3R5bGUuSW5mbzpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLklORk87XG4gICAgICAgIGNhc2UgU3R5bGUuV2FybmluZzpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLldBUk5JTkc7XG4gICAgICAgIGNhc2UgU3R5bGUuRXJyb3I6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5FUlJPUjtcbiAgICB9XG4gICAgcmV0dXJuIGV4cG9ydHMuREVGQVVMVDtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgc3R5bGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZW50L3N0eWxlXCIpO1xuZXhwb3J0cy5TdHlsZSA9IHN0eWxlXzEuU3R5bGU7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgX18xID0gcmVxdWlyZShcIi4uLy4uL1wiKTtcbnZhciB0YWdfMSA9IHJlcXVpcmUoXCIuL3dtbC90YWdcIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLlRBRyA9ICd3dy10YWcnO1xuLyoqXG4gKiBUYWdcbiAqL1xudmFyIFRhZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFnLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhZygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdGFnXzEuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgIGlkOiAndGFnJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlkOiBfXzEuZ2V0SWQoX3RoaXMuYXR0cnMpLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiB1dGlsXzEuY29uY2F0KGV4cG9ydHMuVEFHLCBfXzEuZ2V0Q2xhc3NOYW1lKF90aGlzLmF0dHJzKSwgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnN0eWxlKSA/XG4gICAgICAgICAgICAgICAgc3R5bGVfMS5nZXRTdHlsZUNsYXNzTmFtZShfdGhpcy5hdHRycy53dy5zdHlsZSkgOlxuICAgICAgICAgICAgICAgIHN0eWxlXzEuREVGQVVMVCksXG4gICAgICAgICAgICBvbmNsaWNrOiBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5vbkNsaWNrKVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5vbkNsaWNrKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udGVudDogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnRleHQpID9cbiAgICAgICAgICAgICAgICBbX18xLnRleHQoX3RoaXMuYXR0cnMud3cudGV4dCldIDogX3RoaXMuY2hpbGRyZW5cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVGFnO1xufSh3bWxfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuVGFnID0gVGFnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19zcHJlYWRBcnJheXMgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xuICAgIHJldHVybiByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdzcGFuJywgeyBodG1sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuY2xhc3NOYW1lLCAnb25jbGljayc6IF9fY29udGV4dC52YWx1ZXMub25jbGljayB9LCB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy53bWwuaWQgfSB9LCBfX3NwcmVhZEFycmF5cygoX19jb250ZXh0LnZhbHVlcy5jb250ZW50KSkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBNYWluLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gTWFpbjtcbn0oKSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFnLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvdGh1bWJuYWlsXCIpO1xudmFyIHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgX18xID0gcmVxdWlyZShcIi4uLy4uL1wiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuVEhVTUJOQUlMID0gJ3d3LXRodW1ibmFpbCc7XG5leHBvcnRzLlRIVU1CTkFJTF9DQVBUSU9OID0gJ3d3LXRodW1ibmFpbF9fY2FwdGlvbic7XG4vKipcbiAqIFRodW1ibmFpbFxuICovXG52YXIgVGh1bWJuYWlsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUaHVtYm5haWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGh1bWJuYWlsKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5ocmVmKSA/XG4gICAgICAgICAgICBuZXcgdmlld3MuQW5jaG9yKF90aGlzKSA6IG5ldyB2aWV3cy5UaHVtYm5haWwoX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBpZDogX18xLmdldElkKF90aGlzLmF0dHJzKSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogdXRpbF8xLmNvbmNhdChleHBvcnRzLlRIVU1CTkFJTCwgX18xLmdldENsYXNzTmFtZShfdGhpcy5hdHRycykpLFxuICAgICAgICAgICAgaHJlZjogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmhyZWYpID9cbiAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5ocmVmIDogJycsXG4gICAgICAgICAgICBvbmNsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5vbkNsaWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cub25DbGljaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVGh1bWJuYWlsO1xufSh3bWxfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuVGh1bWJuYWlsID0gVGh1bWJuYWlsO1xuLyoqXG4gKiBDYXB0aW9uXG4gKi9cbnZhciBDYXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDYXB0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENhcHRpb24oKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLkNhcHRpb24oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBpZDogX18xLmdldElkKF90aGlzLmF0dHJzKSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogdXRpbF8xLmNvbmNhdChleHBvcnRzLlRIVU1CTkFJTF9DQVBUSU9OLCBfXzEuZ2V0Q2xhc3NOYW1lKF90aGlzLmF0dHJzKSlcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ2FwdGlvbjtcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLkNhcHRpb24gPSBDYXB0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19zcHJlYWRBcnJheXMgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xuICAgIHJldHVybiByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIFRodW1ibmFpbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUaHVtYm5haWwoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnZGl2JywgeyBodG1sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuY2xhc3NOYW1lLCAnb25jbGljayc6IF9fY29udGV4dC52YWx1ZXMub25jbGljayB9LCB3bWw6IHt9IH0sIF9fc3ByZWFkQXJyYXlzKChfX2NvbnRleHQuY2hpbGRyZW4pKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIFRodW1ibmFpbC5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIFRodW1ibmFpbC5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgVGh1bWJuYWlsLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIFRodW1ibmFpbC5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBUaHVtYm5haWwucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIFRodW1ibmFpbC5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBUaHVtYm5haWwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIFRodW1ibmFpbDtcbn0oKSk7XG5leHBvcnRzLlRodW1ibmFpbCA9IFRodW1ibmFpbDtcbjtcbnZhciBBbmNob3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQW5jaG9yKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX190aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ2EnLCB7IGh0bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jbGFzc05hbWUsICdocmVmJzogX19jb250ZXh0LnZhbHVlcy5ocmVmLCAnb25jbGljayc6IF9fY29udGV4dC52YWx1ZXMub25jbGljayB9LCB3bWw6IHt9IH0sIF9fc3ByZWFkQXJyYXlzKChfX2NvbnRleHQuY2hpbGRyZW4pKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIEFuY2hvci5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIEFuY2hvci5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgQW5jaG9yLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIEFuY2hvci5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBBbmNob3IucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIEFuY2hvci5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBBbmNob3IucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIEFuY2hvcjtcbn0oKSk7XG5leHBvcnRzLkFuY2hvciA9IEFuY2hvcjtcbjtcbnZhciBDYXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhcHRpb24oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnZGl2JywgeyBodG1sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuY2xhc3NOYW1lIH0sIHdtbDoge30gfSwgX19zcHJlYWRBcnJheXMoKF9fY29udGV4dC5jaGlsZHJlbikpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgQ2FwdGlvbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIENhcHRpb24ucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIENhcHRpb24ucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgQ2FwdGlvbi5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBDYXB0aW9uLnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBDYXB0aW9uLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIENhcHRpb24ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIENhcHRpb247XG59KCkpO1xuZXhwb3J0cy5DYXB0aW9uID0gQ2FwdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRodW1ibmFpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2J1dHRvbi1ncm91cFwiKTtcbnZhciB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIHRvb2xiYXJfMSA9IHJlcXVpcmUoXCIuLi90b29sYmFyXCIpO1xudmFyIF9fMSA9IHJlcXVpcmUoXCIuLi8uLi9cIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLkJVVFRPTl9HUk9VUCA9ICd3dy1idXR0b24tZ3JvdXAnO1xuLyoqXG4gKiBCdXR0b25Hcm91cCBncm91cHMgbXVsdGlwbGUgYnV0dG9ucyBpbnRvIG9uZSBlbGVtZW50LlxuICovXG52YXIgQnV0dG9uR3JvdXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJ1dHRvbkdyb3VwLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJ1dHRvbkdyb3VwKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgICAgIGlkOiBfXzEuZ2V0SWQoX3RoaXMuYXR0cnMpLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogdXRpbF8xLmNvbmNhdChleHBvcnRzLkJVVFRPTl9HUk9VUCwgdG9vbGJhcl8xLlRPT0xCQVJfQ09NUEFULCBfXzEuZ2V0Q2xhc3NOYW1lKF90aGlzLmF0dHJzKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQnV0dG9uR3JvdXA7XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5CdXR0b25Hcm91cCA9IEJ1dHRvbkdyb3VwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19zcHJlYWRBcnJheXMgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xuICAgIHJldHVybiByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdkaXYnLCB7IGh0bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5yb290LmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NOYW1lIH0sIHdtbDoge30gfSwgX19zcHJlYWRBcnJheXMoKF9fY29udGV4dC5jaGlsZHJlbikpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgTWFpbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIE1haW47XG59KCkpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1dHRvbi1ncm91cC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2J1dHRvbi1zZWxlY3RcIik7XG52YXIgc3R5bGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZW50L3N0eWxlXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIF9fMSA9IHJlcXVpcmUoXCIuLi8uLi9cIik7XG52YXIgX18yID0gcmVxdWlyZShcIi4uL1wiKTtcbi8vL2NsYXNzTmFtZTpiZWdpblxuZXhwb3J0cy5CVVRUT05fU0VMRUNUID0gJ3d3LWJ1dHRvbi1zZWxlY3QnO1xuZXhwb3J0cy5CVVRUT05fU0VMRUNUX09QVElPTiA9ICd3dy1idXR0b24tc2VsZWN0X19vcHRpb24nO1xuLyoqXG4gKiBCdXR0b25DaGFuZ2VkRXZlbnRcbiAqL1xudmFyIEJ1dHRvbkNoYW5nZWRFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQnV0dG9uQ2hhbmdlZEV2ZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJ1dHRvbkNoYW5nZWRFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQnV0dG9uQ2hhbmdlZEV2ZW50O1xufShfXzIuRXZlbnQpKTtcbmV4cG9ydHMuQnV0dG9uQ2hhbmdlZEV2ZW50ID0gQnV0dG9uQ2hhbmdlZEV2ZW50O1xuLyoqXG4gKiBCdXR0b25TZWxlY3RcbiAqL1xudmFyIEJ1dHRvblNlbGVjdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQnV0dG9uU2VsZWN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJ1dHRvblNlbGVjdCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgICAgICBpZDogX18xLmdldElkKF90aGlzLmF0dHJzKSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IHV0aWxfMS5jb25jYXQoZXhwb3J0cy5CVVRUT05fU0VMRUNULCBfXzEuZ2V0Q2xhc3NOYW1lKF90aGlzLmF0dHJzKSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBidXR0b25zOiB7XG4gICAgICAgICAgICAgICAgY3VycmVudDogLTEsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm9wdGlvbnMpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cub3B0aW9ucyA6IFtdLFxuICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnZhbHVlcy5idXR0b25zLmN1cnJlbnQgPSBpZHg7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cub25DaGFuZ2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cub25DaGFuZ2UobmV3IEJ1dHRvbkNoYW5nZWRFdmVudChfdGhpcy5hdHRycy53dy5uYW1lLCBfdGhpcy52YWx1ZXMuYnV0dG9ucy5vcHRpb25zW2lkeF0udmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmlldy5pbnZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRTdHlsZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnN0eWxlKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LnN0eWxlIDogc3R5bGVfMS5TdHlsZS5EZWZhdWx0OyB9LFxuICAgICAgICAgICAgICAgIGdldEFjdGl2ZTogZnVuY3Rpb24gKG4pIHsgcmV0dXJuIF90aGlzLnZhbHVlcy5idXR0b25zLmN1cnJlbnQgPT09IG47IH0sXG4gICAgICAgICAgICAgICAgZ2V0Q2xhc3NOYW1lczogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5jb25jYXQoZXhwb3J0cy5CVVRUT05fU0VMRUNUX09QVElPTiwgX3RoaXMudmFsdWVzLmJ1dHRvbnMub3B0aW9uc1tuXS5jbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQnV0dG9uU2VsZWN0O1xufShfXzIuQWJzdHJhY3RDb250cm9sKSk7XG5leHBvcnRzLkJ1dHRvblNlbGVjdCA9IEJ1dHRvblNlbGVjdDtcbi8qKlxuICogTXVsdGlCdXR0b25TZWxlY3RcbiAqL1xudmFyIE11bHRpQnV0dG9uU2VsZWN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNdWx0aUJ1dHRvblNlbGVjdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNdWx0aUJ1dHRvblNlbGVjdCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgICAgICBpZDogX18xLmdldElkKF90aGlzLmF0dHJzKSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IHV0aWxfMS5jb25jYXQoZXhwb3J0cy5CVVRUT05fU0VMRUNULCBfXzEuZ2V0Q2xhc3NOYW1lKF90aGlzLmF0dHJzKSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBidXR0b25zOiB7XG4gICAgICAgICAgICAgICAgdmFsdWVzOiBbXSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cub3B0aW9ucykgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5vcHRpb25zIDogW10sXG4gICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBfdGhpcy52YWx1ZXMuYnV0dG9ucy52YWx1ZXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSB2YWx1ZXMuaW5kZXhPZihuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA+IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnNwbGljZShwb3MsIDEpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm9uQ2hhbmdlKVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cub25DaGFuZ2UobmV3IEJ1dHRvbkNoYW5nZWRFdmVudChfdGhpcy5hdHRycy53dy5uYW1lLCB2YWx1ZXMubWFwKGZ1bmN0aW9uIChuKSB7IHJldHVybiBfdGhpcy52YWx1ZXMuYnV0dG9ucy5vcHRpb25zW25dLnZhbHVlOyB9KSkpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy52aWV3LmludmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldFN0eWxlOiBmdW5jdGlvbiAoKSB7IHJldHVybiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuc3R5bGUpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuc3R5bGUgOiBzdHlsZV8xLlN0eWxlLkRlZmF1bHQ7IH0sXG4gICAgICAgICAgICAgICAgZ2V0QWN0aXZlOiBmdW5jdGlvbiAobikgeyByZXR1cm4gX3RoaXMudmFsdWVzLmJ1dHRvbnMudmFsdWVzLmluZGV4T2YobikgPiAtMTsgfSxcbiAgICAgICAgICAgICAgICBnZXRDbGFzc05hbWVzOiBmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXRpbF8xLmNvbmNhdChleHBvcnRzLkJVVFRPTl9TRUxFQ1RfT1BUSU9OLCBfdGhpcy52YWx1ZXMuYnV0dG9ucy5vcHRpb25zW25dLmNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNdWx0aUJ1dHRvblNlbGVjdDtcbn0oX18yLkFic3RyYWN0Q29udHJvbCkpO1xuZXhwb3J0cy5NdWx0aUJ1dHRvblNlbGVjdCA9IE11bHRpQnV0dG9uU2VsZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19zcHJlYWRBcnJheXMgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xuICAgIHJldHVybiByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBidXR0b25fZ3JvdXBfMSA9IHJlcXVpcmUoXCIuLi8uLi9idXR0b24tZ3JvdXBcIik7XG47XG52YXIgYnV0dG9uXzEgPSByZXF1aXJlKFwiLi4vLi4vYnV0dG9uXCIpO1xuO1xuLy9AdHMtaWdub3JlOiA2MTkyXG52YXIgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19pZiA9IGZ1bmN0aW9uIChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkge1xuICAgIHJldHVybiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCgpO1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JJbiA9IGZ1bmN0aW9uIChsaXN0LCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2Zvck9mID0gZnVuY3Rpb24gKG8sIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYWluKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX190aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChidXR0b25fZ3JvdXBfMS5CdXR0b25Hcm91cCwgeyBodG1sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMucm9vdC5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5yb290LmNsYXNzTmFtZSB9LCB3bWw6IHt9IH0sIF9fc3ByZWFkQXJyYXlzKF9fZm9ySW4oX19jb250ZXh0LnZhbHVlcy5idXR0b25zLm9wdGlvbnMsIGZ1bmN0aW9uIChvcHQsIGlkeCwgXyQkYWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoYnV0dG9uXzEuQnV0dG9uLCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmJ1dHRvbnMuZ2V0Q2xhc3NOYW1lcyhpZHgpLCAnYWN0aXZlJzogX19jb250ZXh0LnZhbHVlcy5idXR0b25zLmdldEFjdGl2ZShpZHgpLCAnc3R5bGUnOiBfX2NvbnRleHQudmFsdWVzLmJ1dHRvbnMuZ2V0U3R5bGUoKSwgJ29uQ2xpY2snOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2NvbnRleHQudmFsdWVzLmJ1dHRvbnMuY2xpY2soaWR4KTsgfSwgJ3RleHQnOiBvcHQudGV4dCB9IH0sIFtdKVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gKFtdKTsgfSkpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgTWFpbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIE1haW47XG59KCkpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1dHRvbi1zZWxlY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9idXR0b25cIik7XG52YXIgdG9vbGJhcl8xID0gcmVxdWlyZShcIi4uL3Rvb2xiYXJcIik7XG52YXIgYWN0aXZlXzEgPSByZXF1aXJlKFwiLi4vLi4vY29udGVudC9zdGF0ZS9hY3RpdmVcIik7XG52YXIgb3JpZW50YXRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZW50L29yaWVudGF0aW9uXCIpO1xudmFyIHN0eWxlXzEgPSByZXF1aXJlKFwiLi4vLi4vY29udGVudC9zdHlsZVwiKTtcbmV4cG9ydHMuU3R5bGUgPSBzdHlsZV8xLlN0eWxlO1xudmFyIHNpemVfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZW50L3NpemVcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgX18xID0gcmVxdWlyZShcIi4uLy4uL1wiKTtcbnZhciBfXzIgPSByZXF1aXJlKFwiLi4vXCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5CVVRUT04gPSAnd3ctYnV0dG9uJztcbjtcbi8qKlxuICogQnV0dG9uQ2xpY2tlZEV2ZW50XG4gKi9cbnZhciBCdXR0b25DbGlja2VkRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJ1dHRvbkNsaWNrZWRFdmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCdXR0b25DbGlja2VkRXZlbnQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEJ1dHRvbkNsaWNrZWRFdmVudDtcbn0oX18yLkV2ZW50KSk7XG5leHBvcnRzLkJ1dHRvbkNsaWNrZWRFdmVudCA9IEJ1dHRvbkNsaWNrZWRFdmVudDtcbi8qKlxuICogQnV0dG9uIGlzIGFuIGltcHJvdmVtZW50IG92ZXIgSFRNTEJ1dHRpb25FbGVtZW50XG4gKi9cbnZhciBCdXR0b24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJ1dHRvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCdXR0b24oKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBidXR0b246IHtcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdidXR0b24nXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpZDogX18xLmdldElkKF90aGlzLmF0dHJzKSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IHV0aWxfMS5jb25jYXQoZXhwb3J0cy5CVVRUT04sIF9fMS5nZXRDbGFzc05hbWUoX3RoaXMuYXR0cnMpLCB0b29sYmFyXzEuVE9PTEJBUl9DT01QQVQsIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5zdHlsZSkgP1xuICAgICAgICAgICAgICAgICAgICBzdHlsZV8xLmdldFN0eWxlQ2xhc3NOYW1lKF90aGlzLmF0dHJzLnd3LnN0eWxlKSA6XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlXzEuREVGQVVMVCwgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnNpemUpID9cbiAgICAgICAgICAgICAgICAgICAgc2l6ZV8xLmdldFNpemVDbGFzc05hbWUoX3RoaXMuYXR0cnMud3cuc2l6ZSkgOiAnJywgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm91dGxpbmUpID9cbiAgICAgICAgICAgICAgICAgICAgc3R5bGVfMS5PVVRMSU5FIDogJycsIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5ibG9jaykgP1xuICAgICAgICAgICAgICAgICAgICBvcmllbnRhdGlvbl8xLkJMT0NLIDogJycsIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5hY3RpdmUpID9cbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlXzEuQUNUSVZFIDogJycpLFxuICAgICAgICAgICAgICAgIHR5cGU6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy50eXBlKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LnR5cGUgOiAnYnV0dG9uJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cubmFtZSkgPyBfdGhpcy5hdHRycy53dy5uYW1lIDogJycsXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5kaXNhYmxlZCkgPyB0cnVlIDogbnVsbCxcbiAgICAgICAgICAgICAgICBvbmNsaWNrOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5hdHRycy53dyAmJlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5vbkNsaWNrICYmXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3Lm9uQ2xpY2sobmV3IEJ1dHRvbkNsaWNrZWRFdmVudCgoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cubmFtZSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cubmFtZSA6ICcnLCBfdGhpcy5hdHRycy53dy52YWx1ZSkpOyB9LFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy50ZXh0KSA/XG4gICAgICAgICAgICAgICAgICAgIFtfXzEudGV4dChfdGhpcy5hdHRycy53dy50ZXh0KV0gOiBfdGhpcy5jaGlsZHJlbjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGRpc2FibGUgdGhpcyBidXR0b24uXG4gICAgICovXG4gICAgQnV0dG9uLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsXzEuZ2V0QnlJZCh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLmJ1dHRvbi53bWwuaWQpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChiKSB7IHJldHVybiBiLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBlbmFibGUgdGhpcyBidXR0b24uXG4gICAgICovXG4gICAgQnV0dG9uLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWxfMS5nZXRCeUlkKHRoaXMudmlldywgdGhpcy52YWx1ZXMuYnV0dG9uLndtbC5pZClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGIucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHRvZ2dsZSB0aGUgZGlzYWJsZWQgc3RhdGUgb2YgdGhpcyBidXR0b24uXG4gICAgICovXG4gICAgQnV0dG9uLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHV0aWxfMS5nZXRCeUlkKHRoaXMudmlldywgdGhpcy52YWx1ZXMuYnV0dG9uLndtbC5pZClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGIuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpID9cbiAgICAgICAgICAgIF90aGlzLmVuYWJsZSgpIDogX3RoaXMuZGlzYWJsZSgpOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBCdXR0b247XG59KF9fMi5BYnN0cmFjdENvbnRyb2wpKTtcbmV4cG9ydHMuQnV0dG9uID0gQnV0dG9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19zcHJlYWRBcnJheXMgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xuICAgIHJldHVybiByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdidXR0b24nLCB7IGh0bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5idXR0b24uaWQsICd0eXBlJzogX19jb250ZXh0LnZhbHVlcy5idXR0b24udHlwZSwgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLmJ1dHRvbi5uYW1lLCAnZGlzYWJsZWQnOiBfX2NvbnRleHQudmFsdWVzLmJ1dHRvbi5kaXNhYmxlZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5idXR0b24uY2xhc3NOYW1lLCAnb25jbGljayc6IF9fY29udGV4dC52YWx1ZXMuYnV0dG9uLm9uY2xpY2sgfSwgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuYnV0dG9uLndtbC5pZCB9IH0sIF9fc3ByZWFkQXJyYXlzKChfX2NvbnRleHQudmFsdWVzLmJ1dHRvbi5jb250ZW50KCkpKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idXR0b24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjaGVja2JveF8xID0gcmVxdWlyZShcIi4vd21sL2NoZWNrYm94XCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIF9fMSA9IHJlcXVpcmUoXCIuLi9cIik7XG52YXIgX18yID0gcmVxdWlyZShcIi4uLy4uL1wiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuQ0hFQ0tCT1ggPSAnd3ctY2hlY2tib3gnO1xuLyoqXG4gKiBDaGVja0NoYW5nZWRFdmVudCBzaWduYWxzIHRoZSB1c2VyIGhhcyBjaGFuZ2VkIHRoZSBjaGVja2JveCBzdGF0ZS5cbiAqL1xudmFyIENoZWNrQ2hhbmdlZEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDaGVja0NoYW5nZWRFdmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDaGVja0NoYW5nZWRFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ2hlY2tDaGFuZ2VkRXZlbnQ7XG59KF9fMS5FdmVudCkpO1xuZXhwb3J0cy5DaGVja0NoYW5nZWRFdmVudCA9IENoZWNrQ2hhbmdlZEV2ZW50O1xuLyoqXG4gKiBDaGVja2JveCBjb250cm9sLlxuICpcbiAqIFRoaXMgaXMgYW4gYWx0ZXJuYXRpdmUgdG8gdGhlIG5hdGl2ZSBjaGVja2JveCB0aGF0IGNhbiBiZSBzdHlsZWQuXG4gKi9cbnZhciBDaGVja2JveCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2hlY2tib3gsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2hlY2tib3goKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IGNoZWNrYm94XzEuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgICAgICBpZDogX18yLmdldElkKF90aGlzLmF0dHJzKSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IHV0aWxfMS5jb25jYXQoZXhwb3J0cy5DSEVDS0JPWCwgX18yLmdldENsYXNzTmFtZShfdGhpcy5hdHRycykpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5wdXQ6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBfXzEuZ2V0TmFtZShfdGhpcy5hdHRycyksXG4gICAgICAgICAgICAgICAgdmFsdWU6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy52YWx1ZSkgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy52YWx1ZSA6IG51bGwsXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmFsdWVzLmlucHV0LnZhbHVlID0gKCFfdGhpcy52YWx1ZXMuaW5wdXQudmFsdWUpIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5vbkNoYW5nZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3Lm9uQ2hhbmdlKG5ldyBDaGVja0NoYW5nZWRFdmVudChfdGhpcy52YWx1ZXMuaW5wdXQubmFtZSwgX3RoaXMudmFsdWVzLmlucHV0LnZhbHVlIHx8IGZhbHNlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDaGVja2JveDtcbn0oX18xLkFic3RyYWN0Q29udHJvbCkpO1xuZXhwb3J0cy5DaGVja2JveCA9IENoZWNrYm94O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19zcHJlYWRBcnJheXMgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xuICAgIHJldHVybiByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdkaXYnLCB7IGh0bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5yb290LmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NOYW1lIH0sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdsYWJlbCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgX19zcHJlYWRBcnJheXMoW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaW5wdXQnLCB7IGh0bWw6IHsgJ3R5cGUnOiBcImNoZWNrYm94XCIsICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5pbnB1dC5uYW1lLCAnY2hlY2tlZCc6IF9fY29udGV4dC52YWx1ZXMuaW5wdXQudmFsdWUsICdvbmNoYW5nZSc6IF9fY29udGV4dC52YWx1ZXMuaW5wdXQub25DaGFuZ2UgfSwgd21sOiB7fSB9LCBbXSlcbiAgICAgICAgICAgICAgICBdLCAoX19jb250ZXh0LmNoaWxkcmVuKSkpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgTWFpbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIE1haW47XG59KCkpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNrYm94LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBfXzEgPSByZXF1aXJlKFwiLi4vLi4vXCIpO1xudmFyIGNsb3NlX2J1dHRvbl8xID0gcmVxdWlyZShcIi4vd21sL2Nsb3NlLWJ1dHRvblwiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuQ0xPU0VfQlVUVE9OID0gJ3d3LWNsb3NlLWJ1dHRvbic7XG47XG4vKipcbiAqIENsb3NlQnV0dG9uIHVzZWQgdG8gZGlzcGxheSB0aGUgXCJ4XCIgb24gZGlhbG9ncyBldGMuXG4gKi9cbnZhciBDbG9zZUJ1dHRvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2xvc2VCdXR0b24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2xvc2VCdXR0b24oKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IGNsb3NlX2J1dHRvbl8xLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBpZDogX18xLmdldElkKF90aGlzLmF0dHJzKSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogdXRpbF8xLmNvbmNhdChleHBvcnRzLkNMT1NFX0JVVFRPTiwgX18xLmdldENsYXNzTmFtZShfdGhpcy5hdHRycykpLFxuICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdjbG9zZS1idXR0b24nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25jbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5vbkNsaWNrKVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5vbkNsaWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENsb3NlQnV0dG9uO1xufSh3bWxfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuQ2xvc2VCdXR0b24gPSBDbG9zZUJ1dHRvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNsb3NlXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY29udGVudC9jbG9zZVwiKTtcbjtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdidXR0b24nLCB7IGh0bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jbGFzc05hbWUsICdvbmNsaWNrJzogX19jb250ZXh0LnZhbHVlcy5vbmNsaWNrIH0sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoY2xvc2VfMS5DbG9zZSwgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBNYWluLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gTWFpbjtcbn0oKSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xvc2UtYnV0dG9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvZGF0ZS1maWVsZFwiKTtcbnZhciBtb21lbnQgPSByZXF1aXJlKFwibW9tZW50XCIpO1xudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgZmVlZGJhY2tfMSA9IHJlcXVpcmUoXCIuLi9mZWVkYmFja1wiKTtcbnZhciBmb3JtXzEgPSByZXF1aXJlKFwiLi4vZm9ybVwiKTtcbnZhciBfXzEgPSByZXF1aXJlKFwiLi4vLi4vXCIpO1xudmFyIF9fMiA9IHJlcXVpcmUoXCIuLi9cIik7XG52YXIgb3JpZW50YXRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZW50L29yaWVudGF0aW9uXCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5EQVRFX0ZJRUxEID0gJ3d3LWRhdGUtZmllbGQnO1xuZXhwb3J0cy5EQVRFX0ZJRUxEX0lOUFVUID0gJ3d3LWRhdGUtZmllbGRfX2lucHV0Jztcbi8vL2NsYXNzTmFtZXM6ZW5kXG5leHBvcnRzLkRFRkFVTFRfSU5QVVRfRk9STUFUID0gbW9tZW50LklTT184NjAxO1xuZXhwb3J0cy5ERUZBVUxUX0lOUFVUX1BMQUNFSE9MREVSID0gJ1lZWVktTU0tREQnO1xuZXhwb3J0cy5ERUZBVUxUX0lOUFVUX0RJU1BMQVkgPSAnWVlZWS1NTS1ERCc7XG5leHBvcnRzLlZBTFVFX0ZPUk1BVCA9ICdZWVlZLU1NLUREJztcbmV4cG9ydHMuREVMQVkgPSAyMDA7XG5leHBvcnRzLlRPREFZID0gJ3RvZGF5JztcbmV4cG9ydHMuTk9XID0gJ25vdyc7XG5leHBvcnRzLllFU1RFUkRBWSA9ICd5ZXN0ZXJkYXknO1xuZXhwb3J0cy5pc284NjAxRm9ybWF0cyA9IFtcbiAgICAnWVlZWS1NTS1ERCcsXG4gICAgJ1lZWVktTU0tRCcsXG4gICAgJ1lZWVktTS1ERCcsXG4gICAgJ1lZWVktTS1EJyxcbiAgICAnWVktTU0tREQnLFxuICAgICdZWS1NTS1EJyxcbiAgICAnWVktTS1ERCcsXG4gICAgJ1lZLU0tRCcsXG4gICAgJ1lZWVkvTU0vREQnLFxuICAgICdZWVlZL01NL0QnLFxuICAgICdZWVlZL00vREQnLFxuICAgICdZWVlZL00vRCcsXG4gICAgJ1lZL01NL0REJyxcbiAgICAnWVkvTU0vRCcsXG4gICAgJ1lZL00vREQnLFxuICAgICdZWS9NL0QnLFxuICAgICdZWVlZIE1NIEREJyxcbiAgICAnWVlZWSBNTSBEJyxcbiAgICAnWVlZWSBNIEREJyxcbiAgICAnWVlZWSBNIEQnLFxuICAgICdZWSBNTSBERCcsXG4gICAgJ1lZIE1NIEQnLFxuICAgICdZWSBNIEREJyxcbiAgICAnWVkgTSBEJyxcbiAgICAnWVlZWU1NREQnLFxuICAgICdZWVlZTU1EJyxcbiAgICAnWVlZWU1ERCcsXG4gICAgJ1lZWVlNRCcsXG4gICAgJ1lZTU1ERCcsXG4gICAgJ1lZTU1EJyxcbiAgICAnWVlNREQnLFxuICAgICdZWU1EJyxcbl07XG5leHBvcnRzLmNvbW1vbkZvcm1hdHMgPSBbXG4gICAgJ0RELU1NLVlZWVknLFxuICAgICdELU1NLVlZWVknLFxuICAgICdERC1NLVlZWVknLFxuICAgICdELU0tWVlZWScsXG4gICAgJ0RELU1NLVlZJyxcbiAgICAnRC1NTS1ZWScsXG4gICAgJ0RELU0tWVknLFxuICAgICdELU0tWVknLFxuICAgICdERC9NTS9ZWVlZJyxcbiAgICAnRC9NTS9ZWVlZJyxcbiAgICAnREQvTS9ZWVlZJyxcbiAgICAnRC9NL1lZWVknLFxuICAgICdERC9NTS9ZWScsXG4gICAgJ0QvTU0vWVknLFxuICAgICdERC9NL1lZJyxcbiAgICAnRC9NL1lZJyxcbiAgICAnREQgTU0gWVlZWScsXG4gICAgJ0QgTU0gWVlZWScsXG4gICAgJ0REIE0gWVlZWScsXG4gICAgJ0QgTSBZWVlZJyxcbiAgICAnREQgTU0gWVknLFxuICAgICdEIE1NIFlZJyxcbiAgICAnREQgTSBZWScsXG4gICAgJ0QgTSBZWScsXG4gICAgJ0RETU1ZWVlZJyxcbiAgICAnRE1NWVlZWScsXG4gICAgJ0RETVlZWVknLFxuICAgICdETVlZWVknLFxuICAgICdERE1NWVknLFxuICAgICdETU1ZWScsXG4gICAgJ0RETVlZJyxcbiAgICAnRE1ZWScsXG5dO1xuZXhwb3J0cy51c0Zvcm1hdHMgPSBbXG4gICAgJ01NLURELVlZWVknLFxuICAgICdNTS1ELVlZWVknLFxuICAgICdNLURELVlZWVknLFxuICAgICdNLUQtWVlZWScsXG4gICAgJ01NLURELVlZJyxcbiAgICAnTU0tRC1ZWScsXG4gICAgJ00tREQtWVknLFxuICAgICdNLUQtWVknLFxuICAgICdNTS9ERC9ZWVlZJyxcbiAgICAnTU0vRC9ZWVlZJyxcbiAgICAnTS9ERC9ZWVlZJyxcbiAgICAnTS9EL1lZWVknLFxuICAgICdNTS9ERC9ZWScsXG4gICAgJ01NL0QvWVknLFxuICAgICdNL0REL1lZJyxcbiAgICAnTS9EL1lZJyxcbiAgICAnTU0gREQgWVlZWScsXG4gICAgJ01NIEQgWVlZWScsXG4gICAgJ00gREQgWVlZWScsXG4gICAgJ00gRCBZWVlZJyxcbiAgICAnTU0gREQgWVknLFxuICAgICdNTSBEIFlZJyxcbiAgICAnTSBERCBZWScsXG4gICAgJ00gRCBZWScsXG4gICAgJ01NRERZWVlZJyxcbiAgICAnTU1EWVlZWScsXG4gICAgJ01ERFlZWVknLFxuICAgICdNRFlZWVknLFxuICAgICdNTUREWVknLFxuICAgICdNTURZWScsXG4gICAgJ01ERFlZJyxcbiAgICAnTURZWScsXG5dO1xuLyoqXG4gKiBGb3JtYXQgaXMgdXNlZCB0byBkZXRlcm1pbmUgd2hhdCBmb3JtYXQgaW5wdXQgc2hvdWxkIGJlIHBhcnNlZCBhcy5cbiAqL1xudmFyIEZvcm1hdDtcbihmdW5jdGlvbiAoRm9ybWF0KSB7XG4gICAgRm9ybWF0W0Zvcm1hdFtcIklTTzg2MDFcIl0gPSAxXSA9IFwiSVNPODYwMVwiO1xuICAgIEZvcm1hdFtGb3JtYXRbXCJDT01NT05cIl0gPSAyXSA9IFwiQ09NTU9OXCI7XG4gICAgRm9ybWF0W0Zvcm1hdFtcIlVTQVwiXSA9IDNdID0gXCJVU0FcIjtcbn0pKEZvcm1hdCA9IGV4cG9ydHMuRm9ybWF0IHx8IChleHBvcnRzLkZvcm1hdCA9IHt9KSk7XG4vKipcbiAqIERhdGVDaGFuZ2VkRXZlbnQgaXMgZ2VuZXJhdGVkIHdoZW4gYSB2YWxpZCBkYXRlIGhhcyBiZWVuIGVudGVyZWQuXG4gKlxuICogVGhlIHZhbHVlIGlzIGEgdHJ1bmNhdGVkIElTTzg2MDEgc3RyaW5nIGNvbnNpc3Rpbmcgb2YgdGhlIGRhdGUgcGFydCBhbG9uZS5cbiAqL1xudmFyIERhdGVDaGFuZ2VkRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERhdGVDaGFuZ2VkRXZlbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGF0ZUNoYW5nZWRFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gRGF0ZUNoYW5nZWRFdmVudDtcbn0oX18yLkV2ZW50KSk7XG5leHBvcnRzLkRhdGVDaGFuZ2VkRXZlbnQgPSBEYXRlQ2hhbmdlZEV2ZW50O1xuLyoqXG4gKiBEYXRlRmllbGQgcHJvdmlkZXMgYSB0ZXh0IGZpZWxkIGZvciBlbnRlcmluZyBkYXRlcy5cbiAqXG4gKiBJdCB3aWxsIG9ubHkgZmlyZSBjaGFuZ2UgZXZlbnRzIHdoZW4gdGhlIGRhdGUgaW5wdXQgbWF0Y2hlcyBvbmVcbiAqIG9mIHRoZSAzIGZvcm1hdCBzZXRzIChJU084NjAxLENvbW1vbixVUykuXG4gKlxuICogSWYgdGhlIHVzZXIgcmVtb3ZlcyBmb2N1cyBhbmQgdGhlIGVudHJ5IGlzIG5vdCB2YWxpZCwgaXQgd2lsbCBiZSBpZ25vcmVkXG4gKiBhbmQgbm8gY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQuIE9uY2UgYSB2YWxpZCBkYXRlIGhhcyBiZWVuIGVudGVyZWQsXG4gKiB0aGUgdmFsdWUgZGlzcGxheWVkIGNhbiBiZSBmb3JtYXRlZCB1c2luZyB0aGUgZm9ybWF0IHNwZWNpZmllZCBpbiB0aGVcbiAqIFwiZGlzcGxheVwiIGF0dHJpYnV0ZS4gVGhpcyBkb2VzIG5vdCBhZmZlY3QgdGhlIGFjdHVhbCB2YWx1ZSBwcm92aWRlZFxuICogdG8gb25DaGFuZ2UgaGFuZGxlcnMuXG4gKi9cbnZhciBEYXRlRmllbGQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERhdGVGaWVsZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEYXRlRmllbGQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgd21sOiB7IGlkOiAncm9vdCcgfSxcbiAgICAgICAgICAgICAgICBpZDogX18xLmdldElkKF90aGlzLmF0dHJzKSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IHV0aWxfMS5jb25jYXQoZXhwb3J0cy5EQVRFX0ZJRUxELCBfXzEuZ2V0Q2xhc3NOYW1lKF90aGlzLmF0dHJzKSwgb3JpZW50YXRpb25fMS5nZXRCbG9ja0NsYXNzTmFtZShfdGhpcy5hdHRycyksIGZlZWRiYWNrXzEuZ2V0VmFsaWRpdHlDbGFzc05hbWUoX3RoaXMuYXR0cnMpKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250cm9sOiB7XG4gICAgICAgICAgICAgICAgd21sOiB7IGlkOiAnaW5wdXQnIH0sXG4gICAgICAgICAgICAgICAgaWQ6IF9fMS5nZXRJZChfdGhpcy5hdHRycylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgICAgIGlkOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cubmFtZSkgfHwgJycsXG4gICAgICAgICAgICAgICAgdGV4dDogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmxhYmVsKSB8fCAnJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAnbWVzc2FnZXMnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBmZWVkYmFja18xLmdldE1lc3NhZ2UoX3RoaXMuYXR0cnMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5wdXQ6IHtcbiAgICAgICAgICAgICAgICB3bWw6IHsgaWQ6ICdpbnB1dCcgfSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGV4cG9ydHMuREFURV9GSUVMRF9JTlBVVCxcbiAgICAgICAgICAgICAgICBuYW1lOiBfXzIuZ2V0TmFtZShfdGhpcy5hdHRycyksXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBnZXRGb3JtYXQoX3RoaXMuYXR0cnMpLFxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBnZXRQbGFjZWhvbGRlcihfdGhpcy5hdHRycyksXG4gICAgICAgICAgICAgICAgZGlzcGxheTogZ2V0RGlzcGxheShfdGhpcy5hdHRycyksXG4gICAgICAgICAgICAgICAgbW9tZW50OiAoKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnZhbHVlKSA/XG4gICAgICAgICAgICAgICAgICAgIG1heWJlXzEuanVzdChwYXJzZURhdGUoZ2V0VmFsdWUoX3RoaXMuYXR0cnMpLCBnZXRGb3JtYXQoX3RoaXMuYXR0cnMpKSkgOlxuICAgICAgICAgICAgICAgICAgICBtYXliZV8xLm5vdGhpbmcoKSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIChfdGhpcy52YWx1ZXMuaW5wdXQubW9tZW50LmlzSnVzdCgpICYmXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnZhbHVlcy5pbnB1dC5tb21lbnQuZ2V0KCkuaXNWYWxpZCgpKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnZhbHVlcy5pbnB1dC5tb21lbnQuZ2V0KCkuZm9ybWF0KF90aGlzLnZhbHVlcy5pbnB1dC5kaXNwbGF5KSA6ICcnOyB9LFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuZGlzYWJsZWQgPT09IHRydWUpID9cbiAgICAgICAgICAgICAgICAgICAgdHJ1ZSA6IG51bGwsXG4gICAgICAgICAgICAgICAgb25mb2N1czogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS50YXJnZXQuc2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbmlucHV0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnRhcmdldC5vbmlucHV0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmFsdWVzLmlucHV0Lm9ua2V5dXAoZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbmtleXVwOiB1dGlsXzEuZGVib3VuY2UoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZS50YXJnZXQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtID0gcGFyc2VEYXRlKHZhbHVlLCBfdGhpcy52YWx1ZXMuaW5wdXQuZm9ybWF0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG0uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZXMuaW5wdXQubW9tZW50ID0gbWF5YmVfMS5qdXN0KG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZmlyZUNoYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgZXhwb3J0cy5ERUxBWSksXG4gICAgICAgICAgICAgICAgb25ibHVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnZpZXcuaW52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIERhdGVGaWVsZC5wcm90b3R5cGUuZmlyZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVzLmlucHV0Lm1vbWVudC5pc0p1c3QoKSkge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGlzLnZhbHVlcy5pbnB1dC5tb21lbnQuZ2V0KCk7XG4gICAgICAgICAgICBpZiAobS5pc1ZhbGlkKCkgJiYgKHRoaXMuYXR0cnMud3cgJiYgdGhpcy5hdHRycy53dy5vbkNoYW5nZSkpXG4gICAgICAgICAgICAgICAgdGhpcy5hdHRycy53dy5vbkNoYW5nZShuZXcgRGF0ZUNoYW5nZWRFdmVudCh0aGlzLmF0dHJzLnd3Lm5hbWUgfHwgJycsIG0uZm9ybWF0KGV4cG9ydHMuVkFMVUVfRk9STUFUKSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEYXRlRmllbGQucHJvdG90eXBlLnNldE1lc3NhZ2UgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHRoaXMudmFsdWVzLm1lc3NhZ2VzLnRleHQgPSBtc2c7XG4gICAgICAgIGZvcm1fMS5zZXRNZXNzYWdlKHRoaXMudmlldywgdGhpcy52YWx1ZXMubWVzc2FnZXMud21sLmlkLCBtc2cpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIERhdGVGaWVsZC5wcm90b3R5cGUucmVtb3ZlTWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy52YWx1ZXMubWVzc2FnZXMudGV4dCA9ICcnO1xuICAgICAgICBmb3JtXzEucmVtb3ZlTWVzc2FnZSh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLm1lc3NhZ2VzLndtbC5pZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIERhdGVGaWVsZDtcbn0oZm9ybV8xLkFic3RyYWN0Rm9ybUNvbnRyb2wpKTtcbmV4cG9ydHMuRGF0ZUZpZWxkID0gRGF0ZUZpZWxkO1xudmFyIHBhcnNlRGF0ZSA9IGZ1bmN0aW9uIChkLCBmb3JtYXRzKSB7XG4gICAgdmFyIHN0ciA9IGQudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoKHN0ciA9PT0gZXhwb3J0cy5UT0RBWSkgfHwgKHN0ciA9PT0gZXhwb3J0cy5OT1cpKSB7XG4gICAgICAgIHJldHVybiBtb21lbnQudXRjKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0ciA9PT0gZXhwb3J0cy5ZRVNURVJEQVkpIHtcbiAgICAgICAgcmV0dXJuIG1vbWVudC51dGMoKS5zdWJ0cmFjdCgxLCAnZCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG1vbWVudC51dGMoZCwgZm9ybWF0cywgdHJ1ZSk7XG4gICAgfVxufTtcbnZhciBnZXRWYWx1ZSA9IGZ1bmN0aW9uIChhdHRycykge1xuICAgIHJldHVybiAoYXR0cnMud3cgJiYgYXR0cnMud3cudmFsdWUpID8gYXR0cnMud3cudmFsdWUgOiAnJztcbn07XG52YXIgZ2V0Rm9ybWF0ID0gZnVuY3Rpb24gKGF0dHJzKSB7XG4gICAgaWYgKGF0dHJzLnd3ICYmIGF0dHJzLnd3LmZvcm1hdCkge1xuICAgICAgICBzd2l0Y2ggKGF0dHJzLnd3LmZvcm1hdCkge1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBleHBvcnRzLmNvbW1vbkZvcm1hdHM7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMudXNGb3JtYXRzO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXhwb3J0cy5pc284NjAxRm9ybWF0cztcbn07XG52YXIgZ2V0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAoYXR0cnMpIHtcbiAgICBpZiAoYXR0cnMud3cgJiYgYXR0cnMud3cucGxhY2Vob2xkZXIpXG4gICAgICAgIHJldHVybiBhdHRycy53dy5wbGFjZWhvbGRlcjtcbiAgICBpZiAoYXR0cnMud3cgJiYgYXR0cnMud3cuZm9ybWF0KSB7XG4gICAgICAgIHN3aXRjaCAoYXR0cnMud3cuZm9ybWF0KSB7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdERC1NTS1ZWVlZJztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ01NLURELVlZWVknO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1lZWVktTU0tREQnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnJztcbn07XG52YXIgZ2V0RGlzcGxheSA9IGZ1bmN0aW9uIChhdHRycykge1xuICAgIHJldHVybiAoYXR0cnMud3cgJiYgYXR0cnMud3cuZGlzcGxheSkgPyBhdHRycy53dy5kaXNwbGF5IDogZXhwb3J0cy5ERUZBVUxUX0lOUFVUX0RJU1BMQVk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbGFiZWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9sYWJlbFwiKTtcbjtcbnZhciBoZWxwXzEgPSByZXF1aXJlKFwiLi4vLi4vaGVscFwiKTtcbjtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdkaXYnLCB7IGh0bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5yb290LmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NOYW1lIH0sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobGFiZWxfMS5MYWJlbCwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ2Zvcic6IF9fY29udGV4dC52YWx1ZXMucm9vdC5pZCwgJ3RleHQnOiBfX2NvbnRleHQudmFsdWVzLmxhYmVsLnRleHQgfSB9LCBbXSksXG4gICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2lucHV0JywgeyBodG1sOiB7ICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5pbnB1dC53bWwuaWQsICdvbmZvY3VzJzogX19jb250ZXh0LnZhbHVlcy5pbnB1dC5vbmZvY3VzLCAnb25pbnB1dCc6IF9fY29udGV4dC52YWx1ZXMuaW5wdXQub25pbnB1dCwgJ29ua2V5dXAnOiBfX2NvbnRleHQudmFsdWVzLmlucHV0Lm9ua2V5dXAsICdvbmJsdXInOiBfX2NvbnRleHQudmFsdWVzLmlucHV0Lm9uYmx1ciwgJ3ZhbHVlJzogX19jb250ZXh0LnZhbHVlcy5pbnB1dC52YWx1ZSgpLCAnZGlzYWJsZWQnOiBfX2NvbnRleHQudmFsdWVzLmlucHV0LmRpc2FibGVkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmlucHV0LmNsYXNzTmFtZSwgJ3BsYWNlaG9sZGVyJzogX19jb250ZXh0LnZhbHVlcy5pbnB1dC5wbGFjZWhvbGRlciB9LCB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pbnB1dC53bWwuaWQgfSB9LCBbXSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChoZWxwXzEuSGVscCwgeyBodG1sOiB7fSwgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMubWVzc2FnZXMud21sLmlkIH0sIHd3OiB7ICd0ZXh0JzogX19jb250ZXh0LnZhbHVlcy5tZXNzYWdlcy50ZXh0IH0gfSwgW10pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgTWFpbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIE1haW47XG59KCkpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGUtZmllbGQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIHRvb2xiYXJfMSA9IHJlcXVpcmUoXCIuLi90b29sYmFyXCIpO1xudmFyIG9yaWVudGF0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vY29udGVudC9vcmllbnRhdGlvblwiKTtcbnZhciBzdHlsZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRlbnQvc3R5bGVcIik7XG5leHBvcnRzLlN0eWxlID0gc3R5bGVfMS5TdHlsZTtcbnZhciBzaXplXzEgPSByZXF1aXJlKFwiLi4vLi4vY29udGVudC9zaXplXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIF9fMSA9IHJlcXVpcmUoXCIuLi8uLi9cIik7XG52YXIgZGlzcGxheV9maWVsZF8xID0gcmVxdWlyZShcIi4vd21sL2Rpc3BsYXktZmllbGRcIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLkRJU1BMQVlfRklFTEQgPSAnd3ctZGlzcGxheS1maWVsZCc7XG5leHBvcnRzLkRJU1BMQVlfRklFTERfQ09OVEVOVCA9ICd3dy1kaXNwbGF5LWZpZWxkX19jb250ZW50Jztcbjtcbi8qKlxuICogRGlzcGxheUZpZWxkIGlzIHVzZWQgdG8gZGlzcGxheSBhIHZhbHVlIGluIGEgdGV4dCBmaWVsZCBsaWtlIGJveC5cbiAqL1xudmFyIERpc3BsYXlGaWVsZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGlzcGxheUZpZWxkLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERpc3BsYXlGaWVsZCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgZGlzcGxheV9maWVsZF8xLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICBpZDogJ2Rpc3BsYXknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWQ6IF9fMS5nZXRJZChfdGhpcy5hdHRycyksXG4gICAgICAgICAgICBjbGFzc05hbWU6IHV0aWxfMS5jb25jYXQoZXhwb3J0cy5ESVNQTEFZX0ZJRUxELCBfXzEuZ2V0Q2xhc3NOYW1lKF90aGlzLmF0dHJzKSwgdG9vbGJhcl8xLlRPT0xCQVJfQ09NUEFULCAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuc3R5bGUpID9cbiAgICAgICAgICAgICAgICBzdHlsZV8xLmdldFN0eWxlQ2xhc3NOYW1lKF90aGlzLmF0dHJzLnd3LnN0eWxlKSA6XG4gICAgICAgICAgICAgICAgc3R5bGVfMS5ERUZBVUxULCAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuc2l6ZSkgP1xuICAgICAgICAgICAgICAgIHNpemVfMS5nZXRTaXplQ2xhc3NOYW1lKF90aGlzLmF0dHJzLnd3LnNpemUpIDogJycsIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5ibG9jaykgP1xuICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uXzEuQkxPQ0sgOiAnJyksXG4gICAgICAgICAgICBvbmNsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7IC8vcHJldmVudCBhIGJ1ZyB3aGVuIHVzZWQgd2l0aCBSZXN1bHRzTWVudVxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5vbkNsaWNrKVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5vbkNsaWNrKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogZXhwb3J0cy5ESVNQTEFZX0ZJRUxEX0NPTlRFTlRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gRGlzcGxheUZpZWxkO1xufSh3bWxfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuRGlzcGxheUZpZWxkID0gRGlzcGxheUZpZWxkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19zcHJlYWRBcnJheXMgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xuICAgIHJldHVybiByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdkaXYnLCB7IGh0bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jbGFzc05hbWUsICdvbmNsaWNrJzogX19jb250ZXh0LnZhbHVlcy5vbmNsaWNrIH0sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdkaXYnLCB7IGh0bWw6IHsgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jb250ZW50LmNsYXNzTmFtZSB9LCB3bWw6IHt9IH0sIF9fc3ByZWFkQXJyYXlzKChfX2NvbnRleHQuY2hpbGRyZW4pKSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBNYWluLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gTWFpbjtcbn0oKSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlzcGxheS1maWVsZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2Ryb3AtZG93blwiKTtcbnZhciBoaWRkZW4gPSByZXF1aXJlKFwiLi4vLi4vY29udGVudC9zdGF0ZS9oaWRkZW5cIik7XG52YXIgc3R5bGUgPSByZXF1aXJlKFwiLi4vLi4vY29udGVudC9zdHlsZVwiKTtcbnZhciB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIHN0eWxlXzEgPSByZXF1aXJlKFwiLi4vLi4vY29udGVudC9zdHlsZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBfXzEgPSByZXF1aXJlKFwiLi4vLi4vXCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5EUk9QX0RPV04gPSAnd3ctZHJvcC1kb3duLW1lbnUnO1xuZXhwb3J0cy5EUk9QX0RPV05fVE9HR0xFID0gJ3d3LWRyb3AtZG93bi1tZW51X190b2dnbGUnO1xuZXhwb3J0cy5EUk9QX0RPV05fQ09OVEVOVCA9ICd3dy1kcm9wLWRvd25fX2NvbnRlbnQnO1xuLyoqXG4gKiBEcm9wRG93biBwcm92aWRlcyBhIGNvbXBvbmVudCBmb3IgZGlzcGxheWluZyBhIHBvcCB1cCBtZW51LlxuICpcbiAqXG4gKiAgICArLS0tLS0tLS0rXG4gKiAgICB8ICBNZW51ICB8XG4gKiAgICArLS0tLS0tLS0rXG4gKiAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAqICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogICAgfCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8XG4gKiAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgIHwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfFxuICogICAgfCAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgICB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHxcbiAqICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gKi9cbnZhciBEcm9wRG93biA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRHJvcERvd24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRHJvcERvd24oKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAncm9vdCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlkOiBfXzEuZ2V0SWQoX3RoaXMuYXR0cnMpLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogdXRpbF8xLmNvbmNhdChleHBvcnRzLkRST1BfRE9XTiwgX18xLmdldENsYXNzTmFtZShfdGhpcy5hdHRycykpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYnV0dG9uOiB7XG4gICAgICAgICAgICAgICAgdGV4dDogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmJ1dHRvblRleHQpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuYnV0dG9uVGV4dCA6ICcnLFxuICAgICAgICAgICAgICAgIHN0eWxlOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuYnV0dG9uU3R5bGUpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuYnV0dG9uU3R5bGUgOiBzdHlsZV8xLlN0eWxlLkRlZmF1bHQsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiB1dGlsXzEuY29uY2F0KGV4cG9ydHMuRFJPUF9ET1dOX1RPR0dMRSwgc3R5bGUuREVGQVVMVCwgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmJ1dHRvbkNsYXNzTmFtZSkgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5idXR0b25DbGFzc05hbWUgOiAnJyksXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5idXR0b25UZW1wbGF0ZSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuYnV0dG9uVGVtcGxhdGUgOiB2aWV3cy5idXR0b247XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXlSb290ID0gdXRpbF8xLmdldEJ5SWQoX3RoaXMudmlldywgX3RoaXMudmFsdWVzLnJvb3Qud21sLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heVJvb3QuaXNKdXN0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gbWF5Um9vdC5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy52YWx1ZXMuY29udGVudC5hdXRvQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGlkZSA9IF90aGlzLnZhbHVlcy5jb250ZW50LmhpZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pbnRlcmNlcHQgY2xpY2tzIG9uIGJ1dHRvbiBhbmQgY29udGVudCBzZWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgZG91YmxpbmcgdXAgaGFuZGxlcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuY2hpbGRyZW5baV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhpZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmNoaWxkcmVuW2ldLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGlkZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudG9nZ2xlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ2NvbnRlbnQnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IHV0aWxfMS5jb25jYXQoZXhwb3J0cy5EUk9QX0RPV05fQ09OVEVOVCwgaGlkZGVuLkhJRERFTiksXG4gICAgICAgICAgICAgICAgYXV0b0Nsb3NlOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuYXV0b0Nsb3NlID09PSBmYWxzZSkgP1xuICAgICAgICAgICAgICAgICAgICBmYWxzZSA6IHRydWUsXG4gICAgICAgICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jaGlsZHJlbjsgfSxcbiAgICAgICAgICAgICAgICBoaWRlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5oaWRlKCk7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEcm9wRG93bi5wcm90b3R5cGUuaXNIaWRkZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBoaWRkZW4uaXNIaWRkZW4odGhpcy52aWV3LCB0aGlzLnZhbHVlcy5jb250ZW50LndtbC5pZCk7XG4gICAgfTtcbiAgICBEcm9wRG93bi5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaGlkZGVuLmhpZGUodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5jb250ZW50LndtbC5pZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgRHJvcERvd24ucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGhpZGRlbi5zaG93KHRoaXMudmlldywgdGhpcy52YWx1ZXMuY29udGVudC53bWwuaWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIERyb3BEb3duLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGhpZGRlbi50b2dnbGUodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5jb250ZW50LndtbC5pZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgRHJvcERvd24ucHJvdG90eXBlLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdXRpbF8xLmdldEJ5SWQodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5yb290LndtbC5pZClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgICAgICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyhyb290KSlcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIF90aGlzKTtcbiAgICAgICAgICAgIGlmICgoIXJvb3QuY29udGFpbnMoZS50YXJnZXQpKSlcbiAgICAgICAgICAgICAgICBfdGhpcy5oaWRlKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIERyb3BEb3duO1xufSh3bWxfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuRHJvcERvd24gPSBEcm9wRG93bjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fc3ByZWFkQXJyYXlzID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5cykgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcbiAgICByZXR1cm4gcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYnV0dG9uXzEgPSByZXF1aXJlKFwiLi4vLi4vYnV0dG9uXCIpO1xuO1xudmFyIGNhcmV0XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY29udGVudC9jYXJldFwiKTtcbjtcbnZhciBfXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vXCIpO1xuO1xuLy9AdHMtaWdub3JlOiA2MTkyXG52YXIgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19pZiA9IGZ1bmN0aW9uIChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkge1xuICAgIHJldHVybiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCgpO1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JJbiA9IGZ1bmN0aW9uIChsaXN0LCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2Zvck9mID0gZnVuY3Rpb24gKG8sIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG5leHBvcnRzLmJ1dHRvbiA9IGZ1bmN0aW9uIChkKSB7IHJldHVybiBmdW5jdGlvbiAoX190aGlzKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgX190aGlzLndpZGdldChidXR0b25fMS5CdXR0b24sIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdjbGFzcyc6IGQudmFsdWVzLmJ1dHRvbi5jbGFzc05hbWUsICdzdHlsZSc6IGQudmFsdWVzLmJ1dHRvbi5zdHlsZSwgJ29uQ2xpY2snOiBkLnZhbHVlcy5idXR0b24ub25DbGljayB9IH0sIFtcbiAgICAgICAgICAgIF9fMS50ZXh0KChkLnZhbHVlcy5idXR0b24udGV4dCArIFwiIFwiKSksXG4gICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGNhcmV0XzEuQ2FyZXQsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW10pXG4gICAgICAgIF0pXG4gICAgXTtcbn07IH07XG47XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYWluKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX190aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ2RpdicsIHsgaHRtbDogeyAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NOYW1lIH0sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLnJvb3Qud21sLmlkIH0gfSwgX19zcHJlYWRBcnJheXMoKF9fY29udGV4dC52YWx1ZXMuYnV0dG9uLnRlbXBsYXRlKCkoX19jb250ZXh0KShfX3RoaXMpKSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdkaXYnLCB7IGh0bWw6IHsgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jb250ZW50LmNsYXNzTmFtZSB9LCB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5jb250ZW50LndtbC5pZCB9IH0sIF9fc3ByZWFkQXJyYXlzKChfX2NvbnRleHQudmFsdWVzLmNvbnRlbnQucmVuZGVyKCkpKSlcbiAgICAgICAgICAgIF0pKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgTWFpbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIE1haW47XG59KCkpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRyb3AtZG93bi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIGZlZWRiYWNrXzEgPSByZXF1aXJlKFwiLi4vZmVlZGJhY2tcIik7XG52YXIgc2VsZWN0XzEgPSByZXF1aXJlKFwiLi4vc2VsZWN0XCIpO1xuZXhwb3J0cy5JdGVtQ2hhbmdlZEV2ZW50ID0gc2VsZWN0XzEuSXRlbUNoYW5nZWRFdmVudDtcbnZhciBmb3JtXzEgPSByZXF1aXJlKFwiLi4vZm9ybVwiKTtcbnZhciBfXzEgPSByZXF1aXJlKFwiLi4vLi4vXCIpO1xudmFyIF9fMiA9IHJlcXVpcmUoXCIuLi9cIik7XG52YXIgZHJvcF9saXN0X2ZpZWxkXzEgPSByZXF1aXJlKFwiLi93bWwvZHJvcC1saXN0LWZpZWxkXCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5EUk9QX0xJU1RfRklFTEQgPSAnd3ctZHJvcC1saXN0LWZpZWxkJztcbi8qKlxuICogRHJvcExpc3RGaWVsZFxuICovXG52YXIgRHJvcExpc3RGaWVsZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRHJvcExpc3RGaWVsZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEcm9wTGlzdEZpZWxkKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyBkcm9wX2xpc3RfZmllbGRfMS5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ3Jvb3QnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpZDogX18xLmdldElkKF90aGlzLmF0dHJzKSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IHV0aWxfMS5jb25jYXQoZXhwb3J0cy5EUk9QX0xJU1RfRklFTEQsIF9fMS5nZXRDbGFzc05hbWUoX3RoaXMuYXR0cnMpLCBmZWVkYmFja18xLmdldFZhbGlkaXR5Q2xhc3NOYW1lKF90aGlzLmF0dHJzKSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZXNzYWdlczoge1xuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ21lc3NhZ2UnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBmZWVkYmFja18xLmdldE1lc3NhZ2UoX3RoaXMuYXR0cnMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgICAgICBpZDogX18yLmdldE5hbWUoX3RoaXMuYXR0cnMpLFxuICAgICAgICAgICAgICAgIHRleHQ6IGZvcm1fMS5nZXRMYWJlbChfdGhpcy5hdHRycylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250cm9sOiB7XG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAnY29udHJvbCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG5hbWU6IF9fMi5nZXROYW1lKF90aGlzLmF0dHJzKSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGZlZWRiYWNrXzEuZ2V0VmFsaWRpdHlDbGFzc05hbWUoX3RoaXMuYXR0cnMpLFxuICAgICAgICAgICAgICAgIGJsb2NrOiB0cnVlLFxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cucGxhY2Vob2xkZXIpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cudmFsdWUpLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5vcHRpb25zKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3Lm9wdGlvbnMgOiBbXSxcbiAgICAgICAgICAgICAgICBzdHJpbmdpZmllcjogX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuc3RyaW5naWZpZXIsXG4gICAgICAgICAgICAgICAgaXRlbVRlbXBsYXRlOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuaXRlbVRlbXBsYXRlKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3Lml0ZW1UZW1wbGF0ZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBub0l0ZW1zVGVtcGxhdGU6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5ub0l0ZW1zVGVtcGxhdGUpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cubm9JdGVtc1RlbXBsYXRlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG9uU2VsZWN0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cub25DaGFuZ2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5vbkNoYW5nZShuZXcgc2VsZWN0XzEuSXRlbUNoYW5nZWRFdmVudChlLm5hbWUsIGUudmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERyb3BMaXN0RmllbGQucHJvdG90eXBlLnNldE1lc3NhZ2UgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIGdldEhlbHAodGhpcykubWFwKGZ1bmN0aW9uIChoKSB7IHJldHVybiBoLnNldE1lc3NhZ2UobXNnKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgRHJvcExpc3RGaWVsZC5wcm90b3R5cGUucmVtb3ZlTWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZ2V0SGVscCh0aGlzKS5tYXAoZnVuY3Rpb24gKGgpIHsgcmV0dXJuIGgucmVtb3ZlTWVzc2FnZSgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gRHJvcExpc3RGaWVsZDtcbn0oZm9ybV8xLkFic3RyYWN0Rm9ybUNvbnRyb2wpKTtcbmV4cG9ydHMuRHJvcExpc3RGaWVsZCA9IERyb3BMaXN0RmllbGQ7XG52YXIgZ2V0SGVscCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHV0aWxfMS5nZXRCeUlkKHQudmlldywgdC52YWx1ZXMubWVzc2FnZXMud21sLmlkKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBsYWJlbF8xID0gcmVxdWlyZShcIi4uLy4uL2xhYmVsXCIpO1xuO1xudmFyIGhlbHBfMSA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwXCIpO1xuO1xudmFyIGRyb3BfbGlzdF8xID0gcmVxdWlyZShcIi4uLy4uL2Ryb3AtbGlzdFwiKTtcbjtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdkaXYnLCB7IGh0bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5yb290LmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NOYW1lIH0sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLnJvb3Qud21sLmlkIH0gfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobGFiZWxfMS5MYWJlbCwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ2Zvcic6IF9fY29udGV4dC52YWx1ZXMucm9vdC5pZCwgJ3RleHQnOiBfX2NvbnRleHQudmFsdWVzLmxhYmVsLnRleHQgfSB9LCBbXSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChkcm9wX2xpc3RfMS5Ecm9wTGlzdCwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ2NsYXNzTmFtZSc6IF9fY29udGV4dC52YWx1ZXMuY29udHJvbC5jbGFzc05hbWUsICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5jb250cm9sLm5hbWUsICdwbGFjZWhvbGRlcic6IF9fY29udGV4dC52YWx1ZXMuY29udHJvbC5wbGFjZWhvbGRlciwgJ2Jsb2NrJzogX19jb250ZXh0LnZhbHVlcy5jb250cm9sLmJsb2NrLCAndmFsdWUnOiBfX2NvbnRleHQudmFsdWVzLmNvbnRyb2wudmFsdWUsICdvcHRpb25zJzogX19jb250ZXh0LnZhbHVlcy5jb250cm9sLm9wdGlvbnMsICdvblNlbGVjdCc6IF9fY29udGV4dC52YWx1ZXMuY29udHJvbC5vblNlbGVjdCwgJ25vSXRlbXNUZW1wbGF0ZSc6IF9fY29udGV4dC52YWx1ZXMuY29udHJvbC5ub0l0ZW1zVGVtcGxhdGUsICdpdGVtc1RlbXBsYXRlJzogX19jb250ZXh0LnZhbHVlcy5jb250cm9sLml0ZW1UZW1wbGF0ZSwgJ3N0cmluZ2lmaWVyJzogX19jb250ZXh0LnZhbHVlcy5jb250cm9sLnN0cmluZ2lmaWVyIH0gfSwgW10pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoaGVscF8xLkhlbHAsIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLm1lc3NhZ2VzLndtbC5pZCB9LCB3dzogeyAndGV4dCc6IF9fY29udGV4dC52YWx1ZXMubWVzc2FnZXMudGV4dCB9IH0sIFtdKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kcm9wLWxpc3QtZmllbGQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9kcm9wLWxpc3RcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgc2l6ZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRlbnQvc2l6ZVwiKTtcbnZhciBvcmllbnRhdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRlbnQvb3JpZW50YXRpb25cIik7XG52YXIgcmVzdWx0c19tZW51XzEgPSByZXF1aXJlKFwiLi4vcmVzdWx0cy1tZW51XCIpO1xuZXhwb3J0cy5JdGVtU2VsZWN0ZWRFdmVudCA9IHJlc3VsdHNfbWVudV8xLkl0ZW1TZWxlY3RlZEV2ZW50O1xudmFyIHNlYXJjaF8xID0gcmVxdWlyZShcIi4uL3NlYXJjaFwiKTtcbnZhciBfXzEgPSByZXF1aXJlKFwiLi4vLi4vXCIpO1xudmFyIF9fMiA9IHJlcXVpcmUoXCIuLi9cIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLkRST1BfTElTVCA9ICd3dy1kcm9wLWxpc3QnO1xuLyoqXG4gKiBEcm9wTGlzdCBwcm92aWRlcyBhIGNvbnRyb2wgZm9yIG1ha2luZyBhIHNlbGVjdGlvbiBmcm9tIGEgbGlzdCBvZiBjaG9pY2VzLlxuICovXG52YXIgRHJvcExpc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERyb3BMaXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERyb3BMaXN0KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6IF9fMS5nZXRJZChfdGhpcy5hdHRycyksXG4gICAgICAgICAgICBjbGFzc05hbWU6IHV0aWxfMS5jb25jYXQoZXhwb3J0cy5EUk9QX0xJU1QsIF9fMS5nZXRDbGFzc05hbWUoX3RoaXMuYXR0cnMpLCAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuc2l6ZSkgP1xuICAgICAgICAgICAgICAgIHNpemVfMS5nZXRTaXplQ2xhc3NOYW1lKF90aGlzLmF0dHJzLnd3LnNpemUpIDogJycsIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5ibG9jaykgP1xuICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uXzEuQkxPQ0sgOiAnJyksXG4gICAgICAgICAgICBuYW1lOiBfXzIuZ2V0TmFtZShfdGhpcy5hdHRycyksXG4gICAgICAgICAgICB2YWx1ZTogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnZhbHVlKSxcbiAgICAgICAgICAgIGNvbnRyb2w6IHtcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdkcm9wLWxpc3QnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAnbWVzc2FnZXMnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpc3BsYXk6IHtcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuYXR0cnMud3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hdHRycy53dy5vcHRpb25zICYmIF90aGlzLnZhbHVlcy52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q3VycmVudChfdGhpcy5hdHRycy53dy5vcHRpb25zLCBfdGhpcy52YWx1ZXMudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmF0dHJzLnd3LnBsYWNlaG9sZGVyIHx8ICdTZWxlY3Qgb25lJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25DbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMudmFsdWVzLm1lbnUub3Blbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaF8xLnVwZGF0ZU1lbnUoX3RoaXMudmlldywgX3RoaXMudmFsdWVzLm1lbnUud21sLmlkLCBfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5vcHRpb25zIHx8IFtdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZW51OiB7XG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAnbWVudSdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG5hbWU6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5uYW1lKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3Lm5hbWUgOiAnJyxcbiAgICAgICAgICAgICAgICBibG9jazogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmJsb2NrKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LmJsb2NrIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgb3BlbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgb25TZWxlY3Q6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5vblNlbGVjdClcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3Lm9uU2VsZWN0KG5ldyByZXN1bHRzX21lbnVfMS5JdGVtU2VsZWN0ZWRFdmVudChlLm5hbWUsIGUudmFsdWUudmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmFsdWVzLnZhbHVlID0gZS52YWx1ZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmlldy5pbnZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpdGVtVGVtcGxhdGU6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5pdGVtVGVtcGxhdGUpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuaXRlbVRlbXBsYXRlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG5vSXRlbXNUZW1wbGF0ZTogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm5vSXRlbXNUZW1wbGF0ZSkgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5ub0l0ZW1zVGVtcGxhdGUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgc3RyaW5naWZpZXI6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5zdHJpbmdpZmllcikgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5zdHJpbmdpZmllciA6IGZ1bmN0aW9uICh2KSB7IHJldHVybiB2LmxhYmVsOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogb3BlbiB0aGUgcmVzdWx0cyBtZW51LlxuICAgICAqL1xuICAgIERyb3BMaXN0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnZhbHVlcy5tZW51Lm9wZW4gPSB0cnVlO1xuICAgICAgICBzZWFyY2hfMS5vcGVuTWVudSh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLm1lbnUud21sLmlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBjbG9zZSB0aGUgcmVzdWx0cyBtZW51LlxuICAgICAqL1xuICAgIERyb3BMaXN0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy52YWx1ZXMubWVudS5vcGVuID0gZmFsc2U7XG4gICAgICAgIHNlYXJjaF8xLmNsb3NlTWVudSh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLm1lbnUud21sLmlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gRHJvcExpc3Q7XG59KF9fMi5BYnN0cmFjdENvbnRyb2wpKTtcbmV4cG9ydHMuRHJvcExpc3QgPSBEcm9wTGlzdDtcbnZhciBnZXRDdXJyZW50ID0gZnVuY3Rpb24gKG9wdHMsIHZhbHVlLCB0ZXh0KSB7XG4gICAgaWYgKHRleHQgPT09IHZvaWQgMCkgeyB0ZXh0ID0gJ1NlbGVjdCBvbmUnOyB9XG4gICAgcmV0dXJuIG9wdHMucmVkdWNlKGZ1bmN0aW9uIChwLCBjKSB7IHJldHVybiBjLnZhbHVlID09PSB2YWx1ZSA/IGMubGFiZWwgOiBwOyB9LCB0ZXh0KTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjYXJldF8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2NvbnRlbnQvY2FyZXRcIik7XG47XG52YXIgcmVzdWx0c19tZW51XzEgPSByZXF1aXJlKFwiLi4vLi4vcmVzdWx0cy1tZW51XCIpO1xuO1xudmFyIGRpc3BsYXlfZmllbGRfMSA9IHJlcXVpcmUoXCIuLi8uLi9kaXNwbGF5LWZpZWxkXCIpO1xuO1xudmFyIF9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9cIik7XG47XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnZGl2JywgeyBodG1sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuY2xhc3NOYW1lIH0sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZGlzcGxheV9maWVsZF8xLkRpc3BsYXlGaWVsZCwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ29uQ2xpY2snOiBfX2NvbnRleHQudmFsdWVzLmRpc3BsYXkub25DbGljayB9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX18xLnRleHQoX19jb250ZXh0LnZhbHVlcy5kaXNwbGF5LnBsYWNlaG9sZGVyKCkpLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGNhcmV0XzEuQ2FyZXQsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW10pXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChyZXN1bHRzX21lbnVfMS5SZXN1bHRzTWVudSwgeyBodG1sOiB7fSwgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMubWVudS53bWwuaWQgfSwgd3c6IHsgJ2Jsb2NrJzogX19jb250ZXh0LnZhbHVlcy5tZW51LmJsb2NrLCAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMubWVudS5uYW1lLCAnb25TZWxlY3QnOiBfX2NvbnRleHQudmFsdWVzLm1lbnUub25TZWxlY3QsICdub0l0ZW1zVGVtcGxhdGUnOiBfX2NvbnRleHQudmFsdWVzLm1lbnUubm9JdGVtc1RlbXBsYXRlLCAnaXRlbXNUZW1wbGF0ZSc6IF9fY29udGV4dC52YWx1ZXMubWVudS5pdGVtVGVtcGxhdGUsICdzdHJpbmdpZmllcic6IF9fY29udGV4dC52YWx1ZXMubWVudS5zdHJpbmdpZmllciB9IH0sIFtdKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kcm9wLWxpc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzdHlsZSA9IHJlcXVpcmUoXCIuLi9jb250ZW50L3N0eWxlXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIGNvbnRyb2xfMSA9IHJlcXVpcmUoXCIuLi9jb250cm9sXCIpO1xuLyoqXG4gKiBWYWxpZGF0aW9uU3RhdGVcbiAqL1xudmFyIFZhbGlkYXRpb25TdGF0ZTtcbihmdW5jdGlvbiAoVmFsaWRhdGlvblN0YXRlKSB7XG4gICAgVmFsaWRhdGlvblN0YXRlW1wiTmV1dHJhbFwiXSA9IFwibmV1dHJhbFwiO1xuICAgIFZhbGlkYXRpb25TdGF0ZVtcIkVycm9yXCJdID0gXCJlcnJvclwiO1xuICAgIFZhbGlkYXRpb25TdGF0ZVtcIlN1Y2Nlc3NcIl0gPSBcInN1Y2Nlc3NcIjtcbiAgICBWYWxpZGF0aW9uU3RhdGVbXCJXYXJuaW5nXCJdID0gXCJ3YXJuaW5nXCI7XG59KShWYWxpZGF0aW9uU3RhdGUgPSBleHBvcnRzLlZhbGlkYXRpb25TdGF0ZSB8fCAoZXhwb3J0cy5WYWxpZGF0aW9uU3RhdGUgPSB7fSkpO1xuLyoqXG4gKiBBYnN0cmFjdEZlZWRiYWNrQ29udHJvbFxuICpcbiAqIFByb3ZpZGVzIGEgZGVmYXVsdCBpbXBsZW1lbnRhaW9uIG9mIHRoZSBpbnRlcmZhY2UgbWV0aG9kcy5cbiAqL1xudmFyIEFic3RyYWN0RmVlZGJhY2tDb250cm9sID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBYnN0cmFjdEZlZWRiYWNrQ29udHJvbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBYnN0cmFjdEZlZWRiYWNrQ29udHJvbCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBBYnN0cmFjdEZlZWRiYWNrQ29udHJvbC5wcm90b3R5cGUuc2V0TWVzc2FnZSA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgZXhwb3J0cy5zZXRNZXNzYWdlKHRoaXMudmlldywgdGhpcy52YWx1ZXMubWVzc2FnZXMud21sLmlkLCBtc2cpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEFic3RyYWN0RmVlZGJhY2tDb250cm9sLnByb3RvdHlwZS5yZW1vdmVNZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBleHBvcnRzLnJlbW92ZU1lc3NhZ2UodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5tZXNzYWdlcy53bWwuaWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEFic3RyYWN0RmVlZGJhY2tDb250cm9sLnByb3RvdHlwZS5zZXRWYWxpZGF0aW9uU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgZXhwb3J0cy5zZXRWYWxpZGF0aW9uU3RhdGUodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5jb250cm9sLndtbC5pZCwgc3RhdGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEFic3RyYWN0RmVlZGJhY2tDb250cm9sLnByb3RvdHlwZS5yZW1vdmVWYWxpZGF0aW9uU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGV4cG9ydHMucmVtb3ZlVmFsaWRhdGlvblN0YXRlKHRoaXMudmlldywgdGhpcy52YWx1ZXMuY29udHJvbC53bWwuaWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEFic3RyYWN0RmVlZGJhY2tDb250cm9sLnByb3RvdHlwZS5nZXRWYWxpZGF0aW9uU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLmdldFZhbGlkYXRpb25TdGF0ZSh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLmNvbnRyb2wud21sLmlkKTtcbiAgICB9O1xuICAgIHJldHVybiBBYnN0cmFjdEZlZWRiYWNrQ29udHJvbDtcbn0oY29udHJvbF8xLkFic3RyYWN0Q29udHJvbCkpO1xuZXhwb3J0cy5BYnN0cmFjdEZlZWRiYWNrQ29udHJvbCA9IEFic3RyYWN0RmVlZGJhY2tDb250cm9sO1xuLyoqXG4gKiBzZXRNZXNzYWdlIGhlbHBlci5cbiAqL1xuZXhwb3J0cy5zZXRNZXNzYWdlID0gZnVuY3Rpb24gKHZpZXcsIGlkLCBtc2cpIHtcbiAgICByZXR1cm4gdXRpbF8xLmdldEJ5SWQodmlldywgaWQpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKG1lc3NhZ2VzKSB7XG4gICAgICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobXNnKTtcbiAgICAgICAgd2hpbGUgKG1lc3NhZ2VzLmxhc3RDaGlsZClcbiAgICAgICAgICAgIG1lc3NhZ2VzLnJlbW92ZUNoaWxkKG1lc3NhZ2VzLmxhc3RDaGlsZCk7XG4gICAgICAgIG1lc3NhZ2VzLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgIH0pO1xufTtcbi8qKlxuICogcmVtb3ZlTWVzc2FnZVxuICovXG5leHBvcnRzLnJlbW92ZU1lc3NhZ2UgPSBmdW5jdGlvbiAodmlldywgaWQpIHtcbiAgICByZXR1cm4gdXRpbF8xLmdldEJ5SWQodmlldywgaWQpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKG1lc3NhZ2VzKSB7XG4gICAgICAgIHdoaWxlIChtZXNzYWdlcy5sYXN0Q2hpbGQpXG4gICAgICAgICAgICBtZXNzYWdlcy5yZW1vdmVDaGlsZChtZXNzYWdlcy5sYXN0Q2hpbGQpO1xuICAgIH0pO1xufTtcbi8qKlxuICogc2V0VmFsaWRhdGlvblN0YXRlIGhlbHBlci5cbiAqL1xuZXhwb3J0cy5zZXRWYWxpZGF0aW9uU3RhdGUgPSBmdW5jdGlvbiAodmlldywgaWQsIHN0YXRlKSB7XG4gICAgZXhwb3J0cy5yZW1vdmVWYWxpZGF0aW9uU3RhdGUodmlldywgaWQpO1xuICAgIGlmIChzdGF0ZSAhPT0gVmFsaWRhdGlvblN0YXRlLk5ldXRyYWwpXG4gICAgICAgIHV0aWxfMS5nZXRCeUlkKHZpZXcsIGlkKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5jbGFzc0xpc3QuYWRkKGV4cG9ydHMudmFsaWRhdGlvblN0YXRlMkNsYXNzTmFtZShzdGF0ZSkpOyB9KTtcbn07XG4vKipcbiAqIHJlbW92ZVZhbGlkYXRpb25TdGF0ZSBoZWxwZXIuXG4gKi9cbmV4cG9ydHMucmVtb3ZlVmFsaWRhdGlvblN0YXRlID0gZnVuY3Rpb24gKHZpZXcsIGlkKSB7XG4gICAgdXRpbF8xLmdldEJ5SWQodmlldywgaWQpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgaC5jbGFzc0xpc3QucmVtb3ZlKHN0eWxlLlNVQ0NFU1MpO1xuICAgICAgICBoLmNsYXNzTGlzdC5yZW1vdmUoc3R5bGUuRVJST1IpO1xuICAgICAgICBoLmNsYXNzTGlzdC5yZW1vdmUoc3R5bGUuV0FSTklORyk7XG4gICAgfSk7XG59O1xuLyoqXG4gKiBnZXRWYWxpZGF0aW9uU3RhdGUgY2FsY3VsYXRlcyB0aGUgVmFsaWRhdGlvblN0YXRlIG9mIGFuIEhUTUxFbGVtZW50XG4gKiAoaWRlbnRpZmllZCBieSBpZCkgYnkgYW5hbHlzaW5nIGl0cyBjbGFzcyBsaXN0LlxuICovXG5leHBvcnRzLmdldFZhbGlkYXRpb25TdGF0ZSA9IGZ1bmN0aW9uICh2aWV3LCBpZCkge1xuICAgIHJldHVybiB1dGlsXzEuZ2V0QnlJZCh2aWV3LCBpZClcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoaCkge1xuICAgICAgICBpZiAoaC5jbGFzc0xpc3QuY29udGFpbnMoc3R5bGUuU1VDQ0VTUykpXG4gICAgICAgICAgICByZXR1cm4gVmFsaWRhdGlvblN0YXRlLlN1Y2Nlc3M7XG4gICAgICAgIGVsc2UgaWYgKGguY2xhc3NMaXN0LmNvbnRhaW5zKHN0eWxlLldBUk5JTkcpKVxuICAgICAgICAgICAgcmV0dXJuIFZhbGlkYXRpb25TdGF0ZS5XYXJuaW5nO1xuICAgICAgICBlbHNlIGlmIChoLmNsYXNzTGlzdC5jb250YWlucyhzdHlsZS5FUlJPUikpXG4gICAgICAgICAgICByZXR1cm4gVmFsaWRhdGlvblN0YXRlLkVycm9yO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gVmFsaWRhdGlvblN0YXRlLk5ldXRyYWw7XG4gICAgfSlcbiAgICAgICAgLmdldCgpO1xufTtcbi8qKlxuICogZ2V0VmFsaWRpdHlDbGFzc05hbWUgcHJvdmlkZXMgdGhlIGFwcGxpY2FibGUgc3R5bGUgY2xhc3MgYnkgY2hlY2tpbmdcbiAqIHRoZSB2YWxpZGl0eSBwcm9wZXJ0aWVzIG9mIEZlZWRiYWNrQ29udHJvQXR0cnMuXG4gKi9cbmV4cG9ydHMuZ2V0VmFsaWRpdHlDbGFzc05hbWUgPSBmdW5jdGlvbiAoYXR0cnMpIHtcbiAgICBpZiAoYXR0cnMud3cpIHtcbiAgICAgICAgaWYgKGF0dHJzLnd3LmVycm9yICYmIChhdHRycy53dy5lcnJvciAhPSAnJykpXG4gICAgICAgICAgICByZXR1cm4gc3R5bGUuRVJST1I7XG4gICAgICAgIGlmIChhdHRycy53dy53YXJuaW5nICYmIChhdHRycy53dy53YXJuaW5nICE9ICcnKSlcbiAgICAgICAgICAgIHJldHVybiBzdHlsZS5XQVJOSU5HO1xuICAgICAgICBpZiAoYXR0cnMud3cuc3VjY2VzcyAmJiAoYXR0cnMud3cuc3VjY2VzcyAhPSAnJykpXG4gICAgICAgICAgICByZXR1cm4gc3R5bGUuU1VDQ0VTUztcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufTtcbi8qKlxuICogZ2V0TWVzc2FnZVxuICovXG5leHBvcnRzLmdldE1lc3NhZ2UgPSBmdW5jdGlvbiAoYXR0cnMpIHtcbiAgICBpZiAoYXR0cnMud3cpIHtcbiAgICAgICAgaWYgKGF0dHJzLnd3LmVycm9yICYmIChhdHRycy53dy5lcnJvciAhPSAnJykpXG4gICAgICAgICAgICByZXR1cm4gYXR0cnMud3cuZXJyb3I7XG4gICAgICAgIGlmIChhdHRycy53dy53YXJuaW5nICYmIChhdHRycy53dy53YXJuaW5nICE9ICcnKSlcbiAgICAgICAgICAgIHJldHVybiBhdHRycy53dy53YXJuaW5nO1xuICAgICAgICBpZiAoYXR0cnMud3cuc3VjY2VzcyAmJiAoYXR0cnMud3cuc3VjY2VzcyAhPSAnJykpXG4gICAgICAgICAgICByZXR1cm4gYXR0cnMud3cuc3VjY2VzcztcbiAgICAgICAgaWYgKGF0dHJzLnd3Lm1lc3NhZ2UgJiYgKGF0dHJzLnd3Lm1lc3NhZ2UgIT0gJycpKVxuICAgICAgICAgICAgcmV0dXJuIGF0dHJzLnd3Lm1lc3NhZ2U7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn07XG4vKipcbiAqIHZhbGlkYXRpb25TdGF0ZTJDbGFzc05hbWUgdHJhbnNmb3JtcyBhIFZhbGlkYXRpb25TdGF0ZSBpbnRvXG4gKiB0aGUgY29ycmVzcG9uZGluZyBjbGFzcyBuYW1lIChpZiBhbnkpLlxuICovXG5leHBvcnRzLnZhbGlkYXRpb25TdGF0ZTJDbGFzc05hbWUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUgPT09IFZhbGlkYXRpb25TdGF0ZS5TdWNjZXNzKVxuICAgICAgICByZXR1cm4gc3R5bGUuU1VDQ0VTUztcbiAgICBlbHNlIGlmIChzdGF0ZSA9PT0gVmFsaWRhdGlvblN0YXRlLldhcm5pbmcpXG4gICAgICAgIHJldHVybiBzdHlsZS5XQVJOSU5HO1xuICAgIGVsc2UgaWYgKHN0YXRlID09PSBWYWxpZGF0aW9uU3RhdGUuRXJyb3IpXG4gICAgICAgIHJldHVybiBzdHlsZS5FUlJPUjtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiAnJztcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZWVkYmFjay5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIF9fMSA9IHJlcXVpcmUoXCIuLi8uLi9cIik7XG52YXIgX18yID0gcmVxdWlyZShcIi4uL1wiKTtcbnZhciBmaWxlX2lucHV0XzEgPSByZXF1aXJlKFwiLi93bWwvZmlsZS1pbnB1dFwiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuRklMRV9JTlBVVCA9ICd3dy1maWxlLWlucHV0Jztcbi8qKlxuICogRmlsZUNoYW5nZWRFdmVudCBpcyBmaXJlZCB3aGVuXG4gKi9cbnZhciBGaWxlQ2hhbmdlZEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGaWxlQ2hhbmdlZEV2ZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZpbGVDaGFuZ2VkRXZlbnQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEZpbGVDaGFuZ2VkRXZlbnQ7XG59KF9fMi5FdmVudCkpO1xuZXhwb3J0cy5GaWxlQ2hhbmdlZEV2ZW50ID0gRmlsZUNoYW5nZWRFdmVudDtcbi8qKlxuICogRmlsZUlucHV0IHByb3ZpZGVzIGEgc3VyZmFjZSBmb3IgZmlsZSBzZWxlY3Rpb24uXG4gKlxuICogSXQgc3VwcG9ydHMgZHJhZyBhbmQgZHJvcCBvZiB0aGUgZmlsZXMgYXMgaW5wdXQuXG4gKi9cbnZhciBGaWxlSW5wdXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZpbGVJbnB1dCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGaWxlSW5wdXQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IGZpbGVfaW5wdXRfMS5GaWxlSW5wdXRWaWV3KF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6IF9fMS5nZXRJZChfdGhpcy5hdHRycyksXG4gICAgICAgICAgICBjbGFzc05hbWU6IHV0aWxfMS5jb25jYXQoZXhwb3J0cy5GSUxFX0lOUFVULCBfXzEuZ2V0Q2xhc3NOYW1lKF90aGlzLmF0dHJzKSksXG4gICAgICAgICAgICBuYW1lOiBfXzIuZ2V0TmFtZShfdGhpcy5hdHRycyksXG4gICAgICAgICAgICBhY2NlcHQ6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5hY2NlcHQpID9cbiAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5hY2NlcHQgOiAnJyxcbiAgICAgICAgICAgIGNoYW5nZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSBlLnRhcmdldDtcbiAgICAgICAgICAgICAgICBpZiAoKGlucHV0LmZpbGVzICE9IG51bGwpICYmXG4gICAgICAgICAgICAgICAgICAgIChpbnB1dC5maWxlcy5sZW5ndGggPiAwKSAmJlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dyAmJlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5vbkNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5vbkNoYW5nZShuZXcgRmlsZUNoYW5nZWRFdmVudChpbnB1dC5uYW1lLCBpbnB1dC5maWxlc1swXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gRmlsZUlucHV0O1xufShfXzIuQWJzdHJhY3RDb250cm9sKSk7XG5leHBvcnRzLkZpbGVJbnB1dCA9IEZpbGVJbnB1dDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy9AdHMtaWdub3JlOiA2MTkyXG52YXIgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19pZiA9IGZ1bmN0aW9uIChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkge1xuICAgIHJldHVybiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCgpO1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JJbiA9IGZ1bmN0aW9uIChsaXN0LCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2Zvck9mID0gZnVuY3Rpb24gKG8sIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG52YXIgRmlsZUlucHV0VmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGaWxlSW5wdXRWaWV3KF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX190aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ2lucHV0JywgeyBodG1sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuY2xhc3NOYW1lLCAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMubmFtZSwgJ3R5cGUnOiBcImZpbGVcIiwgJ2FjY2VwdCc6IF9fY29udGV4dC52YWx1ZXMuYWNjZXB0LCAnb25jaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLmNoYW5nZSB9LCB3bWw6IHt9IH0sIFtdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgRmlsZUlucHV0Vmlldy5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIEZpbGVJbnB1dFZpZXcucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIEZpbGVJbnB1dFZpZXcucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgRmlsZUlucHV0Vmlldy5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBGaWxlSW5wdXRWaWV3LnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBGaWxlSW5wdXRWaWV3LnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIEZpbGVJbnB1dFZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIEZpbGVJbnB1dFZpZXc7XG59KCkpO1xuZXhwb3J0cy5GaWxlSW5wdXRWaWV3ID0gRmlsZUlucHV0Vmlldztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbGUtaW5wdXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBmaWxlX2lucHV0XzEgPSByZXF1aXJlKFwiLi4vZmlsZS1pbnB1dFwiKTtcbmV4cG9ydHMuRmlsZUNoYW5nZWRFdmVudCA9IGZpbGVfaW5wdXRfMS5GaWxlQ2hhbmdlZEV2ZW50O1xudmFyIF9fMSA9IHJlcXVpcmUoXCIuLi8uLi9cIik7XG52YXIgX18yID0gcmVxdWlyZShcIi4uL1wiKTtcbnZhciBmaWxlX3VwbG9hZF9zdXJmYWNlXzEgPSByZXF1aXJlKFwiLi93bWwvZmlsZS11cGxvYWQtc3VyZmFjZVwiKTtcbmV4cG9ydHMuSU5TVFJVQ1RJT05fVEVYVCA9ICdDaG9vc2UgYSBmaWxlJztcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuRklMRV9VUExPQURfU1VSRkFDRSA9ICd3dy1maWxlLXVwbG9hZC1zdXJmYWNlJztcbmV4cG9ydHMuRklMRV9VUExPQURfU1VSRkFDRV9JTlBVVCA9ICd3dy1maWxlLXVwbG9hZC1zdXJmYWNlX19pbnB1dCc7XG5leHBvcnRzLkZJTEVfVVBMT0FEX1NVUkZBQ0VfVEVYVCA9ICd3dy1maWxlLXVwbG9hZC1zdXJmYWNlX190ZXh0Jztcbi8qKlxuICogRmlsZVVwbG9hZFN1cmZhY2UgcHJvdmlkZXMgYSBzdXJmYWNlIGZvciBmaWxlIHNlbGVjdGlvbi5cbiAqXG4gKiBJdCBzdXBwb3J0cyBkcmFnIGFuZCBkcm9wIG9mIHRoZSBmaWxlcyBhcyBpbnB1dC5cbiAqL1xudmFyIEZpbGVVcGxvYWRTdXJmYWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGaWxlVXBsb2FkU3VyZmFjZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGaWxlVXBsb2FkU3VyZmFjZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgZmlsZV91cGxvYWRfc3VyZmFjZV8xLkZpbGVVcGxvYWRTdXJmYWNlVmlldyhfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiBfXzEuZ2V0SWQoX3RoaXMuYXR0cnMpLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiB1dGlsXzEuY29uY2F0KGV4cG9ydHMuRklMRV9VUExPQURfU1VSRkFDRSwgX18xLmdldENsYXNzTmFtZShfdGhpcy5hdHRycykpLFxuICAgICAgICAgICAgc3RvcDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkcm9wOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm5hbWUpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cubmFtZSA6ICcnO1xuICAgICAgICAgICAgICAgIGlmIChlLmRhdGFUcmFuc2ZlciAmJiBlLmRhdGFUcmFuc2Zlci5maWxlcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZXMuaW5wdXQub25DaGFuZ2UobmV3IGZpbGVfaW5wdXRfMS5GaWxlQ2hhbmdlZEV2ZW50KG5hbWUsIGUuZGF0YVRyYW5zZmVyLmZpbGVzWzBdKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5wdXQ6IHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGV4cG9ydHMuRklMRV9VUExPQURfU1VSRkFDRV9JTlBVVCxcbiAgICAgICAgICAgICAgICBuYW1lOiBfXzIuZ2V0TmFtZShfdGhpcy5hdHRycyksXG4gICAgICAgICAgICAgICAgYWNjZXB0OiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuYWNjZXB0KSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LmFjY2VwdCA6ICcnLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZXMudGV4dC52YWx1ZSA9IGUudmFsdWUubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm9uQ2hhbmdlKVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cub25DaGFuZ2UoZSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnZpZXcuaW52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZXh0OiB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBleHBvcnRzLkZJTEVfVVBMT0FEX1NVUkZBQ0VfVEVYVCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnRleHQpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cudGV4dCA6IGV4cG9ydHMuSU5TVFJVQ1RJT05fVEVYVFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBGaWxlVXBsb2FkU3VyZmFjZTtcbn0oX18yLkFic3RyYWN0Q29udHJvbCkpO1xuZXhwb3J0cy5GaWxlVXBsb2FkU3VyZmFjZSA9IEZpbGVVcGxvYWRTdXJmYWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX18xID0gcmVxdWlyZShcIi4uLy4uLy4uL1wiKTtcbjtcbnZhciBmaWxlX2lucHV0XzEgPSByZXF1aXJlKFwiLi4vLi4vZmlsZS1pbnB1dFwiKTtcbjtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIEZpbGVVcGxvYWRTdXJmYWNlVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGaWxlVXBsb2FkU3VyZmFjZVZpZXcoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnZGl2JywgeyBodG1sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuY2xhc3NOYW1lLCAnb25kcmFnZW50ZXInOiBfX2NvbnRleHQudmFsdWVzLnN0b3AsICdvbmRyYWdvdmVyJzogX19jb250ZXh0LnZhbHVlcy5zdG9wLCAnb25kcm9wJzogX19jb250ZXh0LnZhbHVlcy5kcm9wIH0sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZmlsZV9pbnB1dF8xLkZpbGVJbnB1dCwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ2NsYXNzTmFtZSc6IF9fY29udGV4dC52YWx1ZXMuaW5wdXQuY2xhc3NOYW1lLCAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMuaW5wdXQubmFtZSwgJ2FjY2VwdCc6IF9fY29udGV4dC52YWx1ZXMuaW5wdXQuYWNjZXB0LCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLmlucHV0Lm9uQ2hhbmdlIH0gfSwgW10pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdkaXYnLCB7IGh0bWw6IHsgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy50ZXh0LmNsYXNzTmFtZSB9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2gzJywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfXzEudGV4dChfX2NvbnRleHQudmFsdWVzLnRleHQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBGaWxlVXBsb2FkU3VyZmFjZVZpZXcucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBGaWxlVXBsb2FkU3VyZmFjZVZpZXcucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIEZpbGVVcGxvYWRTdXJmYWNlVmlldy5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBGaWxlVXBsb2FkU3VyZmFjZVZpZXcucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgRmlsZVVwbG9hZFN1cmZhY2VWaWV3LnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBGaWxlVXBsb2FkU3VyZmFjZVZpZXcucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgRmlsZVVwbG9hZFN1cmZhY2VWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBGaWxlVXBsb2FkU3VyZmFjZVZpZXc7XG59KCkpO1xuZXhwb3J0cy5GaWxlVXBsb2FkU3VyZmFjZVZpZXcgPSBGaWxlVXBsb2FkU3VyZmFjZVZpZXc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWxlLXVwbG9hZC1zdXJmYWNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuLyoqXG4gKiBGb2N1c0dhaW5lZEV2ZW50XG4gKi9cbnZhciBGb2N1c0dhaW5lZEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZvY3VzR2FpbmVkRXZlbnQobmFtZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cbiAgICByZXR1cm4gRm9jdXNHYWluZWRFdmVudDtcbn0oKSk7XG5leHBvcnRzLkZvY3VzR2FpbmVkRXZlbnQgPSBGb2N1c0dhaW5lZEV2ZW50O1xuLyoqXG4gKiBGb2N1c0xvc3RFdmVudFxuICovXG52YXIgRm9jdXNMb3N0RXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRm9jdXNMb3N0RXZlbnQobmFtZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cbiAgICByZXR1cm4gRm9jdXNMb3N0RXZlbnQ7XG59KCkpO1xuZXhwb3J0cy5Gb2N1c0xvc3RFdmVudCA9IEZvY3VzTG9zdEV2ZW50O1xuLyoqXG4gKiBmb2N1cyBET00gaGVscGVyLlxuICovXG5leHBvcnRzLmZvY3VzID0gZnVuY3Rpb24gKHZpZXcsIGlkKSB7XG4gICAgdXRpbF8xLmdldEJ5SWQodmlldywgaWQpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUuZm9jdXMoKTsgfSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIFRoZSBmb3JtIG1vZHVsZSBkZWFscyB3aXRoIGNvbnRyb2xzIHNwZWNpZmljYWxseSBmb3IgYWNjZXB0aW5nIHVzZXIgaW5wdXQuXG4gKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIGZlZWRiYWNrXzEgPSByZXF1aXJlKFwiLi9mZWVkYmFja1wiKTtcbi8qKlxuICogQWJzdHJhY3RGb3JtQ29udHJvbCBwcm92aWRlcyBhIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYVxuICogRm9ybUNvbnRyb2wuXG4gKi9cbnZhciBBYnN0cmFjdEZvcm1Db250cm9sID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBYnN0cmFjdEZvcm1Db250cm9sLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFic3RyYWN0Rm9ybUNvbnRyb2woKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEFic3RyYWN0Rm9ybUNvbnRyb2w7XG59KGZlZWRiYWNrXzEuQWJzdHJhY3RGZWVkYmFja0NvbnRyb2wpKTtcbmV4cG9ydHMuQWJzdHJhY3RGb3JtQ29udHJvbCA9IEFic3RyYWN0Rm9ybUNvbnRyb2w7XG4vKipcbiAqIGdldExhYmVsIGV4dHJhY3RzIHRoZSBsYWJlbCB2YWx1ZSBmcm9tIEZyb21Db250cm9sQXR0cnMuXG4gKi9cbmV4cG9ydHMuZ2V0TGFiZWwgPSBmdW5jdGlvbiAoYXR0cnMpIHsgcmV0dXJuIChhdHRycy53dyAmJiBhdHRycy53dy5sYWJlbCkgPyBhdHRycy53dy5sYWJlbCA6ICcnOyB9O1xuLyoqXG4gKiBzZXRNZXNzYWdlIGhlbHBlci5cbiAqXG4gKiBTZXRzIHRoZSBtZXNzYWdlIG9uIHRoZSBIZWxwIHdpZGdldC5cbiAqL1xuZXhwb3J0cy5zZXRNZXNzYWdlID0gZnVuY3Rpb24gKHZpZXcsIGlkLCBtc2cpIHtcbiAgICB1dGlsXzEuZ2V0QnlJZCh2aWV3LCBpZCkubWFwKGZ1bmN0aW9uIChoKSB7IGguc2V0TWVzc2FnZShtc2cpOyB9KTtcbn07XG4vKipcbiAqIHJlbW92ZU1lc3NhZ2UgaGVscGVyLlxuICpcbiAqIFJlbW92ZXMgdGhlIG1lc3NhZ2UgZnJvbSB0aGUgSGVscCB3aWRnZXQuXG4gKi9cbmV4cG9ydHMucmVtb3ZlTWVzc2FnZSA9IGZ1bmN0aW9uICh2aWV3LCBpZCkge1xuICAgIHV0aWxfMS5nZXRCeUlkKHZpZXcsIGlkKS5tYXAoZnVuY3Rpb24gKGgpIHsgaC5yZW1vdmVNZXNzYWdlKCk7IH0pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIGZlZWRiYWNrXzEgPSByZXF1aXJlKFwiLi4vZmVlZGJhY2tcIik7XG52YXIgX18xID0gcmVxdWlyZShcIi4uLy4uL1wiKTtcbnZhciBoZWxwXzEgPSByZXF1aXJlKFwiLi93bWwvaGVscFwiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuSEVMUCA9ICd3dy1oZWxwJztcbi8qKlxuICogSGVscFxuICovXG52YXIgSGVscCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSGVscCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIZWxwKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyBoZWxwXzEuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGhlbHA6IHtcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdoZWxwJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaWQ6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5pZCkgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5pZCA6ICcnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogdXRpbF8xLmNvbmNhdChleHBvcnRzLkhFTFAsIF9fMS5nZXRDbGFzc05hbWUoX3RoaXMuYXR0cnMpKSxcbiAgICAgICAgICAgICAgICB0ZXh0OiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cudGV4dCkgP1xuICAgICAgICAgICAgICAgICAgICBbZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoX3RoaXMuYXR0cnMud3cudGV4dCldIDogX3RoaXMuY2hpbGRyZW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBIZWxwLnByb3RvdHlwZS5zZXRNZXNzYWdlID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICBmZWVkYmFja18xLnNldE1lc3NhZ2UodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5oZWxwLndtbC5pZCwgbXNnKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBIZWxwLnByb3RvdHlwZS5yZW1vdmVNZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmZWVkYmFja18xLnJlbW92ZU1lc3NhZ2UodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5oZWxwLndtbC5pZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIEhlbHA7XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5IZWxwID0gSGVscDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fc3ByZWFkQXJyYXlzID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5cykgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcbiAgICByZXR1cm4gcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnc3BhbicsIHsgaHRtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmhlbHAuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuaGVscC5jbGFzc05hbWUgfSwgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuaGVscC53bWwuaWQgfSB9LCBfX3NwcmVhZEFycmF5cygoX19jb250ZXh0LnZhbHVlcy5oZWxwLnRleHQpKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFRoaXMgbW9kdWxlIHByb3ZpZGVzIHRoZSBwYXJlbnQgaW50ZXJmYWNlcyBmb3IgbW9zdCBvZiB0aGVcbiAqIHdpZGdldHMgY29uc2lkZXJlZCAnY29udHJvbHMnLlxuICpcbiAqIENvbnRyb2xzIGFsbG93IHVzZXJzIHRvIG1hbmlwdWxhdGUgdGhlIHN0YXRlIG9mIGFuIGFwcGxpY2F0aW9uXG4gKiBieSBpbnRlcmFjdGluZyB3aXRoIHdpZGdldHMgb24gc2NyZWVuLiBJbiBzaW1wbGVyIHRlcm1zLFxuICogdGhleSBhcmUgdGhlIHdpZGdldHMgdGhhdCBhY2NlcHQgdXNlciBpbnB1dCBvciB0cmlnZ2VyXG4gKiByZWFjdGlvbnMgd2hlbiB0aGUgdXNlciBtYW5pcHVsYXRlcyB0aGVtLlxuICpcbiAqIEdlbmVyYWxseSwgd2UgdXNlIGEgc3RyZWFtaW5nIGJhc2VkIHdvcmtmbG93LCB0aGF0IGlzXG4gKiBhcyB0aGUgdXNlciBwcmVmb3JtcyBhIHN1cHBvcnRlZCBhY3Rpb24gYW5kIGV2ZW50IGlzIGdlbmVyYXRlZFxuICogZWFjaCBhbmQgZXZlcnkgdGltZSBhbmQgc29tZSBoYW5kbGVyIGlzIGFwcGxpZWQgdG8gdGhlIGV2ZW50LlxuICovXG4vKiogQGltcG9ydHMgKi9cbnZhciB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vKipcbiAqIEV2ZW50IGlzIHRoZSBwYXJlbnQgY2xhc3Mgb2YgYWxsIGV2ZW50cyBnZW5lcmF0ZWQgYnkgY29udHJvbHMuXG4gKi9cbnZhciBFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFdmVudChuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBFdmVudDtcbn0oKSk7XG5leHBvcnRzLkV2ZW50ID0gRXZlbnQ7XG4vKipcbiAqIEFic3RyYWN0Q29udHJvbCBpbXBsZW1lbnRzIHRoZSBtZXRob2RzIG9mIHRoZSBDb250cm9sIGludGVyZmFjZS5cbiAqL1xudmFyIEFic3RyYWN0Q29udHJvbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWJzdHJhY3RDb250cm9sLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFic3RyYWN0Q29udHJvbCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQWJzdHJhY3RDb250cm9sO1xufSh3bWxfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuQWJzdHJhY3RDb250cm9sID0gQWJzdHJhY3RDb250cm9sO1xuLyoqXG4gKiBnZXROYW1lXG4gKi9cbmV4cG9ydHMuZ2V0TmFtZSA9IGZ1bmN0aW9uIChhdHRycykge1xuICAgIHJldHVybiAoYXR0cnMud3cgJiYgYXR0cnMud3cubmFtZSkgPyBhdHRycy53dy5uYW1lIDogJyc7XG59O1xuLyoqXG4gKiBnZXREaXNhYmxlZFxuICovXG5leHBvcnRzLmdldERpc2FibGVkID0gZnVuY3Rpb24gKGF0dHJzKSB7XG4gICAgcmV0dXJuIChhdHRycy53dyAmJiBhdHRycy53dy5kaXNhYmxlZCkgPyBhdHRycy53dy5kaXNhYmxlZCA6IHVuZGVmaW5lZDtcbn07XG4vKipcbiAqIGdldFZhbHVlXG4gKi9cbmV4cG9ydHMuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoYXR0cnMpIHtcbiAgICByZXR1cm4gKGF0dHJzLnd3ICYmIGF0dHJzLnd3LnZhbHVlKSA/IG1heWJlXzEuanVzdChhdHRycy53dy52YWx1ZSkgOiBtYXliZV8xLm5vdGhpbmcoKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgX18xID0gcmVxdWlyZShcIi4uLy4uL1wiKTtcbnZhciBsYWJlbF8xID0gcmVxdWlyZShcIi4vd21sL2xhYmVsXCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5MQUJFTCA9ICd3dy1sYWJlbCc7XG4vKipcbiAqIExhYmVsXG4gKi9cbnZhciBMYWJlbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGFiZWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGFiZWwoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IGxhYmVsXzEuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiB1dGlsXzEuY29uY2F0KGV4cG9ydHMuTEFCRUwsIF9fMS5nZXRDbGFzc05hbWUoX3RoaXMuYXR0cnMpKSxcbiAgICAgICAgICAgICAgICBmb3I6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5mb3IpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuZm9yIDogJycsXG4gICAgICAgICAgICAgICAgdGV4dDogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnRleHQpID9cbiAgICAgICAgICAgICAgICAgICAgW2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKF90aGlzLmF0dHJzLnd3LnRleHQpXSA6IF90aGlzLmNoaWxkcmVuXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIExhYmVsO1xufSh3bWxfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuTGFiZWwgPSBMYWJlbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fc3ByZWFkQXJyYXlzID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5cykgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcbiAgICByZXR1cm4gcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnbGFiZWwnLCB7IGh0bWw6IHsgJ2Zvcic6IF9fY29udGV4dC52YWx1ZXMubGFiZWwuZm9yLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmxhYmVsLmNsYXNzTmFtZSB9LCB3bWw6IHt9IH0sIF9fc3ByZWFkQXJyYXlzKChfX2NvbnRleHQudmFsdWVzLmxhYmVsLnRleHQpKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYWJlbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL211bHRpLXNlbGVjdFwiKTtcbnZhciBvcmllbnRhdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRlbnQvb3JpZW50YXRpb25cIik7XG52YXIgZm9ybV8xID0gcmVxdWlyZShcIi4uL2Zvcm1cIik7XG52YXIgc2VhcmNoXzEgPSByZXF1aXJlKFwiLi4vc2VhcmNoXCIpO1xuZXhwb3J0cy5UZXJtQ2hhbmdlZEV2ZW50ID0gc2VhcmNoXzEuVGVybUNoYW5nZWRFdmVudDtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBfXzEgPSByZXF1aXJlKFwiLi4vLi4vXCIpO1xudmFyIF9fMiA9IHJlcXVpcmUoXCIuLi9cIik7XG52YXIgZmVlZGJhY2tfMSA9IHJlcXVpcmUoXCIuLi9mZWVkYmFja1wiKTtcbnZhciBhY3RpdmVfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZW50L3N0YXRlL2FjdGl2ZVwiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuTVVMVElfU0VMRUNUID0gJ3d3LW11bHRpLXNlbGVjdCc7XG5leHBvcnRzLk1VTFRJX1NFTEVDVF9DT05URU5UID0gJ3d3LW11bHRpLXNlbGVjdF9fY29udGVudCc7XG5leHBvcnRzLk1VTFRJX1NFTEVDVF9JTlBVVCA9ICd3dy1tdWx0aS1zZWxlY3RfX2lucHV0JztcbmV4cG9ydHMuTVVMVElfU0VMRUNUX1RBRyA9ICd3dy1tdWx0aS1zZWxlY3RfX3RhZyc7XG4vLy9jbGFzc05hbWVzOmVuZFxuZXhwb3J0cy5ERUZBVUxUX0lOUFVUX1dJRFRIID0gNTA7XG5leHBvcnRzLkRFRkFVTFRfRk9OVF9JTkNSRU1FTlQgPSA3O1xuLyoqXG4gKiBJdGVtc0NoYW5nZWRFdmVudFxuICovXG52YXIgSXRlbXNDaGFuZ2VkRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEl0ZW1zQ2hhbmdlZEV2ZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEl0ZW1zQ2hhbmdlZEV2ZW50KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBJdGVtc0NoYW5nZWRFdmVudDtcbn0oX18yLkV2ZW50KSk7XG5leHBvcnRzLkl0ZW1zQ2hhbmdlZEV2ZW50ID0gSXRlbXNDaGFuZ2VkRXZlbnQ7XG4vKipcbiAqIE11bHRpU2VsZWN0XG4gKi9cbnZhciBNdWx0aVNlbGVjdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTXVsdGlTZWxlY3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTXVsdGlTZWxlY3QoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAncm9vdCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlkOiBfXzEuZ2V0SWQoX3RoaXMuYXR0cnMpLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogdXRpbF8xLmNvbmNhdChleHBvcnRzLk1VTFRJX1NFTEVDVCwgX18xLmdldENsYXNzTmFtZShfdGhpcy5hdHRycyksIGZlZWRiYWNrXzEuZ2V0VmFsaWRpdHlDbGFzc05hbWUoX3RoaXMuYXR0cnMpLCBvcmllbnRhdGlvbl8xLmdldEJsb2NrQ2xhc3NOYW1lKF90aGlzLmF0dHJzKSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250cm9sOiB7XG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAncm9vdCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdsYWJlbCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRleHQ6IGZvcm1fMS5nZXRMYWJlbChfdGhpcy5hdHRycylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWFyY2g6IHtcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdzZWFyY2gnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBibG9jazogX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuYmxvY2sgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGl0ZW1UZW1wbGF0ZTogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lml0ZW1UZW1wbGF0ZSkgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5pdGVtVGVtcGxhdGUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbm9JdGVtc1RlbXBsYXRlOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cubm9JdGVtc1RlbXBsYXRlKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3Lm5vSXRlbXNUZW1wbGF0ZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBvblNlYXJjaDogZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cub25TZWFyY2gpXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5vblNlYXJjaChldnQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25TZWxlY3Q6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmZpcmVDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVkcmF3KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAnbWVzc2FnZSdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRleHQ6IGZlZWRiYWNrXzEuZ2V0TWVzc2FnZShfdGhpcy5hdHRycylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBleHBvcnRzLk1VTFRJX1NFTEVDVF9DT05URU5ULFxuICAgICAgICAgICAgICAgIG9uZm9jdXM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmZvY3VzKCk7IH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0YWdzOiB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiB1dGlsXzEuY29uY2F0KGV4cG9ydHMuTVVMVElfU0VMRUNUX1RBRywgZmVlZGJhY2tfMS5nZXRWYWxpZGl0eUNsYXNzTmFtZShfdGhpcy5hdHRycykpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBbXSxcbiAgICAgICAgICAgICAgICBoYXM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnZhbHVlcy50YWdzLnZhbHVlLmxlbmd0aCA+IDA7IH0sXG4gICAgICAgICAgICAgICAgZ2V0VGV4dDogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnN0cmluZ2lmaWVyKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LnN0cmluZ2lmaWVyIDogZnVuY3Rpb24gKHYpIHsgcmV0dXJuIFN0cmluZyh2KTsgfSxcbiAgICAgICAgICAgICAgICBvbkRpc21pc3M6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSBOdW1iZXIoZS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmFsdWVzLnRhZ3MudmFsdWUuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmZpcmVDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVkcmF3KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlucHV0OiB7XG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAnaW5wdXQnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGV4cG9ydHMuTVVMVElfU0VMRUNUX0lOUFVULFxuICAgICAgICAgICAgICAgIG5hbWU6IF9fMi5nZXROYW1lKF90aGlzLmF0dHJzKSxcbiAgICAgICAgICAgICAgICBpbnB1dFdpZHRoOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuaW5wdXRXaWR0aCkgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5pbnB1dFdpZHRoIDogZXhwb3J0cy5ERUZBVUxUX0lOUFVUX1dJRFRILFxuICAgICAgICAgICAgICAgIGZvbnRJbmNyZW1lbnQ6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5mb250SW5jcmVtZW50KSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LmZvbnRJbmNyZW1lbnQgOiBleHBvcnRzLkRFRkFVTFRfRk9OVF9JTkNSRU1FTlQsXG4gICAgICAgICAgICAgICAgb25TZWFyY2g6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmdyb3coZS52YWx1ZS5sZW5ndGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm9uU2VhcmNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cub25TZWFyY2goZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lbnU6IHtcbiAgICAgICAgICAgICAgICB3bWw6IHsgaWQ6ICdtZW51JyB9LFxuICAgICAgICAgICAgICAgIG5hbWU6IF9fMi5nZXROYW1lKF90aGlzLmF0dHJzKSxcbiAgICAgICAgICAgICAgICBibG9jazogdHJ1ZSxcbiAgICAgICAgICAgICAgICBvblNlbGVjdDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmFsdWVzLnRhZ3MudmFsdWUucHVzaChlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZmlyZUNoYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWRyYXcoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGl0ZW1UZW1wbGF0ZTogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lml0ZW1UZW1wbGF0ZSkgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5pdGVtVGVtcGxhdGUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbm9JdGVtc1RlbXBsYXRlOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cubm9JdGVtc1RlbXBsYXRlKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3Lm5vSXRlbXNUZW1wbGF0ZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBzdHJpbmdpZmllcjogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnN0cmluZ2lmaWVyKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LnN0cmluZ2lmaWVyIDogdW5kZWZpbmVkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBNdWx0aVNlbGVjdC5wcm90b3R5cGUuZmlyZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuYXR0cnMud3cgJiYgdGhpcy5hdHRycy53dy5vbkNoYW5nZSlcbiAgICAgICAgICAgIHRoaXMuYXR0cnMud3cub25DaGFuZ2UobmV3IEl0ZW1zQ2hhbmdlZEV2ZW50KF9fMi5nZXROYW1lKHRoaXMuYXR0cnMpLCB0aGlzLnZhbHVlcy50YWdzLnZhbHVlLnNsaWNlKCkpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgTXVsdGlTZWxlY3QucHJvdG90eXBlLmdyb3cgPSBmdW5jdGlvbiAobikge1xuICAgICAgICB2YXIgbUlucHV0ID0gdXRpbF8xLmdldEJ5SWQodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5pbnB1dC53bWwuaWQpO1xuICAgICAgICBpZiAobUlucHV0LmlzTm90aGluZygpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgaSA9IG1JbnB1dC5nZXQoKTtcbiAgICAgICAgdmFyIG1Eb20gPSB1dGlsXzEuZ2V0QnlJZChpLnZpZXcsIGkudmFsdWVzLndtbC5pZCk7XG4gICAgICAgIGlmIChtRG9tLmlzTm90aGluZygpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgZG9tID0gbURvbS5nZXQoKTtcbiAgICAgICAgZG9tLnN0eWxlLndpZHRoID0gbiAqIHRoaXMudmFsdWVzLmlucHV0LmZvbnRJbmNyZW1lbnQgKyBcInB4XCI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE11bHRpU2VsZWN0LnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmlldy5pbnZhbGlkYXRlKCk7XG4gICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBNdWx0aVNlbGVjdC5wcm90b3R5cGUuc2V0TWVzc2FnZSA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgZm9ybV8xLnNldE1lc3NhZ2UodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5tZXNzYWdlcy53bWwuaWQsIG1zZyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgTXVsdGlTZWxlY3QucHJvdG90eXBlLnJlbW92ZU1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvcm1fMS5yZW1vdmVNZXNzYWdlKHRoaXMudmlldywgdGhpcy52YWx1ZXMubWVzc2FnZXMud21sLmlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBNdWx0aVNlbGVjdC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHJlc3VsdHMpIHtcbiAgICAgICAgc2VhcmNoXzEudXBkYXRlTWVudSh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLm1lbnUud21sLmlkLCByZXN1bHRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBNdWx0aVNlbGVjdC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VhcmNoXzEub3Blbk1lbnUodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5tZW51LndtbC5pZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgTXVsdGlTZWxlY3QucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWFyY2hfMS5jbG9zZU1lbnUodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5tZW51LndtbC5pZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgTXVsdGlTZWxlY3QucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBnZXRJbnB1dCh0aGlzKS5tYXAoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGkuZm9jdXMoKTsgfSk7XG4gICAgICAgIGdldFJvb3QodGhpcykubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLmNsYXNzTGlzdC5hZGQoYWN0aXZlXzEuQUNUSVZFKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogcHVzaCBhIHZhbHVlIG9udG8gdGhlIGVuZCBvZiB0aGUgaW50ZXJuYWwgc3RhY2suXG4gICAgICovXG4gICAgTXVsdGlTZWxlY3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZXMudGFncy52YWx1ZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgdGhpcy5maXJlQ2hhbmdlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIE11bHRpU2VsZWN0O1xufShmb3JtXzEuQWJzdHJhY3RGb3JtQ29udHJvbCkpO1xuZXhwb3J0cy5NdWx0aVNlbGVjdCA9IE11bHRpU2VsZWN0O1xudmFyIGdldElucHV0ID0gZnVuY3Rpb24gKG0pIHtcbiAgICByZXR1cm4gdXRpbF8xLmdldEJ5SWQobS52aWV3LCBtLnZhbHVlcy5pbnB1dC53bWwuaWQpO1xufTtcbnZhciBnZXRSb290ID0gZnVuY3Rpb24gKG0pIHtcbiAgICByZXR1cm4gdXRpbF8xLmdldEJ5SWQobS52aWV3LCBtLnZhbHVlcy5yb290LndtbC5pZCk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19zcHJlYWRBcnJheXMgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xuICAgIHJldHVybiByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBsYWJlbF8xID0gcmVxdWlyZShcIi4uLy4uL2xhYmVsXCIpO1xuO1xudmFyIGhlbHBfMSA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwXCIpO1xuO1xudmFyIHRhZ18xID0gcmVxdWlyZShcIi4uLy4uL3RhZ1wiKTtcbjtcbnZhciBzZWFyY2hfMSA9IHJlcXVpcmUoXCIuLi8uLi9zZWFyY2hcIik7XG47XG52YXIgcmVzdWx0c19tZW51XzEgPSByZXF1aXJlKFwiLi4vLi4vcmVzdWx0cy1tZW51XCIpO1xuO1xudmFyIF9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9cIik7XG47XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnZGl2JywgeyBodG1sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMucm9vdC5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5yb290LmNsYXNzTmFtZSB9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGxhYmVsXzEuTGFiZWwsIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdmb3InOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuaWQsICd0ZXh0JzogX19jb250ZXh0LnZhbHVlcy5sYWJlbC50ZXh0IH0gfSwgW10pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdkaXYnLCB7IGh0bWw6IHsgJ29uY2xpY2snOiBfX2NvbnRleHQudmFsdWVzLmNvbnRlbnQub25mb2N1cywgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jb250ZW50LmNsYXNzTmFtZSB9LCB3bWw6IHt9IH0sIF9fc3ByZWFkQXJyYXlzKChfX2lmKF9fY29udGV4dC52YWx1ZXMudGFncy5oYXMoKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gKF9fc3ByZWFkQXJyYXlzKF9fZm9ySW4oX19jb250ZXh0LnZhbHVlcy50YWdzLnZhbHVlLCBmdW5jdGlvbiAodmFsdWUsIGlkeCwgXyQkYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldCh0YWdfMS5UYWcsIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICduYW1lJzogU3RyaW5nKGlkeCksICd0ZXh0JzogX19jb250ZXh0LnZhbHVlcy50YWdzLmdldFRleHQodmFsdWUpLCAnY2xhc3NOYW1lJzogX19jb250ZXh0LnZhbHVlcy50YWdzLmNsYXNzTmFtZSwgJ29uRGlzbWlzcyc6IF9fY29udGV4dC52YWx1ZXMudGFncy5vbkRpc21pc3MgfSB9LCBbXSlcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gKFtdKTsgfSkpKTsgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gKFtcbiAgICAgICAgICAgICAgICAgICAgX18xLnRleHQoXCJcIilcbiAgICAgICAgICAgICAgICBdKTsgfSkpLCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoc2VhcmNoXzEuSW5wdXQsIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmlucHV0LndtbC5pZCB9LCB3dzogeyAnY2xhc3NOYW1lJzogX19jb250ZXh0LnZhbHVlcy5pbnB1dC5jbGFzc05hbWUsICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5pbnB1dC5uYW1lLCAnb25TZWFyY2gnOiBfX2NvbnRleHQudmFsdWVzLmlucHV0Lm9uU2VhcmNoIH0gfSwgW10pXG4gICAgICAgICAgICAgICAgXSkpLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQocmVzdWx0c19tZW51XzEuUmVzdWx0c01lbnUsIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLm1lbnUud21sLmlkIH0sIHd3OiB7ICdibG9jayc6IF9fY29udGV4dC52YWx1ZXMubWVudS5ibG9jaywgJ29uU2VsZWN0JzogX19jb250ZXh0LnZhbHVlcy5tZW51Lm9uU2VsZWN0LCAnbm9JdGVtc1RlbXBsYXRlJzogX19jb250ZXh0LnZhbHVlcy5tZW51Lm5vSXRlbXNUZW1wbGF0ZSwgJ2l0ZW1zVGVtcGxhdGUnOiBfX2NvbnRleHQudmFsdWVzLm1lbnUuaXRlbVRlbXBsYXRlLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLm1lbnUuc3RyaW5naWZpZXIgfSB9LCBbXSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChoZWxwXzEuSGVscCwgeyBodG1sOiB7fSwgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMubWVzc2FnZXMud21sLmlkIH0sIHd3OiB7ICd0ZXh0JzogX19jb250ZXh0LnZhbHVlcy5tZXNzYWdlcy50ZXh0IH0gfSwgW10pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgTWFpbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIE1haW47XG59KCkpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11bHRpLXNlbGVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgX18xID0gcmVxdWlyZShcIi4uLy4uL1wiKTtcbnZhciBfXzIgPSByZXF1aXJlKFwiLi4vXCIpO1xudmFyIHBhZ2luYXRvcl8xID0gcmVxdWlyZShcIi4vd21sL3BhZ2luYXRvclwiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuUEFHSU5BVE9SID0gJ3d3LXBhZ2luYXRvcic7XG5leHBvcnRzLlBBR0lOQVRPUl9GSVJTVCA9ICd3dy1wYWdpbmF0b3JfX2ZpcnN0JztcbmV4cG9ydHMuUEFHSU5BVE9SX1BSRVZJT1VTID0gJ3d3LXBhZ2luYXRvcl9fcHJldmlvdXMnO1xuZXhwb3J0cy5QQUdJTkFUT1JfUE9TSVRJT04gPSAnd3ctcGFnaW5hdG9yX19wb3NpdGlvbic7XG5leHBvcnRzLlBBR0lOQVRPUl9ORVhUID0gJ3d3LXBhZ2luYXRvcl9fbmV4dCc7XG5leHBvcnRzLlBBR0lOQVRPUl9MQVNUID0gJ3d3LXBhZ2luYXRvcl9fbGFzdCc7XG4vKipcbiAqIFBhZ2VDaGFuZ2VkRXZlbnQgaW5kaWNhdGluZyB0aGUgY3VycmVudCBwYWdlIGhhcyBiZWVuIGNoYW5nZWQuXG4gKi9cbnZhciBQYWdlQ2hhbmdlZEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQYWdlQ2hhbmdlZEV2ZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBhZ2VDaGFuZ2VkRXZlbnQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFBhZ2VDaGFuZ2VkRXZlbnQ7XG59KF9fMi5FdmVudCkpO1xuZXhwb3J0cy5QYWdlQ2hhbmdlZEV2ZW50ID0gUGFnZUNoYW5nZWRFdmVudDtcbi8qKlxuICogUGFnaW5hdG9yIHByb3ZpZGVzIGEgY29udHJvbCBmb3IgbmF2aWdhdGluZyBwYWdlZCBkYXRhLCByZXN1bHRzLCB2aWV3IGV0Yy5cbiAqL1xudmFyIFBhZ2luYXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGFnaW5hdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBhZ2luYXRvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgcGFnaW5hdG9yXzEuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiBfXzEuZ2V0SWQoX3RoaXMuYXR0cnMpLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiB1dGlsXzEuY29uY2F0KGV4cG9ydHMuUEFHSU5BVE9SLCBfXzEuZ2V0Q2xhc3NOYW1lKF90aGlzLmF0dHJzKSksXG4gICAgICAgICAgICBjdXJyZW50OiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5jdXJyZW50KSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LmN1cnJlbnQgOiAxLFxuICAgICAgICAgICAgICAgIGFzU3RyaW5nOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnJyArIF90aGlzLnZhbHVlcy5jdXJyZW50LnZhbHVlOyB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG90YWw6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy50b3RhbCkgP1xuICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LnRvdGFsIDogMSxcbiAgICAgICAgICAgIGZpcnN0OiB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBleHBvcnRzLlBBR0lOQVRPUl9GSVJTVCxcbiAgICAgICAgICAgICAgICBpc0Rpc2FibGVkOiBmdW5jdGlvbiAoKSB7IHJldHVybiAoX3RoaXMudmFsdWVzLmN1cnJlbnQudmFsdWUgPD0gMSk7IH0sXG4gICAgICAgICAgICAgICAgb25jbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZXMuY3VycmVudC52YWx1ZSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmZpcmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJldmlvdXM6IHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGV4cG9ydHMuUEFHSU5BVE9SX1BSRVZJT1VTLFxuICAgICAgICAgICAgICAgIGlzRGlzYWJsZWQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIChfdGhpcy52YWx1ZXMuY3VycmVudC52YWx1ZSA8PSAxKTsgfSxcbiAgICAgICAgICAgICAgICBvbmNsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnZhbHVlcy5jdXJyZW50LnZhbHVlID0gX3RoaXMudmFsdWVzLmN1cnJlbnQudmFsdWUgLSAxO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5maXJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBleHBvcnRzLlBBR0lOQVRPUl9QT1NJVElPTlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5leHQ6IHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGV4cG9ydHMuUEFHSU5BVE9SX05FWFQsXG4gICAgICAgICAgICAgICAgaXNEaXNhYmxlZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKF90aGlzLnZhbHVlcy5jdXJyZW50LnZhbHVlID49IF90aGlzLnZhbHVlcy50b3RhbCk7IH0sXG4gICAgICAgICAgICAgICAgb25jbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZXMuY3VycmVudC52YWx1ZSA9IF90aGlzLnZhbHVlcy5jdXJyZW50LnZhbHVlICsgMTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZmlyZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYXN0OiB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBleHBvcnRzLlBBR0lOQVRPUl9MQVNULFxuICAgICAgICAgICAgICAgIGlzRGlzYWJsZWQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIChfdGhpcy52YWx1ZXMuY3VycmVudC52YWx1ZSA+PSBfdGhpcy52YWx1ZXMudG90YWwpOyB9LFxuICAgICAgICAgICAgICAgIG9uY2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmFsdWVzLmN1cnJlbnQudmFsdWUgPSBfdGhpcy52YWx1ZXMudG90YWw7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmZpcmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBQYWdpbmF0b3IucHJvdG90eXBlLmZpcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmF0dHJzLnd3ICYmIHRoaXMuYXR0cnMud3cub25DaGFuZ2UpXG4gICAgICAgICAgICB0aGlzLmF0dHJzLnd3Lm9uQ2hhbmdlKG5ldyBQYWdlQ2hhbmdlZEV2ZW50KHRoaXMuYXR0cnMud3cubmFtZSB8fCAnJywgdGhpcy52YWx1ZXMuY3VycmVudC52YWx1ZSkpO1xuICAgICAgICB0aGlzLnZpZXcuaW52YWxpZGF0ZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFBhZ2luYXRvcjtcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLlBhZ2luYXRvciA9IFBhZ2luYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fc3ByZWFkQXJyYXlzID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5cykgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcbiAgICByZXR1cm4gcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX18xID0gcmVxdWlyZShcIi4uLy4uLy4uL1wiKTtcbjtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCd1bCcsIHsgaHRtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmNsYXNzTmFtZSB9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnbGknLCB7IGh0bWw6IHsgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5maXJzdC5jbGFzc05hbWUgfSwgd21sOiB7fSB9LCBfX3NwcmVhZEFycmF5cygoX19pZihfX2NvbnRleHQudmFsdWVzLmZpcnN0LmlzRGlzYWJsZWQoKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gKFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3NwYW4nLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtdKVxuICAgICAgICAgICAgICAgIF0pOyB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiAoW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnYScsIHsgaHRtbDogeyAnaHJlZic6IFwiI1wiLCAnb25jbGljayc6IF9fY29udGV4dC52YWx1ZXMuZmlyc3Qub25jbGljayB9LCB3bWw6IHt9IH0sIFtdKVxuICAgICAgICAgICAgICAgIF0pOyB9KSkpKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnbGknLCB7IGh0bWw6IHsgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5wcmV2aW91cy5jbGFzc05hbWUgfSwgd21sOiB7fSB9LCBfX3NwcmVhZEFycmF5cygoX19pZihfX2NvbnRleHQudmFsdWVzLnByZXZpb3VzLmlzRGlzYWJsZWQoKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gKFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3NwYW4nLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtdKVxuICAgICAgICAgICAgICAgIF0pOyB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiAoW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnYScsIHsgaHRtbDogeyAnaHJlZic6IFwiI1wiLCAnb25jbGljayc6IF9fY29udGV4dC52YWx1ZXMucHJldmlvdXMub25jbGljayB9LCB3bWw6IHt9IH0sIFtdKVxuICAgICAgICAgICAgICAgIF0pOyB9KSkpKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnbGknLCB7IGh0bWw6IHsgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5wb3NpdGlvbi5jbGFzc05hbWUgfSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdzcGFuJywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlBhZ2UgXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2lucHV0JywgeyBodG1sOiB7ICd2YWx1ZSc6IF9fY29udGV4dC52YWx1ZXMuY3VycmVudC5hc1N0cmluZygpIH0sIHdtbDoge30gfSwgW10pLFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCIgb2YgXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgX18xLnRleHQoX19jb250ZXh0LnZhbHVlcy50b3RhbClcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnbGknLCB7IGh0bWw6IHsgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5uZXh0LmNsYXNzTmFtZSB9LCB3bWw6IHt9IH0sIF9fc3ByZWFkQXJyYXlzKChfX2lmKF9fY29udGV4dC52YWx1ZXMubmV4dC5pc0Rpc2FibGVkKCksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIChbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdzcGFuJywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXSlcbiAgICAgICAgICAgICAgICBdKTsgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gKFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2EnLCB7IGh0bWw6IHsgJ2hyZWYnOiBcIiNcIiwgJ29uY2xpY2snOiBfX2NvbnRleHQudmFsdWVzLm5leHQub25jbGljayB9LCB3bWw6IHt9IH0sIFtdKVxuICAgICAgICAgICAgICAgIF0pOyB9KSkpKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnbGknLCB7IGh0bWw6IHsgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5sYXN0LmNsYXNzTmFtZSB9LCB3bWw6IHt9IH0sIF9fc3ByZWFkQXJyYXlzKChfX2lmKF9fY29udGV4dC52YWx1ZXMubGFzdC5pc0Rpc2FibGVkKCksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIChbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdzcGFuJywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXSlcbiAgICAgICAgICAgICAgICBdKTsgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gKFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2EnLCB7IGh0bWw6IHsgJ2hyZWYnOiBcIiNcIiwgJ29uY2xpY2snOiBfX2NvbnRleHQudmFsdWVzLmxhc3Qub25jbGljayB9LCB3bWw6IHt9IH0sIFtdKVxuICAgICAgICAgICAgICAgIF0pOyB9KSkpKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWdpbmF0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xudmFyIHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgX18xID0gcmVxdWlyZShcIi4uL1wiKTtcbnZhciByZXN1bHRzX21lbnVfMSA9IHJlcXVpcmUoXCIuL3dtbC9yZXN1bHRzLW1lbnVcIik7XG4vKipcbiAqIEl0ZW1TZWxlY3RlZEV2ZW50XG4gKi9cbnZhciBJdGVtU2VsZWN0ZWRFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSXRlbVNlbGVjdGVkRXZlbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSXRlbVNlbGVjdGVkRXZlbnQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEl0ZW1TZWxlY3RlZEV2ZW50O1xufShfXzEuRXZlbnQpKTtcbmV4cG9ydHMuSXRlbVNlbGVjdGVkRXZlbnQgPSBJdGVtU2VsZWN0ZWRFdmVudDtcbi8qKlxuICogUmVzdWx0c01lbnUgdXNlZCB0byBkaXNwbGF5IHJlc3VsdHMgaW4gc2VsZWN0IHN0eWxlZCBjb250cm9scy5cbiAqL1xudmFyIFJlc3VsdHNNZW51ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZXN1bHRzTWVudSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZXN1bHRzTWVudSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgcmVzdWx0c19tZW51XzEuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgIGlkOiAnbWVudSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmVlOiBtYXliZV8xLm5vdGhpbmcoKSxcbiAgICAgICAgICAgIHJlc3VsdHM6IFtdLFxuICAgICAgICAgICAgbmFtZTogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm5hbWUpID9cbiAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5uYW1lIDogJycsXG4gICAgICAgICAgICBibG9jazogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmJsb2NrKSA/XG4gICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuYmxvY2sgOiBmYWxzZSxcbiAgICAgICAgICAgIGhpZGRlbjogdHJ1ZSxcbiAgICAgICAgICAgIGl0ZW06IHtcbiAgICAgICAgICAgICAgICBzdHJpbmdpZmllcjogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnN0cmluZ2lmaWVyKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LnN0cmluZ2lmaWVyIDogZnVuY3Rpb24gKHYpIHsgcmV0dXJuIE9iamVjdC50b1N0cmluZy5jYWxsKHYpOyB9LFxuICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm9uU2VsZWN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cub25TZWxlY3QobmV3IEl0ZW1TZWxlY3RlZEV2ZW50KF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm5hbWUgfHwgJycsIF90aGlzLnZhbHVlcy5yZXN1bHRzW2luZGV4XSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5pdGVtVGVtcGxhdGUpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3Lml0ZW1UZW1wbGF0ZSA6IHJlc3VsdHNfbWVudV8xLml0ZW1UZW1wbGF0ZShfdGhpcyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBub0l0ZW1zVGVtcGxhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5ub0l0ZW1zVGVtcGxhdGUpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3Lm5vSXRlbXNUZW1wbGF0ZSA6IHJlc3VsdHNfbWVudV8xLm5vSXRlbXNUZW1wbGF0ZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUmVzdWx0c01lbnUucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWxfMS5nZXRCeUlkKHRoaXMudmlldywgdGhpcy52YWx1ZXMud21sLmlkKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5zaG93KCk7IH0pO1xuICAgICAgICB0aGlzLnZhbHVlcy5oaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBSZXN1bHRzTWVudS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWxfMS5nZXRCeUlkKHRoaXMudmlldywgdGhpcy52YWx1ZXMud21sLmlkKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5oaWRlKCk7IH0pO1xuICAgICAgICB0aGlzLnZhbHVlcy5oaWRkZW4gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFJlc3VsdHNNZW51LnByb3RvdHlwZS5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlcy50cmVlLmlzSnVzdCgpKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IHRoaXMudmFsdWVzLnRyZWUuZ2V0KCk7XG4gICAgICAgICAgICBpZiAoIWRvY3VtZW50LmJvZHkuY29udGFpbnMocm9vdCkpXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzKTtcbiAgICAgICAgICAgIGlmICgoIXJvb3QuY29udGFpbnMoZS50YXJnZXQpKSlcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHVwZGF0ZSB3aWxsIGNhdXNlIHRoZSBtZW51IHRvIGJlIGRpc3BsYXllZC5cbiAgICAgKi9cbiAgICBSZXN1bHRzTWVudS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHJlc3VsdHMpIHtcbiAgICAgICAgdGhpcy52YWx1ZXMucmVzdWx0cyA9IHJlc3VsdHM7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMuaGlkZGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmlldy5pbnZhbGlkYXRlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgUmVzdWx0c01lbnUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy52YWx1ZXMudHJlZSA9IG1heWJlXzEuanVzdCh0aGlzLnZpZXcucmVuZGVyKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXMudHJlZS5nZXQoKTtcbiAgICB9O1xuICAgIHJldHVybiBSZXN1bHRzTWVudTtcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLlJlc3VsdHNNZW51ID0gUmVzdWx0c01lbnU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3NwcmVhZEFycmF5cyA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheXMpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxuICAgICAgICAgICAgcltrXSA9IGFbal07XG4gICAgcmV0dXJuIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9cIik7XG47XG52YXIgbGlua18xID0gcmVxdWlyZShcIi4uLy4uLy4uL2NvbnRlbnQvbGlua1wiKTtcbjtcbnZhciBtZW51XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vbWVudS9tZW51XCIpO1xuO1xudmFyIGl0ZW1fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9tZW51L2l0ZW1cIik7XG47XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbmV4cG9ydHMuaXRlbVRlbXBsYXRlID0gZnVuY3Rpb24gKHIpIHsgcmV0dXJuIGZ1bmN0aW9uIChvcHRpb24pIHsgcmV0dXJuIGZ1bmN0aW9uIChfaW5kZXgpIHsgcmV0dXJuIGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBfXzEudGV4dChyLnZhbHVlcy5pdGVtLnN0cmluZ2lmaWVyKG9wdGlvbikpXG4gICAgXTtcbn07IH07IH07IH07XG47XG5leHBvcnRzLm5vSXRlbXNUZW1wbGF0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBfX3RoaXMubm9kZSgnYicsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJObyByZXN1bHRzIHRvIGRpc3BsYXkuXCIpXG4gICAgICAgIF0pXG4gICAgXTtcbn07IH07XG47XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYWluKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX190aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChtZW51XzEuTWVudSwgeyBodG1sOiB7fSwgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMud21sLmlkIH0sIHd3OiB7ICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5uYW1lLCAnYmxvY2snOiBfX2NvbnRleHQudmFsdWVzLmJsb2NrLCAnaGlkZGVuJzogX19jb250ZXh0LnZhbHVlcy5oaWRkZW4gfSB9LCBfX3NwcmVhZEFycmF5cyhfX2ZvckluKF9fY29udGV4dC52YWx1ZXMucmVzdWx0cywgZnVuY3Rpb24gKHJlc3VsdCwgaW5kZXgsIF8kJGFsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGl0ZW1fMS5JdGVtLCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAnbmFtZSc6IChcIlwiICsgaW5kZXgpIH0gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChsaW5rXzEuTGluaywgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ29uQ2xpY2snOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2NvbnRleHQudmFsdWVzLml0ZW0uY2xpY2soaW5kZXgpOyB9IH0gfSwgX19zcHJlYWRBcnJheXMoKF9fY29udGV4dC52YWx1ZXMuaXRlbS50ZW1wbGF0ZSgpKHJlc3VsdCkoaW5kZXgpKF9fdGhpcykpKSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIChfX3NwcmVhZEFycmF5cygoX19jb250ZXh0LnZhbHVlcy5pdGVtLm5vSXRlbXNUZW1wbGF0ZSgpKF9fdGhpcykpKSk7IH0pKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXN1bHRzLW1lbnUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9zZWFyY2hcIik7XG52YXIgb3JpZW50YXRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZW50L29yaWVudGF0aW9uXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIHJlc3VsdHNfbWVudV8xID0gcmVxdWlyZShcIi4uL3Jlc3VsdHMtbWVudVwiKTtcbmV4cG9ydHMuSXRlbVNlbGVjdGVkRXZlbnQgPSByZXN1bHRzX21lbnVfMS5JdGVtU2VsZWN0ZWRFdmVudDtcbnZhciBfXzEgPSByZXF1aXJlKFwiLi4vLi4vXCIpO1xudmFyIF9fMiA9IHJlcXVpcmUoXCIuLi9cIik7XG4vKipcbiAqIEVTQ0FQRSBrZXkgY29kZS5cbiAqL1xuZXhwb3J0cy5FU0NBUEUgPSAyNztcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuU0VBUkNIID0gJ3d3LXNlYXJjaCc7XG5leHBvcnRzLlNFQVJDSF9JTlBVVCA9ICd3dy1zZWFyY2hfX2lucHV0Jztcbi8qKlxuICogVGVybUNoYW5nZWRFdmVudCBzaWduYWxzIHRoZSBzZWFyY2ggdGVybSBoYXMgY2hhbmdlZC5cbiAqL1xudmFyIFRlcm1DaGFuZ2VkRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRlcm1DaGFuZ2VkRXZlbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGVybUNoYW5nZWRFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVGVybUNoYW5nZWRFdmVudDtcbn0oX18yLkV2ZW50KSk7XG5leHBvcnRzLlRlcm1DaGFuZ2VkRXZlbnQgPSBUZXJtQ2hhbmdlZEV2ZW50O1xuLyoqXG4gKiBGb2N1c0dhaW5lZEV2ZW50IHNpZ25hbHMgdGhlIHVzZXIgYXMgZ2l2ZW4gZm9jdXMgdG8gdGhlIGNvbnRyb2wuXG4gKi9cbnZhciBGb2N1c0dhaW5lZEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZvY3VzR2FpbmVkRXZlbnQobmFtZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cbiAgICByZXR1cm4gRm9jdXNHYWluZWRFdmVudDtcbn0oKSk7XG5leHBvcnRzLkZvY3VzR2FpbmVkRXZlbnQgPSBGb2N1c0dhaW5lZEV2ZW50O1xuLyoqXG4gKiBGb2N1c0xvc3RFdmVudCBzaWduYWxzIHRoZSB1c2VyIGhhcyByZW1vdmVkIGZvY3VzIGZyb20gdGhlIGNvbnRyb2wuXG4gKi9cbnZhciBGb2N1c0xvc3RFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGb2N1c0xvc3RFdmVudChuYW1lKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgfVxuICAgIHJldHVybiBGb2N1c0xvc3RFdmVudDtcbn0oKSk7XG5leHBvcnRzLkZvY3VzTG9zdEV2ZW50ID0gRm9jdXNMb3N0RXZlbnQ7XG4vKipcbiAqIEVzY2FwZUV2ZW50IHNpZ25hbHMgdGhlIHVzZXIgaGFzIHByZXNzZWQgdGhlIGVzY2FwZSBrZXkgd2hpbGUgdHlwaW5nLlxuICovXG52YXIgRXNjYXBlRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXNjYXBlRXZlbnQobmFtZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cbiAgICByZXR1cm4gRXNjYXBlRXZlbnQ7XG59KCkpO1xuZXhwb3J0cy5Fc2NhcGVFdmVudCA9IEVzY2FwZUV2ZW50O1xuLyoqXG4gKiBJbnB1dCBwcm92aWRlcyB0aGUgaW5wdXQgcGFydCBvZiBhIFNlYXJjaCBjb250cm9sLlxuICpcbiAqIFRoaXMgaXMgaGVyZSBtb3N0bHkgZm9yIGNvZGUgcmUtdXNlLlxuICovXG52YXIgSW5wdXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKElucHV0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIElucHV0KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5JbnB1dFZpZXcoX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICB3bWw6IHsgaWQ6ICdyb290JyB9LFxuICAgICAgICAgICAgY2xhc3NOYW1lOiB1dGlsXzEuY29uY2F0KGV4cG9ydHMuU0VBUkNIX0lOUFVULCBfXzEuZ2V0Q2xhc3NOYW1lKF90aGlzLmF0dHJzKSksXG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnBsYWNlaG9sZGVyKSA/XG4gICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cucGxhY2Vob2xkZXIgOiAnJyxcbiAgICAgICAgICAgIHJlYWRPbmx5OiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cucmVhZE9ubHkpIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGF1dG9jb21wbGV0ZTogJ2RvIG5vdCBlbmFibGUgcGxlYXNlJyxcbiAgICAgICAgICAgIHNpemU6IFN0cmluZygoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuc2l6ZSkgP1xuICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LnNpemUgOiAyMCksXG4gICAgICAgICAgICB2YWx1ZTogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnZhbHVlKSA/XG4gICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cudmFsdWUgOiAnJyxcbiAgICAgICAgICAgIG9uZm9jdXM6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5vbkZvY3VzKVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5vbkZvY3VzKG5ldyBGb2N1c0dhaW5lZEV2ZW50KF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm5hbWUgfHwgJycpKTtcbiAgICAgICAgICAgICAgICB0YXJnZXQudmFsdWUgPSB0YXJnZXQudmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25rZXlkb3duOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlLmtleUNvZGUgIT09IGV4cG9ydHMuRVNDQVBFKVxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cub25TZWFyY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lXzEgPSAnJyArIF90aGlzLmF0dHJzLnd3Lm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBlLnRhcmdldC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3Lm9uU2VhcmNoKG5ldyBUZXJtQ2hhbmdlZEV2ZW50KG5hbWVfMSwgdmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9ua2V5dXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gZXhwb3J0cy5FU0NBUEUpXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5vbkVzY2FwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3Lm9uRXNjYXBlKG5ldyBFc2NhcGVFdmVudChfdGhpcy5hdHRycy53dy5uYW1lIHx8ICcnKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25pbnB1dDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAvL0ZvciBjb21wYXRhYmlsaXR5IHJlYXNvbnNcbiAgICAgICAgICAgICAgICBlLnRhcmdldC5vbmlucHV0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZXMub25rZXlkb3duKGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uYmx1cjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5vbkJsdXIpXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3Lm9uQmx1cihuZXcgRm9jdXNMb3N0RXZlbnQoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cubmFtZSB8fCAnJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGZvY3VzIHN0ZWFscyB1c2VyIGZvY3VzIHRvIHRoZSBJbnB1dC5cbiAgICAgKi9cbiAgICBJbnB1dC5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGdldElucHV0KHRoaXMpLm1hcChmdW5jdGlvbiAoaSkgeyByZXR1cm4gaS5mb2N1cygpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBzZXRTaXplIHNldHMgdGhlIHNpemUgb2YgdGhlIGlucHV0LlxuICAgICAqL1xuICAgIElucHV0LnByb3RvdHlwZS5zZXRTaXplID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgdGhpcy52YWx1ZXMuc2l6ZSA9IFN0cmluZyhuKTtcbiAgICAgICAgZ2V0SW5wdXQodGhpcykubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiBpLnNldEF0dHJpYnV0ZSgnc2l6ZScsIFN0cmluZyhuKSk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGdldFNpemUgcmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgKGludGVybmFsbHkgdHJhY2tlZCkgc2l6ZVxuICAgICAqIG9mIHRoZSBJbnB1dC5cbiAgICAgKi9cbiAgICBJbnB1dC5wcm90b3R5cGUuZ2V0U2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcih0aGlzLnZhbHVlcy5zaXplKTtcbiAgICB9O1xuICAgIHJldHVybiBJbnB1dDtcbn0oX18yLkFic3RyYWN0Q29udHJvbCkpO1xuZXhwb3J0cy5JbnB1dCA9IElucHV0O1xuLyoqXG4gKiBTZWFyY2ggcHJvdmlkZXMgYW4gaW5wdXQgdGhhdCBjYW4gYmUgdXNlZCBpbiB0aGUgdWkgZm9yIGEgc2VhcmNoIGVuZ2luZS5cbiAqL1xudmFyIFNlYXJjaCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2VhcmNoLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNlYXJjaCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdyb290J1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaWQ6IF9fMS5nZXRJZChfdGhpcy5hdHRycyksXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiB1dGlsXzEuY29uY2F0KGV4cG9ydHMuU0VBUkNILCBfXzEuZ2V0Q2xhc3NOYW1lKF90aGlzLmF0dHJzKSwgb3JpZW50YXRpb25fMS5nZXRCbG9ja0NsYXNzTmFtZShfdGhpcy5hdHRycykpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5wdXQ6IHtcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdpbnB1dCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG5hbWU6IF9fMi5nZXROYW1lKF90aGlzLmF0dHJzKSxcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnBsYWNlaG9sZGVyKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LnBsYWNlaG9sZGVyIDogJycsXG4gICAgICAgICAgICAgICAgcmVhZE9ubHk6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5yZWFkT25seSkgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cudGVybSkgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy50ZXJtIDpcbiAgICAgICAgICAgICAgICAgICAgKF90aGlzLmF0dHJzLnd3ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5zdHJpbmdpZmllciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cudmFsdWUpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LnN0cmluZ2lmaWVyKF90aGlzLmF0dHJzLnd3LnZhbHVlKSA6ICcnLFxuICAgICAgICAgICAgICAgIG9uRm9jdXM6IF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm9uRm9jdXMgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG9uU2VhcmNoOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cub25TZWFyY2gpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cub25TZWFyY2ggOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgb25Fc2NhcGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNsb3NlKCk7IH0sXG4gICAgICAgICAgICAgICAgb25CbHVyOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cub25CbHVyKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3Lm9uQmx1ciA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lbnU6IHtcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdtZW51J1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbmFtZTogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm5hbWUpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cubmFtZSA6ICcnLFxuICAgICAgICAgICAgICAgIGJsb2NrOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuYmxvY2spID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuYmxvY2sgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBvblNlbGVjdDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm9uU2VsZWN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cub25TZWxlY3QoZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpdGVtVGVtcGxhdGU6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5pdGVtVGVtcGxhdGUpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuaXRlbVRlbXBsYXRlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG5vSXRlbXNUZW1wbGF0ZTogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm5vSXRlbXNUZW1wbGF0ZSkgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5ub0l0ZW1zVGVtcGxhdGUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgc3RyaW5naWZpZXI6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5zdHJpbmdpZmllcikgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5zdHJpbmdpZmllciA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNlYXJjaC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHV0aWxfMS5nZXRCeUlkKHRoaXMudmlldywgdGhpcy52YWx1ZXMucm9vdC53bWwuaWQpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChlKSB7IGUudmFsdWUgPSB2YWx1ZTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogdXBkYXRlIHRoZSBTZWxlY3Qgd2l0aCBuZXcgaXRlbSBvcHRpb25zIHRvXG4gICAgICogcHJlc2VudCB0byB0aGUgdXNlci5cbiAgICAgKi9cbiAgICBTZWFyY2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICAgIGV4cG9ydHMudXBkYXRlTWVudSh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLm1lbnUud21sLmlkLCByZXN1bHRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBvcGVuIHRoZSByZXN1bHRzIG1lbnUuXG4gICAgICovXG4gICAgU2VhcmNoLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBleHBvcnRzLm9wZW5NZW51KHRoaXMudmlldywgdGhpcy52YWx1ZXMubWVudS53bWwuaWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGNsb3NlIHRoZSByZXN1bHRzIG1lbnUuXG4gICAgICovXG4gICAgU2VhcmNoLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZXhwb3J0cy5jbG9zZU1lbnUodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5tZW51LndtbC5pZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIFNlYXJjaDtcbn0oX18yLkFic3RyYWN0Q29udHJvbCkpO1xuZXhwb3J0cy5TZWFyY2ggPSBTZWFyY2g7XG52YXIgZ2V0SW5wdXQgPSBmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiB1dGlsXzEuZ2V0QnlJZChpLnZpZXcsIGkudmFsdWVzLndtbC5pZCk7XG59O1xuLyoqXG4gKiB1cGRhdGVNZW51IHdpbGwgY2F1c2UgdGhlIG1lbnUgdG8gYmUgZGlzcGxheWVkIHdpdGggbmV3IGl0ZW1zLlxuICovXG5leHBvcnRzLnVwZGF0ZU1lbnUgPSBmdW5jdGlvbiAodmlldywgaWQsIHJlc3VsdHMpIHtcbiAgICB2YXIgbU1lbnUgPSB1dGlsXzEuZ2V0QnlJZCh2aWV3LCBpZCk7XG4gICAgaWYgKG1NZW51LmlzSnVzdCgpKVxuICAgICAgICBtTWVudS5nZXQoKS51cGRhdGUocmVzdWx0cyk7XG59O1xuLyoqXG4gKiBvcGVuTWVudSB3aWxsIGNhdXNlIHRoZSBtZW51IHRvIGJlIGRpc3BsYXllZCB3aXRoIHdoYXRldmVyIGNvbnRlbnRzXG4gKiB3ZXJlIHByZXZpb3VzbHkgc2V0LlxuICovXG5leHBvcnRzLm9wZW5NZW51ID0gZnVuY3Rpb24gKHZpZXcsIGlkKSB7XG4gICAgdXRpbF8xLmdldEJ5SWQodmlldywgaWQpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0ub3BlbigpOyB9KTtcbn07XG4vKipcbiAqIGNsb3NlTWVudSB3aWxsIGNhdXNlIHRoZSBtZW51IHRvIG5vIGxvbmdlciBiZSBkaXNwbGF5ZWQuXG4gKi9cbmV4cG9ydHMuY2xvc2VNZW51ID0gZnVuY3Rpb24gKHZpZXcsIGlkKSB7XG4gICAgdXRpbF8xLmdldEJ5SWQodmlldywgaWQpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0uY2xvc2UoKTsgfSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcmVzdWx0c19tZW51XzEgPSByZXF1aXJlKFwiLi4vLi4vcmVzdWx0cy1tZW51XCIpO1xuO1xudmFyIF9fMSA9IHJlcXVpcmUoXCIuLi9cIik7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBJbnB1dFZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW5wdXRWaWV3KF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX190aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ2lucHV0JywgeyBodG1sOiB7ICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuY2xhc3NOYW1lLCAnb25rZXlkb3duJzogX19jb250ZXh0LnZhbHVlcy5vbmtleWRvd24sICdvbmtleXVwJzogX19jb250ZXh0LnZhbHVlcy5vbmtleXVwLCAnb25pbnB1dCc6IF9fY29udGV4dC52YWx1ZXMub25pbnB1dCwgJ29uZm9jdXMnOiBfX2NvbnRleHQudmFsdWVzLm9uZm9jdXMsICdvbmJsdXInOiBfX2NvbnRleHQudmFsdWVzLm9uYmx1ciwgJ2F1dG9jb21wbGV0ZSc6IF9fY29udGV4dC52YWx1ZXMuYXV0b2NvbXBsZXRlLCAnc2l6ZSc6IF9fY29udGV4dC52YWx1ZXMuc2l6ZSwgJ3BsYWNlaG9sZGVyJzogX19jb250ZXh0LnZhbHVlcy5wbGFjZWhvbGRlciwgJ3JlYWRPbmx5JzogX19jb250ZXh0LnZhbHVlcy5yZWFkT25seSwgJ3ZhbHVlJzogX19jb250ZXh0LnZhbHVlcy52YWx1ZSB9LCB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy53bWwuaWQgfSB9LCBbXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIElucHV0Vmlldy5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIElucHV0Vmlldy5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgSW5wdXRWaWV3LnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIElucHV0Vmlldy5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBJbnB1dFZpZXcucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIElucHV0Vmlldy5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBJbnB1dFZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIElucHV0Vmlldztcbn0oKSk7XG5leHBvcnRzLklucHV0VmlldyA9IElucHV0VmlldztcbjtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnZGl2JywgeyBodG1sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMucm9vdC5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5yb290LmNsYXNzTmFtZSB9LCB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5yb290LndtbC5pZCB9IH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KF9fMS5JbnB1dCwgeyBodG1sOiB7fSwgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuaW5wdXQud21sLmlkIH0sIHd3OiB7ICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5pbnB1dC5uYW1lLCAnb25Gb2N1cyc6IF9fY29udGV4dC52YWx1ZXMuaW5wdXQub25Gb2N1cywgJ29uU2VhcmNoJzogX19jb250ZXh0LnZhbHVlcy5pbnB1dC5vblNlYXJjaCwgJ29uRXNjYXBlJzogX19jb250ZXh0LnZhbHVlcy5pbnB1dC5vbkVzY2FwZSwgJ29uQmx1cic6IF9fY29udGV4dC52YWx1ZXMuaW5wdXQub25CbHVyLCAncGxhY2Vob2xkZXInOiBfX2NvbnRleHQudmFsdWVzLmlucHV0LnBsYWNlaG9sZGVyLCAncmVhZE9ubHknOiBfX2NvbnRleHQudmFsdWVzLmlucHV0LnJlYWRPbmx5LCAndmFsdWUnOiBfX2NvbnRleHQudmFsdWVzLmlucHV0LnZhbHVlIH0gfSwgW10pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQocmVzdWx0c19tZW51XzEuUmVzdWx0c01lbnUsIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLm1lbnUud21sLmlkIH0sIHd3OiB7ICdibG9jayc6IF9fY29udGV4dC52YWx1ZXMubWVudS5ibG9jaywgJ29uU2VsZWN0JzogX19jb250ZXh0LnZhbHVlcy5tZW51Lm9uU2VsZWN0LCAnbm9JdGVtc1RlbXBsYXRlJzogX19jb250ZXh0LnZhbHVlcy5tZW51Lm5vSXRlbXNUZW1wbGF0ZSwgJ2l0ZW1zVGVtcGxhdGUnOiBfX2NvbnRleHQudmFsdWVzLm1lbnUuaXRlbVRlbXBsYXRlLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLm1lbnUuc3RyaW5naWZpZXIgfSB9LCBbXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBNYWluLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gTWFpbjtcbn0oKSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VhcmNoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvc2VsZWN0XCIpO1xudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG52YXIgb3JpZW50YXRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZW50L29yaWVudGF0aW9uXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIGZlZWRiYWNrXzEgPSByZXF1aXJlKFwiLi4vZmVlZGJhY2tcIik7XG52YXIgZm9ybV8xID0gcmVxdWlyZShcIi4uL2Zvcm1cIik7XG52YXIgX18xID0gcmVxdWlyZShcIi4uLy4uL1wiKTtcbnZhciBfXzIgPSByZXF1aXJlKFwiLi4vXCIpO1xudmFyIHNlYXJjaF8xID0gcmVxdWlyZShcIi4uL3NlYXJjaFwiKTtcbmV4cG9ydHMuVGVybUNoYW5nZWRFdmVudCA9IHNlYXJjaF8xLlRlcm1DaGFuZ2VkRXZlbnQ7XG5leHBvcnRzLkl0ZW1TZWxlY3RlZEV2ZW50ID0gc2VhcmNoXzEuSXRlbVNlbGVjdGVkRXZlbnQ7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLlNFTEVDVCA9ICd3dy1zZWxlY3QnO1xuLyoqXG4gKiBJdGVtQ2hhbmdlZEV2ZW50XG4gKi9cbnZhciBJdGVtQ2hhbmdlZEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJdGVtQ2hhbmdlZEV2ZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEl0ZW1DaGFuZ2VkRXZlbnQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEl0ZW1DaGFuZ2VkRXZlbnQ7XG59KF9fMi5FdmVudCkpO1xuZXhwb3J0cy5JdGVtQ2hhbmdlZEV2ZW50ID0gSXRlbUNoYW5nZWRFdmVudDtcbi8qKlxuICogSXRlbVVuc2V0RXZlbnRcbiAqL1xudmFyIEl0ZW1VbnNldEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJdGVtVW5zZXRFdmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJdGVtVW5zZXRFdmVudChuYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUsIHVuZGVmaW5lZCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEl0ZW1VbnNldEV2ZW50O1xufShfXzIuRXZlbnQpKTtcbmV4cG9ydHMuSXRlbVVuc2V0RXZlbnQgPSBJdGVtVW5zZXRFdmVudDtcbi8qKlxuICogUm9vdFNlY3Rpb25cbiAqL1xudmFyIFJvb3RTZWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJvb3RTZWN0aW9uKGF0dHJzKSB7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy53bWwgPSB7IGlkOiAncm9vdCcgfTtcbiAgICAgICAgdGhpcy5pZCA9IF9fMS5nZXRJZCh0aGlzLmF0dHJzKTtcbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSB1dGlsXzEuY29uY2F0KGV4cG9ydHMuU0VMRUNULCBfXzEuZ2V0Q2xhc3NOYW1lKHRoaXMuYXR0cnMpLCBmZWVkYmFja18xLmdldFZhbGlkaXR5Q2xhc3NOYW1lKHRoaXMuYXR0cnMpLCBvcmllbnRhdGlvbl8xLmdldEJsb2NrQ2xhc3NOYW1lKHRoaXMuYXR0cnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIFJvb3RTZWN0aW9uO1xufSgpKTtcbmV4cG9ydHMuUm9vdFNlY3Rpb24gPSBSb290U2VjdGlvbjtcbi8qKlxuICogQ29udHJvbFNlY3Rpb25cbiAqL1xudmFyIENvbnRyb2xTZWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbnRyb2xTZWN0aW9uKCkge1xuICAgICAgICB0aGlzLndtbCA9IHsgaWQ6ICdyb290JyB9O1xuICAgIH1cbiAgICByZXR1cm4gQ29udHJvbFNlY3Rpb247XG59KCkpO1xuZXhwb3J0cy5Db250cm9sU2VjdGlvbiA9IENvbnRyb2xTZWN0aW9uO1xuLyoqXG4gKiBNZXNzYWdlc1NlY3Rpb25cbiAqL1xudmFyIE1lc3NhZ2VzU2VjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZXNzYWdlc1NlY3Rpb24oYXR0cnMpIHtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLndtbCA9IHsgaWQ6ICdtZXNzYWdlJyB9O1xuICAgICAgICB0aGlzLnRleHQgPSBmZWVkYmFja18xLmdldE1lc3NhZ2UodGhpcy5hdHRycyk7XG4gICAgfVxuICAgIHJldHVybiBNZXNzYWdlc1NlY3Rpb247XG59KCkpO1xuZXhwb3J0cy5NZXNzYWdlc1NlY3Rpb24gPSBNZXNzYWdlc1NlY3Rpb247XG4vKipcbiAqIExhYmVsU2VjdGlvblxuICovXG52YXIgTGFiZWxTZWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExhYmVsU2VjdGlvbihhdHRycykge1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMuaWQgPSBfXzIuZ2V0TmFtZSh0aGlzLmF0dHJzKTtcbiAgICAgICAgdGhpcy50ZXh0ID0gZm9ybV8xLmdldExhYmVsKHRoaXMuYXR0cnMpO1xuICAgIH1cbiAgICByZXR1cm4gTGFiZWxTZWN0aW9uO1xufSgpKTtcbmV4cG9ydHMuTGFiZWxTZWN0aW9uID0gTGFiZWxTZWN0aW9uO1xuLyoqXG4gKiBJbnB1dFNlY3Rpb25cbiAqL1xudmFyIElucHV0U2VjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbnB1dFNlY3Rpb24oYXR0cnMpIHtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLndtbCA9IHsgaWQ6ICdpbnB1dCcgfTtcbiAgICB9XG4gICAgcmV0dXJuIElucHV0U2VjdGlvbjtcbn0oKSk7XG5leHBvcnRzLklucHV0U2VjdGlvbiA9IElucHV0U2VjdGlvbjtcbi8qKlxuICogU2VhcmNoU2VjdGlvblxuICovXG52YXIgU2VhcmNoU2VjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZWFyY2hTZWN0aW9uKGF0dHJzLCBjbG9zZSwgb25TZWxlY3QpIHtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLmNsb3NlID0gY2xvc2U7XG4gICAgICAgIHRoaXMub25TZWxlY3QgPSBvblNlbGVjdDtcbiAgICAgICAgdGhpcy53bWwgPSB7IGlkOiAnc2VhcmNoJyB9O1xuICAgICAgICB0aGlzLm5hbWUgPSBfXzIuZ2V0TmFtZSh0aGlzLmF0dHJzKTtcbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSAodGhpcy5hdHRycy53dyAmJiB0aGlzLmF0dHJzLnd3LmlucHV0Q2xhc3NOYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmF0dHJzLnd3LmlucHV0Q2xhc3NOYW1lIDogJyc7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSAodGhpcy5hdHRycy53dyAmJiB0aGlzLmF0dHJzLnd3LnBsYWNlaG9sZGVyKSA/XG4gICAgICAgICAgICB0aGlzLmF0dHJzLnd3LnBsYWNlaG9sZGVyIDogJyc7XG4gICAgICAgIHRoaXMuYmxvY2sgPSAodGhpcy5hdHRycy53dyAmJiB0aGlzLmF0dHJzLnd3LmJsb2NrKSA/XG4gICAgICAgICAgICB0aGlzLmF0dHJzLnd3LmJsb2NrIDogZmFsc2U7XG4gICAgICAgIHRoaXMudmFsdWUgPSAodGhpcy5hdHRycy53dyAmJiB0aGlzLmF0dHJzLnd3LnZhbHVlKSA/XG4gICAgICAgICAgICB0aGlzLmF0dHJzLnd3LnZhbHVlIDogdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnJlYWRPbmx5ID0gKHRoaXMuYXR0cnMud3cgJiYgdGhpcy5hdHRycy53dy5yZWFkT25seSk7XG4gICAgICAgIHRoaXMuaXRlbVRlbXBsYXRlID0gKHRoaXMuYXR0cnMud3cgJiYgdGhpcy5hdHRycy53dy5pdGVtVGVtcGxhdGUpID9cbiAgICAgICAgICAgIHRoaXMuYXR0cnMud3cuaXRlbVRlbXBsYXRlIDogdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm5vSXRlbXNUZW1wbGF0ZSA9ICh0aGlzLmF0dHJzLnd3ICYmIHRoaXMuYXR0cnMud3cubm9JdGVtc1RlbXBsYXRlKSA/XG4gICAgICAgICAgICB0aGlzLmF0dHJzLnd3Lm5vSXRlbXNUZW1wbGF0ZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zdHJpbmdpZmllciA9ICh0aGlzLmF0dHJzLnd3ICYmIHRoaXMuYXR0cnMud3cuc3RyaW5naWZpZXIpID9cbiAgICAgICAgICAgIHRoaXMuYXR0cnMud3cuc3RyaW5naWZpZXIgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMub25TZWFyY2ggPSAodGhpcy5hdHRycy53dyAmJiB0aGlzLmF0dHJzLnd3Lm9uU2VhcmNoKSA/XG4gICAgICAgICAgICB0aGlzLmF0dHJzLnd3Lm9uU2VhcmNoIDogZnVuY3Rpb24gKCkgeyB9O1xuICAgIH1cbiAgICByZXR1cm4gU2VhcmNoU2VjdGlvbjtcbn0oKSk7XG5leHBvcnRzLlNlYXJjaFNlY3Rpb24gPSBTZWFyY2hTZWN0aW9uO1xuLyoqXG4gKiBTZWxlY3QgcHJvdmlkZXMgYW4gY29udHJvbCBmb3Igc2VsZWN0aW5nIGFuIGl0ZW0gZnJvbSBhXG4gKiBsaXN0LlxuICovXG52YXIgU2VsZWN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTZWxlY3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2VsZWN0KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgcm9vdDogbmV3IFJvb3RTZWN0aW9uKF90aGlzLmF0dHJzKSxcbiAgICAgICAgICAgIGNvbnRyb2w6IG5ldyBDb250cm9sU2VjdGlvbigpLFxuICAgICAgICAgICAgbWVzc2FnZXM6IG5ldyBNZXNzYWdlc1NlY3Rpb24oX3RoaXMuYXR0cnMpLFxuICAgICAgICAgICAgbGFiZWw6IG5ldyBMYWJlbFNlY3Rpb24oX3RoaXMuYXR0cnMpLFxuICAgICAgICAgICAgaW5wdXQ6IG5ldyBJbnB1dFNlY3Rpb24oX3RoaXMuYXR0cnMpLFxuICAgICAgICAgICAgc2VhcmNoOiBuZXcgU2VhcmNoU2VjdGlvbihfdGhpcy5hdHRycywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY2xvc2UoKTsgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIF90aGlzLnZhbHVlcy50YWcudmFsdWUgPSBtYXliZV8xLmp1c3QoZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm9uQ2hhbmdlKVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5vbkNoYW5nZShuZXcgSXRlbUNoYW5nZWRFdmVudCgnJyArIF90aGlzLmF0dHJzLnd3Lm5hbWUsIGUudmFsdWUpKTtcbiAgICAgICAgICAgICAgICBfdGhpcy52aWV3LmludmFsaWRhdGUoKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdGFnOiB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBmZWVkYmFja18xLmdldFZhbGlkaXR5Q2xhc3NOYW1lKF90aGlzLmF0dHJzKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogKChfdGhpcy5hdHRycy53dyAmJlxuICAgICAgICAgICAgICAgICAgICAoX3RoaXMuYXR0cnMud3cudmFsdWUgIT0gdW5kZWZpbmVkKSkgP1xuICAgICAgICAgICAgICAgICAgICBtYXliZV8xLmp1c3QoX3RoaXMuYXR0cnMud3cudmFsdWUpIDogbWF5YmVfMS5ub3RoaW5nKCkpLFxuICAgICAgICAgICAgICAgIGlzU2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy52YWx1ZXMudGFnLnZhbHVlLmlzSnVzdCgpOyB9LFxuICAgICAgICAgICAgICAgIGdldFRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnN0cmluZ2lmaWVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmF0dHJzLnd3LnN0cmluZ2lmaWVyKF90aGlzLnZhbHVlcy50YWcudmFsdWUuZ2V0KCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkaXNtaXNzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnZhbHVlcy50YWcudmFsdWUgPSBtYXliZV8xLm5vdGhpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm9uVW5zZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5vblVuc2V0KG5ldyBJdGVtVW5zZXRFdmVudChfdGhpcy5hdHRycy53dy5uYW1lICsgJycpKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmlldy5pbnZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNlbGVjdC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZXhwb3J0cy5vcGVuKHRoaXMudmlldywgdGhpcy52YWx1ZXMuc2VhcmNoLndtbC5pZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU2VsZWN0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZXhwb3J0cy5jbG9zZSh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLnNlYXJjaC53bWwuaWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFNlbGVjdC5wcm90b3R5cGUuc2V0TWVzc2FnZSA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdGhpcy52YWx1ZXMubWVzc2FnZXMudGV4dCA9IG1zZztcbiAgICAgICAgZm9ybV8xLnNldE1lc3NhZ2UodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5tZXNzYWdlcy53bWwuaWQsIG1zZyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU2VsZWN0LnByb3RvdHlwZS5yZW1vdmVNZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnZhbHVlcy5tZXNzYWdlcy50ZXh0ID0gJyc7XG4gICAgICAgIGZvcm1fMS5yZW1vdmVNZXNzYWdlKHRoaXMudmlldywgdGhpcy52YWx1ZXMubWVzc2FnZXMud21sLmlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiB1cGRhdGUgdGhlIFNlbGVjdCB3aXRoIG5ldyBpdGVtIG9wdGlvbnMgdG9cbiAgICAgKiBwcmVzZW50IHRvIHRoZSB1c2VyLlxuICAgICAqL1xuICAgIFNlbGVjdC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHJlc3VsdHMpIHtcbiAgICAgICAgZXhwb3J0cy51cGRhdGUodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5zZWFyY2gud21sLmlkLCByZXN1bHRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gU2VsZWN0O1xufShmb3JtXzEuQWJzdHJhY3RGb3JtQ29udHJvbCkpO1xuZXhwb3J0cy5TZWxlY3QgPSBTZWxlY3Q7XG4vKipcbiAqIG9wZW4gaGVscGVyLlxuICpcbiAqIEludm9rZXMgdGhlIG9wZW4gbWV0aG9kIG9uIHRoZSBTZWFyY2ggd2lkZ2V0LlxuICovXG5leHBvcnRzLm9wZW4gPSBmdW5jdGlvbiAodmlldywgaWQpIHtcbiAgICB1dGlsXzEuZ2V0QnlJZCh2aWV3LCBpZClcbiAgICAgICAgLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5vcGVuKCk7IH0pO1xufTtcbi8qKlxuICogY2xvc2UgaGVscGVyLlxuICpcbiAqIEludm9rZXMgdGhlIGNsb3NlIG1ldGhvZCBvbiB0aGUgU2VhcmNoIHdpZGdldC5cbiAqL1xuZXhwb3J0cy5jbG9zZSA9IGZ1bmN0aW9uICh2aWV3LCBpZCkge1xuICAgIHV0aWxfMS5nZXRCeUlkKHZpZXcsIGlkKVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLmNsb3NlKCk7IH0pO1xufTtcbi8qKlxuICogdXBkYXRlIGhlbHBlci5cbiAqXG4gKiBJbnZva2VzIHRoZSB1cGRhdGUgbWV0aG9kIG9uIHRoZSBTZWFyY2ggd2lkZ2V0LlxuICovXG5leHBvcnRzLnVwZGF0ZSA9IGZ1bmN0aW9uICh2aWV3LCBpZCwgcmVzdWx0cykge1xuICAgIHZhciBtU2VhcmNoID0gdXRpbF8xLmdldEJ5SWQodmlldywgaWQpO1xuICAgIGlmIChtU2VhcmNoLmlzSnVzdCgpKVxuICAgICAgICBtU2VhcmNoLmdldCgpLnVwZGF0ZShyZXN1bHRzKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3NwcmVhZEFycmF5cyA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheXMpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxuICAgICAgICAgICAgcltrXSA9IGFbal07XG4gICAgcmV0dXJuIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHNlYXJjaF8xID0gcmVxdWlyZShcIi4uLy4uL3NlYXJjaFwiKTtcbjtcbnZhciBsYWJlbF8xID0gcmVxdWlyZShcIi4uLy4uL2xhYmVsXCIpO1xuO1xudmFyIGhlbHBfMSA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwXCIpO1xuO1xudmFyIHRhZ18xID0gcmVxdWlyZShcIi4uLy4uL3RhZ1wiKTtcbjtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdkaXYnLCB7IGh0bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5yb290LmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NOYW1lIH0sIHdtbDoge30gfSwgX19zcHJlYWRBcnJheXMoW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobGFiZWxfMS5MYWJlbCwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ2Zvcic6IF9fY29udGV4dC52YWx1ZXMucm9vdC5pZCwgJ3RleHQnOiBfX2NvbnRleHQudmFsdWVzLmxhYmVsLnRleHQgfSB9LCBbXSlcbiAgICAgICAgICAgIF0sIChfX2lmKF9fY29udGV4dC52YWx1ZXMudGFnLmlzU2V0KCksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIChbXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldCh0YWdfMS5UYWcsIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICd0ZXh0JzogX19jb250ZXh0LnZhbHVlcy50YWcuZ2V0VGV4dCgpLCAnY2xhc3NOYW1lJzogX19jb250ZXh0LnZhbHVlcy50YWcuY2xhc3NOYW1lLCAnb25EaXNtaXNzJzogX19jb250ZXh0LnZhbHVlcy50YWcuZGlzbWlzcyB9IH0sIFtdKVxuICAgICAgICAgICAgXSk7IH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIChbXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChzZWFyY2hfMS5TZWFyY2gsIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLnNlYXJjaC53bWwuaWQgfSwgd3c6IHsgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLnNlYXJjaC5uYW1lLCAnY2xhc3NOYW1lJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2guY2xhc3NOYW1lLCAnYmxvY2snOiBfX2NvbnRleHQudmFsdWVzLnNlYXJjaC5ibG9jaywgJ3BsYWNlaG9sZGVyJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2gucGxhY2Vob2xkZXIsICdyZWFkT25seSc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLnJlYWRPbmx5LCAnaXRlbVRlbXBsYXRlJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2guaXRlbVRlbXBsYXRlLCAnbm9JdGVtc1RlbXBsYXRlJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2gubm9JdGVtc1RlbXBsYXRlLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLnNlYXJjaC5zdHJpbmdpZmllciwgJ29uU2VhcmNoJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2gub25TZWFyY2gsICdvblNlbGVjdCc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLm9uU2VsZWN0IH0gfSwgW10pXG4gICAgICAgICAgICBdKTsgfSkpLCBbXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChoZWxwXzEuSGVscCwgeyBodG1sOiB7fSwgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMubWVzc2FnZXMud21sLmlkIH0sIHd3OiB7ICd0ZXh0JzogX19jb250ZXh0LnZhbHVlcy5tZXNzYWdlcy50ZXh0IH0gfSwgW10pXG4gICAgICAgICAgICBdKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWxlY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9zdGFjay1zZWxlY3RcIik7XG52YXIgb3JpZW50YXRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZW50L29yaWVudGF0aW9uXCIpO1xudmFyIGZvcm1fMSA9IHJlcXVpcmUoXCIuLi9mb3JtXCIpO1xudmFyIHNlYXJjaF8xID0gcmVxdWlyZShcIi4uL3NlYXJjaFwiKTtcbmV4cG9ydHMuVGVybUNoYW5nZWRFdmVudCA9IHNlYXJjaF8xLlRlcm1DaGFuZ2VkRXZlbnQ7XG52YXIgc2VsZWN0XzEgPSByZXF1aXJlKFwiLi4vc2VsZWN0XCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIF9fMSA9IHJlcXVpcmUoXCIuLi8uLi9cIik7XG52YXIgX18yID0gcmVxdWlyZShcIi4uL1wiKTtcbnZhciBmZWVkYmFja18xID0gcmVxdWlyZShcIi4uL2ZlZWRiYWNrXCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5TVEFDS19TRUxFQ1QgPSAnd3ctc3RhY2stc2VsZWN0Jztcbi8qKlxuICogSXRlbXNDaGFuZ2VkRXZlbnRcbiAqL1xudmFyIEl0ZW1zQ2hhbmdlZEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJdGVtc0NoYW5nZWRFdmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJdGVtc0NoYW5nZWRFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSXRlbXNDaGFuZ2VkRXZlbnQ7XG59KF9fMi5FdmVudCkpO1xuZXhwb3J0cy5JdGVtc0NoYW5nZWRFdmVudCA9IEl0ZW1zQ2hhbmdlZEV2ZW50O1xuLyoqXG4gKiBTdGFja1NlbGVjdCBwcm92aWRlcyBhIGNvbnRyb2wgZm9yIGFsbG93aW5nIGEgdXNlciB0byBzZWxlY3RcbiAqIG11bHRpcGxlIGl0ZW1zIGZyb20gYSBsaXN0LlxuICpcbiAqIEl0IHVzZSBhIHN0YWNrIHRvIGRpc3BsYXkgdGhlIHNlbGVjdGVkIGl0ZW1zLlxuICpcbiAqICAgICArPT09PT09PT09PT09PT09PT09PT09PT09PStcbiAqICAgICB8ICA8c2VsZWN0PiAgICAgICAgICAgICAgIHxcbiAqICAgICArPT09PT09PT09PT09PT09PT09PT09PT09PStcbiAqICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAqICAgICB8ICAgPGl0ZW0+ICAgICAgICAgICAgICB4IHxcbiAqICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAqICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAqICAgICB8ICAgPGl0ZW0+ICAgICAgICAgICAgICB4IHxcbiAqICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAqICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAqICAgICB8ICAgPGl0ZW0+ICAgICAgICAgICAgICB4IHxcbiAqICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAqL1xudmFyIFN0YWNrU2VsZWN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdGFja1NlbGVjdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdGFja1NlbGVjdCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdyb290J1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaWQ6IF9fMS5nZXRJZChfdGhpcy5hdHRycyksXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiB1dGlsXzEuY29uY2F0KGV4cG9ydHMuU1RBQ0tfU0VMRUNULCBfXzEuZ2V0Q2xhc3NOYW1lKF90aGlzLmF0dHJzKSwgZmVlZGJhY2tfMS5nZXRWYWxpZGl0eUNsYXNzTmFtZShfdGhpcy5hdHRycyksIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5ibG9jaykgPyBvcmllbnRhdGlvbl8xLkJMT0NLIDogJycpLFxuICAgICAgICAgICAgICAgIGRpcjogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmRpcikgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5kaXIgOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udHJvbDoge1xuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ3Jvb3QnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAnbGFiZWwnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBmb3JtXzEuZ2V0TGFiZWwoX3RoaXMuYXR0cnMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VhcmNoOiB7XG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAnc2VhcmNoJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbmFtZTogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm5hbWUpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cubmFtZSA6ICcnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgYmxvY2s6IHRydWUsXG4gICAgICAgICAgICAgICAgb25TZWFyY2g6IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm9uU2VhcmNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cub25TZWFyY2goZXZ0KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uU2VsZWN0OiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gX2EudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWVzc2FnZXM6IHtcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdtZXNzYWdlJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGV4dDogZmVlZGJhY2tfMS5nZXRNZXNzYWdlKF90aGlzLmF0dHJzKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0YWNrOiB7XG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAnc3RhY2snXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBuYW1lOiBfXzIuZ2V0TmFtZShfdGhpcy5hdHRycyksXG4gICAgICAgICAgICAgICAgdmFsdWU6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy52YWx1ZSkgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy52YWx1ZSA6IFtdLFxuICAgICAgICAgICAgICAgIGRlY29yYXRvcjogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnN0cmluZ2lmaWVyKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LnN0cmluZ2lmaWVyIDogZnVuY3Rpb24gKHYpIHsgcmV0dXJuIFN0cmluZyh2KTsgfSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm9uQ2hhbmdlKVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cub25DaGFuZ2UoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFN0YWNrU2VsZWN0LnByb3RvdHlwZS5zZXRNZXNzYWdlID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICBmb3JtXzEuc2V0TWVzc2FnZSh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLm1lc3NhZ2VzLndtbC5pZCwgbXNnKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBTdGFja1NlbGVjdC5wcm90b3R5cGUucmVtb3ZlTWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9ybV8xLnJlbW92ZU1lc3NhZ2UodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5tZXNzYWdlcy53bWwuaWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHVwZGF0ZSB0aGUgbGlzdCBvZiBhdmFpbGFibGUgb3B0aW9ucyBkaXNwbGF5ZWQgdG8gdGhlIHVzZXIuXG4gICAgICovXG4gICAgU3RhY2tTZWxlY3QucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICAgIHNlbGVjdF8xLnVwZGF0ZSh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLnNlYXJjaC53bWwuaWQsIGxpc3QpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHB1c2ggYSB2YWx1ZSBvbnRvIHRoZSBzdGFjay5cbiAgICAgKi9cbiAgICBTdGFja1NlbGVjdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHRoaXNcbiAgICAgICAgICAgIC52aWV3XG4gICAgICAgICAgICAuZmluZEJ5SWQodGhpcy52YWx1ZXMuc3RhY2sud21sLmlkKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gcy5wdXNoKHYpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhY2tTZWxlY3Q7XG59KGZvcm1fMS5BYnN0cmFjdEZvcm1Db250cm9sKSk7XG5leHBvcnRzLlN0YWNrU2VsZWN0ID0gU3RhY2tTZWxlY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3NwcmVhZEFycmF5cyA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheXMpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxuICAgICAgICAgICAgcltrXSA9IGFbal07XG4gICAgcmV0dXJuIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHNlYXJjaF8xID0gcmVxdWlyZShcIi4uLy4uL3NlYXJjaFwiKTtcbjtcbnZhciBzdGFja18xID0gcmVxdWlyZShcIi4uLy4uL3N0YWNrXCIpO1xuO1xudmFyIGxhYmVsXzEgPSByZXF1aXJlKFwiLi4vLi4vbGFiZWxcIik7XG47XG52YXIgaGVscF8xID0gcmVxdWlyZShcIi4uLy4uL2hlbHBcIik7XG47XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnZGl2JywgeyBodG1sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMucm9vdC5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5yb290LmNsYXNzTmFtZSB9LCB3bWw6IHt9IH0sIF9fc3ByZWFkQXJyYXlzKChfX2lmKChfX2NvbnRleHQudmFsdWVzLnJvb3QuZGlyID09PSAtMSksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIChbXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChsYWJlbF8xLkxhYmVsLCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAnZm9yJzogX19jb250ZXh0LnZhbHVlcy5yb290LmlkLCAndGV4dCc6IF9fY29udGV4dC52YWx1ZXMubGFiZWwudGV4dCB9IH0sIFtdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHNlYXJjaF8xLlNlYXJjaCwgeyBodG1sOiB7fSwgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLndtbC5pZCB9LCB3dzogeyAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLm5hbWUsICd2YWx1ZSc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLnZhbHVlLCAnYmxvY2snOiBfX2NvbnRleHQudmFsdWVzLnNlYXJjaC5ibG9jaywgJ3N0cmluZ2lmaWVyJzogX19jb250ZXh0LnZhbHVlcy5zdGFjay5kZWNvcmF0b3IsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLm9uU2VhcmNoLCAnb25TZWxlY3QnOiBfX2NvbnRleHQudmFsdWVzLnNlYXJjaC5vblNlbGVjdCB9IH0sIFtdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHN0YWNrXzEuU3RhY2ssIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLnN0YWNrLndtbC5pZCB9LCB3dzogeyAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMuc3RhY2submFtZSwgJ3ZhbHVlJzogX19jb250ZXh0LnZhbHVlcy5zdGFjay52YWx1ZSwgJ2RlY29yYXRvcic6IF9fY29udGV4dC52YWx1ZXMuc3RhY2suZGVjb3JhdG9yLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLnN0YWNrLm9uQ2hhbmdlIH0gfSwgW10pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoaGVscF8xLkhlbHAsIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLm1lc3NhZ2VzLndtbC5pZCB9LCB3dzogeyAndGV4dCc6IF9fY29udGV4dC52YWx1ZXMubWVzc2FnZXMudGV4dCB9IH0sIFtdKVxuICAgICAgICAgICAgXSk7IH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIChbXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChsYWJlbF8xLkxhYmVsLCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAnZm9yJzogX19jb250ZXh0LnZhbHVlcy5yb290LmlkLCAndGV4dCc6IF9fY29udGV4dC52YWx1ZXMubGFiZWwudGV4dCB9IH0sIFtdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHN0YWNrXzEuU3RhY2ssIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLnN0YWNrLndtbC5pZCB9LCB3dzogeyAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMuc3RhY2submFtZSwgJ3ZhbHVlJzogX19jb250ZXh0LnZhbHVlcy5zdGFjay52YWx1ZSwgJ2RlY29yYXRvcic6IF9fY29udGV4dC52YWx1ZXMuc3RhY2suZGVjb3JhdG9yLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLnN0YWNrLm9uQ2hhbmdlIH0gfSwgW10pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoc2VhcmNoXzEuU2VhcmNoLCB7IGh0bWw6IHt9LCB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2gud21sLmlkIH0sIHd3OiB7ICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2gubmFtZSwgJ3ZhbHVlJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2gudmFsdWUsICdibG9jayc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLmJsb2NrLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLnN0YWNrLmRlY29yYXRvciwgJ29uU2VhcmNoJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2gub25TZWFyY2gsICdvblNlbGVjdCc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLm9uU2VsZWN0IH0gfSwgW10pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoaGVscF8xLkhlbHAsIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLm1lc3NhZ2VzLndtbC5pZCB9LCB3dzogeyAndGV4dCc6IF9fY29udGV4dC52YWx1ZXMubWVzc2FnZXMudGV4dCB9IH0sIFtdKVxuICAgICAgICAgICAgXSk7IH0pKSkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBNYWluLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gTWFpbjtcbn0oKSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhY2stc2VsZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvc3RhY2tcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgX18xID0gcmVxdWlyZShcIi4uLy4uL1wiKTtcbnZhciBfXzIgPSByZXF1aXJlKFwiLi4vXCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5TVEFDSyA9ICd3dy1zdGFjayc7XG5leHBvcnRzLlNUQUNLX0VMRU1FTlQgPSAnd3ctc3RhY2tfX2VsZW1lbnQnO1xuZXhwb3J0cy5TVEFDS19FTEVNRU5UX0NPTlRFTlQgPSAnd3ctc3RhY2tfX2VsZW1lbnRfX2NvbnRlbnQnO1xuZXhwb3J0cy5TVEFDS19DTE9TRV9CVVRUT04gPSAnd3ctc3RhY2tfX2J1dHRvbic7XG4vKipcbiAqIFN0YWNrQ2hhbmdlZEV2ZW50IGlzIGdlbmVyYXRlZCB3aGVuIHRoZSB1c2VyIHJlbW92ZXMgYW4gaXRlbSBmcm9tIHRoZSBzdGFjay5cbiAqL1xudmFyIFN0YWNrQ2hhbmdlZEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdGFja0NoYW5nZWRFdmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdGFja0NoYW5nZWRFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gU3RhY2tDaGFuZ2VkRXZlbnQ7XG59KF9fMi5FdmVudCkpO1xuZXhwb3J0cy5TdGFja0NoYW5nZWRFdmVudCA9IFN0YWNrQ2hhbmdlZEV2ZW50O1xuLyoqXG4gKiBTdGFjayBkaXNwbGF5cyBhIGxpc3Qgb2YgaXRlbXMgdGhhdCBjYW4gYmUgbW9kaWZpZWRcbiAqIGJ5IHJlbGVhc2luZyBvbmUgb3IgbW9yZSBhdCBhIHRpbWUuXG4gKi9cbnZhciBTdGFjayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3RhY2ssIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3RhY2soKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgaWQ6IF9fMS5nZXRJZChfdGhpcy5hdHRycyksXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiB1dGlsXzEuY29uY2F0KGV4cG9ydHMuU1RBQ0ssIF9fMS5nZXRDbGFzc05hbWUoX3RoaXMuYXR0cnMpKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnZhbHVlKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LnZhbHVlIDogW10sXG4gICAgICAgICAgICAgICAgZmlyZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cub25DaGFuZ2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5vbkNoYW5nZShuZXcgU3RhY2tDaGFuZ2VkRXZlbnQoX3RoaXMuYXR0cnMud3cubmFtZSwgX3RoaXMudmFsdWVzLnJvb3QudmFsdWUuc2xpY2UoKSkpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy52aWV3LmludmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZWxlbWVudDoge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogZXhwb3J0cy5TVEFDS19FTEVNRU5ULFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBmdW5jdGlvbiAodikgeyByZXR1cm4gZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmVsZW1lbnRUZW1wbGF0ZSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuZWxlbWVudFRlbXBsYXRlKF90aGlzKSh2KShpZHgpKF90aGlzLnZpZXcpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdzLmNvbnRlbnQoX3RoaXMpKHYpKGlkeCkoX3RoaXMudmlldyk7XG4gICAgICAgICAgICAgICAgfTsgfSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogZXhwb3J0cy5TVEFDS19FTEVNRU5UX0NPTlRFTlRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbiAoaW5kZXgpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmFsdWVzLnJvb3QudmFsdWUuc3BsaWNlKE51bWJlcihpbmRleCksIDEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZXMucm9vdC5maXJlKCk7XG4gICAgICAgICAgICAgICAgfTsgfSxcbiAgICAgICAgICAgICAgICBkZWNvcmF0b3I6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfXzEudGV4dCgoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuZGVjb3JhdG9yKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5kZWNvcmF0b3IodikgOiB2ICsgJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZToge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogZXhwb3J0cy5TVEFDS19DTE9TRV9CVVRUT05cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBwdXNoIGEgbmV3IG1lbWJlciBvbnRvIHRoZSBzdGFjay5cbiAgICAgKi9cbiAgICBTdGFjay5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlcy5yb290LnZhbHVlLnB1c2godmFsdWUpO1xuICAgICAgICB0aGlzLnZhbHVlcy5yb290LmZpcmUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhY2s7XG59KF9fMi5BYnN0cmFjdENvbnRyb2wpKTtcbmV4cG9ydHMuU3RhY2sgPSBTdGFjaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fc3ByZWFkQXJyYXlzID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5cykgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcbiAgICByZXR1cm4gcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbmV4cG9ydHMuY29udGVudCA9IGZ1bmN0aW9uIChzKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBfX3RoaXMubm9kZSgnZGl2JywgeyBodG1sOiB7ICdjbGFzcyc6IHMudmFsdWVzLmVsZW1lbnQuY29udGVudC5jbGFzc05hbWUgfSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICBzLnZhbHVlcy5lbGVtZW50LmRlY29yYXRvcih2KVxuICAgICAgICBdKVxuICAgIF07XG59OyB9OyB9OyB9O1xuO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCd1bCcsIHsgaHRtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMucm9vdC5jbGFzc05hbWUgfSwgd21sOiB7fSB9LCBfX3NwcmVhZEFycmF5cyhfX2ZvckluKF9fY29udGV4dC52YWx1ZXMucm9vdC52YWx1ZSwgZnVuY3Rpb24gKHYsIGluZGV4LCBfJCRhbGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2xpJywgeyBodG1sOiB7ICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuZWxlbWVudC5jbGFzc05hbWUgfSwgd21sOiB7fSB9LCBfX3NwcmVhZEFycmF5cygoX19jb250ZXh0LnZhbHVlcy5lbGVtZW50LnRlbXBsYXRlKHYpKGluZGV4KSksIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdidXR0b24nLCB7IGh0bWw6IHsgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jbG9zZS5jbGFzc05hbWUsICdvbmNsaWNrJzogX19jb250ZXh0LnZhbHVlcy5lbGVtZW50LmNsb3NlKGluZGV4KSB9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcdTAwRDdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgIF0pKVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gKFtdKTsgfSkpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgTWFpbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIE1haW47XG59KCkpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YWNrLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgX18xID0gcmVxdWlyZShcIi4uLy4uL1wiKTtcbnZhciBfXzIgPSByZXF1aXJlKFwiLi4vXCIpO1xudmFyIHN3aXRjaF8xID0gcmVxdWlyZShcIi4vd21sL3N3aXRjaFwiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuU1dJVENIID0gJ3d3LXN3aXRjaCc7XG5leHBvcnRzLlNXSVRDSF9TTElERVIgPSAnd3ctc3dpdGNoX19zbGlkZXInO1xuLyoqXG4gKiBTd2l0Y2hDaGFuZ2VkRXZlbnQgc2lnbmFscyB0aGUgdXNlciBoYXMgY2hhbmdlZCB0aGUgc3dpdGNoLlxuICovXG52YXIgU3dpdGNoQ2hhbmdlZEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTd2l0Y2hDaGFuZ2VkRXZlbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3dpdGNoQ2hhbmdlZEV2ZW50KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBTd2l0Y2hDaGFuZ2VkRXZlbnQ7XG59KF9fMi5FdmVudCkpO1xuZXhwb3J0cy5Td2l0Y2hDaGFuZ2VkRXZlbnQgPSBTd2l0Y2hDaGFuZ2VkRXZlbnQ7XG4vKipcbiAqIFN3aXRjaCBhbGxvd3MgdGhlIHVzZXIgdG8gc2VsZWN0IGJldHdlZW4gb25lIG9yIHR3byB2YWx1ZXMuXG4gKi9cbnZhciBTd2l0Y2ggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN3aXRjaCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTd2l0Y2goKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHN3aXRjaF8xLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgaWQ6IF9fMS5nZXRJZChfdGhpcy5hdHRycyksXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiB1dGlsXzEuY29uY2F0KGV4cG9ydHMuU1dJVENILCBfXzEuZ2V0Q2xhc3NOYW1lKF90aGlzLmF0dHJzKSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzbGlkZXI6IHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGV4cG9ydHMuU1dJVENIX1NMSURFUlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlucHV0OiB7XG4gICAgICAgICAgICAgICAgbmFtZTogX18yLmdldE5hbWUoX3RoaXMuYXR0cnMpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cudmFsdWUpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cudmFsdWUgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjaGVja2VkOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy52YWx1ZXMuaW5wdXQudmFsdWUgPyB0cnVlIDogdW5kZWZpbmVkOyB9LFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiBfXzIuZ2V0RGlzYWJsZWQoX3RoaXMuYXR0cnMpLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnZhbHVlcy5pbnB1dC52YWx1ZSA9ICghX3RoaXMudmFsdWVzLmlucHV0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5vbkNoYW5nZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5vbkNoYW5nZShuZXcgU3dpdGNoQ2hhbmdlZEV2ZW50KF90aGlzLnZhbHVlcy5pbnB1dC5uYW1lLCBfdGhpcy52YWx1ZXMuaW5wdXQudmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFN3aXRjaDtcbn0oX18yLkFic3RyYWN0Q29udHJvbCkpO1xuZXhwb3J0cy5Td2l0Y2ggPSBTd2l0Y2g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdsYWJlbCcsIHsgaHRtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMucm9vdC5jbGFzc05hbWUgfSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2lucHV0JywgeyBodG1sOiB7ICd0eXBlJzogXCJjaGVja2JveFwiLCAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMuaW5wdXQubmFtZSwgJ2NoZWNrZWQnOiBfX2NvbnRleHQudmFsdWVzLmlucHV0LmNoZWNrZWQoKSwgJ2Rpc2FibGVkJzogX19jb250ZXh0LnZhbHVlcy5pbnB1dC5kaXNhYmxlZCwgJ29uY2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5pbnB1dC5vbkNoYW5nZSB9LCB3bWw6IHt9IH0sIFtdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnZGl2JywgeyBodG1sOiB7ICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuc2xpZGVyLmNsYXNzTmFtZSB9LCB3bWw6IHt9IH0sIFtdKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zd2l0Y2guanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC90YWItYmFyXCIpO1xudmFyIHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgYWN0aXZlXzEgPSByZXF1aXJlKFwiLi4vLi4vY29udGVudC9zdGF0ZS9hY3RpdmVcIik7XG52YXIgb3JpZW50YXRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZW50L29yaWVudGF0aW9uXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIF9fMSA9IHJlcXVpcmUoXCIuLi8uLi9cIik7XG52YXIgX18yID0gcmVxdWlyZShcIi4uL1wiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbi8qKlxuICogVEFCXG4gKi9cbmV4cG9ydHMuVEFCID0gJ3d3LXRhYic7XG4vKipcbiAqIFRBQl9CQVJcbiAqL1xuZXhwb3J0cy5UQUJfQkFSID0gJ3d3LXRhYi1iYXInO1xuLyoqXG4gKiBUYWJDbGlja2VkRXZlbnQgaXMgZmlyZWQgd2hlbiBhIHVzZXIgY2xpY2tzIG9uIGEgdGFiLlxuICpcbiAqIEl0IGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSB0YWIgdGhhdCB3YXMgY2xpY2tlZC5cbiAqL1xudmFyIFRhYkNsaWNrZWRFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFiQ2xpY2tlZEV2ZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYkNsaWNrZWRFdmVudChuYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUsIG5hbWUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBUYWJDbGlja2VkRXZlbnQ7XG59KF9fMi5FdmVudCkpO1xuZXhwb3J0cy5UYWJDbGlja2VkRXZlbnQgPSBUYWJDbGlja2VkRXZlbnQ7XG4vKipcbiAqIFRhYiBwcm92aWRlcyBhIHNpbmdsZSB0YWIgaXRlbS5cbiAqXG4gKiBXaGVuIGEgdGFiIGlzIGNsaWNrZWQsIGl0IGF0dGVtcHRzIHRvIHJlbW92ZSB0aGUgYWN0aXZlIGNsYXNzIGZyb21cbiAqIGl0J3Mgc2libGluZ3MgYW5kIGFwcGx5IGl0IHRvIGl0c2VsZi4gVGhlcmVmb3JlIHRoZSBzaWJsaW5nIG9mIGFcbiAqIHRhYiBzaG91bGQgYWx3YXlzIGJlIGEgVGFiLlxuICovXG52YXIgVGFiID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYWIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFiKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5UYWIoX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAncm9vdCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlkOiBfXzEuZ2V0SWQoX3RoaXMuYXR0cnMpLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogdXRpbF8xLmNvbmNhdChleHBvcnRzLlRBQiwgX18xLmdldENsYXNzTmFtZShfdGhpcy5hdHRycyksIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5hY3RpdmUpID8gYWN0aXZlXzEuQUNUSVZFIDogJycpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdsaW5rJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29udGVudDogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnRleHQpID9cbiAgICAgICAgICAgICAgICAgICAgW19fMS50ZXh0KF90aGlzLmF0dHJzLnd3LnRleHQpXSA6IF90aGlzLmNoaWxkcmVuLFxuICAgICAgICAgICAgICAgIGNsaWNrZWQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heWJlUm9vdCA9IHV0aWxfMS5nZXRCeUlkKF90aGlzLnZpZXcsIF90aGlzLnZhbHVlcy5yb290LndtbC5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXliZVJvb3QuaXNOb3RoaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHZhciByb290ID0gbWF5YmVSb290LmdldCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gcm9vdC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2licyA9IHBhcmVudC5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWJzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2lic1tpXS5jbGFzc0xpc3QucmVtb3ZlKGFjdGl2ZV8xLkFDVElWRSk7XG4gICAgICAgICAgICAgICAgICAgIHJvb3QuY2xhc3NMaXN0LmFkZChhY3RpdmVfMS5BQ1RJVkUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cub25DbGljaylcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3Lm9uQ2xpY2sobmV3IFRhYkNsaWNrZWRFdmVudChcIlwiICsgX3RoaXMuYXR0cnMud3cubmFtZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjbGljayB0aGlzIFRhYlxuICAgICAqL1xuICAgIFRhYi5wcm90b3R5cGUuY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWxfMS5nZXRCeUlkKHRoaXMudmlldywgdGhpcy52YWx1ZXMucm9vdC53bWwuaWQpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLmNsaWNrKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBUYWI7XG59KF9fMi5BYnN0cmFjdENvbnRyb2wpKTtcbmV4cG9ydHMuVGFiID0gVGFiO1xuLyoqXG4gKiBUYWJCYXIgYWN0cyBhcyBhIHBhcmVudCBjb250YWluZXIgZm9yIGEgZ3JvdXAgb2YgVGFiLlxuICpcbiAqIFVzZSBpdCB0byBjcmVhdGUgYSB0YWJiZWQgbmF2aWdhdGlvbiBvciB2aWV3IGZvciBtYWluIGxheW91dCxcbiAqIHN1YiB2aWV3cyBvciBmb3JtcyBldGMuXG4gKi9cbnZhciBUYWJCYXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhYkJhciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJCYXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLlRhYkJhcihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgICAgICBpZDogX18xLmdldElkKF90aGlzLmF0dHJzKSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IHV0aWxfMS5jb25jYXQoZXhwb3J0cy5UQUJfQkFSLCBfXzEuZ2V0Q2xhc3NOYW1lKF90aGlzLmF0dHJzKSwgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lmp1c3RpZnkpID8gb3JpZW50YXRpb25fMS5KVVNUSUZJRUQgOiAnJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVGFiQmFyO1xufSh3bWxfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuVGFiQmFyID0gVGFiQmFyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19zcHJlYWRBcnJheXMgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xuICAgIHJldHVybiByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIFRhYkJhciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWJCYXIoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgndWwnLCB7IGh0bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5yb290LmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NOYW1lIH0sIHdtbDoge30gfSwgX19zcHJlYWRBcnJheXMoKF9fY29udGV4dC5jaGlsZHJlbikpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgVGFiQmFyLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgVGFiQmFyLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBUYWJCYXIucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgVGFiQmFyLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIFRhYkJhci5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgVGFiQmFyLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIFRhYkJhci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gVGFiQmFyO1xufSgpKTtcbmV4cG9ydHMuVGFiQmFyID0gVGFiQmFyO1xuO1xudmFyIFRhYiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWIoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnbGknLCB7IGh0bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5yb290LmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NOYW1lIH0sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLnJvb3Qud21sLmlkIH0gfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdhJywgeyBodG1sOiB7ICdocmVmJzogXCIjXCIsICdvbmNsaWNrJzogX19jb250ZXh0LnZhbHVlcy5hLmNsaWNrZWQgfSwgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuYS53bWwuaWQgfSB9LCBfX3NwcmVhZEFycmF5cygoX19jb250ZXh0LnZhbHVlcy5hLmNvbnRlbnQpKSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBUYWIucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBUYWIucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIFRhYi5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBUYWIucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgVGFiLnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBUYWIucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgVGFiLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBUYWI7XG59KCkpO1xuZXhwb3J0cy5UYWIgPSBUYWI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWItYmFyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc3R5bGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZW50L3N0eWxlXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIF9fMSA9IHJlcXVpcmUoXCIuLi8uLi9cIik7XG52YXIgX18yID0gcmVxdWlyZShcIi4uL1wiKTtcbnZhciB0YWdfMSA9IHJlcXVpcmUoXCIuL3dtbC90YWdcIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLlRBR19DT05UUk9MID0gJ3d3LXRhZy1jb250cm9sJztcbmV4cG9ydHMuVEFHX0NPTlRST0xfVEVYVCA9ICd3dy10YWctY29udHJvbF9fdGV4dCc7XG5leHBvcnRzLlRBR19DT05UUk9MX0RJU01JU1MgPSAnd3ctdGFnLWNvbnRyb2xfX2Rpc21pc3MnO1xuLyoqXG4gKiBEaXNtaXNzRXZlbnQgaXMgZ2VuZXJhdGVkIHdoZW4gdGhlIGNsb3NlIGJ1dHRvbiB1cyBjbGlja2VkLlxuICovXG52YXIgRGlzbWlzc0V2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEaXNtaXNzRXZlbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGlzbWlzc0V2ZW50KG5hbWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSwgdW5kZWZpbmVkKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gRGlzbWlzc0V2ZW50O1xufShfXzIuRXZlbnQpKTtcbmV4cG9ydHMuRGlzbWlzc0V2ZW50ID0gRGlzbWlzc0V2ZW50O1xuLyoqXG4gKiBUYWcgZGlzcGxheXMgc29tZSB0ZXh0IGluIGEgZGlzbWlzc2FibGUgdGFnLlxuICpcbiAqIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhpcyBUYWcgYW5kIHRoZSBvbmUgZnJvbSB0aGUgY29udGVudFxuICogbW9kdWxlIGlzIHRoYXQgdGhpcyBvbmUgaXMgcHJpbWFyaWx5IG1lYW50IHRvIGJlIHVzZWQgYXMgYSBjb250cm9sXG4gKiBvciBhcyBwYXJ0IG9mIGEgbW9yZSBjb21wbGljYXRlZCBjb250cm9sLlxuICovXG52YXIgVGFnID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYWcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFnKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB0YWdfMS5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6IF9fMS5nZXRJZChfdGhpcy5hdHRycyksXG4gICAgICAgICAgICBjbGFzc05hbWU6IHV0aWxfMS5jb25jYXQoZXhwb3J0cy5UQUdfQ09OVFJPTCwgX18xLmdldENsYXNzTmFtZShfdGhpcy5hdHRycykpLFxuICAgICAgICAgICAgc3R5bGU6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5zdHlsZSkgP1xuICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LnN0eWxlIDogc3R5bGVfMS5TdHlsZS5EZWZhdWx0LFxuICAgICAgICAgICAgdGV4dDoge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogZXhwb3J0cy5UQUdfQ09OVFJPTF9URVhULFxuICAgICAgICAgICAgICAgIHZhbHVlOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cudGV4dCkgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy50ZXh0IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpc21pc3M6IHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGV4cG9ydHMuVEFHX0NPTlRST0xfRElTTUlTUyxcbiAgICAgICAgICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5vbkRpc21pc3MpXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5vbkRpc21pc3MobmV3IERpc21pc3NFdmVudChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5uYW1lIHx8ICcnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBUYWc7XG59KF9fMi5BYnN0cmFjdENvbnRyb2wpKTtcbmV4cG9ydHMuVGFnID0gVGFnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19zcHJlYWRBcnJheXMgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xuICAgIHJldHVybiByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ID0gcmVxdWlyZShcIi4uLy4uLy4uL2NvbnRlbnQvdGFnXCIpO1xuO1xudmFyIF9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9cIik7XG47XG52YXIgY2xvc2VfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb250ZW50L2Nsb3NlXCIpO1xuO1xuLy9AdHMtaWdub3JlOiA2MTkyXG52YXIgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19pZiA9IGZ1bmN0aW9uIChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkge1xuICAgIHJldHVybiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCgpO1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JJbiA9IGZ1bmN0aW9uIChsaXN0LCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2Zvck9mID0gZnVuY3Rpb24gKG8sIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYWluKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX190aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldCh0LlRhZywgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pZCwgJ2NsYXNzTmFtZSc6IF9fY29udGV4dC52YWx1ZXMuY2xhc3NOYW1lLCAnc3R5bGUnOiBfX2NvbnRleHQudmFsdWVzLnN0eWxlIH0gfSwgX19zcHJlYWRBcnJheXMoKF9faWYoKF9fY29udGV4dC52YWx1ZXMudGV4dC52YWx1ZSAhPT0gXCJcIiksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIChbXG4gICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3NwYW4nLCB7IGh0bWw6IHsgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy50ZXh0LmNsYXNzTmFtZSB9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX18xLnRleHQoX19jb250ZXh0LnZhbHVlcy50ZXh0LnZhbHVlKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKTsgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gKFtcbiAgICAgICAgICAgICAgICBfXzEudGV4dChcIlwiKVxuICAgICAgICAgICAgXSk7IH0pKSwgKF9fY29udGV4dC5jaGlsZHJlbiksIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGNsb3NlXzEuQ2xvc2UsIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuZGlzbWlzcy5jbGFzc05hbWUsICdvbkNsaWNrJzogX19jb250ZXh0LnZhbHVlcy5kaXNtaXNzLm9uQ2xpY2sgfSB9LCBbXSlcbiAgICAgICAgICAgIF0pKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgTWFpbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIE1haW47XG59KCkpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL3RleHQtZmllbGRcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgZmVlZGJhY2tfMSA9IHJlcXVpcmUoXCIuLi9mZWVkYmFja1wiKTtcbnZhciBmb3JtXzEgPSByZXF1aXJlKFwiLi4vZm9ybVwiKTtcbnZhciB0ZXh0X2lucHV0XzEgPSByZXF1aXJlKFwiLi4vdGV4dC1pbnB1dFwiKTtcbmV4cG9ydHMuVGV4dENoYW5nZWRFdmVudCA9IHRleHRfaW5wdXRfMS5UZXh0Q2hhbmdlZEV2ZW50O1xudmFyIF9fMSA9IHJlcXVpcmUoXCIuLi8uLi9cIik7XG52YXIgX18yID0gcmVxdWlyZShcIi4uL1wiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuVEVYVF9GSUVMRCA9ICd3dy10ZXh0LWZpZWxkJztcbi8qKlxuICogVGV4dEZpZWxkIHByb3ZpZGVzIGEgd3JhcHBlZCBuYXRpdmUgdGV4dCBpbnB1dCBjb250cm9sLlxuICovXG52YXIgVGV4dEZpZWxkID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUZXh0RmllbGQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGV4dEZpZWxkKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ3Jvb3QnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IHV0aWxfMS5jb25jYXQoZXhwb3J0cy5URVhUX0ZJRUxELCBfXzEuZ2V0Q2xhc3NOYW1lKF90aGlzLmF0dHJzKSwgZmVlZGJhY2tfMS5nZXRWYWxpZGl0eUNsYXNzTmFtZShfdGhpcy5hdHRycykpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWVzc2FnZXM6IHtcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdtZXNzYWdlJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGV4dDogZmVlZGJhY2tfMS5nZXRNZXNzYWdlKF90aGlzLmF0dHJzKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICAgICAgaWQ6IF9fMi5nZXROYW1lKF90aGlzLmF0dHJzKSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBmb3JtXzEuZ2V0TGFiZWwoX3RoaXMuYXR0cnMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udHJvbDoge1xuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ2NvbnRyb2wnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpZDogX18xLmdldElkKF90aGlzLmF0dHJzKSxcbiAgICAgICAgICAgICAgICBuYW1lOiBfXzIuZ2V0TmFtZShfdGhpcy5hdHRycyksXG4gICAgICAgICAgICAgICAgdHlwZTogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnR5cGUpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cudHlwZSA6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICBmb2N1czogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmZvY3VzKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LmZvY3VzIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cucGxhY2Vob2xkZXIpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cucGxhY2Vob2xkZXIgOiAnJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnZhbHVlKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LnZhbHVlIDogJycsXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5kaXNhYmxlZCkgPyB0cnVlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHJlYWRPbmx5OiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cucmVhZE9ubHkpID9cbiAgICAgICAgICAgICAgICAgICAgdHJ1ZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICByb3dzOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cucm93cykgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5yb3dzIDogMSxcbiAgICAgICAgICAgICAgICBvbmlucHV0OiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cub25DaGFuZ2UpID9cbiAgICAgICAgICAgICAgICAgICAgb25pbnB1dChfdGhpcykgOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5vbkNoYW5nZSkgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5vbkNoYW5nZSA6IGZ1bmN0aW9uICgpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRleHRGaWVsZC5wcm90b3R5cGUuc2V0TWVzc2FnZSA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgZ2V0SGVscCh0aGlzKS5tYXAoZnVuY3Rpb24gKGgpIHsgcmV0dXJuIGguc2V0TWVzc2FnZShtc2cpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUZXh0RmllbGQucHJvdG90eXBlLnJlbW92ZU1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGdldEhlbHAodGhpcykubWFwKGZ1bmN0aW9uIChoKSB7IHJldHVybiBoLnJlbW92ZU1lc3NhZ2UoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIFRleHRGaWVsZDtcbn0oZm9ybV8xLkFic3RyYWN0Rm9ybUNvbnRyb2wpKTtcbmV4cG9ydHMuVGV4dEZpZWxkID0gVGV4dEZpZWxkO1xudmFyIGdldEhlbHAgPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB1dGlsXzEuZ2V0QnlJZCh0LnZpZXcsIHQudmFsdWVzLm1lc3NhZ2VzLndtbC5pZCk7XG59O1xudmFyIG9uaW5wdXQgPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZi5hdHRycy53dyAmJiBmLmF0dHJzLnd3ICYmIGYuYXR0cnMud3cub25DaGFuZ2UpXG4gICAgICAgIGYuYXR0cnMud3cub25DaGFuZ2UobmV3IHRleHRfaW5wdXRfMS5UZXh0Q2hhbmdlZEV2ZW50KChmLmF0dHJzLnd3ICYmIGYuYXR0cnMud3cubmFtZSkgP1xuICAgICAgICAgICAgZi5hdHRycy53dy5uYW1lIDogJycsIGUudGFyZ2V0LnZhbHVlKSk7XG59OyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbGFiZWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9sYWJlbFwiKTtcbjtcbnZhciBoZWxwXzEgPSByZXF1aXJlKFwiLi4vLi4vaGVscFwiKTtcbjtcbnZhciB0ZXh0X2lucHV0XzEgPSByZXF1aXJlKFwiLi4vLi4vdGV4dC1pbnB1dFwiKTtcbjtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdkaXYnLCB7IGh0bWw6IHsgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5yb290LmNsYXNzTmFtZSB9LCB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5yb290LndtbC5pZCB9IH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGxhYmVsXzEuTGFiZWwsIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdmb3InOiBfX2NvbnRleHQudmFsdWVzLmNvbnRyb2wuaWQsICd0ZXh0JzogX19jb250ZXh0LnZhbHVlcy5sYWJlbC50ZXh0IH0gfSwgW10pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQodGV4dF9pbnB1dF8xLlRleHRJbnB1dCwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5jb250cm9sLmlkLCAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMuY29udHJvbC5uYW1lLCAnZm9jdXMnOiBfX2NvbnRleHQudmFsdWVzLmNvbnRyb2wuZm9jdXMsICdwbGFjZWhvbGRlcic6IF9fY29udGV4dC52YWx1ZXMuY29udHJvbC5wbGFjZWhvbGRlciwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5jb250cm9sLm9uQ2hhbmdlLCAnYmxvY2snOiB0cnVlLCAndHlwZSc6IF9fY29udGV4dC52YWx1ZXMuY29udHJvbC50eXBlLCAndmFsdWUnOiBfX2NvbnRleHQudmFsdWVzLmNvbnRyb2wudmFsdWUsICdyb3dzJzogX19jb250ZXh0LnZhbHVlcy5jb250cm9sLnJvd3MsICdkaXNhYmxlZCc6IF9fY29udGV4dC52YWx1ZXMuY29udHJvbC5kaXNhYmxlZCwgJ3JlYWRPbmx5JzogX19jb250ZXh0LnZhbHVlcy5jb250cm9sLnJlYWRPbmx5IH0gfSwgW10pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoaGVscF8xLkhlbHAsIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLm1lc3NhZ2VzLndtbC5pZCB9LCB3dzogeyAndGV4dCc6IF9fY29udGV4dC52YWx1ZXMubWVzc2FnZXMudGV4dCB9IH0sIFtdKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZXh0LWZpZWxkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvdGV4dC1pbnB1dFwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBvcmllbnRhdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRlbnQvb3JpZW50YXRpb25cIik7XG52YXIgc2l6ZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRlbnQvc2l6ZVwiKTtcbnZhciBmb2N1c18xID0gcmVxdWlyZShcIi4uL2ZvY3VzXCIpO1xudmFyIF9fMSA9IHJlcXVpcmUoXCIuLi8uLi9cIik7XG52YXIgX18yID0gcmVxdWlyZShcIi4uL1wiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuVEVYVF9JTlBVVCA9ICd3dy10ZXh0LWlucHV0Jztcbi8qKlxuICogVGV4dENoYW5nZWRFdmVudFxuICovXG52YXIgVGV4dENoYW5nZWRFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGV4dENoYW5nZWRFdmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUZXh0Q2hhbmdlZEV2ZW50KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBUZXh0Q2hhbmdlZEV2ZW50O1xufShfXzIuRXZlbnQpKTtcbmV4cG9ydHMuVGV4dENoYW5nZWRFdmVudCA9IFRleHRDaGFuZ2VkRXZlbnQ7XG4vKipcbiAqIFRleHRJbnB1dCBwcm92aWRlcyBzb21lIGV4dHJhIHN0eWxpbmcgdG8gdGhlIG5hdGl2ZSBpbnB1dC5cbiAqL1xudmFyIFRleHRJbnB1dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGV4dElucHV0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRleHRJbnB1dCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cucm93cyAmJiBfdGhpcy5hdHRycy53dy5yb3dzID4gMSkgP1xuICAgICAgICAgICAgbmV3IHZpZXdzLlRleHRhcmVhKF90aGlzKSA6IG5ldyB2aWV3cy5JbnB1dChfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGNvbnRyb2w6IHtcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdyb290J1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZDogX18xLmdldElkKF90aGlzLmF0dHJzKSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogdXRpbF8xLmNvbmNhdChleHBvcnRzLlRFWFRfSU5QVVQsIF9fMS5nZXRDbGFzc05hbWUoX3RoaXMuYXR0cnMpLCAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuc2l6ZSkgP1xuICAgICAgICAgICAgICAgIHNpemVfMS5nZXRTaXplQ2xhc3NOYW1lKF90aGlzLmF0dHJzLnd3LnNpemUpIDogJycsIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5ibG9jaykgP1xuICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uXzEuQkxPQ0sgOiAnJyksXG4gICAgICAgICAgICBuYW1lOiBfXzIuZ2V0TmFtZShfdGhpcy5hdHRycyksXG4gICAgICAgICAgICB0eXBlOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cudHlwZSkgP1xuICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LnR5cGUgOiAndGV4dCcsXG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnBsYWNlaG9sZGVyKSA/XG4gICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cucGxhY2Vob2xkZXIgOiAnJyxcbiAgICAgICAgICAgIHZhbHVlOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cudmFsdWUpID9cbiAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy52YWx1ZSA6ICcnLFxuICAgICAgICAgICAgcm93czogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnJvd3MpID9cbiAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5yb3dzIDogMSxcbiAgICAgICAgICAgIGRpc2FibGVkOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuZGlzYWJsZWQgPT09IHRydWUpID9cbiAgICAgICAgICAgICAgICB0cnVlIDogbnVsbCxcbiAgICAgICAgICAgIHJlYWRPbmx5OiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cucmVhZE9ubHkgPT09IHRydWUpID9cbiAgICAgICAgICAgICAgICB0cnVlIDogbnVsbCxcbiAgICAgICAgICAgIG9uaW5wdXQ6IGRpc3BhdGNoSW5wdXQoX3RoaXMpLFxuICAgICAgICAgICAgZm9jdXM6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5mb2N1cykgPyB0cnVlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgb25mb2N1czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5vbkZvY3VzR2FpbmVkKVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5vbkZvY3VzR2FpbmVkKG5ldyBmb2N1c18xLkZvY3VzR2FpbmVkRXZlbnQoX18yLmdldE5hbWUoX3RoaXMuYXR0cnMpKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25ibHVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm9uRm9jdXNMb3N0KVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5vbkZvY3VzTG9zdChuZXcgZm9jdXNfMS5Gb2N1c0xvc3RFdmVudChfXzIuZ2V0TmFtZShfdGhpcy5hdHRycykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUZXh0SW5wdXQucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZm9jdXNfMS5mb2N1cyh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLmNvbnRyb2wud21sLmlkKTtcbiAgICB9O1xuICAgIHJldHVybiBUZXh0SW5wdXQ7XG59KF9fMi5BYnN0cmFjdENvbnRyb2wpKTtcbmV4cG9ydHMuVGV4dElucHV0ID0gVGV4dElucHV0O1xuLyoqXG4gKiBkaXNwYXRjaElucHV0IHdoZW4gdGhlIHVzZXIgaW5wdXRzIHNvbWUgdGV4dC5cbiAqL1xudmFyIGRpc3BhdGNoSW5wdXQgPSBmdW5jdGlvbiAoaSkgeyByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoaS5hdHRycy53dyAmJiBpLmF0dHJzLnd3Lm9uQ2hhbmdlKVxuICAgICAgICBpLmF0dHJzLnd3Lm9uQ2hhbmdlKG5ldyBUZXh0Q2hhbmdlZEV2ZW50KChpLmF0dHJzICYmIGkuYXR0cnMud3cubmFtZSkgP1xuICAgICAgICAgICAgaS5hdHRycy53dy5uYW1lIDogJycsIGUudGFyZ2V0LnZhbHVlKSk7XG59OyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBUZXh0YXJlYSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZXh0YXJlYShfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCd0ZXh0YXJlYScsIHsgaHRtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmlkLCAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMubmFtZSwgJ3BsYWNlaG9sZGVyJzogX19jb250ZXh0LnZhbHVlcy5wbGFjZWhvbGRlciwgJ29uaW5wdXQnOiBfX2NvbnRleHQudmFsdWVzLm9uaW5wdXQsICd2YWx1ZSc6IF9fY29udGV4dC52YWx1ZXMudmFsdWUsICdkaXNhYmxlZCc6IF9fY29udGV4dC52YWx1ZXMuZGlzYWJsZWQsICdyZWFkb25seSc6IF9fY29udGV4dC52YWx1ZXMucmVhZE9ubHksICdyb3dzJzogX19jb250ZXh0LnZhbHVlcy5yb3dzLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmNsYXNzTmFtZSB9LCB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5jb250cm9sLndtbC5pZCB9IH0sIFtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShfX2NvbnRleHQudmFsdWVzLnZhbHVlKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIFRleHRhcmVhLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgVGV4dGFyZWEucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIFRleHRhcmVhLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIFRleHRhcmVhLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIFRleHRhcmVhLnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBUZXh0YXJlYS5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBUZXh0YXJlYS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gVGV4dGFyZWE7XG59KCkpO1xuZXhwb3J0cy5UZXh0YXJlYSA9IFRleHRhcmVhO1xuO1xudmFyIElucHV0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElucHV0KF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX190aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ2lucHV0JywgeyBodG1sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuaWQsICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5uYW1lLCAndHlwZSc6IF9fY29udGV4dC52YWx1ZXMudHlwZSwgJ3BsYWNlaG9sZGVyJzogX19jb250ZXh0LnZhbHVlcy5wbGFjZWhvbGRlciwgJ29uaW5wdXQnOiBfX2NvbnRleHQudmFsdWVzLm9uaW5wdXQsICd2YWx1ZSc6IF9fY29udGV4dC52YWx1ZXMudmFsdWUsICdkaXNhYmxlZCc6IF9fY29udGV4dC52YWx1ZXMuZGlzYWJsZWQsICdyZWFkb25seSc6IF9fY29udGV4dC52YWx1ZXMucmVhZE9ubHksICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuY2xhc3NOYW1lIH0sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmNvbnRyb2wud21sLmlkIH0gfSwgW10pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBJbnB1dC5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIElucHV0LnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBJbnB1dC5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBJbnB1dC5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBJbnB1dC5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgSW5wdXQucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgSW5wdXQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIElucHV0O1xufSgpKTtcbmV4cG9ydHMuSW5wdXQgPSBJbnB1dDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRleHQtaW5wdXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC90b29sYmFyXCIpO1xudmFyIHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgX18xID0gcmVxdWlyZShcIi4uLy4uL1wiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuVE9PTEJBUiA9ICd3dy10b29sYmFyJztcbmV4cG9ydHMuVE9PTEJBUl9DT01QQVQgPSAnLXRvb2xiYXItY29tcGF0Jztcbi8qKlxuICogVG9vbGJhciBwcm92aWRlcyBhIHdpZGdldCBmb3IgZ3JvdXBpbmcgcmVsYXRlZCBjb250cm9scyBpbnRvIGFcbiAqIHNpbmdsZSByb3cuXG4gKi9cbnZhciBUb29sYmFyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUb29sYmFyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRvb2xiYXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgaWQ6IF9fMS5nZXRJZChfdGhpcy5hdHRycyksXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiB1dGlsXzEuY29uY2F0KGV4cG9ydHMuVE9PTEJBUiwgX18xLmdldENsYXNzTmFtZShfdGhpcy5hdHRycykpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRvb2xiYXI7XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5Ub29sYmFyID0gVG9vbGJhcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fc3ByZWFkQXJyYXlzID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5cykgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcbiAgICByZXR1cm4gcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnZGl2JywgeyBodG1sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMucm9vdC5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5yb290LmNsYXNzTmFtZSB9LCB3bWw6IHt9IH0sIF9fc3ByZWFkQXJyYXlzKChfX2NvbnRleHQuY2hpbGRyZW4pKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b29sYmFyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvdHlwZWFoZWFkXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIGZvcm1fMSA9IHJlcXVpcmUoXCIuLi9mb3JtXCIpO1xudmFyIHNlYXJjaF8xID0gcmVxdWlyZShcIi4uL3NlYXJjaFwiKTtcbmV4cG9ydHMuVGVybUNoYW5nZWRFdmVudCA9IHNlYXJjaF8xLlRlcm1DaGFuZ2VkRXZlbnQ7XG52YXIgdGV4dF9maWVsZF8xID0gcmVxdWlyZShcIi4uL3RleHQtZmllbGRcIik7XG5leHBvcnRzLlRleHRDaGFuZ2VkRXZlbnQgPSB0ZXh0X2ZpZWxkXzEuVGV4dENoYW5nZWRFdmVudDtcbnZhciBzZWxlY3RfMSA9IHJlcXVpcmUoXCIuLi9zZWxlY3RcIik7XG5leHBvcnRzLkl0ZW1TZWxlY3RlZEV2ZW50ID0gc2VsZWN0XzEuSXRlbVNlbGVjdGVkRXZlbnQ7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLlRZUEVBSEVBRCA9ICd3dy10eXBlYWhlYWQnO1xuLyoqXG4gKiBUeXBlYWhlYWQgcHJvdmlkZXMgYW4gdGV4dCBpbnB1dCBmaWVsZCB0aGF0IGNhbiBzdWdnZXN0cyB2YWx1ZXNcbiAqIGFzIHRoZSB1c2VyIHR5cGVzLlxuICovXG52YXIgVHlwZWFoZWFkID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUeXBlYWhlYWQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVHlwZWFoZWFkKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgcm9vdDogbmV3IHNlbGVjdF8xLlJvb3RTZWN0aW9uKF90aGlzLmF0dHJzKSxcbiAgICAgICAgICAgIGNvbnRyb2w6IG5ldyBzZWxlY3RfMS5Db250cm9sU2VjdGlvbigpLFxuICAgICAgICAgICAgbWVzc2FnZXM6IG5ldyBzZWxlY3RfMS5NZXNzYWdlc1NlY3Rpb24oX3RoaXMuYXR0cnMpLFxuICAgICAgICAgICAgbGFiZWw6IG5ldyBzZWxlY3RfMS5MYWJlbFNlY3Rpb24oX3RoaXMuYXR0cnMpLFxuICAgICAgICAgICAgc2VhcmNoOiBuZXcgc2VsZWN0XzEuU2VhcmNoU2VjdGlvbihfdGhpcy5hdHRycywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY2xvc2UoKTsgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHZhciBtU2VhcmNoID0gdXRpbF8xLmdldEJ5SWQoX3RoaXMudmlldywgX3RoaXMudmFsdWVzLnNlYXJjaC53bWwuaWQpO1xuICAgICAgICAgICAgICAgIGlmIChtU2VhcmNoLmlzSnVzdCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gbVNlYXJjaC5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0ciA9IChfdGhpcy52YWx1ZXMuc2VhcmNoLnN0cmluZ2lmaWVyKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZXMuc2VhcmNoLnN0cmluZ2lmaWVyKGUudmFsdWUpIDogZS52YWx1ZSArICcnO1xuICAgICAgICAgICAgICAgICAgICBzLnNldChzdHIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cub25DaGFuZ2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5vbkNoYW5nZShuZXcgdGV4dF9maWVsZF8xLlRleHRDaGFuZ2VkRXZlbnQoJycgKyBfdGhpcy5hdHRycy53dy5uYW1lLCBzdHIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFR5cGVhaGVhZC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZWN0XzEub3Blbih0aGlzLnZpZXcsIHRoaXMudmFsdWVzLnNlYXJjaC53bWwuaWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR5cGVhaGVhZC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGVjdF8xLmNsb3NlKHRoaXMudmlldywgdGhpcy52YWx1ZXMuc2VhcmNoLndtbC5pZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHlwZWFoZWFkLnByb3RvdHlwZS5zZXRNZXNzYWdlID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICB0aGlzLnZhbHVlcy5tZXNzYWdlcy50ZXh0ID0gbXNnO1xuICAgICAgICBmb3JtXzEuc2V0TWVzc2FnZSh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLm1lc3NhZ2VzLndtbC5pZCwgbXNnKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUeXBlYWhlYWQucHJvdG90eXBlLnJlbW92ZU1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmFsdWVzLm1lc3NhZ2VzLnRleHQgPSAnJztcbiAgICAgICAgZm9ybV8xLnJlbW92ZU1lc3NhZ2UodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5tZXNzYWdlcy53bWwuaWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR5cGVhaGVhZC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHJlc3VsdHMpIHtcbiAgICAgICAgc2VsZWN0XzEudXBkYXRlKHRoaXMudmlldywgdGhpcy52YWx1ZXMuc2VhcmNoLndtbC5pZCwgcmVzdWx0cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIFR5cGVhaGVhZDtcbn0oZm9ybV8xLkFic3RyYWN0Rm9ybUNvbnRyb2wpKTtcbmV4cG9ydHMuVHlwZWFoZWFkID0gVHlwZWFoZWFkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc2VhcmNoXzEgPSByZXF1aXJlKFwiLi4vLi4vc2VhcmNoXCIpO1xuO1xudmFyIGxhYmVsXzEgPSByZXF1aXJlKFwiLi4vLi4vbGFiZWxcIik7XG47XG52YXIgaGVscF8xID0gcmVxdWlyZShcIi4uLy4uL2hlbHBcIik7XG47XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnZGl2JywgeyBodG1sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMucm9vdC5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5yb290LmNsYXNzTmFtZSB9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGxhYmVsXzEuTGFiZWwsIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdmb3InOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuaWQsICd0ZXh0JzogX19jb250ZXh0LnZhbHVlcy5sYWJlbC50ZXh0IH0gfSwgW10pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoc2VhcmNoXzEuU2VhcmNoLCB7IGh0bWw6IHt9LCB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2gud21sLmlkIH0sIHd3OiB7ICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2gubmFtZSwgJ2NsYXNzTmFtZSc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLmNsYXNzTmFtZSwgJ2Jsb2NrJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2guYmxvY2ssICdwbGFjZWhvbGRlcic6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLnBsYWNlaG9sZGVyLCAncmVhZE9ubHknOiBfX2NvbnRleHQudmFsdWVzLnNlYXJjaC5yZWFkT25seSwgJ2l0ZW1UZW1wbGF0ZSc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLml0ZW1UZW1wbGF0ZSwgJ25vSXRlbXNUZW1wbGF0ZSc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLm5vSXRlbXNUZW1wbGF0ZSwgJ3N0cmluZ2lmaWVyJzogX19jb250ZXh0LnZhbHVlcy5zZWFyY2guc3RyaW5naWZpZXIsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMuc2VhcmNoLm9uU2VhcmNoLCAnb25TZWxlY3QnOiBfX2NvbnRleHQudmFsdWVzLnNlYXJjaC5vblNlbGVjdCB9IH0sIFtdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGhlbHBfMS5IZWxwLCB7IGh0bWw6IHt9LCB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5tZXNzYWdlcy53bWwuaWQgfSwgd3c6IHsgJ3RleHQnOiBfX2NvbnRleHQudmFsdWVzLm1lc3NhZ2VzLnRleHQgfSB9LCBbXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBNYWluLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gTWFpbjtcbn0oKSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZWFoZWFkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBwYXRoXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvcmVjb3JkL3BhdGhcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgX18xID0gcmVxdWlyZShcIi4uLy4uL1wiKTtcbnZhciBwcm9wZXJ0eV9saXN0XzEgPSByZXF1aXJlKFwiLi93bWwvcHJvcGVydHktbGlzdFwiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuUFJPUEVSVFlfTElTVCA9ICd3dy1wcm9wZXJ0eS1saXN0Jztcbi8qKlxuICogUHJvcGVydHlMaXN0IGdlbmVyYXRlcyBhIGRlc2NyaXB0aW9uIGxpc3QgdXNpbmcgdGhlIHByb3BlcnRpZXMgb2ZcbiAqIGFuIG9iamVjdC5cbiAqL1xudmFyIFByb3BlcnR5TGlzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUHJvcGVydHlMaXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFByb3BlcnR5TGlzdCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgcHJvcGVydHlfbGlzdF8xLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiB1dGlsXzEuY29uY2F0KGV4cG9ydHMuUFJPUEVSVFlfTElTVCwgX18xLmdldENsYXNzTmFtZShfdGhpcy5hdHRycykpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmllbGRzOiAoKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmZpZWxkcykgP1xuICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LmZpZWxkcyA6IFtdKSxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogKChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5kYXRhKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LmRhdGEgOiB7fSksXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbURhdGEgPSBwYXRoXzEuZ2V0KGYubmFtZSwgX3RoaXMudmFsdWVzLmRhdGEudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobURhdGEuaXNOb3RoaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW19fMS50ZXh0KCctJyldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IG1EYXRhLmdldCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZi5kYXRhRnJhZ21lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZi5kYXRhRnJhZ21lbnQoZCwgZi5uYW1lLCBfdGhpcy52YWx1ZXMuZGF0YS52YWx1ZSkoX3RoaXMudmlldyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmLmZvcm1hdClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbX18xLnRleHQoJycgKyBmLmZvcm1hdChkKSldO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW19fMS50ZXh0KCcnICsgZCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBzZXREYXRhIHRvIGJlIGRpc3BsYXllZC5cbiAgICAgKi9cbiAgICBQcm9wZXJ0eUxpc3QucHJvdG90eXBlLnNldERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLnZhbHVlcy5kYXRhLnZhbHVlID0gZGF0YTtcbiAgICAgICAgdGhpcy52aWV3LmludmFsaWRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gUHJvcGVydHlMaXN0O1xufSh3bWxfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuUHJvcGVydHlMaXN0ID0gUHJvcGVydHlMaXN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19zcHJlYWRBcnJheXMgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xuICAgIHJldHVybiByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbjtcbnZhciBfXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vXCIpO1xuO1xudmFyIGRlc2NyaXB0aW9uX2xpc3RfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9sYXlvdXQvZGVzY3JpcHRpb24tbGlzdFwiKTtcbjtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQoZGVzY3JpcHRpb25fbGlzdF8xLkRlc2NyaXB0aW9uTGlzdCwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ2NsYXNzTmFtZSc6IF9fY29udGV4dC52YWx1ZXMucm9vdC5jbGFzc05hbWUgfSB9LCBfX3NwcmVhZEFycmF5cyhfX2ZvckluKF9fY29udGV4dC52YWx1ZXMuZmllbGRzLCBmdW5jdGlvbiAoZmllbGQsIF8kJGksIF8kJGFsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGRlc2NyaXB0aW9uX2xpc3RfMS5UaXRsZSwgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfXzEudGV4dChmaWVsZC5oZWFkaW5nKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChkZXNjcmlwdGlvbl9saXN0XzEuRGF0YSwgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBfX3NwcmVhZEFycmF5cygoX19jb250ZXh0LnZhbHVlcy5kYXRhLmdldChmaWVsZCkpKSlcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIChbXSk7IH0pKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9wZXJ0eS1saXN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHBhdGhfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9yZWNvcmQvcGF0aFwiKTtcbnZhciBzb3J0XzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvYXJyYXkvc29ydFwiKTtcbi8qKlxuICogU29ydFJlcXVlc3QgY29udGFpbnMgdGhlIGluZm8gbmVlZGVkIHRvIHByZWZvcm0gYSBzb3J0LlxuICovXG52YXIgU29ydFJlcXVlc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU29ydFJlcXVlc3QoY29sdW1uLCBkYXRhLCBrZXkpIHtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIH1cbiAgICByZXR1cm4gU29ydFJlcXVlc3Q7XG59KCkpO1xuZXhwb3J0cy5Tb3J0UmVxdWVzdCA9IFNvcnRSZXF1ZXN0O1xuLyoqXG4gKiBzb3J0QnlJZCBzb3J0cyBhIGRhdGFzZXQgYnkgYSBjb2x1bW4gdXNpbmcgdGhlIGNvbHVtbnMgaWQuXG4gKlxuICogRGF0YSBpcyBvbmx5IHNvcnRlZCBieSBvbmUgY29sdW1uIGF0IGEgdGltZS5cbiAqL1xuZXhwb3J0cy5zb3J0QnlJZCA9IGZ1bmN0aW9uIChjb2xzLCBrZXksIGRhdGEsIGlkKSB7XG4gICAgdmFyIHNwZWMgPSBjb2xzW2lkXTtcbiAgICB2YXIgY3VycmVudCA9IGRhdGFbMF0sIG9yaWdpbmFsID0gZGF0YVsxXTtcbiAgICBpZiAoc3BlYyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gW2N1cnJlbnQsIGtleV07XG4gICAgaWYgKCFzcGVjLnNvcnQpXG4gICAgICAgIHJldHVybiBbY3VycmVudCwga2V5XTtcbiAgICBpZiAoa2V5WzBdID09PSBpZCkge1xuICAgICAgICByZXR1cm4gW2N1cnJlbnQucmV2ZXJzZSgpLCBba2V5WzBdLCBrZXlbMV0gKiAtMV1dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHN0cmF0ZWd5ID0gZ2V0U29ydFN0cmF0ZWd5KHNwZWMuc29ydCk7XG4gICAgICAgIHZhciBhbGlhcyA9IHNwZWMuYWxpYXMgPyBzcGVjLmFsaWFzIDogc3BlYy5uYW1lO1xuICAgICAgICByZXR1cm4gW2RvU29ydChvcmlnaW5hbC5zbGljZSgpLCBzdHJhdGVneSwgYWxpYXMpLCBbaWQsIC0xXV07XG4gICAgfVxufTtcbnZhciBnZXRTb3J0U3RyYXRlZ3kgPSBmdW5jdGlvbiAocykge1xuICAgIGlmICh0eXBlb2YgcyA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgaWYgKHMgPT09ICdkYXRlJylcbiAgICAgICAgcmV0dXJuIHNvcnRfMS5kYXRlO1xuICAgIGlmIChzID09PSAnbnVtYmVyJylcbiAgICAgICAgcmV0dXJuIHNvcnRfMS5udW1iZXI7XG4gICAgaWYgKHMgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gc29ydF8xLnN0cmluZztcbiAgICByZXR1cm4gc29ydF8xLm5hdHVyYWw7XG59O1xudmFyIGRvU29ydCA9IGZ1bmN0aW9uIChkYXRhLCBzLCBhbGlhcykge1xuICAgIHJldHVybiBkYXRhLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIHMoZ2V0QW55KGFsaWFzLCBhKSwgZ2V0QW55KGFsaWFzLCBiKSk7IH0pO1xufTtcbnZhciBnZXRBbnkgPSBmdW5jdGlvbiAocGF0aCwgc3JjKSB7XG4gICAgcmV0dXJuIHBhdGhfMS5nZXREZWZhdWx0KHBhdGgsIHNyYywgdW5kZWZpbmVkKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zb3J0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBIZWFkaW5nQ2xpY2tlZEV2ZW50IGlzIHRyaWdnZXJlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvblxuICogb25lIG9mIHRoZSBjb2x1bW4gaGVhZGluZ3MuXG4gKi9cbnZhciBIZWFkaW5nQ2xpY2tlZEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEhlYWRpbmdDbGlja2VkRXZlbnQoY29sdW1uKSB7XG4gICAgICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICAgIH1cbiAgICByZXR1cm4gSGVhZGluZ0NsaWNrZWRFdmVudDtcbn0oKSk7XG5leHBvcnRzLkhlYWRpbmdDbGlja2VkRXZlbnQgPSBIZWFkaW5nQ2xpY2tlZEV2ZW50O1xuLyoqXG4gKiBDZWxsQ2xpY2tlZEV2ZW50IHRyaWdnZXJlZCB3aGVuIGEgY2VsbCBpcyBjbGlja2VkIG9uLlxuICovXG52YXIgQ2VsbENsaWNrZWRFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDZWxsQ2xpY2tlZEV2ZW50KGNvbHVtbiwgcm93KSB7XG4gICAgICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICAgICAgICB0aGlzLnJvdyA9IHJvdztcbiAgICB9XG4gICAgcmV0dXJuIENlbGxDbGlja2VkRXZlbnQ7XG59KCkpO1xuZXhwb3J0cy5DZWxsQ2xpY2tlZEV2ZW50ID0gQ2VsbENsaWNrZWRFdmVudDtcbi8qKlxuICogRGF0YUNoYW5nZWRFdmVudCBnZW5lcmF0ZWQgd2hlbiB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGRhdGFcbiAqIGNoYW5nZXMuXG4gKi9cbnZhciBEYXRhQ2hhbmdlZEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERhdGFDaGFuZ2VkRXZlbnQoZGF0YSwga2V5KSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIH1cbiAgICByZXR1cm4gRGF0YUNoYW5nZWRFdmVudDtcbn0oKSk7XG5leHBvcnRzLkRhdGFDaGFuZ2VkRXZlbnQgPSBEYXRhQ2hhbmdlZEV2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXZlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC90YWJsZVwiKTtcbnZhciB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIGFycmF5XzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvYXJyYXlcIik7XG52YXIgcGF0aF8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL3JlY29yZC9wYXRoXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIF9fMSA9IHJlcXVpcmUoXCIuLi8uLi9cIik7XG52YXIgc29ydF8xID0gcmVxdWlyZShcIi4vY29sdW1uL3NvcnRcIik7XG5leHBvcnRzLlNvcnRSZXF1ZXN0ID0gc29ydF8xLlNvcnRSZXF1ZXN0O1xudmFyIGV2ZW50XzEgPSByZXF1aXJlKFwiLi9ldmVudFwiKTtcbmV4cG9ydHMuRGF0YUNoYW5nZWRFdmVudCA9IGV2ZW50XzEuRGF0YUNoYW5nZWRFdmVudDtcbmV4cG9ydHMuQ2VsbENsaWNrZWRFdmVudCA9IGV2ZW50XzEuQ2VsbENsaWNrZWRFdmVudDtcbmV4cG9ydHMuSGVhZGluZ0NsaWNrZWRFdmVudCA9IGV2ZW50XzEuSGVhZGluZ0NsaWNrZWRFdmVudDtcbnZhciByYW5nZV8xID0gcmVxdWlyZShcIi4vcmFuZ2VcIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLkRBVEFfVEFCTEUgPSAnd3ctZGF0YS10YWJsZSc7XG5leHBvcnRzLkRBVEFfVEFCTEVfSEVBRCA9ICd3dy1kYXRhLXRhYmxlX19oZWFkJztcbmV4cG9ydHMuREFUQV9UQUJMRV9IRUFESU5HID0gJ3d3LWRhdGEtdGFibGVfX2hlYWRpbmcnO1xuZXhwb3J0cy5EQVRBX1RBQkxFX0JPRFkgPSAnd3ctZGF0YS10YWJsZV9fYm9keSc7XG5leHBvcnRzLkRBVEFfVEFCTEVfQ0VMTCA9ICd3dy1kYXRhLXRhYmxlX19jZWxsJztcbmV4cG9ydHMuQVNDID0gJy1hc2MnO1xuZXhwb3J0cy5ERVNDID0gJy1kZXNjJztcbi8qKlxuICogTmV3SGVhZENvbnRleHRcbiAqL1xudmFyIE5ld0hlYWRDb250ZXh0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5ld0hlYWRDb250ZXh0KHRhYmxlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudGFibGUgPSB0YWJsZTtcbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSB1dGlsXzEuY29uY2F0KGV4cG9ydHMuREFUQV9UQUJMRV9IRUFELCAodGhpcy50YWJsZS5hdHRycy53dyAmJiB0aGlzLnRhYmxlLmF0dHJzLnd3LmhlYWRDbGFzc05hbWUgfHwgJycpKTtcbiAgICAgICAgdGhpcy5jb2x1bW5zID0gdGhpcy50YWJsZS52YWx1ZXMuY29sdW1ucztcbiAgICAgICAgdGhpcy5kYXRhID0gdGhpcy50YWJsZS52YWx1ZXMuZGF0YXNldFswXTtcbiAgICAgICAgdGhpcy5oZWFkaW5nID0gZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0SGVhZGluZ1ZpZXcoX3RoaXMudGFibGUsIG5ldyBOZXdIZWFkaW5nQ29udGV4dChfdGhpcy50YWJsZSwgX3RoaXMsIGMsIGkpLCBjKS5yZW5kZXIoKTtcbiAgICAgICAgfTsgfTtcbiAgICB9XG4gICAgcmV0dXJuIE5ld0hlYWRDb250ZXh0O1xufSgpKTtcbmV4cG9ydHMuTmV3SGVhZENvbnRleHQgPSBOZXdIZWFkQ29udGV4dDtcbi8qKlxuICogTmV3SGVhZGluZ0NvbnRleHRcbiAqL1xudmFyIE5ld0hlYWRpbmdDb250ZXh0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5ld0hlYWRpbmdDb250ZXh0KHRhYmxlLCBoZWFkQ29udGV4dCwgY29sdW1uLCBpbmRleCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRhYmxlID0gdGFibGU7XG4gICAgICAgIHRoaXMuaGVhZENvbnRleHQgPSBoZWFkQ29udGV4dDtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSB1dGlsXzEuY29uY2F0KGV4cG9ydHMuREFUQV9UQUJMRV9IRUFESU5HLCAodGhpcy50YWJsZS5hdHRycy53dyAmJiB0aGlzLnRhYmxlLmF0dHJzLnd3LmhlYWRpbmdDbGFzc05hbWUgfHwgJycpLCB0aGlzLmNvbHVtbi5oZWFkaW5nQ2xhc3NOYW1lLCBnZXRTb3J0Q2xhc3NOYW1lKHRoaXMudGFibGUudmFsdWVzLnNvcnRLZXksIHRoaXMuaW5kZXgpKTtcbiAgICAgICAgdGhpcy5vbmNsaWNrID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5jb2x1bW4uc29ydClcbiAgICAgICAgICAgICAgICBfdGhpcy50YWJsZS52YWx1ZXMuc29ydChfdGhpcy5pbmRleCk7XG4gICAgICAgICAgICBpZiAoX3RoaXMuY29sdW1uLm9uSGVhZGluZ0NsaWNrZWQpXG4gICAgICAgICAgICAgICAgX3RoaXMuY29sdW1uLm9uSGVhZGluZ0NsaWNrZWQobmV3IGV2ZW50XzEuSGVhZGluZ0NsaWNrZWRFdmVudChfdGhpcy5pbmRleCkpO1xuICAgICAgICAgICAgaWYgKF90aGlzLnRhYmxlLmF0dHJzLnd3ICYmIF90aGlzLnRhYmxlLmF0dHJzLnd3Lm9uSGVhZGluZ0NsaWNrZWQpXG4gICAgICAgICAgICAgICAgX3RoaXMudGFibGUuYXR0cnMud3cub25IZWFkaW5nQ2xpY2tlZChuZXcgZXZlbnRfMS5IZWFkaW5nQ2xpY2tlZEV2ZW50KF90aGlzLmluZGV4KSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBOZXdIZWFkaW5nQ29udGV4dDtcbn0oKSk7XG5leHBvcnRzLk5ld0hlYWRpbmdDb250ZXh0ID0gTmV3SGVhZGluZ0NvbnRleHQ7XG4vKipcbiAqIE5ld0JvZHlDb250ZXh0XG4gKi9cbnZhciBOZXdCb2R5Q29udGV4dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOZXdCb2R5Q29udGV4dCh0YWJsZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRhYmxlID0gdGFibGU7XG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gdXRpbF8xLmNvbmNhdChleHBvcnRzLkRBVEFfVEFCTEVfQk9EWSwgKHRoaXMudGFibGUuYXR0cnMud3cgJiYgdGhpcy50YWJsZS5hdHRycy53dy5ib2R5Q2xhc3NOYW1lIHx8ICcnKSk7XG4gICAgICAgIHRoaXMuY29sdW1ucyA9IHRoaXMudGFibGUudmFsdWVzLmNvbHVtbnM7XG4gICAgICAgIHRoaXMuZGF0YSA9IHRoaXMudGFibGUudmFsdWVzLmRhdGFzZXRbMF07XG4gICAgICAgIHRoaXMuY2VsbCA9IGZ1bmN0aW9uIChjKSB7IHJldHVybiBmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDZWxsVmlldyhfdGhpcy50YWJsZSwgbmV3IE5ld0NlbGxDb250ZXh0KF90aGlzLnRhYmxlLCBfdGhpcywgYywgaWQsIHJvdyksIGMpLnJlbmRlcigpO1xuICAgICAgICB9OyB9OyB9O1xuICAgIH1cbiAgICByZXR1cm4gTmV3Qm9keUNvbnRleHQ7XG59KCkpO1xuZXhwb3J0cy5OZXdCb2R5Q29udGV4dCA9IE5ld0JvZHlDb250ZXh0O1xuLyoqXG4gKiBOZXdDZWxsQ29udGV4dFxuICovXG52YXIgTmV3Q2VsbENvbnRleHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmV3Q2VsbENvbnRleHQodGFibGUsIGJvZHlDb250ZXh0LCBzcGVjLCBjb2x1bW4sIHJvdykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRhYmxlID0gdGFibGU7XG4gICAgICAgIHRoaXMuYm9keUNvbnRleHQgPSBib2R5Q29udGV4dDtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICAgICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgICAgIHRoaXMucm93ID0gcm93O1xuICAgICAgICB0aGlzLmlkID0gY2VsbElkKHRoaXMuY29sdW1uLCB0aGlzLnJvdyk7XG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gdXRpbF8xLmNvbmNhdChleHBvcnRzLkRBVEFfVEFCTEVfQ0VMTCwgKHRoaXMudGFibGUuYXR0cnMud3cgJiYgdGhpcy50YWJsZS5hdHRycy53dy5jZWxsQ2xhc3NOYW1lIHx8ICcnKSwgdGhpcy5zcGVjLmNlbGxDbGFzc05hbWUsIGdldFNvcnRDbGFzc05hbWUodGhpcy50YWJsZS52YWx1ZXMuc29ydEtleSwgdGhpcy5jb2x1bW4pKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHBhdGhfMS51bnNhZmVHZXQodGhpcy5zcGVjLm5hbWUsIHRoaXMudGFibGUudmFsdWVzLmRhdGFzZXRbMF1bdGhpcy5yb3ddKTtcbiAgICAgICAgdGhpcy5kYXR1bSA9IHRoaXMudGFibGUudmFsdWVzLmRhdGFzZXRbMF1bdGhpcy5yb3ddO1xuICAgICAgICB0aGlzLmZvcm1hdCA9IHRoaXMuc3BlYy5mb3JtYXQgPyB0aGlzLnNwZWMuZm9ybWF0IDogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIFN0cmluZyhjKTsgfTtcbiAgICAgICAgdGhpcy5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnNwZWMub25DZWxsQ2xpY2tlZClcbiAgICAgICAgICAgICAgICBfdGhpcy5zcGVjLm9uQ2VsbENsaWNrZWQobmV3IGV2ZW50XzEuQ2VsbENsaWNrZWRFdmVudChfdGhpcy5jb2x1bW4sIF90aGlzLnJvdykpO1xuICAgICAgICAgICAgaWYgKF90aGlzLnRhYmxlLmF0dHJzLnd3ICYmIF90aGlzLnRhYmxlLmF0dHJzLnd3Lm9uQ2VsbENsaWNrZWQpXG4gICAgICAgICAgICAgICAgX3RoaXMudGFibGUuYXR0cnMud3cub25DZWxsQ2xpY2tlZChuZXcgZXZlbnRfMS5DZWxsQ2xpY2tlZEV2ZW50KF90aGlzLmNvbHVtbiwgX3RoaXMucm93KSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBOZXdDZWxsQ29udGV4dDtcbn0oKSk7XG5leHBvcnRzLk5ld0NlbGxDb250ZXh0ID0gTmV3Q2VsbENvbnRleHQ7XG4vKipcbiAqIERhdGFUYWJsZSBjYW4gYmUgdXNlZCBmb3IgZGlzcGxheWluZyBzb3J0YWJsZVxuICogdGFidWxhciBkYXRhLlxuICovXG52YXIgRGF0YVRhYmxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEYXRhVGFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGF0YVRhYmxlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudGhlYWRWaWV3ID0gbmV3IHZpZXdzLkVtcHR5Vmlldyh7fSk7XG4gICAgICAgIF90aGlzLnRib2R5VmlldyA9IG5ldyB2aWV3cy5FbXB0eVZpZXcoe30pO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICB3bWw6IHsgaWQ6ICd0YWJsZScgfSxcbiAgICAgICAgICAgIGlkOiBfXzEuZ2V0SWQoX3RoaXMuYXR0cnMpLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiB1dGlsXzEuY29uY2F0KGV4cG9ydHMuREFUQV9UQUJMRSwgX18xLmdldENsYXNzTmFtZShfdGhpcy5hdHRycykpLFxuICAgICAgICAgICAgc29ydGFibGU6IChfdGhpcy5hdHRycy53dyAmJiAoX3RoaXMuYXR0cnMud3cuc29ydGFibGUgIT0gbnVsbCkpID9cbiAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5zb3J0YWJsZSA6IHRydWUsXG4gICAgICAgICAgICBzb3J0S2V5OiAoKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnNvcnRLZXkpID9cbiAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5zb3J0S2V5IDogWy0xLCAxXSksXG4gICAgICAgICAgICBzb3J0OiBmdW5jdGlvbiAoY29sKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnZhbHVlcy5zb3J0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuc29ydERlbGVnYXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuc29ydERlbGVnYXRlKG5ldyBzb3J0XzEuU29ydFJlcXVlc3QoY29sLCBfdGhpcy52YWx1ZXMuZGF0YXNldFsxXSwgX3RoaXMudmFsdWVzLnNvcnRLZXkpKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc29ydChjb2wpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkYXRhc2V0OiAoKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmRhdGEpID9cbiAgICAgICAgICAgICAgICBbX3RoaXMuYXR0cnMud3cuZGF0YS5zbGljZSgpLCBfdGhpcy5hdHRycy53dy5kYXRhLnNsaWNlKCldIDpcbiAgICAgICAgICAgICAgICBbW10sIFtdXSksXG4gICAgICAgICAgICBjb2x1bW5zOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuY29sdW1ucykgP1xuICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LmNvbHVtbnMgOiBbXSxcbiAgICAgICAgICAgIHRoZWFkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudGhlYWRWaWV3ID0gZ2V0SGVhZFZpZXcoX3RoaXMsIG5ldyBOZXdIZWFkQ29udGV4dChfdGhpcykpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy50aGVhZFZpZXcucmVuZGVyKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGJvZHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy50Ym9keVZpZXcgPSBnZXRCb2R5VmlldyhfdGhpcywgbmV3IE5ld0JvZHlDb250ZXh0KF90aGlzKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnRib2R5Vmlldy5yZW5kZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIERhdGFUYWJsZS5wcm90b3R5cGUuZmlyZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuYXR0cnMud3cgJiYgdGhpcy5hdHRycy53dy5vbkNoYW5nZSlcbiAgICAgICAgICAgIHRoaXMuYXR0cnMud3cub25DaGFuZ2UobmV3IGV2ZW50XzEuRGF0YUNoYW5nZWRFdmVudCh0aGlzLnZhbHVlcy5kYXRhc2V0WzBdLnNsaWNlKCksIHRoaXMudmFsdWVzLnNvcnRLZXkuc2xpY2UoKSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogdXBkYXRlIHRoZSBkYXRhIGRpc3BsYXllZCB3aXRoIGEgbmV3IGRhdGEuXG4gICAgICovXG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLnZhbHVlcy5kYXRhc2V0ID0gW2RhdGEuc2xpY2UoKSwgZGF0YS5zbGljZSgpXTtcbiAgICAgICAgdGhpcy52aWV3LmludmFsaWRhdGUoKTtcbiAgICAgICAgdGhpcy5maXJlQ2hhbmdlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogdXBkYXRlV2l0aFNvcnRLZXkgaXMgbGlrZSB1cGRhdGUgYnV0IHdpbGwgc2V0IHRoZSBzb3J0IGtleSBhcyB3ZWxsLlxuICAgICAqL1xuICAgIERhdGFUYWJsZS5wcm90b3R5cGUudXBkYXRlV2l0aFNvcnRLZXkgPSBmdW5jdGlvbiAoZGF0YSwga2V5KSB7XG4gICAgICAgIHRoaXMudmFsdWVzLmRhdGFzZXQgPSBbZGF0YS5zbGljZSgpLCBkYXRhLnNsaWNlKCldO1xuICAgICAgICB0aGlzLnZhbHVlcy5zb3J0S2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnZpZXcuaW52YWxpZGF0ZSgpO1xuICAgICAgICB0aGlzLmZpcmVDaGFuZ2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBzb3J0IHRoZSB0YWJsZSBkYXRhIGJ5IHRoZSBjb2x1bW4gaWQgc3BlY2lmaWVkLlxuICAgICAqXG4gICAgICogVGhlIGRhdGEgY2FuIG9ubHkgYmUgc29ydGVkIGJ5IG9uZSBjb2x1bW4gYXQgYSB0aW1lIGFuZCB0aGF0IGNvbHVtblxuICAgICAqIG11c3Qgc3BlY2lmeSB0aGUgXCJzb3J0XCIga2V5LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgY2F1c2VzIGEgcmVwYWludC5cbiAgICAgKi9cbiAgICBEYXRhVGFibGUucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy52YWx1ZXMsIGNvbHVtbnMgPSBfYS5jb2x1bW5zLCBzb3J0S2V5ID0gX2Euc29ydEtleSwgZGF0YXNldCA9IF9hLmRhdGFzZXQ7XG4gICAgICAgIHZhciBfYiA9IHNvcnRfMS5zb3J0QnlJZChjb2x1bW5zLCBzb3J0S2V5LCBkYXRhc2V0LCBpZCksIGRhdGEgPSBfYlswXSwga2V5ID0gX2JbMV07XG4gICAgICAgIHRoaXMudmFsdWVzLmRhdGFzZXRbMF0gPSBkYXRhO1xuICAgICAgICB0aGlzLnZhbHVlcy5zb3J0S2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnZpZXcuaW52YWxpZGF0ZSgpO1xuICAgICAgICB0aGlzLmZpcmVDaGFuZ2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBnZXRSb3cgcmV0dXJucyBhIFJhbmdlIG9mIEhUTUxUYWJsZUNlbGxFbGVtZW50cyBmb3IgdGhlIHJvd1xuICAgICAqIHRoYXQgbWF0Y2hlcyB0aGUgcHJvdmlkZWQgaWQuXG4gICAgICpcbiAgICAgKiBJZiBubyByb3dzIGFyZSBmb3VuZCBieSB0aGF0IGlkLCB0aGUgUmFuZ2Ugd2lsbCBiZSBlbXB0eS5cbiAgICAgKiBJbiBvcmRlciBmb3IgdGhpcyBtZXRob2QgdG8gd29yayB0aGUgYm9keSB2aWV3IE1VU1QgaW5jbHVkZVxuICAgICAqIHRoZSB3bWw6aWQgb24gZWFjaCA8dHI+IGVsZW1lbnQgdGhhdCByZXByZXNlbnRzIGEgcm93IG9mIGRhdGEuXG4gICAgICovXG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS5nZXRSb3cgPSBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHZhciBtVHIgPSB1dGlsXzEuZ2V0QnlJZCh0aGlzLnRib2R5VmlldywgXCJcIiArIHJvdyk7XG4gICAgICAgIGlmIChtVHIuaXNOb3RoaW5nKCkpXG4gICAgICAgICAgICByZXR1cm4gbmV3IHJhbmdlXzEuUmFuZ2VJbnN0YW5jZShbXSk7XG4gICAgICAgIHZhciB0ciA9IG1Uci5nZXQoKTtcbiAgICAgICAgcmV0dXJuIG5ldyByYW5nZV8xLlJhbmdlSW5zdGFuY2UoYXJyYXlfMS5tYWtlKHRyLmNlbGxzLmxlbmd0aCwgZnVuY3Rpb24gKG4pIHsgcmV0dXJuIHRyLmNlbGxzW25dOyB9KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBnZXRDZWxsIHByb3ZpZGVzIGEgUmFuZ2UgY29udGFpbmluZyBhIGNlbGwgbG9jYXRlZCBhdCB0aGVcbiAgICAgKiBpbnRlcnNlY3Rpb24gb2YgdGhlIGNvbHVtbiBhbmQgcm93LlxuICAgICAqL1xuICAgIERhdGFUYWJsZS5wcm90b3R5cGUuZ2V0Q2VsbCA9IGZ1bmN0aW9uIChjb2x1bW4sIHJvdykge1xuICAgICAgICB2YXIgY2VsbHMgPSB0aGlzLmdldFJvdyhyb3cpLmNlbGxzO1xuICAgICAgICBpZiAoIWNlbGxzW2NvbHVtbl0pXG4gICAgICAgICAgICByZXR1cm4gbmV3IHJhbmdlXzEuUmFuZ2VJbnN0YW5jZShbXSk7XG4gICAgICAgIHJldHVybiBuZXcgcmFuZ2VfMS5SYW5nZUluc3RhbmNlKFtjZWxsc1tjb2x1bW5dXSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGF0YVRhYmxlO1xufSh3bWxfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuRGF0YVRhYmxlID0gRGF0YVRhYmxlO1xudmFyIGdldEhlYWRWaWV3ID0gZnVuY3Rpb24gKHRhYmxlLCBjdHgpIHtcbiAgICByZXR1cm4gKHRhYmxlLmF0dHJzLnd3ICYmIHRhYmxlLmF0dHJzLnd3LmhlYWRGcmFnbWVudCkgP1xuICAgICAgICB0YWJsZS5hdHRycy53dy5oZWFkRnJhZ21lbnQoY3R4KSA6IG5ldyB2aWV3cy5IZWFkVmlldyhjdHgpO1xufTtcbnZhciBnZXRIZWFkaW5nVmlldyA9IGZ1bmN0aW9uICh0YWJsZSwgY3R4LCBjKSB7XG4gICAgcmV0dXJuIGMuaGVhZGluZ0ZyYWdtZW50ID8gYy5oZWFkaW5nRnJhZ21lbnQoY3R4KSA6XG4gICAgICAgICh0YWJsZS5hdHRycy53dyAmJiB0YWJsZS5hdHRycy53dy5oZWFkaW5nRnJhZ21lbnQpID9cbiAgICAgICAgICAgIHRhYmxlLmF0dHJzLnd3LmhlYWRpbmdGcmFnbWVudChjdHgpIDogbmV3IHZpZXdzLkhlYWRpbmdWaWV3KGN0eCk7XG59O1xudmFyIGdldEJvZHlWaWV3ID0gZnVuY3Rpb24gKHRhYmxlLCBjdHgpIHtcbiAgICByZXR1cm4gKHRhYmxlLmF0dHJzLnd3ICYmIHRhYmxlLmF0dHJzLnd3LmJvZHlGcmFnbWVudCkgP1xuICAgICAgICB0YWJsZS5hdHRycy53dy5ib2R5RnJhZ21lbnQoY3R4KSA6XG4gICAgICAgIG5ldyB2aWV3cy5Cb2R5VmlldyhjdHgpO1xufTtcbnZhciBnZXRDZWxsVmlldyA9IGZ1bmN0aW9uICh0YWJsZSwgY3R4LCBjKSB7XG4gICAgcmV0dXJuIGMuY2VsbEZyYWdtZW50ID8gYy5jZWxsRnJhZ21lbnQoY3R4KSA6XG4gICAgICAgICh0YWJsZS5hdHRycy53dyAmJiB0YWJsZS5hdHRycy53dy5jZWxsRnJhZ21lbnQpID9cbiAgICAgICAgICAgIHRhYmxlLmF0dHJzLnd3LmNlbGxGcmFnbWVudChjdHgpIDpcbiAgICAgICAgICAgIG5ldyB2aWV3cy5DZWxsVmlldyhjdHgpO1xufTtcbnZhciBnZXRTb3J0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKGtleSwgaW5kZXgpIHtcbiAgICByZXR1cm4gKGtleVswXSA9PT0gaW5kZXgpID8gKGtleVsxXSA9PT0gMSkgPyBleHBvcnRzLkFTQyA6IGV4cG9ydHMuREVTQyA6ICcnO1xufTtcbnZhciBjZWxsSWQgPSBmdW5jdGlvbiAoY29sdW1uLCByb3cpIHsgcmV0dXJuIGNvbHVtbiArIFwiLFwiICsgcm93OyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFJhbmdlSW5zdGFuY2VcbiAqL1xudmFyIFJhbmdlSW5zdGFuY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmFuZ2VJbnN0YW5jZShjZWxscykge1xuICAgICAgICB0aGlzLmNlbGxzID0gY2VsbHM7XG4gICAgfVxuICAgIHJldHVybiBSYW5nZUluc3RhbmNlO1xufSgpKTtcbmV4cG9ydHMuUmFuZ2VJbnN0YW5jZSA9IFJhbmdlSW5zdGFuY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYW5nZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3NwcmVhZEFycmF5cyA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheXMpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxuICAgICAgICAgICAgcltrXSA9IGFbal07XG4gICAgcmV0dXJuIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuO1xudmFyIHRhYmxlXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vbGF5b3V0L3RhYmxlXCIpO1xuO1xudmFyIF9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9cIik7XG47XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBFbXB0eVZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRW1wdHlWaWV3KF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX190aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ2RpdicsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW10pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBFbXB0eVZpZXcucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBFbXB0eVZpZXcucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIEVtcHR5Vmlldy5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBFbXB0eVZpZXcucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgRW1wdHlWaWV3LnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBFbXB0eVZpZXcucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgRW1wdHlWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBFbXB0eVZpZXc7XG59KCkpO1xuZXhwb3J0cy5FbXB0eVZpZXcgPSBFbXB0eVZpZXc7XG47XG52YXIgSGVhZFZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSGVhZFZpZXcoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgndGhlYWQnLCB7IGh0bWw6IHsgJ2NsYXNzJzogX19jb250ZXh0LmNsYXNzTmFtZSB9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgndHInLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIF9fc3ByZWFkQXJyYXlzKF9fZm9ySW4oX19jb250ZXh0LmNvbHVtbnMsIGZ1bmN0aW9uIChjb2wsIGlkeCwgXyQkYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoW1xuICAgICAgICAgICAgICAgICAgICAgICAgX19jb250ZXh0LmhlYWRpbmcoY29sKShpZHgpXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIChbXSk7IH0pKSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBIZWFkVmlldy5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIEhlYWRWaWV3LnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBIZWFkVmlldy5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBIZWFkVmlldy5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBIZWFkVmlldy5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgSGVhZFZpZXcucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgSGVhZFZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIEhlYWRWaWV3O1xufSgpKTtcbmV4cG9ydHMuSGVhZFZpZXcgPSBIZWFkVmlldztcbjtcbnZhciBIZWFkaW5nVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIZWFkaW5nVmlldyhfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCd0aCcsIHsgaHRtbDogeyAnY2xhc3MnOiBfX2NvbnRleHQuY2xhc3NOYW1lLCAnb25jbGljayc6IF9fY29udGV4dC5vbmNsaWNrIH0sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgIF9fMS50ZXh0KF9fY29udGV4dC5jb2x1bW4uaGVhZGluZylcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBIZWFkaW5nVmlldy5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIEhlYWRpbmdWaWV3LnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBIZWFkaW5nVmlldy5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBIZWFkaW5nVmlldy5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBIZWFkaW5nVmlldy5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgSGVhZGluZ1ZpZXcucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgSGVhZGluZ1ZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIEhlYWRpbmdWaWV3O1xufSgpKTtcbmV4cG9ydHMuSGVhZGluZ1ZpZXcgPSBIZWFkaW5nVmlldztcbjtcbnZhciBCb2R5VmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCb2R5VmlldyhfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCd0Ym9keScsIHsgaHRtbDogeyAnY2xhc3MnOiBfX2NvbnRleHQuY2xhc3NOYW1lIH0sIHdtbDoge30gfSwgX19zcHJlYWRBcnJheXMoX19mb3JJbihfX2NvbnRleHQuZGF0YSwgZnVuY3Rpb24gKF8sIHJvdywgXyQkYWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCd0cicsIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBTdHJpbmcocm93KSB9IH0sIF9fc3ByZWFkQXJyYXlzKF9fZm9ySW4oX19jb250ZXh0LmNvbHVtbnMsIGZ1bmN0aW9uIChjb2wsIGlkeCwgXyQkYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2NvbnRleHQuY2VsbChjb2wpKGlkeCkocm93KVxuICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIChbXSk7IH0pKSlcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIChbXSk7IH0pKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIEJvZHlWaWV3LnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgQm9keVZpZXcucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIEJvZHlWaWV3LnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIEJvZHlWaWV3LnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIEJvZHlWaWV3LnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBCb2R5Vmlldy5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBCb2R5Vmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gQm9keVZpZXc7XG59KCkpO1xuZXhwb3J0cy5Cb2R5VmlldyA9IEJvZHlWaWV3O1xuO1xudmFyIENlbGxWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENlbGxWaWV3KF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX190aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ3RkJywgeyBodG1sOiB7ICdjbGFzcyc6IF9fY29udGV4dC5jbGFzc05hbWUsICdvbmNsaWNrJzogX19jb250ZXh0Lm9uY2xpY2sgfSwgd21sOiB7ICdpZCc6IF9fY29udGV4dC5pZCB9IH0sIFtcbiAgICAgICAgICAgICAgICBfXzEudGV4dChfX2NvbnRleHQuZm9ybWF0KF9fY29udGV4dC52YWx1ZSkpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgQ2VsbFZpZXcucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBDZWxsVmlldy5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgQ2VsbFZpZXcucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgQ2VsbFZpZXcucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgQ2VsbFZpZXcucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIENlbGxWaWV3LnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIENlbGxWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBDZWxsVmlldztcbn0oKSk7XG5leHBvcnRzLkNlbGxWaWV3ID0gQ2VsbFZpZXc7XG47XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYWluKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX190aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldCh0YWJsZV8xLlRhYmxlTGF5b3V0LCB7IGh0bWw6IHt9LCB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy53bWwuaWQgfSwgd3c6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pZCwgJ2NsYXNzTmFtZSc6IF9fY29udGV4dC52YWx1ZXMuY2xhc3NOYW1lIH0gfSwgW1xuICAgICAgICAgICAgICAgIF9fY29udGV4dC52YWx1ZXMudGhlYWQoKSxcbiAgICAgICAgICAgICAgICBfX2NvbnRleHQudmFsdWVzLnRib2R5KClcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBNYWluLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gTWFpbjtcbn0oKSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIHN0eWxlXzEgPSByZXF1aXJlKFwiLi4vLi4vY29udGVudC9zdHlsZVwiKTtcbmV4cG9ydHMuU3R5bGUgPSBzdHlsZV8xLlN0eWxlO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIF9fMSA9IHJlcXVpcmUoXCIuLi8uLi9cIik7XG52YXIgYWxlcnRfMSA9IHJlcXVpcmUoXCIuL3dtbC9hbGVydFwiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuQUxFUlQgPSAnd3ctYWxlcnQnO1xuLyoqXG4gKiBBbGVydCBpcyB1c2VkIGZvciBkaXNwbGF5aW5nIGltcG9ydGFudCBtZXNzYWdlcyB0byB1c2Vycy5cbiAqL1xudmFyIEFsZXJ0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBbGVydCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBbGVydCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgYWxlcnRfMS5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdhbGVydCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZDogX18xLmdldElkKF90aGlzLmF0dHJzKSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogdXRpbF8xLmNvbmNhdChleHBvcnRzLkFMRVJULCBfXzEuZ2V0Q2xhc3NOYW1lKF90aGlzLmF0dHJzKSwgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnN0eWxlKSA/XG4gICAgICAgICAgICAgICAgc3R5bGVfMS5nZXRTdHlsZUNsYXNzTmFtZShfdGhpcy5hdHRycy53dy5zdHlsZSkgOlxuICAgICAgICAgICAgICAgIHN0eWxlXzEuREVGQVVMVCksXG4gICAgICAgICAgICBjbG9zYWJsZTogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmNsb3NhYmxlKSA/XG4gICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuY2xvc2FibGUgOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy50ZXh0KSA/XG4gICAgICAgICAgICAgICAgW19fMS50ZXh0KF90aGlzLmF0dHJzLnd3LnRleHQpXSA6IF90aGlzLmNoaWxkcmVuXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogY2xvc2UgdGhlIGFsZXJ0LlxuICAgICAqL1xuICAgIEFsZXJ0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1Sb290ID0gdXRpbF8xLmdldEJ5SWQodGhpcy52aWV3LCB0aGlzLnZhbHVlcy53bWwuaWQpO1xuICAgICAgICBpZiAobVJvb3QuaXNKdXN0KCkpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gbVJvb3QuZ2V0KCk7XG4gICAgICAgICAgICBpZiAocm9vdC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgIHJvb3QucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChyb290KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFsZXJ0O1xufSh3bWxfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuQWxlcnQgPSBBbGVydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fc3ByZWFkQXJyYXlzID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5cykgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcbiAgICByZXR1cm4gcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY2xvc2VfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb250ZW50L2Nsb3NlXCIpO1xuO1xudmFyIF9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9cIik7XG47XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnZGl2JywgeyBodG1sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuY2xhc3NOYW1lIH0sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLndtbC5pZCB9IH0sIF9fc3ByZWFkQXJyYXlzKChfX2NvbnRleHQudmFsdWVzLmNvbnRlbnQpLCAoX19pZihfX2NvbnRleHQudmFsdWVzLmNsb3NhYmxlLCBmdW5jdGlvbiAoKSB7IHJldHVybiAoW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoY2xvc2VfMS5DbG9zZSwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ29uQ2xpY2snOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2NvbnRleHQuY2xvc2UoKTsgfSB9IH0sIFtdKVxuICAgICAgICAgICAgXSk7IH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIChbXG4gICAgICAgICAgICAgICAgX18xLnRleHQoXCJcIilcbiAgICAgICAgICAgIF0pOyB9KSkpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgTWFpbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIE1haW47XG59KCkpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFsZXJ0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBfXzEgPSByZXF1aXJlKFwiLi4vLi4vXCIpO1xudmFyIHByb21wdF8xID0gcmVxdWlyZShcIi4uL3Byb21wdFwiKTtcbnZhciBjb25maXJtXzEgPSByZXF1aXJlKFwiLi93bWwvY29uZmlybVwiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuQ09ORklSTSA9ICd3dy1jb25maXJtJztcbmV4cG9ydHMuQ09ORklSTV9OTyA9ICd3dy1jb25maXJtX19ubyc7XG5leHBvcnRzLkNPTkZJUk1fWUVTID0gJ3d3LXByb21wdF9feWVzJztcbi8vL2NsYXNzTmFtZXM6ZW5kXG4vKipcbiAqIFByaW1hcnkgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIHllcyBvciBubyBidXR0b24gc2hvdWxkIGJlIGhpZ2hsaWdodGVkLlxuICovXG52YXIgUHJpbWFyeTtcbihmdW5jdGlvbiAoUHJpbWFyeSkge1xuICAgIFByaW1hcnlbXCJOb1wiXSA9IFwibm9cIjtcbiAgICBQcmltYXJ5W1wiWWVzXCJdID0gXCJ5ZXNcIjtcbn0pKFByaW1hcnkgPSBleHBvcnRzLlByaW1hcnkgfHwgKGV4cG9ydHMuUHJpbWFyeSA9IHt9KSk7XG4vKipcbiAqIENvbmZpcm0gZGlzcGxheXMgYSBkaWFsb2cgZm9yIGNvbmZpcm1pbmcgYW4gYWN0aW9uLlxuICovXG52YXIgQ29uZmlybSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29uZmlybSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb25maXJtKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyBjb25maXJtXzEuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiBfXzEuZ2V0SWQoX3RoaXMuYXR0cnMpLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiB1dGlsXzEuY29uY2F0KGV4cG9ydHMuQ09ORklSTSwgX18xLmdldENsYXNzTmFtZShfdGhpcy5hdHRycykpLFxuICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdtb2RhbCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoZWFkZXI6IHtcbiAgICAgICAgICAgICAgICB0aXRsZTogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnRpdGxlKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LnRpdGxlIDogJydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb290ZXI6IHtcbiAgICAgICAgICAgICAgICBubzoge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cubm9UZXh0KSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5ub1RleHQgOiAnTm8nLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IHV0aWxfMS5jb25jYXQoZXhwb3J0cy5DT05GSVJNX05PLCAoX3RoaXMuYXR0cnMud3cgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LnByaW1hcnkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LnByaW1hcnkgPT09IFByaW1hcnkuTm8pID8gJy1wcmltYXJ5JyA6ICcnKSxcbiAgICAgICAgICAgICAgICAgICAgb25DbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm9uTm8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cub25ObygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeWVzOiB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy55ZXNUZXh0KSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy55ZXNUZXh0IDogJ1llcycsXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICd5ZXMnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogdXRpbF8xLmNvbmNhdChleHBvcnRzLkNPTkZJUk1fWUVTLCAoX3RoaXMuYXR0cnMud3cgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LnByaW1hcnkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LnByaW1hcnkgPT09IFByaW1hcnkuTm8pID8gJycgOiAnLXByaW1hcnknKSxcbiAgICAgICAgICAgICAgICAgICAgb25DbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm9uWWVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3Lm9uWWVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENvbmZpcm0ucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBwcm9tcHRfMS5jbG9zZSh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLndtbC5pZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIENvbmZpcm07XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5Db25maXJtID0gQ29uZmlybTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fc3ByZWFkQXJyYXlzID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5cykgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcbiAgICByZXR1cm4gcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYnV0dG9uXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY29udHJvbC9idXR0b25cIik7XG47XG52YXIgY2xvc2VfYnV0dG9uXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY29udHJvbC9jbG9zZS1idXR0b25cIik7XG47XG52YXIgX18xID0gcmVxdWlyZShcIi4uLy4uLy4uL1wiKTtcbjtcbnZhciBtb2RhbF8xID0gcmVxdWlyZShcIi4uLy4uL21vZGFsXCIpO1xuO1xuLy9AdHMtaWdub3JlOiA2MTkyXG52YXIgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19pZiA9IGZ1bmN0aW9uIChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkge1xuICAgIHJldHVybiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCgpO1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JJbiA9IGZ1bmN0aW9uIChsaXN0LCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2Zvck9mID0gZnVuY3Rpb24gKG8sIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYWluKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX190aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChtb2RhbF8xLk1vZGFsLCB7IGh0bWw6IHt9LCB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy53bWwuaWQgfSwgd3c6IHsgJ2NsYXNzTmFtZSc6IF9fY29udGV4dC52YWx1ZXMuY2xhc3NOYW1lIH0gfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobW9kYWxfMS5Nb2RhbEhlYWRlciwgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoY2xvc2VfYnV0dG9uXzEuQ2xvc2VCdXR0b24sIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdvbkNsaWNrJzogX19jb250ZXh0LnZhbHVlcy5mb290ZXIubm8ub25DbGljayB9IH0sIFtdKSxcbiAgICAgICAgICAgICAgICAgICAgX18xLnRleHQoX19jb250ZXh0LnZhbHVlcy5oZWFkZXIudGl0bGUpXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChtb2RhbF8xLk1vZGFsQm9keSwgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBfX3NwcmVhZEFycmF5cygoX19jb250ZXh0LmNoaWxkcmVuKSkpLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobW9kYWxfMS5Nb2RhbEZvb3RlciwgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoYnV0dG9uXzEuQnV0dG9uLCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAndGV4dCc6IF9fY29udGV4dC52YWx1ZXMuZm9vdGVyLm5vLnRleHQsICdjbGFzc05hbWUnOiBfX2NvbnRleHQudmFsdWVzLmZvb3Rlci5uby5jbGFzc05hbWUsICdvbkNsaWNrJzogX19jb250ZXh0LnZhbHVlcy5mb290ZXIubm8ub25DbGljayB9IH0sIFtdKSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChidXR0b25fMS5CdXR0b24sIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICd0ZXh0JzogX19jb250ZXh0LnZhbHVlcy5mb290ZXIueWVzLnRleHQsICdjbGFzc05hbWUnOiBfX2NvbnRleHQudmFsdWVzLmZvb3Rlci55ZXMuY2xhc3NOYW1lLCAnb25DbGljayc6IF9fY29udGV4dC52YWx1ZXMuZm9vdGVyLnllcy5vbkNsaWNrIH0gfSwgW10pXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBNYWluLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gTWFpbjtcbn0oKSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uZmlybS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgX18xID0gcmVxdWlyZShcIi4uLy4uL1wiKTtcbnZhciBwcm9tcHRfMSA9IHJlcXVpcmUoXCIuLi9wcm9tcHRcIik7XG52YXIgaW5mb3JtXzEgPSByZXF1aXJlKFwiLi93bWwvaW5mb3JtXCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5JTkZPUk0gPSAnd3ctaW5mb3JtJztcbmV4cG9ydHMuSU5GT1JNX09LID0gJ3d3LWluZm9ybV9fb2snO1xuLyoqXG4gKiBJbmZvcm0gZGlzcGxheXMgYSBtZXNzYWdlIHRvIHRoZSB1c2VyLlxuICovXG52YXIgSW5mb3JtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbmZvcm0sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5mb3JtKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyBpbmZvcm1fMS5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6IF9fMS5nZXRJZChfdGhpcy5hdHRycyksXG4gICAgICAgICAgICBjbGFzc05hbWU6IHV0aWxfMS5jb25jYXQoZXhwb3J0cy5JTkZPUk0sIF9fMS5nZXRDbGFzc05hbWUoX3RoaXMuYXR0cnMpKSxcbiAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgIGlkOiAnbW9kYWwnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGVhZGVyOiB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy50aXRsZSkgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy50aXRsZSA6ICcnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9vdGVyOiB7XG4gICAgICAgICAgICAgICAgb2s6IHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmJ1dHRvblRleHQpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LmJ1dHRvblRleHQgOiAnT2snLFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnb2snXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogdXRpbF8xLmNvbmNhdChleHBvcnRzLklORk9STV9PSywgJy1wcmltYXJ5JyksXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5vbkNsb3NlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3Lm9uQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSW5mb3JtLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcHJvbXB0XzEuY2xvc2UodGhpcy52aWV3LCB0aGlzLnZhbHVlcy53bWwuaWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBJbmZvcm07XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5JbmZvcm0gPSBJbmZvcm07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3NwcmVhZEFycmF5cyA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheXMpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxuICAgICAgICAgICAgcltrXSA9IGFbal07XG4gICAgcmV0dXJuIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGJ1dHRvbl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2NvbnRyb2wvYnV0dG9uXCIpO1xuO1xudmFyIGNsb3NlX2J1dHRvbl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2NvbnRyb2wvY2xvc2UtYnV0dG9uXCIpO1xuO1xudmFyIF9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9cIik7XG47XG52YXIgbW9kYWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9tb2RhbFwiKTtcbjtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQobW9kYWxfMS5Nb2RhbCwgeyBodG1sOiB7fSwgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMud21sLmlkIH0sIHd3OiB7ICdjbGFzc05hbWUnOiBfX2NvbnRleHQudmFsdWVzLmNsYXNzTmFtZSB9IH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG1vZGFsXzEuTW9kYWxIZWFkZXIsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGNsb3NlX2J1dHRvbl8xLkNsb3NlQnV0dG9uLCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAnb25DbGljayc6IF9fY29udGV4dC52YWx1ZXMuZm9vdGVyLm9rLm9uQ2xpY2sgfSB9LCBbXSksXG4gICAgICAgICAgICAgICAgICAgIF9fMS50ZXh0KF9fY29udGV4dC52YWx1ZXMuaGVhZGVyLnRpdGxlKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobW9kYWxfMS5Nb2RhbEJvZHksIHsgaHRtbDoge30sIHdtbDoge30gfSwgX19zcHJlYWRBcnJheXMoKF9fY29udGV4dC5jaGlsZHJlbikpKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG1vZGFsXzEuTW9kYWxGb290ZXIsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGJ1dHRvbl8xLkJ1dHRvbiwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ3RleHQnOiBfX2NvbnRleHQudmFsdWVzLmZvb3Rlci5vay50ZXh0LCAnY2xhc3NOYW1lJzogX19jb250ZXh0LnZhbHVlcy5mb290ZXIub2suY2xhc3NOYW1lLCAnb25DbGljayc6IF9fY29udGV4dC52YWx1ZXMuZm9vdGVyLm9rLm9uQ2xpY2sgfSB9LCBbXSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmZvcm0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9tb2RhbFwiKTtcbnZhciB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIF9fMSA9IHJlcXVpcmUoXCIuLi8uLi9cIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLk1PREFMID0gJ3d3LW1vZGFsJztcbmV4cG9ydHMuTU9EQUxfUE9TSVRJT04gPSAnd3ctbW9kYWxfX3Bvc2l0aW9uJztcbmV4cG9ydHMuTU9EQUxfQ09OVEVOVCA9ICd3dy1tb2RhbF9fY29udGVudCc7XG5leHBvcnRzLk1PREFMX0hFQURFUiA9ICd3dy1tb2RhbF9faGVhZGVyJztcbmV4cG9ydHMuTU9EQUxfQk9EWSA9ICd3dy1tb2RhbF9fYm9keSc7XG5leHBvcnRzLk1PREFMX0ZPT1RFUiA9ICd3dy1tb2RhbF9fZm9vdGVyJztcbi8qKlxuICogTW9kYWxcbiAqL1xudmFyIE1vZGFsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNb2RhbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNb2RhbCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTW9kYWwoX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICBpZDogJ3Jvb3QnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWQ6IF9fMS5nZXRJZChfdGhpcy5hdHRycyksXG4gICAgICAgICAgICBjbGFzc05hbWU6IHV0aWxfMS5jb25jYXQoZXhwb3J0cy5NT0RBTCwgX18xLmdldENsYXNzTmFtZShfdGhpcy5hdHRycykpLFxuICAgICAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogZXhwb3J0cy5NT0RBTF9DT05URU5UXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGV4cG9ydHMuTU9EQUxfUE9TSVRJT05cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjbG9zZSB0aGUgbW9kYWwuXG4gICAgICovXG4gICAgTW9kYWwucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbU8gPSB1dGlsXzEuZ2V0QnlJZCh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLndtbC5pZCk7XG4gICAgICAgIGlmIChtTy5pc0p1c3QoKSkge1xuICAgICAgICAgICAgdmFyIG4gPSBtTy5nZXQoKTtcbiAgICAgICAgICAgIGlmIChuLnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgbi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG4pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTW9kYWw7XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5Nb2RhbCA9IE1vZGFsO1xuLyoqXG4gKiBNb2RhbEhlYWRlclxuICovXG52YXIgTW9kYWxIZWFkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1vZGFsSGVhZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1vZGFsSGVhZGVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5Nb2RhbEhlYWRlcihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgIGlkOiAncm9vdCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZDogX18xLmdldElkKF90aGlzLmF0dHJzKSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogdXRpbF8xLmNvbmNhdChleHBvcnRzLk1PREFMX0hFQURFUiwgX18xLmdldENsYXNzTmFtZShfdGhpcy5hdHRycykpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNb2RhbEhlYWRlcjtcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLk1vZGFsSGVhZGVyID0gTW9kYWxIZWFkZXI7XG4vKipcbiAqIE1vZGFsQm9keUF0dHJzXG4gKi9cbnZhciBNb2RhbEJvZHkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1vZGFsQm9keSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNb2RhbEJvZHkoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1vZGFsQm9keShfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgIGlkOiAncm9vdCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZDogX18xLmdldElkKF90aGlzLmF0dHJzKSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogdXRpbF8xLmNvbmNhdChleHBvcnRzLk1PREFMX0JPRFksIF9fMS5nZXRDbGFzc05hbWUoX3RoaXMuYXR0cnMpKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTW9kYWxCb2R5O1xufSh3bWxfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuTW9kYWxCb2R5ID0gTW9kYWxCb2R5O1xuLyoqXG4gKiBNb2RhbEZvb3RlclxuICovXG52YXIgTW9kYWxGb290ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1vZGFsRm9vdGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1vZGFsRm9vdGVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5Nb2RhbEZvb3RlcihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgIGlkOiAncm9vdCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZDogX18xLmdldElkKF90aGlzLmF0dHJzKSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogdXRpbF8xLmNvbmNhdChleHBvcnRzLk1PREFMX0ZPT1RFUiwgX18xLmdldENsYXNzTmFtZShfdGhpcy5hdHRycykpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNb2RhbEZvb3Rlcjtcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLk1vZGFsRm9vdGVyID0gTW9kYWxGb290ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3NwcmVhZEFycmF5cyA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheXMpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxuICAgICAgICAgICAgcltrXSA9IGFbal07XG4gICAgcmV0dXJuIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy9AdHMtaWdub3JlOiA2MTkyXG52YXIgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19pZiA9IGZ1bmN0aW9uIChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkge1xuICAgIHJldHVybiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCgpO1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JJbiA9IGZ1bmN0aW9uIChsaXN0LCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2Zvck9mID0gZnVuY3Rpb24gKG8sIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG52YXIgTW9kYWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTW9kYWwoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnZGl2JywgeyBodG1sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuY2xhc3NOYW1lIH0sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLndtbC5pZCB9IH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnZGl2JywgeyBodG1sOiB7ICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMucG9zaXRpb24uY2xhc3NOYW1lIH0sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnZGl2JywgeyBodG1sOiB7ICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuY29udGVudC5jbGFzc05hbWUgfSwgd21sOiB7fSB9LCBfX3NwcmVhZEFycmF5cygoX19jb250ZXh0LmNoaWxkcmVuKSkpXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBNb2RhbC5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1vZGFsLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNb2RhbC5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBNb2RhbC5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBNb2RhbC5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTW9kYWwucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgTW9kYWwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIE1vZGFsO1xufSgpKTtcbmV4cG9ydHMuTW9kYWwgPSBNb2RhbDtcbjtcbnZhciBNb2RhbEhlYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNb2RhbEhlYWRlcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdkaXYnLCB7IGh0bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jbGFzc05hbWUgfSwgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMud21sLmlkIH0gfSwgX19zcHJlYWRBcnJheXMoKF9fY29udGV4dC5jaGlsZHJlbikpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgTW9kYWxIZWFkZXIucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNb2RhbEhlYWRlci5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTW9kYWxIZWFkZXIucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgTW9kYWxIZWFkZXIucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTW9kYWxIZWFkZXIucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIE1vZGFsSGVhZGVyLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIE1vZGFsSGVhZGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNb2RhbEhlYWRlcjtcbn0oKSk7XG5leHBvcnRzLk1vZGFsSGVhZGVyID0gTW9kYWxIZWFkZXI7XG47XG52YXIgTW9kYWxCb2R5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1vZGFsQm9keShfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdkaXYnLCB7IGh0bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jbGFzc05hbWUgfSwgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMud21sLmlkIH0gfSwgX19zcHJlYWRBcnJheXMoKF9fY29udGV4dC5jaGlsZHJlbikpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgTW9kYWxCb2R5LnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTW9kYWxCb2R5LnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNb2RhbEJvZHkucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgTW9kYWxCb2R5LnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIE1vZGFsQm9keS5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTW9kYWxCb2R5LnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIE1vZGFsQm9keS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gTW9kYWxCb2R5O1xufSgpKTtcbmV4cG9ydHMuTW9kYWxCb2R5ID0gTW9kYWxCb2R5O1xuO1xudmFyIE1vZGFsRm9vdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1vZGFsRm9vdGVyKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX190aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ2RpdicsIHsgaHRtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmNsYXNzTmFtZSB9LCB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy53bWwuaWQgfSB9LCBfX3NwcmVhZEFycmF5cygoX19jb250ZXh0LmNoaWxkcmVuKSkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBNb2RhbEZvb3Rlci5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1vZGFsRm9vdGVyLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNb2RhbEZvb3Rlci5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBNb2RhbEZvb3Rlci5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBNb2RhbEZvb3Rlci5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTW9kYWxGb290ZXIucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgTW9kYWxGb290ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIE1vZGFsRm9vdGVyO1xufSgpKTtcbmV4cG9ydHMuTW9kYWxGb290ZXIgPSBNb2RhbEZvb3Rlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGFsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBfXzEgPSByZXF1aXJlKFwiLi4vLi4vXCIpO1xudmFyIHByb21wdF8xID0gcmVxdWlyZShcIi4vd21sL3Byb21wdFwiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuUFJPTVBUID0gJ3d3LXByb21wdCc7XG5leHBvcnRzLlBST01QVF9DTE9TRSA9ICd3dy1wcm9tcHRfX2Nsb3NlJztcbmV4cG9ydHMuUFJPTVBUX1NBVkUgPSAnd3ctcHJvbXB0X19zYXZlJztcbi8qKlxuICogUHJvbXB0IGRpc3BsYXlzIGEgZGlhbG9nIHRvIHRoZSB1c2VyIHN1aXRhYmxlIGZvciBjb2xsZWN0aW5nIGRhdGFcbiAqIGlucHV0LlxuICovXG52YXIgUHJvbXB0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQcm9tcHQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUHJvbXB0KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyBwcm9tcHRfMS5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6IF9fMS5nZXRJZChfdGhpcy5hdHRycyksXG4gICAgICAgICAgICBjbGFzc05hbWU6IHV0aWxfMS5jb25jYXQoZXhwb3J0cy5QUk9NUFQsIF9fMS5nZXRDbGFzc05hbWUoX3RoaXMuYXR0cnMpKSxcbiAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgIGlkOiAnbW9kYWwnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGVhZGVyOiB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy50aXRsZSkgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy50aXRsZSA6ICcnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9vdGVyOiB7XG4gICAgICAgICAgICAgICAgY2xvc2U6IHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmNsb3NlVGV4dCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuY2xvc2VUZXh0IDogJ0Nsb3NlJyxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBleHBvcnRzLlBST01QVF9DTE9TRSxcbiAgICAgICAgICAgICAgICAgICAgb25DbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm9uQ2FuY2VsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3Lm9uQ2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzYXZlOiB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5zYXZlVGV4dCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuc2F2ZVRleHQgOiAnU2F2ZScsXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdzYXZlJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IHV0aWxfMS5jb25jYXQoJy1wcmltYXJ5JywgZXhwb3J0cy5QUk9NUFRfU0FWRSksXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuZGlzYWJsZWQpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRydWUgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgb25DbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm9uU2F2ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5vblNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUHJvbXB0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZXhwb3J0cy5jbG9zZSh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLndtbC5pZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZW5hYmxlIHNhdmluZy5cbiAgICAgKi9cbiAgICBQcm9tcHQucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZ2V0U2F2ZSh0aGlzKS5tYXAoZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGIuZW5hYmxlKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGRpc2FibGUgc2F2aW5nLlxuICAgICAqL1xuICAgIFByb21wdC5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZ2V0U2F2ZSh0aGlzKS5tYXAoZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGIuZGlzYWJsZSgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gUHJvbXB0O1xufSh3bWxfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuUHJvbXB0ID0gUHJvbXB0O1xudmFyIGdldFNhdmUgPSBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiB1dGlsXzEuZ2V0QnlJZChwLnZpZXcsIHAudmFsdWVzLmZvb3Rlci5zYXZlLndtbC5pZCk7XG59O1xuLyoqXG4gKiBjbG9zZSB0aGUgTW9kYWwgaW4gYSB2aWV3LlxuICovXG5leHBvcnRzLmNsb3NlID0gZnVuY3Rpb24gKHZpZXcsIGlkKSB7XG4gICAgcmV0dXJuIHV0aWxfMS5nZXRCeUlkKHZpZXcsIGlkKS5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0uY2xvc2UoKTsgfSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19zcHJlYWRBcnJheXMgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xuICAgIHJldHVybiByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBidXR0b25fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb250cm9sL2J1dHRvblwiKTtcbjtcbnZhciBjbG9zZV9idXR0b25fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb250cm9sL2Nsb3NlLWJ1dHRvblwiKTtcbjtcbnZhciBfXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vXCIpO1xuO1xudmFyIG1vZGFsXzEgPSByZXF1aXJlKFwiLi4vLi4vbW9kYWxcIik7XG47XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KG1vZGFsXzEuTW9kYWwsIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLndtbC5pZCB9LCB3dzogeyAnY2xhc3NOYW1lJzogX19jb250ZXh0LnZhbHVlcy5jbGFzc05hbWUgfSB9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChtb2RhbF8xLk1vZGFsSGVhZGVyLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChjbG9zZV9idXR0b25fMS5DbG9zZUJ1dHRvbiwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ29uQ2xpY2snOiBfX2NvbnRleHQudmFsdWVzLmZvb3Rlci5jbG9zZS5vbkNsaWNrIH0gfSwgW10pLFxuICAgICAgICAgICAgICAgICAgICBfXzEudGV4dChfX2NvbnRleHQudmFsdWVzLmhlYWRlci50aXRsZSlcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG1vZGFsXzEuTW9kYWxCb2R5LCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIF9fc3ByZWFkQXJyYXlzKChfX2NvbnRleHQuY2hpbGRyZW4pKSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChtb2RhbF8xLk1vZGFsRm9vdGVyLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChidXR0b25fMS5CdXR0b24sIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICd0ZXh0JzogX19jb250ZXh0LnZhbHVlcy5mb290ZXIuY2xvc2UudGV4dCwgJ2NsYXNzTmFtZSc6IF9fY29udGV4dC52YWx1ZXMuZm9vdGVyLmNsb3NlLmNsYXNzTmFtZSwgJ29uQ2xpY2snOiBfX2NvbnRleHQudmFsdWVzLmZvb3Rlci5jbG9zZS5vbkNsaWNrIH0gfSwgW10pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGJ1dHRvbl8xLkJ1dHRvbiwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ3RleHQnOiBfX2NvbnRleHQudmFsdWVzLmZvb3Rlci5zYXZlLnRleHQsICdjbGFzc05hbWUnOiBfX2NvbnRleHQudmFsdWVzLmZvb3Rlci5zYXZlLmNsYXNzTmFtZSwgJ2Rpc2FibGVkJzogX19jb250ZXh0LnZhbHVlcy5mb290ZXIuc2F2ZS5kaXNhYmxlZCwgJ29uQ2xpY2snOiBfX2NvbnRleHQudmFsdWVzLmZvb3Rlci5zYXZlLm9uQ2xpY2sgfSB9LCBbXSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9tcHQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIGdldElkIGZyb20gYSB3aWRnZXQncyBwYXNzZWQgYXR0cmlidXRlcy5cbiAqL1xuZXhwb3J0cy5nZXRJZCA9IGZ1bmN0aW9uIChhdHRycykge1xuICAgIHJldHVybiAoYXR0cnMud3cgJiYgYXR0cnMud3cuaWQpID8gYXR0cnMud3cuaWQgOiAnJztcbn07XG4vKipcbiAqIGdldENsYXNzTmFtZSBmcm9tIGEgd2lkZ2V0J3MgcGFzc2VkIGF0dHJpYnV0ZXMuXG4gKi9cbmV4cG9ydHMuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKGF0dHJzKSB7XG4gICAgcmV0dXJuIChhdHRycy53dyAmJiBhdHRycy53dy5jbGFzc05hbWUpID8gYXR0cnMud3cuY2xhc3NOYW1lIDogJyc7XG59O1xuLyoqXG4gKiB0ZXh0IGNvbnN0cnVjdG9yLlxuICovXG5leHBvcnRzLnRleHQgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFN0cmluZygoc3RyID09IG51bGwpID8gJycgOiBzdHIpKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBvcmllbnRhdGlvbiA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZW50L29yaWVudGF0aW9uXCIpO1xudmFyIF9fMSA9IHJlcXVpcmUoXCIuLi9cIik7XG52YXIgYWN0aW9uX2Jhcl8xID0gcmVxdWlyZShcIi4vd21sL2FjdGlvbi1iYXJcIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG4vKipcbiAqIEFDVElPTl9CQVIgY2xhc3MgbmFtZS4gZm9yIHRoZSBBY3Rpb25CYXIgcm9vdC5cbiAqL1xuZXhwb3J0cy5BQ1RJT05fQkFSID0gJ3d3LWFjdGlvbi1iYXInO1xuLyoqXG4gKiBBQ1RJT05fQkFSX0NPTlRFTlQgY2xhc3MgbmFtZS5cbiAqL1xuZXhwb3J0cy5BQ1RJT05fQkFSX0NPTlRFTlQgPSAnd3ctYWN0aW9uLWJhcl9fY29udGVudCc7XG4vKipcbiAqIEFjdGlvbkJhciBwcm92aWRlcyBhIGJhciBhY3Jvc3MgdGhlIHNjcmVlbiB0aGF0IGNhbiBiZVxuICogdXNlZCBhcyBhIHRvb2xiYXIsIG5hdmlnYXRpb24gbWVudSBvciBzb21ldGhpbmcgc2ltaWxsYXIuXG4gKi9cbnZhciBBY3Rpb25CYXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFjdGlvbkJhciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY3Rpb25CYXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IGFjdGlvbl9iYXJfMS5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ3Jvb3QnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaWQ6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5pZCkgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5pZCA6ICcnLFxuICAgICAgICAgICAgICAgIGNsYXNzOiB1dGlsLmNvbWJpbmUoW1xuICAgICAgICAgICAgICAgICAgICBleHBvcnRzLkFDVElPTl9CQVIsXG4gICAgICAgICAgICAgICAgICAgIF9fMS5MQVlPVVQsXG4gICAgICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uLlBPU0lUSU9ORURcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdjb250ZW50J1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2xhc3M6IGV4cG9ydHMuQUNUSU9OX0JBUl9DT05URU5UXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEFjdGlvbkJhcjtcbn0oX18xLkFic3RyYWN0TGF5b3V0KSk7XG5leHBvcnRzLkFjdGlvbkJhciA9IEFjdGlvbkJhcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fc3ByZWFkQXJyYXlzID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5cykgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcbiAgICByZXR1cm4gcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnZGl2JywgeyBodG1sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMucm9vdC5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5yb290LmNsYXNzIH0sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLnJvb3Qud21sLmlkIH0gfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdkaXYnLCB7IGh0bWw6IHsgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jb250ZW50LmNsYXNzIH0sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmNvbnRlbnQud21sLmlkIH0gfSwgX19zcHJlYWRBcnJheXMoKF9fY29udGV4dC5jaGlsZHJlbikpKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3Rpb24tYmFyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBzdHlsZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRlbnQvc3R5bGVcIik7XG5leHBvcnRzLlN0eWxlID0gc3R5bGVfMS5TdHlsZTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBfXzEgPSByZXF1aXJlKFwiLi4vLi4vXCIpO1xudmFyIGNhbGxvdXRfMSA9IHJlcXVpcmUoXCIuL3dtbC9jYWxsb3V0XCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5DQUxMT1VUID0gJ3d3LWNhbGxvdXQnO1xuLyoqXG4gKiBDYWxsb3V0XG4gKi9cbnZhciBDYWxsb3V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDYWxsb3V0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENhbGxvdXQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IGNhbGxvdXRfMS5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6IF9fMS5nZXRJZChfdGhpcy5hdHRycyksXG4gICAgICAgICAgICBjbGFzc05hbWU6IHV0aWxfMS5jb25jYXQoZXhwb3J0cy5DQUxMT1VULCBfXzEuZ2V0Q2xhc3NOYW1lKF90aGlzLmF0dHJzKSwgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnN0eWxlKSA/XG4gICAgICAgICAgICAgICAgc3R5bGVfMS5nZXRTdHlsZUNsYXNzTmFtZShfdGhpcy5hdHRycy53dy5zdHlsZSkgOlxuICAgICAgICAgICAgICAgIHN0eWxlXzEuREVGQVVMVClcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ2FsbG91dDtcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLkNhbGxvdXQgPSBDYWxsb3V0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19zcHJlYWRBcnJheXMgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xuICAgIHJldHVybiByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdkaXYnLCB7IGh0bWw6IHsgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jbGFzc05hbWUgfSwgd21sOiB7fSB9LCBfX3NwcmVhZEFycmF5cygoX19jb250ZXh0LmNoaWxkcmVuKSkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBNYWluLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gTWFpbjtcbn0oKSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FsbG91dC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2Rlc2NyaXB0aW9uLWxpc3RcIik7XG52YXIgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBvcmllbnRhdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRlbnQvb3JpZW50YXRpb25cIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgX18xID0gcmVxdWlyZShcIi4uLy4uL1wiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuREVTQ1JJUFRJT05fTElTVCA9ICd3dy1kZXNjcmlwdGlvbi1saXN0JztcbmV4cG9ydHMuREVTQ1JJUFRJT05fTElTVF9USVRMRSA9ICd3dy1kZXNjcmlwdGlvbi1saXN0X190aXRsZSc7XG5leHBvcnRzLkRFU0NSSVBUSU9OX0xJU1RfREFUQSA9ICd3dy1kZXNjcmlwdGlvbi1saXN0X19kYXRhJztcbi8qKlxuICogRGVzY3JpcHRpb25MaXN0IGxheW91dC5cbiAqL1xudmFyIERlc2NyaXB0aW9uTGlzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGVzY3JpcHRpb25MaXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERlc2NyaXB0aW9uTGlzdCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuRGVzY3JpcHRpb25MaXN0KF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6IF9fMS5nZXRJZChfdGhpcy5hdHRycyksXG4gICAgICAgICAgICBjbGFzc05hbWU6IHV0aWxfMS5jb25jYXQoZXhwb3J0cy5ERVNDUklQVElPTl9MSVNULCBfXzEuZ2V0Q2xhc3NOYW1lKF90aGlzLmF0dHJzKSwgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lmhvcml6b250YWwpID8gb3JpZW50YXRpb25fMS5IT1JJWk9OVEFMIDogJycpXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIERlc2NyaXB0aW9uTGlzdDtcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLkRlc2NyaXB0aW9uTGlzdCA9IERlc2NyaXB0aW9uTGlzdDtcbi8qKlxuICogVGl0bGVcbiAqL1xudmFyIFRpdGxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUaXRsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaXRsZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuVGl0bGUoX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBpZDogX18xLmdldElkKF90aGlzLmF0dHJzKSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogdXRpbF8xLmNvbmNhdChleHBvcnRzLkRFU0NSSVBUSU9OX0xJU1RfVElUTEUsIF9fMS5nZXRDbGFzc05hbWUoX3RoaXMuYXR0cnMpKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBUaXRsZTtcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLlRpdGxlID0gVGl0bGU7XG4vKipcbiAqIERhdGFcbiAqL1xudmFyIERhdGEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERhdGEsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGF0YSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuRGF0YShfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiBfXzEuZ2V0SWQoX3RoaXMuYXR0cnMpLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiB1dGlsXzEuY29uY2F0KGV4cG9ydHMuREVTQ1JJUFRJT05fTElTVF9EQVRBLCBfXzEuZ2V0Q2xhc3NOYW1lKF90aGlzLmF0dHJzKSlcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gRGF0YTtcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLkRhdGEgPSBEYXRhO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19zcHJlYWRBcnJheXMgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xuICAgIHJldHVybiByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIERlc2NyaXB0aW9uTGlzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZXNjcmlwdGlvbkxpc3QoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnZGwnLCB7IGh0bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jbGFzc05hbWUgfSwgd21sOiB7fSB9LCBfX3NwcmVhZEFycmF5cygoX19jb250ZXh0LmNoaWxkcmVuKSkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBEZXNjcmlwdGlvbkxpc3QucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBEZXNjcmlwdGlvbkxpc3QucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIERlc2NyaXB0aW9uTGlzdC5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBEZXNjcmlwdGlvbkxpc3QucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgRGVzY3JpcHRpb25MaXN0LnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBEZXNjcmlwdGlvbkxpc3QucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgRGVzY3JpcHRpb25MaXN0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBEZXNjcmlwdGlvbkxpc3Q7XG59KCkpO1xuZXhwb3J0cy5EZXNjcmlwdGlvbkxpc3QgPSBEZXNjcmlwdGlvbkxpc3Q7XG47XG52YXIgVGl0bGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGl0bGUoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnZHQnLCB7IGh0bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jbGFzc05hbWUgfSwgd21sOiB7fSB9LCBfX3NwcmVhZEFycmF5cygoX19jb250ZXh0LmNoaWxkcmVuKSkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBUaXRsZS5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIFRpdGxlLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBUaXRsZS5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBUaXRsZS5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBUaXRsZS5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgVGl0bGUucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgVGl0bGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIFRpdGxlO1xufSgpKTtcbmV4cG9ydHMuVGl0bGUgPSBUaXRsZTtcbjtcbnZhciBEYXRhID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERhdGEoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnZGQnLCB7IGh0bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jbGFzc05hbWUgfSwgd21sOiB7fSB9LCBfX3NwcmVhZEFycmF5cygoX19jb250ZXh0LmNoaWxkcmVuKSkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBEYXRhLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgRGF0YS5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgRGF0YS5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBEYXRhLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIERhdGEucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIERhdGEucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgRGF0YS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gRGF0YTtcbn0oKSk7XG5leHBvcnRzLkRhdGEgPSBEYXRhO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVzY3JpcHRpb24tbGlzdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2RyYXdlclwiKTtcbnZhciB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIGhpZGRlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRlbnQvc3RhdGUvaGlkZGVuXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIF9fMSA9IHJlcXVpcmUoXCIuLi9cIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG4vKipcbiAqIERSQVdFUl9MQVlPVVRcbiAqL1xuZXhwb3J0cy5EUkFXRVJfTEFZT1VUID0gJ3d3LWRyYXdlci1sYXlvdXQnO1xuO1xuLyoqXG4gKiBEcmF3ZXJMYXlvdXQgcHJvdmlkZXMgYSAxIGNvbHVtbiBhcHBsaWNhdGlvbiBsYXlvdXQgd2l0aCBhIGRyYXdlciB0aGF0IGNhblxuICogYmUgc2hvd24gb3IgaGlkZGVuIHVwb24gcmVxdWVzdHMuXG4gKlxuICogVGhlIGRyYXdlciB0YWtlcyB1cCBtb3N0IG9mIHRoZSBzY3JlZW4gb24gbW9iaWxlIGFuZCBhYm91dCByb3VnaGx5IDEvNiAtIDEvOFxuICogb24gYSBkZXNrdG9wIChub3QgZmFjdCBjaGVja2VkIHlldCkuXG4gKlxuICogIE1vYmlsZTpcbiAqICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICogIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgICA8ZHJhd2VyPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICpcbiAqICBEZXNrdG9wOlxuICogICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gKiAgfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgICA8ZHJhd2VyPiAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAqL1xudmFyIERyYXdlckxheW91dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRHJhd2VyTGF5b3V0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERyYXdlckxheW91dCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuRHJhd2VyTGF5b3V0KF90aGlzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHZhbHVlcyBpcyBhIGhhc2ggb2YgdmFsdWVzIHVzZWQgaW4gdGhlIHRlbXBsYXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ2xheW91dCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlkOiBfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5pZCxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IHV0aWxfMS5jb25jYXQoZXhwb3J0cy5EUkFXRVJfTEFZT1VULCBfXzEuTEFZT1VULCAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuY2xhc3NOYW1lKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LmNsYXNzTmFtZSA6ICcnKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRyYXdlcjoge1xuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ2RyYXdlcidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhpZGRlbjogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmRyYXdlckhpZGRlbikgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5kcmF3ZXJIaWRkZW4gOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuZHJhd2VyQ29udGVudCkgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5kcmF3ZXJDb250ZW50IDogW11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdjb250ZW50JyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogX3RoaXMuY2hpbGRyZW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEcmF3ZXJMYXlvdXQucHJvdG90eXBlLmlzSGlkZGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbSA9IGdldERyYXdlcih0aGlzKTtcbiAgICAgICAgaWYgKG0uaXNOb3RoaW5nKCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG0uZ2V0KCkuaXNIaWRkZW4oKTtcbiAgICB9O1xuICAgIERyYXdlckxheW91dC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG0gPSBnZXREcmF3ZXIodGhpcyk7XG4gICAgICAgIGlmIChtLmlzSnVzdCgpKSB7XG4gICAgICAgICAgICBtLmdldCgpLmhpZGUoKTtcbiAgICAgICAgICAgIGhpZGRlbl8xLmhpZGUodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5yb290LndtbC5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBEcmF3ZXJMYXlvdXQucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtID0gZ2V0RHJhd2VyKHRoaXMpO1xuICAgICAgICBpZiAobS5pc0p1c3QoKSkge1xuICAgICAgICAgICAgbS5nZXQoKS5zaG93KCk7XG4gICAgICAgICAgICBoaWRkZW5fMS5zaG93KHRoaXMudmlldywgdGhpcy52YWx1ZXMucm9vdC53bWwuaWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgRHJhd2VyTGF5b3V0LnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtID0gZ2V0RHJhd2VyKHRoaXMpO1xuICAgICAgICBpZiAobS5pc0p1c3QoKSkge1xuICAgICAgICAgICAgbS5nZXQoKS50b2dnbGUoKTtcbiAgICAgICAgICAgIGhpZGRlbl8xLnRvZ2dsZSh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLnJvb3Qud21sLmlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIERyYXdlckxheW91dC5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHRoaXMudmFsdWVzLmNvbnRlbnQudmFsdWUgPSBjO1xuICAgICAgICB0aGlzLnZpZXcuaW52YWxpZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIERyYXdlckxheW91dC5wcm90b3R5cGUucmVtb3ZlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy52YWx1ZXMuY29udGVudC52YWx1ZSA9IFtdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBEcmF3ZXJMYXlvdXQ7XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5EcmF3ZXJMYXlvdXQgPSBEcmF3ZXJMYXlvdXQ7XG52YXIgZ2V0RHJhd2VyID0gZnVuY3Rpb24gKGRsKSB7XG4gICAgdmFyIG0gPSBkbC52aWV3LmZpbmRCeUlkKGRsLnZhbHVlcy5kcmF3ZXIud21sLmlkKTtcbiAgICBpZiAobS5pc05vdGhpbmcoKSlcbiAgICAgICAgdXRpbF8xLndhcm5NaXNzaW5nKGRsLnZpZXcsIGRsLnZhbHVlcy5kcmF3ZXIud21sLmlkKTtcbiAgICByZXR1cm4gbTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3NwcmVhZEFycmF5cyA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheXMpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxuICAgICAgICAgICAgcltrXSA9IGFbal07XG4gICAgcmV0dXJuIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRyYXdlcl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL21lbnUvZHJhd2VyXCIpO1xuO1xuLy9AdHMtaWdub3JlOiA2MTkyXG52YXIgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19pZiA9IGZ1bmN0aW9uIChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkge1xuICAgIHJldHVybiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCgpO1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JJbiA9IGZ1bmN0aW9uIChsaXN0LCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2Zvck9mID0gZnVuY3Rpb24gKG8sIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG52YXIgRHJhd2VyTGF5b3V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERyYXdlckxheW91dChfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdkaXYnLCB7IGh0bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5yb290LmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NOYW1lIH0sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLnJvb3Qud21sLmlkIH0gfSwgX19zcHJlYWRBcnJheXMoW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZHJhd2VyXzEuRHJhd2VyLCB7IGh0bWw6IHt9LCB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5kcmF3ZXIud21sLmlkIH0sIHd3OiB7ICdoaWRkZW4nOiBfX2NvbnRleHQudmFsdWVzLmRyYXdlci5oaWRkZW4sICdjb250ZW50JzogX19jb250ZXh0LnZhbHVlcy5kcmF3ZXIuY29udGVudCB9IH0sIFtdKVxuICAgICAgICAgICAgXSwgKF9fY29udGV4dC52YWx1ZXMuY29udGVudC52YWx1ZSkpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgRHJhd2VyTGF5b3V0LnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgRHJhd2VyTGF5b3V0LnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBEcmF3ZXJMYXlvdXQucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgRHJhd2VyTGF5b3V0LnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIERyYXdlckxheW91dC5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgRHJhd2VyTGF5b3V0LnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIERyYXdlckxheW91dC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gRHJhd2VyTGF5b3V0O1xufSgpKTtcbmV4cG9ydHMuRHJhd2VyTGF5b3V0ID0gRHJhd2VyTGF5b3V0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZHJhd2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvZ3JpZFwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBfXzEgPSByZXF1aXJlKFwiLi4vXCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5HUklEX0xBWU9VVCA9ICd3dy1ncmlkLWxheW91dCc7XG5leHBvcnRzLkdSSURfTEFZT1VUX1JPVyA9ICd3dy1ncmlkLWxheW91dF9fcm93JztcbmV4cG9ydHMuR1JJRF9MQVlPVVRfQ09MVU1OID0gJ3d3LWdyaWQtbGF5b3V0X19jb2x1bW4nO1xuO1xuLyoqXG4gKiBHcmlkTGF5b3V0XG4gKi9cbnZhciBHcmlkTGF5b3V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHcmlkTGF5b3V0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdyaWRMYXlvdXQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLkdyaWRMYXlvdXQoX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICAgICAgaWQ6IF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmlkLFxuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ3Jvb3QnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmNsYXNzTmFtZSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuY2xhc3NOYW1lIDogJyc7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1dGlsXzEuY29uY2F0KGV4cG9ydHMuR1JJRF9MQVlPVVQsIF9fMS5MQVlPVVQsIGMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gR3JpZExheW91dDtcbn0oX18xLkFic3RyYWN0TGF5b3V0KSk7XG5leHBvcnRzLkdyaWRMYXlvdXQgPSBHcmlkTGF5b3V0O1xuLyoqXG4gKiBSb3dcbiAqL1xudmFyIFJvdyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUm93LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJvdygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuUm93KF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgICAgIGlkOiBfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5pZCxcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdyb3cnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmNsYXNzTmFtZSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuY2xhc3NOYW1lIDogJyc7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1dGlsXzEuY29uY2F0KGV4cG9ydHMuR1JJRF9MQVlPVVRfUk9XLCBjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJvdztcbn0oX18xLkFic3RyYWN0TGF5b3V0KSk7XG5leHBvcnRzLlJvdyA9IFJvdztcbi8qKlxuICogQ29sdW1uXG4gKi9cbnZhciBDb2x1bW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbHVtbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb2x1bW4oKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLkNvbHVtbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICAgICAgICBpZDogX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuaWQsXG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAnY29sdW1uJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hdHRycy53dyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXRpbF8xLmNvbmNhdChleHBvcnRzLkdSSURfTEFZT1VUX0NPTFVNTiwgX3RoaXMuYXR0cnMud3cuc3BhbiA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCItc3BhblwiICsgX3RoaXMuYXR0cnMud3cuc3BhbiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJy1zcGFuMTInLCBfdGhpcy5hdHRycy53dy5vZmZzZXQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLW9mZnNldFwiICsgX3RoaXMuYXR0cnMud3cub2Zmc2V0IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJywgX3RoaXMuYXR0cnMud3cuY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1dGlsXzEuY29uY2F0KGV4cG9ydHMuR1JJRF9MQVlPVVRfQ09MVU1OLCAnLXNwYW4xMicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDb2x1bW47XG59KF9fMS5BYnN0cmFjdExheW91dCkpO1xuZXhwb3J0cy5Db2x1bW4gPSBDb2x1bW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3NwcmVhZEFycmF5cyA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheXMpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxuICAgICAgICAgICAgcltrXSA9IGFbal07XG4gICAgcmV0dXJuIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy9AdHMtaWdub3JlOiA2MTkyXG52YXIgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19pZiA9IGZ1bmN0aW9uIChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkge1xuICAgIHJldHVybiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCgpO1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JJbiA9IGZ1bmN0aW9uIChsaXN0LCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2Zvck9mID0gZnVuY3Rpb24gKG8sIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG52YXIgR3JpZExheW91dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHcmlkTGF5b3V0KF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX190aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ2RpdicsIHsgaHRtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmNvbnRlbnQuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuY29udGVudC5jbGFzc05hbWUoKSB9LCB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5jb250ZW50LndtbC5pZCB9IH0sIF9fc3ByZWFkQXJyYXlzKChfX2NvbnRleHQuY2hpbGRyZW4pKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIEdyaWRMYXlvdXQucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBHcmlkTGF5b3V0LnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBHcmlkTGF5b3V0LnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIEdyaWRMYXlvdXQucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgR3JpZExheW91dC5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgR3JpZExheW91dC5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBHcmlkTGF5b3V0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBHcmlkTGF5b3V0O1xufSgpKTtcbmV4cG9ydHMuR3JpZExheW91dCA9IEdyaWRMYXlvdXQ7XG47XG52YXIgUm93ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJvdyhfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdkaXYnLCB7IGh0bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5jb250ZW50LmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmNvbnRlbnQuY2xhc3NOYW1lKCkgfSwgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuY29udGVudC53bWwuaWQgfSB9LCBfX3NwcmVhZEFycmF5cygoX19jb250ZXh0LmNoaWxkcmVuKSkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBSb3cucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBSb3cucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIFJvdy5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBSb3cucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgUm93LnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBSb3cucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgUm93LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBSb3c7XG59KCkpO1xuZXhwb3J0cy5Sb3cgPSBSb3c7XG47XG52YXIgQ29sdW1uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbHVtbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdkaXYnLCB7IGh0bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5jb250ZW50LmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmNvbnRlbnQuY2xhc3NOYW1lKCkgfSwgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuY29udGVudC53bWwuaWQgfSB9LCBfX3NwcmVhZEFycmF5cygoX19jb250ZXh0LmNoaWxkcmVuKSkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBDb2x1bW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBDb2x1bW4ucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIENvbHVtbi5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBDb2x1bW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgQ29sdW1uLnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBDb2x1bW4ucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgQ29sdW1uLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBDb2x1bW47XG59KCkpO1xuZXhwb3J0cy5Db2x1bW4gPSBDb2x1bW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncmlkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvaG9yaXpvbnRhbFwiKTtcbnZhciBvcmllbnRhdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRlbnQvb3JpZW50YXRpb25cIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgX18xID0gcmVxdWlyZShcIi4uLy4uL1wiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuSE9SSVpPTlRBTF9MQVlPVVQgPSAnd3ctaG9yaXpvbnRhbC1sYXlvdXQnO1xuLy8vY2xhc3NOYW1lczplbmRcbi8qKlxuICogSG9yaXpvbnRhbExheW91dE9yaWVudGF0aW9uXG4gKi9cbnZhciBIb3Jpem9udGFsTGF5b3V0T3JpZW50YXRpb247XG4oZnVuY3Rpb24gKEhvcml6b250YWxMYXlvdXRPcmllbnRhdGlvbikge1xuICAgIEhvcml6b250YWxMYXlvdXRPcmllbnRhdGlvbltcIkxlZnRcIl0gPSBcImxlZnRcIjtcbiAgICBIb3Jpem9udGFsTGF5b3V0T3JpZW50YXRpb25bXCJSaWdodFwiXSA9IFwicmlnaHRcIjtcbn0pKEhvcml6b250YWxMYXlvdXRPcmllbnRhdGlvbiA9IGV4cG9ydHMuSG9yaXpvbnRhbExheW91dE9yaWVudGF0aW9uIHx8IChleHBvcnRzLkhvcml6b250YWxMYXlvdXRPcmllbnRhdGlvbiA9IHt9KSk7XG4vKipcbiAqIEhvcml6b250YWxMYXlvdXQgdXNlcyB0aGUgY3NzIGZsZXhib3ggdG8gcHJvdmlkZSBhIGNvbnRhaW5lclxuICogd2hlcmUgYWxsIGl0ZW1zIGFyZSBsYWlkIG91dCBpbiBhIHNpbmdsZSByb3cuXG4gKi9cbnZhciBIb3Jpem9udGFsTGF5b3V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhIb3Jpem9udGFsTGF5b3V0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhvcml6b250YWxMYXlvdXQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgaWQ6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5pZCkgPyBfdGhpcy5hdHRycy53dy5pZCA6ICcnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogdXRpbF8xLmNvbmNhdChleHBvcnRzLkhPUklaT05UQUxfTEFZT1VULCBfXzEuZ2V0Q2xhc3NOYW1lKF90aGlzLmF0dHJzKSwgZ2V0T3JpZW50YXRpb24oX3RoaXMuYXR0cnMpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBIb3Jpem9udGFsTGF5b3V0O1xufSh3bWwuQ29tcG9uZW50KSk7XG5leHBvcnRzLkhvcml6b250YWxMYXlvdXQgPSBIb3Jpem9udGFsTGF5b3V0O1xudmFyIGdldE9yaWVudGF0aW9uID0gZnVuY3Rpb24gKGF0dHJzKSB7XG4gICAgcmV0dXJuIChhdHRycy53dyAmJiBhdHRycy53dy5vcmllbnRhdGlvbikgP1xuICAgICAgICBhdHRycy53dy5vcmllbnRhdGlvbiA9PT0gSG9yaXpvbnRhbExheW91dE9yaWVudGF0aW9uLlJpZ2h0ID9cbiAgICAgICAgICAgIG9yaWVudGF0aW9uXzEuUklHSFQgOiBvcmllbnRhdGlvbl8xLkxFRlQgOiAnJztcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3NwcmVhZEFycmF5cyA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheXMpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxuICAgICAgICAgICAgcltrXSA9IGFbal07XG4gICAgcmV0dXJuIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy9AdHMtaWdub3JlOiA2MTkyXG52YXIgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19pZiA9IGZ1bmN0aW9uIChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkge1xuICAgIHJldHVybiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCgpO1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JJbiA9IGZ1bmN0aW9uIChsaXN0LCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2Zvck9mID0gZnVuY3Rpb24gKG8sIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYWluKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX190aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ2RpdicsIHsgaHRtbDogeyAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NOYW1lIH0sIHdtbDoge30gfSwgX19zcHJlYWRBcnJheXMoKF9fY29udGV4dC5jaGlsZHJlbikpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgTWFpbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIE1haW47XG59KCkpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhvcml6b250YWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5MQVlPVVQgPSAnLWxheW91dCc7XG4vKipcbiAqIEFic3RyYWN0TGF5b3V0IHByb3ZpZGVzIGFuIGltcGxlbWVudGF0aW9uIG9mIExheW91dC5cbiAqL1xudmFyIEFic3RyYWN0TGF5b3V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBYnN0cmFjdExheW91dCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBYnN0cmFjdExheW91dCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBBYnN0cmFjdExheW91dC5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGV4cG9ydHMuZG9TZXRDb250ZW50KHRoaXMudmlldywgdGhpcy52YWx1ZXMuY29udGVudC53bWwuaWQsIGMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEFic3RyYWN0TGF5b3V0LnByb3RvdHlwZS5yZW1vdmVDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBleHBvcnRzLmRvUmVtb3ZlQ29udGVudCh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLmNvbnRlbnQud21sLmlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gQWJzdHJhY3RMYXlvdXQ7XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5BYnN0cmFjdExheW91dCA9IEFic3RyYWN0TGF5b3V0O1xuLyoqXG4gKiBkb1NldENvbnRlbnQgb24gYSBOb2RlIGZvdW5kIGluIGEgdmlldy5cbiAqL1xuZXhwb3J0cy5kb1NldENvbnRlbnQgPSBmdW5jdGlvbiAodmlldywgaWQsIGNvbnRlbnQpIHtcbiAgICB2YXIgbWF5YmVSb290ID0gdmlldy5maW5kQnlJZChpZCk7XG4gICAgaWYgKG1heWJlUm9vdC5pc05vdGhpbmcoKSlcbiAgICAgICAgcmV0dXJuIHV0aWxfMS53YXJuTWlzc2luZyh2aWV3LCBpZCk7XG4gICAgdmFyIG4gPSBtYXliZVJvb3QuZ2V0KCk7XG4gICAgd2hpbGUgKG4uZmlyc3RDaGlsZClcbiAgICAgICAgbi5yZW1vdmVDaGlsZChuLmZpcnN0Q2hpbGQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudC5sZW5ndGg7IGkrKylcbiAgICAgICAgbi5hcHBlbmRDaGlsZChjb250ZW50W2ldKTtcbn07XG4vKipcbiAqIGRvUmVtb3ZlQ29udGVudCBmcm9tIGEgVmlldy5cbiAqL1xuZXhwb3J0cy5kb1JlbW92ZUNvbnRlbnQgPSBmdW5jdGlvbiAodmlldywgaWQpIHtcbiAgICB2YXIgbWF5YmVOb2RlID0gdmlldy5maW5kQnlJZChpZCk7XG4gICAgaWYgKG1heWJlTm9kZS5pc05vdGhpbmcoKSlcbiAgICAgICAgcmV0dXJuIHV0aWxfMS53YXJuTWlzc2luZyh2aWV3LCBpZCk7XG4gICAgdmFyIG4gPSBtYXliZU5vZGUuZ2V0KCk7XG4gICAgd2hpbGUgKG4uZmlyc3RDaGlsZClcbiAgICAgICAgbi5yZW1vdmVDaGlsZChuLmZpcnN0Q2hpbGQpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvbGlzdFwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBhY3RpdmVfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZW50L3N0YXRlL2FjdGl2ZVwiKTtcbnZhciBfXzEgPSByZXF1aXJlKFwiLi4vXCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5MSVNUX0xBWU9VVCA9ICd3dy1saXN0LWxheW91dCc7XG5leHBvcnRzLkxJU1RfTEFZT1VUX0lURU0gPSAnd3ctbGlzdC1sYXlvdXRfX2l0ZW0nO1xuLyoqXG4gKiBMaXN0TGF5b3V0SXRlbVxuICovXG52YXIgTGlzdExheW91dEl0ZW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpc3RMYXlvdXRJdGVtLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpc3RMYXlvdXRJdGVtKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5MaXN0TGF5b3V0SXRlbShfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdpdGVtJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaWQ6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5pZCkgPyBfdGhpcy5hdHRycy53dy5pZCA6ICcnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogdXRpbF8xLmNvbmNhdChleHBvcnRzLkxJU1RfTEFZT1VUX0lURU0sIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5hY3RpdmUpID8gYWN0aXZlXzEuQUNUSVZFIDogJycpLFxuICAgICAgICAgICAgICAgIG5hbWU6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5uYW1lKSA/IF90aGlzLmF0dHJzLnd3Lm5hbWUgOiAnJyxcbiAgICAgICAgICAgICAgICBvbmNsaWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5vbkNsaWNrKVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cub25DbGljayhfdGhpcy5hdHRycy53dyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3Lm5hbWUgfHwgJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBMaXN0TGF5b3V0SXRlbS5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhY3RpdmVfMS5pc0FjdGl2ZSh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLmNvbnRlbnQud21sLmlkKTtcbiAgICB9O1xuICAgIExpc3RMYXlvdXRJdGVtLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYWN0aXZlXzEuYWN0aXZhdGUodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5jb250ZW50LndtbC5pZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgTGlzdExheW91dEl0ZW0ucHJvdG90eXBlLmRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFjdGl2ZV8xLmRlYWN0aXZhdGUodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5jb250ZW50LndtbC5pZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgTGlzdExheW91dEl0ZW0ucHJvdG90eXBlLnRvZ2dsZUFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUoKSlcbiAgICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZSgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIExpc3RMYXlvdXRJdGVtO1xufShfXzEuQWJzdHJhY3RMYXlvdXQpKTtcbmV4cG9ydHMuTGlzdExheW91dEl0ZW0gPSBMaXN0TGF5b3V0SXRlbTtcbi8qKlxuICogTGlzdExheW91dCBpcyB1c2VkIHRvIGNyZWF0ZSBhIHZlcnRpY2FsIGxpc3Qgb2YgY29udGVudC5cbiAqXG4gKiBDaGlsZHJlbiBtdXN0IGJlIExpc3RHcm91cEl0ZW1zLlxuICovXG52YXIgTGlzdExheW91dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGlzdExheW91dCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMaXN0TGF5b3V0KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5MaXN0TGF5b3V0KF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ2xpc3QnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpZDogX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuaWQsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiB1dGlsXzEuY29uY2F0KGV4cG9ydHMuTElTVF9MQVlPVVQsIF9fMS5MQVlPVVQsIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5jbGFzc05hbWUpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuY2xhc3NOYW1lIDogJycpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIExpc3RMYXlvdXQ7XG59KF9fMS5BYnN0cmFjdExheW91dCkpO1xuZXhwb3J0cy5MaXN0TGF5b3V0ID0gTGlzdExheW91dDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fc3ByZWFkQXJyYXlzID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5cykgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcbiAgICByZXR1cm4gcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBMaXN0TGF5b3V0SXRlbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMaXN0TGF5b3V0SXRlbShfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdsaScsIHsgaHRtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmNvbnRlbnQuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuY29udGVudC5jbGFzc05hbWUsICdvbmNsaWNrJzogX19jb250ZXh0LnZhbHVlcy5jb250ZW50Lm9uY2xpY2sgfSwgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuY29udGVudC53bWwuaWQgfSB9LCBfX3NwcmVhZEFycmF5cygoX19jb250ZXh0LmNoaWxkcmVuKSkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBMaXN0TGF5b3V0SXRlbS5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIExpc3RMYXlvdXRJdGVtLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBMaXN0TGF5b3V0SXRlbS5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBMaXN0TGF5b3V0SXRlbS5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBMaXN0TGF5b3V0SXRlbS5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTGlzdExheW91dEl0ZW0ucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgTGlzdExheW91dEl0ZW0ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIExpc3RMYXlvdXRJdGVtO1xufSgpKTtcbmV4cG9ydHMuTGlzdExheW91dEl0ZW0gPSBMaXN0TGF5b3V0SXRlbTtcbjtcbnZhciBMaXN0TGF5b3V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExpc3RMYXlvdXQoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgndWwnLCB7IGh0bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5jb250ZW50LmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmNvbnRlbnQuY2xhc3NOYW1lIH0sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmNvbnRlbnQud21sLmlkIH0gfSwgX19zcHJlYWRBcnJheXMoKF9fY29udGV4dC5jaGlsZHJlbikpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgTGlzdExheW91dC5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIExpc3RMYXlvdXQucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIExpc3RMYXlvdXQucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgTGlzdExheW91dC5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBMaXN0TGF5b3V0LnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBMaXN0TGF5b3V0LnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIExpc3RMYXlvdXQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIExpc3RMYXlvdXQ7XG59KCkpO1xuZXhwb3J0cy5MaXN0TGF5b3V0ID0gTGlzdExheW91dDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9tYWluXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIF9fMSA9IHJlcXVpcmUoXCIuLi9cIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLk1BSU5fTEFZT1VUID0gJ3d3LW1haW4tbGF5b3V0Jztcbi8qKlxuICogTWFpbkxheW91dCBwcm92aWRlcyBhIGNvbnRhaW5lciBmb3IgdGhlIG1haW4gY29udGVudCBvZiBhbiBhcHBsaWNhdGlvbi5cbiAqL1xudmFyIE1haW5MYXlvdXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW5MYXlvdXQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbkxheW91dCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdtYWluJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaWQ6IChfdGhpcy5hdHRycyAmJiBfdGhpcy5hdHRycy53dykgPyBfdGhpcy5hdHRycy53dy5pZCA6ICcnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogdXRpbF8xLmNvbmNhdChleHBvcnRzLk1BSU5fTEFZT1VULCBfXzEuTEFZT1VULCAoX3RoaXMuYXR0cnMgJiYgX3RoaXMuYXR0cnMud3cpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuY2xhc3NOYW1lIDogJycpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW5MYXlvdXQ7XG59KF9fMS5BYnN0cmFjdExheW91dCkpO1xuZXhwb3J0cy5NYWluTGF5b3V0ID0gTWFpbkxheW91dDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fc3ByZWFkQXJyYXlzID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5cykgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcbiAgICByZXR1cm4gcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnZGl2JywgeyBodG1sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuY29udGVudC5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jb250ZW50LmNsYXNzTmFtZSB9LCB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5jb250ZW50LndtbC5pZCB9IH0sIF9fc3ByZWFkQXJyYXlzKChfX2NvbnRleHQuY2hpbGRyZW4pKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWluLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvbWV0ZXJcIik7XG52YXIgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBfXzEgPSByZXF1aXJlKFwiLi4vLi4vXCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5NRVRFUiA9ICd3dy1tZXRlcic7XG5leHBvcnRzLk1FVEVSX0JBUiA9ICd3dy1tZXRlcl9fYmFyJztcbi8qKlxuICogTWV0ZXJcbiAqL1xudmFyIE1ldGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZXRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZXRlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWV0ZXIoX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBpZDogX18xLmdldElkKF90aGlzLmF0dHJzKSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogdXRpbF8xLmNvbmNhdChleHBvcnRzLk1FVEVSLCBfXzEuZ2V0Q2xhc3NOYW1lKF90aGlzLmF0dHJzKSlcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWV0ZXI7XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5NZXRlciA9IE1ldGVyO1xuLyoqXG4gKiBNZXRlckJhclxuICovXG52YXIgTWV0ZXJCYXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ldGVyQmFyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1ldGVyQmFyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NZXRlckJhcihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiBfXzEuZ2V0SWQoX3RoaXMuYXR0cnMpLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiB1dGlsXzEuY29uY2F0KGV4cG9ydHMuTUVURVJfQkFSLCBfXzEuZ2V0Q2xhc3NOYW1lKF90aGlzLmF0dHJzKSksXG4gICAgICAgICAgICB2YWx1ZTogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnZhbHVlKSA/XG4gICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cudmFsdWUgOiAwLFxuICAgICAgICAgICAgY29sb3I6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5jb2xvcikgP1xuICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LmNvbG9yIDogJycsXG4gICAgICAgICAgICBzdHlsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBsaXN0ID0gW107XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnZhbHVlcy5jb2xvcilcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5wdXNoKFwiYmFja2dyb3VuZC1jb2xvcjpcIiArIF90aGlzLnZhbHVlcy5jb2xvcik7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnZhbHVlcy52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5wdXNoKFwid2lkdGg6XCIgKyBfdGhpcy52YWx1ZXMudmFsdWUgKyBcIiVcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3Quam9pbignOycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHNldFZhbHVlIHNldHMgdGhlIHZhbHVlIG9mIHRoZSBNZXRlckJhci5cbiAgICAgKi9cbiAgICBNZXRlckJhci5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy52aWV3LmludmFsaWRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBpbmNyZWFzZSB0aGUgdmFsdWUgYnkgdGhlIHNwZWNpZmllZCBhbW91bnQuXG4gICAgICovXG4gICAgTWV0ZXJCYXIucHJvdG90eXBlLmluY3JlYXNlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWVzLnZhbHVlID0gdGhpcy52YWx1ZXMudmFsdWUgKyB2YWx1ZTtcbiAgICAgICAgdGhpcy52aWV3LmludmFsaWRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBkZWNyZWFzZSB0aGUgdmFsdWUgYnkgdGhlIHNwZWNpZmllZCBhbW91bnQuXG4gICAgICovXG4gICAgTWV0ZXJCYXIucHJvdG90eXBlLmRlY3JlYXNlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWVzLnZhbHVlID0gdGhpcy52YWx1ZXMudmFsdWUgLSB2YWx1ZTtcbiAgICAgICAgdGhpcy52aWV3LmludmFsaWRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBzZXRDb2xvciBvZiB0aGUgTWV0ZXJCYXIuXG4gICAgICovXG4gICAgTWV0ZXJCYXIucHJvdG90eXBlLnNldENvbG9yID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIHRoaXMudmFsdWVzLmNvbG9yID0gY29sb3I7XG4gICAgICAgIHRoaXMudmlldy5pbnZhbGlkYXRlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIE1ldGVyQmFyO1xufSh3bWxfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuTWV0ZXJCYXIgPSBNZXRlckJhcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fc3ByZWFkQXJyYXlzID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5cykgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcbiAgICByZXR1cm4gcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBNZXRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZXRlcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdkaXYnLCB7IGh0bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jbGFzc05hbWUgfSwgd21sOiB7fSB9LCBfX3NwcmVhZEFycmF5cygoX19jb250ZXh0LmNoaWxkcmVuKSkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBNZXRlci5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1ldGVyLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNZXRlci5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBNZXRlci5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBNZXRlci5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWV0ZXIucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgTWV0ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIE1ldGVyO1xufSgpKTtcbmV4cG9ydHMuTWV0ZXIgPSBNZXRlcjtcbjtcbnZhciBNZXRlckJhciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZXRlckJhcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdkaXYnLCB7IGh0bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jbGFzc05hbWUsICdzdHlsZSc6IF9fY29udGV4dC52YWx1ZXMuc3R5bGUoKSB9LCB3bWw6IHt9IH0sIFtdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgTWV0ZXJCYXIucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNZXRlckJhci5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWV0ZXJCYXIucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgTWV0ZXJCYXIucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWV0ZXJCYXIucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIE1ldGVyQmFyLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIE1ldGVyQmFyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNZXRlckJhcjtcbn0oKSk7XG5leHBvcnRzLk1ldGVyQmFyID0gTWV0ZXJCYXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHN0eWxlID0gcmVxdWlyZShcIi4uLy4uL2NvbnRlbnQvc3R5bGVcIik7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvcGFuZWxcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgX18xID0gcmVxdWlyZShcIi4uXCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuLyoqXG4gKiBQQU5FTCB3cmFwcGVyIGNsYXNzLlxuICovXG5leHBvcnRzLlBBTkVMID0gJ3d3LXBhbmVsJztcbi8qKlxuICogUEFORUxfSEVBREVSIGNsYXNzIG5hbWUuXG4gKi9cbmV4cG9ydHMuUEFORUxfSEVBREVSID0gJ3d3LXBhbmVsX19oZWFkZXInO1xuLyoqXG4gKiBQQU5FTF9CT0RZIGNsYXNzIG5hbWUuXG4gKi9cbmV4cG9ydHMuUEFORUxfQk9EWSA9ICd3dy1wYW5lbF9fYm9keSc7XG4vKipcbiAqIFBBTkVMX0ZPT1RFUiBjbGFzcyBuYW1lLlxuICovXG5leHBvcnRzLlBBTkVMX0ZPT1RFUiA9ICd3dy1wYW5lbF9fZm9vdGVyJztcbi8qKlxuICogUGFuZWwgcHJvdmlkZXMgYSByZWN0YW5ndWxhciBjb250YWluZXIgZm9yIHZpc3VhbGx5IHNlcGVyYXRpbmdcbiAqIGNvbnRlbnQgYnkgY29udGV4dC5cbiAqL1xudmFyIFBhbmVsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQYW5lbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQYW5lbCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuUGFuZWwoX3RoaXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogdmFsdWVzXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHJvb3QgdmFsdWVzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICAgICAgaWQ6IF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmlkLFxuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ3BhbmVsJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogdXRpbF8xLmNvbmNhdChleHBvcnRzLlBBTkVMLCBfXzEuTEFZT1VULCAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuc3R5bGUpID9cbiAgICAgICAgICAgICAgICAgICAgXCItXCIgKyBfdGhpcy5hdHRycy53dy5zdHlsZSA6IHN0eWxlLkRFRkFVTFQsIF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmNsYXNzTmFtZSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LmNsYXNzTmFtZSA6ICcnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBQYW5lbDtcbn0oX18xLkFic3RyYWN0TGF5b3V0KSk7XG5leHBvcnRzLlBhbmVsID0gUGFuZWw7XG4vKipcbiAqIFBhbmVsSGVhZGVyXG4gKi9cbnZhciBQYW5lbEhlYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGFuZWxIZWFkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGFuZWxIZWFkZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLlBhbmVsSGVhZGVyKF90aGlzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHZhbHVlc1xuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ2hlYWRlcidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlkOiBfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5pZCxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IHV0aWxfMS5jb25jYXQoZXhwb3J0cy5QQU5FTF9IRUFERVIsIF9fMS5MQVlPVVQsIF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmNsYXNzTmFtZSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LmNsYXNzTmFtZSA6ICcnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBQYW5lbEhlYWRlcjtcbn0oX18xLkFic3RyYWN0TGF5b3V0KSk7XG5leHBvcnRzLlBhbmVsSGVhZGVyID0gUGFuZWxIZWFkZXI7XG4vKipcbiAqIFBhbmVsQm9keVxuICovXG52YXIgUGFuZWxCb2R5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQYW5lbEJvZHksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGFuZWxCb2R5KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5QYW5lbEJvZHkoX3RoaXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogdmFsdWVzXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAnYm9keSdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlkOiBfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5pZCxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IHV0aWxfMS5jb25jYXQoZXhwb3J0cy5QQU5FTF9CT0RZLCBfXzEuTEFZT1VULCBfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5jbGFzc05hbWUgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5jbGFzc05hbWUgOiAnJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUGFuZWxCb2R5O1xufShfXzEuQWJzdHJhY3RMYXlvdXQpKTtcbmV4cG9ydHMuUGFuZWxCb2R5ID0gUGFuZWxCb2R5O1xuLyoqXG4gKiBQYW5lbEZvb3RlclxuICovXG52YXIgUGFuZWxGb290ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBhbmVsRm9vdGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBhbmVsRm9vdGVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5QYW5lbEZvb3RlcihfdGhpcyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB2YWx1ZXNcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdmb290ZXInXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpZDogX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuaWQsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiB1dGlsXzEuY29uY2F0KGV4cG9ydHMuUEFORUxfRk9PVEVSLCBfXzEuTEFZT1VULCBfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5jbGFzc05hbWUgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5jbGFzc05hbWUgOiAnJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUGFuZWxGb290ZXI7XG59KF9fMS5BYnN0cmFjdExheW91dCkpO1xuZXhwb3J0cy5QYW5lbEZvb3RlciA9IFBhbmVsRm9vdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19zcHJlYWRBcnJheXMgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xuICAgIHJldHVybiByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIFBhbmVsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhbmVsKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX190aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ2RpdicsIHsgaHRtbDogeyAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmNvbnRlbnQuY2xhc3NOYW1lIH0sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmNvbnRlbnQuaWQgfSB9LCBfX3NwcmVhZEFycmF5cygoX19jb250ZXh0LmNoaWxkcmVuKSkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBQYW5lbC5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIFBhbmVsLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBQYW5lbC5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBQYW5lbC5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBQYW5lbC5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgUGFuZWwucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgUGFuZWwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIFBhbmVsO1xufSgpKTtcbmV4cG9ydHMuUGFuZWwgPSBQYW5lbDtcbjtcbnZhciBQYW5lbEhlYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYW5lbEhlYWRlcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdkaXYnLCB7IGh0bWw6IHsgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jb250ZW50LmNsYXNzTmFtZSB9LCB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5jb250ZW50LmlkIH0gfSwgX19zcHJlYWRBcnJheXMoKF9fY29udGV4dC5jaGlsZHJlbikpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgUGFuZWxIZWFkZXIucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBQYW5lbEhlYWRlci5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgUGFuZWxIZWFkZXIucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgUGFuZWxIZWFkZXIucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgUGFuZWxIZWFkZXIucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIFBhbmVsSGVhZGVyLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIFBhbmVsSGVhZGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBQYW5lbEhlYWRlcjtcbn0oKSk7XG5leHBvcnRzLlBhbmVsSGVhZGVyID0gUGFuZWxIZWFkZXI7XG47XG52YXIgUGFuZWxCb2R5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhbmVsQm9keShfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdkaXYnLCB7IGh0bWw6IHsgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jb250ZW50LmNsYXNzTmFtZSB9LCB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5jb250ZW50LmlkIH0gfSwgX19zcHJlYWRBcnJheXMoKF9fY29udGV4dC5jaGlsZHJlbikpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgUGFuZWxCb2R5LnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgUGFuZWxCb2R5LnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBQYW5lbEJvZHkucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgUGFuZWxCb2R5LnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIFBhbmVsQm9keS5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgUGFuZWxCb2R5LnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIFBhbmVsQm9keS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gUGFuZWxCb2R5O1xufSgpKTtcbmV4cG9ydHMuUGFuZWxCb2R5ID0gUGFuZWxCb2R5O1xuO1xudmFyIFBhbmVsRm9vdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhbmVsRm9vdGVyKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX190aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ2RpdicsIHsgaHRtbDogeyAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmNvbnRlbnQuY2xhc3NOYW1lIH0sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmNvbnRlbnQuaWQgfSB9LCBfX3NwcmVhZEFycmF5cygoX19jb250ZXh0LmNoaWxkcmVuKSkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBQYW5lbEZvb3Rlci5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIFBhbmVsRm9vdGVyLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBQYW5lbEZvb3Rlci5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBQYW5lbEZvb3Rlci5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBQYW5lbEZvb3Rlci5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgUGFuZWxGb290ZXIucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgUGFuZWxGb290ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIFBhbmVsRm9vdGVyO1xufSgpKTtcbmV4cG9ydHMuUGFuZWxGb290ZXIgPSBQYW5lbEZvb3Rlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhbmVsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvdGFiXCIpO1xudmFyIHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBfXzEgPSByZXF1aXJlKFwiLi4vLi4vXCIpO1xudmFyIF9fMiA9IHJlcXVpcmUoXCIuLi9cIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLlRBQl9MQVlPVVQgPSAnd3ctdGFiLWxheW91dCc7XG4vKipcbiAqIFRhYkxheW91dCBwcm92aWRlcyBhIGxheW91dCB3aG9zZSBkaXNwbGF5ZWQgY29udGVudCBjYW4gYmUgY2hhbmdlZCB2aWEgdGFicy5cbiAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IFRhYjEgIHwgIFRhYjIgIHwgVGFiMiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Q29udGVudD4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8X19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX198XG4gKi9cbnZhciBUYWJMYXlvdXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhYkxheW91dCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJMYXlvdXQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgaWQ6IF9fMS5nZXRJZChfdGhpcy5hdHRycyksXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiB1dGlsXzEuY29uY2F0KGV4cG9ydHMuVEFCX0xBWU9VVCwgX18yLkxBWU9VVCwgX18xLmdldENsYXNzTmFtZShfdGhpcy5hdHRycykpLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5hY3RpdmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF5YmVBY3RpdmUgPSBtYXliZV8xLmZyb21OdWxsYWJsZShfdGhpcy52YWx1ZXMudGFicy5kYXRhW190aGlzLmF0dHJzLnd3LmFjdGl2ZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1heWJlQWN0aXZlLmlzSnVzdCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXliZUFjdGl2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0KClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbnRlbnRGdW4oX3RoaXMpKF90aGlzLnZpZXcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGFiczoge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQ6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5hY3RpdmUpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuYWN0aXZlIDogJycsXG4gICAgICAgICAgICAgICAgZGF0YTogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnRhYnMpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cudGFicyA6IHt9LFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0LnRhYkZ1bilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0LnRhYkZ1bihfdGhpcykoX3RoaXMudmlldyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0LnRleHQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW19fMS50ZXh0KHQudGV4dCldO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMudmFsdWVzLnRhYnMuY3VycmVudCAhPT0gZS5uYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudmFsdWVzLnRhYnMuY3VycmVudCA9IGUubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhYiA9IG1heWJlXzEuZnJvbU51bGxhYmxlKF90aGlzLnZhbHVlcy50YWJzLmRhdGFbZS5uYW1lXSkuZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnZhbHVlcy5yb290LmNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFiLmNvbnRlbnRGdW4oX3RoaXMpKF90aGlzLnZpZXcpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy52aWV3LmludmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVGFiTGF5b3V0LnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdGhpcy52YWx1ZXMucm9vdC5jb250ZW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gYzsgfTtcbiAgICAgICAgdGhpcy52aWV3LmludmFsaWRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUYWJMYXlvdXQucHJvdG90eXBlLnJlbW92ZUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmFsdWVzLnJvb3QuY29udGVudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgICAgICB0aGlzLnZpZXcuaW52YWxpZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBUYWJMYXlvdXQ7XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5UYWJMYXlvdXQgPSBUYWJMYXlvdXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3NwcmVhZEFycmF5cyA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheXMpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxuICAgICAgICAgICAgcltrXSA9IGFbal07XG4gICAgcmV0dXJuIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRhYl9iYXJfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb250cm9sL3RhYi1iYXJcIik7XG47XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgnZGl2JywgeyBodG1sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMucm9vdC5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5yb290LmNsYXNzTmFtZSB9LCB3bWw6IHt9IH0sIF9fc3ByZWFkQXJyYXlzKFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHRhYl9iYXJfMS5UYWJCYXIsIHsgaHRtbDoge30sIHdtbDoge30gfSwgX19zcHJlYWRBcnJheXMoX19mb3JPZihfX2NvbnRleHQudmFsdWVzLnRhYnMuZGF0YSwgZnVuY3Rpb24gKHRhYiwgbmFtZSwgXyQkYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldCh0YWJfYmFyXzEuVGFiLCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAnbmFtZSc6IG5hbWUsICdhY3RpdmUnOiAoX19jb250ZXh0LnZhbHVlcy50YWJzLmN1cnJlbnQgPT09IG5hbWUpLCAnb25DbGljayc6IF9fY29udGV4dC52YWx1ZXMudGFicy5vbkNsaWNrIH0gfSwgX19zcHJlYWRBcnJheXMoKF9fY29udGV4dC52YWx1ZXMudGFicy5jb250ZW50KHRhYikpKSlcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gKFtdKTsgfSkpKVxuICAgICAgICAgICAgXSwgKF9fY29udGV4dC52YWx1ZXMucm9vdC5jb250ZW50KCkpKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC90YWJsZVwiKTtcbnZhciB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIF9fMSA9IHJlcXVpcmUoXCIuLi8uLi9cIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLlRBQkxFX0hFQURFUiA9ICd3dy10YWJsZS1sYXlvdXRfX2hlYWRlcic7XG5leHBvcnRzLlRBQkxFX0JPRFkgPSAnd3ctdGFibGUtbGF5b3V0X19ib2R5JztcbmV4cG9ydHMuVEFCTEVfRk9PVEVSID0gJ3d3LXRhYmxlLWxheW91dF9fZm9vdGVyJztcbmV4cG9ydHMuVEFCTEVfUk9XID0gJ3d3LXRhYmxlLWxheW91dF9fcm93JztcbmV4cG9ydHMuVEFCTEVfSEVBRElORyA9ICd3dy10YWJsZS1sYXlvdXQgX2hlYWRpbmcnO1xuZXhwb3J0cy5UQUJMRV9DRUxMID0gJ3d3LXRhYmxlLWxheW91dF9fY2VsbCc7XG5leHBvcnRzLlRBQkxFX0xBWU9VVCA9ICd3dy10YWJsZS1sYXlvdXQnO1xuZXhwb3J0cy5UQUJMRV9XSU5ET1cgPSAnd3ctdGFibGUtd2luZG93JztcbmV4cG9ydHMuQk9SREVSRUQgPSAnLWJvcmRlcmVkJztcbmV4cG9ydHMuQ09NUEFDVCA9ICctY29tcGFjdCc7XG5leHBvcnRzLkFMVEVSTkFURSA9ICctYWx0ZXJuYXRlJztcbmV4cG9ydHMuSE9WRVJBQkxFID0gJy1ob3ZlcmFibGUnO1xuLyoqXG4gKiBUYWJsZUhlYWRlciAoPHRoZWFkPilcbiAqL1xudmFyIFRhYmxlSGVhZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYWJsZUhlYWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZUhlYWRlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuVGFibGVIZWFkZXIoX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBpZDogX18xLmdldElkKF90aGlzLmF0dHJzKSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogdXRpbF8xLmNvbmNhdChleHBvcnRzLlRBQkxFX0hFQURFUiwgX18xLmdldENsYXNzTmFtZShfdGhpcy5hdHRycykpXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRhYmxlSGVhZGVyO1xufSh3bWxfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuVGFibGVIZWFkZXIgPSBUYWJsZUhlYWRlcjtcbi8qKlxuICogVGFibGVCb2R5XG4gKi9cbnZhciBUYWJsZUJvZHkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhYmxlQm9keSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZUJvZHkoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLlRhYmxlQm9keShfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiBfXzEuZ2V0SWQoX3RoaXMuYXR0cnMpLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiB1dGlsXzEuY29uY2F0KGV4cG9ydHMuVEFCTEVfQk9EWSwgX18xLmdldENsYXNzTmFtZShfdGhpcy5hdHRycykpXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRhYmxlQm9keTtcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLlRhYmxlQm9keSA9IFRhYmxlQm9keTtcbi8qKlxuICogVGFibGVGb290ZXJcbiAqL1xudmFyIFRhYmxlRm9vdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYWJsZUZvb3RlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZUZvb3RlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuVGFibGVGb290ZXIoX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBpZDogX18xLmdldElkKF90aGlzLmF0dHJzKSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogdXRpbF8xLmNvbmNhdChleHBvcnRzLlRBQkxFX0ZPT1RFUiwgX18xLmdldENsYXNzTmFtZShfdGhpcy5hdHRycykpXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRhYmxlRm9vdGVyO1xufSh3bWxfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuVGFibGVGb290ZXIgPSBUYWJsZUZvb3Rlcjtcbi8qKlxuICogVGFibGVSb3dcbiAqL1xudmFyIFRhYmxlUm93ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYWJsZVJvdywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZVJvdygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuVGFibGVSb3coX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBpZDogX18xLmdldElkKF90aGlzLmF0dHJzKSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogdXRpbF8xLmNvbmNhdChleHBvcnRzLlRBQkxFX1JPVywgX18xLmdldENsYXNzTmFtZShfdGhpcy5hdHRycykpLFxuICAgICAgICAgICAgb25jbGljazogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm9uY2xpY2spID9cbiAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5vbmNsaWNrIDogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRhYmxlUm93O1xufSh3bWxfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuVGFibGVSb3cgPSBUYWJsZVJvdztcbi8qKlxuICogVGFibGVIZWFkaW5nXG4gKi9cbnZhciBUYWJsZUhlYWRpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhYmxlSGVhZGluZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZUhlYWRpbmcoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLlRhYmxlSGVhZGluZyhfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiBfXzEuZ2V0SWQoX3RoaXMuYXR0cnMpLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiB1dGlsXzEuY29uY2F0KGV4cG9ydHMuVEFCTEVfSEVBRElORywgX18xLmdldENsYXNzTmFtZShfdGhpcy5hdHRycykpLFxuICAgICAgICAgICAgb25jbGljazogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm9uY2xpY2spID9cbiAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5vbmNsaWNrIDogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRhYmxlSGVhZGluZztcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLlRhYmxlSGVhZGluZyA9IFRhYmxlSGVhZGluZztcbi8qKlxuICogVGFibGVDZWxsXG4gKi9cbnZhciBUYWJsZUNlbGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhYmxlQ2VsbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZUNlbGwoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLlRhYmxlQ2VsbChfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiBfXzEuZ2V0SWQoX3RoaXMuYXR0cnMpLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiB1dGlsXzEuY29uY2F0KGV4cG9ydHMuVEFCTEVfQ0VMTCwgX18xLmdldENsYXNzTmFtZShfdGhpcy5hdHRycykpLFxuICAgICAgICAgICAgY29sc3BhbjogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmNvbHNwYW4pID9cbiAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5jb2xzcGFuIDogMSxcbiAgICAgICAgICAgIHJvd3NwYW46IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5yb3dzcGFuKSA/XG4gICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cucm93c3BhbiA6IDEsXG4gICAgICAgICAgICBvbmNsaWNrOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cub25jbGljaykgP1xuICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3Lm9uY2xpY2sgOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVGFibGVDZWxsO1xufSh3bWxfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuVGFibGVDZWxsID0gVGFibGVDZWxsO1xuLyoqXG4gKiBUYWJsZVdpbmRvdyBhbGxvd3MgYSBUYWJsZUxheW91dCB0byBiZSBzY3JvbGxlZCBvbiBzbWFsbGVyIHNjcmVlbnMuXG4gKi9cbnZhciBUYWJsZVdpbmRvdyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFibGVXaW5kb3csIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVXaW5kb3coKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLlRhYmxlV2luZG93KF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6IF9fMS5nZXRJZChfdGhpcy5hdHRycyksXG4gICAgICAgICAgICBjbGFzc05hbWU6IHV0aWxfMS5jb25jYXQoZXhwb3J0cy5UQUJMRV9XSU5ET1csIF9fMS5nZXRDbGFzc05hbWUoX3RoaXMuYXR0cnMpKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBUYWJsZVdpbmRvdztcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLlRhYmxlV2luZG93ID0gVGFibGVXaW5kb3c7XG4vKipcbiAqIFRhYmxlTGF5b3V0IHByb3ZpZGVzIGEgPHRhYmxlPiBiYXNlZCBsYXlvdXQuXG4gKi9cbnZhciBUYWJsZUxheW91dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFibGVMYXlvdXQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVMYXlvdXQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLlRhYmxlTGF5b3V0KF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICd0YWJsZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZDogX18xLmdldElkKF90aGlzLmF0dHJzKSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogdXRpbF8xLmNvbmNhdChleHBvcnRzLlRBQkxFX0xBWU9VVCwgX18xLmdldENsYXNzTmFtZShfdGhpcy5hdHRycyksIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5hbHRlcm5hdGUpID8gZXhwb3J0cy5BTFRFUk5BVEUgOiAnJywgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmJvcmRlcmVkKSA/IGV4cG9ydHMuQk9SREVSRUQgOiAnJywgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmNvbXBhY3QpID8gZXhwb3J0cy5DT01QQUNUIDogJycsIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5ob3ZlcmFibGUpID8gZXhwb3J0cy5IT1ZFUkFCTEUgOiAnJyksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRhYmxlTGF5b3V0O1xufSh3bWxfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuVGFibGVMYXlvdXQgPSBUYWJsZUxheW91dDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fc3ByZWFkQXJyYXlzID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5cykgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcbiAgICByZXR1cm4gcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBUYWJsZUhlYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWJsZUhlYWRlcihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCd0aGVhZCcsIHsgaHRtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmNsYXNzTmFtZSB9LCB3bWw6IHt9IH0sIF9fc3ByZWFkQXJyYXlzKChfX2NvbnRleHQuY2hpbGRyZW4pKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIFRhYmxlSGVhZGVyLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgVGFibGVIZWFkZXIucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIFRhYmxlSGVhZGVyLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIFRhYmxlSGVhZGVyLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIFRhYmxlSGVhZGVyLnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBUYWJsZUhlYWRlci5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBUYWJsZUhlYWRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gVGFibGVIZWFkZXI7XG59KCkpO1xuZXhwb3J0cy5UYWJsZUhlYWRlciA9IFRhYmxlSGVhZGVyO1xuO1xudmFyIFRhYmxlQm9keSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWJsZUJvZHkoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgndGJvZHknLCB7IGh0bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jbGFzc05hbWUgfSwgd21sOiB7fSB9LCBfX3NwcmVhZEFycmF5cygoX19jb250ZXh0LmNoaWxkcmVuKSkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBUYWJsZUJvZHkucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBUYWJsZUJvZHkucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIFRhYmxlQm9keS5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBUYWJsZUJvZHkucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgVGFibGVCb2R5LnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBUYWJsZUJvZHkucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgVGFibGVCb2R5LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBUYWJsZUJvZHk7XG59KCkpO1xuZXhwb3J0cy5UYWJsZUJvZHkgPSBUYWJsZUJvZHk7XG47XG52YXIgVGFibGVGb290ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGFibGVGb290ZXIoX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgndGZvb3QnLCB7IGh0bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jbGFzc05hbWUgfSwgd21sOiB7fSB9LCBfX3NwcmVhZEFycmF5cygoX19jb250ZXh0LmNoaWxkcmVuKSkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBUYWJsZUZvb3Rlci5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIFRhYmxlRm9vdGVyLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBUYWJsZUZvb3Rlci5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBUYWJsZUZvb3Rlci5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBUYWJsZUZvb3Rlci5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgVGFibGVGb290ZXIucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgVGFibGVGb290ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIFRhYmxlRm9vdGVyO1xufSgpKTtcbmV4cG9ydHMuVGFibGVGb290ZXIgPSBUYWJsZUZvb3RlcjtcbjtcbnZhciBUYWJsZVJvdyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWJsZVJvdyhfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCd0cicsIHsgaHRtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmNsYXNzTmFtZSwgJ29uY2xpY2snOiBfX2NvbnRleHQudmFsdWVzLm9uY2xpY2sgfSwgd21sOiB7fSB9LCBfX3NwcmVhZEFycmF5cygoX19jb250ZXh0LmNoaWxkcmVuKSkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBUYWJsZVJvdy5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIFRhYmxlUm93LnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBUYWJsZVJvdy5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBUYWJsZVJvdy5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBUYWJsZVJvdy5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgVGFibGVSb3cucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgVGFibGVSb3cucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIFRhYmxlUm93O1xufSgpKTtcbmV4cG9ydHMuVGFibGVSb3cgPSBUYWJsZVJvdztcbjtcbnZhciBUYWJsZUhlYWRpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGFibGVIZWFkaW5nKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX190aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ3RoJywgeyBodG1sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuY2xhc3NOYW1lLCAnb25jbGljayc6IF9fY29udGV4dC52YWx1ZXMub25jbGljayB9LCB3bWw6IHt9IH0sIF9fc3ByZWFkQXJyYXlzKChfX2NvbnRleHQuY2hpbGRyZW4pKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIFRhYmxlSGVhZGluZy5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIFRhYmxlSGVhZGluZy5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgVGFibGVIZWFkaW5nLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIFRhYmxlSGVhZGluZy5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBUYWJsZUhlYWRpbmcucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIFRhYmxlSGVhZGluZy5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBUYWJsZUhlYWRpbmcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIFRhYmxlSGVhZGluZztcbn0oKSk7XG5leHBvcnRzLlRhYmxlSGVhZGluZyA9IFRhYmxlSGVhZGluZztcbjtcbnZhciBUYWJsZUNlbGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGFibGVDZWxsKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX190aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ3RkJywgeyBodG1sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuaWQsICdjbGFzcyc6IF9fY29udGV4dC52YWx1ZXMuY2xhc3NOYW1lLCAnY29sc3Bhbic6IFN0cmluZyhfX2NvbnRleHQudmFsdWVzLmNvbHNwYW4pLCAncm93c3Bhbic6IFN0cmluZyhfX2NvbnRleHQudmFsdWVzLnJvd3NwYW4pLCAnb25jbGljayc6IF9fY29udGV4dC52YWx1ZXMub25jbGljayB9LCB3bWw6IHt9IH0sIF9fc3ByZWFkQXJyYXlzKChfX2NvbnRleHQuY2hpbGRyZW4pKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIFRhYmxlQ2VsbC5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIFRhYmxlQ2VsbC5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgVGFibGVDZWxsLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIFRhYmxlQ2VsbC5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBUYWJsZUNlbGwucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIFRhYmxlQ2VsbC5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBUYWJsZUNlbGwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIFRhYmxlQ2VsbDtcbn0oKSk7XG5leHBvcnRzLlRhYmxlQ2VsbCA9IFRhYmxlQ2VsbDtcbjtcbnZhciBUYWJsZVdpbmRvdyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWJsZVdpbmRvdyhfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdkaXYnLCB7IGh0bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jbGFzc05hbWUgfSwgd21sOiB7fSB9LCBfX3NwcmVhZEFycmF5cygoX19jb250ZXh0LmNoaWxkcmVuKSkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBUYWJsZVdpbmRvdy5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIFRhYmxlV2luZG93LnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBUYWJsZVdpbmRvdy5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBUYWJsZVdpbmRvdy5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBUYWJsZVdpbmRvdy5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgVGFibGVXaW5kb3cucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgVGFibGVXaW5kb3cucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIFRhYmxlV2luZG93O1xufSgpKTtcbmV4cG9ydHMuVGFibGVXaW5kb3cgPSBUYWJsZVdpbmRvdztcbjtcbnZhciBUYWJsZUxheW91dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWJsZUxheW91dChfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCd0YWJsZScsIHsgaHRtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLmNsYXNzTmFtZSB9LCB3bWw6IHt9IH0sIF9fc3ByZWFkQXJyYXlzKChfX2NvbnRleHQuY2hpbGRyZW4pKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIFRhYmxlTGF5b3V0LnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgVGFibGVMYXlvdXQucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIFRhYmxlTGF5b3V0LnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIFRhYmxlTGF5b3V0LnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIFRhYmxlTGF5b3V0LnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBUYWJsZUxheW91dC5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBUYWJsZUxheW91dC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gVGFibGVMYXlvdXQ7XG59KCkpO1xuZXhwb3J0cy5UYWJsZUxheW91dCA9IFRhYmxlTGF5b3V0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBoaWRkZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZW50L3N0YXRlL2hpZGRlblwiKTtcbnZhciBsYXlvdXRfMSA9IHJlcXVpcmUoXCIuLi8uLi9sYXlvdXRcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgZHJhd2VyXzEgPSByZXF1aXJlKFwiLi93bWwvZHJhd2VyXCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5EUkFXRVIgPSAnd3ctZHJhd2VyJztcbmV4cG9ydHMuRFJBV0VSX0NPTlRFTlQgPSAnd3ctZHJhd2VyX19jb250ZW50Jztcbi8qKlxuICogRHJhd2VyIHByb3ZpZGVzIGEgd2lkZ2V0IGZvciBkaXNwbGF5aW5nIG5hdmlnYXRpb24gYW5kIG90aGVyIHNpZGViYXIgY29udGVudC5cbiAqXG4gKiBJdCdzIGFwaSBhbGxvd3MgZm9yIHRvZ2dsaW5nIGJldHdlZW4gaGlkZGVuIGFuZCBzaG93biBzdGF0ZXMgYXMgd2VsbCBhc1xuICogcXVlcnlpbmcgdGhlIGN1cnJlbnQgc3RhdGUuXG4gKlxuICogVGhpcyB3aWRnZXQncyBzdHlsZSBpbnRlbnRpb25hbGx5IGdpdmVzIGl0IGEgaGlnaCB6LWluZGV4IHNvIHRoYXQgaXQgYXBwZWFyc1xuICogaW4tZnJvbnQgIG9mIG90aGVyIGNvbnRlbnQuIEFkanVzdCB0aGUgcmVzcGVjdGl2ZSBzdHlsZSB2YXJpYWJsZXMgdG8gY2hhbmdlLlxuICovXG52YXIgRHJhd2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEcmF3ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRHJhd2VyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyBkcmF3ZXJfMS5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgICAgIGlkOiBfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5pZCxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IHV0aWxfMS5jb25jYXQoZXhwb3J0cy5EUkFXRVIsIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5oaWRkZW4pID9cbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuXzEuSElEREVOIDogJycpLFxuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ3Jvb3QnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdjb250ZW50J1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBleHBvcnRzLkRSQVdFUl9DT05URU5ULFxuICAgICAgICAgICAgICAgIHZhbHVlOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuY29udGVudCkgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5jb250ZW50IDogX3RoaXMuY2hpbGRyZW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEcmF3ZXIucHJvdG90eXBlLmlzSGlkZGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaGlkZGVuXzEuaXNIaWRkZW4odGhpcy52aWV3LCB0aGlzLnZhbHVlcy5yb290LndtbC5pZCk7XG4gICAgfTtcbiAgICBEcmF3ZXIucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGhpZGRlbl8xLmhpZGUodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5yb290LndtbC5pZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgRHJhd2VyLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBoaWRkZW5fMS5zaG93KHRoaXMudmlldywgdGhpcy52YWx1ZXMucm9vdC53bWwuaWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIERyYXdlci5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBoaWRkZW5fMS50b2dnbGUodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5yb290LndtbC5pZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIERyYXdlcjtcbn0obGF5b3V0XzEuQWJzdHJhY3RMYXlvdXQpKTtcbmV4cG9ydHMuRHJhd2VyID0gRHJhd2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19zcHJlYWRBcnJheXMgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xuICAgIHJldHVybiByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdkaXYnLCB7IGh0bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5yb290LmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NOYW1lIH0sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLnJvb3Qud21sLmlkIH0gfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdkaXYnLCB7IGh0bWw6IHsgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5jb250ZW50LmNsYXNzTmFtZSB9LCB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5jb250ZW50LndtbC5pZCB9IH0sIF9fc3ByZWFkQXJyYXlzKChfX2NvbnRleHQudmFsdWVzLmNvbnRlbnQudmFsdWUpKSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBNYWluLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gTWFpbjtcbn0oKSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZHJhd2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvaGVhZGVyXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuLyoqXG4gKiBNRU5VX0hFQURFUlxuICovXG5leHBvcnRzLk1FTlVfSEVBREVSID0gJ3d3LW1lbnUtaGVhZGVyJztcbi8qKlxuICogTWVudUhlYWRlciBjYW4gYmUgdXNlZCB0byBkaXNwbGF5IG5vbi1jbGlja2FibGUgaGVhZGluZyB0ZXh0IGluIGEgbmF2IG1lbnUuXG4gKi9cbnZhciBNZW51SGVhZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZW51SGVhZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lbnVIZWFkZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBzcGFuOiB7XG4gICAgICAgICAgICAgICAgaWQ6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5pZCkgPyBfdGhpcy5hdHRycy53dy5pZCA6ICcnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogdXRpbF8xLmNvbmNhdChleHBvcnRzLk1FTlVfSEVBREVSLCAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuY2xhc3NOYW1lKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LmNsYXNzTmFtZSA6ICcnKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRleHQ6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy50ZXh0KSA/XG4gICAgICAgICAgICAgICAgW2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKF90aGlzLmF0dHJzLnd3LnRleHQpXSA6IF90aGlzLmNoaWxkcmVuXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1lbnVIZWFkZXI7XG59KHdtbC5Db21wb25lbnQpKTtcbmV4cG9ydHMuTWVudUhlYWRlciA9IE1lbnVIZWFkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3NwcmVhZEFycmF5cyA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheXMpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxuICAgICAgICAgICAgcltrXSA9IGFbal07XG4gICAgcmV0dXJuIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy9AdHMtaWdub3JlOiA2MTkyXG52YXIgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19pZiA9IGZ1bmN0aW9uIChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkge1xuICAgIHJldHVybiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCgpO1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JJbiA9IGZ1bmN0aW9uIChsaXN0LCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2Zvck9mID0gZnVuY3Rpb24gKG8sIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYWluKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX190aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ3NwYW4nLCB7IGh0bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5zcGFuLmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLnNwYW4uY2xhc3NOYW1lIH0sIHdtbDoge30gfSwgX19zcHJlYWRBcnJheXMoKF9fY29udGV4dC52YWx1ZXMudGV4dCkpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgTWFpbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIE1haW47XG59KCkpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlYWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHdtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2l0ZW1cIik7XG52YXIgYWN0aXZlXzEgPSByZXF1aXJlKFwiLi4vLi4vY29udGVudC9zdGF0ZS9hY3RpdmVcIik7XG52YXIgYWN0aXZlXzIgPSByZXF1aXJlKFwiLi4vLi4vY29udGVudC9zdGF0ZS9hY3RpdmVcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLklURU0gPSAnd3ctbWVudS1pdGVtJztcbmV4cG9ydHMuRElWSURFUiA9ICctZGl2aWRlcic7XG4vKipcbiAqIEl0ZW1DbGlja2VkRXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gYW4gaXRlbSBpblxuICogYSBuYXYgbGlzdC5cbiAqL1xudmFyIEl0ZW1DbGlja2VkRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSXRlbUNsaWNrZWRFdmVudChuYW1lKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgfVxuICAgIHJldHVybiBJdGVtQ2xpY2tlZEV2ZW50O1xufSgpKTtcbmV4cG9ydHMuSXRlbUNsaWNrZWRFdmVudCA9IEl0ZW1DbGlja2VkRXZlbnQ7XG4vKipcbiAqIEl0ZW0gd3JhcHMgY29udGVudCBpbiBhIG5hdmlnYXRpb24gbGlzdC5cbiAqXG4gKiBJdGVtcyBzaG91bGQgbm90IGhhdmUgYW55IHNpYmxpbmdzIHRoYXQgYXJlIG5vdCBvdGhlciBJdGVtcy5cbiAqL1xudmFyIEl0ZW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEl0ZW0sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSXRlbSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdyb290J1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaWQ6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5pZCkgPyBfdGhpcy5hdHRycy53dy5pZCA6ICcnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogdXRpbF8xLmNvbmNhdChleHBvcnRzLklURU0sIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5hY3RpdmUpID8gYWN0aXZlXzIuQUNUSVZFIDogJycsIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5kaXZpZGVyKSA/IGV4cG9ydHMuRElWSURFUiA6ICcnKSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmRpdmlkZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cudGV4dClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKF90aGlzLmF0dHJzLnd3LnRleHQpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSXRlbS5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFjdGl2ZV8xLmFjdGl2YXRlKHRoaXMudmlldywgdGhpcy52YWx1ZXMucm9vdC53bWwuaWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEl0ZW0ucHJvdG90eXBlLmRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFjdGl2ZV8xLmRlYWN0aXZhdGUodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5yb290LndtbC5pZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIEl0ZW07XG59KHdtbC5Db21wb25lbnQpKTtcbmV4cG9ydHMuSXRlbSA9IEl0ZW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3NwcmVhZEFycmF5cyA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheXMpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxuICAgICAgICAgICAgcltrXSA9IGFbal07XG4gICAgcmV0dXJuIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy9AdHMtaWdub3JlOiA2MTkyXG52YXIgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19pZiA9IGZ1bmN0aW9uIChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkge1xuICAgIHJldHVybiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCgpO1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JJbiA9IGZ1bmN0aW9uIChsaXN0LCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2Zvck9mID0gZnVuY3Rpb24gKG8sIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYWluKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX190aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLm5vZGUoJ2xpJywgeyBodG1sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMucm9vdC5pZCwgJ2NsYXNzJzogX19jb250ZXh0LnZhbHVlcy5yb290LmNsYXNzTmFtZSB9LCB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5yb290LndtbC5pZCB9IH0sIF9fc3ByZWFkQXJyYXlzKChfX2NvbnRleHQudmFsdWVzLnJvb3QuY29udGVudC5yZW5kZXIoKSkpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgTWFpbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIE1haW47XG59KCkpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWl0ZW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBoaWRkZW4gPSByZXF1aXJlKFwiLi4vLi4vY29udGVudC9zdGF0ZS9oaWRkZW5cIik7XG52YXIgaGVhZGVyVmlld3MgPSByZXF1aXJlKFwiLi93bWwvaGVhZGVyXCIpO1xudmFyIHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgb3JpZW50YXRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZW50L29yaWVudGF0aW9uXCIpO1xudmFyIF9fMSA9IHJlcXVpcmUoXCIuLi8uLi9cIik7XG52YXIgbWVudV8xID0gcmVxdWlyZShcIi4vd21sL21lbnVcIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLk1FTlUgPSAnd3ctbWVudSc7XG5leHBvcnRzLk1FTlVfSEVBREVSX0lURU0gPSAnd3ctbWVudV9faGVhZGVyLWl0ZW0nO1xuLy8vY2xhc3NOYW1lczplbmRcbmV4cG9ydHMuTkFWX01PREUgPSAnbmF2JztcbmV4cG9ydHMuQ09OVEVOVF9NT0RFID0gJ2NvbnRlbnQnO1xuLyoqXG4gKiBIZWFkZXJJdGVtXG4gKi9cbnZhciBIZWFkZXJJdGVtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhIZWFkZXJJdGVtLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhlYWRlckl0ZW0oKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IGhlYWRlclZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiB1dGlsXzEuY29uY2F0KGV4cG9ydHMuTUVOVV9IRUFERVJfSVRFTSwgX18xLmdldENsYXNzTmFtZShfdGhpcy5hdHRycykpLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy50ZXh0KSA/XG4gICAgICAgICAgICAgICAgICAgIFtfXzEudGV4dChfdGhpcy5hdHRycy53dy50ZXh0KV0gOiBfdGhpcy5jaGlsZHJlblxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBIZWFkZXJJdGVtO1xufSh3bWxfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuSGVhZGVySXRlbSA9IEhlYWRlckl0ZW07XG4vKipcbiAqIE1lbnUgcHJvdmlkZXMgYSBET00gY29udGFpbmVyIGZvciByZW5kZXJpbmdcbiAqIGEgZHJvcGRvd24gc3R5bGUgbWVudS5cbiAqL1xudmFyIE1lbnUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lbnUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVudSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgbWVudV8xLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAncm9vdCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlkOiBfXzEuZ2V0SWQoX3RoaXMuYXR0cnMpLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogdXRpbF8xLmNvbmNhdChleHBvcnRzLk1FTlUsIF9fMS5nZXRDbGFzc05hbWUoX3RoaXMuYXR0cnMpLCAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuaGlkZGVuKSA/IGhpZGRlbi5ISURERU4gOiAnJywgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmJsb2NrKSA/IG9yaWVudGF0aW9uXzEuQkxPQ0sgOiAnJylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZW51OiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdtZW51J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNoaWxkcmVuOyB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTWVudS5wcm90b3R5cGUuaXNIaWRkZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBoaWRkZW4uaXNIaWRkZW4odGhpcy52aWV3LCB0aGlzLnZhbHVlcy5yb290LndtbC5pZCk7XG4gICAgfTtcbiAgICBNZW51LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBoaWRkZW4uaGlkZSh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLnJvb3Qud21sLmlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBNZW51LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBoaWRkZW4uc2hvdyh0aGlzLnZpZXcsIHRoaXMudmFsdWVzLnJvb3Qud21sLmlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBNZW51LnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGhpZGRlbi50b2dnbGUodGhpcy52aWV3LCB0aGlzLnZhbHVlcy5yb290LndtbC5pZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgTWVudS5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgICAgIHRoaXMudmFsdWVzLmNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb250ZW50OyB9O1xuICAgICAgICB0aGlzLnZpZXcuaW52YWxpZGF0ZSgpO1xuICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gTWVudTtcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLk1lbnUgPSBNZW51O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19zcHJlYWRBcnJheXMgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xuICAgIHJldHVybiByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy5ub2RlKCdsaScsIHsgaHRtbDogeyAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NOYW1lIH0sIHdtbDoge30gfSwgX19zcHJlYWRBcnJheXMoKF9fY29udGV4dC52YWx1ZXMucm9vdC5jb250ZW50KSkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBNYWluLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gTWFpbjtcbn0oKSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVhZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fc3ByZWFkQXJyYXlzID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5cykgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcbiAgICByZXR1cm4gcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgndWwnLCB7IGh0bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5yb290LmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NOYW1lIH0sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLnJvb3Qud21sLmlkIH0gfSwgX19zcHJlYWRBcnJheXMoKF9fY29udGV4dC52YWx1ZXMuY29udGVudCgpKSkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBNYWluLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gTWFpbjtcbn0oKSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVudS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHdtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9uYXZcIik7XG52YXIgb3JpZW50YXRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZW50L29yaWVudGF0aW9uXCIpO1xudmFyIGl0ZW1fMSA9IHJlcXVpcmUoXCIuLi9pdGVtXCIpO1xuZXhwb3J0cy5JdGVtID0gaXRlbV8xLkl0ZW07XG52YXIgbGlua18xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRlbnQvbGlua1wiKTtcbmV4cG9ydHMuTGluayA9IGxpbmtfMS5MaW5rO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuLyoqXG4gKiBOQVZcbiAqL1xuZXhwb3J0cy5OQVYgPSAnd3ctbmF2Jztcbi8qKlxuICogTmF2IHByb3ZpZGVzIHN0eWxpbmcgZm9yIGRpc3BsYXlpbmcgYSBsaXN0IG9mIGFuY2hvciBsaW5rcy5cbiAqL1xudmFyIE5hdiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTmF2LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5hdigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgICAgICBpZDogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmlkKSA/IF90aGlzLmF0dHJzLnd3LmlkIDogJycsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiB1dGlsLmNvbmNhdChleHBvcnRzLk5BViwgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmNsYXNzTmFtZSkgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5jbGFzc05hbWUgOiAnJywgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnZlcnRpY2FsKSA/XG4gICAgICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uXzEuVkVSVElDQUwgOiAnJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTmF2O1xufSh3bWwuQ29tcG9uZW50KSk7XG5leHBvcnRzLk5hdiA9IE5hdjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fc3ByZWFkQXJyYXlzID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5cykgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcbiAgICByZXR1cm4gcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMubm9kZSgndWwnLCB7IGh0bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5yb290LmlkLCAnY2xhc3MnOiBfX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NOYW1lIH0sIHdtbDoge30gfSwgX19zcHJlYWRBcnJheXMoKF9fY29udGV4dC5jaGlsZHJlbikpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgTWFpbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIE1haW47XG59KCkpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5hdi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogVGhpcyBtb2R1bGUgcHJvdmlkZXMgdXRpbGl0eSBmdW5jdGlvbnMgYW5kIGNvbnN0YW50cyB1c2VkXG4gKiB0aHJvdWdoIG91dCB0aGUgd21sLXdpZGdldHMgbW9kdWxlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIGdldEJ5SWQgcmV0cmVpdmVzIGFuIFdNTEVsZW1lbnQgZnJvbSBhIHZpZXcgYnkgaXRzIGlkLlxuICpcbiAqIElmIHRoZSBXTUxFbGVtZW50IGlzIG5vdCBmb3VuZCBhIHdhcm5pbmcgaXMgbG9nZ2VkIHRvIGNvbnNvbGUuXG4gKi9cbmV4cG9ydHMuZ2V0QnlJZCA9IGZ1bmN0aW9uICh2aWV3LCBpZCkge1xuICAgIHZhciBtID0gdmlldy5maW5kQnlJZChpZCk7XG4gICAgaWYgKG0uaXNOb3RoaW5nKCkpIHtcbiAgICAgICAgZXhwb3J0cy53YXJuTWlzc2luZyh2aWV3LCBpZCk7XG4gICAgfVxuICAgIHJldHVybiBtO1xufTtcbi8qKlxuICogd2FybiB2aWEgY29uc29sZSB0aGF0IGFuIGVsZW1lbnQgaXMgbWlzc2luZy5cbiAqL1xuZXhwb3J0cy53YXJuTWlzc2luZyA9IGZ1bmN0aW9uICh2aWV3LCBpZCkge1xuICAgIGNvbnNvbGUud2FybignVGhlIHZpZXcgJywgdmlldywgXCIgZG9lcyBub3QgaGF2ZSBhbiBpZCBcXFwiXCIgKyBpZCArIFwiXFxcIiFcIik7XG59O1xuLyoqXG4gKiBjb21iaW5lIHRoZSBtZW1iZXJzIG9mIGFuIGFycmF5IGludG8gb25lIHN0cmluZy5cbiAqL1xuZXhwb3J0cy5jb21iaW5lID0gZnVuY3Rpb24gKHN0ciwgam9pbmVyKSB7XG4gICAgaWYgKGpvaW5lciA9PT0gdm9pZCAwKSB7IGpvaW5lciA9ICcgJzsgfVxuICAgIHJldHVybiBzdHIuZmlsdGVyKGZ1bmN0aW9uIChzKSB7IHJldHVybiAoKHMgIT0gbnVsbCkgfHwgcyAhPSAnJyk7IH0pLmpvaW4oam9pbmVyKTtcbn07XG4vKipcbiAqIGNvbmNhdCBqb2lucyB2YXJpb3VzIHN0cmluZ3MgdG9nZXRoZXIgdG8gZm9ybSBhbiBodG1sIGNsYXNzIGF0dHJpYnV0ZSB2YWx1ZS5cbiAqXG4gKiBSZW1vdmVzIGVtcHR5IHN0cmluZ3MsIG51bGwgYW5kIHVuZGVmaW5lZCB2YWx1ZXMuXG4gKi9cbmV4cG9ydHMuY29uY2F0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdHIgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBzdHJbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5maWx0ZXIoZnVuY3Rpb24gKHMpIHsgcmV0dXJuICgocyA9PSBudWxsKSB8fCAocyA9PSAnJykpID8gZmFsc2UgOiB0cnVlOyB9KVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnRyaW0oKTsgfSkuam9pbignICcpO1xufTtcbi8qKlxuICogbm9vcFxuICovXG5leHBvcnRzLm5vb3AgPSBmdW5jdGlvbiAoKSB7IH07XG4vKipcbiAqIHJlcGxhY2VDb250ZW50XG4gKi9cbmV4cG9ydHMucmVwbGFjZUNvbnRlbnQgPSBmdW5jdGlvbiAociwgbm9kZSkge1xuICAgIHdoaWxlIChub2RlLmxhc3RDaGlsZClcbiAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmxhc3RDaGlsZCk7XG4gICAgbm9kZS5hcHBlbmRDaGlsZChyLnJlbmRlcigpKTtcbn07XG4vKipcbiAqIGRlYm91bmNlIGEgZnVuY3Rpb24gc28gdGhhdCBpdCBpcyBvbmx5IGNhbGxlZCBvbmNlIGFmdGVyXG4gKiBhIHBlcmlvZCBvZiB0aW1lLlxuICovXG5leHBvcnRzLmRlYm91bmNlID0gZnVuY3Rpb24gKGYsIGRlbGF5KSB7XG4gICAgdmFyIHRpbWVyID0gLTE7XG4gICAgcmV0dXJuIGRlbGF5ID09PSAwID8gZiA6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIGlmICh0aW1lciA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZihhKTsgfSwgZGVsYXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIHRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZihhKTsgfSwgZGVsYXkpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fc3ByZWFkQXJyYXlzID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5cykgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcbiAgICByZXR1cm4gcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFRoZSBhcnJheSBtb2R1bGUgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9uc1xuICogZm9yIHdvcmtpbmcgd2l0aCBKUyBhcnJheXMuXG4gKi9cbnZhciByZWNvcmRfMSA9IHJlcXVpcmUoXCIuLi9yZWNvcmRcIik7XG52YXIgbWF0aF8xID0gcmVxdWlyZShcIi4uLy4uL21hdGhcIik7XG4vKipcbiAqIGhlYWQgcmV0dXJucyB0aGUgaXRlbSBhdCBpbmRleCAwIG9mIGFuIGFycmF5XG4gKi9cbmV4cG9ydHMuaGVhZCA9IGZ1bmN0aW9uIChsaXN0KSB7IHJldHVybiBsaXN0WzBdOyB9O1xuLyoqXG4gKiB0YWlsIHJldHVybnMgdGhlIGxhc3QgaXRlbSBpbiBhbiBhcnJheVxuICovXG5leHBvcnRzLnRhaWwgPSBmdW5jdGlvbiAobGlzdCkgeyByZXR1cm4gbGlzdFtsaXN0Lmxlbmd0aCAtIDFdOyB9O1xuLyoqXG4gKiBlbXB0eSBpbmRpY2F0ZXMgd2hldGhlciBhbiBhcnJheSBpcyBlbXB0eSBvciBub3QuXG4gKi9cbmV4cG9ydHMuZW1wdHkgPSBmdW5jdGlvbiAobGlzdCkgeyByZXR1cm4gKGxpc3QubGVuZ3RoID09PSAwKTsgfTtcbi8qKlxuICogY29udGFpbnMgaW5kaWNhdGVzIHdoZXRoZXIgYW4gZWxlbWVudCBleGlzdHMgaW4gYW4gYXJyYXkuXG4gKi9cbmV4cG9ydHMuY29udGFpbnMgPSBmdW5jdGlvbiAobGlzdCkgeyByZXR1cm4gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIChsaXN0LmluZGV4T2YoYSkgPiAtMSk7IH07IH07XG4vKipcbiAqIG1hcCBpcyBhIGN1cnJpZWQgdmVyc2lvbiBvZiB0aGUgQXJyYXkjbWFwIG1ldGhvZC5cbiAqL1xuZXhwb3J0cy5tYXAgPSBmdW5jdGlvbiAobGlzdCkgeyByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGxpc3QubWFwKGYpOyB9OyB9O1xuLyoqXG4gKiBjb25jYXQgY29uY2F0ZW5hdGVzIGFuIGVsZW1lbnQgdG8gYW4gYXJyYXkgd2l0aG91dCBkZXN0cnVjdHVyaW5nXG4gKiB0aGUgZWxlbWVudCBpZiBpdHNlbGYgaXMgYW4gYXJyYXkuXG4gKi9cbmV4cG9ydHMuY29uY2F0ID0gZnVuY3Rpb24gKGxpc3QsIGEpIHsgcmV0dXJuIF9fc3ByZWFkQXJyYXlzKGxpc3QsIFthXSk7IH07XG4vKipcbiAqIHBhcnRpdGlvbiBhbiBhcnJheSBpbnRvIHR3byB1c2luZyBhIHBhcnRpdGlvbmluZyBmdW5jdGlvbi5cbiAqXG4gKiBUaGUgZmlyc3QgYXJyYXkgY29udGFpbnMgdmFsdWVzIHRoYXQgcmV0dXJuIHRydWUgYW5kIHRoZSBzZWNvbmQgZmFsc2UuXG4gKi9cbmV4cG9ydHMucGFydGl0aW9uID0gZnVuY3Rpb24gKGxpc3QpIHsgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiBleHBvcnRzLmVtcHR5KGxpc3QpID9cbiAgICBbW10sIFtdXSA6XG4gICAgbGlzdC5yZWR1Y2UoZnVuY3Rpb24gKF9hLCBjLCBpKSB7XG4gICAgICAgIHZhciB5ZXMgPSBfYVswXSwgbm8gPSBfYVsxXTtcbiAgICAgICAgcmV0dXJuIChmKGMsIGksIGxpc3QpID9cbiAgICAgICAgICAgIFtleHBvcnRzLmNvbmNhdCh5ZXMsIGMpLCBub10gOlxuICAgICAgICAgICAgW3llcywgZXhwb3J0cy5jb25jYXQobm8sIGMpXSk7XG4gICAgfSwgW1tdLCBbXV0pOyB9OyB9O1xuLyoqXG4gKiBncm91cCB0aGUgZWxlbWVudHMgb2YgYW4gYXJyYXkgaW50byBhIFJlY29yZCB3aGVyZSBlYWNoIHByb3BlcnR5XG4gKiBpcyBhbiBhcnJheSBvZiBlbGVtZW50cyBhc3NpZ25lZCB0byBpdCdzIHByb3BlcnR5IG5hbWUuXG4gKi9cbmV4cG9ydHMuZ3JvdXAgPSBmdW5jdGlvbiAobGlzdCkgeyByZXR1cm4gZnVuY3Rpb24gKGYpIHtcbiAgICByZXR1cm4gbGlzdC5yZWR1Y2UoZnVuY3Rpb24gKHAsIGMsIGkpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgZyA9IGYoYywgaSwgbGlzdCk7XG4gICAgICAgIHJldHVybiByZWNvcmRfMS5tZXJnZShwLCAoX2EgPSB7fSxcbiAgICAgICAgICAgIF9hW2ddID0gQXJyYXkuaXNBcnJheShwW2ddKSA/XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5jb25jYXQocFtnXSwgYykgOiBbY10sXG4gICAgICAgICAgICBfYSkpO1xuICAgIH0sIHt9KTtcbn07IH07XG4vKipcbiAqIGRpc3RyaWJ1dGUgYnJlYWtzIGFuIGFycmF5IGludG8gYW4gYXJyYXkgb2YgZXF1YWxseSAoYXBwcm94aW1hdGUpIHNpemVkXG4gKiBzbWFsbGVyIGFycmF5cy5cbiAqL1xuZXhwb3J0cy5kaXN0cmlidXRlID0gZnVuY3Rpb24gKGxpc3QsIHNpemUpIHtcbiAgICB2YXIgciA9IGxpc3QucmVkdWNlKGZ1bmN0aW9uIChwLCBjLCBpKSB7XG4gICAgICAgIHJldHVybiBtYXRoXzEuaXNNdWx0aXBsZU9mKHNpemUsIGkgKyAxKSA/XG4gICAgICAgICAgICBbZXhwb3J0cy5jb25jYXQocFswXSwgZXhwb3J0cy5jb25jYXQocFsxXSwgYykpLCBbXV0gOlxuICAgICAgICAgICAgW3BbMF0sIGV4cG9ydHMuY29uY2F0KHBbMV0sIGMpXTtcbiAgICB9LCBbW10sIFtdXSk7XG4gICAgcmV0dXJuIChyWzFdLmxlbmd0aCA9PT0gMCkgPyByWzBdIDogZXhwb3J0cy5jb25jYXQoclswXSwgclsxXSk7XG59O1xuLyoqXG4gKiBkZWR1cGUgYW4gYXJyYXkgYnkgZmlsdGVyaW5nIG91dCBlbGVtZW50c1xuICogdGhhdCBhcHBlYXIgdHdpY2UuXG4gKi9cbmV4cG9ydHMuZGVkdXBlID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgICByZXR1cm4gbGlzdC5maWx0ZXIoZnVuY3Rpb24gKGUsIGksIGwpIHsgcmV0dXJuIGwuaW5kZXhPZihlKSA9PT0gaTsgfSk7XG59O1xuLyoqXG4gKiByZW1vdmUgYW4gZWxlbWVudCBmcm9tIGFuIGFycmF5IHJldHVybmluZyBhIG5ldyBjb3B5IHdpdGggdGhlIGVsZW1lbnRcbiAqIHJlbW92ZWQuXG4gKi9cbmV4cG9ydHMucmVtb3ZlID0gZnVuY3Rpb24gKGxpc3QsIHRhcmdldCkge1xuICAgIHZhciBpZHggPSBsaXN0LmluZGV4T2YodGFyZ2V0KTtcbiAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgICByZXR1cm4gbGlzdC5zbGljZSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGEgPSBsaXN0LnNsaWNlKCk7XG4gICAgICAgIGEuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbn07XG4vKipcbiAqIHJlbW92ZUF0IHJlbW92ZXMgYW4gZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4IHJldHVybmluZyBhIGNvcHlcbiAqIG9mIHRoZSBvcmlnaW5hbCBhcnJheSB3aXRoIHRoZSBlbGVtZW50IHJlbW92ZWQuXG4gKi9cbmV4cG9ydHMucmVtb3ZlQXQgPSBmdW5jdGlvbiAobGlzdCwgaWR4KSB7XG4gICAgaWYgKChsaXN0Lmxlbmd0aCA+IGlkeCkgJiYgKGlkeCA+IC0xKSkge1xuICAgICAgICB2YXIgYSA9IGxpc3Quc2xpY2UoKTtcbiAgICAgICAgYS5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbGlzdC5zbGljZSgpO1xuICAgIH1cbn07XG4vKipcbiAqIG1ha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgb2YgYSBnaXZlbiBzaXplIHVzaW5nIGEgZnVuY3Rpb24gdG8gcHJvdmlkZVxuICogZWFjaCBlbGVtZW50LlxuICpcbiAqIFRoZSBmdW5jdGlvbiByZWNlaXZlcyB0aGUgaW5kZXggbnVtYmVyIGZvciBlYWNoIHN0ZXAuXG4gKi9cbmV4cG9ydHMubWFrZSA9IGZ1bmN0aW9uIChzaXplLCBmKSB7XG4gICAgdmFyIGEgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspXG4gICAgICAgIGFbaV0gPSBmKGkpO1xuICAgIHJldHVybiBhO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBVc2VmdWwgZnVuY3Rpb25zIGZvciBzb3J0aW5nIGRhdGEgaW4gYW4gYXJyYXkuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBhcmUgZXhwZWN0ZWQgdG8gYmUgcGFzc2VkIHRvIEFycmF5I3NvcnQuXG4gKiBEZWZhdWx0cyB0byBhc2NlbmRpbmcgb3JkZXIgdW5sZXNzIHNwZWNpZmllZCBvdGhlcndpc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogZGF0ZSBzb3J0cyB0d28gc3RyaW5ncyByZXByZXNlbnRpbmcgZGF0ZXMuXG4gKlxuICogVGhlIGRhdGVzIGFyZSBwYXNzZWQgdG8gdGhlIGRhdGUgY29uc3RydWN0b3IuXG4gKi9cbmV4cG9ydHMuZGF0ZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIG5hID0gbmV3IERhdGUoYSkuZ2V0VGltZSgpO1xuICAgIHZhciBuYiA9IG5ldyBEYXRlKGIpLmdldFRpbWUoKTtcbiAgICByZXR1cm4gbmEgPiBuYiA/IC0xIDogbmEgPCBuYiA/IDEgOiAwO1xufTtcbi8qKlxuICogc3RyaW5nIHNvcnRzIHR3byBzdHJpbmdzIGJ5IGZpcnN0IGxvd2VyIGNhc2luZyB0aGVtLlxuICovXG5leHBvcnRzLnN0cmluZyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGxhID0gU3RyaW5nKGEpLnJlcGxhY2UoL1xccysvLCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgbGIgPSBTdHJpbmcoYikucmVwbGFjZSgvXFxzKy8sICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiAobGEgPiBsYikgPyAtMSA6IChsYSA8IGxiKSA/IDEgOiAwO1xufTtcbi8qKlxuICogbnVtYmVyIHNvcnRcbiAqL1xuZXhwb3J0cy5udW1iZXIgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciBuYSA9IHBhcnNlRmxvYXQoYSk7XG4gICAgdmFyIG5iID0gcGFyc2VGbG9hdChiKTtcbiAgICBuYSA9IChpc05hTihhKSkgPyAtSW5maW5pdHkgOiBhO1xuICAgIG5iID0gKGlzTmFOKGIpKSA/IC1JbmZpbml0eSA6IGI7XG4gICAgcmV0dXJuIChuYSA+IG5iKSA/IC0xIDogKG5hIDwgbmIpID8gMSA6IDA7XG59O1xuLyoqXG4gKiBuYXR1cmFsIHNvcnQgaW1wZWxtZW50YXRpb24uXG4gKi9cbmV4cG9ydHMubmF0dXJhbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgaWYgKGEgPT09IHZvaWQgMCkgeyBhID0gJyc7IH1cbiAgICBpZiAoYiA9PT0gdm9pZCAwKSB7IGIgPSAnJzsgfVxuICAgIHZhciByZUEgPSAvW15hLXpBLVpdL2c7XG4gICAgdmFyIHJlTiA9IC9bXjAtOV0vZztcbiAgICB2YXIgYUludCA9IHBhcnNlSW50KGEsIDEwKTtcbiAgICB2YXIgYkludCA9IHBhcnNlSW50KGIsIDEwKTtcbiAgICBpZiAoaXNOYU4oYUludCkgJiYgaXNOYU4oYkludCkpIHtcbiAgICAgICAgdmFyIGFBID0gU3RyaW5nKGEpLnJlcGxhY2UocmVBLCAnJyk7XG4gICAgICAgIHZhciBiQSA9IFN0cmluZyhiKS5yZXBsYWNlKHJlQSwgJycpO1xuICAgICAgICBpZiAoYUEgPT09IGJBKSB7XG4gICAgICAgICAgICB2YXIgYU4gPSBwYXJzZUludChTdHJpbmcoYSkucmVwbGFjZShyZU4sICcnKSwgMTApO1xuICAgICAgICAgICAgdmFyIGJOID0gcGFyc2VJbnQoU3RyaW5nKGIpLnJlcGxhY2UocmVOLCAnJyksIDEwKTtcbiAgICAgICAgICAgIHJldHVybiBhTiA9PT0gYk4gPyAwIDogYU4gPiBiTiA/IC0xIDogMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhQSA+IGJBID8gLTEgOiAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzTmFOKGFJbnQpKSB7IC8vQSBpcyBub3QgYW4gSW50XG4gICAgICAgIHJldHVybiAtMTsgLy90byBtYWtlIGFscGhhbnVtZXJpYyBzb3J0IGZpcnN0IHJldHVybiAtMSBoZXJlXG4gICAgfVxuICAgIGVsc2UgaWYgKGlzTmFOKGJJbnQpKSB7IC8vQiBpcyBub3QgYW4gSW50XG4gICAgICAgIHJldHVybiAxOyAvL3RvIG1ha2UgYWxwaGFudW1lcmljIHNvcnQgZmlyc3QgcmV0dXJuIDEgaGVyZVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFJbnQgPiBiSW50ID8gLTEgOiAxO1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zb3J0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBOb3RoaW5nIHJlcHJlc2VudHMgdGhlIGFic2VuY2Ugb2YgYSB1c2FibGUgdmFsdWUuXG4gKi9cbnZhciBOb3RoaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vdGhpbmcoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIG1hcCBzaW1wbHkgcmV0dXJucyBhIE5vdGhpbmc8QT5cbiAgICAgKi9cbiAgICBOb3RoaW5nLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICByZXR1cm4gbmV3IE5vdGhpbmcoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGFwIGFsbG93cyBmb3IgYSBmdW5jdGlvbiB3cmFwcGVkIGluIGEgSnVzdCB0byBhcHBseVxuICAgICAqIHRvIHZhbHVlIHByZXNlbnQgaW4gdGhpcyBKdXN0LlxuICAgICAqL1xuICAgIE5vdGhpbmcucHJvdG90eXBlLmFwID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb3RoaW5nKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBvZiB3cmFwcyBhIHZhbHVlIGluIGEgSnVzdC5cbiAgICAgKi9cbiAgICBOb3RoaW5nLnByb3RvdHlwZS5vZiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBuZXcgSnVzdChhKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGNoYWluIHNpbXBseSByZXR1cm5zIGEgTm90aGluZzxBPi5cbiAgICAgKi9cbiAgICBOb3RoaW5nLnByb3RvdHlwZS5jaGFpbiA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgIHJldHVybiBuZXcgTm90aGluZygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogYWx0IHdpbGwgcHJlZmVyIHdoYXRldmVyIE1heWJlIGluc3RhbmNlIHByb3ZpZGVkLlxuICAgICAqL1xuICAgIE5vdGhpbmcucHJvdG90eXBlLmFsdCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZW1wdHkgcHJvdmlkZXMgYSBkZWZhdWx0IE1heWJlLlxuICAgICAqIE1heWJlLmVtcHR5KCkgPSBuZXcgTm90aGluZygpXG4gICAgICovXG4gICAgTm90aGluZy5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTm90aGluZygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZXh0ZW5kIHJldHVybnMgYSBOb3RoaW5nPEE+LlxuICAgICAqL1xuICAgIE5vdGhpbmcucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgIHJldHVybiBuZXcgTm90aGluZygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZXEgcmV0dXJucyB0cnVlIGlmIGNvbXBhcmVkIHRvIGFub3RoZXIgTm90aGluZyBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBOb3RoaW5nLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIHJldHVybiBtIGluc3RhbmNlb2YgTm90aGluZztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIG9ySnVzdCBjb252ZXJ0cyBhIE5vdGhpbmc8QT4gdG8gYSBKdXN0XG4gICAgICogdXNpbmcgdGhlIHZhbHVlIGZyb20gdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIE5vdGhpbmcucHJvdG90eXBlLm9ySnVzdCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBuZXcgSnVzdChmKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogb3JFbHNlIGFsbG93cyBhbiBhbHRlcm5hdGl2ZSBNYXliZSB2YWx1ZVxuICAgICAqIHRvIGJlIHByb3ZpZGVkIHNpbmNlIHRoaXMgb25lIGlzIE5vdGhpbmc8QT4uXG4gICAgICovXG4gICAgTm90aGluZy5wcm90b3R5cGUub3JFbHNlID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIGYoKTtcbiAgICB9O1xuICAgIE5vdGhpbmcucHJvdG90eXBlLmlzTm90aGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBOb3RoaW5nLnByb3RvdHlwZS5pc0p1c3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGdldCB0aHJvd3MgYW4gZXJyb3IgYmVjYXVzZSB0aGVyZVxuICAgICAqIGlzIG5vdGhpbmcgaGVyZSB0byBnZXQuXG4gICAgICovXG4gICAgTm90aGluZy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgZ2V0IGEgdmFsdWUgZnJvbSBOb3RoaW5nIScpO1xuICAgIH07XG4gICAgcmV0dXJuIE5vdGhpbmc7XG59KCkpO1xuZXhwb3J0cy5Ob3RoaW5nID0gTm90aGluZztcbi8qKlxuICogSnVzdCByZXByZXNlbnRzIHRoZSBwcmVzZW5jZSBvZiBhIHVzYWJsZSB2YWx1ZS5cbiAqL1xudmFyIEp1c3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSnVzdCh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIG1hcCBvdmVyIHRoZSB2YWx1ZSBwcmVzZW50IGluIHRoZSBKdXN0LlxuICAgICAqL1xuICAgIEp1c3QucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBuZXcgSnVzdChmKHRoaXMudmFsdWUpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGFwIGFsbG93cyBmb3IgYSBmdW5jdGlvbiB3cmFwcGVkIGluIGEgSnVzdCB0byBhcHBseVxuICAgICAqIHRvIHZhbHVlIHByZXNlbnQgaW4gdGhpcyBKdXN0LlxuICAgICAqL1xuICAgIEp1c3QucHJvdG90eXBlLmFwID0gZnVuY3Rpb24gKG1iKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBtYi5tYXAoZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYoX3RoaXMudmFsdWUpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIG9mIHdyYXBzIGEgdmFsdWUgaW4gYSBKdXN0LlxuICAgICAqL1xuICAgIEp1c3QucHJvdG90eXBlLm9mID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBKdXN0KGEpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogY2hhaW4gYWxsb3dzIHRoZSBzZXF1ZW5jaW5nIG9mIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBhIE1heWJlLlxuICAgICAqL1xuICAgIEp1c3QucHJvdG90eXBlLmNoYWluID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIGYodGhpcy52YWx1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBhbHQgd2lsbCBwcmVmZXIgdGhlIGZpcnN0IEp1c3QgZW5jb3VudGVyZWQgKHRoaXMpLlxuICAgICAqL1xuICAgIEp1c3QucHJvdG90eXBlLmFsdCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZW1wdHkgcHJvdmlkZXMgYSBkZWZhdWx0IE1heWJlLlxuICAgICAqIE1heWJlLmVtcHR5KCkgPSBuZXcgTm90aGluZygpXG4gICAgICovXG4gICAgSnVzdC5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTm90aGluZygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZXh0ZW5kIGFsbG93cyBzZXF1ZW5jaW5nIG9mIE1heWJlcyB3aXRoXG4gICAgICogZnVuY3Rpb25zIHRoYXQgdW53cmFwIGludG8gbm9uIE1heWJlIHR5cGVzLlxuICAgICAqL1xuICAgIEp1c3QucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBuZXcgSnVzdChmKHRoaXMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGVxIHRlc3RzIHRoZSB2YWx1ZSBvZiB0d28gSnVzdHMuXG4gICAgICovXG4gICAgSnVzdC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiAobSkge1xuICAgICAgICByZXR1cm4gKChtIGluc3RhbmNlb2YgSnVzdCkgJiYgKG0udmFsdWUgPT09IHRoaXMudmFsdWUpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIG9ySnVzdCByZXR1cm5zIHRoaXMgSnVzdC5cbiAgICAgKi9cbiAgICBKdXN0LnByb3RvdHlwZS5vckp1c3QgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIG9yRWxzZSByZXR1cm5zIHRoaXMgSnVzdFxuICAgICAqL1xuICAgIEp1c3QucHJvdG90eXBlLm9yRWxzZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgSnVzdC5wcm90b3R5cGUuaXNOb3RoaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBKdXN0LnByb3RvdHlwZS5pc0p1c3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSB2YWx1ZSBvZiB0aGlzIEp1c3QuXG4gICAgICovXG4gICAgSnVzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9O1xuICAgIHJldHVybiBKdXN0O1xufSgpKTtcbmV4cG9ydHMuSnVzdCA9IEp1c3Q7XG4vKipcbiAqIG9mXG4gKi9cbmV4cG9ydHMub2YgPSBmdW5jdGlvbiAoYSkgeyByZXR1cm4gbmV3IEp1c3QoYSk7IH07XG4vKipcbiAqIG5vdGhpbmcgY29udmVuaWVuY2UgY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0cy5ub3RoaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IE5vdGhpbmcoKTsgfTtcbi8qKlxuICoganVzdCBjb252ZW5pZW5jZSBjb25zdHJ1Y3RvclxuICovXG5leHBvcnRzLmp1c3QgPSBmdW5jdGlvbiAoYSkgeyByZXR1cm4gbmV3IEp1c3QoYSk7IH07XG4vKipcbiAqIGZyb21OdWxsYWJsZSBjb25zdHJ1Y3RzIGEgTWF5YmUgZnJvbSBhIHZhbHVlIHRoYXQgbWF5IGJlIG51bGwuXG4gKi9cbmV4cG9ydHMuZnJvbU51bGxhYmxlID0gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEgPT0gbnVsbCA/XG4gICAgbmV3IE5vdGhpbmcoKSA6IG5ldyBKdXN0KGEpOyB9O1xuLyoqXG4gKiBmcm9tQXJyYXkgY2hlY2tzIGFuIGFycmF5IHRvIHNlZSBpZiBpdCdzIGVtcHR5XG4gKlxuICogUmV0dXJucyBbW05vdGhpbmddXSBpZiBpdCBpcywgW1tKdXN0XV0gb3RoZXJ3aXNlLlxuICovXG5leHBvcnRzLmZyb21BcnJheSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIChhLmxlbmd0aCA9PT0gMCkgPyBuZXcgTm90aGluZygpIDogbmV3IEp1c3QoYSk7XG59O1xuLyoqXG4gKiBmcm9tT2JqZWN0IHVzZXMgT2JqZWN0LmtleXMgdG8gdHVybiBzZWUgaWYgYW4gb2JqZWN0XG4gKiBoYXMgYW55IG93biBwcm9wZXJ0aWVzLlxuICovXG5leHBvcnRzLmZyb21PYmplY3QgPSBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvKS5sZW5ndGggPT09IDAgPyBuZXcgTm90aGluZygpIDogbmV3IEp1c3Qobyk7XG59O1xuLyoqXG4gKiBmcm9tU3RyaW5nIGNvbnN0cnVjdHMgTm90aGluZzxBPiBpZiB0aGUgc3RyaW5nIGlzIGVtcHR5IG9yIEp1c3Q8QT4gb3RoZXJ3aXNlLlxuICovXG5leHBvcnRzLmZyb21TdHJpbmcgPSBmdW5jdGlvbiAocykge1xuICAgIHJldHVybiAocyA9PT0gJycpID8gbmV3IE5vdGhpbmcoKSA6IG5ldyBKdXN0KHMpO1xufTtcbi8qKlxuICogZnJvbUJvb2xlYW4gY29uc3RydWN0cyBOb3RoaW5nIGlmIGIgaXMgZmFsc2UsIEp1c3Q8QT4gb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydHMuZnJvbUJvb2xlYW4gPSBmdW5jdGlvbiAoYikge1xuICAgIHJldHVybiAoYiA9PT0gZmFsc2UpID8gbmV3IE5vdGhpbmcoKSA6IG5ldyBKdXN0KGIpO1xufTtcbi8qKlxuICogZnJvbU51bWJlciBjb25zdHJ1Y3RzIE5vdGhpbmcgaWYgbiBpcyAwIEp1c3Q8QT4gb3RoZXJ3aXNlLlxuICovXG5leHBvcnRzLmZyb21OdW1iZXIgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiAobiA9PT0gMCkgPyBuZXcgTm90aGluZygpIDogbmV3IEp1c3Qobik7XG59O1xuLyoqXG4gKiBmcm9tTmFOIGNvbnN0cnVjdHMgTm90aGluZyBpZiBhIHZhbHVlIGlzIG5vdCBhIG51bWJlciBvclxuICogSnVzdDxBPiBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydHMuZnJvbU5hTiA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIGlzTmFOKG4pID8gbmV3IE5vdGhpbmcoKSA6IG5ldyBKdXN0KG4pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1heWJlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBUaGUgcmVjb3JkIG1vZHVsZSBwcm92aWRlcyBmdW5jdGlvbnMgZm9yIHRyZWF0aW5nIEVTIG9iamVjdHMgYXMgcmVjb3Jkcy5cbiAqXG4gKiBTb21lIG9mIHRoZSBmdW5jdGlvbnMgcHJvdmlkZWQgaGVyZSBhcmUgaW5oZXJlbnRseSB1bnNhZmUgKHRzYyB3aWxsIG5vdFxuICogYmUgYWJsZSB0cmFjayBpbnRlZ3JpdHkgYW5kIG1heSByZXN1bHQgaW4gcnVudGltZSBlcnJvcnMgaWYgbm90IHVzZWQgY2FyZWZ1bGx5LlxuICovXG52YXIgYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi9hcnJheVwiKTtcbi8qKlxuICogYXNzaWduIHBvbHlmaWxsLlxuICovXG5mdW5jdGlvbiBhc3NpZ24odGFyZ2V0KSB7XG4gICAgdmFyIF92YXJBcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgX3ZhckFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIGlmICh0YXJnZXQgPT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XG4gICAgdmFyIHRvID0gT2JqZWN0KHRhcmdldCk7XG4gICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIG5leHRTb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICBpZiAobmV4dFNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBuZXh0S2V5IGluIG5leHRTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAvLyBBdm9pZCBidWdzIHdoZW4gaGFzT3duUHJvcGVydHkgaXMgc2hhZG93ZWRcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5leHRTb3VyY2UsIG5leHRLZXkpKVxuICAgICAgICAgICAgICAgICAgICB0b1tuZXh0S2V5XSA9IG5leHRTb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvO1xufVxuZXhwb3J0cy5hc3NpZ24gPSBhc3NpZ247XG4vKipcbiAqIGlzUmVjb3JkIHRlc3RzIHdoZXRoZXIgYSB2YWx1ZSBpcyBhIHJlY29yZC5cbiAqXG4gKiBUaGlzIGlzIGEgdHlwZW9mIGNoZWNrIHRoYXQgZXhjbHVkZXMgYXJyYXlzLlxuICpcbiAqIFVuc2FmZS5cbiAqL1xuZXhwb3J0cy5pc1JlY29yZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JykgJiYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSk7XG59O1xuLyoqXG4gKiBrZXlzIHByb2R1Y2VzIGEgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcyBmcm9tIGEgUmVjb3JkLlxuICovXG5leHBvcnRzLmtleXMgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKTsgfTtcbi8qKlxuICogbWFwIG92ZXIgYSBSZWNvcmQncyBwcm9wZXJ0aWVzIHByb2R1Y2luZyBhIG5ldyByZWNvcmQuXG4gKlxuICogVGhlIG9yZGVyIG9mIGtleXMgcHJvY2Vzc2VkIGlzIG5vdCBndWFyYW50ZWVkLlxuICovXG5leHBvcnRzLm1hcCA9IGZ1bmN0aW9uIChvLCBmKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMua2V5cyhvKS5yZWR1Y2UoZnVuY3Rpb24gKHAsIGspIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5tZXJnZShwLCAoX2EgPSB7fSwgX2Fba10gPSBmKG9ba10sIGssIG8pLCBfYSkpO1xuICAgIH0sIHt9KTtcbn07XG4vKipcbiAqIHJlZHVjZSBhIFJlY29yZCdzIGtleXMgdG8gYSBzaW5nbGUgdmFsdWUuXG4gKlxuICogVGhlIGluaXRpYWwgdmFsdWUgKGFjY3VtKSBtdXN0IGJlIHN1cHBsaWVkIHRvIGF2b2lkIGVycm9ycyB3aGVuXG4gKiB0aGVyZSBhcmUgbm8gcHJvcGVyaXRlcyBvbiB0aGUgUmVjb3JkLlxuICogVGhlIG9yZGVyIG9mIGtleXMgcHJvY2Vzc2VkIGlzIG5vdCBndWFyYW50ZWVkLlxuICovXG5leHBvcnRzLnJlZHVjZSA9IGZ1bmN0aW9uIChvLCBhY2N1bSwgZikge1xuICAgIHJldHVybiBleHBvcnRzLmtleXMobykucmVkdWNlKGZ1bmN0aW9uIChwLCBrKSB7IHJldHVybiBmKHAsIG9ba10sIGspOyB9LCBhY2N1bSk7XG59O1xuLyoqXG4gKiBmaWx0ZXIgdGhlIGtleXMgb2YgYSByZWNvcmQgdXNpbmcgYSBmaWx0ZXIgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydHMuZmlsdGVyID0gZnVuY3Rpb24gKG8sIGYpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5rZXlzKG8pLnJlZHVjZShmdW5jdGlvbiAocCwgaykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBmKG9ba10sIGssIG8pID8gZXhwb3J0cy5tZXJnZShwLCAoX2EgPSB7fSwgX2Fba10gPSBvW2tdLCBfYSkpIDogcDtcbiAgICB9LCB7fSk7XG59O1xuLyoqXG4gKiBtZXJnZSB0d28gb2JqZWN0cyBpbnRvIG9uZS5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlJ3MgdHlwZSBpcyB0aGUgcHJvZHVjdCBvZiB0aGUgdHdvIHR5cGVzIHN1cHBsaWVkLlxuICogVGhpcyBmdW5jdGlvbiBtYXkgYmUgdW5zYWZlLlxuICovXG5leHBvcnRzLm1lcmdlID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7IHJldHVybiBhc3NpZ24oe30sIGxlZnQsIHJpZ2h0KTsgfTtcbi8qKlxuICogbWVyZ2UzIG1lcmdlcyAzIHJlY29yZHMgaW50byBvbmUuXG4gKi9cbmV4cG9ydHMubWVyZ2UzID0gZnVuY3Rpb24gKGEsIGIsIGMpIHsgcmV0dXJuIGFzc2lnbih7fSwgYSwgYiwgYyk7IH07XG4vKipcbiAqIG1lcmdlNCBtZXJnZXMgNCByZWNvcmRzIGludG8gb25lLlxuICovXG5leHBvcnRzLm1lcmdlNCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGFzc2lnbih7fSwgYSwgYiwgYywgZCk7XG59O1xuLyoqXG4gKiBtZXJnZTUgbWVyZ2VzIDUgcmVjb3JkcyBpbnRvIG9uZS5cbiAqL1xuZXhwb3J0cy5tZXJnZTUgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgZSkgeyByZXR1cm4gYXNzaWduKHt9LCBhLCBiLCBjLCBkLCBlKTsgfTtcbi8qKlxuICogcm1lcmdlIG1lcmdlcyAyIHJlY29yZHMgcmVjdXJzaXZlbHkuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBtYXkgYmUgdW5zYWZlLlxuICovXG5leHBvcnRzLnJtZXJnZSA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiBleHBvcnRzLnJlZHVjZShyaWdodCwgbGVmdCwgZGVlcE1lcmdlKTtcbn07XG4vKipcbiAqIHJtZXJnZTMgbWVyZ2VzIDMgcmVjb3JkcyByZWN1cnNpdmVseS5cbiAqL1xuZXhwb3J0cy5ybWVyZ2UzID0gZnVuY3Rpb24gKHIsIHMsIHQpIHtcbiAgICByZXR1cm4gW3MsIHRdXG4gICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKHAsIGMpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMucmVkdWNlKGMsIChwKSwgZGVlcE1lcmdlKTtcbiAgICB9LCByKTtcbn07XG4vKipcbiAqIHJtZXJnZTQgbWVyZ2VzIDQgcmVjb3JkcyByZWN1cnNpdmVseS5cbiAqL1xuZXhwb3J0cy5ybWVyZ2U0ID0gZnVuY3Rpb24gKHIsIHMsIHQsIHUpIHtcbiAgICByZXR1cm4gW3MsIHQsIHVdXG4gICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKHAsIGMpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMucmVkdWNlKGMsIChwKSwgZGVlcE1lcmdlKTtcbiAgICB9LCByKTtcbn07XG4vKipcbiAqIHJtZXJnZTUgbWVyZ2VzIDUgcmVjb3JkcyByZWN1cnNpdmVseS5cbiAqL1xuZXhwb3J0cy5ybWVyZ2U1ID0gZnVuY3Rpb24gKHIsIHMsIHQsIHUsIHYpIHtcbiAgICByZXR1cm4gW3MsIHQsIHUsIHZdXG4gICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKHAsIGMpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMucmVkdWNlKGMsIChwKSwgZGVlcE1lcmdlKTtcbiAgICB9LCByKTtcbn07XG52YXIgZGVlcE1lcmdlID0gZnVuY3Rpb24gKHByZSwgY3Vyciwga2V5KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gZXhwb3J0cy5pc1JlY29yZChjdXJyKSA/XG4gICAgICAgIGV4cG9ydHMubWVyZ2UocHJlLCAoX2EgPSB7fSxcbiAgICAgICAgICAgIF9hW2tleV0gPSBleHBvcnRzLmlzUmVjb3JkKHByZVtrZXldKSA/XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5ybWVyZ2UocHJlW2tleV0sIGN1cnIpIDpcbiAgICAgICAgICAgICAgICBjdXJyLFxuICAgICAgICAgICAgX2EpKSA6XG4gICAgICAgIGV4cG9ydHMubWVyZ2UocHJlLCAoX2IgPSB7fSwgX2Jba2V5XSA9IGN1cnIsIF9iKSk7XG59O1xuLyoqXG4gKiBleGNsdWRlIHJlbW92ZXMgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzIGZyb20gYSBSZWNvcmQuXG4gKi9cbmV4cG9ydHMuZXhjbHVkZSA9IGZ1bmN0aW9uIChvLCBrZXlzKSB7XG4gICAgdmFyIGxpc3QgPSBBcnJheS5pc0FycmF5KGtleXMpID8ga2V5cyA6IFtrZXlzXTtcbiAgICByZXR1cm4gZXhwb3J0cy5yZWR1Y2Uobywge30sIGZ1bmN0aW9uIChwLCBjLCBrKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIGxpc3QuaW5kZXhPZihrKSA+IC0xID8gcCA6IGV4cG9ydHMubWVyZ2UocCwgKF9hID0ge30sIF9hW2tdID0gYywgX2EpKTtcbiAgICB9KTtcbn07XG4vKipcbiAqIHBhcnRpdGlvbiBhIFJlY29yZCBpbnRvIHR3byBzdWItcmVjb3JkcyB1c2luZyBhIHNlcGFyYXRpbmcgZnVuY3Rpb24uXG4gKlxuICogVGhpcyBmdW5jdGlvbiBwcm9kdWNlcyBhbiBhcnJheSB3aGVyZSB0aGUgZmlyc3QgZWxlbWVudCBpcyBhIHJlY29yZFxuICogb2YgcGFzc2luZyB2YWx1ZXMgYW5kIHRoZSBzZWNvbmQgdGhlIGZhaWxpbmcgdmFsdWVzLlxuICovXG5leHBvcnRzLnBhcnRpdGlvbiA9IGZ1bmN0aW9uIChyLCBmKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMucmVkdWNlKHIsIFt7fSwge31dLCBmdW5jdGlvbiAoX2EsIGMsIGspIHtcbiAgICAgICAgdmFyIF9iLCBfYztcbiAgICAgICAgdmFyIHllcyA9IF9hWzBdLCBubyA9IF9hWzFdO1xuICAgICAgICByZXR1cm4gZihjLCBrLCByKSA/XG4gICAgICAgICAgICBbZXhwb3J0cy5tZXJnZSh5ZXMsIChfYiA9IHt9LCBfYltrXSA9IGMsIF9iKSksIG5vXSA6XG4gICAgICAgICAgICBbeWVzLCBleHBvcnRzLm1lcmdlKG5vLCAoX2MgPSB7fSwgX2Nba10gPSBjLCBfYykpXTtcbiAgICB9KTtcbn07XG4vKipcbiAqIGdyb3VwIHRoZSBwcm9wZXJ0aWVzIG9mIGEgUmVjb3JkIGludG8gYW5vdGhlciBSZWNvcmQgdXNpbmcgYSBncm91cGluZ1xuICogZnVuY3Rpb24uXG4gKi9cbmV4cG9ydHMuZ3JvdXAgPSBmdW5jdGlvbiAociwgZikge1xuICAgIHJldHVybiBleHBvcnRzLnJlZHVjZShyLCB7fSwgZnVuY3Rpb24gKHAsIGMsIGspIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHZhciBnID0gZihjLCBrLCByKTtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMubWVyZ2UocCwgKF9hID0ge30sXG4gICAgICAgICAgICBfYVtnXSA9IGV4cG9ydHMuaXNSZWNvcmQocFtnXSkgP1xuICAgICAgICAgICAgICAgIGV4cG9ydHMubWVyZ2UocFtnXSwgKF9iID0ge30sIF9iW2tdID0gYywgX2IpKSA6IChfYyA9IHt9LCBfY1trXSA9IGMsIF9jKSxcbiAgICAgICAgICAgIF9hKSk7XG4gICAgfSk7XG59O1xuLyoqXG4gKiB2YWx1ZXMgcmV0dXJucyBhIHNoYWxsb3cgYXJyYXkgb2YgdGhlIHZhbHVlcyBvZiBhIHJlY29yZC5cbiAqL1xuZXhwb3J0cy52YWx1ZXMgPSBmdW5jdGlvbiAocikge1xuICAgIHJldHVybiBleHBvcnRzLnJlZHVjZShyLCBbXSwgZnVuY3Rpb24gKHAsIGMpIHsgcmV0dXJuIGFycmF5XzEuY29uY2F0KHAsIGMpOyB9KTtcbn07XG4vKipcbiAqIGNvbnRhaW5zIGluZGljYXRlcyB3aGV0aGVyIGEgUmVjb3JkIGhhcyBhIGdpdmVuIGtleS5cbiAqL1xuZXhwb3J0cy5jb250YWlucyA9IGZ1bmN0aW9uIChyLCBrZXkpIHtcbiAgICByZXR1cm4gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwociwga2V5KTtcbn07XG4vKipcbiAqIGNsb25lIGEgUmVjb3JkLlxuICpcbiAqIEJyZWFrcyByZWZlcmVuY2VzIGFuZCBkZWVwIGNsb25lcyBhcnJheXMuXG4gKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIHVzZWQgb24gUmVjb3JkcyBvciBvYmplY3RzIHRoYXRcbiAqIGFyZSBub3QgY2xhc3MgaW5zdGFuY2VzLlxuICovXG5leHBvcnRzLmNsb25lID0gZnVuY3Rpb24gKHIpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5yZWR1Y2Uociwge30sIGZ1bmN0aW9uIChwLCBjLCBrKSB7IHBba10gPSBfY2xvbmUoYyk7IHJldHVybiBwOyB9KTtcbn07XG52YXIgX2Nsb25lID0gZnVuY3Rpb24gKGEpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSlcbiAgICAgICAgcmV0dXJuIGEubWFwKF9jbG9uZSk7XG4gICAgZWxzZSBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5jbG9uZShhKTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBhO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBUaGlzIG1vZHVsZSBwcm92aWRlcyBhIHN5bnRheCBhbmQgYXNzb2NpYXRlZCBmdW5jdGlvbnMgZm9yXG4gKiBnZXR0aW5nIGFuZCBzZXR0aW5nIHZhbHVlcyBvbiBFUyBvYmplY3RzIGVhc2lseS5cbiAqXG4gKiBHaXZlbiBhIHBhdGgsIGEgdmFsdWUgY2FuIGVpdGhlciBiZSByZXRyaWV2ZWQgb3Igc2V0IG9uIGFuIG9iamVjdC5cbiAqXG4gKiBUaGUgcGF0aCBzeW50YXggZm9sbG93cyB0eXBpY2FsIEVTIGRvdCBub3RhdGlvbiwgYnJhY2tldCBub3RhdGlvbiBvciBhIG1peHR1cmVcbiAqIG9mIGJvdGguXG4gKlxuICogTm90ZSB0aGF0IHF1b3RlcyBhcmUgbm90IHVzZWQgd2hlbiBkZXNjcmliaW5nIGEgcGF0aCB2aWEgYnJhY2tldCBub3RhdGlvbi5cbiAqXG4gKiBJZiB5b3UgbmVlZCB0byB1c2UgYSBkb3Qgb3Igc3F1YXJlIGJyYWNrZXRzIGluIHlvdXIgcGF0aHMsIHByZWZpeCB0aGVtIHdpdGhcbiAqIHRoZSBcIlxcXCIgKGJhY2tzbGFzaCkgY2hhcmFjdGVyLlxuICovXG4vKiogaW1wb3J0cyAqKi9cbnZhciBtYXliZV8xID0gcmVxdWlyZShcIi4uL21heWJlXCIpO1xudmFyIF8xID0gcmVxdWlyZShcIi4vXCIpO1xudmFyIFRPS0VOX0RPVCA9ICcuJztcbnZhciBUT0tFTl9CUkFDS0VUX0xFRlQgPSAnWyc7XG52YXIgVE9LRU5fQlJBQ0tFVF9SSUdIVCA9ICddJztcbnZhciBUT0tFTl9FU0NBUEUgPSAnXFxcXCc7XG4vKipcbiAqIHRva2VuaXplIGEgcGF0aCBpbnRvIGEgbGlzdCBvZiBzZXF1ZW50aWFsIHByb3BlcnR5IG5hbWVzLlxuICovXG5leHBvcnRzLnRva2VuaXplID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgYnVmID0gJyc7XG4gICAgdmFyIGN1cnIgPSAnJztcbiAgICB2YXIgbmV4dCA9ICcnO1xuICAgIHZhciB0b2tlbnMgPSBbXTtcbiAgICB3aGlsZSAoaSA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgY3VyciA9IHN0cltpXTtcbiAgICAgICAgbmV4dCA9IHN0cltpICsgMV07XG4gICAgICAgIGlmIChjdXJyID09PSBUT0tFTl9FU0NBUEUpIHtcbiAgICAgICAgICAgIC8vZXNjYXBlIHNlcXVlbmNlXG4gICAgICAgICAgICBidWYgPSBcIlwiICsgYnVmICsgbmV4dDtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJyID09PSBUT0tFTl9ET1QpIHtcbiAgICAgICAgICAgIGlmIChidWYgIT09ICcnKVxuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKGJ1Zik7IC8vcmVjb2duaXplIGEgcGF0aCBhbmQgcHVzaCBhIG5ldyB0b2tlblxuICAgICAgICAgICAgYnVmID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGN1cnIgPT09IFRPS0VOX0JSQUNLRVRfTEVGVCkgJiZcbiAgICAgICAgICAgIG5leHQgPT09IFRPS0VOX0JSQUNLRVRfUklHSFQpIHtcbiAgICAgICAgICAgIC8vaW50ZXJjZXB0IGVtcHR5IGJyYWNrZXQgcGF0aHNcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJyID09PSBUT0tFTl9CUkFDS0VUX0xFRlQpIHtcbiAgICAgICAgICAgIHZhciBicmFja2V0QnVmID0gJyc7XG4gICAgICAgICAgICB2YXIgZmlyc3REb3QgPSAtMTtcbiAgICAgICAgICAgIHZhciBmaXJzdERvdEJ1ZiA9ICcnO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAvL2V2ZXJ5dGhpbmcgYmV0d2VlbiBicmFja2V0cyBpcyB0cmVhdGVkIGFzIGEgcGF0aFxuICAgICAgICAgICAgICAgIC8vaWYgbm8gY2xvc2luZyBicmFja2V0IGlzIGZvdW5kLCB3ZSBiYWNrIHRyYWNrIHRvIHRoZSBmaXJzdCBkb3RcbiAgICAgICAgICAgICAgICAvL2lmIHRoZXJlIGlzIG5vIGRvdCB0aGUgd2hvbGUgYnVmZmVyIGlzIHRyZWF0ZWQgYXMgYSBwYXRoXG4gICAgICAgICAgICAgICAgY3VyciA9IHN0cltpXTtcbiAgICAgICAgICAgICAgICBuZXh0ID0gc3RyW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoKGN1cnIgPT09IFRPS0VOX0JSQUNLRVRfUklHSFQpICYmXG4gICAgICAgICAgICAgICAgICAgIChuZXh0ID09PSBUT0tFTl9CUkFDS0VUX1JJR0hUKSkge1xuICAgICAgICAgICAgICAgICAgICAvL2VzY2FwZWQgcmlnaHQgYnJhY2tldFxuICAgICAgICAgICAgICAgICAgICBicmFja2V0QnVmID0gXCJcIiArIGJyYWNrZXRCdWYgKyBUT0tFTl9CUkFDS0VUX1JJR0hUO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1cnIgPT09IFRPS0VOX0JSQUNLRVRfUklHSFQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9zdWNjZXNzZnVsbHkgdG9rZW5pemVkIHRoZSBwYXRoXG4gICAgICAgICAgICAgICAgICAgIGlmIChidWYgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goYnVmKTsgLy9zYXZlIHRoZSBwcmV2aW91cyBwYXRoXG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKGJyYWNrZXRCdWYpOyAvL3NhdmUgdGhlIGN1cnJlbnQgcGF0aFxuICAgICAgICAgICAgICAgICAgICBidWYgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1cnIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvL25vIGNsb3NpbmcgYnJhY2tldCBmb3VuZCBhbmQgd2UgcmFuIG91dCBvZiBzdHJpbmcgdG8gc2VhcmNoXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdERvdCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYmFja3RyYWNrIHRvIHRoZSBmaXJzdCBkb3QgZW5jb3VudGVyZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBmaXJzdERvdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc2F2ZSB0aGUgcGF0aHMgc28gZmFyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaChcIlwiICsgYnVmICsgVE9LRU5fQlJBQ0tFVF9MRUZUICsgZmlyc3REb3RCdWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZWxzZSBpZiBubyBkb3RzIHdlcmUgZm91bmQgdHJlYXQgdGhlIGN1cnJlbnQgYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgcmVzdCBvZiB0aGUgc3RyaW5nIGFzIHBhcnQgb2Ygb25lIHBhdGguXG4gICAgICAgICAgICAgICAgICAgICAgICBidWYgPSBcIlwiICsgYnVmICsgVE9LRU5fQlJBQ0tFVF9MRUZUICsgYnJhY2tldEJ1ZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoY3VyciA9PT0gVE9LRU5fRE9UKSAmJiAoZmlyc3REb3QgPT09IC0xKSkge1xuICAgICAgICAgICAgICAgICAgICAvL3Rha2Ugbm90ZSBvZiB0aGUgbG9jYXRpb24gYW5kIHRva2VucyBiZXR3ZWVuIFxuICAgICAgICAgICAgICAgICAgICAvL3RoZSBvcGVuaW5nIGJyYWNrZXQgYW5kIGZpcnN0IGRvdC5cbiAgICAgICAgICAgICAgICAgICAgLy9JZiB0aGVyZSBpcyBubyBjbG9zaW5nIGJyYWNrZXQsIHdlIHVzZSB0aGlzIGluZm8gdG9cbiAgICAgICAgICAgICAgICAgICAgLy9sZXggcHJvcGVybHkuXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0RG90ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3REb3RCdWYgPSBicmFja2V0QnVmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmFja2V0QnVmID0gXCJcIiArIGJyYWNrZXRCdWYgKyBjdXJyO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZiA9IFwiXCIgKyBidWYgKyBjdXJyO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgaWYgKChidWYubGVuZ3RoID4gMCkpXG4gICAgICAgIHRva2Vucy5wdXNoKGJ1Zik7XG4gICAgcmV0dXJuIHRva2Vucztcbn07XG4vKipcbiAqIHVuc2FmZUdldCByZXRyaWV2ZXMgYSB2YWx1ZSBhdCB0aGUgc3BlY2lmaWVkIHBhdGhcbiAqIG9uIGFueSBFUyBvYmplY3QuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBjaGVjayBpZiBnZXR0aW5nIHRoZSB2YWx1ZSBzdWNjZWVkZWQgb3Igbm90LlxuICovXG5leHBvcnRzLnVuc2FmZUdldCA9IGZ1bmN0aW9uIChwYXRoLCBzcmMpIHtcbiAgICBpZiAoc3JjID09IG51bGwpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgdmFyIHRva3MgPSBleHBvcnRzLnRva2VuaXplKHBhdGgpO1xuICAgIHZhciBoZWFkID0gc3JjW3Rva3Muc2hpZnQoKV07XG4gICAgcmV0dXJuIHRva3MucmVkdWNlKGZ1bmN0aW9uIChwLCBjKSB7IHJldHVybiAocCA9PSBudWxsKSA/IHAgOiBwW2NdOyB9LCBoZWFkKTtcbn07XG4vKipcbiAqIGdldCBhIHZhbHVlIGZyb20gYSBSZWNvcmQgZ2l2ZW4gaXRzIHBhdGggc2FmZWx5LlxuICovXG5leHBvcnRzLmdldCA9IGZ1bmN0aW9uIChwYXRoLCBzcmMpIHtcbiAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUoZXhwb3J0cy51bnNhZmVHZXQocGF0aCwgc3JjKSk7XG59O1xuLyoqXG4gKiBnZXREZWZhdWx0IGlzIGxpa2UgZ2V0IGJ1dCB0YWtlcyBhIGRlZmF1bHQgdmFsdWUgdG8gcmV0dXJuIGlmXG4gKiB0aGUgcGF0aCBpcyBub3QgZm91bmQuXG4gKi9cbmV4cG9ydHMuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uIChwYXRoLCBzcmMsIGRlZikge1xuICAgIHJldHVybiBleHBvcnRzLmdldChwYXRoLCBzcmMpLm9ySnVzdChmdW5jdGlvbiAoKSB7IHJldHVybiBkZWY7IH0pLmdldCgpO1xufTtcbi8qKlxuICogZ2V0U3RyaW5nIGNhc3RzIHRoZSByZXN1bHRpbmcgdmFsdWUgdG8gYSBzdHJpbmcuXG4gKlxuICogQW4gZW1wdHkgc3RyaW5nIGlzIHByb3ZpZGVkIGlmIHRoZSBwYXRoIGlzIG5vdCBmb3VuZC5cbiAqL1xuZXhwb3J0cy5nZXRTdHJpbmcgPSBmdW5jdGlvbiAocGF0aCwgc3JjKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZ2V0KHBhdGgsIHNyYykubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBTdHJpbmcodik7IH0pLm9ySnVzdChmdW5jdGlvbiAoKSB7IHJldHVybiAnJzsgfSkuZ2V0KCk7XG59O1xuLyoqXG4gKiBzZXQgc2V0cyBhIHZhbHVlIG9uIGFuIG9iamVjdCBnaXZlbiBhIHBhdGguXG4gKi9cbmV4cG9ydHMuc2V0ID0gZnVuY3Rpb24gKHAsIHYsIHIpIHtcbiAgICB2YXIgdG9rcyA9IGV4cG9ydHMudG9rZW5pemUocCk7XG4gICAgcmV0dXJuIF9zZXQociwgdiwgdG9rcyk7XG59O1xudmFyIF9zZXQgPSBmdW5jdGlvbiAociwgdmFsdWUsIHRva3MpIHtcbiAgICB2YXIgbztcbiAgICBpZiAodG9rcy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBvID0gXzEuaXNSZWNvcmQocikgPyBfMS5jbG9uZShyKSA6IHt9O1xuICAgIG9bdG9rc1swXV0gPSBfc2V0KG9bdG9rc1swXV0sIHZhbHVlLCB0b2tzLnNsaWNlKDEpKTtcbiAgICByZXR1cm4gbztcbn07XG4vKipcbiAqIGVzY2FwZSBhIHBhdGggc28gdGhhdCBvY2N1cmVuY2VzIG9mIGRvdHMgYXJlIG5vdCBpbnRlcnByZXRlZCBhcyBwYXRocy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGVzY2FwZXMgZG90cyBhbmQgZG90cyBvbmx5LlxuICovXG5leHBvcnRzLmVzY2FwZSA9IGZ1bmN0aW9uIChwKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBidWYgPSAnJztcbiAgICB2YXIgY3VyciA9ICcnO1xuICAgIHdoaWxlIChpIDwgcC5sZW5ndGgpIHtcbiAgICAgICAgY3VyciA9IHBbaV07XG4gICAgICAgIGlmICgoY3VyciA9PT0gVE9LRU5fRVNDQVBFKSB8fCAoY3VyciA9PT0gVE9LRU5fRE9UKSlcbiAgICAgICAgICAgIGJ1ZiA9IFwiXCIgKyBidWYgKyBUT0tFTl9FU0NBUEUgKyBjdXJyO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBidWYgPSBcIlwiICsgYnVmICsgY3VycjtcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gYnVmO1xufTtcbi8qKlxuICogdW5lc2NhcGUgYSBwYXRoIHRoYXQgaGFzIGJlZW4gcHJldmlvdXNseSBlc2NhcGVkLlxuICovXG5leHBvcnRzLnVuZXNjYXBlID0gZnVuY3Rpb24gKHApIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGN1cnIgPSAnJztcbiAgICB2YXIgbmV4dCA9ICcnO1xuICAgIHZhciBidWYgPSAnJztcbiAgICB3aGlsZSAoaSA8IHAubGVuZ3RoKSB7XG4gICAgICAgIGN1cnIgPSBwW2ldO1xuICAgICAgICBuZXh0ID0gcFtpICsgMV07XG4gICAgICAgIGlmIChjdXJyID09PSBUT0tFTl9FU0NBUEUpIHtcbiAgICAgICAgICAgIGJ1ZiA9IFwiXCIgKyBidWYgKyBuZXh0O1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnVmID0gXCJcIiArIGJ1ZiArIGN1cnI7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gYnVmO1xufTtcbi8qKlxuICogZXNjYXBlUmVjb3JkIGVzY2FwZXMgZWFjaCBwcm9wZXJ0eSBvZiBhIHJlY29yZCByZWN1cnNpdmVseS5cbiAqL1xuZXhwb3J0cy5lc2NhcGVSZWNvcmQgPSBmdW5jdGlvbiAocikge1xuICAgIHJldHVybiBfMS5yZWR1Y2Uociwge30sIGZ1bmN0aW9uIChwLCBjLCBrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYyA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBwW2V4cG9ydHMuZXNjYXBlKGspXSA9IGV4cG9ydHMuZXNjYXBlUmVjb3JkKGMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBwW2V4cG9ydHMuZXNjYXBlKGspXSA9IGM7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH0pO1xufTtcbi8qKlxuICogdW5lc2NhcGVSZWNvcmQgdW5lc2NhcGVzIGVhY2ggcHJvcGVydHkgb2YgYSByZWNvcmQgcmVjdXJzaXZlbHkuXG4gKi9cbmV4cG9ydHMudW5lc2NhcGVSZWNvcmQgPSBmdW5jdGlvbiAocikge1xuICAgIHJldHVybiBfMS5yZWR1Y2Uociwge30sIGZ1bmN0aW9uIChwLCBjLCBrKSB7XG4gICAgICAgIGlmIChfMS5pc1JlY29yZChjKSlcbiAgICAgICAgICAgIHBbZXhwb3J0cy51bmVzY2FwZShrKV0gPSBleHBvcnRzLnVuZXNjYXBlUmVjb3JkKGMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBwW2V4cG9ydHMudW5lc2NhcGUoayldID0gYztcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfSk7XG59O1xuLyoqXG4gKiBmbGF0dGVuIGFuIG9iamVjdCBpbnRvIGEgUmVjb3JkIHdoZXJlIGVhY2gga2V5IGlzIGEgcGF0aCB0byBhIG5vbi1jb21wbGV4XG4gKiB2YWx1ZSBvciBhcnJheS5cbiAqXG4gKiBJZiBhbnkgb2YgdGhlIHBhdGhzIGNvbnRhaW4gZG90cywgdGhleSB3aWxsIGJlIGVzY2FwZWQuXG4gKi9cbmV4cG9ydHMuZmxhdHRlbiA9IGZ1bmN0aW9uIChyKSB7XG4gICAgcmV0dXJuIChmbGF0SW1wbCgnJykoe30pKHIpKTtcbn07XG52YXIgZmxhdEltcGwgPSBmdW5jdGlvbiAocGZpeCkgeyByZXR1cm4gZnVuY3Rpb24gKHByZXYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgcmV0dXJuIF8xLnJlZHVjZShyLCBwcmV2LCBmdW5jdGlvbiAocCwgYywgaykge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuIF8xLmlzUmVjb3JkKGMpID9cbiAgICAgICAgICAgICAgICAoZmxhdEltcGwocHJlZml4KHBmaXgsIGspKShwKShjKSkgOlxuICAgICAgICAgICAgICAgIF8xLm1lcmdlKHAsIChfYSA9IHt9LCBfYVtwcmVmaXgocGZpeCwgayldID0gYywgX2EpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn07IH07XG52YXIgcHJlZml4ID0gZnVuY3Rpb24gKHBmaXgsIGtleSkgeyByZXR1cm4gKHBmaXggPT09ICcnKSA/XG4gICAgZXhwb3J0cy5lc2NhcGUoa2V5KSA6IHBmaXggKyBcIi5cIiArIGV4cG9ydHMuZXNjYXBlKGtleSk7IH07XG4vKipcbiAqIHVuZmxhdHRlbiBhIGZsYXR0ZW5lZCBSZWNvcmQgc28gdGhhdCBhbnkgbmVzdGVkIHBhdGhzIGFyZSBleHBhbmRlZFxuICogdG8gdGhlaXIgZnVsbCByZXByZXNlbnRhdGlvbi5cbiAqL1xuZXhwb3J0cy51bmZsYXR0ZW4gPSBmdW5jdGlvbiAocikge1xuICAgIHJldHVybiBfMS5yZWR1Y2Uociwge30sIGZ1bmN0aW9uIChwLCBjLCBrKSB7IHJldHVybiBleHBvcnRzLnNldChrLCBjLCBwKTsgfSk7XG59O1xuLyoqXG4gKiBpbnRlcnNlY3Qgc2V0IG9wZXJhdGlvbiBiZXR3ZWVuIHRoZSBrZXlzIG9mIHR3byByZWNvcmRzLlxuICpcbiAqIEFsbCB0aGUgcHJvcGVydGllcyBvZiB0aGUgbGVmdCByZWNvcmQgdGhhdCBoYXZlIG1hdGNoaW5nIHByb3BlcnR5XG4gKiBuYW1lcyBpbiB0aGUgcmlnaHQgYXJlIHJldGFpbmVkLlxuICovXG5leHBvcnRzLmludGVyc2VjdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIF8xLnJlZHVjZShhLCB7fSwgZnVuY3Rpb24gKHAsIGMsIGspIHtcbiAgICAgICAgaWYgKGIuaGFzT3duUHJvcGVydHkoaykpXG4gICAgICAgICAgICBwW2tdID0gYztcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfSk7XG59O1xuLyoqXG4gKiBkaWZmZXJlbmNlIHNldCBvcGVyYXRpb24gYmV0d2VlbiB0aGUga2V5cyBvZiB0d28gcmVjb3Jkcy5cbiAqXG4gKiBBbGwgdGhlIHByb3BlcnRpZXMgb24gdGhlIGxlZnQgcmVjb3JkIHRoYXQgZG8gbm90IGhhdmUgbWF0Y2hpbmdcbiAqIHByb3BlcnR5IG5hbWVzIGluIHRoZSByaWdodCBhcmUgcmV0YWluZWQuXG4gKi9cbmV4cG9ydHMuZGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIF8xLnJlZHVjZShhLCB7fSwgZnVuY3Rpb24gKHAsIGMsIGspIHtcbiAgICAgICAgaWYgKCFiLmhhc093blByb3BlcnR5KGspKVxuICAgICAgICAgICAgcFtrXSA9IGM7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH0pO1xufTtcbi8qKlxuICogbWFwIG92ZXIgdGhlIHByb3BlcnR5IG5hbWVzIG9mIGEgcmVjb3JkLlxuICovXG5leHBvcnRzLm1hcCA9IGZ1bmN0aW9uIChhLCBmKSB7XG4gICAgcmV0dXJuIF8xLnJlZHVjZShhLCB7fSwgZnVuY3Rpb24gKHAsIGMsIGspIHtcbiAgICAgICAgcFtmKGspXSA9IGM7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH0pO1xufTtcbi8qKlxuICogcHJvamVjdCBhIFJlY29yZCBhY2NvcmRpbmcgdG8gdGhlIGZpZWxkIHNwZWNpZmljYXRpb24gZ2l2ZW4uXG4gKlxuICogT25seSBwcm9wZXJ0aWVzIHRoYXQgYXBwZWFyIGluIHRoZSBzcGVjIGFuZCBzZXQgdG8gdHJ1ZSB3aWxsIGJlIHJldGFpbmVkLlxuICogVGhpcyBmdW5jdGlvbiBpcyBub3Qgc2FmZS4gSXQgbWF5IGxlYXZlIHVuZGVmaW5lZCB2YWx1ZXMgaW4gdGhlIHJlc3VsdGluZ1xuICogcmVjb3JkLlxuICovXG5leHBvcnRzLnByb2plY3QgPSBmdW5jdGlvbiAoc3BlYywgcmVjKSB7XG4gICAgcmV0dXJuIF8xLnJlZHVjZShzcGVjLCB7fSwgZnVuY3Rpb24gKHAsIGMsIGspIHtcbiAgICAgICAgcmV0dXJuIChjID09PSB0cnVlKSA/IGV4cG9ydHMuc2V0KGssIGV4cG9ydHMudW5zYWZlR2V0KGssIHJlYyksIHApIDogcDtcbiAgICB9KTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXRoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBpc011bHRpcGxlT2YgdGVzdHMgd2hldGhlciB0aGUgSW50ZWdlciAneScgaXMgYSBtdWx0aXBsZSBvZiB4LlxuICovXG5leHBvcnRzLmlzTXVsdGlwbGVPZiA9IGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiAoKHkgJSB4KSA9PT0gMCk7IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuO1xuLyoqXG4gKiBDb21wb25lbnQgaXMgYW4gYWJzdHJhY3QgV2lkZ2V0IGltcGxlbWVudGF0aW9uXG4gKiB0aGF0IGNhbiBiZSB1c2VkIGluc3RlYWQgb2YgbWFudWFsbHkgaW1wbGVtZW50aW5nIHRoZSB3aG9sZSBpbnRlcmZhY2UuXG4gKi9cbnZhciBDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBfSBhdHRycyBpcyB0aGUgYXR0cmlidXRlcyB0aGlzIENvbXBvbmVudCBleGNlcHRzLlxuICAgICAqIEBwYXJhbSB7Q29udGVudFtdfSBjaGlsZHJlbiBpcyBhbiBhcnJheSBvZiBjb250ZW50IGZvciBDb21wb25lbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tcG9uZW50KGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB9XG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXJlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBDb21wb25lbnQucHJvdG90eXBlLnJlbW92ZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnZpZXcucmVuZGVyKCk7IH07XG4gICAgcmV0dXJuIENvbXBvbmVudDtcbn0oKSk7XG5leHBvcnRzLkNvbXBvbmVudCA9IENvbXBvbmVudDtcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8vISBtb21lbnQuanNcblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgZ2xvYmFsLm1vbWVudCA9IGZhY3RvcnkoKVxufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgaG9va0NhbGxiYWNrO1xuXG4gICAgZnVuY3Rpb24gaG9va3MgKCkge1xuICAgICAgICByZXR1cm4gaG9va0NhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBpcyBkb25lIHRvIHJlZ2lzdGVyIHRoZSBtZXRob2QgY2FsbGVkIHdpdGggbW9tZW50KClcbiAgICAvLyB3aXRob3V0IGNyZWF0aW5nIGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cbiAgICBmdW5jdGlvbiBzZXRIb29rQ2FsbGJhY2sgKGNhbGxiYWNrKSB7XG4gICAgICAgIGhvb2tDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQXJyYXkoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgQXJyYXkgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09iamVjdChpbnB1dCkge1xuICAgICAgICAvLyBJRTggd2lsbCB0cmVhdCB1bmRlZmluZWQgYW5kIG51bGwgYXMgb2JqZWN0IGlmIGl0IHdhc24ndCBmb3JcbiAgICAgICAgLy8gaW5wdXQgIT0gbnVsbFxuICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBPYmplY3RdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09iamVjdEVtcHR5KG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMpIHtcbiAgICAgICAgICAgIHJldHVybiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5sZW5ndGggPT09IDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGs7XG4gICAgICAgICAgICBmb3IgKGsgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZChpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT09IHZvaWQgMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc051bWJlcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJyB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBOdW1iZXJdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RhdGUoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgRGF0ZSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBEYXRlXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFwKGFyciwgZm4pIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdLCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXMucHVzaChmbihhcnJbaV0sIGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc093blByb3AoYSwgYikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gYikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoYiwgaSkpIHtcbiAgICAgICAgICAgICAgICBhW2ldID0gYltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd0b1N0cmluZycpKSB7XG4gICAgICAgICAgICBhLnRvU3RyaW5nID0gYi50b1N0cmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd2YWx1ZU9mJykpIHtcbiAgICAgICAgICAgIGEudmFsdWVPZiA9IGIudmFsdWVPZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVUQyAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIHRydWUpLnV0YygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRQYXJzaW5nRmxhZ3MoKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZGVlcCBjbG9uZSB0aGlzIG9iamVjdC5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVtcHR5ICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgdW51c2VkVG9rZW5zICAgIDogW10sXG4gICAgICAgICAgICB1bnVzZWRJbnB1dCAgICAgOiBbXSxcbiAgICAgICAgICAgIG92ZXJmbG93ICAgICAgICA6IC0yLFxuICAgICAgICAgICAgY2hhcnNMZWZ0T3ZlciAgIDogMCxcbiAgICAgICAgICAgIG51bGxJbnB1dCAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgaW52YWxpZE1vbnRoICAgIDogbnVsbCxcbiAgICAgICAgICAgIGludmFsaWRGb3JtYXQgICA6IGZhbHNlLFxuICAgICAgICAgICAgdXNlckludmFsaWRhdGVkIDogZmFsc2UsXG4gICAgICAgICAgICBpc28gICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHBhcnNlZERhdGVQYXJ0cyA6IFtdLFxuICAgICAgICAgICAgbWVyaWRpZW0gICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgIHJmYzI4MjIgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgd2Vla2RheU1pc21hdGNoIDogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzaW5nRmxhZ3MobSkge1xuICAgICAgICBpZiAobS5fcGYgPT0gbnVsbCkge1xuICAgICAgICAgICAgbS5fcGYgPSBkZWZhdWx0UGFyc2luZ0ZsYWdzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0uX3BmO1xuICAgIH1cblxuICAgIHZhciBzb21lO1xuICAgIGlmIChBcnJheS5wcm90b3R5cGUuc29tZSkge1xuICAgICAgICBzb21lID0gQXJyYXkucHJvdG90eXBlLnNvbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc29tZSA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICAgICAgICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gdCAmJiBmdW4uY2FsbCh0aGlzLCB0W2ldLCBpLCB0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkKG0pIHtcbiAgICAgICAgaWYgKG0uX2lzVmFsaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGZsYWdzID0gZ2V0UGFyc2luZ0ZsYWdzKG0pO1xuICAgICAgICAgICAgdmFyIHBhcnNlZFBhcnRzID0gc29tZS5jYWxsKGZsYWdzLnBhcnNlZERhdGVQYXJ0cywgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaSAhPSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgaXNOb3dWYWxpZCA9ICFpc05hTihtLl9kLmdldFRpbWUoKSkgJiZcbiAgICAgICAgICAgICAgICBmbGFncy5vdmVyZmxvdyA8IDAgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuZW1wdHkgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZE1vbnRoICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRXZWVrZGF5ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLndlZWtkYXlNaXNtYXRjaCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5udWxsSW5wdXQgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZEZvcm1hdCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy51c2VySW52YWxpZGF0ZWQgJiZcbiAgICAgICAgICAgICAgICAoIWZsYWdzLm1lcmlkaWVtIHx8IChmbGFncy5tZXJpZGllbSAmJiBwYXJzZWRQYXJ0cykpO1xuXG4gICAgICAgICAgICBpZiAobS5fc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgaXNOb3dWYWxpZCA9IGlzTm93VmFsaWQgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuY2hhcnNMZWZ0T3ZlciA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy51bnVzZWRUb2tlbnMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmJpZ0hvdXIgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5pc0Zyb3plbiA9PSBudWxsIHx8ICFPYmplY3QuaXNGcm96ZW4obSkpIHtcbiAgICAgICAgICAgICAgICBtLl9pc1ZhbGlkID0gaXNOb3dWYWxpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc05vd1ZhbGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9pc1ZhbGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmFsaWQgKGZsYWdzKSB7XG4gICAgICAgIHZhciBtID0gY3JlYXRlVVRDKE5hTik7XG4gICAgICAgIGlmIChmbGFncyAhPSBudWxsKSB7XG4gICAgICAgICAgICBleHRlbmQoZ2V0UGFyc2luZ0ZsYWdzKG0pLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkudXNlckludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cblxuICAgIC8vIFBsdWdpbnMgdGhhdCBhZGQgcHJvcGVydGllcyBzaG91bGQgYWxzbyBhZGQgdGhlIGtleSBoZXJlIChudWxsIHZhbHVlKSxcbiAgICAvLyBzbyB3ZSBjYW4gcHJvcGVybHkgY2xvbmUgb3Vyc2VsdmVzLlxuICAgIHZhciBtb21lbnRQcm9wZXJ0aWVzID0gaG9va3MubW9tZW50UHJvcGVydGllcyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gY29weUNvbmZpZyh0bywgZnJvbSkge1xuICAgICAgICB2YXIgaSwgcHJvcCwgdmFsO1xuXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNBTW9tZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgdG8uX2lzQU1vbWVudE9iamVjdCA9IGZyb20uX2lzQU1vbWVudE9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2kpKSB7XG4gICAgICAgICAgICB0by5faSA9IGZyb20uX2k7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9mKSkge1xuICAgICAgICAgICAgdG8uX2YgPSBmcm9tLl9mO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbCkpIHtcbiAgICAgICAgICAgIHRvLl9sID0gZnJvbS5fbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3N0cmljdCkpIHtcbiAgICAgICAgICAgIHRvLl9zdHJpY3QgPSBmcm9tLl9zdHJpY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl90em0pKSB7XG4gICAgICAgICAgICB0by5fdHptID0gZnJvbS5fdHptO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNVVEMpKSB7XG4gICAgICAgICAgICB0by5faXNVVEMgPSBmcm9tLl9pc1VUQztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX29mZnNldCkpIHtcbiAgICAgICAgICAgIHRvLl9vZmZzZXQgPSBmcm9tLl9vZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9wZikpIHtcbiAgICAgICAgICAgIHRvLl9wZiA9IGdldFBhcnNpbmdGbGFncyhmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2xvY2FsZSkpIHtcbiAgICAgICAgICAgIHRvLl9sb2NhbGUgPSBmcm9tLl9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9tZW50UHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbW9tZW50UHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHByb3AgPSBtb21lbnRQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgICAgIHZhbCA9IGZyb21bcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgLy8gTW9tZW50IHByb3RvdHlwZSBvYmplY3RcbiAgICBmdW5jdGlvbiBNb21lbnQoY29uZmlnKSB7XG4gICAgICAgIGNvcHlDb25maWcodGhpcywgY29uZmlnKTtcbiAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5fZCAhPSBudWxsID8gY29uZmlnLl9kLmdldFRpbWUoKSA6IE5hTik7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcCBpbiBjYXNlIHVwZGF0ZU9mZnNldCBjcmVhdGVzIG5ldyBtb21lbnRcbiAgICAgICAgLy8gb2JqZWN0cy5cbiAgICAgICAgaWYgKHVwZGF0ZUluUHJvZ3Jlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTW9tZW50IChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE1vbWVudCB8fCAob2JqICE9IG51bGwgJiYgb2JqLl9pc0FNb21lbnRPYmplY3QgIT0gbnVsbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzRmxvb3IgKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgLy8gLTAgLT4gMFxuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpIHx8IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JbnQoYXJndW1lbnRGb3JDb2VyY2lvbikge1xuICAgICAgICB2YXIgY29lcmNlZE51bWJlciA9ICthcmd1bWVudEZvckNvZXJjaW9uLFxuICAgICAgICAgICAgdmFsdWUgPSAwO1xuXG4gICAgICAgIGlmIChjb2VyY2VkTnVtYmVyICE9PSAwICYmIGlzRmluaXRlKGNvZXJjZWROdW1iZXIpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGFic0Zsb29yKGNvZXJjZWROdW1iZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8vIGNvbXBhcmUgdHdvIGFycmF5cywgcmV0dXJuIHRoZSBudW1iZXIgb2YgZGlmZmVyZW5jZXNcbiAgICBmdW5jdGlvbiBjb21wYXJlQXJyYXlzKGFycmF5MSwgYXJyYXkyLCBkb250Q29udmVydCkge1xuICAgICAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJyYXkxLmxlbmd0aCwgYXJyYXkyLmxlbmd0aCksXG4gICAgICAgICAgICBsZW5ndGhEaWZmID0gTWF0aC5hYnMoYXJyYXkxLmxlbmd0aCAtIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgZGlmZnMgPSAwLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKGRvbnRDb252ZXJ0ICYmIGFycmF5MVtpXSAhPT0gYXJyYXkyW2ldKSB8fFxuICAgICAgICAgICAgICAgICghZG9udENvbnZlcnQgJiYgdG9JbnQoYXJyYXkxW2ldKSAhPT0gdG9JbnQoYXJyYXkyW2ldKSkpIHtcbiAgICAgICAgICAgICAgICBkaWZmcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWZmcyArIGxlbmd0aERpZmY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICAgICAgaWYgKGhvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIGNvbnNvbGUgIT09ICAndW5kZWZpbmVkJykgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIHdhcm5pbmc6ICcgKyBtc2cpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlKG1zZywgZm4pIHtcbiAgICAgICAgdmFyIGZpcnN0VGltZSA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobnVsbCwgbXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBhcmc7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnICs9ICdcXG5bJyArIGkgKyAnXSAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGFyZ3VtZW50c1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArPSBrZXkgKyAnOiAnICsgYXJndW1lbnRzWzBdW2tleV0gKyAnLCAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKDAsIC0yKTsgLy8gUmVtb3ZlIHRyYWlsaW5nIGNvbW1hIGFuZCBzcGFjZVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChhcmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3YXJuKG1zZyArICdcXG5Bcmd1bWVudHM6ICcgKyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKS5qb2luKCcnKSArICdcXG4nICsgKG5ldyBFcnJvcigpKS5zdGFjayk7XG4gICAgICAgICAgICAgICAgZmlyc3RUaW1lID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSwgZm4pO1xuICAgIH1cblxuICAgIHZhciBkZXByZWNhdGlvbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCBtc2cpIHtcbiAgICAgICAgaWYgKGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobmFtZSwgbXNnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlcHJlY2F0aW9uc1tuYW1lXSkge1xuICAgICAgICAgICAgd2Fybihtc2cpO1xuICAgICAgICAgICAgZGVwcmVjYXRpb25zW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9IGZhbHNlO1xuICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0IChjb25maWcpIHtcbiAgICAgICAgdmFyIHByb3AsIGk7XG4gICAgICAgIGZvciAoaSBpbiBjb25maWcpIHtcbiAgICAgICAgICAgIHByb3AgPSBjb25maWdbaV07XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihwcm9wKSkge1xuICAgICAgICAgICAgICAgIHRoaXNbaV0gPSBwcm9wO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzWydfJyArIGldID0gcHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgICAgIC8vIExlbmllbnQgb3JkaW5hbCBwYXJzaW5nIGFjY2VwdHMganVzdCBhIG51bWJlciBpbiBhZGRpdGlvbiB0b1xuICAgICAgICAvLyBudW1iZXIgKyAocG9zc2libHkpIHN0dWZmIGNvbWluZyBmcm9tIF9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlLlxuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgICAgIHRoaXMuX2RheU9mTW9udGhPcmRpbmFsUGFyc2VMZW5pZW50ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICh0aGlzLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlLnNvdXJjZSB8fCB0aGlzLl9vcmRpbmFsUGFyc2Uuc291cmNlKSArXG4gICAgICAgICAgICAgICAgJ3wnICsgKC9cXGR7MSwyfS8pLnNvdXJjZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY2hpbGRDb25maWcpIHtcbiAgICAgICAgdmFyIHJlcyA9IGV4dGVuZCh7fSwgcGFyZW50Q29uZmlnKSwgcHJvcDtcbiAgICAgICAgZm9yIChwcm9wIGluIGNoaWxkQ29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSAmJiBpc09iamVjdChjaGlsZENvbmZpZ1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0ge307XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIHBhcmVudENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIGNoaWxkQ29uZmlnW3Byb3BdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkQ29uZmlnW3Byb3BdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gY2hpbGRDb25maWdbcHJvcF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc1twcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChwcm9wIGluIHBhcmVudENvbmZpZykge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AocGFyZW50Q29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgICAgICAhaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBjaGFuZ2VzIHRvIHByb3BlcnRpZXMgZG9uJ3QgbW9kaWZ5IHBhcmVudCBjb25maWdcbiAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSBleHRlbmQoe30sIHJlc1twcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMb2NhbGUoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zZXQoY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXlzO1xuXG4gICAgaWYgKE9iamVjdC5rZXlzKSB7XG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cztcbiAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgdmFyIGksIHJlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKG9iaiwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdENhbGVuZGFyID0ge1xuICAgICAgICBzYW1lRGF5IDogJ1tUb2RheSBhdF0gTFQnLFxuICAgICAgICBuZXh0RGF5IDogJ1tUb21vcnJvdyBhdF0gTFQnLFxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFthdF0gTFQnLFxuICAgICAgICBsYXN0RGF5IDogJ1tZZXN0ZXJkYXkgYXRdIExUJyxcbiAgICAgICAgbGFzdFdlZWsgOiAnW0xhc3RdIGRkZGQgW2F0XSBMVCcsXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNhbGVuZGFyIChrZXksIG1vbSwgbm93KSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9jYWxlbmRhcltrZXldIHx8IHRoaXMuX2NhbGVuZGFyWydzYW1lRWxzZSddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihvdXRwdXQpID8gb3V0cHV0LmNhbGwobW9tLCBub3cpIDogb3V0cHV0O1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQgPSB7XG4gICAgICAgIExUUyAgOiAnaDptbTpzcyBBJyxcbiAgICAgICAgTFQgICA6ICdoOm1tIEEnLFxuICAgICAgICBMICAgIDogJ01NL0REL1lZWVknLFxuICAgICAgICBMTCAgIDogJ01NTU0gRCwgWVlZWScsXG4gICAgICAgIExMTCAgOiAnTU1NTSBELCBZWVlZIGg6bW0gQScsXG4gICAgICAgIExMTEwgOiAnZGRkZCwgTU1NTSBELCBZWVlZIGg6bW0gQSdcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9uZ0RhdGVGb3JtYXQgKGtleSkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSxcbiAgICAgICAgICAgIGZvcm1hdFVwcGVyID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5LnRvVXBwZXJDYXNlKCldO1xuXG4gICAgICAgIGlmIChmb3JtYXQgfHwgIWZvcm1hdFVwcGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSA9IGZvcm1hdFVwcGVyLnJlcGxhY2UoL01NTU18TU18RER8ZGRkZC9nLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsLnNsaWNlKDEpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdEludmFsaWREYXRlID0gJ0ludmFsaWQgZGF0ZSc7XG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkRGF0ZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZhbGlkRGF0ZTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE9yZGluYWwgPSAnJWQnO1xuICAgIHZhciBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSA9IC9cXGR7MSwyfS87XG5cbiAgICBmdW5jdGlvbiBvcmRpbmFsIChudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yZGluYWwucmVwbGFjZSgnJWQnLCBudW1iZXIpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0UmVsYXRpdmVUaW1lID0ge1xuICAgICAgICBmdXR1cmUgOiAnaW4gJXMnLFxuICAgICAgICBwYXN0ICAgOiAnJXMgYWdvJyxcbiAgICAgICAgcyAgOiAnYSBmZXcgc2Vjb25kcycsXG4gICAgICAgIHNzIDogJyVkIHNlY29uZHMnLFxuICAgICAgICBtICA6ICdhIG1pbnV0ZScsXG4gICAgICAgIG1tIDogJyVkIG1pbnV0ZXMnLFxuICAgICAgICBoICA6ICdhbiBob3VyJyxcbiAgICAgICAgaGggOiAnJWQgaG91cnMnLFxuICAgICAgICBkICA6ICdhIGRheScsXG4gICAgICAgIGRkIDogJyVkIGRheXMnLFxuICAgICAgICBNICA6ICdhIG1vbnRoJyxcbiAgICAgICAgTU0gOiAnJWQgbW9udGhzJyxcbiAgICAgICAgeSAgOiAnYSB5ZWFyJyxcbiAgICAgICAgeXkgOiAnJWQgeWVhcnMnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlbGF0aXZlVGltZSAobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbc3RyaW5nXTtcbiAgICAgICAgcmV0dXJuIChpc0Z1bmN0aW9uKG91dHB1dCkpID9cbiAgICAgICAgICAgIG91dHB1dChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIDpcbiAgICAgICAgICAgIG91dHB1dC5yZXBsYWNlKC8lZC9pLCBudW1iZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhc3RGdXR1cmUgKGRpZmYsIG91dHB1dCkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW2RpZmYgPiAwID8gJ2Z1dHVyZScgOiAncGFzdCddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihmb3JtYXQpID8gZm9ybWF0KG91dHB1dCkgOiBmb3JtYXQucmVwbGFjZSgvJXMvaSwgb3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgYWxpYXNlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkVW5pdEFsaWFzICh1bml0LCBzaG9ydGhhbmQpIHtcbiAgICAgICAgdmFyIGxvd2VyQ2FzZSA9IHVuaXQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgYWxpYXNlc1tsb3dlckNhc2VdID0gYWxpYXNlc1tsb3dlckNhc2UgKyAncyddID0gYWxpYXNlc1tzaG9ydGhhbmRdID0gdW5pdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVVbml0cyh1bml0cykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHVuaXRzID09PSAnc3RyaW5nJyA/IGFsaWFzZXNbdW5pdHNdIHx8IGFsaWFzZXNbdW5pdHMudG9Mb3dlckNhc2UoKV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplT2JqZWN0VW5pdHMoaW5wdXRPYmplY3QpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IHt9LFxuICAgICAgICAgICAgbm9ybWFsaXplZFByb3AsXG4gICAgICAgICAgICBwcm9wO1xuXG4gICAgICAgIGZvciAocHJvcCBpbiBpbnB1dE9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoaW5wdXRPYmplY3QsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFByb3AgPSBub3JtYWxpemVVbml0cyhwcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZFByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZElucHV0W25vcm1hbGl6ZWRQcm9wXSA9IGlucHV0T2JqZWN0W3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkSW5wdXQ7XG4gICAgfVxuXG4gICAgdmFyIHByaW9yaXRpZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFVuaXRQcmlvcml0eSh1bml0LCBwcmlvcml0eSkge1xuICAgICAgICBwcmlvcml0aWVzW3VuaXRdID0gcHJpb3JpdHk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UHJpb3JpdGl6ZWRVbml0cyh1bml0c09iaikge1xuICAgICAgICB2YXIgdW5pdHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgdSBpbiB1bml0c09iaikge1xuICAgICAgICAgICAgdW5pdHMucHVzaCh7dW5pdDogdSwgcHJpb3JpdHk6IHByaW9yaXRpZXNbdV19KTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdW5pdHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gemVyb0ZpbGwobnVtYmVyLCB0YXJnZXRMZW5ndGgsIGZvcmNlU2lnbikge1xuICAgICAgICB2YXIgYWJzTnVtYmVyID0gJycgKyBNYXRoLmFicyhudW1iZXIpLFxuICAgICAgICAgICAgemVyb3NUb0ZpbGwgPSB0YXJnZXRMZW5ndGggLSBhYnNOdW1iZXIubGVuZ3RoLFxuICAgICAgICAgICAgc2lnbiA9IG51bWJlciA+PSAwO1xuICAgICAgICByZXR1cm4gKHNpZ24gPyAoZm9yY2VTaWduID8gJysnIDogJycpIDogJy0nKSArXG4gICAgICAgICAgICBNYXRoLnBvdygxMCwgTWF0aC5tYXgoMCwgemVyb3NUb0ZpbGwpKS50b1N0cmluZygpLnN1YnN0cigxKSArIGFic051bWJlcjtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhbSGhdbW0oc3MpP3xNb3xNTT9NP00/fERvfERERG98REQ/RD9EP3xkZGQ/ZD98ZG8/fHdbb3x3XT98V1tvfFddP3xRbz98WVlZWVlZfFlZWVlZfFlZWVl8WVl8Z2coZ2dnPyk/fEdHKEdHRz8pP3xlfEV8YXxBfGhoP3xISD98a2s/fG1tP3xzcz98U3sxLDl9fHh8WHx6ej98Wlo/fC4pL2c7XG5cbiAgICB2YXIgbG9jYWxGb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KExUU3xMVHxMTD9MP0w/fGx7MSw0fSkvZztcblxuICAgIHZhciBmb3JtYXRGdW5jdGlvbnMgPSB7fTtcblxuICAgIHZhciBmb3JtYXRUb2tlbkZ1bmN0aW9ucyA9IHt9O1xuXG4gICAgLy8gdG9rZW46ICAgICdNJ1xuICAgIC8vIHBhZGRlZDogICBbJ01NJywgMl1cbiAgICAvLyBvcmRpbmFsOiAgJ01vJ1xuICAgIC8vIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7IHRoaXMubW9udGgoKSArIDEgfVxuICAgIGZ1bmN0aW9uIGFkZEZvcm1hdFRva2VuICh0b2tlbiwgcGFkZGVkLCBvcmRpbmFsLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tjYWxsYmFja10oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWRkZWQpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3BhZGRlZFswXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHplcm9GaWxsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgcGFkZGVkWzFdLCBwYWRkZWRbMl0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JkaW5hbCkge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbb3JkaW5hbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm9yZGluYWwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0b2tlbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQubWF0Y2goL1xcW1tcXHNcXFNdLykpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9eXFxbfFxcXSQvZywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgIHZhciBhcnJheSA9IGZvcm1hdC5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSwgaSwgbGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSBmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhhcnJheVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1vbSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9ICcnLCBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGlzRnVuY3Rpb24oYXJyYXlbaV0pID8gYXJyYXlbaV0uY2FsbChtb20sIGZvcm1hdCkgOiBhcnJheVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gZm9ybWF0IGRhdGUgdXNpbmcgbmF0aXZlIGRhdGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gZm9ybWF0TW9tZW50KG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbS5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGV4cGFuZEZvcm1hdChmb3JtYXQsIG0ubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gPSBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSB8fCBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KTtcblxuICAgICAgICByZXR1cm4gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0obSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBpID0gNTtcblxuICAgICAgICBmdW5jdGlvbiByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubG9uZ0RhdGVGb3JtYXQoaW5wdXQpIHx8IGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChpID49IDAgJiYgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLnRlc3QoZm9ybWF0KSkge1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UobG9jYWxGb3JtYXR0aW5nVG9rZW5zLCByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMpO1xuICAgICAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICBpIC09IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH1cblxuICAgIHZhciBtYXRjaDEgICAgICAgICA9IC9cXGQvOyAgICAgICAgICAgIC8vICAgICAgIDAgLSA5XG4gICAgdmFyIG1hdGNoMiAgICAgICAgID0gL1xcZFxcZC87ICAgICAgICAgIC8vICAgICAgMDAgLSA5OVxuICAgIHZhciBtYXRjaDMgICAgICAgICA9IC9cXGR7M30vOyAgICAgICAgIC8vICAgICAwMDAgLSA5OTlcbiAgICB2YXIgbWF0Y2g0ICAgICAgICAgPSAvXFxkezR9LzsgICAgICAgICAvLyAgICAwMDAwIC0gOTk5OVxuICAgIHZhciBtYXRjaDYgICAgICAgICA9IC9bKy1dP1xcZHs2fS87ICAgIC8vIC05OTk5OTkgLSA5OTk5OTlcbiAgICB2YXIgbWF0Y2gxdG8yICAgICAgPSAvXFxkXFxkPy87ICAgICAgICAgLy8gICAgICAgMCAtIDk5XG4gICAgdmFyIG1hdGNoM3RvNCAgICAgID0gL1xcZFxcZFxcZFxcZD8vOyAgICAgLy8gICAgIDk5OSAtIDk5OTlcbiAgICB2YXIgbWF0Y2g1dG82ICAgICAgPSAvXFxkXFxkXFxkXFxkXFxkXFxkPy87IC8vICAgOTk5OTkgLSA5OTk5OTlcbiAgICB2YXIgbWF0Y2gxdG8zICAgICAgPSAvXFxkezEsM30vOyAgICAgICAvLyAgICAgICAwIC0gOTk5XG4gICAgdmFyIG1hdGNoMXRvNCAgICAgID0gL1xcZHsxLDR9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OTlcbiAgICB2YXIgbWF0Y2gxdG82ICAgICAgPSAvWystXT9cXGR7MSw2fS87ICAvLyAtOTk5OTk5IC0gOTk5OTk5XG5cbiAgICB2YXIgbWF0Y2hVbnNpZ25lZCAgPSAvXFxkKy87ICAgICAgICAgICAvLyAgICAgICAwIC0gaW5mXG4gICAgdmFyIG1hdGNoU2lnbmVkICAgID0gL1srLV0/XFxkKy87ICAgICAgLy8gICAgLWluZiAtIGluZlxuXG4gICAgdmFyIG1hdGNoT2Zmc2V0ICAgID0gL1p8WystXVxcZFxcZDo/XFxkXFxkL2dpOyAvLyArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcbiAgICB2YXIgbWF0Y2hTaG9ydE9mZnNldCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/L2dpOyAvLyArMDAgLTAwICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxuXG4gICAgdmFyIG1hdGNoVGltZXN0YW1wID0gL1srLV0/XFxkKyhcXC5cXGR7MSwzfSk/LzsgLy8gMTIzNDU2Nzg5IDEyMzQ1Njc4OS4xMjNcblxuICAgIC8vIGFueSB3b3JkIChvciB0d28pIGNoYXJhY3RlcnMgb3IgbnVtYmVycyBpbmNsdWRpbmcgdHdvL3RocmVlIHdvcmQgbW9udGggaW4gYXJhYmljLlxuICAgIC8vIGluY2x1ZGVzIHNjb3R0aXNoIGdhZWxpYyB0d28gd29yZCBhbmQgaHlwaGVuYXRlZCBtb250aHNcbiAgICB2YXIgbWF0Y2hXb3JkID0gL1swLTldezAsMjU2fVsnYS16XFx1MDBBMC1cXHUwNUZGXFx1MDcwMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRjA3XFx1RkYxMC1cXHVGRkVGXXsxLDI1Nn18W1xcdTA2MDAtXFx1MDZGRlxcL117MSwyNTZ9KFxccyo/W1xcdTA2MDAtXFx1MDZGRl17MSwyNTZ9KXsxLDJ9L2k7XG5cbiAgICB2YXIgcmVnZXhlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkUmVnZXhUb2tlbiAodG9rZW4sIHJlZ2V4LCBzdHJpY3RSZWdleCkge1xuICAgICAgICByZWdleGVzW3Rva2VuXSA9IGlzRnVuY3Rpb24ocmVnZXgpID8gcmVnZXggOiBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZURhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiAoaXNTdHJpY3QgJiYgc3RyaWN0UmVnZXgpID8gc3RyaWN0UmVnZXggOiByZWdleDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4gKHRva2VuLCBjb25maWcpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHJlZ2V4ZXMsIHRva2VuKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodW5lc2NhcGVGb3JtYXQodG9rZW4pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWdleGVzW3Rva2VuXShjb25maWcuX3N0cmljdCwgY29uZmlnLl9sb2NhbGUpO1xuICAgIH1cblxuICAgIC8vIENvZGUgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM1NjE0OTMvaXMtdGhlcmUtYS1yZWdleHAtZXNjYXBlLWZ1bmN0aW9uLWluLWphdmFzY3JpcHRcbiAgICBmdW5jdGlvbiB1bmVzY2FwZUZvcm1hdChzKSB7XG4gICAgICAgIHJldHVybiByZWdleEVzY2FwZShzLnJlcGxhY2UoJ1xcXFwnLCAnJykucmVwbGFjZSgvXFxcXChcXFspfFxcXFwoXFxdKXxcXFsoW15cXF1cXFtdKilcXF18XFxcXCguKS9nLCBmdW5jdGlvbiAobWF0Y2hlZCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgICAgIHJldHVybiBwMSB8fCBwMiB8fCBwMyB8fCBwNDtcbiAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZ2V4RXNjYXBlKHMpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG4gICAgfVxuXG4gICAgdmFyIHRva2VucyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBpLCBmdW5jID0gY2FsbGJhY2s7XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0b2tlbiA9IFt0b2tlbl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTnVtYmVyKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgICAgICAgICBhcnJheVtjYWxsYmFja10gPSB0b0ludChpbnB1dCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuW2ldXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgICAgIGNvbmZpZy5fdyA9IGNvbmZpZy5fdyB8fCB7fTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGlucHV0LCBjb25maWcuX3csIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgaW5wdXQsIGNvbmZpZykge1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCAmJiBoYXNPd25Qcm9wKHRva2VucywgdG9rZW4pKSB7XG4gICAgICAgICAgICB0b2tlbnNbdG9rZW5dKGlucHV0LCBjb25maWcuX2EsIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFlFQVIgPSAwO1xuICAgIHZhciBNT05USCA9IDE7XG4gICAgdmFyIERBVEUgPSAyO1xuICAgIHZhciBIT1VSID0gMztcbiAgICB2YXIgTUlOVVRFID0gNDtcbiAgICB2YXIgU0VDT05EID0gNTtcbiAgICB2YXIgTUlMTElTRUNPTkQgPSA2O1xuICAgIHZhciBXRUVLID0gNztcbiAgICB2YXIgV0VFS0RBWSA9IDg7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignWScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnllYXIoKTtcbiAgICAgICAgcmV0dXJuIHkgPD0gOTk5OSA/ICcnICsgeSA6ICcrJyArIHk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZJywgICA0XSwgICAgICAgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZJywgIDVdLCAgICAgICAwLCAneWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVlZJywgNiwgdHJ1ZV0sIDAsICd5ZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3llYXInLCAneScpO1xuXG4gICAgLy8gUFJJT1JJVElFU1xuXG4gICAgYWRkVW5pdFByaW9yaXR5KCd5ZWFyJywgMSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdZJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWVknLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVknLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWScsICBtYXRjaDF0bzYsIG1hdGNoNik7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWVlZJywgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ1lZWVlZJywgJ1lZWVlZWSddLCBZRUFSKTtcbiAgICBhZGRQYXJzZVRva2VuKCdZWVlZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IGlucHV0Lmxlbmd0aCA9PT0gMiA/IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KSA6IHRvSW50KGlucHV0KTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBwYXJzZUludChpbnB1dCwgMTApO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gZGF5c0luWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHllYXIpID8gMzY2IDogMzY1O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4gKHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDApIHx8IHllYXIgJSA0MDAgPT09IDA7XG4gICAgfVxuXG4gICAgLy8gSE9PS1NcblxuICAgIGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0b0ludChpbnB1dCkgKyAodG9JbnQoaW5wdXQpID4gNjggPyAxOTAwIDogMjAwMCk7XG4gICAgfTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRZZWFyID0gbWFrZUdldFNldCgnRnVsbFllYXInLCB0cnVlKTtcblxuICAgIGZ1bmN0aW9uIGdldElzTGVhcFllYXIgKCkge1xuICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih0aGlzLnllYXIoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldFNldCAodW5pdCwga2VlcFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZXQkMSh0aGlzLCB1bml0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIGtlZXBUaW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldCh0aGlzLCB1bml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXQgKG1vbSwgdW5pdCkge1xuICAgICAgICByZXR1cm4gbW9tLmlzVmFsaWQoKSA/XG4gICAgICAgICAgICBtb20uX2RbJ2dldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oKSA6IE5hTjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXQkMSAobW9tLCB1bml0LCB2YWx1ZSkge1xuICAgICAgICBpZiAobW9tLmlzVmFsaWQoKSAmJiAhaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAodW5pdCA9PT0gJ0Z1bGxZZWFyJyAmJiBpc0xlYXBZZWFyKG1vbS55ZWFyKCkpICYmIG1vbS5tb250aCgpID09PSAxICYmIG1vbS5kYXRlKCkgPT09IDI5KSB7XG4gICAgICAgICAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlLCBtb20ubW9udGgoKSwgZGF5c0luTW9udGgodmFsdWUsIG1vbS5tb250aCgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gc3RyaW5nR2V0ICh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHN0cmluZ1NldCAodW5pdHMsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdW5pdHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIHZhciBwcmlvcml0aXplZCA9IGdldFByaW9yaXRpemVkVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmlvcml0aXplZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXNbcHJpb3JpdGl6ZWRbaV0udW5pdF0odW5pdHNbcHJpb3JpdGl6ZWRbaV0udW5pdF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vZChuLCB4KSB7XG4gICAgICAgIHJldHVybiAoKG4gJSB4KSArIHgpICUgeDtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXhPZjtcblxuICAgIGlmIChBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuICAgICAgICBpbmRleE9mID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2Y7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXhPZiA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICAvLyBJIGtub3dcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpc1tpXSA9PT0gbykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c0luTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICAgICAgaWYgKGlzTmFOKHllYXIpIHx8IGlzTmFOKG1vbnRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbW9kTW9udGggPSBtb2QobW9udGgsIDEyKTtcbiAgICAgICAgeWVhciArPSAobW9udGggLSBtb2RNb250aCkgLyAxMjtcbiAgICAgICAgcmV0dXJuIG1vZE1vbnRoID09PSAxID8gKGlzTGVhcFllYXIoeWVhcikgPyAyOSA6IDI4KSA6ICgzMSAtIG1vZE1vbnRoICUgNyAlIDIpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNJywgWydNTScsIDJdLCAnTW8nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vbnRoKCkgKyAxO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRoc1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignTU1NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRocyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtb250aCcsICdNJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdtb250aCcsIDgpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignTScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignTU0nLCAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU0nLCAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU1NJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTScsICdNTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9IHRvSW50KGlucHV0KSAtIDE7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTU1NJywgJ01NTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB2YXIgbW9udGggPSBjb25maWcuX2xvY2FsZS5tb250aHNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGZpbmQgYSBtb250aCBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWQuXG4gICAgICAgIGlmIChtb250aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhcnJheVtNT05USF0gPSBtb250aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRNb250aCA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICB2YXIgTU9OVEhTX0lOX0ZPUk1BVCA9IC9EW29EXT8oXFxbW15cXFtcXF1dKlxcXXxcXHMpK01NTU0/LztcbiAgICB2YXIgZGVmYXVsdExvY2FsZU1vbnRocyA9ICdKYW51YXJ5X0ZlYnJ1YXJ5X01hcmNoX0FwcmlsX01heV9KdW5lX0p1bHlfQXVndXN0X1NlcHRlbWJlcl9PY3RvYmVyX05vdmVtYmVyX0RlY2VtYmVyJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRocyAobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKSA/IHRoaXMuX21vbnRocyA6XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzWydzdGFuZGFsb25lJ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKSA/IHRoaXMuX21vbnRoc1ttLm1vbnRoKCldIDpcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1sodGhpcy5fbW9udGhzLmlzRm9ybWF0IHx8IE1PTlRIU19JTl9GT1JNQVQpLnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLm1vbnRoKCldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQgPSAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzU2hvcnQgKG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0IDpcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFsnc3RhbmRhbG9uZSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0W20ubW9udGgoKV0gOlxuICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRbTU9OVEhTX0lOX0ZPUk1BVC50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5tb250aCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZShtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBpaSwgbW9tLCBsbGMgPSBtb250aE5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3QgdXNlZFxuICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyArK2kpIHtcbiAgICAgICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1BhcnNlIChtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlU3RyaWN0UGFyc2UuY2FsbCh0aGlzLCBtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IGFkZCBzb3J0aW5nXG4gICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXJcbiAgICAgICAgLy8gc2VlIHNvcnRpbmcgaW4gY29tcHV0ZU1vbnRoc1BhcnNlXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJywgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RyaWN0ICYmICF0aGlzLl9tb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykgKyAnfF4nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTU0nICYmIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTScgJiYgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl9tb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIHNldE1vbnRoIChtb20sIHZhbHVlKSB7XG4gICAgICAgIHZhciBkYXlPZk1vbnRoO1xuXG4gICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKC9eXFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b0ludCh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbW9tLmxvY2FsZURhdGEoKS5tb250aHNQYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogQW5vdGhlciBzaWxlbnQgZmFpbHVyZT9cbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRheU9mTW9udGggPSBNYXRoLm1pbihtb20uZGF0ZSgpLCBkYXlzSW5Nb250aChtb20ueWVhcigpLCB2YWx1ZSkpO1xuICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgJ01vbnRoJ10odmFsdWUsIGRheU9mTW9udGgpO1xuICAgICAgICByZXR1cm4gbW9tO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldE1vbnRoICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0TW9udGgodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0KHRoaXMsICdNb250aCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF5c0luTW9udGggKCkge1xuICAgICAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIG1vbnRoc1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA6IHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE1vbnRoc1JlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIG1vbnRoc1JlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUmVnZXggPSBkZWZhdWx0TW9udGhzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4IDogdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlTW9udGhzUGFyc2UgKCkge1xuICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2hvcnRQaWVjZXMgPSBbXSwgbG9uZ1BpZWNlcyA9IFtdLCBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgaSwgbW9tO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgIHNob3J0UGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgICAgICAgICBsb25nUGllY2VzLnB1c2godGhpcy5tb250aHMobW9tLCAnJykpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAgICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgICAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXNbaV0gPSByZWdleEVzY2FwZShsb25nUGllY2VzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMjQ7IGkrKykge1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShtaXhlZFBpZWNlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9tb250aHNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRSZWdleCA9IHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICB0aGlzLl9tb250aHNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZURhdGUgKHksIG0sIGQsIGgsIE0sIHMsIG1zKSB7XG4gICAgICAgIC8vIGNhbid0IGp1c3QgYXBwbHkoKSB0byBjcmVhdGUgYSBkYXRlOlxuICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMTgxMzQ4XG4gICAgICAgIHZhciBkYXRlO1xuICAgICAgICAvLyB0aGUgZGF0ZSBjb25zdHJ1Y3RvciByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHkgKyA0MDAsIG0sIGQsIGgsIE0sIHMsIG1zKTtcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZShkYXRlLmdldEZ1bGxZZWFyKCkpKSB7XG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcih5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh5LCBtLCBkLCBoLCBNLCBzLCBtcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVVENEYXRlICh5KSB7XG4gICAgICAgIHZhciBkYXRlO1xuICAgICAgICAvLyB0aGUgRGF0ZS5VVEMgZnVuY3Rpb24gcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIGFyZ3NbMF0gPSB5ICsgNDAwO1xuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDLmFwcGx5KG51bGwsIGFyZ3MpKTtcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZShkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpKSB7XG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIC8vIHN0YXJ0LW9mLWZpcnN0LXdlZWsgLSBzdGFydC1vZi15ZWFyXG4gICAgZnVuY3Rpb24gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSB7XG4gICAgICAgIHZhciAvLyBmaXJzdC13ZWVrIGRheSAtLSB3aGljaCBqYW51YXJ5IGlzIGFsd2F5cyBpbiB0aGUgZmlyc3Qgd2VlayAoNCBmb3IgaXNvLCAxIGZvciBvdGhlcilcbiAgICAgICAgICAgIGZ3ZCA9IDcgKyBkb3cgLSBkb3ksXG4gICAgICAgICAgICAvLyBmaXJzdC13ZWVrIGRheSBsb2NhbCB3ZWVrZGF5IC0tIHdoaWNoIGxvY2FsIHdlZWtkYXkgaXMgZndkXG4gICAgICAgICAgICBmd2RsdyA9ICg3ICsgY3JlYXRlVVRDRGF0ZSh5ZWFyLCAwLCBmd2QpLmdldFVUQ0RheSgpIC0gZG93KSAlIDc7XG5cbiAgICAgICAgcmV0dXJuIC1md2RsdyArIGZ3ZCAtIDE7XG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZSNDYWxjdWxhdGluZ19hX2RhdGVfZ2l2ZW5fdGhlX3llYXIuMkNfd2Vla19udW1iZXJfYW5kX3dlZWtkYXlcbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla3MoeWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIGxvY2FsV2Vla2RheSA9ICg3ICsgd2Vla2RheSAtIGRvdykgJSA3LFxuICAgICAgICAgICAgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXG4gICAgICAgICAgICBkYXlPZlllYXIgPSAxICsgNyAqICh3ZWVrIC0gMSkgKyBsb2NhbFdlZWtkYXkgKyB3ZWVrT2Zmc2V0LFxuICAgICAgICAgICAgcmVzWWVhciwgcmVzRGF5T2ZZZWFyO1xuXG4gICAgICAgIGlmIChkYXlPZlllYXIgPD0gMCkge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXIgLSAxO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5c0luWWVhcihyZXNZZWFyKSArIGRheU9mWWVhcjtcbiAgICAgICAgfSBlbHNlIGlmIChkYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXIpKSB7XG4gICAgICAgICAgICByZXNZZWFyID0geWVhciArIDE7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXIgLSBkYXlzSW5ZZWFyKHllYXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXI7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcjogcmVzWWVhcixcbiAgICAgICAgICAgIGRheU9mWWVhcjogcmVzRGF5T2ZZZWFyXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla09mWWVhcihtb20sIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KG1vbS55ZWFyKCksIGRvdywgZG95KSxcbiAgICAgICAgICAgIHdlZWsgPSBNYXRoLmZsb29yKChtb20uZGF5T2ZZZWFyKCkgLSB3ZWVrT2Zmc2V0IC0gMSkgLyA3KSArIDEsXG4gICAgICAgICAgICByZXNXZWVrLCByZXNZZWFyO1xuXG4gICAgICAgIGlmICh3ZWVrIDwgMSkge1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgLSAxO1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWsgKyB3ZWVrc0luWWVhcihyZXNZZWFyLCBkb3csIGRveSk7XG4gICAgICAgIH0gZWxzZSBpZiAod2VlayA+IHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KSkge1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWsgLSB3ZWVrc0luWWVhcihtb20ueWVhcigpLCBkb3csIGRveSk7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKTtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdlZWs6IHJlc1dlZWssXG4gICAgICAgICAgICB5ZWFyOiByZXNZZWFyXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla3NJblllYXIoeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICAgICAgd2Vla09mZnNldE5leHQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciArIDEsIGRvdywgZG95KTtcbiAgICAgICAgcmV0dXJuIChkYXlzSW5ZZWFyKHllYXIpIC0gd2Vla09mZnNldCArIHdlZWtPZmZzZXROZXh0KSAvIDc7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3cnLCBbJ3d3JywgMl0sICd3bycsICd3ZWVrJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ1cnLCBbJ1dXJywgMl0sICdXbycsICdpc29XZWVrJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWsnLCAndycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2VlaycsICdXJyk7XG5cbiAgICAvLyBQUklPUklUSUVTXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWsnLCA1KTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWsnLCA1KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3cnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCd3dycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdXJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignV1cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ3cnLCAnd3cnLCAnVycsICdXVyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMSldID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2VlayAobW9tKSB7XG4gICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKG1vbSwgdGhpcy5fd2Vlay5kb3csIHRoaXMuX3dlZWsuZG95KS53ZWVrO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2VlayA9IHtcbiAgICAgICAgZG93IDogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgIGRveSA6IDYgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDZ0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZldlZWsgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZlllYXIgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3k7XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2VlayAoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB0aGlzLmxvY2FsZURhdGEoKS53ZWVrKHRoaXMpO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2VlayAoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB3ZWVrT2ZZZWFyKHRoaXMsIDEsIDQpLndlZWs7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignZCcsIDAsICdkbycsICdkYXknKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzTWluKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5cyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2UnLCAwLCAwLCAnd2Vla2RheScpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdFJywgMCwgMCwgJ2lzb1dlZWtkYXknKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF5JywgJ2QnKTtcbiAgICBhZGRVbml0QWxpYXMoJ3dlZWtkYXknLCAnZScpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla2RheScsICdFJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF5JywgMTEpO1xuICAgIGFkZFVuaXRQcmlvcml0eSgnd2Vla2RheScsIDExKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtkYXknLCAxMSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdkJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdlJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdFJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c01pblJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdkZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdkZGRkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydkZCcsICdkZGQnLCAnZGRkZCddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIHdlZWtkYXkgPSBjb25maWcuX2xvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZ2V0IGEgd2Vla2RheSBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWRcbiAgICAgICAgaWYgKHdlZWtkYXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgd2Vlay5kID0gd2Vla2RheTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRXZWVrZGF5ID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZCcsICdlJywgJ0UnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW5dID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlucHV0ID0gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VJc29XZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCkgJSA3IHx8IDc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzTmFOKGlucHV0KSA/IG51bGwgOiBpbnB1dDtcbiAgICB9XG5cbiAgICAvLyBMT0NBTEVTXG4gICAgZnVuY3Rpb24gc2hpZnRXZWVrZGF5cyAod3MsIG4pIHtcbiAgICAgICAgcmV0dXJuIHdzLnNsaWNlKG4sIDcpLmNvbmNhdCh3cy5zbGljZSgwLCBuKSk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5cyA9ICdTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheScuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5cyAobSwgZm9ybWF0KSB7XG4gICAgICAgIHZhciB3ZWVrZGF5cyA9IGlzQXJyYXkodGhpcy5fd2Vla2RheXMpID8gdGhpcy5fd2Vla2RheXMgOlxuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNbKG0gJiYgbSAhPT0gdHJ1ZSAmJiB0aGlzLl93ZWVrZGF5cy5pc0Zvcm1hdC50ZXN0KGZvcm1hdCkpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddO1xuICAgICAgICByZXR1cm4gKG0gPT09IHRydWUpID8gc2hpZnRXZWVrZGF5cyh3ZWVrZGF5cywgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgICAgICA6IChtKSA/IHdlZWtkYXlzW20uZGF5KCldIDogd2Vla2RheXM7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0ID0gJ1N1bl9Nb25fVHVlX1dlZF9UaHVfRnJpX1NhdCcuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1Nob3J0IChtKSB7XG4gICAgICAgIHJldHVybiAobSA9PT0gdHJ1ZSkgPyBzaGlmdFdlZWtkYXlzKHRoaXMuX3dlZWtkYXlzU2hvcnQsIHRoaXMuX3dlZWsuZG93KVxuICAgICAgICAgICAgOiAobSkgPyB0aGlzLl93ZWVrZGF5c1Nob3J0W20uZGF5KCldIDogdGhpcy5fd2Vla2RheXNTaG9ydDtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluID0gJ1N1X01vX1R1X1dlX1RoX0ZyX1NhJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzTWluIChtKSB7XG4gICAgICAgIHJldHVybiAobSA9PT0gdHJ1ZSkgPyBzaGlmdFdlZWtkYXlzKHRoaXMuX3dlZWtkYXlzTWluLCB0aGlzLl93ZWVrLmRvdylcbiAgICAgICAgICAgIDogKG0pID8gdGhpcy5fd2Vla2RheXNNaW5bbS5kYXkoKV0gOiB0aGlzLl93ZWVrZGF5c01pbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZSQxKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgaWksIG1vbSwgbGxjID0gd2Vla2RheU5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7ICsraSkge1xuICAgICAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5c01pbihtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1BhcnNlICh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVN0cmljdFBhcnNlJDEuY2FsbCh0aGlzLCB3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcblxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFxcXC4/JykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZGRkJyAmJiB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGRkJyAmJiB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkJyAmJiB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fd2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRheSA9IHRoaXMuX2lzVVRDID8gdGhpcy5fZC5nZXRVVENEYXkoKSA6IHRoaXMuX2QuZ2V0RGF5KCk7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpbnB1dCA9IHBhcnNlV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGlucHV0IC0gZGF5LCAnZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRheTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldExvY2FsZURheU9mV2VlayAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gKHRoaXMuZGF5KCkgKyA3IC0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93KSAlIDc7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2Vla2RheSA6IHRoaXMuYWRkKGlucHV0IC0gd2Vla2RheSwgJ2QnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09EYXlPZldlZWsgKGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGJlaGF2ZXMgdGhlIHNhbWUgYXMgbW9tZW50I2RheSBleGNlcHRcbiAgICAgICAgLy8gYXMgYSBnZXR0ZXIsIHJldHVybnMgNyBpbnN0ZWFkIG9mIDAgKDEtNyByYW5nZSBpbnN0ZWFkIG9mIDAtNilcbiAgICAgICAgLy8gYXMgYSBzZXR0ZXIsIHN1bmRheSBzaG91bGQgYmVsb25nIHRvIHRoZSBwcmV2aW91cyB3ZWVrLlxuXG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgd2Vla2RheSA9IHBhcnNlSXNvV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF5KHRoaXMuZGF5KCkgJSA3ID8gd2Vla2RheSA6IHdlZWtkYXkgLSA3KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRheSgpIHx8IDc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFdlZWtkYXlzUmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgZnVuY3Rpb24gd2Vla2RheXNSZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBkZWZhdWx0V2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIHdlZWtkYXlzU2hvcnRSZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1Nob3J0UmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFdlZWtkYXlzTWluUmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgZnVuY3Rpb24gd2Vla2RheXNNaW5SZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzTWluUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSBkZWZhdWx0V2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZVdlZWtkYXlzUGFyc2UgKCkge1xuICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWluUGllY2VzID0gW10sIHNob3J0UGllY2VzID0gW10sIGxvbmdQaWVjZXMgPSBbXSwgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksIG1vbSwgbWlucCwgc2hvcnRwLCBsb25ncDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICBtaW5wID0gdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgICAgIHNob3J0cCA9IHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKTtcbiAgICAgICAgICAgIGxvbmdwID0gdGhpcy53ZWVrZGF5cyhtb20sICcnKTtcbiAgICAgICAgICAgIG1pblBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICAgICAgc2hvcnRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gobWlucCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHNob3J0cCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIHdlZWtkYXkgKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAgICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgICAgICBtaW5QaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIHNob3J0UGllY2VzW2ldID0gcmVnZXhFc2NhcGUoc2hvcnRQaWVjZXNbaV0pO1xuICAgICAgICAgICAgbG9uZ1BpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKGxvbmdQaWVjZXNbaV0pO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShtaXhlZFBpZWNlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl93ZWVrZGF5c1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcblxuICAgICAgICB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbG9uZ1BpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIHNob3J0UGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1pblBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgZnVuY3Rpb24gaEZvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKSAlIDEyIHx8IDEyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGtGb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvdXJzKCkgfHwgMjQ7XG4gICAgfVxuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0gnLCBbJ0hIJywgMl0sIDAsICdob3VyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ2gnLCBbJ2hoJywgMl0sIDAsIGhGb3JtYXQpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdrJywgWydraycsIDJdLCAwLCBrRm9ybWF0KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdobW0nLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignaG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyB0aGlzLmhvdXJzKCkgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbWVyaWRpZW0gKHRva2VuLCBsb3dlcmNhc2UpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tZXJpZGllbSh0aGlzLmhvdXJzKCksIHRoaXMubWludXRlcygpLCBsb3dlcmNhc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtZXJpZGllbSgnYScsIHRydWUpO1xuICAgIG1lcmlkaWVtKCdBJywgZmFsc2UpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdob3VyJywgJ2gnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdob3VyJywgMTMpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgZnVuY3Rpb24gbWF0Y2hNZXJpZGllbSAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLl9tZXJpZGllbVBhcnNlO1xuICAgIH1cblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2EnLCAgbWF0Y2hNZXJpZGllbSk7XG4gICAgYWRkUmVnZXhUb2tlbignQScsICBtYXRjaE1lcmlkaWVtKTtcbiAgICBhZGRSZWdleFRva2VuKCdIJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignaCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2snLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdISCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdoaCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdraycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignaG1tc3MnLCBtYXRjaDV0bzYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignSG1tc3MnLCBtYXRjaDV0bzYpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0gnLCAnSEgnXSwgSE9VUik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2snLCAna2snXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBrSW5wdXQgPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGFycmF5W0hPVVJdID0ga0lucHV0ID09PSAyNCA/IDAgOiBrSW5wdXQ7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2EnLCAnQSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9pc1BtID0gY29uZmlnLl9sb2NhbGUuaXNQTShpbnB1dCk7XG4gICAgICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnaCcsICdoaCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNDtcbiAgICAgICAgdmFyIHBvczIgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgICAgICBhcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczIpKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignSG1tJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MpKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdIbW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQ7XG4gICAgICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcbiAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICBmdW5jdGlvbiBsb2NhbGVJc1BNIChpbnB1dCkge1xuICAgICAgICAvLyBJRTggUXVpcmtzIE1vZGUgJiBJRTcgU3RhbmRhcmRzIE1vZGUgZG8gbm90IGFsbG93IGFjY2Vzc2luZyBzdHJpbmdzIGxpa2UgYXJyYXlzXG4gICAgICAgIC8vIFVzaW5nIGNoYXJBdCBzaG91bGQgYmUgbW9yZSBjb21wYXRpYmxlLlxuICAgICAgICByZXR1cm4gKChpbnB1dCArICcnKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gJ3AnKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2UgPSAvW2FwXVxcLj9tP1xcLj8vaTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNZXJpZGllbSAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3BtJyA6ICdQTSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdhbScgOiAnQU0nO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBTZXR0aW5nIHRoZSBob3VyIHNob3VsZCBrZWVwIHRoZSB0aW1lLCBiZWNhdXNlIHRoZSB1c2VyIGV4cGxpY2l0bHlcbiAgICAvLyBzcGVjaWZpZWQgd2hpY2ggaG91ciB0aGV5IHdhbnQuIFNvIHRyeWluZyB0byBtYWludGFpbiB0aGUgc2FtZSBob3VyIChpblxuICAgIC8vIGEgbmV3IHRpbWV6b25lKSBtYWtlcyBzZW5zZS4gQWRkaW5nL3N1YnRyYWN0aW5nIGhvdXJzIGRvZXMgbm90IGZvbGxvd1xuICAgIC8vIHRoaXMgcnVsZS5cbiAgICB2YXIgZ2V0U2V0SG91ciA9IG1ha2VHZXRTZXQoJ0hvdXJzJywgdHJ1ZSk7XG5cbiAgICB2YXIgYmFzZUNvbmZpZyA9IHtcbiAgICAgICAgY2FsZW5kYXI6IGRlZmF1bHRDYWxlbmRhcixcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQ6IGRlZmF1bHRMb25nRGF0ZUZvcm1hdCxcbiAgICAgICAgaW52YWxpZERhdGU6IGRlZmF1bHRJbnZhbGlkRGF0ZSxcbiAgICAgICAgb3JkaW5hbDogZGVmYXVsdE9yZGluYWwsXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IGRlZmF1bHREYXlPZk1vbnRoT3JkaW5hbFBhcnNlLFxuICAgICAgICByZWxhdGl2ZVRpbWU6IGRlZmF1bHRSZWxhdGl2ZVRpbWUsXG5cbiAgICAgICAgbW9udGhzOiBkZWZhdWx0TG9jYWxlTW9udGhzLFxuICAgICAgICBtb250aHNTaG9ydDogZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LFxuXG4gICAgICAgIHdlZWs6IGRlZmF1bHRMb2NhbGVXZWVrLFxuXG4gICAgICAgIHdlZWtkYXlzOiBkZWZhdWx0TG9jYWxlV2Vla2RheXMsXG4gICAgICAgIHdlZWtkYXlzTWluOiBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4sXG4gICAgICAgIHdlZWtkYXlzU2hvcnQ6IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0LFxuXG4gICAgICAgIG1lcmlkaWVtUGFyc2U6IGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlXG4gICAgfTtcblxuICAgIC8vIGludGVybmFsIHN0b3JhZ2UgZm9yIGxvY2FsZSBjb25maWcgZmlsZXNcbiAgICB2YXIgbG9jYWxlcyA9IHt9O1xuICAgIHZhciBsb2NhbGVGYW1pbGllcyA9IHt9O1xuICAgIHZhciBnbG9iYWxMb2NhbGU7XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVMb2NhbGUoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgPyBrZXkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdfJywgJy0nKSA6IGtleTtcbiAgICB9XG5cbiAgICAvLyBwaWNrIHRoZSBsb2NhbGUgZnJvbSB0aGUgYXJyYXlcbiAgICAvLyB0cnkgWydlbi1hdScsICdlbi1nYiddIGFzICdlbi1hdScsICdlbi1nYicsICdlbicsIGFzIGluIG1vdmUgdGhyb3VnaCB0aGUgbGlzdCB0cnlpbmcgZWFjaFxuICAgIC8vIHN1YnN0cmluZyBmcm9tIG1vc3Qgc3BlY2lmaWMgdG8gbGVhc3QsIGJ1dCBtb3ZlIHRvIHRoZSBuZXh0IGFycmF5IGl0ZW0gaWYgaXQncyBhIG1vcmUgc3BlY2lmaWMgdmFyaWFudCB0aGFuIHRoZSBjdXJyZW50IHJvb3RcbiAgICBmdW5jdGlvbiBjaG9vc2VMb2NhbGUobmFtZXMpIHtcbiAgICAgICAgdmFyIGkgPSAwLCBqLCBuZXh0LCBsb2NhbGUsIHNwbGl0O1xuXG4gICAgICAgIHdoaWxlIChpIDwgbmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzcGxpdCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpXSkuc3BsaXQoJy0nKTtcbiAgICAgICAgICAgIGogPSBzcGxpdC5sZW5ndGg7XG4gICAgICAgICAgICBuZXh0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2kgKyAxXSk7XG4gICAgICAgICAgICBuZXh0ID0gbmV4dCA/IG5leHQuc3BsaXQoJy0nKSA6IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAoaiA+IDApIHtcbiAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKHNwbGl0LnNsaWNlKDAsIGopLmpvaW4oJy0nKSk7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0Lmxlbmd0aCA+PSBqICYmIGNvbXBhcmVBcnJheXMoc3BsaXQsIG5leHQsIHRydWUpID49IGogLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdGhlIG5leHQgYXJyYXkgaXRlbSBpcyBiZXR0ZXIgdGhhbiBhIHNoYWxsb3dlciBzdWJzdHJpbmcgb2YgdGhpcyBvbmVcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRMb2NhbGUobmFtZSkge1xuICAgICAgICB2YXIgb2xkTG9jYWxlID0gbnVsbDtcbiAgICAgICAgLy8gVE9ETzogRmluZCBhIGJldHRlciB3YXkgdG8gcmVnaXN0ZXIgYW5kIGxvYWQgYWxsIHRoZSBsb2NhbGVzIGluIE5vZGVcbiAgICAgICAgaWYgKCFsb2NhbGVzW25hbWVdICYmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb2xkTG9jYWxlID0gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgICAgICAgICAgICAgIHZhciBhbGlhc2VkUmVxdWlyZSA9IHJlcXVpcmU7XG4gICAgICAgICAgICAgICAgYWxpYXNlZFJlcXVpcmUoJy4vbG9jYWxlLycgKyBuYW1lKTtcbiAgICAgICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUob2xkTG9jYWxlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbG9jYWxlIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxvY2FsZS4gIElmXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcbiAgICAvLyBsb2NhbGUga2V5LlxuICAgIGZ1bmN0aW9uIGdldFNldEdsb2JhbExvY2FsZSAoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGdldExvY2FsZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRlZmluZUxvY2FsZShrZXksIHZhbHVlcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gbW9tZW50LmR1cmF0aW9uLl9sb2NhbGUgPSBtb21lbnQuX2xvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgZ2xvYmFsTG9jYWxlID0gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIGNvbnNvbGUgIT09ICAndW5kZWZpbmVkJykgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vd2FybiB1c2VyIGlmIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGJ1dCB0aGUgbG9jYWxlIGNvdWxkIG5vdCBiZSBzZXRcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdMb2NhbGUgJyArIGtleSArICAnIG5vdCBmb3VuZC4gRGlkIHlvdSBmb3JnZXQgdG8gbG9hZCBpdD8nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmluZUxvY2FsZSAobmFtZSwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUsIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgICAgICBjb25maWcuYWJiciA9IG5hbWU7XG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKCdkZWZpbmVMb2NhbGVPdmVycmlkZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlIG1vbWVudC51cGRhdGVMb2NhbGUobG9jYWxlTmFtZSwgY29uZmlnKSB0byBjaGFuZ2UgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYW4gZXhpc3RpbmcgbG9jYWxlLiBtb21lbnQuZGVmaW5lTG9jYWxlKGxvY2FsZU5hbWUsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbmZpZykgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RlZmluZS1sb2NhbGUvIGZvciBtb3JlIGluZm8uJyk7XG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tuYW1lXS5fY29uZmlnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb25maWcucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0uX2NvbmZpZztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGNvbmZpZy5wYXJlbnRMb2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZS5fY29uZmlnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IG5ldyBMb2NhbGUobWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKSk7XG5cbiAgICAgICAgICAgIGlmIChsb2NhbGVGYW1pbGllc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lTG9jYWxlKHgubmFtZSwgeC5jb25maWcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGxvY2FsZSBBRlRFUiBhbGwgY2hpbGQgbG9jYWxlcyBoYXZlIGJlZW5cbiAgICAgICAgICAgIC8vIGNyZWF0ZWQsIHNvIHdlIHdvbid0IGVuZCB1cCB3aXRoIHRoZSBjaGlsZCBsb2NhbGUgc2V0LlxuICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuXG5cbiAgICAgICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdXNlZnVsIGZvciB0ZXN0aW5nXG4gICAgICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlTG9jYWxlKG5hbWUsIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUsIHRtcExvY2FsZSwgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcbiAgICAgICAgICAgIC8vIE1FUkdFXG4gICAgICAgICAgICB0bXBMb2NhbGUgPSBsb2FkTG9jYWxlKG5hbWUpO1xuICAgICAgICAgICAgaWYgKHRtcExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gdG1wTG9jYWxlLl9jb25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25maWcgPSBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpO1xuICAgICAgICAgICAgbG9jYWxlID0gbmV3IExvY2FsZShjb25maWcpO1xuICAgICAgICAgICAgbG9jYWxlLnBhcmVudExvY2FsZSA9IGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlO1xuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhc3MgbnVsbCBmb3IgY29uZmlnIHRvIHVudXBkYXRlLCB1c2VmdWwgZm9yIHRlc3RzXG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIGxvY2FsZSBkYXRhXG4gICAgZnVuY3Rpb24gZ2V0TG9jYWxlIChrZXkpIHtcbiAgICAgICAgdmFyIGxvY2FsZTtcblxuICAgICAgICBpZiAoa2V5ICYmIGtleS5fbG9jYWxlICYmIGtleS5fbG9jYWxlLl9hYmJyKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0FycmF5KGtleSkpIHtcbiAgICAgICAgICAgIC8vc2hvcnQtY2lyY3VpdCBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5ID0gW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hvb3NlTG9jYWxlKGtleSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdExvY2FsZXMoKSB7XG4gICAgICAgIHJldHVybiBrZXlzKGxvY2FsZXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3cgKG0pIHtcbiAgICAgICAgdmFyIG92ZXJmbG93O1xuICAgICAgICB2YXIgYSA9IG0uX2E7XG5cbiAgICAgICAgaWYgKGEgJiYgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID09PSAtMikge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPVxuICAgICAgICAgICAgICAgIGFbTU9OVEhdICAgICAgIDwgMCB8fCBhW01PTlRIXSAgICAgICA+IDExICA/IE1PTlRIIDpcbiAgICAgICAgICAgICAgICBhW0RBVEVdICAgICAgICA8IDEgfHwgYVtEQVRFXSAgICAgICAgPiBkYXlzSW5Nb250aChhW1lFQVJdLCBhW01PTlRIXSkgPyBEQVRFIDpcbiAgICAgICAgICAgICAgICBhW0hPVVJdICAgICAgICA8IDAgfHwgYVtIT1VSXSAgICAgICAgPiAyNCB8fCAoYVtIT1VSXSA9PT0gMjQgJiYgKGFbTUlOVVRFXSAhPT0gMCB8fCBhW1NFQ09ORF0gIT09IDAgfHwgYVtNSUxMSVNFQ09ORF0gIT09IDApKSA/IEhPVVIgOlxuICAgICAgICAgICAgICAgIGFbTUlOVVRFXSAgICAgIDwgMCB8fCBhW01JTlVURV0gICAgICA+IDU5ICA/IE1JTlVURSA6XG4gICAgICAgICAgICAgICAgYVtTRUNPTkRdICAgICAgPCAwIHx8IGFbU0VDT05EXSAgICAgID4gNTkgID8gU0VDT05EIDpcbiAgICAgICAgICAgICAgICBhW01JTExJU0VDT05EXSA8IDAgfHwgYVtNSUxMSVNFQ09ORF0gPiA5OTkgPyBNSUxMSVNFQ09ORCA6XG4gICAgICAgICAgICAgICAgLTE7XG5cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93RGF5T2ZZZWFyICYmIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gREFURTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla3MgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrZGF5ICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gV0VFS0RBWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICAvLyBQaWNrIHRoZSBmaXJzdCBkZWZpbmVkIG9mIHR3byBvciB0aHJlZSBhcmd1bWVudHMuXG4gICAgZnVuY3Rpb24gZGVmYXVsdHMoYSwgYiwgYykge1xuICAgICAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYiAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZykge1xuICAgICAgICAvLyBob29rcyBpcyBhY3R1YWxseSB0aGUgZXhwb3J0ZWQgbW9tZW50IG9iamVjdFxuICAgICAgICB2YXIgbm93VmFsdWUgPSBuZXcgRGF0ZShob29rcy5ub3coKSk7XG4gICAgICAgIGlmIChjb25maWcuX3VzZVVUQykge1xuICAgICAgICAgICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRVVENGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRVVENNb250aCgpLCBub3dWYWx1ZS5nZXRVVENEYXRlKCldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbm93VmFsdWUuZ2V0RnVsbFllYXIoKSwgbm93VmFsdWUuZ2V0TW9udGgoKSwgbm93VmFsdWUuZ2V0RGF0ZSgpXTtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IGFuIGFycmF5IHRvIGEgZGF0ZS5cbiAgICAvLyB0aGUgYXJyYXkgc2hvdWxkIG1pcnJvciB0aGUgcGFyYW1ldGVycyBiZWxvd1xuICAgIC8vIG5vdGU6IGFsbCB2YWx1ZXMgcGFzdCB0aGUgeWVhciBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlLlxuICAgIC8vIFt5ZWFyLCBtb250aCwgZGF5ICwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXVxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21BcnJheSAoY29uZmlnKSB7XG4gICAgICAgIHZhciBpLCBkYXRlLCBpbnB1dCA9IFtdLCBjdXJyZW50RGF0ZSwgZXhwZWN0ZWRXZWVrZGF5LCB5ZWFyVG9Vc2U7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZyk7XG5cbiAgICAgICAgLy9jb21wdXRlIGRheSBvZiB0aGUgeWVhciBmcm9tIHdlZWtzIGFuZCB3ZWVrZGF5c1xuICAgICAgICBpZiAoY29uZmlnLl93ICYmIGNvbmZpZy5fYVtEQVRFXSA9PSBudWxsICYmIGNvbmZpZy5fYVtNT05USF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2lmIHRoZSBkYXkgb2YgdGhlIHllYXIgaXMgc2V0LCBmaWd1cmUgb3V0IHdoYXQgaXQgaXNcbiAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHllYXJUb1VzZSA9IGRlZmF1bHRzKGNvbmZpZy5fYVtZRUFSXSwgY3VycmVudERhdGVbWUVBUl0pO1xuXG4gICAgICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXJUb1VzZSkgfHwgY29uZmlnLl9kYXlPZlllYXIgPT09IDApIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dEYXlPZlllYXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZSh5ZWFyVG9Vc2UsIDAsIGNvbmZpZy5fZGF5T2ZZZWFyKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNT05USF0gPSBkYXRlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICBjb25maWcuX2FbREFURV0gPSBkYXRlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCBkYXRlLlxuICAgICAgICAvLyAqIGlmIG5vIHllYXIsIG1vbnRoLCBkYXkgb2YgbW9udGggYXJlIGdpdmVuLCBkZWZhdWx0IHRvIHRvZGF5XG4gICAgICAgIC8vICogaWYgZGF5IG9mIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG1vbnRoIGFuZCB5ZWFyXG4gICAgICAgIC8vICogaWYgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgb25seSB5ZWFyXG4gICAgICAgIC8vICogaWYgeWVhciBpcyBnaXZlbiwgZG9uJ3QgZGVmYXVsdCBhbnl0aGluZ1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMyAmJiBjb25maWcuX2FbaV0gPT0gbnVsbDsgKytpKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IGN1cnJlbnREYXRlW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWmVybyBvdXQgd2hhdGV2ZXIgd2FzIG5vdCBkZWZhdWx0ZWQsIGluY2x1ZGluZyB0aW1lXG4gICAgICAgIGZvciAoOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IChjb25maWcuX2FbaV0gPT0gbnVsbCkgPyAoaSA9PT0gMiA/IDEgOiAwKSA6IGNvbmZpZy5fYVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZvciAyNDowMDowMC4wMDBcbiAgICAgICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA9PT0gMjQgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbTUlOVVRFXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtTRUNPTkRdID09PSAwICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW01JTExJU0VDT05EXSA9PT0gMCkge1xuICAgICAgICAgICAgY29uZmlnLl9uZXh0RGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcuX2QgPSAoY29uZmlnLl91c2VVVEMgPyBjcmVhdGVVVENEYXRlIDogY3JlYXRlRGF0ZSkuYXBwbHkobnVsbCwgaW5wdXQpO1xuICAgICAgICBleHBlY3RlZFdlZWtkYXkgPSBjb25maWcuX3VzZVVUQyA/IGNvbmZpZy5fZC5nZXRVVENEYXkoKSA6IGNvbmZpZy5fZC5nZXREYXkoKTtcblxuICAgICAgICAvLyBBcHBseSB0aW1lem9uZSBvZmZzZXQgZnJvbSBpbnB1dC4gVGhlIGFjdHVhbCB1dGNPZmZzZXQgY2FuIGJlIGNoYW5nZWRcbiAgICAgICAgLy8gd2l0aCBwYXJzZVpvbmUuXG4gICAgICAgIGlmIChjb25maWcuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fbmV4dERheSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMjQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBmb3IgbWlzbWF0Y2hpbmcgZGF5IG9mIHdlZWtcbiAgICAgICAgaWYgKGNvbmZpZy5fdyAmJiB0eXBlb2YgY29uZmlnLl93LmQgIT09ICd1bmRlZmluZWQnICYmIGNvbmZpZy5fdy5kICE9PSBleHBlY3RlZFdlZWtkYXkpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLndlZWtkYXlNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKSB7XG4gICAgICAgIHZhciB3LCB3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3ksIHRlbXAsIHdlZWtkYXlPdmVyZmxvdztcblxuICAgICAgICB3ID0gY29uZmlnLl93O1xuICAgICAgICBpZiAody5HRyAhPSBudWxsIHx8IHcuVyAhPSBudWxsIHx8IHcuRSAhPSBudWxsKSB7XG4gICAgICAgICAgICBkb3cgPSAxO1xuICAgICAgICAgICAgZG95ID0gNDtcblxuICAgICAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byB0YWtlIHRoZSBjdXJyZW50IGlzb1dlZWtZZWFyLCBidXQgdGhhdCBkZXBlbmRzIG9uXG4gICAgICAgICAgICAvLyBob3cgd2UgaW50ZXJwcmV0IG5vdyAobG9jYWwsIHV0YywgZml4ZWQgb2Zmc2V0KS4gU28gY3JlYXRlXG4gICAgICAgICAgICAvLyBhIG5vdyB2ZXJzaW9uIG9mIGN1cnJlbnQgY29uZmlnICh0YWtlIGxvY2FsL3V0Yy9vZmZzZXQgZmxhZ3MsIGFuZFxuICAgICAgICAgICAgLy8gY3JlYXRlIG5vdykuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuR0csIGNvbmZpZy5fYVtZRUFSXSwgd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCAxLCA0KS55ZWFyKTtcbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LlcsIDEpO1xuICAgICAgICAgICAgd2Vla2RheSA9IGRlZmF1bHRzKHcuRSwgMSk7XG4gICAgICAgICAgICBpZiAod2Vla2RheSA8IDEgfHwgd2Vla2RheSA+IDcpIHtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG93ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG93O1xuICAgICAgICAgICAgZG95ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG95O1xuXG4gICAgICAgICAgICB2YXIgY3VyV2VlayA9IHdlZWtPZlllYXIoY3JlYXRlTG9jYWwoKSwgZG93LCBkb3kpO1xuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuZ2csIGNvbmZpZy5fYVtZRUFSXSwgY3VyV2Vlay55ZWFyKTtcblxuICAgICAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IHdlZWsuXG4gICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody53LCBjdXJXZWVrLndlZWspO1xuXG4gICAgICAgICAgICBpZiAody5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZWVrZGF5IC0tIGxvdyBkYXkgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBuZXh0IHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5kO1xuICAgICAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgMCB8fCB3ZWVrZGF5ID4gNikge1xuICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAody5lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBsb2NhbCB3ZWVrZGF5IC0tIGNvdW50aW5nIHN0YXJ0cyBmcm9tIGJlZ2lubmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IHcuZSArIGRvdztcbiAgICAgICAgICAgICAgICBpZiAody5lIDwgMCB8fCB3LmUgPiA2KSB7XG4gICAgICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IHRvIGJlZ2lubmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IGRvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod2VlayA8IDEgfHwgd2VlayA+IHdlZWtzSW5ZZWFyKHdlZWtZZWFyLCBkb3csIGRveSkpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh3ZWVrZGF5T3ZlcmZsb3cgIT0gbnVsbCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla2RheSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZW1wID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgICAgICAgICBjb25maWcuX2FbWUVBUl0gPSB0ZW1wLnllYXI7XG4gICAgICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRlbXAuZGF5T2ZZZWFyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gaXNvIDg2MDEgcmVnZXhcbiAgICAvLyAwMDAwLTAwLTAwIDAwMDAtVzAwIG9yIDAwMDAtVzAwLTAgKyBUICsgMDAgb3IgMDA6MDAgb3IgMDA6MDA6MDAgb3IgMDA6MDA6MDAuMDAwICsgKzAwOjAwIG9yICswMDAwIG9yICswMClcbiAgICB2YXIgZXh0ZW5kZWRJc29SZWdleCA9IC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSktKD86XFxkXFxkLVxcZFxcZHxXXFxkXFxkLVxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGQpKSg/OihUfCApKFxcZFxcZCg/OjpcXGRcXGQoPzo6XFxkXFxkKD86Wy4sXVxcZCspPyk/KT8pKFtcXCtcXC1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLztcbiAgICB2YXIgYmFzaWNJc29SZWdleCA9IC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSkoPzpcXGRcXGRcXGRcXGR8V1xcZFxcZFxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGQpKSg/OihUfCApKFxcZFxcZCg/OlxcZFxcZCg/OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbXFwrXFwtXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/JC87XG5cbiAgICB2YXIgdHpSZWdleCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/LztcblxuICAgIHZhciBpc29EYXRlcyA9IFtcbiAgICAgICAgWydZWVlZWVktTU0tREQnLCAvWystXVxcZHs2fS1cXGRcXGQtXFxkXFxkL10sXG4gICAgICAgIFsnWVlZWS1NTS1ERCcsIC9cXGR7NH0tXFxkXFxkLVxcZFxcZC9dLFxuICAgICAgICBbJ0dHR0ctW1ddV1ctRScsIC9cXGR7NH0tV1xcZFxcZC1cXGQvXSxcbiAgICAgICAgWydHR0dHLVtXXVdXJywgL1xcZHs0fS1XXFxkXFxkLywgZmFsc2VdLFxuICAgICAgICBbJ1lZWVktREREJywgL1xcZHs0fS1cXGR7M30vXSxcbiAgICAgICAgWydZWVlZLU1NJywgL1xcZHs0fS1cXGRcXGQvLCBmYWxzZV0sXG4gICAgICAgIFsnWVlZWVlZTU1ERCcsIC9bKy1dXFxkezEwfS9dLFxuICAgICAgICBbJ1lZWVlNTUREJywgL1xcZHs4fS9dLFxuICAgICAgICAvLyBZWVlZTU0gaXMgTk9UIGFsbG93ZWQgYnkgdGhlIHN0YW5kYXJkXG4gICAgICAgIFsnR0dHR1tXXVdXRScsIC9cXGR7NH1XXFxkezN9L10sXG4gICAgICAgIFsnR0dHR1tXXVdXJywgL1xcZHs0fVdcXGR7Mn0vLCBmYWxzZV0sXG4gICAgICAgIFsnWVlZWURERCcsIC9cXGR7N30vXVxuICAgIF07XG5cbiAgICAvLyBpc28gdGltZSBmb3JtYXRzIGFuZCByZWdleGVzXG4gICAgdmFyIGlzb1RpbWVzID0gW1xuICAgICAgICBbJ0hIOm1tOnNzLlNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGRcXC5cXGQrL10sXG4gICAgICAgIFsnSEg6bW06c3MsU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZCxcXGQrL10sXG4gICAgICAgIFsnSEg6bW06c3MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgWydISDptbScsIC9cXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgIFsnSEhtbXNzLlNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkXFwuXFxkKy9dLFxuICAgICAgICBbJ0hIbW1zcyxTU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZCxcXGQrL10sXG4gICAgICAgIFsnSEhtbXNzJywgL1xcZFxcZFxcZFxcZFxcZFxcZC9dLFxuICAgICAgICBbJ0hIbW0nLCAvXFxkXFxkXFxkXFxkL10sXG4gICAgICAgIFsnSEgnLCAvXFxkXFxkL11cbiAgICBdO1xuXG4gICAgdmFyIGFzcE5ldEpzb25SZWdleCA9IC9eXFwvP0RhdGVcXCgoXFwtP1xcZCspL2k7XG5cbiAgICAvLyBkYXRlIGZyb20gaXNvIGZvcm1hdFxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21JU08oY29uZmlnKSB7XG4gICAgICAgIHZhciBpLCBsLFxuICAgICAgICAgICAgc3RyaW5nID0gY29uZmlnLl9pLFxuICAgICAgICAgICAgbWF0Y2ggPSBleHRlbmRlZElzb1JlZ2V4LmV4ZWMoc3RyaW5nKSB8fCBiYXNpY0lzb1JlZ2V4LmV4ZWMoc3RyaW5nKSxcbiAgICAgICAgICAgIGFsbG93VGltZSwgZGF0ZUZvcm1hdCwgdGltZUZvcm1hdCwgdHpGb3JtYXQ7XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pc28gPSB0cnVlO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvRGF0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzb0RhdGVzW2ldWzFdLmV4ZWMobWF0Y2hbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVGb3JtYXQgPSBpc29EYXRlc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dUaW1lID0gaXNvRGF0ZXNbaV1bMl0gIT09IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0ZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb1RpbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNvVGltZXNbaV1bMV0uZXhlYyhtYXRjaFszXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hdGNoWzJdIHNob3VsZCBiZSAnVCcgb3Igc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVGb3JtYXQgPSAobWF0Y2hbMl0gfHwgJyAnKSArIGlzb1RpbWVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYWxsb3dUaW1lICYmIHRpbWVGb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFs0XSkge1xuICAgICAgICAgICAgICAgIGlmICh0elJlZ2V4LmV4ZWMobWF0Y2hbNF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHR6Rm9ybWF0ID0gJ1onO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uZmlnLl9mID0gZGF0ZUZvcm1hdCArICh0aW1lRm9ybWF0IHx8ICcnKSArICh0ekZvcm1hdCB8fCAnJyk7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJGQyAyODIyIHJlZ2V4OiBGb3IgZGV0YWlscyBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI4MjIjc2VjdGlvbi0zLjNcbiAgICB2YXIgcmZjMjgyMiA9IC9eKD86KE1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1biksP1xccyk/KFxcZHsxLDJ9KVxccyhKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYylcXHMoXFxkezIsNH0pXFxzKFxcZFxcZCk6KFxcZFxcZCkoPzo6KFxcZFxcZCkpP1xccyg/OihVVHxHTVR8W0VDTVBdW1NEXVQpfChbWnpdKXwoWystXVxcZHs0fSkpJC87XG5cbiAgICBmdW5jdGlvbiBleHRyYWN0RnJvbVJGQzI4MjJTdHJpbmdzKHllYXJTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXG4gICAgICAgICAgICB1bnRydW5jYXRlWWVhcih5ZWFyU3RyKSxcbiAgICAgICAgICAgIGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydC5pbmRleE9mKG1vbnRoU3RyKSxcbiAgICAgICAgICAgIHBhcnNlSW50KGRheVN0ciwgMTApLFxuICAgICAgICAgICAgcGFyc2VJbnQoaG91clN0ciwgMTApLFxuICAgICAgICAgICAgcGFyc2VJbnQobWludXRlU3RyLCAxMClcbiAgICAgICAgXTtcblxuICAgICAgICBpZiAoc2Vjb25kU3RyKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJzZUludChzZWNvbmRTdHIsIDEwKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVudHJ1bmNhdGVZZWFyKHllYXJTdHIpIHtcbiAgICAgICAgdmFyIHllYXIgPSBwYXJzZUludCh5ZWFyU3RyLCAxMCk7XG4gICAgICAgIGlmICh5ZWFyIDw9IDQ5KSB7XG4gICAgICAgICAgICByZXR1cm4gMjAwMCArIHllYXI7XG4gICAgICAgIH0gZWxzZSBpZiAoeWVhciA8PSA5OTkpIHtcbiAgICAgICAgICAgIHJldHVybiAxOTAwICsgeWVhcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geWVhcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwcm9jZXNzUkZDMjgyMihzKSB7XG4gICAgICAgIC8vIFJlbW92ZSBjb21tZW50cyBhbmQgZm9sZGluZyB3aGl0ZXNwYWNlIGFuZCByZXBsYWNlIG11bHRpcGxlLXNwYWNlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1xcKFteKV0qXFwpfFtcXG5cXHRdL2csICcgJykucmVwbGFjZSgvKFxcc1xccyspL2csICcgJykucmVwbGFjZSgvXlxcc1xccyovLCAnJykucmVwbGFjZSgvXFxzXFxzKiQvLCAnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tXZWVrZGF5KHdlZWtkYXlTdHIsIHBhcnNlZElucHV0LCBjb25maWcpIHtcbiAgICAgICAgaWYgKHdlZWtkYXlTdHIpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFJlcGxhY2UgdGhlIHZhbmlsbGEgSlMgRGF0ZSBvYmplY3Qgd2l0aCBhbiBpbmRlcGVudGVudCBkYXktb2Ytd2VlayBjaGVjay5cbiAgICAgICAgICAgIHZhciB3ZWVrZGF5UHJvdmlkZWQgPSBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydC5pbmRleE9mKHdlZWtkYXlTdHIpLFxuICAgICAgICAgICAgICAgIHdlZWtkYXlBY3R1YWwgPSBuZXcgRGF0ZShwYXJzZWRJbnB1dFswXSwgcGFyc2VkSW5wdXRbMV0sIHBhcnNlZElucHV0WzJdKS5nZXREYXkoKTtcbiAgICAgICAgICAgIGlmICh3ZWVrZGF5UHJvdmlkZWQgIT09IHdlZWtkYXlBY3R1YWwpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS53ZWVrZGF5TWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgb2JzT2Zmc2V0cyA9IHtcbiAgICAgICAgVVQ6IDAsXG4gICAgICAgIEdNVDogMCxcbiAgICAgICAgRURUOiAtNCAqIDYwLFxuICAgICAgICBFU1Q6IC01ICogNjAsXG4gICAgICAgIENEVDogLTUgKiA2MCxcbiAgICAgICAgQ1NUOiAtNiAqIDYwLFxuICAgICAgICBNRFQ6IC02ICogNjAsXG4gICAgICAgIE1TVDogLTcgKiA2MCxcbiAgICAgICAgUERUOiAtNyAqIDYwLFxuICAgICAgICBQU1Q6IC04ICogNjBcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlT2Zmc2V0KG9ic09mZnNldCwgbWlsaXRhcnlPZmZzZXQsIG51bU9mZnNldCkge1xuICAgICAgICBpZiAob2JzT2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gb2JzT2Zmc2V0c1tvYnNPZmZzZXRdO1xuICAgICAgICB9IGVsc2UgaWYgKG1pbGl0YXJ5T2Zmc2V0KSB7XG4gICAgICAgICAgICAvLyB0aGUgb25seSBhbGxvd2VkIG1pbGl0YXJ5IHR6IGlzIFpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGhtID0gcGFyc2VJbnQobnVtT2Zmc2V0LCAxMCk7XG4gICAgICAgICAgICB2YXIgbSA9IGhtICUgMTAwLCBoID0gKGhtIC0gbSkgLyAxMDA7XG4gICAgICAgICAgICByZXR1cm4gaCAqIDYwICsgbTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgYW5kIHRpbWUgZnJvbSByZWYgMjgyMiBmb3JtYXRcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tUkZDMjgyMihjb25maWcpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gcmZjMjgyMi5leGVjKHByZXByb2Nlc3NSRkMyODIyKGNvbmZpZy5faSkpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBwYXJzZWRBcnJheSA9IGV4dHJhY3RGcm9tUkZDMjgyMlN0cmluZ3MobWF0Y2hbNF0sIG1hdGNoWzNdLCBtYXRjaFsyXSwgbWF0Y2hbNV0sIG1hdGNoWzZdLCBtYXRjaFs3XSk7XG4gICAgICAgICAgICBpZiAoIWNoZWNrV2Vla2RheShtYXRjaFsxXSwgcGFyc2VkQXJyYXksIGNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbmZpZy5fYSA9IHBhcnNlZEFycmF5O1xuICAgICAgICAgICAgY29uZmlnLl90em0gPSBjYWxjdWxhdGVPZmZzZXQobWF0Y2hbOF0sIG1hdGNoWzldLCBtYXRjaFsxMF0pO1xuXG4gICAgICAgICAgICBjb25maWcuX2QgPSBjcmVhdGVVVENEYXRlLmFwcGx5KG51bGwsIGNvbmZpZy5fYSk7XG4gICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5yZmMyODIyID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXQgb3IgZmFsbGJhY2tcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nKGNvbmZpZykge1xuICAgICAgICB2YXIgbWF0Y2hlZCA9IGFzcE5ldEpzb25SZWdleC5leGVjKGNvbmZpZy5faSk7XG5cbiAgICAgICAgaWYgKG1hdGNoZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCttYXRjaGVkWzFdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdGcm9tUkZDMjgyMihjb25maWcpO1xuICAgICAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5faXNWYWxpZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmFsIGF0dGVtcHQsIHVzZSBJbnB1dCBGYWxsYmFja1xuICAgICAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgIH1cblxuICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrID0gZGVwcmVjYXRlKFxuICAgICAgICAndmFsdWUgcHJvdmlkZWQgaXMgbm90IGluIGEgcmVjb2duaXplZCBSRkMyODIyIG9yIElTTyBmb3JtYXQuIG1vbWVudCBjb25zdHJ1Y3Rpb24gZmFsbHMgYmFjayB0byBqcyBEYXRlKCksICcgK1xuICAgICAgICAnd2hpY2ggaXMgbm90IHJlbGlhYmxlIGFjcm9zcyBhbGwgYnJvd3NlcnMgYW5kIHZlcnNpb25zLiBOb24gUkZDMjgyMi9JU08gZGF0ZSBmb3JtYXRzIGFyZSAnICtcbiAgICAgICAgJ2Rpc2NvdXJhZ2VkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYW4gdXBjb21pbmcgbWFqb3IgcmVsZWFzZS4gUGxlYXNlIHJlZmVyIHRvICcgK1xuICAgICAgICAnaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9qcy1kYXRlLyBmb3IgbW9yZSBpbmZvLicsXG4gICAgICAgIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5faSArIChjb25maWcuX3VzZVVUQyA/ICcgVVRDJyA6ICcnKSk7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIElTTyBzdGFuZGFyZFxuICAgIGhvb2tzLklTT184NjAxID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBjb25zdGFudCB0aGF0IHJlZmVycyB0byB0aGUgUkZDIDI4MjIgZm9ybVxuICAgIGhvb2tzLlJGQ18yODIyID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBmb3JtYXQgc3RyaW5nXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIHRvIGFub3RoZXIgcGFydCBvZiB0aGUgY3JlYXRpb24gZmxvdyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcHNcbiAgICAgICAgaWYgKGNvbmZpZy5fZiA9PT0gaG9va3MuSVNPXzg2MDEpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLl9mID09PSBob29rcy5SRkNfMjgyMikge1xuICAgICAgICAgICAgY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25maWcuX2EgPSBbXTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSB0cnVlO1xuXG4gICAgICAgIC8vIFRoaXMgYXJyYXkgaXMgdXNlZCB0byBtYWtlIGEgRGF0ZSwgZWl0aGVyIHdpdGggYG5ldyBEYXRlYCBvciBgRGF0ZS5VVENgXG4gICAgICAgIHZhciBzdHJpbmcgPSAnJyArIGNvbmZpZy5faSxcbiAgICAgICAgICAgIGksIHBhcnNlZElucHV0LCB0b2tlbnMsIHRva2VuLCBza2lwcGVkLFxuICAgICAgICAgICAgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggPSAwO1xuXG4gICAgICAgIHRva2VucyA9IGV4cGFuZEZvcm1hdChjb25maWcuX2YsIGNvbmZpZy5fbG9jYWxlKS5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSB8fCBbXTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgIHBhcnNlZElucHV0ID0gKHN0cmluZy5tYXRjaChnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpIHx8IFtdKVswXTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCd0b2tlbicsIHRva2VuLCAncGFyc2VkSW5wdXQnLCBwYXJzZWRJbnB1dCxcbiAgICAgICAgICAgIC8vICAgICAgICAgJ3JlZ2V4JywgZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIHNraXBwZWQgPSBzdHJpbmcuc3Vic3RyKDAsIHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSk7XG4gICAgICAgICAgICAgICAgaWYgKHNraXBwZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHNraXBwZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2Uoc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpICsgcGFyc2VkSW5wdXQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoICs9IHBhcnNlZElucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRvbid0IHBhcnNlIGlmIGl0J3Mgbm90IGEga25vd24gdG9rZW5cbiAgICAgICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0pIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIHBhcnNlZElucHV0LCBjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnLl9zdHJpY3QgJiYgIXBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHJlbWFpbmluZyB1bnBhcnNlZCBpbnB1dCBsZW5ndGggdG8gdGhlIHN0cmluZ1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5jaGFyc0xlZnRPdmVyID0gc3RyaW5nTGVuZ3RoIC0gdG90YWxQYXJzZWRJbnB1dExlbmd0aDtcbiAgICAgICAgaWYgKHN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHN0cmluZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhciBfMTJoIGZsYWcgaWYgaG91ciBpcyA8PSAxMlxuICAgICAgICBpZiAoY29uZmlnLl9hW0hPVVJdIDw9IDEyICYmXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID09PSB0cnVlICYmXG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPiAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykucGFyc2VkRGF0ZVBhcnRzID0gY29uZmlnLl9hLnNsaWNlKDApO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5tZXJpZGllbSA9IGNvbmZpZy5fbWVyaWRpZW07XG4gICAgICAgIC8vIGhhbmRsZSBtZXJpZGllbVxuICAgICAgICBjb25maWcuX2FbSE9VUl0gPSBtZXJpZGllbUZpeFdyYXAoY29uZmlnLl9sb2NhbGUsIGNvbmZpZy5fYVtIT1VSXSwgY29uZmlnLl9tZXJpZGllbSk7XG5cbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgIGNoZWNrT3ZlcmZsb3coY29uZmlnKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIG1lcmlkaWVtRml4V3JhcCAobG9jYWxlLCBob3VyLCBtZXJpZGllbSkge1xuICAgICAgICB2YXIgaXNQbTtcblxuICAgICAgICBpZiAobWVyaWRpZW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsZS5tZXJpZGllbUhvdXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS5tZXJpZGllbUhvdXIoaG91ciwgbWVyaWRpZW0pO1xuICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZS5pc1BNICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrXG4gICAgICAgICAgICBpc1BtID0gbG9jYWxlLmlzUE0obWVyaWRpZW0pO1xuICAgICAgICAgICAgaWYgKGlzUG0gJiYgaG91ciA8IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciArPSAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNQbSAmJiBob3VyID09PSAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBzdXBwb3NlZCB0byBoYXBwZW5cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgYXJyYXkgb2YgZm9ybWF0IHN0cmluZ3NcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIHZhciB0ZW1wQ29uZmlnLFxuICAgICAgICAgICAgYmVzdE1vbWVudCxcblxuICAgICAgICAgICAgc2NvcmVUb0JlYXQsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgY3VycmVudFNjb3JlO1xuXG4gICAgICAgIGlmIChjb25maWcuX2YubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkRm9ybWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29uZmlnLl9mLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgPSAwO1xuICAgICAgICAgICAgdGVtcENvbmZpZyA9IGNvcHlDb25maWcoe30sIGNvbmZpZyk7XG4gICAgICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRlbXBDb25maWcuX3VzZVVUQyA9IGNvbmZpZy5fdXNlVVRDO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVtcENvbmZpZy5fZiA9IGNvbmZpZy5fZltpXTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQodGVtcENvbmZpZyk7XG5cbiAgICAgICAgICAgIGlmICghaXNWYWxpZCh0ZW1wQ29uZmlnKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbnkgaW5wdXQgdGhhdCB3YXMgbm90IHBhcnNlZCBhZGQgYSBwZW5hbHR5IGZvciB0aGF0IGZvcm1hdFxuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5jaGFyc0xlZnRPdmVyO1xuXG4gICAgICAgICAgICAvL29yIHRva2Vuc1xuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS51bnVzZWRUb2tlbnMubGVuZ3RoICogMTA7XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5zY29yZSA9IGN1cnJlbnRTY29yZTtcblxuICAgICAgICAgICAgaWYgKHNjb3JlVG9CZWF0ID09IG51bGwgfHwgY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQpIHtcbiAgICAgICAgICAgICAgICBzY29yZVRvQmVhdCA9IGN1cnJlbnRTY29yZTtcbiAgICAgICAgICAgICAgICBiZXN0TW9tZW50ID0gdGVtcENvbmZpZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4dGVuZChjb25maWcsIGJlc3RNb21lbnQgfHwgdGVtcENvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbU9iamVjdChjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSBub3JtYWxpemVPYmplY3RVbml0cyhjb25maWcuX2kpO1xuICAgICAgICBjb25maWcuX2EgPSBtYXAoW2kueWVhciwgaS5tb250aCwgaS5kYXkgfHwgaS5kYXRlLCBpLmhvdXIsIGkubWludXRlLCBpLnNlY29uZCwgaS5taWxsaXNlY29uZF0sIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBvYmogJiYgcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZyb21Db25maWcgKGNvbmZpZykge1xuICAgICAgICB2YXIgcmVzID0gbmV3IE1vbWVudChjaGVja092ZXJmbG93KHByZXBhcmVDb25maWcoY29uZmlnKSkpO1xuICAgICAgICBpZiAocmVzLl9uZXh0RGF5KSB7XG4gICAgICAgICAgICAvLyBBZGRpbmcgaXMgc21hcnQgZW5vdWdoIGFyb3VuZCBEU1RcbiAgICAgICAgICAgIHJlcy5hZGQoMSwgJ2QnKTtcbiAgICAgICAgICAgIHJlcy5fbmV4dERheSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcGFyZUNvbmZpZyAoY29uZmlnKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGNvbmZpZy5fZjtcblxuICAgICAgICBjb25maWcuX2xvY2FsZSA9IGNvbmZpZy5fbG9jYWxlIHx8IGdldExvY2FsZShjb25maWcuX2wpO1xuXG4gICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCAoZm9ybWF0ID09PSB1bmRlZmluZWQgJiYgaW5wdXQgPT09ICcnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoe251bGxJbnB1dDogdHJ1ZX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faSA9IGlucHV0ID0gY29uZmlnLl9sb2NhbGUucHJlcGFyc2UoaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTW9tZW50KGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhpbnB1dCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IGlucHV0O1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZm9ybWF0KSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0KSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgIH0gIGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnRnJvbUlucHV0KGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVmFsaWQoY29uZmlnKSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUlucHV0KGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2k7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZChpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGhvb2tzLm5vdygpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dC52YWx1ZU9mKCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9hID0gbWFwKGlucHV0LnNsaWNlKDApLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG9iaiwgMTApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdChpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkpIHtcbiAgICAgICAgICAgIC8vIGZyb20gbWlsbGlzZWNvbmRzXG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTG9jYWxPclVUQyAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGlzVVRDKSB7XG4gICAgICAgIHZhciBjID0ge307XG5cbiAgICAgICAgaWYgKGxvY2FsZSA9PT0gdHJ1ZSB8fCBsb2NhbGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzdHJpY3QgPSBsb2NhbGU7XG4gICAgICAgICAgICBsb2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKGlzT2JqZWN0KGlucHV0KSAmJiBpc09iamVjdEVtcHR5KGlucHV0KSkgfHxcbiAgICAgICAgICAgICAgICAoaXNBcnJheShpbnB1dCkgJiYgaW5wdXQubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgaW5wdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb2JqZWN0IGNvbnN0cnVjdGlvbiBtdXN0IGJlIGRvbmUgdGhpcyB3YXkuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNDIzXG4gICAgICAgIGMuX2lzQU1vbWVudE9iamVjdCA9IHRydWU7XG4gICAgICAgIGMuX3VzZVVUQyA9IGMuX2lzVVRDID0gaXNVVEM7XG4gICAgICAgIGMuX2wgPSBsb2NhbGU7XG4gICAgICAgIGMuX2kgPSBpbnB1dDtcbiAgICAgICAgYy5fZiA9IGZvcm1hdDtcbiAgICAgICAgYy5fc3RyaWN0ID0gc3RyaWN0O1xuXG4gICAgICAgIHJldHVybiBjcmVhdGVGcm9tQ29uZmlnKGMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgZmFsc2UpO1xuICAgIH1cblxuICAgIHZhciBwcm90b3R5cGVNaW4gPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5taW4gaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5tYXggaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9taW4tbWF4LycsXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyIDwgdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICB2YXIgcHJvdG90eXBlTWF4ID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkubWF4IGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWluIGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdGhlciA+IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gUGljayBhIG1vbWVudCBtIGZyb20gbW9tZW50cyBzbyB0aGF0IG1bZm5dKG90aGVyKSBpcyB0cnVlIGZvciBhbGxcbiAgICAvLyBvdGhlci4gVGhpcyByZWxpZXMgb24gdGhlIGZ1bmN0aW9uIGZuIHRvIGJlIHRyYW5zaXRpdmUuXG4gICAgLy9cbiAgICAvLyBtb21lbnRzIHNob3VsZCBlaXRoZXIgYmUgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMgb3IgYW4gYXJyYXksIHdob3NlXG4gICAgLy8gZmlyc3QgZWxlbWVudCBpcyBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cy5cbiAgICBmdW5jdGlvbiBwaWNrQnkoZm4sIG1vbWVudHMpIHtcbiAgICAgICAgdmFyIHJlcywgaTtcbiAgICAgICAgaWYgKG1vbWVudHMubGVuZ3RoID09PSAxICYmIGlzQXJyYXkobW9tZW50c1swXSkpIHtcbiAgICAgICAgICAgIG1vbWVudHMgPSBtb21lbnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbW9tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVMb2NhbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcyA9IG1vbWVudHNbMF07XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBtb21lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIW1vbWVudHNbaV0uaXNWYWxpZCgpIHx8IG1vbWVudHNbaV1bZm5dKHJlcykpIHtcbiAgICAgICAgICAgICAgICByZXMgPSBtb21lbnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIFtdLnNvcnQgaW5zdGVhZD9cbiAgICBmdW5jdGlvbiBtaW4gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0JlZm9yZScsIGFyZ3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1heCAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQWZ0ZXInLCBhcmdzKTtcbiAgICB9XG5cbiAgICB2YXIgbm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gRGF0ZS5ub3cgPyBEYXRlLm5vdygpIDogKyhuZXcgRGF0ZSgpKTtcbiAgICB9O1xuXG4gICAgdmFyIG9yZGVyaW5nID0gWyd5ZWFyJywgJ3F1YXJ0ZXInLCAnbW9udGgnLCAnd2VlaycsICdkYXknLCAnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJywgJ21pbGxpc2Vjb25kJ107XG5cbiAgICBmdW5jdGlvbiBpc0R1cmF0aW9uVmFsaWQobSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbSkge1xuICAgICAgICAgICAgaWYgKCEoaW5kZXhPZi5jYWxsKG9yZGVyaW5nLCBrZXkpICE9PSAtMSAmJiAobVtrZXldID09IG51bGwgfHwgIWlzTmFOKG1ba2V5XSkpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1bml0SGFzRGVjaW1hbCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyaW5nLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAobVtvcmRlcmluZ1tpXV0pIHtcbiAgICAgICAgICAgICAgICBpZiAodW5pdEhhc0RlY2ltYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBvbmx5IGFsbG93IG5vbi1pbnRlZ2VycyBmb3Igc21hbGxlc3QgdW5pdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VGbG9hdChtW29yZGVyaW5nW2ldXSkgIT09IHRvSW50KG1bb3JkZXJpbmdbaV1dKSkge1xuICAgICAgICAgICAgICAgICAgICB1bml0SGFzRGVjaW1hbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWYWxpZCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNWYWxpZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVJbnZhbGlkJDEoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbihOYU4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIER1cmF0aW9uIChkdXJhdGlvbikge1xuICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoZHVyYXRpb24pLFxuICAgICAgICAgICAgeWVhcnMgPSBub3JtYWxpemVkSW5wdXQueWVhciB8fCAwLFxuICAgICAgICAgICAgcXVhcnRlcnMgPSBub3JtYWxpemVkSW5wdXQucXVhcnRlciB8fCAwLFxuICAgICAgICAgICAgbW9udGhzID0gbm9ybWFsaXplZElucHV0Lm1vbnRoIHx8IDAsXG4gICAgICAgICAgICB3ZWVrcyA9IG5vcm1hbGl6ZWRJbnB1dC53ZWVrIHx8IG5vcm1hbGl6ZWRJbnB1dC5pc29XZWVrIHx8IDAsXG4gICAgICAgICAgICBkYXlzID0gbm9ybWFsaXplZElucHV0LmRheSB8fCAwLFxuICAgICAgICAgICAgaG91cnMgPSBub3JtYWxpemVkSW5wdXQuaG91ciB8fCAwLFxuICAgICAgICAgICAgbWludXRlcyA9IG5vcm1hbGl6ZWRJbnB1dC5taW51dGUgfHwgMCxcbiAgICAgICAgICAgIHNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQuc2Vjb25kIHx8IDAsXG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQubWlsbGlzZWNvbmQgfHwgMDtcblxuICAgICAgICB0aGlzLl9pc1ZhbGlkID0gaXNEdXJhdGlvblZhbGlkKG5vcm1hbGl6ZWRJbnB1dCk7XG5cbiAgICAgICAgLy8gcmVwcmVzZW50YXRpb24gZm9yIGRhdGVBZGRSZW1vdmVcbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gK21pbGxpc2Vjb25kcyArXG4gICAgICAgICAgICBzZWNvbmRzICogMWUzICsgLy8gMTAwMFxuICAgICAgICAgICAgbWludXRlcyAqIDZlNCArIC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgaG91cnMgKiAxMDAwICogNjAgKiA2MDsgLy91c2luZyAxMDAwICogNjAgKiA2MCBpbnN0ZWFkIG9mIDM2ZTUgdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yOTc4XG4gICAgICAgIC8vIEJlY2F1c2Ugb2YgZGF0ZUFkZFJlbW92ZSB0cmVhdHMgMjQgaG91cnMgYXMgZGlmZmVyZW50IGZyb20gYVxuICAgICAgICAvLyBkYXkgd2hlbiB3b3JraW5nIGFyb3VuZCBEU1QsIHdlIG5lZWQgdG8gc3RvcmUgdGhlbSBzZXBhcmF0ZWx5XG4gICAgICAgIHRoaXMuX2RheXMgPSArZGF5cyArXG4gICAgICAgICAgICB3ZWVrcyAqIDc7XG4gICAgICAgIC8vIEl0IGlzIGltcG9zc2libGUgdG8gdHJhbnNsYXRlIG1vbnRocyBpbnRvIGRheXMgd2l0aG91dCBrbm93aW5nXG4gICAgICAgIC8vIHdoaWNoIG1vbnRocyB5b3UgYXJlIGFyZSB0YWxraW5nIGFib3V0LCBzbyB3ZSBoYXZlIHRvIHN0b3JlXG4gICAgICAgIC8vIGl0IHNlcGFyYXRlbHkuXG4gICAgICAgIHRoaXMuX21vbnRocyA9ICttb250aHMgK1xuICAgICAgICAgICAgcXVhcnRlcnMgKiAzICtcbiAgICAgICAgICAgIHllYXJzICogMTI7XG5cbiAgICAgICAgdGhpcy5fZGF0YSA9IHt9O1xuXG4gICAgICAgIHRoaXMuX2xvY2FsZSA9IGdldExvY2FsZSgpO1xuXG4gICAgICAgIHRoaXMuX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRHVyYXRpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRHVyYXRpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzUm91bmQgKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoLTEgKiBudW1iZXIpICogLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgZnVuY3Rpb24gb2Zmc2V0ICh0b2tlbiwgc2VwYXJhdG9yKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy51dGNPZmZzZXQoKTtcbiAgICAgICAgICAgIHZhciBzaWduID0gJysnO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAtb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHNpZ24gPSAnLSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2lnbiArIHplcm9GaWxsKH5+KG9mZnNldCAvIDYwKSwgMikgKyBzZXBhcmF0b3IgKyB6ZXJvRmlsbCh+fihvZmZzZXQpICUgNjAsIDIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvZmZzZXQoJ1onLCAnOicpO1xuICAgIG9mZnNldCgnWlonLCAnJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdaJywgIG1hdGNoU2hvcnRPZmZzZXQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1paJywgbWF0Y2hTaG9ydE9mZnNldCk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ1onLCAnWlonXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fdXNlVVRDID0gdHJ1ZTtcbiAgICAgICAgY29uZmlnLl90em0gPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIHRpbWV6b25lIGNodW5rZXJcbiAgICAvLyAnKzEwOjAwJyA+IFsnMTAnLCAgJzAwJ11cbiAgICAvLyAnLTE1MzAnICA+IFsnLTE1JywgJzMwJ11cbiAgICB2YXIgY2h1bmtPZmZzZXQgPSAvKFtcXCtcXC1dfFxcZFxcZCkvZ2k7XG5cbiAgICBmdW5jdGlvbiBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoZXIsIHN0cmluZykge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IChzdHJpbmcgfHwgJycpLm1hdGNoKG1hdGNoZXIpO1xuXG4gICAgICAgIGlmIChtYXRjaGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaHVuayAgID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdIHx8IFtdO1xuICAgICAgICB2YXIgcGFydHMgICA9IChjaHVuayArICcnKS5tYXRjaChjaHVua09mZnNldCkgfHwgWyctJywgMCwgMF07XG4gICAgICAgIHZhciBtaW51dGVzID0gKyhwYXJ0c1sxXSAqIDYwKSArIHRvSW50KHBhcnRzWzJdKTtcblxuICAgICAgICByZXR1cm4gbWludXRlcyA9PT0gMCA/XG4gICAgICAgICAgMCA6XG4gICAgICAgICAgcGFydHNbMF0gPT09ICcrJyA/IG1pbnV0ZXMgOiAtbWludXRlcztcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYSBtb21lbnQgZnJvbSBpbnB1dCwgdGhhdCBpcyBsb2NhbC91dGMvem9uZSBlcXVpdmFsZW50IHRvIG1vZGVsLlxuICAgIGZ1bmN0aW9uIGNsb25lV2l0aE9mZnNldChpbnB1dCwgbW9kZWwpIHtcbiAgICAgICAgdmFyIHJlcywgZGlmZjtcbiAgICAgICAgaWYgKG1vZGVsLl9pc1VUQykge1xuICAgICAgICAgICAgcmVzID0gbW9kZWwuY2xvbmUoKTtcbiAgICAgICAgICAgIGRpZmYgPSAoaXNNb21lbnQoaW5wdXQpIHx8IGlzRGF0ZShpbnB1dCkgPyBpbnB1dC52YWx1ZU9mKCkgOiBjcmVhdGVMb2NhbChpbnB1dCkudmFsdWVPZigpKSAtIHJlcy52YWx1ZU9mKCk7XG4gICAgICAgICAgICAvLyBVc2UgbG93LWxldmVsIGFwaSwgYmVjYXVzZSB0aGlzIGZuIGlzIGxvdy1sZXZlbCBhcGkuXG4gICAgICAgICAgICByZXMuX2Quc2V0VGltZShyZXMuX2QudmFsdWVPZigpICsgZGlmZik7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQocmVzLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0KS5sb2NhbCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF0ZU9mZnNldCAobSkge1xuICAgICAgICAvLyBPbiBGaXJlZm94LjI0IERhdGUjZ2V0VGltZXpvbmVPZmZzZXQgcmV0dXJucyBhIGZsb2F0aW5nIHBvaW50LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9wdWxsLzE4NzFcbiAgICAgICAgcmV0dXJuIC1NYXRoLnJvdW5kKG0uX2QuZ2V0VGltZXpvbmVPZmZzZXQoKSAvIDE1KSAqIDE1O1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIGEgbW9tZW50IGlzIG11dGF0ZWQuXG4gICAgLy8gSXQgaXMgaW50ZW5kZWQgdG8ga2VlcCB0aGUgb2Zmc2V0IGluIHN5bmMgd2l0aCB0aGUgdGltZXpvbmUuXG4gICAgaG9va3MudXBkYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBrZWVwTG9jYWxUaW1lID0gdHJ1ZSBtZWFucyBvbmx5IGNoYW5nZSB0aGUgdGltZXpvbmUsIHdpdGhvdXRcbiAgICAvLyBhZmZlY3RpbmcgdGhlIGxvY2FsIGhvdXIuIFNvIDU6MzE6MjYgKzAzMDAgLS1bdXRjT2Zmc2V0KDIsIHRydWUpXS0tPlxuICAgIC8vIDU6MzE6MjYgKzAyMDAgSXQgaXMgcG9zc2libGUgdGhhdCA1OjMxOjI2IGRvZXNuJ3QgZXhpc3Qgd2l0aCBvZmZzZXRcbiAgICAvLyArMDIwMCwgc28gd2UgYWRqdXN0IHRoZSB0aW1lIGFzIG5lZWRlZCwgdG8gYmUgdmFsaWQuXG4gICAgLy9cbiAgICAvLyBLZWVwaW5nIHRoZSB0aW1lIGFjdHVhbGx5IGFkZHMvc3VidHJhY3RzIChvbmUgaG91cilcbiAgICAvLyBmcm9tIHRoZSBhY3R1YWwgcmVwcmVzZW50ZWQgdGltZS4gVGhhdCBpcyB3aHkgd2UgY2FsbCB1cGRhdGVPZmZzZXRcbiAgICAvLyBhIHNlY29uZCB0aW1lLiBJbiBjYXNlIGl0IHdhbnRzIHVzIHRvIGNoYW5nZSB0aGUgb2Zmc2V0IGFnYWluXG4gICAgLy8gX2NoYW5nZUluUHJvZ3Jlc3MgPT0gdHJ1ZSBjYXNlLCB0aGVuIHdlIGhhdmUgdG8gYWRqdXN0LCBiZWNhdXNlXG4gICAgLy8gdGhlcmUgaXMgbm8gc3VjaCB0aW1lIGluIHRoZSBnaXZlbiB0aW1lem9uZS5cbiAgICBmdW5jdGlvbiBnZXRTZXRPZmZzZXQgKGlucHV0LCBrZWVwTG9jYWxUaW1lLCBrZWVwTWludXRlcykge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0IHx8IDAsXG4gICAgICAgICAgICBsb2NhbEFkanVzdDtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoaW5wdXQpIDwgMTYgJiYgIWtlZXBNaW51dGVzKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dCAqIDYwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1VUQyAmJiBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxBZGp1c3QgPSBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5wdXQ7XG4gICAgICAgICAgICB0aGlzLl9pc1VUQyA9IHRydWU7XG4gICAgICAgICAgICBpZiAobG9jYWxBZGp1c3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGxvY2FsQWRqdXN0LCAnbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9mZnNldCAhPT0gaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWtlZXBMb2NhbFRpbWUgfHwgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICBhZGRTdWJ0cmFjdCh0aGlzLCBjcmVhdGVEdXJhdGlvbihpbnB1dCAtIG9mZnNldCwgJ20nKSwgMSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyBvZmZzZXQgOiBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0Wm9uZSAoaW5wdXQsIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSAtaW5wdXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KGlucHV0LCBrZWVwTG9jYWxUaW1lKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLXRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb1VUQyAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICByZXR1cm4gdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9Mb2NhbCAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICBpZiAodGhpcy5faXNVVEMpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgICAgICAgICAgdGhpcy5faXNVVEMgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnRyYWN0KGdldERhdGVPZmZzZXQodGhpcyksICdtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQgKCkge1xuICAgICAgICBpZiAodGhpcy5fdHptICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KHRoaXMuX3R6bSwgZmFsc2UsIHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9pID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIHRab25lID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaE9mZnNldCwgdGhpcy5faSk7XG4gICAgICAgICAgICBpZiAodFpvbmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KHRab25lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc0FsaWduZWRIb3VyT2Zmc2V0IChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXQgPSBpbnB1dCA/IGNyZWF0ZUxvY2FsKGlucHV0KS51dGNPZmZzZXQoKSA6IDA7XG5cbiAgICAgICAgcmV0dXJuICh0aGlzLnV0Y09mZnNldCgpIC0gaW5wdXQpICUgNjAgPT09IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWUgKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCgwKS51dGNPZmZzZXQoKSB8fFxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCg1KS51dGNPZmZzZXQoKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZCAoKSB7XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5faXNEU1RTaGlmdGVkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjID0ge307XG5cbiAgICAgICAgY29weUNvbmZpZyhjLCB0aGlzKTtcbiAgICAgICAgYyA9IHByZXBhcmVDb25maWcoYyk7XG5cbiAgICAgICAgaWYgKGMuX2EpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGMuX2lzVVRDID8gY3JlYXRlVVRDKGMuX2EpIDogY3JlYXRlTG9jYWwoYy5fYSk7XG4gICAgICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSB0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgICAgIGNvbXBhcmVBcnJheXMoYy5fYSwgb3RoZXIudG9BcnJheSgpKSA+IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMb2NhbCAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/ICF0aGlzLl9pc1VUQyA6IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVXRjT2Zmc2V0ICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0YyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDICYmIHRoaXMuX29mZnNldCA9PT0gMCA6IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEFTUC5ORVQganNvbiBkYXRlIGZvcm1hdCByZWdleFxuICAgIHZhciBhc3BOZXRSZWdleCA9IC9eKFxcLXxcXCspPyg/OihcXGQqKVsuIF0pPyhcXGQrKVxcOihcXGQrKSg/OlxcOihcXGQrKShcXC5cXGQqKT8pPyQvO1xuXG4gICAgLy8gZnJvbSBodHRwOi8vZG9jcy5jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vZ2l0L2Nsb3N1cmVfZ29vZ19kYXRlX2RhdGUuanMuc291cmNlLmh0bWxcbiAgICAvLyBzb21ld2hhdCBtb3JlIGluIGxpbmUgd2l0aCA0LjQuMy4yIDIwMDQgc3BlYywgYnV0IGFsbG93cyBkZWNpbWFsIGFueXdoZXJlXG4gICAgLy8gYW5kIGZ1cnRoZXIgbW9kaWZpZWQgdG8gYWxsb3cgZm9yIHN0cmluZ3MgY29udGFpbmluZyBib3RoIHdlZWsgYW5kIGRheVxuICAgIHZhciBpc29SZWdleCA9IC9eKC18XFwrKT9QKD86KFstK10/WzAtOSwuXSopWSk/KD86KFstK10/WzAtOSwuXSopTSk/KD86KFstK10/WzAtOSwuXSopVyk/KD86KFstK10/WzAtOSwuXSopRCk/KD86VCg/OihbLStdP1swLTksLl0qKUgpPyg/OihbLStdP1swLTksLl0qKU0pPyg/OihbLStdP1swLTksLl0qKVMpPyk/JC87XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEdXJhdGlvbiAoaW5wdXQsIGtleSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBpbnB1dCxcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIGFnYWluc3QgcmVnZXhwIGlzIGV4cGVuc2l2ZSwgZG8gaXQgb24gZGVtYW5kXG4gICAgICAgICAgICBtYXRjaCA9IG51bGwsXG4gICAgICAgICAgICBzaWduLFxuICAgICAgICAgICAgcmV0LFxuICAgICAgICAgICAgZGlmZlJlcztcblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIG1zIDogaW5wdXQuX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgICAgICBkICA6IGlucHV0Ll9kYXlzLFxuICAgICAgICAgICAgICAgIE0gIDogaW5wdXQuX21vbnRoc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb25ba2V5XSA9IGlucHV0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbi5taWxsaXNlY29uZHMgPSBpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGFzcE5ldFJlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gJy0nKSA/IC0xIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHkgIDogMCxcbiAgICAgICAgICAgICAgICBkICA6IHRvSW50KG1hdGNoW0RBVEVdKSAgICAgICAgICAgICAgICAgICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgaCAgOiB0b0ludChtYXRjaFtIT1VSXSkgICAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIG0gIDogdG9JbnQobWF0Y2hbTUlOVVRFXSkgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBzICA6IHRvSW50KG1hdGNoW1NFQ09ORF0pICAgICAgICAgICAgICAgICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbXMgOiB0b0ludChhYnNSb3VuZChtYXRjaFtNSUxMSVNFQ09ORF0gKiAxMDAwKSkgKiBzaWduIC8vIHRoZSBtaWxsaXNlY29uZCBkZWNpbWFsIHBvaW50IGlzIGluY2x1ZGVkIGluIHRoZSBtYXRjaFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGlzb1JlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gJy0nKSA/IC0xIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHkgOiBwYXJzZUlzbyhtYXRjaFsyXSwgc2lnbiksXG4gICAgICAgICAgICAgICAgTSA6IHBhcnNlSXNvKG1hdGNoWzNdLCBzaWduKSxcbiAgICAgICAgICAgICAgICB3IDogcGFyc2VJc28obWF0Y2hbNF0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIGQgOiBwYXJzZUlzbyhtYXRjaFs1XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgaCA6IHBhcnNlSXNvKG1hdGNoWzZdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBtIDogcGFyc2VJc28obWF0Y2hbN10sIHNpZ24pLFxuICAgICAgICAgICAgICAgIHMgOiBwYXJzZUlzbyhtYXRjaFs4XSwgc2lnbilcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZHVyYXRpb24gPT0gbnVsbCkgey8vIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGR1cmF0aW9uID09PSAnb2JqZWN0JyAmJiAoJ2Zyb20nIGluIGR1cmF0aW9uIHx8ICd0bycgaW4gZHVyYXRpb24pKSB7XG4gICAgICAgICAgICBkaWZmUmVzID0gbW9tZW50c0RpZmZlcmVuY2UoY3JlYXRlTG9jYWwoZHVyYXRpb24uZnJvbSksIGNyZWF0ZUxvY2FsKGR1cmF0aW9uLnRvKSk7XG5cbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBkdXJhdGlvbi5tcyA9IGRpZmZSZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgZHVyYXRpb24uTSA9IGRpZmZSZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0ID0gbmV3IER1cmF0aW9uKGR1cmF0aW9uKTtcblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkgJiYgaGFzT3duUHJvcChpbnB1dCwgJ19sb2NhbGUnKSkge1xuICAgICAgICAgICAgcmV0Ll9sb2NhbGUgPSBpbnB1dC5fbG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBjcmVhdGVEdXJhdGlvbi5mbiA9IER1cmF0aW9uLnByb3RvdHlwZTtcbiAgICBjcmVhdGVEdXJhdGlvbi5pbnZhbGlkID0gY3JlYXRlSW52YWxpZCQxO1xuXG4gICAgZnVuY3Rpb24gcGFyc2VJc28gKGlucCwgc2lnbikge1xuICAgICAgICAvLyBXZSdkIG5vcm1hbGx5IHVzZSB+fmlucCBmb3IgdGhpcywgYnV0IHVuZm9ydHVuYXRlbHkgaXQgYWxzb1xuICAgICAgICAvLyBjb252ZXJ0cyBmbG9hdHMgdG8gaW50cy5cbiAgICAgICAgLy8gaW5wIG1heSBiZSB1bmRlZmluZWQsIHNvIGNhcmVmdWwgY2FsbGluZyByZXBsYWNlIG9uIGl0LlxuICAgICAgICB2YXIgcmVzID0gaW5wICYmIHBhcnNlRmxvYXQoaW5wLnJlcGxhY2UoJywnLCAnLicpKTtcbiAgICAgICAgLy8gYXBwbHkgc2lnbiB3aGlsZSB3ZSdyZSBhdCBpdFxuICAgICAgICByZXR1cm4gKGlzTmFOKHJlcykgPyAwIDogcmVzKSAqIHNpZ247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzID0ge307XG5cbiAgICAgICAgcmVzLm1vbnRocyA9IG90aGVyLm1vbnRoKCkgLSBiYXNlLm1vbnRoKCkgK1xuICAgICAgICAgICAgKG90aGVyLnllYXIoKSAtIGJhc2UueWVhcigpKSAqIDEyO1xuICAgICAgICBpZiAoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpLmlzQWZ0ZXIob3RoZXIpKSB7XG4gICAgICAgICAgICAtLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gK290aGVyIC0gKyhiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykpO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgaWYgKCEoYmFzZS5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHttaWxsaXNlY29uZHM6IDAsIG1vbnRoczogMH07XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlciA9IGNsb25lV2l0aE9mZnNldChvdGhlciwgYmFzZSk7XG4gICAgICAgIGlmIChiYXNlLmlzQmVmb3JlKG90aGVyKSkge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKG90aGVyLCBiYXNlKTtcbiAgICAgICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSAtcmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIHJlcy5tb250aHMgPSAtcmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogcmVtb3ZlICduYW1lJyBhcmcgYWZ0ZXIgZGVwcmVjYXRpb24gaXMgcmVtb3ZlZFxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFkZGVyKGRpcmVjdGlvbiwgbmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCwgcGVyaW9kKSB7XG4gICAgICAgICAgICB2YXIgZHVyLCB0bXA7XG4gICAgICAgICAgICAvL2ludmVydCB0aGUgYXJndW1lbnRzLCBidXQgY29tcGxhaW4gYWJvdXQgaXRcbiAgICAgICAgICAgIGlmIChwZXJpb2QgIT09IG51bGwgJiYgIWlzTmFOKCtwZXJpb2QpKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKG5hbWUsICdtb21lbnQoKS4nICsgbmFtZSAgKyAnKHBlcmlvZCwgbnVtYmVyKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIG1vbWVudCgpLicgKyBuYW1lICsgJyhudW1iZXIsIHBlcmlvZCkuICcgK1xuICAgICAgICAgICAgICAgICdTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9hZGQtaW52ZXJ0ZWQtcGFyYW0vIGZvciBtb3JlIGluZm8uJyk7XG4gICAgICAgICAgICAgICAgdG1wID0gdmFsOyB2YWwgPSBwZXJpb2Q7IHBlcmlvZCA9IHRtcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyArdmFsIDogdmFsO1xuICAgICAgICAgICAgZHVyID0gY3JlYXRlRHVyYXRpb24odmFsLCBwZXJpb2QpO1xuICAgICAgICAgICAgYWRkU3VidHJhY3QodGhpcywgZHVyLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkU3VidHJhY3QgKG1vbSwgZHVyYXRpb24sIGlzQWRkaW5nLCB1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IGR1cmF0aW9uLl9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICBkYXlzID0gYWJzUm91bmQoZHVyYXRpb24uX2RheXMpLFxuICAgICAgICAgICAgbW9udGhzID0gYWJzUm91bmQoZHVyYXRpb24uX21vbnRocyk7XG5cbiAgICAgICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAvLyBObyBvcFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlT2Zmc2V0ID0gdXBkYXRlT2Zmc2V0ID09IG51bGwgPyB0cnVlIDogdXBkYXRlT2Zmc2V0O1xuXG4gICAgICAgIGlmIChtb250aHMpIHtcbiAgICAgICAgICAgIHNldE1vbnRoKG1vbSwgZ2V0KG1vbSwgJ01vbnRoJykgKyBtb250aHMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRheXMpIHtcbiAgICAgICAgICAgIHNldCQxKG1vbSwgJ0RhdGUnLCBnZXQobW9tLCAnRGF0ZScpICsgZGF5cyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWlsbGlzZWNvbmRzKSB7XG4gICAgICAgICAgICBtb20uX2Quc2V0VGltZShtb20uX2QudmFsdWVPZigpICsgbWlsbGlzZWNvbmRzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldChtb20sIGRheXMgfHwgbW9udGhzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhZGQgICAgICA9IGNyZWF0ZUFkZGVyKDEsICdhZGQnKTtcbiAgICB2YXIgc3VidHJhY3QgPSBjcmVhdGVBZGRlcigtMSwgJ3N1YnRyYWN0Jyk7XG5cbiAgICBmdW5jdGlvbiBnZXRDYWxlbmRhckZvcm1hdChteU1vbWVudCwgbm93KSB7XG4gICAgICAgIHZhciBkaWZmID0gbXlNb21lbnQuZGlmZihub3csICdkYXlzJywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBkaWZmIDwgLTYgPyAnc2FtZUVsc2UnIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgLTEgPyAnbGFzdFdlZWsnIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgMCA/ICdsYXN0RGF5JyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDEgPyAnc2FtZURheScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAyID8gJ25leHREYXknIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgNyA/ICduZXh0V2VlaycgOiAnc2FtZUVsc2UnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGVuZGFyJDEgKHRpbWUsIGZvcm1hdHMpIHtcbiAgICAgICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cbiAgICAgICAgLy8gR2V0dGluZyBzdGFydC1vZi10b2RheSBkZXBlbmRzIG9uIHdoZXRoZXIgd2UncmUgbG9jYWwvdXRjL29mZnNldCBvciBub3QuXG4gICAgICAgIHZhciBub3cgPSB0aW1lIHx8IGNyZWF0ZUxvY2FsKCksXG4gICAgICAgICAgICBzb2QgPSBjbG9uZVdpdGhPZmZzZXQobm93LCB0aGlzKS5zdGFydE9mKCdkYXknKSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGhvb2tzLmNhbGVuZGFyRm9ybWF0KHRoaXMsIHNvZCkgfHwgJ3NhbWVFbHNlJztcblxuICAgICAgICB2YXIgb3V0cHV0ID0gZm9ybWF0cyAmJiAoaXNGdW5jdGlvbihmb3JtYXRzW2Zvcm1hdF0pID8gZm9ybWF0c1tmb3JtYXRdLmNhbGwodGhpcywgbm93KSA6IGZvcm1hdHNbZm9ybWF0XSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KG91dHB1dCB8fCB0aGlzLmxvY2FsZURhdGEoKS5jYWxlbmRhcihmb3JtYXQsIHRoaXMsIGNyZWF0ZUxvY2FsKG5vdykpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTW9tZW50KHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQWZ0ZXIgKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB8fCAnbWlsbGlzZWNvbmQnO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA+IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsSW5wdXQudmFsdWVPZigpIDwgdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQmVmb3JlIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cykgfHwgJ21pbGxpc2Vjb25kJztcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPCBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNCZXR3ZWVuIChmcm9tLCB0bywgdW5pdHMsIGluY2x1c2l2aXR5KSB7XG4gICAgICAgIHZhciBsb2NhbEZyb20gPSBpc01vbWVudChmcm9tKSA/IGZyb20gOiBjcmVhdGVMb2NhbChmcm9tKSxcbiAgICAgICAgICAgIGxvY2FsVG8gPSBpc01vbWVudCh0bykgPyB0byA6IGNyZWF0ZUxvY2FsKHRvKTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxGcm9tLmlzVmFsaWQoKSAmJiBsb2NhbFRvLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpbmNsdXNpdml0eSA9IGluY2x1c2l2aXR5IHx8ICcoKSc7XG4gICAgICAgIHJldHVybiAoaW5jbHVzaXZpdHlbMF0gPT09ICcoJyA/IHRoaXMuaXNBZnRlcihsb2NhbEZyb20sIHVuaXRzKSA6ICF0aGlzLmlzQmVmb3JlKGxvY2FsRnJvbSwgdW5pdHMpKSAmJlxuICAgICAgICAgICAgKGluY2x1c2l2aXR5WzFdID09PSAnKScgPyB0aGlzLmlzQmVmb3JlKGxvY2FsVG8sIHVuaXRzKSA6ICF0aGlzLmlzQWZ0ZXIobG9jYWxUbywgdW5pdHMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1NhbWUgKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpLFxuICAgICAgICAgICAgaW5wdXRNcztcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cykgfHwgJ21pbGxpc2Vjb25kJztcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPT09IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRNcyA9IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCkgPD0gaW5wdXRNcyAmJiBpbnB1dE1zIDw9IHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lT3JBZnRlciAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNBZnRlcihpbnB1dCwgdW5pdHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQmVmb3JlIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0JlZm9yZShpbnB1dCwgdW5pdHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpZmYgKGlucHV0LCB1bml0cywgYXNGbG9hdCkge1xuICAgICAgICB2YXIgdGhhdCxcbiAgICAgICAgICAgIHpvbmVEZWx0YSxcbiAgICAgICAgICAgIG91dHB1dDtcblxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhhdCA9IGNsb25lV2l0aE9mZnNldChpbnB1dCwgdGhpcyk7XG5cbiAgICAgICAgaWYgKCF0aGF0LmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIHpvbmVEZWx0YSA9ICh0aGF0LnV0Y09mZnNldCgpIC0gdGhpcy51dGNPZmZzZXQoKSkgKiA2ZTQ7XG5cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6IG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KSAvIDEyOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzogb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOiBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAzOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyAxZTM7IGJyZWFrOyAvLyAxMDAwXG4gICAgICAgICAgICBjYXNlICdtaW51dGUnOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gNmU0OyBicmVhazsgLy8gMTAwMCAqIDYwXG4gICAgICAgICAgICBjYXNlICdob3VyJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDM2ZTU7IGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MFxuICAgICAgICAgICAgY2FzZSAnZGF5Jzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0IC0gem9uZURlbHRhKSAvIDg2NGU1OyBicmVhazsgLy8gMTAwMCAqIDYwICogNjAgKiAyNCwgbmVnYXRlIGRzdFxuICAgICAgICAgICAgY2FzZSAnd2Vlayc6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCAtIHpvbmVEZWx0YSkgLyA2MDQ4ZTU7IGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MCAqIDI0ICogNywgbmVnYXRlIGRzdFxuICAgICAgICAgICAgZGVmYXVsdDogb3V0cHV0ID0gdGhpcyAtIHRoYXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXNGbG9hdCA/IG91dHB1dCA6IGFic0Zsb29yKG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhEaWZmIChhLCBiKSB7XG4gICAgICAgIC8vIGRpZmZlcmVuY2UgaW4gbW9udGhzXG4gICAgICAgIHZhciB3aG9sZU1vbnRoRGlmZiA9ICgoYi55ZWFyKCkgLSBhLnllYXIoKSkgKiAxMikgKyAoYi5tb250aCgpIC0gYS5tb250aCgpKSxcbiAgICAgICAgICAgIC8vIGIgaXMgaW4gKGFuY2hvciAtIDEgbW9udGgsIGFuY2hvciArIDEgbW9udGgpXG4gICAgICAgICAgICBhbmNob3IgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmLCAnbW9udGhzJyksXG4gICAgICAgICAgICBhbmNob3IyLCBhZGp1c3Q7XG5cbiAgICAgICAgaWYgKGIgLSBhbmNob3IgPCAwKSB7XG4gICAgICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiAtIDEsICdtb250aHMnKTtcbiAgICAgICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXG4gICAgICAgICAgICBhZGp1c3QgPSAoYiAtIGFuY2hvcikgLyAoYW5jaG9yIC0gYW5jaG9yMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiArIDEsICdtb250aHMnKTtcbiAgICAgICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXG4gICAgICAgICAgICBhZGp1c3QgPSAoYiAtIGFuY2hvcikgLyAoYW5jaG9yMiAtIGFuY2hvcik7XG4gICAgICAgIH1cblxuICAgICAgICAvL2NoZWNrIGZvciBuZWdhdGl2ZSB6ZXJvLCByZXR1cm4gemVybyBpZiBuZWdhdGl2ZSB6ZXJvXG4gICAgICAgIHJldHVybiAtKHdob2xlTW9udGhEaWZmICsgYWRqdXN0KSB8fCAwO1xuICAgIH1cblxuICAgIGhvb2tzLmRlZmF1bHRGb3JtYXQgPSAnWVlZWS1NTS1ERFRISDptbTpzc1onO1xuICAgIGhvb2tzLmRlZmF1bHRGb3JtYXRVdGMgPSAnWVlZWS1NTS1ERFRISDptbTpzc1taXSc7XG5cbiAgICBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkubG9jYWxlKCdlbicpLmZvcm1hdCgnZGRkIE1NTSBERCBZWVlZIEhIOm1tOnNzIFtHTVRdWlonKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0lTT1N0cmluZyhrZWVwT2Zmc2V0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1dGMgPSBrZWVwT2Zmc2V0ICE9PSB0cnVlO1xuICAgICAgICB2YXIgbSA9IHV0YyA/IHRoaXMuY2xvbmUoKS51dGMoKSA6IHRoaXM7XG4gICAgICAgIGlmIChtLnllYXIoKSA8IDAgfHwgbS55ZWFyKCkgPiA5OTk5KSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sIHV0YyA/ICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nIDogJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1onKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNGdW5jdGlvbihEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZykpIHtcbiAgICAgICAgICAgIC8vIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBpcyB+NTB4IGZhc3RlciwgdXNlIGl0IHdoZW4gd2UgY2FuXG4gICAgICAgICAgICBpZiAodXRjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9EYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpICsgdGhpcy51dGNPZmZzZXQoKSAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKS5yZXBsYWNlKCdaJywgZm9ybWF0TW9tZW50KG0sICdaJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgdXRjID8gJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nIDogJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NaJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgaHVtYW4gcmVhZGFibGUgcmVwcmVzZW50YXRpb24gb2YgYSBtb21lbnQgdGhhdCBjYW5cbiAgICAgKiBhbHNvIGJlIGV2YWx1YXRlZCB0byBnZXQgYSBuZXcgbW9tZW50IHdoaWNoIGlzIHRoZSBzYW1lXG4gICAgICpcbiAgICAgKiBAbGluayBodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QvZG9jcy9hcGkvdXRpbC5odG1sI3V0aWxfY3VzdG9tX2luc3BlY3RfZnVuY3Rpb25fb25fb2JqZWN0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ21vbWVudC5pbnZhbGlkKC8qICcgKyB0aGlzLl9pICsgJyAqLyknO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmdW5jID0gJ21vbWVudCc7XG4gICAgICAgIHZhciB6b25lID0gJyc7XG4gICAgICAgIGlmICghdGhpcy5pc0xvY2FsKCkpIHtcbiAgICAgICAgICAgIGZ1bmMgPSB0aGlzLnV0Y09mZnNldCgpID09PSAwID8gJ21vbWVudC51dGMnIDogJ21vbWVudC5wYXJzZVpvbmUnO1xuICAgICAgICAgICAgem9uZSA9ICdaJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJlZml4ID0gJ1snICsgZnVuYyArICcoXCJdJztcbiAgICAgICAgdmFyIHllYXIgPSAoMCA8PSB0aGlzLnllYXIoKSAmJiB0aGlzLnllYXIoKSA8PSA5OTk5KSA/ICdZWVlZJyA6ICdZWVlZWVknO1xuICAgICAgICB2YXIgZGF0ZXRpbWUgPSAnLU1NLUREW1RdSEg6bW06c3MuU1NTJztcbiAgICAgICAgdmFyIHN1ZmZpeCA9IHpvbmUgKyAnW1wiKV0nO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChwcmVmaXggKyB5ZWFyICsgZGF0ZXRpbWUgKyBzdWZmaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdCAoaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgaWYgKCFpbnB1dFN0cmluZykge1xuICAgICAgICAgICAgaW5wdXRTdHJpbmcgPSB0aGlzLmlzVXRjKCkgPyBob29rcy5kZWZhdWx0Rm9ybWF0VXRjIDogaG9va3MuZGVmYXVsdEZvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0cHV0ID0gZm9ybWF0TW9tZW50KHRoaXMsIGlucHV0U3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8XG4gICAgICAgICAgICAgICAgIGNyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7dG86IHRoaXMsIGZyb206IHRpbWV9KS5sb2NhbGUodGhpcy5sb2NhbGUoKSkuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb20oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG8gKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHxcbiAgICAgICAgICAgICAgICAgY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHtmcm9tOiB0aGlzLCB0bzogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvKGNyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xuICAgIH1cblxuICAgIC8vIElmIHBhc3NlZCBhIGxvY2FsZSBrZXksIGl0IHdpbGwgc2V0IHRoZSBsb2NhbGUgZm9yIHRoaXNcbiAgICAvLyBpbnN0YW5jZS4gIE90aGVyd2lzZSwgaXQgd2lsbCByZXR1cm4gdGhlIGxvY2FsZSBjb25maWd1cmF0aW9uXG4gICAgLy8gdmFyaWFibGVzIGZvciB0aGlzIGluc3RhbmNlLlxuICAgIGZ1bmN0aW9uIGxvY2FsZSAoa2V5KSB7XG4gICAgICAgIHZhciBuZXdMb2NhbGVEYXRhO1xuXG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0xvY2FsZURhdGEgPSBnZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChuZXdMb2NhbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBuZXdMb2NhbGVEYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGFuZyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCgpLmxhbmcoKSBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2UgbW9tZW50KCkubG9jYWxlRGF0YSgpIHRvIGdldCB0aGUgbGFuZ3VhZ2UgY29uZmlndXJhdGlvbi4gVXNlIG1vbWVudCgpLmxvY2FsZSgpIHRvIGNoYW5nZSBsYW5ndWFnZXMuJyxcbiAgICAgICAgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVEYXRhICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZTtcbiAgICB9XG5cbiAgICB2YXIgTVNfUEVSX1NFQ09ORCA9IDEwMDA7XG4gICAgdmFyIE1TX1BFUl9NSU5VVEUgPSA2MCAqIE1TX1BFUl9TRUNPTkQ7XG4gICAgdmFyIE1TX1BFUl9IT1VSID0gNjAgKiBNU19QRVJfTUlOVVRFO1xuICAgIHZhciBNU19QRVJfNDAwX1lFQVJTID0gKDM2NSAqIDQwMCArIDk3KSAqIDI0ICogTVNfUEVSX0hPVVI7XG5cbiAgICAvLyBhY3R1YWwgbW9kdWxvIC0gaGFuZGxlcyBuZWdhdGl2ZSBudW1iZXJzIChmb3IgZGF0ZXMgYmVmb3JlIDE5NzApOlxuICAgIGZ1bmN0aW9uIG1vZCQxKGRpdmlkZW5kLCBkaXZpc29yKSB7XG4gICAgICAgIHJldHVybiAoZGl2aWRlbmQgJSBkaXZpc29yICsgZGl2aXNvcikgJSBkaXZpc29yO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsU3RhcnRPZkRhdGUoeSwgbSwgZCkge1xuICAgICAgICAvLyB0aGUgZGF0ZSBjb25zdHJ1Y3RvciByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHkgKyA0MDAsIG0sIGQpIC0gTVNfUEVSXzQwMF9ZRUFSUztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh5LCBtLCBkKS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1dGNTdGFydE9mRGF0ZSh5LCBtLCBkKSB7XG4gICAgICAgIC8vIERhdGUuVVRDIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDApIHtcbiAgICAgICAgICAgIC8vIHByZXNlcnZlIGxlYXAgeWVhcnMgdXNpbmcgYSBmdWxsIDQwMCB5ZWFyIGN5Y2xlLCB0aGVuIHJlc2V0XG4gICAgICAgICAgICByZXR1cm4gRGF0ZS5VVEMoeSArIDQwMCwgbSwgZCkgLSBNU19QRVJfNDAwX1lFQVJTO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIERhdGUuVVRDKHksIG0sIGQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhcnRPZiAodW5pdHMpIHtcbiAgICAgICAgdmFyIHRpbWU7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICBpZiAodW5pdHMgPT09IHVuZGVmaW5lZCB8fCB1bml0cyA9PT0gJ21pbGxpc2Vjb25kJyB8fCAhdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YXJ0T2ZEYXRlID0gdGhpcy5faXNVVEMgPyB1dGNTdGFydE9mRGF0ZSA6IGxvY2FsU3RhcnRPZkRhdGU7XG5cbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCAwLCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpIC0gdGhpcy5tb250aCgpICUgMywgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpIC0gdGhpcy53ZWVrZGF5KCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpIC0gKHRoaXMuaXNvV2Vla2RheSgpIC0gMSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSAtPSBtb2QkMSh0aW1lICsgKHRoaXMuX2lzVVRDID8gMCA6IHRoaXMudXRjT2Zmc2V0KCkgKiBNU19QRVJfTUlOVVRFKSwgTVNfUEVSX0hPVVIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSAtPSBtb2QkMSh0aW1lLCBNU19QRVJfTUlOVVRFKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgLT0gbW9kJDEodGltZSwgTVNfUEVSX1NFQ09ORCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kLnNldFRpbWUodGltZSk7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5kT2YgKHVuaXRzKSB7XG4gICAgICAgIHZhciB0aW1lO1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcgfHwgIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGFydE9mRGF0ZSA9IHRoaXMuX2lzVVRDID8gdXRjU3RhcnRPZkRhdGUgOiBsb2NhbFN0YXJ0T2ZEYXRlO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSArIDEsIDAsIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpIC0gdGhpcy5tb250aCgpICUgMyArIDMsIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSArIDEsIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSAtIHRoaXMud2Vla2RheSgpICsgNykgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpIC0gKHRoaXMuaXNvV2Vla2RheSgpIC0gMSkgKyA3KSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpICsgMSkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX0hPVVIgLSBtb2QkMSh0aW1lICsgKHRoaXMuX2lzVVRDID8gMCA6IHRoaXMudXRjT2Zmc2V0KCkgKiBNU19QRVJfTUlOVVRFKSwgTVNfUEVSX0hPVVIpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX01JTlVURSAtIG1vZCQxKHRpbWUsIE1TX1BFUl9NSU5VVEUpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX1NFQ09ORCAtIG1vZCQxKHRpbWUsIE1TX1BFUl9TRUNPTkQpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2Quc2V0VGltZSh0aW1lKTtcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWx1ZU9mICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2QudmFsdWVPZigpIC0gKCh0aGlzLl9vZmZzZXQgfHwgMCkgKiA2MDAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5peCAoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMudmFsdWVPZigpIC8gMTAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9EYXRlICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0FycmF5ICgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW20ueWVhcigpLCBtLm1vbnRoKCksIG0uZGF0ZSgpLCBtLmhvdXIoKSwgbS5taW51dGUoKSwgbS5zZWNvbmQoKSwgbS5taWxsaXNlY29uZCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b09iamVjdCAoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXJzOiBtLnllYXIoKSxcbiAgICAgICAgICAgIG1vbnRoczogbS5tb250aCgpLFxuICAgICAgICAgICAgZGF0ZTogbS5kYXRlKCksXG4gICAgICAgICAgICBob3VyczogbS5ob3VycygpLFxuICAgICAgICAgICAgbWludXRlczogbS5taW51dGVzKCksXG4gICAgICAgICAgICBzZWNvbmRzOiBtLnNlY29uZHMoKSxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kczogbS5taWxsaXNlY29uZHMoKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gICAgICAgIC8vIG5ldyBEYXRlKE5hTikudG9KU09OKCkgPT09IG51bGxcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy50b0lTT1N0cmluZygpIDogbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkJDIgKCkge1xuICAgICAgICByZXR1cm4gaXNWYWxpZCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzaW5nRmxhZ3MgKCkge1xuICAgICAgICByZXR1cm4gZXh0ZW5kKHt9LCBnZXRQYXJzaW5nRmxhZ3ModGhpcykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludmFsaWRBdCAoKSB7XG4gICAgICAgIHJldHVybiBnZXRQYXJzaW5nRmxhZ3ModGhpcykub3ZlcmZsb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRpb25EYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5wdXQ6IHRoaXMuX2ksXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuX2YsXG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMuX2xvY2FsZSxcbiAgICAgICAgICAgIGlzVVRDOiB0aGlzLl9pc1VUQyxcbiAgICAgICAgICAgIHN0cmljdDogdGhpcy5fc3RyaWN0XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydnZycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndlZWtZZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ0dHJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNvV2Vla1llYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4gKHRva2VuLCBnZXR0ZXIpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgW3Rva2VuLCB0b2tlbi5sZW5ndGhdLCAwLCBnZXR0ZXIpO1xuICAgIH1cblxuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2cnLCAgICAgJ3dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZ2cnLCAgICAnd2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHJywgICdpc29XZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0dHJywgJ2lzb1dlZWtZZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWtZZWFyJywgJ2dnJyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrWWVhcicsICdHRycpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnd2Vla1llYXInLCAxKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtZZWFyJywgMSk7XG5cblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0cnLCAgICAgIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdnJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignR0cnLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHR0dHJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICBhZGRSZWdleFRva2VuKCdnZ2dnZycsICBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2dnZ2cnLCAnZ2dnZ2cnLCAnR0dHRycsICdHR0dHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMildID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZycsICdHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrWWVhciAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGdldFNldFdlZWtZZWFySGVscGVyLmNhbGwodGhpcyxcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICB0aGlzLndlZWsoKSxcbiAgICAgICAgICAgICAgICB0aGlzLndlZWtkYXkoKSxcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3csXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG95KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09XZWVrWWVhciAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGdldFNldFdlZWtZZWFySGVscGVyLmNhbGwodGhpcyxcbiAgICAgICAgICAgICAgICBpbnB1dCwgdGhpcy5pc29XZWVrKCksIHRoaXMuaXNvV2Vla2RheSgpLCAxLCA0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJU09XZWVrc0luWWVhciAoKSB7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgMSwgNCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2Vla3NJblllYXIgKCkge1xuICAgICAgICB2YXIgd2Vla0luZm8gPSB0aGlzLmxvY2FsZURhdGEoKS5fd2VlaztcbiAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCB3ZWVrSW5mby5kb3csIHdlZWtJbmZvLmRveSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXJIZWxwZXIoaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrc1RhcmdldDtcbiAgICAgICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKHRoaXMsIGRvdywgZG95KS55ZWFyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2Vla3NUYXJnZXQgPSB3ZWVrc0luWWVhcihpbnB1dCwgZG93LCBkb3kpO1xuICAgICAgICAgICAgaWYgKHdlZWsgPiB3ZWVrc1RhcmdldCkge1xuICAgICAgICAgICAgICAgIHdlZWsgPSB3ZWVrc1RhcmdldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZXRXZWVrQWxsLmNhbGwodGhpcywgaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFdlZWtBbGwod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciBkYXlPZlllYXJEYXRhID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSksXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZShkYXlPZlllYXJEYXRhLnllYXIsIDAsIGRheU9mWWVhckRhdGEuZGF5T2ZZZWFyKTtcblxuICAgICAgICB0aGlzLnllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpKTtcbiAgICAgICAgdGhpcy5tb250aChkYXRlLmdldFVUQ01vbnRoKCkpO1xuICAgICAgICB0aGlzLmRhdGUoZGF0ZS5nZXRVVENEYXRlKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignUScsIDAsICdRbycsICdxdWFydGVyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3F1YXJ0ZXInLCAnUScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgncXVhcnRlcicsIDcpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignUScsIG1hdGNoMSk7XG4gICAgYWRkUGFyc2VUb2tlbignUScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTU9OVEhdID0gKHRvSW50KGlucHV0KSAtIDEpICogMztcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFF1YXJ0ZXIgKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gTWF0aC5jZWlsKCh0aGlzLm1vbnRoKCkgKyAxKSAvIDMpIDogdGhpcy5tb250aCgoaW5wdXQgLSAxKSAqIDMgKyB0aGlzLm1vbnRoKCkgJSAzKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignRCcsIFsnREQnLCAyXSwgJ0RvJywgJ2RhdGUnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF0ZScsICdEJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF0ZScsIDkpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignRCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0REJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIFwib3JkaW5hbFBhcnNlXCIgZmFsbGJhY2sgaW4gbmV4dCBtYWpvciByZWxlYXNlLlxuICAgICAgICByZXR1cm4gaXNTdHJpY3QgP1xuICAgICAgICAgIChsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2UgfHwgbG9jYWxlLl9vcmRpbmFsUGFyc2UpIDpcbiAgICAgICAgICBsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2VMZW5pZW50O1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0QnLCAnREQnXSwgREFURSk7XG4gICAgYWRkUGFyc2VUb2tlbignRG8nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W0RBVEVdID0gdG9JbnQoaW5wdXQubWF0Y2gobWF0Y2gxdG8yKVswXSk7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0RGF5T2ZNb250aCA9IG1ha2VHZXRTZXQoJ0RhdGUnLCB0cnVlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdEREQnLCBbJ0REREQnLCAzXSwgJ0RERG8nLCAnZGF5T2ZZZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RheU9mWWVhcicsICdEREQnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdkYXlPZlllYXInLCA0KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0RERCcsICBtYXRjaDF0bzMpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0REREQnLCBtYXRjaDMpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydEREQnLCAnRERERCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZlllYXIgKGlucHV0KSB7XG4gICAgICAgIHZhciBkYXlPZlllYXIgPSBNYXRoLnJvdW5kKCh0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykgLSB0aGlzLmNsb25lKCkuc3RhcnRPZigneWVhcicpKSAvIDg2NGU1KSArIDE7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gZGF5T2ZZZWFyIDogdGhpcy5hZGQoKGlucHV0IC0gZGF5T2ZZZWFyKSwgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignbScsIFsnbW0nLCAyXSwgMCwgJ21pbnV0ZScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaW51dGUnLCAnbScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbWludXRlJywgMTQpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignbScsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ21tJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydtJywgJ21tJ10sIE1JTlVURSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0TWludXRlID0gbWFrZUdldFNldCgnTWludXRlcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdzJywgWydzcycsIDJdLCAwLCAnc2Vjb25kJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3NlY29uZCcsICdzJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdzZWNvbmQnLCAxNSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdzJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignc3MnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ3MnLCAnc3MnXSwgU0VDT05EKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRTZWNvbmQgPSBtYWtlR2V0U2V0KCdTZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMDApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTUycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTUycsIDNdLCAwLCAnbWlsbGlzZWNvbmQnKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1MnLCA0XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTUycsIDVdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1MnLCA2XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1MnLCA3XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTUycsIDhdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTU1MnLCA5XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwMDtcbiAgICB9KTtcblxuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaWxsaXNlY29uZCcsICdtcycpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbWlsbGlzZWNvbmQnLCAxNik7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdTJywgICAgbWF0Y2gxdG8zLCBtYXRjaDEpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1NTJywgICBtYXRjaDF0bzMsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignU1NTJywgIG1hdGNoMXRvMywgbWF0Y2gzKTtcblxuICAgIHZhciB0b2tlbjtcbiAgICBmb3IgKHRva2VuID0gJ1NTU1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgICAgIGFkZFJlZ2V4VG9rZW4odG9rZW4sIG1hdGNoVW5zaWduZWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTXMoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01JTExJU0VDT05EXSA9IHRvSW50KCgnMC4nICsgaW5wdXQpICogMTAwMCk7XG4gICAgfVxuXG4gICAgZm9yICh0b2tlbiA9ICdTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBwYXJzZU1zKTtcbiAgICB9XG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldE1pbGxpc2Vjb25kID0gbWFrZUdldFNldCgnTWlsbGlzZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3onLCAgMCwgMCwgJ3pvbmVBYmJyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3p6JywgMCwgMCwgJ3pvbmVOYW1lJyk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRab25lQWJiciAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdVVEMnIDogJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Wm9uZU5hbWUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnQ29vcmRpbmF0ZWQgVW5pdmVyc2FsIFRpbWUnIDogJyc7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvID0gTW9tZW50LnByb3RvdHlwZTtcblxuICAgIHByb3RvLmFkZCAgICAgICAgICAgICAgID0gYWRkO1xuICAgIHByb3RvLmNhbGVuZGFyICAgICAgICAgID0gY2FsZW5kYXIkMTtcbiAgICBwcm90by5jbG9uZSAgICAgICAgICAgICA9IGNsb25lO1xuICAgIHByb3RvLmRpZmYgICAgICAgICAgICAgID0gZGlmZjtcbiAgICBwcm90by5lbmRPZiAgICAgICAgICAgICA9IGVuZE9mO1xuICAgIHByb3RvLmZvcm1hdCAgICAgICAgICAgID0gZm9ybWF0O1xuICAgIHByb3RvLmZyb20gICAgICAgICAgICAgID0gZnJvbTtcbiAgICBwcm90by5mcm9tTm93ICAgICAgICAgICA9IGZyb21Ob3c7XG4gICAgcHJvdG8udG8gICAgICAgICAgICAgICAgPSB0bztcbiAgICBwcm90by50b05vdyAgICAgICAgICAgICA9IHRvTm93O1xuICAgIHByb3RvLmdldCAgICAgICAgICAgICAgID0gc3RyaW5nR2V0O1xuICAgIHByb3RvLmludmFsaWRBdCAgICAgICAgID0gaW52YWxpZEF0O1xuICAgIHByb3RvLmlzQWZ0ZXIgICAgICAgICAgID0gaXNBZnRlcjtcbiAgICBwcm90by5pc0JlZm9yZSAgICAgICAgICA9IGlzQmVmb3JlO1xuICAgIHByb3RvLmlzQmV0d2VlbiAgICAgICAgID0gaXNCZXR3ZWVuO1xuICAgIHByb3RvLmlzU2FtZSAgICAgICAgICAgID0gaXNTYW1lO1xuICAgIHByb3RvLmlzU2FtZU9yQWZ0ZXIgICAgID0gaXNTYW1lT3JBZnRlcjtcbiAgICBwcm90by5pc1NhbWVPckJlZm9yZSAgICA9IGlzU2FtZU9yQmVmb3JlO1xuICAgIHByb3RvLmlzVmFsaWQgICAgICAgICAgID0gaXNWYWxpZCQyO1xuICAgIHByb3RvLmxhbmcgICAgICAgICAgICAgID0gbGFuZztcbiAgICBwcm90by5sb2NhbGUgICAgICAgICAgICA9IGxvY2FsZTtcbiAgICBwcm90by5sb2NhbGVEYXRhICAgICAgICA9IGxvY2FsZURhdGE7XG4gICAgcHJvdG8ubWF4ICAgICAgICAgICAgICAgPSBwcm90b3R5cGVNYXg7XG4gICAgcHJvdG8ubWluICAgICAgICAgICAgICAgPSBwcm90b3R5cGVNaW47XG4gICAgcHJvdG8ucGFyc2luZ0ZsYWdzICAgICAgPSBwYXJzaW5nRmxhZ3M7XG4gICAgcHJvdG8uc2V0ICAgICAgICAgICAgICAgPSBzdHJpbmdTZXQ7XG4gICAgcHJvdG8uc3RhcnRPZiAgICAgICAgICAgPSBzdGFydE9mO1xuICAgIHByb3RvLnN1YnRyYWN0ICAgICAgICAgID0gc3VidHJhY3Q7XG4gICAgcHJvdG8udG9BcnJheSAgICAgICAgICAgPSB0b0FycmF5O1xuICAgIHByb3RvLnRvT2JqZWN0ICAgICAgICAgID0gdG9PYmplY3Q7XG4gICAgcHJvdG8udG9EYXRlICAgICAgICAgICAgPSB0b0RhdGU7XG4gICAgcHJvdG8udG9JU09TdHJpbmcgICAgICAgPSB0b0lTT1N0cmluZztcbiAgICBwcm90by5pbnNwZWN0ICAgICAgICAgICA9IGluc3BlY3Q7XG4gICAgcHJvdG8udG9KU09OICAgICAgICAgICAgPSB0b0pTT047XG4gICAgcHJvdG8udG9TdHJpbmcgICAgICAgICAgPSB0b1N0cmluZztcbiAgICBwcm90by51bml4ICAgICAgICAgICAgICA9IHVuaXg7XG4gICAgcHJvdG8udmFsdWVPZiAgICAgICAgICAgPSB2YWx1ZU9mO1xuICAgIHByb3RvLmNyZWF0aW9uRGF0YSAgICAgID0gY3JlYXRpb25EYXRhO1xuICAgIHByb3RvLnllYXIgICAgICAgPSBnZXRTZXRZZWFyO1xuICAgIHByb3RvLmlzTGVhcFllYXIgPSBnZXRJc0xlYXBZZWFyO1xuICAgIHByb3RvLndlZWtZZWFyICAgID0gZ2V0U2V0V2Vla1llYXI7XG4gICAgcHJvdG8uaXNvV2Vla1llYXIgPSBnZXRTZXRJU09XZWVrWWVhcjtcbiAgICBwcm90by5xdWFydGVyID0gcHJvdG8ucXVhcnRlcnMgPSBnZXRTZXRRdWFydGVyO1xuICAgIHByb3RvLm1vbnRoICAgICAgID0gZ2V0U2V0TW9udGg7XG4gICAgcHJvdG8uZGF5c0luTW9udGggPSBnZXREYXlzSW5Nb250aDtcbiAgICBwcm90by53ZWVrICAgICAgICAgICA9IHByb3RvLndlZWtzICAgICAgICA9IGdldFNldFdlZWs7XG4gICAgcHJvdG8uaXNvV2VlayAgICAgICAgPSBwcm90by5pc29XZWVrcyAgICAgPSBnZXRTZXRJU09XZWVrO1xuICAgIHByb3RvLndlZWtzSW5ZZWFyICAgID0gZ2V0V2Vla3NJblllYXI7XG4gICAgcHJvdG8uaXNvV2Vla3NJblllYXIgPSBnZXRJU09XZWVrc0luWWVhcjtcbiAgICBwcm90by5kYXRlICAgICAgID0gZ2V0U2V0RGF5T2ZNb250aDtcbiAgICBwcm90by5kYXkgICAgICAgID0gcHJvdG8uZGF5cyAgICAgICAgICAgICA9IGdldFNldERheU9mV2VlaztcbiAgICBwcm90by53ZWVrZGF5ICAgID0gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrO1xuICAgIHByb3RvLmlzb1dlZWtkYXkgPSBnZXRTZXRJU09EYXlPZldlZWs7XG4gICAgcHJvdG8uZGF5T2ZZZWFyICA9IGdldFNldERheU9mWWVhcjtcbiAgICBwcm90by5ob3VyID0gcHJvdG8uaG91cnMgPSBnZXRTZXRIb3VyO1xuICAgIHByb3RvLm1pbnV0ZSA9IHByb3RvLm1pbnV0ZXMgPSBnZXRTZXRNaW51dGU7XG4gICAgcHJvdG8uc2Vjb25kID0gcHJvdG8uc2Vjb25kcyA9IGdldFNldFNlY29uZDtcbiAgICBwcm90by5taWxsaXNlY29uZCA9IHByb3RvLm1pbGxpc2Vjb25kcyA9IGdldFNldE1pbGxpc2Vjb25kO1xuICAgIHByb3RvLnV0Y09mZnNldCAgICAgICAgICAgID0gZ2V0U2V0T2Zmc2V0O1xuICAgIHByb3RvLnV0YyAgICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9VVEM7XG4gICAgcHJvdG8ubG9jYWwgICAgICAgICAgICAgICAgPSBzZXRPZmZzZXRUb0xvY2FsO1xuICAgIHByb3RvLnBhcnNlWm9uZSAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQ7XG4gICAgcHJvdG8uaGFzQWxpZ25lZEhvdXJPZmZzZXQgPSBoYXNBbGlnbmVkSG91ck9mZnNldDtcbiAgICBwcm90by5pc0RTVCAgICAgICAgICAgICAgICA9IGlzRGF5bGlnaHRTYXZpbmdUaW1lO1xuICAgIHByb3RvLmlzTG9jYWwgICAgICAgICAgICAgID0gaXNMb2NhbDtcbiAgICBwcm90by5pc1V0Y09mZnNldCAgICAgICAgICA9IGlzVXRjT2Zmc2V0O1xuICAgIHByb3RvLmlzVXRjICAgICAgICAgICAgICAgID0gaXNVdGM7XG4gICAgcHJvdG8uaXNVVEMgICAgICAgICAgICAgICAgPSBpc1V0YztcbiAgICBwcm90by56b25lQWJiciA9IGdldFpvbmVBYmJyO1xuICAgIHByb3RvLnpvbmVOYW1lID0gZ2V0Wm9uZU5hbWU7XG4gICAgcHJvdG8uZGF0ZXMgID0gZGVwcmVjYXRlKCdkYXRlcyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgZGF0ZSBpbnN0ZWFkLicsIGdldFNldERheU9mTW9udGgpO1xuICAgIHByb3RvLm1vbnRocyA9IGRlcHJlY2F0ZSgnbW9udGhzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb250aCBpbnN0ZWFkJywgZ2V0U2V0TW9udGgpO1xuICAgIHByb3RvLnllYXJzICA9IGRlcHJlY2F0ZSgneWVhcnMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIHllYXIgaW5zdGVhZCcsIGdldFNldFllYXIpO1xuICAgIHByb3RvLnpvbmUgICA9IGRlcHJlY2F0ZSgnbW9tZW50KCkuem9uZSBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50KCkudXRjT2Zmc2V0IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3Mvem9uZS8nLCBnZXRTZXRab25lKTtcbiAgICBwcm90by5pc0RTVFNoaWZ0ZWQgPSBkZXByZWNhdGUoJ2lzRFNUU2hpZnRlZCBpcyBkZXByZWNhdGVkLiBTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kc3Qtc2hpZnRlZC8gZm9yIG1vcmUgaW5mb3JtYXRpb24nLCBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQpO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlVW5peCAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0ICogMTAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW5ab25lICgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cykucGFyc2Vab25lKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlUGFyc2VQb3N0Rm9ybWF0IChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9XG5cbiAgICB2YXIgcHJvdG8kMSA9IExvY2FsZS5wcm90b3R5cGU7XG5cbiAgICBwcm90byQxLmNhbGVuZGFyICAgICAgICA9IGNhbGVuZGFyO1xuICAgIHByb3RvJDEubG9uZ0RhdGVGb3JtYXQgID0gbG9uZ0RhdGVGb3JtYXQ7XG4gICAgcHJvdG8kMS5pbnZhbGlkRGF0ZSAgICAgPSBpbnZhbGlkRGF0ZTtcbiAgICBwcm90byQxLm9yZGluYWwgICAgICAgICA9IG9yZGluYWw7XG4gICAgcHJvdG8kMS5wcmVwYXJzZSAgICAgICAgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG4gICAgcHJvdG8kMS5wb3N0Zm9ybWF0ICAgICAgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG4gICAgcHJvdG8kMS5yZWxhdGl2ZVRpbWUgICAgPSByZWxhdGl2ZVRpbWU7XG4gICAgcHJvdG8kMS5wYXN0RnV0dXJlICAgICAgPSBwYXN0RnV0dXJlO1xuICAgIHByb3RvJDEuc2V0ICAgICAgICAgICAgID0gc2V0O1xuXG4gICAgcHJvdG8kMS5tb250aHMgICAgICAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHM7XG4gICAgcHJvdG8kMS5tb250aHNTaG9ydCAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHNTaG9ydDtcbiAgICBwcm90byQxLm1vbnRoc1BhcnNlICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRoc1BhcnNlO1xuICAgIHByb3RvJDEubW9udGhzUmVnZXggICAgICAgPSBtb250aHNSZWdleDtcbiAgICBwcm90byQxLm1vbnRoc1Nob3J0UmVnZXggID0gbW9udGhzU2hvcnRSZWdleDtcbiAgICBwcm90byQxLndlZWsgPSBsb2NhbGVXZWVrO1xuICAgIHByb3RvJDEuZmlyc3REYXlPZlllYXIgPSBsb2NhbGVGaXJzdERheU9mWWVhcjtcbiAgICBwcm90byQxLmZpcnN0RGF5T2ZXZWVrID0gbG9jYWxlRmlyc3REYXlPZldlZWs7XG5cbiAgICBwcm90byQxLndlZWtkYXlzICAgICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzO1xuICAgIHByb3RvJDEud2Vla2RheXNNaW4gICAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNNaW47XG4gICAgcHJvdG8kMS53ZWVrZGF5c1Nob3J0ICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c1Nob3J0O1xuICAgIHByb3RvJDEud2Vla2RheXNQYXJzZSAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNQYXJzZTtcblxuICAgIHByb3RvJDEud2Vla2RheXNSZWdleCAgICAgICA9ICAgICAgICB3ZWVrZGF5c1JlZ2V4O1xuICAgIHByb3RvJDEud2Vla2RheXNTaG9ydFJlZ2V4ICA9ICAgICAgICB3ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgcHJvdG8kMS53ZWVrZGF5c01pblJlZ2V4ICAgID0gICAgICAgIHdlZWtkYXlzTWluUmVnZXg7XG5cbiAgICBwcm90byQxLmlzUE0gPSBsb2NhbGVJc1BNO1xuICAgIHByb3RvJDEubWVyaWRpZW0gPSBsb2NhbGVNZXJpZGllbTtcblxuICAgIGZ1bmN0aW9uIGdldCQxIChmb3JtYXQsIGluZGV4LCBmaWVsZCwgc2V0dGVyKSB7XG4gICAgICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKTtcbiAgICAgICAgdmFyIHV0YyA9IGNyZWF0ZVVUQygpLnNldChzZXR0ZXIsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIGxvY2FsZVtmaWVsZF0odXRjLCBmb3JtYXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RNb250aHNJbXBsIChmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQkMShmb3JtYXQsIGluZGV4LCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgb3V0W2ldID0gZ2V0JDEoZm9ybWF0LCBpLCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICAvLyAoKVxuICAgIC8vICg1KVxuICAgIC8vIChmbXQsIDUpXG4gICAgLy8gKGZtdClcbiAgICAvLyAodHJ1ZSlcbiAgICAvLyAodHJ1ZSwgNSlcbiAgICAvLyAodHJ1ZSwgZm10LCA1KVxuICAgIC8vICh0cnVlLCBmbXQpXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzSW1wbCAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgICAgICBpZiAodHlwZW9mIGxvY2FsZVNvcnRlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9ybWF0ID0gbG9jYWxlU29ydGVkO1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBsb2NhbGVTb3J0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKSxcbiAgICAgICAgICAgIHNoaWZ0ID0gbG9jYWxlU29ydGVkID8gbG9jYWxlLl93ZWVrLmRvdyA6IDA7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQkMShmb3JtYXQsIChpbmRleCArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBnZXQkMShmb3JtYXQsIChpICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RNb250aHMgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHMnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzU2hvcnQgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHNTaG9ydCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5cyAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzU2hvcnQgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c1Nob3J0Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzTWluIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNNaW4nKTtcbiAgICB9XG5cbiAgICBnZXRTZXRHbG9iYWxMb2NhbGUoJ2VuJywge1xuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0odGh8c3R8bmR8cmQpLyxcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRvSW50KG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAndGgnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMykgPyAncmQnIDogJ3RoJztcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuICAgIGhvb2tzLmxhbmcgPSBkZXByZWNhdGUoJ21vbWVudC5sYW5nIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlIGluc3RlYWQuJywgZ2V0U2V0R2xvYmFsTG9jYWxlKTtcbiAgICBob29rcy5sYW5nRGF0YSA9IGRlcHJlY2F0ZSgnbW9tZW50LmxhbmdEYXRhIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlRGF0YSBpbnN0ZWFkLicsIGdldExvY2FsZSk7XG5cbiAgICB2YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gYWJzICgpIHtcbiAgICAgICAgdmFyIGRhdGEgICAgICAgICAgID0gdGhpcy5fZGF0YTtcblxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgPSBtYXRoQWJzKHRoaXMuX21pbGxpc2Vjb25kcyk7XG4gICAgICAgIHRoaXMuX2RheXMgICAgICAgICA9IG1hdGhBYnModGhpcy5fZGF5cyk7XG4gICAgICAgIHRoaXMuX21vbnRocyAgICAgICA9IG1hdGhBYnModGhpcy5fbW9udGhzKTtcblxuICAgICAgICBkYXRhLm1pbGxpc2Vjb25kcyAgPSBtYXRoQWJzKGRhdGEubWlsbGlzZWNvbmRzKTtcbiAgICAgICAgZGF0YS5zZWNvbmRzICAgICAgID0gbWF0aEFicyhkYXRhLnNlY29uZHMpO1xuICAgICAgICBkYXRhLm1pbnV0ZXMgICAgICAgPSBtYXRoQWJzKGRhdGEubWludXRlcyk7XG4gICAgICAgIGRhdGEuaG91cnMgICAgICAgICA9IG1hdGhBYnMoZGF0YS5ob3Vycyk7XG4gICAgICAgIGRhdGEubW9udGhzICAgICAgICA9IG1hdGhBYnMoZGF0YS5tb250aHMpO1xuICAgICAgICBkYXRhLnllYXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEueWVhcnMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFN1YnRyYWN0JDEgKGR1cmF0aW9uLCBpbnB1dCwgdmFsdWUsIGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVEdXJhdGlvbihpbnB1dCwgdmFsdWUpO1xuXG4gICAgICAgIGR1cmF0aW9uLl9taWxsaXNlY29uZHMgKz0gZGlyZWN0aW9uICogb3RoZXIuX21pbGxpc2Vjb25kcztcbiAgICAgICAgZHVyYXRpb24uX2RheXMgICAgICAgICArPSBkaXJlY3Rpb24gKiBvdGhlci5fZGF5cztcbiAgICAgICAgZHVyYXRpb24uX21vbnRocyAgICAgICArPSBkaXJlY3Rpb24gKiBvdGhlci5fbW9udGhzO1xuXG4gICAgICAgIHJldHVybiBkdXJhdGlvbi5fYnViYmxlKCk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgYWRkKDEsICdzJykgb3IgYWRkKGR1cmF0aW9uKVxuICAgIGZ1bmN0aW9uIGFkZCQxIChpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFkZFN1YnRyYWN0JDEodGhpcywgaW5wdXQsIHZhbHVlLCAxKTtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBzdWJ0cmFjdCgxLCAncycpIG9yIHN1YnRyYWN0KGR1cmF0aW9uKVxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0JDEgKGlucHV0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYWRkU3VidHJhY3QkMSh0aGlzLCBpbnB1dCwgdmFsdWUsIC0xKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNDZWlsIChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWJibGUgKCkge1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuICAgICAgICB2YXIgZGF5cyAgICAgICAgID0gdGhpcy5fZGF5cztcbiAgICAgICAgdmFyIG1vbnRocyAgICAgICA9IHRoaXMuX21vbnRocztcbiAgICAgICAgdmFyIGRhdGEgICAgICAgICA9IHRoaXMuX2RhdGE7XG4gICAgICAgIHZhciBzZWNvbmRzLCBtaW51dGVzLCBob3VycywgeWVhcnMsIG1vbnRoc0Zyb21EYXlzO1xuXG4gICAgICAgIC8vIGlmIHdlIGhhdmUgYSBtaXggb2YgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcywgYnViYmxlIGRvd24gZmlyc3RcbiAgICAgICAgLy8gY2hlY2s6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yMTY2XG4gICAgICAgIGlmICghKChtaWxsaXNlY29uZHMgPj0gMCAmJiBkYXlzID49IDAgJiYgbW9udGhzID49IDApIHx8XG4gICAgICAgICAgICAgICAgKG1pbGxpc2Vjb25kcyA8PSAwICYmIGRheXMgPD0gMCAmJiBtb250aHMgPD0gMCkpKSB7XG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgKz0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzKSArIGRheXMpICogODY0ZTU7XG4gICAgICAgICAgICBkYXlzID0gMDtcbiAgICAgICAgICAgIG1vbnRocyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgYnViYmxlcyB1cCB2YWx1ZXMsIHNlZSB0aGUgdGVzdHMgZm9yXG4gICAgICAgIC8vIGV4YW1wbGVzIG9mIHdoYXQgdGhhdCBtZWFucy5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHMgJSAxMDAwO1xuXG4gICAgICAgIHNlY29uZHMgICAgICAgICAgID0gYWJzRmxvb3IobWlsbGlzZWNvbmRzIC8gMTAwMCk7XG4gICAgICAgIGRhdGEuc2Vjb25kcyAgICAgID0gc2Vjb25kcyAlIDYwO1xuXG4gICAgICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgZGF0YS5taW51dGVzICAgICAgPSBtaW51dGVzICUgNjA7XG5cbiAgICAgICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBkYXRhLmhvdXJzICAgICAgICA9IGhvdXJzICUgMjQ7XG5cbiAgICAgICAgZGF5cyArPSBhYnNGbG9vcihob3VycyAvIDI0KTtcblxuICAgICAgICAvLyBjb252ZXJ0IGRheXMgdG8gbW9udGhzXG4gICAgICAgIG1vbnRoc0Zyb21EYXlzID0gYWJzRmxvb3IoZGF5c1RvTW9udGhzKGRheXMpKTtcbiAgICAgICAgbW9udGhzICs9IG1vbnRoc0Zyb21EYXlzO1xuICAgICAgICBkYXlzIC09IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRoc0Zyb21EYXlzKSk7XG5cbiAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgICAgICB5ZWFycyA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICAgICAgbW9udGhzICU9IDEyO1xuXG4gICAgICAgIGRhdGEuZGF5cyAgID0gZGF5cztcbiAgICAgICAgZGF0YS5tb250aHMgPSBtb250aHM7XG4gICAgICAgIGRhdGEueWVhcnMgID0geWVhcnM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c1RvTW9udGhzIChkYXlzKSB7XG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDE0NjA5NyBkYXlzICh0YWtpbmcgaW50byBhY2NvdW50IGxlYXAgeWVhciBydWxlcylcbiAgICAgICAgLy8gNDAwIHllYXJzIGhhdmUgMTIgbW9udGhzID09PSA0ODAwXG4gICAgICAgIHJldHVybiBkYXlzICogNDgwMCAvIDE0NjA5NztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aHNUb0RheXMgKG1vbnRocykge1xuICAgICAgICAvLyB0aGUgcmV2ZXJzZSBvZiBkYXlzVG9Nb250aHNcbiAgICAgICAgcmV0dXJuIG1vbnRocyAqIDE0NjA5NyAvIDQ4MDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXMgKHVuaXRzKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRheXM7XG4gICAgICAgIHZhciBtb250aHM7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XG5cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgaWYgKHVuaXRzID09PSAnbW9udGgnIHx8IHVuaXRzID09PSAncXVhcnRlcicgfHwgdW5pdHMgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgIG1vbnRocyA9IHRoaXMuX21vbnRocyArIGRheXNUb01vbnRocyhkYXlzKTtcbiAgICAgICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdtb250aCc6ICAgcmV0dXJuIG1vbnRocztcbiAgICAgICAgICAgICAgICBjYXNlICdxdWFydGVyJzogcmV0dXJuIG1vbnRocyAvIDM7XG4gICAgICAgICAgICAgICAgY2FzZSAneWVhcic6ICAgIHJldHVybiBtb250aHMgLyAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBtaWxsaXNlY29uZHMgc2VwYXJhdGVseSBiZWNhdXNlIG9mIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIChpc3N1ZSAjMTg2NylcbiAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgTWF0aC5yb3VuZChtb250aHNUb0RheXModGhpcy5fbW9udGhzKSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnd2VlaycgICA6IHJldHVybiBkYXlzIC8gNyAgICAgKyBtaWxsaXNlY29uZHMgLyA2MDQ4ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGF5JyAgICA6IHJldHVybiBkYXlzICAgICAgICAgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdob3VyJyAgIDogcmV0dXJuIGRheXMgKiAyNCAgICArIG1pbGxpc2Vjb25kcyAvIDM2ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWludXRlJyA6IHJldHVybiBkYXlzICogMTQ0MCAgKyBtaWxsaXNlY29uZHMgLyA2ZTQ7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2Vjb25kJyA6IHJldHVybiBkYXlzICogODY0MDAgKyBtaWxsaXNlY29uZHMgLyAxMDAwO1xuICAgICAgICAgICAgICAgIC8vIE1hdGguZmxvb3IgcHJldmVudHMgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgaGVyZVxuICAgICAgICAgICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzogcmV0dXJuIE1hdGguZmxvb3IoZGF5cyAqIDg2NGU1KSArIG1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdW5pdCAnICsgdW5pdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIHRoaXMuYXMoJ21zJyk/XG4gICAgZnVuY3Rpb24gdmFsdWVPZiQxICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgIHRoaXMuX2RheXMgKiA4NjRlNSArXG4gICAgICAgICAgICAodGhpcy5fbW9udGhzICUgMTIpICogMjU5MmU2ICtcbiAgICAgICAgICAgIHRvSW50KHRoaXMuX21vbnRocyAvIDEyKSAqIDMxNTM2ZTZcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlQXMgKGFsaWFzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcyhhbGlhcyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGFzTWlsbGlzZWNvbmRzID0gbWFrZUFzKCdtcycpO1xuICAgIHZhciBhc1NlY29uZHMgICAgICA9IG1ha2VBcygncycpO1xuICAgIHZhciBhc01pbnV0ZXMgICAgICA9IG1ha2VBcygnbScpO1xuICAgIHZhciBhc0hvdXJzICAgICAgICA9IG1ha2VBcygnaCcpO1xuICAgIHZhciBhc0RheXMgICAgICAgICA9IG1ha2VBcygnZCcpO1xuICAgIHZhciBhc1dlZWtzICAgICAgICA9IG1ha2VBcygndycpO1xuICAgIHZhciBhc01vbnRocyAgICAgICA9IG1ha2VBcygnTScpO1xuICAgIHZhciBhc1F1YXJ0ZXJzICAgICA9IG1ha2VBcygnUScpO1xuICAgIHZhciBhc1llYXJzICAgICAgICA9IG1ha2VBcygneScpO1xuXG4gICAgZnVuY3Rpb24gY2xvbmUkMSAoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXQkMiAodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXNbdW5pdHMgKyAncyddKCkgOiBOYU47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldHRlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9kYXRhW25hbWVdIDogTmFOO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBtaWxsaXNlY29uZHMgPSBtYWtlR2V0dGVyKCdtaWxsaXNlY29uZHMnKTtcbiAgICB2YXIgc2Vjb25kcyAgICAgID0gbWFrZUdldHRlcignc2Vjb25kcycpO1xuICAgIHZhciBtaW51dGVzICAgICAgPSBtYWtlR2V0dGVyKCdtaW51dGVzJyk7XG4gICAgdmFyIGhvdXJzICAgICAgICA9IG1ha2VHZXR0ZXIoJ2hvdXJzJyk7XG4gICAgdmFyIGRheXMgICAgICAgICA9IG1ha2VHZXR0ZXIoJ2RheXMnKTtcbiAgICB2YXIgbW9udGhzICAgICAgID0gbWFrZUdldHRlcignbW9udGhzJyk7XG4gICAgdmFyIHllYXJzICAgICAgICA9IG1ha2VHZXR0ZXIoJ3llYXJzJyk7XG5cbiAgICBmdW5jdGlvbiB3ZWVrcyAoKSB7XG4gICAgICAgIHJldHVybiBhYnNGbG9vcih0aGlzLmRheXMoKSAvIDcpO1xuICAgIH1cblxuICAgIHZhciByb3VuZCA9IE1hdGgucm91bmQ7XG4gICAgdmFyIHRocmVzaG9sZHMgPSB7XG4gICAgICAgIHNzOiA0NCwgICAgICAgICAvLyBhIGZldyBzZWNvbmRzIHRvIHNlY29uZHNcbiAgICAgICAgcyA6IDQ1LCAgICAgICAgIC8vIHNlY29uZHMgdG8gbWludXRlXG4gICAgICAgIG0gOiA0NSwgICAgICAgICAvLyBtaW51dGVzIHRvIGhvdXJcbiAgICAgICAgaCA6IDIyLCAgICAgICAgIC8vIGhvdXJzIHRvIGRheVxuICAgICAgICBkIDogMjYsICAgICAgICAgLy8gZGF5cyB0byBtb250aFxuICAgICAgICBNIDogMTEgICAgICAgICAgLy8gbW9udGhzIHRvIHllYXJcbiAgICB9O1xuXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uIGZvciBtb21lbnQuZm4uZnJvbSwgbW9tZW50LmZuLmZyb21Ob3csIGFuZCBtb21lbnQuZHVyYXRpb24uZm4uaHVtYW5pemVcbiAgICBmdW5jdGlvbiBzdWJzdGl0dXRlVGltZUFnbyhzdHJpbmcsIG51bWJlciwgd2l0aG91dFN1ZmZpeCwgaXNGdXR1cmUsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLnJlbGF0aXZlVGltZShudW1iZXIgfHwgMSwgISF3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWxhdGl2ZVRpbWUkMSAocG9zTmVnRHVyYXRpb24sIHdpdGhvdXRTdWZmaXgsIGxvY2FsZSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBjcmVhdGVEdXJhdGlvbihwb3NOZWdEdXJhdGlvbikuYWJzKCk7XG4gICAgICAgIHZhciBzZWNvbmRzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdzJykpO1xuICAgICAgICB2YXIgbWludXRlcyAgPSByb3VuZChkdXJhdGlvbi5hcygnbScpKTtcbiAgICAgICAgdmFyIGhvdXJzICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ2gnKSk7XG4gICAgICAgIHZhciBkYXlzICAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdkJykpO1xuICAgICAgICB2YXIgbW9udGhzICAgPSByb3VuZChkdXJhdGlvbi5hcygnTScpKTtcbiAgICAgICAgdmFyIHllYXJzICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ3knKSk7XG5cbiAgICAgICAgdmFyIGEgPSBzZWNvbmRzIDw9IHRocmVzaG9sZHMuc3MgJiYgWydzJywgc2Vjb25kc10gIHx8XG4gICAgICAgICAgICAgICAgc2Vjb25kcyA8IHRocmVzaG9sZHMucyAgICYmIFsnc3MnLCBzZWNvbmRzXSB8fFxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPD0gMSAgICAgICAgICAgICAmJiBbJ20nXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBtaW51dGVzIDwgdGhyZXNob2xkcy5tICAgJiYgWydtbScsIG1pbnV0ZXNdIHx8XG4gICAgICAgICAgICAgICAgaG91cnMgICA8PSAxICAgICAgICAgICAgICYmIFsnaCddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIGhvdXJzICAgPCB0aHJlc2hvbGRzLmggICAmJiBbJ2hoJywgaG91cnNdICAgfHxcbiAgICAgICAgICAgICAgICBkYXlzICAgIDw9IDEgICAgICAgICAgICAgJiYgWydkJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgZGF5cyAgICA8IHRocmVzaG9sZHMuZCAgICYmIFsnZGQnLCBkYXlzXSAgICB8fFxuICAgICAgICAgICAgICAgIG1vbnRocyAgPD0gMSAgICAgICAgICAgICAmJiBbJ00nXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBtb250aHMgIDwgdGhyZXNob2xkcy5NICAgJiYgWydNTScsIG1vbnRoc10gIHx8XG4gICAgICAgICAgICAgICAgeWVhcnMgICA8PSAxICAgICAgICAgICAgICYmIFsneSddICAgICAgICAgICB8fCBbJ3l5JywgeWVhcnNdO1xuXG4gICAgICAgIGFbMl0gPSB3aXRob3V0U3VmZml4O1xuICAgICAgICBhWzNdID0gK3Bvc05lZ0R1cmF0aW9uID4gMDtcbiAgICAgICAgYVs0XSA9IGxvY2FsZTtcbiAgICAgICAgcmV0dXJuIHN1YnN0aXR1dGVUaW1lQWdvLmFwcGx5KG51bGwsIGEpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgdGhlIHJvdW5kaW5nIGZ1bmN0aW9uIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbiAgICBmdW5jdGlvbiBnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZyAocm91bmRpbmdGdW5jdGlvbikge1xuICAgICAgICBpZiAocm91bmRpbmdGdW5jdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZihyb3VuZGluZ0Z1bmN0aW9uKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcm91bmQgPSByb3VuZGluZ0Z1bmN0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgYSB0aHJlc2hvbGQgZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZCAodGhyZXNob2xkLCBsaW1pdCkge1xuICAgICAgICBpZiAodGhyZXNob2xkc1t0aHJlc2hvbGRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRocmVzaG9sZHNbdGhyZXNob2xkXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJlc2hvbGRzW3RocmVzaG9sZF0gPSBsaW1pdDtcbiAgICAgICAgaWYgKHRocmVzaG9sZCA9PT0gJ3MnKSB7XG4gICAgICAgICAgICB0aHJlc2hvbGRzLnNzID0gbGltaXQgLSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGh1bWFuaXplICh3aXRoU3VmZml4KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvY2FsZSA9IHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gcmVsYXRpdmVUaW1lJDEodGhpcywgIXdpdGhTdWZmaXgsIGxvY2FsZSk7XG5cbiAgICAgICAgaWYgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IGxvY2FsZS5wYXN0RnV0dXJlKCt0aGlzLCBvdXRwdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxvY2FsZS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgdmFyIGFicyQxID0gTWF0aC5hYnM7XG5cbiAgICBmdW5jdGlvbiBzaWduKHgpIHtcbiAgICAgICAgcmV0dXJuICgoeCA+IDApIC0gKHggPCAwKSkgfHwgK3g7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JU09TdHJpbmckMSgpIHtcbiAgICAgICAgLy8gZm9yIElTTyBzdHJpbmdzIHdlIGRvIG5vdCB1c2UgdGhlIG5vcm1hbCBidWJibGluZyBydWxlczpcbiAgICAgICAgLy8gICogbWlsbGlzZWNvbmRzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSBob3Vyc1xuICAgICAgICAvLyAgKiBkYXlzIGRvIG5vdCBidWJibGUgYXQgYWxsXG4gICAgICAgIC8vICAqIG1vbnRocyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgeWVhcnNcbiAgICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIHRoZXJlIGlzIG5vIGNvbnRleHQtZnJlZSBjb252ZXJzaW9uIGJldHdlZW4gaG91cnMgYW5kIGRheXNcbiAgICAgICAgLy8gKHRoaW5rIG9mIGNsb2NrIGNoYW5nZXMpXG4gICAgICAgIC8vIGFuZCBhbHNvIG5vdCBiZXR3ZWVuIGRheXMgYW5kIG1vbnRocyAoMjgtMzEgZGF5cyBwZXIgbW9udGgpXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlY29uZHMgPSBhYnMkMSh0aGlzLl9taWxsaXNlY29uZHMpIC8gMTAwMDtcbiAgICAgICAgdmFyIGRheXMgICAgICAgICA9IGFicyQxKHRoaXMuX2RheXMpO1xuICAgICAgICB2YXIgbW9udGhzICAgICAgID0gYWJzJDEodGhpcy5fbW9udGhzKTtcbiAgICAgICAgdmFyIG1pbnV0ZXMsIGhvdXJzLCB5ZWFycztcblxuICAgICAgICAvLyAzNjAwIHNlY29uZHMgLT4gNjAgbWludXRlcyAtPiAxIGhvdXJcbiAgICAgICAgbWludXRlcyAgICAgICAgICAgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgICAgICBob3VycyAgICAgICAgICAgICA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgIHNlY29uZHMgJT0gNjA7XG4gICAgICAgIG1pbnV0ZXMgJT0gNjA7XG5cbiAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgICAgICB5ZWFycyAgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIG1vbnRocyAlPSAxMjtcblxuXG4gICAgICAgIC8vIGluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9kb3JkaWxsZS9tb21lbnQtaXNvZHVyYXRpb24vYmxvYi9tYXN0ZXIvbW9tZW50Lmlzb2R1cmF0aW9uLmpzXG4gICAgICAgIHZhciBZID0geWVhcnM7XG4gICAgICAgIHZhciBNID0gbW9udGhzO1xuICAgICAgICB2YXIgRCA9IGRheXM7XG4gICAgICAgIHZhciBoID0gaG91cnM7XG4gICAgICAgIHZhciBtID0gbWludXRlcztcbiAgICAgICAgdmFyIHMgPSBzZWNvbmRzID8gc2Vjb25kcy50b0ZpeGVkKDMpLnJlcGxhY2UoL1xcLj8wKyQvLCAnJykgOiAnJztcbiAgICAgICAgdmFyIHRvdGFsID0gdGhpcy5hc1NlY29uZHMoKTtcblxuICAgICAgICBpZiAoIXRvdGFsKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBzYW1lIGFzIEMjJ3MgKE5vZGEpIGFuZCBweXRob24gKGlzb2RhdGUpLi4uXG4gICAgICAgICAgICAvLyBidXQgbm90IG90aGVyIEpTIChnb29nLmRhdGUpXG4gICAgICAgICAgICByZXR1cm4gJ1AwRCc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG90YWxTaWduID0gdG90YWwgPCAwID8gJy0nIDogJyc7XG4gICAgICAgIHZhciB5bVNpZ24gPSBzaWduKHRoaXMuX21vbnRocykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG4gICAgICAgIHZhciBkYXlzU2lnbiA9IHNpZ24odGhpcy5fZGF5cykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG4gICAgICAgIHZhciBobXNTaWduID0gc2lnbih0aGlzLl9taWxsaXNlY29uZHMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuXG4gICAgICAgIHJldHVybiB0b3RhbFNpZ24gKyAnUCcgK1xuICAgICAgICAgICAgKFkgPyB5bVNpZ24gKyBZICsgJ1knIDogJycpICtcbiAgICAgICAgICAgIChNID8geW1TaWduICsgTSArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAoRCA/IGRheXNTaWduICsgRCArICdEJyA6ICcnKSArXG4gICAgICAgICAgICAoKGggfHwgbSB8fCBzKSA/ICdUJyA6ICcnKSArXG4gICAgICAgICAgICAoaCA/IGhtc1NpZ24gKyBoICsgJ0gnIDogJycpICtcbiAgICAgICAgICAgIChtID8gaG1zU2lnbiArIG0gKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgKHMgPyBobXNTaWduICsgcyArICdTJyA6ICcnKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG8kMiA9IER1cmF0aW9uLnByb3RvdHlwZTtcblxuICAgIHByb3RvJDIuaXNWYWxpZCAgICAgICAgPSBpc1ZhbGlkJDE7XG4gICAgcHJvdG8kMi5hYnMgICAgICAgICAgICA9IGFicztcbiAgICBwcm90byQyLmFkZCAgICAgICAgICAgID0gYWRkJDE7XG4gICAgcHJvdG8kMi5zdWJ0cmFjdCAgICAgICA9IHN1YnRyYWN0JDE7XG4gICAgcHJvdG8kMi5hcyAgICAgICAgICAgICA9IGFzO1xuICAgIHByb3RvJDIuYXNNaWxsaXNlY29uZHMgPSBhc01pbGxpc2Vjb25kcztcbiAgICBwcm90byQyLmFzU2Vjb25kcyAgICAgID0gYXNTZWNvbmRzO1xuICAgIHByb3RvJDIuYXNNaW51dGVzICAgICAgPSBhc01pbnV0ZXM7XG4gICAgcHJvdG8kMi5hc0hvdXJzICAgICAgICA9IGFzSG91cnM7XG4gICAgcHJvdG8kMi5hc0RheXMgICAgICAgICA9IGFzRGF5cztcbiAgICBwcm90byQyLmFzV2Vla3MgICAgICAgID0gYXNXZWVrcztcbiAgICBwcm90byQyLmFzTW9udGhzICAgICAgID0gYXNNb250aHM7XG4gICAgcHJvdG8kMi5hc1F1YXJ0ZXJzICAgICA9IGFzUXVhcnRlcnM7XG4gICAgcHJvdG8kMi5hc1llYXJzICAgICAgICA9IGFzWWVhcnM7XG4gICAgcHJvdG8kMi52YWx1ZU9mICAgICAgICA9IHZhbHVlT2YkMTtcbiAgICBwcm90byQyLl9idWJibGUgICAgICAgID0gYnViYmxlO1xuICAgIHByb3RvJDIuY2xvbmUgICAgICAgICAgPSBjbG9uZSQxO1xuICAgIHByb3RvJDIuZ2V0ICAgICAgICAgICAgPSBnZXQkMjtcbiAgICBwcm90byQyLm1pbGxpc2Vjb25kcyAgID0gbWlsbGlzZWNvbmRzO1xuICAgIHByb3RvJDIuc2Vjb25kcyAgICAgICAgPSBzZWNvbmRzO1xuICAgIHByb3RvJDIubWludXRlcyAgICAgICAgPSBtaW51dGVzO1xuICAgIHByb3RvJDIuaG91cnMgICAgICAgICAgPSBob3VycztcbiAgICBwcm90byQyLmRheXMgICAgICAgICAgID0gZGF5cztcbiAgICBwcm90byQyLndlZWtzICAgICAgICAgID0gd2Vla3M7XG4gICAgcHJvdG8kMi5tb250aHMgICAgICAgICA9IG1vbnRocztcbiAgICBwcm90byQyLnllYXJzICAgICAgICAgID0geWVhcnM7XG4gICAgcHJvdG8kMi5odW1hbml6ZSAgICAgICA9IGh1bWFuaXplO1xuICAgIHByb3RvJDIudG9JU09TdHJpbmcgICAgPSB0b0lTT1N0cmluZyQxO1xuICAgIHByb3RvJDIudG9TdHJpbmcgICAgICAgPSB0b0lTT1N0cmluZyQxO1xuICAgIHByb3RvJDIudG9KU09OICAgICAgICAgPSB0b0lTT1N0cmluZyQxO1xuICAgIHByb3RvJDIubG9jYWxlICAgICAgICAgPSBsb2NhbGU7XG4gICAgcHJvdG8kMi5sb2NhbGVEYXRhICAgICA9IGxvY2FsZURhdGE7XG5cbiAgICBwcm90byQyLnRvSXNvU3RyaW5nID0gZGVwcmVjYXRlKCd0b0lzb1N0cmluZygpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdG9JU09TdHJpbmcoKSBpbnN0ZWFkIChub3RpY2UgdGhlIGNhcGl0YWxzKScsIHRvSVNPU3RyaW5nJDEpO1xuICAgIHByb3RvJDIubGFuZyA9IGxhbmc7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignWCcsIDAsIDAsICd1bml4Jyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3gnLCAwLCAwLCAndmFsdWVPZicpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigneCcsIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdYJywgbWF0Y2hUaW1lc3RhbXApO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUocGFyc2VGbG9hdChpbnB1dCwgMTApICogMTAwMCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbigneCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSh0b0ludChpbnB1dCkpO1xuICAgIH0pO1xuXG4gICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG5cbiAgICBob29rcy52ZXJzaW9uID0gJzIuMjQuMCc7XG5cbiAgICBzZXRIb29rQ2FsbGJhY2soY3JlYXRlTG9jYWwpO1xuXG4gICAgaG9va3MuZm4gICAgICAgICAgICAgICAgICAgID0gcHJvdG87XG4gICAgaG9va3MubWluICAgICAgICAgICAgICAgICAgID0gbWluO1xuICAgIGhvb2tzLm1heCAgICAgICAgICAgICAgICAgICA9IG1heDtcbiAgICBob29rcy5ub3cgICAgICAgICAgICAgICAgICAgPSBub3c7XG4gICAgaG9va3MudXRjICAgICAgICAgICAgICAgICAgID0gY3JlYXRlVVRDO1xuICAgIGhvb2tzLnVuaXggICAgICAgICAgICAgICAgICA9IGNyZWF0ZVVuaXg7XG4gICAgaG9va3MubW9udGhzICAgICAgICAgICAgICAgID0gbGlzdE1vbnRocztcbiAgICBob29rcy5pc0RhdGUgICAgICAgICAgICAgICAgPSBpc0RhdGU7XG4gICAgaG9va3MubG9jYWxlICAgICAgICAgICAgICAgID0gZ2V0U2V0R2xvYmFsTG9jYWxlO1xuICAgIGhvb2tzLmludmFsaWQgICAgICAgICAgICAgICA9IGNyZWF0ZUludmFsaWQ7XG4gICAgaG9va3MuZHVyYXRpb24gICAgICAgICAgICAgID0gY3JlYXRlRHVyYXRpb247XG4gICAgaG9va3MuaXNNb21lbnQgICAgICAgICAgICAgID0gaXNNb21lbnQ7XG4gICAgaG9va3Mud2Vla2RheXMgICAgICAgICAgICAgID0gbGlzdFdlZWtkYXlzO1xuICAgIGhvb2tzLnBhcnNlWm9uZSAgICAgICAgICAgICA9IGNyZWF0ZUluWm9uZTtcbiAgICBob29rcy5sb2NhbGVEYXRhICAgICAgICAgICAgPSBnZXRMb2NhbGU7XG4gICAgaG9va3MuaXNEdXJhdGlvbiAgICAgICAgICAgID0gaXNEdXJhdGlvbjtcbiAgICBob29rcy5tb250aHNTaG9ydCAgICAgICAgICAgPSBsaXN0TW9udGhzU2hvcnQ7XG4gICAgaG9va3Mud2Vla2RheXNNaW4gICAgICAgICAgID0gbGlzdFdlZWtkYXlzTWluO1xuICAgIGhvb2tzLmRlZmluZUxvY2FsZSAgICAgICAgICA9IGRlZmluZUxvY2FsZTtcbiAgICBob29rcy51cGRhdGVMb2NhbGUgICAgICAgICAgPSB1cGRhdGVMb2NhbGU7XG4gICAgaG9va3MubG9jYWxlcyAgICAgICAgICAgICAgID0gbGlzdExvY2FsZXM7XG4gICAgaG9va3Mud2Vla2RheXNTaG9ydCAgICAgICAgID0gbGlzdFdlZWtkYXlzU2hvcnQ7XG4gICAgaG9va3Mubm9ybWFsaXplVW5pdHMgICAgICAgID0gbm9ybWFsaXplVW5pdHM7XG4gICAgaG9va3MucmVsYXRpdmVUaW1lUm91bmRpbmcgID0gZ2V0U2V0UmVsYXRpdmVUaW1lUm91bmRpbmc7XG4gICAgaG9va3MucmVsYXRpdmVUaW1lVGhyZXNob2xkID0gZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkO1xuICAgIGhvb2tzLmNhbGVuZGFyRm9ybWF0ICAgICAgICA9IGdldENhbGVuZGFyRm9ybWF0O1xuICAgIGhvb2tzLnByb3RvdHlwZSAgICAgICAgICAgICA9IHByb3RvO1xuXG4gICAgLy8gY3VycmVudGx5IEhUTUw1IGlucHV0IHR5cGUgb25seSBzdXBwb3J0cyAyNC1ob3VyIGZvcm1hdHNcbiAgICBob29rcy5IVE1MNV9GTVQgPSB7XG4gICAgICAgIERBVEVUSU1FX0xPQ0FMOiAnWVlZWS1NTS1ERFRISDptbScsICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiAvPlxuICAgICAgICBEQVRFVElNRV9MT0NBTF9TRUNPTkRTOiAnWVlZWS1NTS1ERFRISDptbTpzcycsICAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgc3RlcD1cIjFcIiAvPlxuICAgICAgICBEQVRFVElNRV9MT0NBTF9NUzogJ1lZWVktTU0tRERUSEg6bW06c3MuU1NTJywgICAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgc3RlcD1cIjAuMDAxXCIgLz5cbiAgICAgICAgREFURTogJ1lZWVktTU0tREQnLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJkYXRlXCIgLz5cbiAgICAgICAgVElNRTogJ0hIOm1tJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgLz5cbiAgICAgICAgVElNRV9TRUNPTkRTOiAnSEg6bW06c3MnLCAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgc3RlcD1cIjFcIiAvPlxuICAgICAgICBUSU1FX01TOiAnSEg6bW06c3MuU1NTJywgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiBzdGVwPVwiMC4wMDFcIiAvPlxuICAgICAgICBXRUVLOiAnR0dHRy1bV11XVycsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cIndlZWtcIiAvPlxuICAgICAgICBNT05USDogJ1lZWVktTU0nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cIm1vbnRoXCIgLz5cbiAgICB9O1xuXG4gICAgcmV0dXJuIGhvb2tzO1xuXG59KSkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcmVjb3JkXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvcmVjb3JkXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvdXRpbFwiKTtcbnZhciBhcHBfMSA9IHJlcXVpcmUoXCIuL3dtbC9hcHBcIik7XG52YXIgcGFnZXNfMSA9IHJlcXVpcmUoXCIuL3BhZ2VzXCIpO1xudmFyIHBhZ2VzMlBhZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0bXAgPSByZWNvcmRfMS5ncm91cChwYWdlc18xLnBhZ2VzLCBmdW5jdGlvbiAoXywgaykgeyByZXR1cm4gay5zcGxpdCgnXycpWzBdOyB9KTtcbiAgICBmb3IgKHZhciBzZWMgaW4gdG1wKVxuICAgICAgICBpZiAodG1wLmhhc093blByb3BlcnR5KHNlYykpIHtcbiAgICAgICAgICAgIHZhciBuZXdTZWMgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWVfMSBpbiB0bXBbc2VjXSlcbiAgICAgICAgICAgICAgICBpZiAodG1wW3NlY10uaGFzT3duUHJvcGVydHkobmFtZV8xKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdTZWNbbmFtZV8xLnNwbGl0KCdfJylbMV1dID0gdG1wW3NlY11bbmFtZV8xXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB0bXBbc2VjXSA9IG5ld1NlYztcbiAgICAgICAgfVxuICAgIHJldHVybiB0bXA7XG59O1xudmFyIHBhZ2VzMk1vZHVsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJlY29yZF8xLnJlZHVjZShwYWdlc18xLnBhZ2VzLCB7fSwgZnVuY3Rpb24gKHAsIGMsIGspIHtcbiAgICAgICAgcFtrLnNwbGl0KCdfJylbMV1dID0gYztcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfSk7XG59O1xuLyoqXG4gKiBBcHAgZGlzcGxheWluZyBhbGwgdGhlIHdtbCB3aWRnZXRzLlxuICovXG52YXIgQXBwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFwcChyb290KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyBhcHBfMS5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBbXTtcbiAgICAgICAgdGhpcy5wYWdlID0gJyc7XG4gICAgICAgIHRoaXMucGFnZXMgPSBwYWdlczJQYWdlcygpO1xuICAgICAgICB0aGlzLm1vZHVsZXMgPSBwYWdlczJNb2R1bGVzKCk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICBsYXlvdXQ6ICdsYXlvdXQnXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBuYXZpZ2F0ZSBpcyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gYVxuICAgICAgICAgKiBuYXZpZ2F0aW9uIGxpbmsuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hdmlnYXRlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IF9hLm5hbWU7XG4gICAgICAgICAgICBfdGhpcy5wYWdlID0gbmFtZTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5tb2R1bGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29udGVudCA9IFtfdGhpcy5tb2R1bGVzW25hbWVdLnZpZXcucmVuZGVyKCldO1xuICAgICAgICAgICAgICAgIF90aGlzLnZpZXcuaW52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogdG9nZ2xlRHJhd2VyXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRvZ2dsZURyYXdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHV0aWxfMS5nZXRCeUlkKF90aGlzLnZpZXcsIF90aGlzLnZhbHVlcy5pZC5sYXlvdXQpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC50b2dnbGUoKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHJ1biB0aGUgYXBwbGljYXRpb24uXG4gICAgICovXG4gICAgQXBwLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByb290ID0gdGhpcy5yb290O1xuICAgICAgICB3aGlsZSAocm9vdC5sYXN0Q2hpbGQpXG4gICAgICAgICAgICByb290LnJlbW92ZUNoaWxkKHJvb3QubGFzdENoaWxkKTtcbiAgICAgICAgcm9vdC5hcHBlbmRDaGlsZCh0aGlzLnZpZXcucmVuZGVyKCkpO1xuICAgICAgICB2YXIgcGF0aCA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoLnNwbGl0KCcjJylbMV07XG4gICAgICAgIHBhdGggPSBwYXRoID8gcGF0aC5zcGxpdCgnLycpLmpvaW4oJycpIDogJyc7XG4gICAgfTtcbiAgICBBcHAubWFpbiA9IGZ1bmN0aW9uIChyb290KSB7XG4gICAgICAgIHJldHVybiBuZXcgQXBwKHJvb3QpO1xuICAgIH07XG4gICAgcmV0dXJuIEFwcDtcbn0oKSk7XG5leHBvcnRzLkFwcCA9IEFwcDtcbkFwcC5tYWluKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhcHAnKSkucnVuKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlc3VsdHMgPSBbXG4gICAgeyBsYWJlbDogJ0FzdXMnLCB2YWx1ZTogJ0FzdXMnIH0sXG4gICAgeyBsYWJlbDogJ01TSScsIHZhbHVlOiAnTVNJJyB9LFxuICAgIHsgbGFiZWw6ICdHaWdhYnl0ZScsIHZhbHVlOiAnR2lnYWJ5dGUnIH0sXG4gICAgeyBsYWJlbDogJ0dpZ2FzJywgdmFsdWU6ICdHaWdhcycgfSxcbiAgICB7IGxhYmVsOiAnQXN1c1RlaycsIHZhbHVlOiAnQXN1c1RlaycgfSxcbiAgICB7IGxhYmVsOiAnQXN1c3VnYScsIHZhbHVlOiAnQXN1c3VnYScgfSxcbiAgICB7IGxhYmVsOiAnUXVhbGNvbW0nLCB2YWx1ZTogJ1F1YWxjb21tJyB9LFxuICAgIHsgbGFiZWw6ICdRdWFsaXRhdGl2ZScsIHZhbHVlOiAnUXVhbGl0YXR2ZScgfSxcbiAgICB7IGxhYmVsOiAnS2lycGFsYW5pXFwncycsIHZhbHVlOiAnS2lycGFsYW5pXFwncycgfSxcbiAgICB7IGxhYmVsOiAnQXN1bmRlcicsIHZhbHVlOiAnQXN1bmRlcicgfVxuXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc3VsdHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvZW1iZWRcIik7XG52YXIgRW1iZWRQYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVtYmVkUGFnZSgpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgam9qbzogJ2h0dHBzOi8vd3d3LnlvdXR1YmUuY29tL2VtYmVkLzFiYnI1dE11U25jJyxcbiAgICAgICAgICAgIHdpbjogJ2h0dHBzOi8vd3d3LnlvdXR1YmUuY29tL2VtYmVkL2l0Z1N5UHhmcW9FJyxcbiAgICAgICAgICAgIG1heDogJ2h0dHBzOi8vd3d3LnlvdXR1YmUuY29tL2VtYmVkLzlycnpRU2JrOWhJJyxcbiAgICAgICAgICAgIGFsbG93OiAnYWNjZWxlcm9tZXRlcjsgYXV0b3BsYXk7IGVuY3J5cHRlZC1tZWRpYTsgZ3lyb3Njb3BlOyAnICtcbiAgICAgICAgICAgICAgICAncGljdHVyZS1pbi1waWN0dXJlJ1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gRW1iZWRQYWdlO1xufSgpKTtcbmV4cG9ydHMuRW1iZWRQYWdlID0gRW1iZWRQYWdlO1xuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IEVtYmVkUGFnZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ3JpZF8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9sYXlvdXQvZ3JpZFwiKTtcbjtcbnZhciBlbWJlZF8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9jb250ZW50L2VtYmVkXCIpO1xuO1xudmFyIGRlbW9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi93aWRnZXRzL2RlbW9cIik7XG47XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaDEnLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJFbWJlZFwiKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZ3JpZF8xLkdyaWRMYXlvdXQsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGdyaWRfMS5Sb3csIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChncmlkXzEuQ29sdW1uLCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAnc3Bhbic6IDQgfSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChlbWJlZF8xLkVtYmVkLCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAnY2xhc3NOYW1lJzogXCItYXNwZWN0LXJhdGlvLTE2eDlcIiB9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2lmcmFtZScsIHsgaHRtbDogeyAnc3JjJzogX19jb250ZXh0LnZhbHVlcy5qb2pvLCAnYWxsb3cnOiBfX2NvbnRleHQudmFsdWVzLmFsbG93IH0sIHdtbDoge30gfSwgW10pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChncmlkXzEuQ29sdW1uLCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAnc3Bhbic6IDQgfSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChlbWJlZF8xLkVtYmVkLCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAnY2xhc3NOYW1lJzogXCItYXNwZWN0LXJhdGlvLTR4M1wiIH0gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaWZyYW1lJywgeyBodG1sOiB7ICdzcmMnOiBfX2NvbnRleHQudmFsdWVzLndpbiwgJ2FsbG93JzogX19jb250ZXh0LnZhbHVlcy5hbGxvdyB9LCB3bWw6IHt9IH0sIFtdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZ3JpZF8xLkNvbHVtbiwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ3NwYW4nOiA0IH0gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZW1iZWRfMS5FbWJlZCwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ2NsYXNzTmFtZSc6IFwiLWFzcGVjdC1yYXRpby0xNng5XCIgfSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdpZnJhbWUnLCB7IGh0bWw6IHsgJ3NyYyc6IF9fY29udGV4dC52YWx1ZXMubWF4LCAnYWxsb3cnOiBfX2NvbnRleHQudmFsdWVzLmFsbG93IH0sIHdtbDoge30gfSwgW10pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBNYWluLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gTWFpbjtcbn0oKSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW1iZWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvbWVkaWEtZGVzY3JpcHRpb25cIik7XG52YXIgTWVkaWFEZXNjcmlwdGlvblBhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVkaWFEZXNjcmlwdGlvblBhZ2UoKSB7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHt9O1xuICAgIH1cbiAgICByZXR1cm4gTWVkaWFEZXNjcmlwdGlvblBhZ2U7XG59KCkpO1xuZXhwb3J0cy5NZWRpYURlc2NyaXB0aW9uUGFnZSA9IE1lZGlhRGVzY3JpcHRpb25QYWdlO1xuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IE1lZGlhRGVzY3JpcHRpb25QYWdlKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBtZWRpYV9kZXNjcmlwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9jb250ZW50L21lZGlhLWRlc2NyaXB0aW9uXCIpO1xuO1xudmFyIGRlbW9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi93aWRnZXRzL2RlbW9cIik7XG47XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaDEnLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJNZWRpYSBEZXNjcmlwdGlvblwiKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobWVkaWFfZGVzY3JpcHRpb25fMS5NZWRpYURlc2NyaXB0aW9uLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChtZWRpYV9kZXNjcmlwdGlvbl8xLk1lZGlhLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdpbWcnLCB7IGh0bWw6IHsgJ2FsdCc6IFwicGxhY2Vob2xkZXJcIiwgJ3NyYyc6IFwiaHR0cHM6Ly92aWEucGxhY2Vob2xkZXIuY29tLzE0MHgxMDBcIiB9LCB3bWw6IHt9IH0sIFtdKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChtZWRpYV9kZXNjcmlwdGlvbl8xLkRlc2NyaXB0aW9uLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdoNCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiRGVzY3JpcHRpb25cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIkxvY2F0ZWQgYXQgdGhlIHNpZGUgcmVsYXRlZCB0byB0aGUgaW1hZ2Ugb24gdGhlIGxlZnQuXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgTWFpbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIE1haW47XG59KCkpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lZGlhLWRlc2NyaXB0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL292ZXJsYXlcIik7XG52YXIgT3ZlcmxheVBhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT3ZlcmxheVBhZ2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbU8gPSBfdGhpcy52aWV3LmZpbmRCeUlkKCdvdmVybGF5Jyk7XG4gICAgICAgICAgICAgICAgaWYgKG1PLmlzSnVzdCgpKVxuICAgICAgICAgICAgICAgICAgICBtTy5nZXQoKS5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gT3ZlcmxheVBhZ2U7XG59KCkpO1xuZXhwb3J0cy5PdmVybGF5UGFnZSA9IE92ZXJsYXlQYWdlO1xuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IE92ZXJsYXlQYWdlKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBvdmVybGF5XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRlbnQvb3ZlcmxheVwiKTtcbjtcbnZhciBkZW1vXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vd2lkZ2V0cy9kZW1vXCIpO1xuO1xuLy9AdHMtaWdub3JlOiA2MTkyXG52YXIgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19pZiA9IGZ1bmN0aW9uIChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkge1xuICAgIHJldHVybiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCgpO1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JJbiA9IGZ1bmN0aW9uIChsaXN0LCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2Zvck9mID0gZnVuY3Rpb24gKG8sIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYWluKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX190aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChkZW1vXzEuRGVtbywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2gxJywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiT3ZlcmxheVwiKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQob3ZlcmxheV8xLk92ZXJsYXksIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBcIm92ZXJsYXlcIiB9LCB3dzogeyAnb25DbGljayc6IF9fY29udGV4dC52YWx1ZXMub25DbGljayB9IH0sIFtdKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vdmVybGF5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL3RhZ1wiKTtcbnZhciBzdHlsZV8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL2xpYi9jb250ZW50L3N0eWxlXCIpO1xudmFyIFRhZ1BhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGFnUGFnZSgpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgY2FwaXRhbGl6ZTogZnVuY3Rpb24gKHMpIHsgcmV0dXJuIFwiXCIgKyBzWzBdLnRvVXBwZXJDYXNlKCkgKyBzLnNsaWNlKDEpOyB9LFxuICAgICAgICAgICAgc3R5bGVzOiBbXG4gICAgICAgICAgICAgICAgc3R5bGVfMS5TdHlsZS5EZWZhdWx0LFxuICAgICAgICAgICAgICAgIHN0eWxlXzEuU3R5bGUuUHJpbWFyeSxcbiAgICAgICAgICAgICAgICBzdHlsZV8xLlN0eWxlLlN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgc3R5bGVfMS5TdHlsZS5JbmZvLFxuICAgICAgICAgICAgICAgIHN0eWxlXzEuU3R5bGUuV2FybmluZyxcbiAgICAgICAgICAgICAgICBzdHlsZV8xLlN0eWxlLkVycm9yXG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBUYWdQYWdlO1xufSgpKTtcbmV4cG9ydHMuVGFnUGFnZSA9IFRhZ1BhZ2U7XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgVGFnUGFnZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19zcHJlYWRBcnJheXMgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xuICAgIHJldHVybiByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0YWdfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvY29udGVudC90YWdcIik7XG47XG52YXIgZGVtb18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3dpZGdldHMvZGVtb1wiKTtcbjtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaDEnLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiVGFnXCIpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgX19zcHJlYWRBcnJheXMoW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2gyJywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJTdHlsZXNcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgIF0sIF9fZm9ySW4oX19jb250ZXh0LnZhbHVlcy5zdHlsZXMsIGZ1bmN0aW9uICh2LCBfJCRpLCBfJCRhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQodGFnXzEuVGFnLCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAnc3R5bGUnOiB2LCAndGV4dCc6IF9fY29udGV4dC52YWx1ZXMuY2FwaXRhbGl6ZSh2KSB9IH0sIFtdKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIChbXSk7IH0pKSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWcuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvdGh1bWJuYWlsXCIpO1xudmFyIFRodW1ibmFpbFBhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGh1bWJuYWlsUGFnZSgpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgb25DbGljazogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWxlcnQoJ1lvdSBjbGlja2VkIGl0IScpOyB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBUaHVtYm5haWxQYWdlO1xufSgpKTtcbmV4cG9ydHMuVGh1bWJuYWlsUGFnZSA9IFRodW1ibmFpbFBhZ2U7XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgVGh1bWJuYWlsUGFnZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdGh1bWJuYWlsXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRlbnQvdGh1bWJuYWlsXCIpO1xuO1xudmFyIGdyaWRfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvbGF5b3V0L2dyaWRcIik7XG47XG52YXIgZGVtb18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3dpZGdldHMvZGVtb1wiKTtcbjtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdoMScsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlRodW1ibmFpbFwiKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZ3JpZF8xLkdyaWRMYXlvdXQsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGdyaWRfMS5Sb3csIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChncmlkXzEuQ29sdW1uLCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAnc3Bhbic6IDQgfSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldCh0aHVtYm5haWxfMS5UaHVtYm5haWwsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaW1nJywgeyBodG1sOiB7ICdhbHQnOiBcInBsYWNlaG9sZGVyXCIsICdzcmMnOiBcImh0dHBzOi8vdmlhLnBsYWNlaG9sZGVyLmNvbS8xNzF4MTgwXCIsICdzdHlsZSc6IFwid2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtkaXNwbGF5OmJsb2NrXCIgfSwgd21sOiB7fSB9LCBbXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGdyaWRfMS5Db2x1bW4sIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdzcGFuJzogNCB9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHRodW1ibmFpbF8xLlRodW1ibmFpbCwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ29uQ2xpY2snOiBfX2NvbnRleHQudmFsdWVzLm9uQ2xpY2sgfSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdpbWcnLCB7IGh0bWw6IHsgJ2FsdCc6IFwicGxhY2Vob2xkZXJcIiwgJ3NyYyc6IFwiaHR0cHM6Ly92aWEucGxhY2Vob2xkZXIuY29tLzE3MXgxODBcIiwgJ3N0eWxlJzogXCJ3aWR0aDoxMDAlO2hlaWdodDoxMDAlO2Rpc3BsYXk6YmxvY2tcIiB9LCB3bWw6IHt9IH0sIFtdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZ3JpZF8xLkNvbHVtbiwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ3NwYW4nOiA0IH0gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQodGh1bWJuYWlsXzEuVGh1bWJuYWlsLCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAnaHJlZic6IFwiI1wiIH0gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaW1nJywgeyBodG1sOiB7ICdhbHQnOiBcInBsYWNlaG9sZGVyXCIsICdzcmMnOiBcImh0dHBzOi8vdmlhLnBsYWNlaG9sZGVyLmNvbS8xNzF4MTgwXCIsICdzdHlsZSc6IFwid2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtkaXNwbGF5OmJsb2NrXCIgfSwgd21sOiB7fSB9LCBbXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZ3JpZF8xLlJvdywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGdyaWRfMS5Db2x1bW4sIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdzcGFuJzogNCB9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHRodW1ibmFpbF8xLlRodW1ibmFpbCwgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdpbWcnLCB7IGh0bWw6IHsgJ2FsdCc6IFwicGxhY2Vob2xkZXJcIiwgJ3NyYyc6IFwiaHR0cHM6Ly92aWEucGxhY2Vob2xkZXIuY29tLzE3MXgxODBcIiwgJ3N0eWxlJzogXCJ3aWR0aDoxMDAlO2hlaWdodDoxMDAlO2Rpc3BsYXk6YmxvY2tcIiB9LCB3bWw6IHt9IH0sIFtdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldCh0aHVtYm5haWxfMS5DYXB0aW9uLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdoNCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiQ2FwdGlvblwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiRGVzY3JpYmVzIHRoZSB0aHVtYm5haWwgaW4gbWlub3IgZGV0YWlsLlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGdyaWRfMS5Db2x1bW4sIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdzcGFuJzogNCB9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHRodW1ibmFpbF8xLlRodW1ibmFpbCwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ29uQ2xpY2snOiBfX2NvbnRleHQudmFsdWVzLm9uQ2xpY2sgfSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdpbWcnLCB7IGh0bWw6IHsgJ2FsdCc6IFwicGxhY2Vob2xkZXJcIiwgJ3NyYyc6IFwiaHR0cHM6Ly92aWEucGxhY2Vob2xkZXIuY29tLzE3MXgxODBcIiwgJ3N0eWxlJzogXCJ3aWR0aDoxMDAlO2hlaWdodDoxMDAlO2Rpc3BsYXk6YmxvY2tcIiB9LCB3bWw6IHt9IH0sIFtdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldCh0aHVtYm5haWxfMS5DYXB0aW9uLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdoNCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiQ2FwdGlvblwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiRGVzY3JpYmVzIHRoZSB0aHVtYm5haWwgaW4gbWlub3IgZGV0YWlsLlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGdyaWRfMS5Db2x1bW4sIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdzcGFuJzogNCB9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHRodW1ibmFpbF8xLlRodW1ibmFpbCwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ2hyZWYnOiBcIiNcIiB9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2ltZycsIHsgaHRtbDogeyAnYWx0JzogXCJwbGFjZWhvbGRlclwiLCAnc3JjJzogXCJodHRwczovL3ZpYS5wbGFjZWhvbGRlci5jb20vMTcxeDE4MFwiLCAnc3R5bGUnOiBcIndpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7ZGlzcGxheTpibG9ja1wiIH0sIHdtbDoge30gfSwgW10pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHRodW1ibmFpbF8xLkNhcHRpb24sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2g0JywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJDYXB0aW9uXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJEZXNjcmliZXMgdGhlIHRodW1ibmFpbCBpbiBtaW5vciBkZXRhaWwuXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgTWFpbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIE1haW47XG59KCkpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRodW1ibmFpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9idXR0b24tZ3JvdXBcIik7XG52YXIgQnV0dG9uR3JvdXBQYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJ1dHRvbkdyb3VwUGFnZSgpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBCdXR0b25Hcm91cFBhZ2U7XG59KCkpO1xuZXhwb3J0cy5CdXR0b25Hcm91cFBhZ2UgPSBCdXR0b25Hcm91cFBhZ2U7XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgQnV0dG9uR3JvdXBQYWdlKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkZW1vXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vd2lkZ2V0cy9kZW1vXCIpO1xuO1xudmFyIGJ1dHRvbl8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9jb250cm9sL2J1dHRvblwiKTtcbjtcbnZhciBidXR0b25fZ3JvdXBfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvY29udHJvbC9idXR0b24tZ3JvdXBcIik7XG47XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGJ1dHRvbl9ncm91cF8xLkJ1dHRvbkdyb3VwLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChidXR0b25fMS5CdXR0b24sIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICd0ZXh0JzogXCJvbmVcIiB9IH0sIFtdKSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChidXR0b25fMS5CdXR0b24sIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICd0ZXh0JzogXCJ0aHJlZVwiLCAnYWN0aXZlJzogdHJ1ZSB9IH0sIFtdKSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChidXR0b25fMS5CdXR0b24sIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICd0ZXh0JzogXCJmb3VyXCIgfSB9LCBbXSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idXR0b24tZ3JvdXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvYnV0dG9uLXNlbGVjdFwiKTtcbnZhciBCdXR0b25TZWxlY3RQYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJ1dHRvblNlbGVjdFBhZ2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIG9wdGlvbnM6IFtcbiAgICAgICAgICAgICAgICB7IHRleHQ6ICdBc3VzJywgdmFsdWU6ICdBc3VzJyB9LFxuICAgICAgICAgICAgICAgIHsgdGV4dDogJ01TSScsIHZhbHVlOiAnTVNJJyB9LFxuICAgICAgICAgICAgICAgIHsgdGV4dDogJ0dpZ2FieXRlJywgdmFsdWU6ICdHaWdhYnl0ZScgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfYS52YWx1ZSwgbmFtZSA9IF9hLm5hbWU7XG4gICAgICAgICAgICBfdGhpc1xuICAgICAgICAgICAgICAgIC52aWV3XG4gICAgICAgICAgICAgICAgLmZpbmRCeUlkKG5hbWUgKyBcIi1jb250ZW50XCIpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChlLmxhc3RDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgZS5yZW1vdmVDaGlsZChlLmxhc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShTdHJpbmcodmFsdWUpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZU11bHRpID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfYS52YWx1ZSwgbmFtZSA9IF9hLm5hbWU7XG4gICAgICAgICAgICBfdGhpc1xuICAgICAgICAgICAgICAgIC52aWV3XG4gICAgICAgICAgICAgICAgLmZpbmRCeUlkKG5hbWUgKyBcIi1jb250ZW50XCIpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChlLmxhc3RDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgZS5yZW1vdmVDaGlsZChlLmxhc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShTdHJpbmcodmFsdWUpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1dHRvblNlbGVjdFBhZ2U7XG59KCkpO1xuZXhwb3J0cy5CdXR0b25TZWxlY3RQYWdlID0gQnV0dG9uU2VsZWN0UGFnZTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBCdXR0b25TZWxlY3RQYWdlKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkZW1vXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vd2lkZ2V0cy9kZW1vXCIpO1xuO1xudmFyIHN0eWxlXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRlbnQvc3R5bGVcIik7XG47XG52YXIgYnV0dG9uX3NlbGVjdF8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9jb250cm9sL2J1dHRvbi1zZWxlY3RcIik7XG47XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiWW91IHNlbGVjdGVkOiBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnYicsIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBcInNlbGVjdC1jb250ZW50XCIgfSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCIoTm9uZSlcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCIuXCIpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChidXR0b25fc2VsZWN0XzEuQnV0dG9uU2VsZWN0LCB7IGh0bWw6IHt9LCB3bWw6IHsgJ2lkJzogXCJzZWxlY3RcIiB9LCB3dzogeyAnbmFtZSc6IFwic2VsZWN0XCIsICdzdHlsZSc6IHN0eWxlXzEuU3R5bGUuUHJpbWFyeSwgJ29wdGlvbnMnOiBfX2NvbnRleHQudmFsdWVzLm9wdGlvbnMsICdvbkNoYW5nZSc6IF9fY29udGV4dC5vbkNoYW5nZSB9IH0sIFtdKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJZb3UgY2FuIGFsc28gdXNlIE11bHRpQnV0dG9uU2VsZWN0IGluc3RlYWQ6IFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdiJywgeyBodG1sOiB7fSwgd21sOiB7ICdpZCc6IFwibXVsdGktY29udGVudFwiIH0gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiKE5vbmUpXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiLlwiKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoYnV0dG9uX3NlbGVjdF8xLk11bHRpQnV0dG9uU2VsZWN0LCB7IGh0bWw6IHt9LCB3bWw6IHsgJ2lkJzogXCJtdWx0aVwiIH0sIHd3OiB7ICduYW1lJzogXCJtdWx0aVwiLCAnc3R5bGUnOiBzdHlsZV8xLlN0eWxlLldhcm5pbmcsICdvcHRpb25zJzogX19jb250ZXh0LnZhbHVlcy5vcHRpb25zLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQub25DaGFuZ2VNdWx0aSB9IH0sIFtdKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgTWFpbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIE1haW47XG59KCkpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1dHRvbi1zZWxlY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvYnV0dG9uXCIpO1xudmFyIHN0eWxlXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRlbnQvc3R5bGVcIik7XG52YXIgc2l6ZV8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL2xpYi9jb250ZW50L3NpemVcIik7XG52YXIgQnV0dG9uUGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCdXR0b25QYWdlKCkge1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbih0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBjYXBpdGFsaXplOiBmdW5jdGlvbiAocykgeyByZXR1cm4gXCJcIiArIHNbMF0udG9VcHBlckNhc2UoKSArIHMuc2xpY2UoMSk7IH0sXG4gICAgICAgICAgICBzdHlsZXM6IFtcbiAgICAgICAgICAgICAgICBzdHlsZV8xLlN0eWxlLkRlZmF1bHQsXG4gICAgICAgICAgICAgICAgc3R5bGVfMS5TdHlsZS5QcmltYXJ5LFxuICAgICAgICAgICAgICAgIHN0eWxlXzEuU3R5bGUuU3VjY2VzcyxcbiAgICAgICAgICAgICAgICBzdHlsZV8xLlN0eWxlLkluZm8sXG4gICAgICAgICAgICAgICAgc3R5bGVfMS5TdHlsZS5XYXJuaW5nLFxuICAgICAgICAgICAgICAgIHN0eWxlXzEuU3R5bGUuRXJyb3JcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBzaXplczogW1xuICAgICAgICAgICAgICAgIHNpemVfMS5TaXplLkV4dHJhU21hbGwsXG4gICAgICAgICAgICAgICAgc2l6ZV8xLlNpemUuU21hbGwsXG4gICAgICAgICAgICAgICAgc2l6ZV8xLlNpemUuTWVkaXVtLFxuICAgICAgICAgICAgICAgIHNpemVfMS5TaXplLkxhcmdlLFxuICAgICAgICAgICAgICAgIHNpemVfMS5TaXplLkV4dHJhTGFyZ2VcbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1dHRvblBhZ2U7XG59KCkpO1xuZXhwb3J0cy5CdXR0b25QYWdlID0gQnV0dG9uUGFnZTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBCdXR0b25QYWdlKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3NwcmVhZEFycmF5cyA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheXMpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxuICAgICAgICAgICAgcltrXSA9IGFbal07XG4gICAgcmV0dXJuIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRlbW9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi93aWRnZXRzL2RlbW9cIik7XG47XG52YXIgYnV0dG9uXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRyb2wvYnV0dG9uXCIpO1xuO1xuLy9AdHMtaWdub3JlOiA2MTkyXG52YXIgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19pZiA9IGZ1bmN0aW9uIChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkge1xuICAgIHJldHVybiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCgpO1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JJbiA9IGZ1bmN0aW9uIChsaXN0LCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2Zvck9mID0gZnVuY3Rpb24gKG8sIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYWluKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX190aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChkZW1vXzEuRGVtbywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChkZW1vXzEuRGVtbywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdoMScsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJCdXR0b25zXCIpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgX19zcHJlYWRBcnJheXMoW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2gyJywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJTdHlsZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgXSwgX19mb3JJbihfX2NvbnRleHQudmFsdWVzLnN0eWxlcywgZnVuY3Rpb24gKHYsIF8kJGksIF8kJGFsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChidXR0b25fMS5CdXR0b24sIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICduYW1lJzogdiwgJ3N0eWxlJzogdiwgJ3RleHQnOiBfX2NvbnRleHQudmFsdWVzLmNhcGl0YWxpemUodikgfSB9LCBbXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiAoW10pOyB9KSkpXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChkZW1vXzEuRGVtbywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBfX3NwcmVhZEFycmF5cyhbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdoMicsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJPdXRsaW5lXCIpXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSwgX19mb3JJbihfX2NvbnRleHQudmFsdWVzLnN0eWxlcywgZnVuY3Rpb24gKHN0eWxlLCBfJCRpLCBfJCRhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGJ1dHRvbl8xLkJ1dHRvbiwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ3N0eWxlJzogc3R5bGUsICdvdXRsaW5lJzogdHJ1ZSwgJ3RleHQnOiBfX2NvbnRleHQudmFsdWVzLmNhcGl0YWxpemUoc3R5bGUpIH0gfSwgW10pXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIChbXSk7IH0pKSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChkZW1vXzEuRGVtbywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBfX3NwcmVhZEFycmF5cyhbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaDInLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIkFjdGl2ZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgXSwgX19mb3JJbihfX2NvbnRleHQudmFsdWVzLnN0eWxlcywgZnVuY3Rpb24gKHYsIF8kJGksIF8kJGFsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChidXR0b25fMS5CdXR0b24sIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICduYW1lJzogdiwgJ2FjdGl2ZSc6IHRydWUsICdzdHlsZSc6IHYsICd0ZXh0JzogX19jb250ZXh0LnZhbHVlcy5jYXBpdGFsaXplKHYpIH0gfSwgW10pXG4gICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gKFtdKTsgfSkpKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgX19zcHJlYWRBcnJheXMoW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2gyJywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJEaXNhYmxlZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgXSwgX19mb3JJbihfX2NvbnRleHQudmFsdWVzLnN0eWxlcywgZnVuY3Rpb24gKHYsIF8kJGksIF8kJGFsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChidXR0b25fMS5CdXR0b24sIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICduYW1lJzogdiwgJ2Rpc2FibGVkJzogdHJ1ZSwgJ3N0eWxlJzogdiwgJ3RleHQnOiBfX2NvbnRleHQudmFsdWVzLmNhcGl0YWxpemUodikgfSB9LCBbXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiAoW10pOyB9KSkpXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChkZW1vXzEuRGVtbywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBfX3NwcmVhZEFycmF5cyhbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdoMicsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJTaXplXCIpXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSwgX19mb3JJbihfX2NvbnRleHQudmFsdWVzLnN0eWxlcywgZnVuY3Rpb24gKHN0eWxlLCBfJCRpLCBfJCRhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgX19zcHJlYWRBcnJheXMoX19mb3JJbihfX2NvbnRleHQudmFsdWVzLnNpemVzLCBmdW5jdGlvbiAoc2l6ZSwgXyQkaSwgXyQkYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoYnV0dG9uXzEuQnV0dG9uLCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAnbmFtZSc6IHNpemUsICdzdHlsZSc6IHN0eWxlLCAnc2l6ZSc6IHNpemUsICd0ZXh0JzogX19jb250ZXh0LnZhbHVlcy5jYXBpdGFsaXplKHNpemUpIH0gfSwgW10pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiAoW10pOyB9KSkpXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIChbXSk7IH0pKSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChkZW1vXzEuRGVtbywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBfX3NwcmVhZEFycmF5cyhbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdoMicsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJCbG9ja1wiKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0sIF9fZm9ySW4oX19jb250ZXh0LnZhbHVlcy5zdHlsZXMsIGZ1bmN0aW9uIChzdHlsZSwgXyQkaSwgXyQkYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChidXR0b25fMS5CdXR0b24sIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdzdHlsZSc6IHN0eWxlLCAnYmxvY2snOiB0cnVlLCAndGV4dCc6IF9fY29udGV4dC52YWx1ZXMuY2FwaXRhbGl6ZShzdHlsZSkgfSB9LCBbXSlcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gKFtdKTsgfSkpKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idXR0b24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvY2hlY2tib3hcIik7XG52YXIgQ2hlY2tib3hQYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENoZWNrYm94UGFnZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0cnVlO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgIF90aGlzLnZpZXcuZmluZEJ5SWQoJ2NvbnRlbnQnKVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZS5maXJzdENoaWxkKVxuICAgICAgICAgICAgICAgICAgICBlLnJlbW92ZUNoaWxkKGUuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWx1ZSA9PT0gdHJ1ZSA/XG4gICAgICAgICAgICAgICAgICAgICdvbicgOlxuICAgICAgICAgICAgICAgICAgICAodmFsdWUgPT09IGZhbHNlID8gJ29mZicgOiAnZXJyb3InKSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBDaGVja2JveFBhZ2U7XG59KCkpO1xuZXhwb3J0cy5DaGVja2JveFBhZ2UgPSBDaGVja2JveFBhZ2U7XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgQ2hlY2tib3hQYWdlKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkZW1vXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vd2lkZ2V0cy9kZW1vXCIpO1xuO1xudmFyIGNoZWNrYm94XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRyb2wvY2hlY2tib3hcIik7XG47XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlRoZSBjaGVja2JveCBpcyBcIiksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdiJywgeyBodG1sOiB7fSwgd21sOiB7ICdpZCc6IFwiY29udGVudFwiIH0gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJ1bnRvdWNoZWRcIilcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiLlwiKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoY2hlY2tib3hfMS5DaGVja2JveCwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ25hbWUnOiBcImNoZWNrYm94XCIsICdvbkNoYW5nZSc6IF9fY29udGV4dC5vbkNoYW5nZSB9IH0sIFtdKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgTWFpbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIE1haW47XG59KCkpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNrYm94LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2RhdGUtZmllbGRcIik7XG52YXIgZGF0ZV9maWVsZF8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL2xpYi9jb250cm9sL2RhdGUtZmllbGRcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL2xpYi91dGlsXCIpO1xudmFyIERhdGVGaWVsZFBhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGF0ZUZpZWxkUGFnZSgpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgZm9ybWF0czoge1xuICAgICAgICAgICAgICAgIGlzbzoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ2lzbycsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdpc28nLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ0lTTzg2MDEnLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IGRhdGVfZmllbGRfMS5Gb3JtYXQuSVNPODYwMSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ0lTTzg2MDEgZGF0ZScsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBleHBvcnRzLm9uQ2hhbmdlKHRoaXMpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdjb21tb24nLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnY29tbW9uJyxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdDb21vbicsXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogZGF0ZV9maWVsZF8xLkZvcm1hdC5DT01NT04sXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdDb21tb24gZGF0ZScsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBleHBvcnRzLm9uQ2hhbmdlKHRoaXMpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB1czoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ3VzJyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3VzJyxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdVUycsXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogZGF0ZV9maWVsZF8xLkZvcm1hdC5VU0EsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdVUyBkYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6IGV4cG9ydHMub25DaGFuZ2UodGhpcylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RhdGVzOiB7XG4gICAgICAgICAgICAgICAgc3VjY2Vzczoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ3N1Y2Nlc3MnLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnc3VjY2VzcycsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiAnU3VjY2VzcycsXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6ICdTdWNjZXNzIGRhdGUnLFxuICAgICAgICAgICAgICAgICAgICB3YXJuaW5nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6IGV4cG9ydHMub25DaGFuZ2UodGhpcylcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdhcm5pbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICd3YXJuaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3dhcm5pbmcnLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ1dhcm5pbmcnLFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIHdhcm5pbmc6ICdXYXJuaW5nIGRhdGUnLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBibG9jazogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBleHBvcnRzLm9uQ2hhbmdlKHRoaXMpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdFcnJvcicsXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgd2FybmluZzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogJ0Vycm9yIGRhdGUnLFxuICAgICAgICAgICAgICAgICAgICBibG9jazogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBleHBvcnRzLm9uQ2hhbmdlKHRoaXMpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBibG9jazoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ2Jsb2NrJyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2Jsb2NrJyxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdCbG9jaycsXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgd2FybmluZzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBibG9jazogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6IGV4cG9ydHMub25DaGFuZ2UodGhpcylcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gRGF0ZUZpZWxkUGFnZTtcbn0oKSk7XG5leHBvcnRzLkRhdGVGaWVsZFBhZ2UgPSBEYXRlRmllbGRQYWdlO1xuZXhwb3J0cy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChkKSB7IHJldHVybiBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgbmFtZSA9IF9hLm5hbWUsIHZhbHVlID0gX2EudmFsdWU7XG4gICAgdmFyIG1EYXRlID0gdXRpbF8xLmdldEJ5SWQoZC52aWV3LCBuYW1lKTtcbiAgICBpZiAobURhdGUuaXNKdXN0KCkpIHtcbiAgICAgICAgdmFyIGRfMSA9IG1EYXRlLmdldCgpO1xuICAgICAgICBkXzEuc2V0TWVzc2FnZShcIlRoZSBkYXRlIGlzIFwiICsgdmFsdWUgKyBcIi5cIik7XG4gICAgfVxufTsgfTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBEYXRlRmllbGRQYWdlKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3NwcmVhZEFycmF5cyA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheXMpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxuICAgICAgICAgICAgcltrXSA9IGFbal07XG4gICAgcmV0dXJuIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRlbW9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi93aWRnZXRzL2RlbW9cIik7XG47XG52YXIgZGF0ZV9maWVsZF8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9jb250cm9sL2RhdGUtZmllbGRcIik7XG47XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIF9fc3ByZWFkQXJyYXlzKF9fZm9yT2YoX19jb250ZXh0LnZhbHVlcy5mb3JtYXRzLCBmdW5jdGlvbiAoc3BlYywgXyQkaywgXyQkYWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGRhdGVfZmllbGRfMS5EYXRlRmllbGQsIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBzcGVjLmlkIH0sIHd3OiB7ICduYW1lJzogc3BlYy5uYW1lLCAnbGFiZWwnOiBzcGVjLmxhYmVsLCAnZm9ybWF0Jzogc3BlYy5mb3JtYXQsICdtZXNzYWdlJzogc3BlYy5tZXNzYWdlLCAnb25DaGFuZ2UnOiBzcGVjLm9uQ2hhbmdlIH0gfSwgW10pXG4gICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gKFtdKTsgfSksIF9fZm9yT2YoX19jb250ZXh0LnZhbHVlcy5zdGF0ZXMsIGZ1bmN0aW9uIChzcGVjLCBfJCRrLCBfJCRhbGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChkZW1vXzEuRGVtbywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZGF0ZV9maWVsZF8xLkRhdGVGaWVsZCwgeyBodG1sOiB7fSwgd21sOiB7ICdpZCc6IHNwZWMuaWQgfSwgd3c6IHsgJ25hbWUnOiBzcGVjLm5hbWUsICdsYWJlbCc6IHNwZWMubGFiZWwsICdzdWNjZXNzJzogc3BlYy5zdWNjZXNzLCAnd2FybmluZyc6IHNwZWMud2FybmluZywgJ2Vycm9yJzogc3BlYy5lcnJvciwgJ2Jsb2NrJzogc3BlYy5ibG9jaywgJ29uQ2hhbmdlJzogc3BlYy5vbkNoYW5nZSB9IH0sIFtdKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIChbXSk7IH0pKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRlLWZpZWxkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2Rpc3BsYXktZmllbGRcIik7XG52YXIgc3R5bGVfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi9saWIvY29udGVudC9zdHlsZVwiKTtcbnZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgc3R5bGVfMS5TdHlsZS5EZWZhdWx0LFxuICAgIHN0eWxlXzEuU3R5bGUuUHJpbWFyeSxcbiAgICBzdHlsZV8xLlN0eWxlLlN1Y2Nlc3MsXG4gICAgc3R5bGVfMS5TdHlsZS5JbmZvLFxuICAgIHN0eWxlXzEuU3R5bGUuV2FybmluZyxcbiAgICBzdHlsZV8xLlN0eWxlLkVycm9yXG5dOyB9O1xudmFyIERpc3BsYXlGaWVsZFBhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGlzcGxheUZpZWxkUGFnZSgpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgY2FwaXRhbGl6ZTogZnVuY3Rpb24gKHMpIHsgcmV0dXJuIFwiXCIgKyBzWzBdLnRvVXBwZXJDYXNlKCkgKyBzLnNsaWNlKDEpOyB9LFxuICAgICAgICAgICAgc3R5bGVzOiBnZXRTdHlsZXMoKVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gRGlzcGxheUZpZWxkUGFnZTtcbn0oKSk7XG5leHBvcnRzLkRpc3BsYXlGaWVsZFBhZ2UgPSBEaXNwbGF5RmllbGRQYWdlO1xuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IERpc3BsYXlGaWVsZFBhZ2UoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRpc3BsYXlfZmllbGRfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvY29udHJvbC9kaXNwbGF5LWZpZWxkXCIpO1xuO1xudmFyIGRlbW9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi93aWRnZXRzL2RlbW9cIik7XG47XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChkaXNwbGF5X2ZpZWxkXzEuRGlzcGxheUZpZWxkLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiIEl0IHdhcyBhIGNob2ljZS5cIilcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXNwbGF5LWZpZWxkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2Ryb3AtZG93blwiKTtcbnZhciBEcm9wRG93blBhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRHJvcERvd25QYWdlKCkge1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbih0aGlzKTtcbiAgICAgICAgdGhpcy5vbkNsaWNrID0gZnVuY3Rpb24gKG1zZykgeyByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGFsZXJ0KG1zZyk7XG4gICAgICAgIH07IH07XG4gICAgfVxuICAgIHJldHVybiBEcm9wRG93blBhZ2U7XG59KCkpO1xuZXhwb3J0cy5Ecm9wRG93blBhZ2UgPSBEcm9wRG93blBhZ2U7XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgRHJvcERvd25QYWdlKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkZW1vXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vd2lkZ2V0cy9kZW1vXCIpO1xuO1xudmFyIGRyb3BfZG93bl8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9jb250cm9sL2Ryb3AtZG93blwiKTtcbjtcbnZhciBtZW51XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL21lbnUvbWVudVwiKTtcbjtcbnZhciBpdGVtXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL21lbnUvaXRlbVwiKTtcbjtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZHJvcF9kb3duXzEuRHJvcERvd24sIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdidXR0b25UZXh0JzogXCJDbGljayBNZVwiIH0gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChtZW51XzEuTWVudSwgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChpdGVtXzEuSXRlbSwgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdhJywgeyBodG1sOiB7ICdocmVmJzogXCIjXCIsICdvbmNsaWNrJzogX19jb250ZXh0Lm9uQ2xpY2soXCJZb3UgY2xpY2tlZCBvbmVcIikgfSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIk9uZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoaXRlbV8xLkl0ZW0sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnYScsIHsgaHRtbDogeyAnaHJlZic6IFwiI1wiLCAnb25jbGljayc6IF9fY29udGV4dC5vbkNsaWNrKFwiWW91IGNsaWNrZWQgdHdvXCIpIH0sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJUd29cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGl0ZW1fMS5JdGVtLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2EnLCB7IGh0bWw6IHsgJ2hyZWYnOiBcIiNcIiwgJ29uY2xpY2snOiBfX2NvbnRleHQub25DbGljayhcIllvdSBjbGlja2VkIHRocmVlXCIpIH0sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJUaHJlZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChkcm9wX2Rvd25fMS5Ecm9wRG93biwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ2J1dHRvblRleHQnOiBcIk1lIFRvb1wiLCAnYXV0b0Nsb3NlJzogZmFsc2UgfSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaDEnLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIkFueSBmbG93IGNvbnRlbnQgY2FuIGdvIGhlcmUhXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgTWFpbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIE1haW47XG59KCkpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRyb3AtZG93bi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9kcm9wLWxpc3QtZmllbGRcIik7XG52YXIgcmVzdWx0c18xID0gcmVxdWlyZShcIi4uLy4uL2ZpeHR1cmVzL2RhdGEvcmVzdWx0c1wiKTtcbnZhciBvcHRpb25zID0gcmVzdWx0c18xLnJlc3VsdHM7XG52YXIgRHJvcExpc3RGaWVsZFBhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRHJvcExpc3RGaWVsZFBhZ2UoKSB7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIG5vcm1hbDoge1xuICAgICAgICAgICAgICAgIGlkOiAnbm9ybWFsJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnbm9ybWFsJyxcbiAgICAgICAgICAgICAgICBsYWJlbDogJ05vcm1hbCcsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0c18xLnJlc3VsdHNbMl0udmFsdWUsXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6IGRvQ2hhbmdlKHRoaXMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3VjY2Vzczoge1xuICAgICAgICAgICAgICAgIGlkOiAnc3VjY2VzcycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3N1Y2Nlc3MnLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnU3VjY2VzcycsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnVGhpcyBoYXMgYSBzdWNjZXNzIG1lc3NhZ2UuJyxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogZG9DaGFuZ2UodGhpcylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3YXJuaW5nOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICd3YXJuaW5nJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnd2FybmluZycsXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdXYXJuaW5nJyxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdUaGlzIGhhcyBhIHdhcm5pbmcgbWVzc2FnZS4nLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBkb0NoYW5nZSh0aGlzKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICBsYWJlbDogJ0Vycm9yJyxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdUaGlzIGhhcyBhIGVycm9yIG1lc3NhZ2UuJyxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogZG9DaGFuZ2UodGhpcylcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBEcm9wTGlzdEZpZWxkUGFnZTtcbn0oKSk7XG5leHBvcnRzLkRyb3BMaXN0RmllbGRQYWdlID0gRHJvcExpc3RGaWVsZFBhZ2U7XG52YXIgZG9DaGFuZ2UgPSBmdW5jdGlvbiAocGFnZSkgeyByZXR1cm4gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIG5hbWUgPSBfYS5uYW1lLCB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgIHJldHVybiBwYWdlXG4gICAgICAgIC52aWV3XG4gICAgICAgIC5maW5kQnlJZChuYW1lKVxuICAgICAgICAubWFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYWxlcnQoXCJTZWxlY3RlZDogXCIgKyBuYW1lICsgXCI9XCIgKyB2YWx1ZSk7XG4gICAgfSk7XG59OyB9O1xuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IERyb3BMaXN0RmllbGRQYWdlKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkZW1vXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vd2lkZ2V0cy9kZW1vXCIpO1xuO1xudmFyIGRyb3BfbGlzdF9maWVsZF8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9jb250cm9sL2Ryb3AtbGlzdC1maWVsZFwiKTtcbjtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnYicsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJOb3JtYWxcIilcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGRyb3BfbGlzdF9maWVsZF8xLkRyb3BMaXN0RmllbGQsIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5uYW1lIH0sIHd3OiB7ICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwubmFtZSwgJ3ZhbHVlJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwudmFsdWUsICdvcHRpb25zJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwub3B0aW9ucywgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwub25DaGFuZ2UgfSB9LCBbXSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2InLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiU3VjY2Vzc1wiKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZHJvcF9saXN0X2ZpZWxkXzEuRHJvcExpc3RGaWVsZCwgeyBodG1sOiB7fSwgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuc3VjY2Vzcy5pZCB9LCB3dzogeyAnY2xhc3NOYW1lJzogXCItc3VjY2Vzc1wiLCAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMuc3VjY2Vzcy5uYW1lLCAnb3B0aW9ucyc6IF9fY29udGV4dC52YWx1ZXMuc3VjY2Vzcy5vcHRpb25zLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3Mub25DaGFuZ2UgfSB9LCBbXSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2InLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiV2FybmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZHJvcF9saXN0X2ZpZWxkXzEuRHJvcExpc3RGaWVsZCwgeyBodG1sOiB7fSwgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMud2FybmluZy5pZCB9LCB3dzogeyAnY2xhc3NOYW1lJzogXCItd2FybmluZ1wiLCAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMud2FybmluZy5uYW1lLCAnb3B0aW9ucyc6IF9fY29udGV4dC52YWx1ZXMud2FybmluZy5vcHRpb25zLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcub25DaGFuZ2UgfSB9LCBbXSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2InLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiRXJyb3JcIilcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGRyb3BfbGlzdF9maWVsZF8xLkRyb3BMaXN0RmllbGQsIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLmlkIH0sIHd3OiB7ICdjbGFzc05hbWUnOiBcIi1lcnJvclwiLCAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMuZXJyb3IubmFtZSwgJ29wdGlvbnMnOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLm9wdGlvbnMsICdvbkNoYW5nZSc6IF9fY29udGV4dC52YWx1ZXMuZXJyb3Iub25DaGFuZ2UgfSB9LCBbXSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kcm9wLWxpc3QtZmllbGQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvZHJvcC1saXN0XCIpO1xudmFyIHJlc3VsdHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9maXh0dXJlcy9kYXRhL3Jlc3VsdHNcIik7XG52YXIgb3B0aW9ucyA9IHJlc3VsdHNfMS5yZXN1bHRzO1xudmFyIERyb3BMaXN0UGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEcm9wTGlzdFBhZ2UoKSB7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIG5vcm1hbDoge1xuICAgICAgICAgICAgICAgIGlkOiAnbm9ybWFsJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnbm9ybWFsJyxcbiAgICAgICAgICAgICAgICBsYWJlbDogJ05vcm1hbCcsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0c18xLnJlc3VsdHNbMl0udmFsdWUsXG4gICAgICAgICAgICAgICAgb25TZWxlY3Q6IGRvU2VsZWN0KHRoaXMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmxvY2s6IHtcbiAgICAgICAgICAgICAgICBpZDogJ2Jsb2NrJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnYmxvY2snLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnQmxvY2snLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgb25TZWxlY3Q6IGRvU2VsZWN0KHRoaXMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3VjY2Vzczoge1xuICAgICAgICAgICAgICAgIGlkOiAnc3VjY2VzcycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3N1Y2Nlc3MnLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnU3VjY2VzcycsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnVGhpcyBoYXMgYSBzdWNjZXNzIG1lc3NhZ2UuJyxcbiAgICAgICAgICAgICAgICBvblNlbGVjdDogZG9TZWxlY3QodGhpcylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3YXJuaW5nOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICd3YXJuaW5nJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnd2FybmluZycsXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdXYXJuaW5nJyxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdUaGlzIGhhcyBhIHdhcm5pbmcgbWVzc2FnZS4nLFxuICAgICAgICAgICAgICAgIG9uU2VsZWN0OiBkb1NlbGVjdCh0aGlzKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICBsYWJlbDogJ0Vycm9yJyxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdUaGlzIGhhcyBhIGVycm9yIG1lc3NhZ2UuJyxcbiAgICAgICAgICAgICAgICBvblNlbGVjdDogZG9TZWxlY3QodGhpcylcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBEcm9wTGlzdFBhZ2U7XG59KCkpO1xuZXhwb3J0cy5Ecm9wTGlzdFBhZ2UgPSBEcm9wTGlzdFBhZ2U7XG52YXIgZG9TZWxlY3QgPSBmdW5jdGlvbiAocGFnZSkgeyByZXR1cm4gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIG5hbWUgPSBfYS5uYW1lLCB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgIHJldHVybiBwYWdlXG4gICAgICAgIC52aWV3XG4gICAgICAgIC5maW5kQnlJZChuYW1lKVxuICAgICAgICAubWFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYWxlcnQoXCJTZWxlY3RlZDogXCIgKyBuYW1lICsgXCI9XCIgKyB2YWx1ZSk7XG4gICAgfSk7XG59OyB9O1xuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IERyb3BMaXN0UGFnZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZGVtb18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3dpZGdldHMvZGVtb1wiKTtcbjtcbnZhciBkcm9wX2xpc3RfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvY29udHJvbC9kcm9wLWxpc3RcIik7XG47XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2InLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiTm9ybWFsXCIpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChkcm9wX2xpc3RfMS5Ecm9wTGlzdCwgeyBodG1sOiB7fSwgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMubm9ybWFsLm5hbWUgfSwgd3c6IHsgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5uYW1lLCAndmFsdWUnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC52YWx1ZSwgJ29wdGlvbnMnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5vcHRpb25zLCAnb25TZWxlY3QnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5vblNlbGVjdCB9IH0sIFtdKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnYicsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJTdWNjZXNzXCIpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChkcm9wX2xpc3RfMS5Ecm9wTGlzdCwgeyBodG1sOiB7fSwgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuc3VjY2Vzcy5pZCB9LCB3dzogeyAnY2xhc3NOYW1lJzogXCItc3VjY2Vzc1wiLCAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMuc3VjY2Vzcy5uYW1lLCAnb3B0aW9ucyc6IF9fY29udGV4dC52YWx1ZXMuc3VjY2Vzcy5vcHRpb25zLCAnb25TZWxlY3QnOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3Mub25TZWxlY3QgfSB9LCBbXSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2InLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiV2FybmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZHJvcF9saXN0XzEuRHJvcExpc3QsIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcuaWQgfSwgd3c6IHsgJ2NsYXNzTmFtZSc6IFwiLXdhcm5pbmdcIiwgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcubmFtZSwgJ29wdGlvbnMnOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcub3B0aW9ucywgJ29uU2VsZWN0JzogX19jb250ZXh0LnZhbHVlcy53YXJuaW5nLm9uU2VsZWN0IH0gfSwgW10pXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChkZW1vXzEuRGVtbywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdiJywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIkVycm9yXCIpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChkcm9wX2xpc3RfMS5Ecm9wTGlzdCwgeyBodG1sOiB7fSwgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuZXJyb3IuaWQgfSwgd3c6IHsgJ2NsYXNzTmFtZSc6IFwiLWVycm9yXCIsICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5lcnJvci5uYW1lLCAnb3B0aW9ucyc6IF9fY29udGV4dC52YWx1ZXMuZXJyb3Iub3B0aW9ucywgJ29uU2VsZWN0JzogX19jb250ZXh0LnZhbHVlcy5lcnJvci5vblNlbGVjdCB9IH0sIFtdKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2InLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIkJsb2NrXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZHJvcF9saXN0XzEuRHJvcExpc3QsIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmJsb2NrLmlkIH0sIHd3OiB7ICdjbGFzc05hbWUnOiBcIi1ibG9ja1wiLCAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMuYmxvY2submFtZSwgJ2Jsb2NrJzogdHJ1ZSwgJ29uU2VsZWN0JzogX19jb250ZXh0LnZhbHVlcy5ibG9jay5vblNlbGVjdCB9IH0sIFtdKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgTWFpbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIE1haW47XG59KCkpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRyb3AtbGlzdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9maWxlLXVwbG9hZC1zdXJmYWNlXCIpO1xudmFyIEZpbGVVcGxvYWRTdXJmYWNlUGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGaWxlVXBsb2FkU3VyZmFjZVBhZ2UoKSB7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHt9O1xuICAgIH1cbiAgICByZXR1cm4gRmlsZVVwbG9hZFN1cmZhY2VQYWdlO1xufSgpKTtcbmV4cG9ydHMuRmlsZVVwbG9hZFN1cmZhY2VQYWdlID0gRmlsZVVwbG9hZFN1cmZhY2VQYWdlO1xuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IEZpbGVVcGxvYWRTdXJmYWNlUGFnZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZGVtb18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3dpZGdldHMvZGVtb1wiKTtcbjtcbnZhciBmaWxlX3VwbG9hZF9zdXJmYWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRyb2wvZmlsZS11cGxvYWQtc3VyZmFjZVwiKTtcbjtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZmlsZV91cGxvYWRfc3VyZmFjZV8xLkZpbGVVcGxvYWRTdXJmYWNlLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtdKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWxlLXVwbG9hZC1zdXJmYWNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL211bHRpLXNlbGVjdFwiKTtcbnZhciByZXN1bHRzXzEgPSByZXF1aXJlKFwiLi4vLi4vZml4dHVyZXMvZGF0YS9yZXN1bHRzXCIpO1xudmFyIE11bHRpU2VsZWN0UGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNdWx0aVNlbGVjdFBhZ2UoKSB7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIG5vcm1hbDoge1xuICAgICAgICAgICAgICAgIGlkOiAnbm9ybWFsJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnbm9ybWFsJyxcbiAgICAgICAgICAgICAgICBsYWJlbDogJ05vcm1hbCcsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdHNfMS5yZXN1bHRzWzJdLFxuICAgICAgICAgICAgICAgIHN0cmluZ2lmaWVyOiBmdW5jdGlvbiAocikgeyByZXR1cm4gci52YWx1ZTsgfSxcbiAgICAgICAgICAgICAgICBvblNlYXJjaDogb25TZWFyY2godGhpcyksXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6IG9uQ2hhbmdlKHRoaXMpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHtcbiAgICAgICAgICAgICAgICBpZDogJ3N1Y2Nlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgICAgICBsYWJlbDogJ1N1Y2Nlc3MnLFxuICAgICAgICAgICAgICAgIHN0cmluZ2lmaWVyOiBmdW5jdGlvbiAocikgeyByZXR1cm4gci52YWx1ZTsgfSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnVGhpcyBoYXMgYSBzdWNjZXNzIG1lc3NhZ2UuJyxcbiAgICAgICAgICAgICAgICBvblNlYXJjaDogb25TZWFyY2godGhpcyksXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6IG9uQ2hhbmdlKHRoaXMpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdhcm5pbmc6IHtcbiAgICAgICAgICAgICAgICBpZDogJ3dhcm5pbmcnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd3YXJuaW5nJyxcbiAgICAgICAgICAgICAgICBsYWJlbDogJ1dhcm5pbmcnLFxuICAgICAgICAgICAgICAgIHN0cmluZ2lmaWVyOiBmdW5jdGlvbiAocikgeyByZXR1cm4gci52YWx1ZTsgfSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnVGhpcyBoYXMgYSB3YXJuaW5nIG1lc3NhZ2UuJyxcbiAgICAgICAgICAgICAgICBvblNlYXJjaDogb25TZWFyY2godGhpcyksXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6IG9uQ2hhbmdlKHRoaXMpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICBsYWJlbDogJ0Vycm9yJyxcbiAgICAgICAgICAgICAgICBzdHJpbmdpZmllcjogZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIudmFsdWU7IH0sXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1RoaXMgaGFzIGEgZXJyb3IgbWVzc2FnZS4nLFxuICAgICAgICAgICAgICAgIG9uU2VhcmNoOiBvblNlYXJjaCh0aGlzKSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogb25DaGFuZ2UodGhpcyksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmxvY2s6IHtcbiAgICAgICAgICAgICAgICBpZDogJ2Jsb2NrJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnYmxvY2snLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnQmxvY2snLFxuICAgICAgICAgICAgICAgIHN0cmluZ2lmaWVyOiBmdW5jdGlvbiAocikgeyByZXR1cm4gci52YWx1ZTsgfSxcbiAgICAgICAgICAgICAgICBvblNlYXJjaDogb25TZWFyY2godGhpcyksXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6IG9uQ2hhbmdlKHRoaXMpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIE11bHRpU2VsZWN0UGFnZTtcbn0oKSk7XG5leHBvcnRzLk11bHRpU2VsZWN0UGFnZSA9IE11bHRpU2VsZWN0UGFnZTtcbnZhciBvblNlYXJjaCA9IGZ1bmN0aW9uIChwYWdlKSB7IHJldHVybiBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgbmFtZSA9IF9hLm5hbWUsIHZhbHVlID0gX2EudmFsdWU7XG4gICAgcmV0dXJuIHBhZ2VcbiAgICAgICAgLnZpZXdcbiAgICAgICAgLmZpbmRCeUlkKG5hbWUpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgdmFyIGhpdCA9IHJlc3VsdHNfMS5yZXN1bHRzLmZpbHRlcihmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgcmV0dXJuIGMudmFsdWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKHZhbHVlKSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHMudXBkYXRlKGhpdCk7XG4gICAgfSk7XG59OyB9O1xudmFyIG9uQ2hhbmdlID0gZnVuY3Rpb24gKHBhZ2UpIHsgcmV0dXJuIGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBuYW1lID0gX2EubmFtZSwgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICByZXR1cm4gcGFnZVxuICAgICAgICAudmlld1xuICAgICAgICAuZmluZEJ5SWQobmFtZSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICB0LnNldE1lc3NhZ2UoXCJDb3VudDogXCIgKyB2YWx1ZS5sZW5ndGgpO1xuICAgIH0pO1xufTsgfTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBNdWx0aVNlbGVjdFBhZ2UoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRlbW9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi93aWRnZXRzL2RlbW9cIik7XG47XG52YXIgbXVsdGlfc2VsZWN0XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRyb2wvbXVsdGktc2VsZWN0XCIpO1xuO1xuLy9AdHMtaWdub3JlOiA2MTkyXG52YXIgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19pZiA9IGZ1bmN0aW9uIChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkge1xuICAgIHJldHVybiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCgpO1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JJbiA9IGZ1bmN0aW9uIChsaXN0LCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2Zvck9mID0gZnVuY3Rpb24gKG8sIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYWluKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX190aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChkZW1vXzEuRGVtbywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChkZW1vXzEuRGVtbywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobXVsdGlfc2VsZWN0XzEuTXVsdGlTZWxlY3QsIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5pZCB9LCB3dzogeyAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMubm9ybWFsLm5hbWUsICdsYWJlbCc6IF9fY29udGV4dC52YWx1ZXMubm9ybWFsLmxhYmVsLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5zdHJpbmdpZmllciwgJ29uU2VhcmNoJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwub25TZWFyY2gsICdvbkNoYW5nZSc6IF9fY29udGV4dC52YWx1ZXMubm9ybWFsLm9uQ2hhbmdlIH0gfSwgW10pXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChkZW1vXzEuRGVtbywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobXVsdGlfc2VsZWN0XzEuTXVsdGlTZWxlY3QsIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3MuaWQgfSwgd3c6IHsgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3MubmFtZSwgJ2xhYmVsJzogX19jb250ZXh0LnZhbHVlcy5zdWNjZXNzLmxhYmVsLCAnc3VjY2Vzcyc6IF9fY29udGV4dC52YWx1ZXMuc3VjY2Vzcy5tZXNzYWdlLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3Muc3RyaW5naWZpZXIsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMuc3VjY2Vzcy5vblNlYXJjaCwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5zdWNjZXNzLm9uQ2hhbmdlIH0gfSwgW10pXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChkZW1vXzEuRGVtbywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobXVsdGlfc2VsZWN0XzEuTXVsdGlTZWxlY3QsIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcuaWQgfSwgd3c6IHsgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcubmFtZSwgJ2xhYmVsJzogX19jb250ZXh0LnZhbHVlcy53YXJuaW5nLmxhYmVsLCAnd2FybmluZyc6IF9fY29udGV4dC52YWx1ZXMud2FybmluZy5tZXNzYWdlLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcuc3RyaW5naWZpZXIsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMud2FybmluZy5vblNlYXJjaCwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy53YXJuaW5nLm9uQ2hhbmdlIH0gfSwgW10pXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChkZW1vXzEuRGVtbywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobXVsdGlfc2VsZWN0XzEuTXVsdGlTZWxlY3QsIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLmlkIH0sIHd3OiB7ICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5lcnJvci5uYW1lLCAnbGFiZWwnOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLmxhYmVsLCAnZXJyb3InOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLm1lc3NhZ2UsICdzdHJpbmdpZmllcic6IF9fY29udGV4dC52YWx1ZXMuZXJyb3Iuc3RyaW5naWZpZXIsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMuZXJyb3Iub25TZWFyY2gsICdvbkNoYW5nZSc6IF9fY29udGV4dC52YWx1ZXMuZXJyb3Iub25DaGFuZ2UgfSB9LCBbXSlcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChtdWx0aV9zZWxlY3RfMS5NdWx0aVNlbGVjdCwgeyBodG1sOiB7fSwgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuYmxvY2suaWQgfSwgd3c6IHsgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLmJsb2NrLm5hbWUsICdsYWJlbCc6IF9fY29udGV4dC52YWx1ZXMuYmxvY2subGFiZWwsICdibG9jayc6IHRydWUsICdzdHJpbmdpZmllcic6IF9fY29udGV4dC52YWx1ZXMuYmxvY2suc3RyaW5naWZpZXIsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMuYmxvY2sub25TZWFyY2gsICdvbkNoYW5nZSc6IF9fY29udGV4dC52YWx1ZXMuYmxvY2sub25DaGFuZ2UgfSB9LCBbXSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tdWx0aS1zZWxlY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvcGFnaW5hdG9yXCIpO1xudmFyIHNjZW5lcyA9IFtcbiAgICAnUGFnZSAxJyxcbiAgICAnUGFnZSAyJyxcbiAgICAnUGFnZSAzJyxcbiAgICAnUGFnZSA0JyxcbiAgICAnUGFnZSA1JyxcbiAgICAnUGFnZSA2JyxcbiAgICAnUGFnZSA3JyxcbiAgICAnUGFnZSA4JyxcbiAgICAnUGFnZSA5JyxcbiAgICAnUGFnZSAxMCdcbl07XG52YXIgUGFnaW5hdG9yUGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYWdpbmF0b3JQYWdlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbih0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBtZXNzYWdlOiBzY2VuZXNbMF0sXG4gICAgICAgICAgICBjdXJyZW50OiAxLFxuICAgICAgICAgICAgdG90YWw6IHNjZW5lcy5sZW5ndGgsXG4gICAgICAgICAgICBvbkNoYW5nZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZXMubWVzc2FnZSA9IHNjZW5lc1tlLnZhbHVlIC0gMV07XG4gICAgICAgICAgICAgICAgX3RoaXMudmFsdWVzLmN1cnJlbnQgPSBlLnZhbHVlO1xuICAgICAgICAgICAgICAgIF90aGlzLnZpZXcuaW52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gUGFnaW5hdG9yUGFnZTtcbn0oKSk7XG5leHBvcnRzLlBhZ2luYXRvclBhZ2UgPSBQYWdpbmF0b3JQYWdlO1xuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IFBhZ2luYXRvclBhZ2UoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRlbW9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi93aWRnZXRzL2RlbW9cIik7XG47XG52YXIgcGFnaW5hdG9yXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRyb2wvcGFnaW5hdG9yXCIpO1xuO1xudmFyIGxpYl8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYlwiKTtcbjtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQocGFnaW5hdG9yXzEuUGFnaW5hdG9yLCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAndG90YWwnOiBfX2NvbnRleHQudmFsdWVzLnRvdGFsLCAnY3VycmVudCc6IF9fY29udGV4dC52YWx1ZXMuY3VycmVudCwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5vbkNoYW5nZSB9IH0sIFtdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBsaWJfMS50ZXh0KF9fY29udGV4dC52YWx1ZXMubWVzc2FnZSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWdpbmF0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvc2VhcmNoXCIpO1xudmFyIHJlc3VsdHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9maXh0dXJlcy9kYXRhL3Jlc3VsdHNcIik7XG52YXIgU2VhcmNoUGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZWFyY2hQYWdlKCkge1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbih0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBpZDogJ3NlYXJjaCcsXG4gICAgICAgICAgICBuYW1lOiAnc2VhcmNoJyxcbiAgICAgICAgICAgIGlkMjogJ3NlYXJjaDInLFxuICAgICAgICAgICAgbmFtZTI6ICdzZWFyY2gyJyxcbiAgICAgICAgICAgIHN0cmluZ2lmaWVyOiBmdW5jdGlvbiAocikgeyByZXR1cm4gci52YWx1ZTsgfSxcbiAgICAgICAgICAgIG9uU2VhcmNoOiBvblNlYXJjaCh0aGlzKSxcbiAgICAgICAgICAgIG9uU2VsZWN0OiBvblNlbGVjdCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIFNlYXJjaFBhZ2U7XG59KCkpO1xuZXhwb3J0cy5TZWFyY2hQYWdlID0gU2VhcmNoUGFnZTtcbnZhciBvblNlYXJjaCA9IGZ1bmN0aW9uIChwYWdlKSB7IHJldHVybiBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgbmFtZSA9IF9hLm5hbWUsIHZhbHVlID0gX2EudmFsdWU7XG4gICAgcmV0dXJuIHBhZ2VcbiAgICAgICAgLnZpZXdcbiAgICAgICAgLmZpbmRCeUlkKG5hbWUpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgdmFyIGhpdCA9IHJlc3VsdHNfMS5yZXN1bHRzLmZpbHRlcihmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgcmV0dXJuIGMudmFsdWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKHZhbHVlLnRvTG93ZXJDYXNlKCkpID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgcy51cGRhdGUoaGl0KTtcbiAgICB9KTtcbn07IH07XG52YXIgb25TZWxlY3QgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICByZXR1cm4gYWxlcnQoXCJTZWxlY3RlZCBcXFwiXCIgKyB2YWx1ZS52YWx1ZSArIFwiXFxcIlwiKTtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgU2VhcmNoUGFnZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZGVtb18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3dpZGdldHMvZGVtb1wiKTtcbjtcbnZhciBzZWFyY2hfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvY29udHJvbC9zZWFyY2hcIik7XG47XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoc2VhcmNoXzEuU2VhcmNoLCB7IGh0bWw6IHt9LCB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pZCB9LCB3dzogeyAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMubmFtZSwgJ3N0cmluZ2lmaWVyJzogX19jb250ZXh0LnZhbHVlcy5zdHJpbmdpZmllciwgJ29uU2VhcmNoJzogX19jb250ZXh0LnZhbHVlcy5vblNlYXJjaCwgJ29uU2VsZWN0JzogX19jb250ZXh0LnZhbHVlcy5vblNlbGVjdCB9IH0sIFtdKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChzZWFyY2hfMS5TZWFyY2gsIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmlkMiB9LCB3dzogeyAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMubmFtZTIsICdibG9jayc6IHRydWUsICdzdHJpbmdpZmllcic6IF9fY29udGV4dC52YWx1ZXMuc3RyaW5naWZpZXIsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMub25TZWFyY2gsICdvblNlbGVjdCc6IF9fY29udGV4dC52YWx1ZXMub25TZWxlY3QgfSB9LCBbXSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWFyY2guanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvc2VsZWN0XCIpO1xudmFyIHJlc3VsdHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9maXh0dXJlcy9kYXRhL3Jlc3VsdHNcIik7XG52YXIgU2VsZWN0UGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZWxlY3RQYWdlKCkge1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbih0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBub3JtYWw6IHtcbiAgICAgICAgICAgICAgICBpZDogJ25vcm1hbCcsXG4gICAgICAgICAgICAgICAgbmFtZTogJ25vcm1hbCcsXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdOb3JtYWwnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHRzXzEucmVzdWx0c1syXSxcbiAgICAgICAgICAgICAgICBzdHJpbmdpZmllcjogZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIudmFsdWU7IH0sXG4gICAgICAgICAgICAgICAgb25TZWFyY2g6IGRvU2VhcmNoKHRoaXMpLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBkb0NoYW5nZSh0aGlzKSxcbiAgICAgICAgICAgICAgICBvblVuc2V0OiBkb1Vuc2V0KHRoaXMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmxvY2s6IHtcbiAgICAgICAgICAgICAgICBpZDogJ2Jsb2NrJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnYmxvY2snLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnQmxvY2snLFxuICAgICAgICAgICAgICAgIHN0cmluZ2lmaWVyOiBmdW5jdGlvbiAocikgeyByZXR1cm4gci52YWx1ZTsgfSxcbiAgICAgICAgICAgICAgICBvblNlYXJjaDogZG9TZWFyY2godGhpcyksXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6IGRvQ2hhbmdlKHRoaXMpLFxuICAgICAgICAgICAgICAgIG9uVW5zZXQ6IGRvVW5zZXQodGhpcylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdWNjZXNzOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnc3VjY2VzcycsXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdTdWNjZXNzJyxcbiAgICAgICAgICAgICAgICBzdHJpbmdpZmllcjogZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIudmFsdWU7IH0sXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1RoaXMgaGFzIGEgc3VjY2VzcyBtZXNzYWdlLicsXG4gICAgICAgICAgICAgICAgb25TZWFyY2g6IGRvU2VhcmNoKHRoaXMpLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBkb0NoYW5nZSh0aGlzKSxcbiAgICAgICAgICAgICAgICBvblVuc2V0OiBkb1Vuc2V0KHRoaXMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd2FybmluZzoge1xuICAgICAgICAgICAgICAgIGlkOiAnd2FybmluZycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3dhcm5pbmcnLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnV2FybmluZycsXG4gICAgICAgICAgICAgICAgc3RyaW5naWZpZXI6IGZ1bmN0aW9uIChyKSB7IHJldHVybiByLnZhbHVlOyB9LFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdUaGlzIGhhcyBhIHdhcm5pbmcgbWVzc2FnZS4nLFxuICAgICAgICAgICAgICAgIG9uU2VhcmNoOiBkb1NlYXJjaCh0aGlzKSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogZG9DaGFuZ2UodGhpcyksXG4gICAgICAgICAgICAgICAgb25VbnNldDogZG9VbnNldCh0aGlzKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICBsYWJlbDogJ0Vycm9yJyxcbiAgICAgICAgICAgICAgICBzdHJpbmdpZmllcjogZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIudmFsdWU7IH0sXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1RoaXMgaGFzIGEgZXJyb3IgbWVzc2FnZS4nLFxuICAgICAgICAgICAgICAgIG9uU2VhcmNoOiBkb1NlYXJjaCh0aGlzKSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogZG9DaGFuZ2UodGhpcyksXG4gICAgICAgICAgICAgICAgb25VbnNldDogZG9VbnNldCh0aGlzKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIFNlbGVjdFBhZ2U7XG59KCkpO1xuZXhwb3J0cy5TZWxlY3RQYWdlID0gU2VsZWN0UGFnZTtcbnZhciBkb1NlYXJjaCA9IGZ1bmN0aW9uIChwYWdlKSB7IHJldHVybiBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgbmFtZSA9IF9hLm5hbWUsIHZhbHVlID0gX2EudmFsdWU7XG4gICAgcmV0dXJuIHBhZ2VcbiAgICAgICAgLnZpZXdcbiAgICAgICAgLmZpbmRCeUlkKG5hbWUpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgdmFyIGhpdCA9IHJlc3VsdHNfMS5yZXN1bHRzLmZpbHRlcihmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgcmV0dXJuIGMudmFsdWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKHZhbHVlKSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHMudXBkYXRlKGhpdCk7XG4gICAgfSk7XG59OyB9O1xudmFyIGRvQ2hhbmdlID0gZnVuY3Rpb24gKHBhZ2UpIHsgcmV0dXJuIGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBuYW1lID0gX2EubmFtZSwgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICByZXR1cm4gcGFnZVxuICAgICAgICAudmlld1xuICAgICAgICAuZmluZEJ5SWQobmFtZSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICB0LnNldE1lc3NhZ2UoXCJTZWxlY3RlZDogXCIgKyB2YWx1ZS52YWx1ZSk7XG4gICAgfSk7XG59OyB9O1xudmFyIGRvVW5zZXQgPSBmdW5jdGlvbiAocGFnZSkgeyByZXR1cm4gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIG5hbWUgPSBfYS5uYW1lO1xuICAgIHJldHVybiBwYWdlXG4gICAgICAgIC52aWV3XG4gICAgICAgIC5maW5kQnlJZChuYW1lKVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHQuc2V0TWVzc2FnZSgnJyk7XG4gICAgfSk7XG59OyB9O1xuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IFNlbGVjdFBhZ2UoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRlbW9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi93aWRnZXRzL2RlbW9cIik7XG47XG52YXIgc2VsZWN0XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRyb2wvc2VsZWN0XCIpO1xuO1xuLy9AdHMtaWdub3JlOiA2MTkyXG52YXIgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19pZiA9IGZ1bmN0aW9uIChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkge1xuICAgIHJldHVybiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCgpO1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JJbiA9IGZ1bmN0aW9uIChsaXN0LCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2Zvck9mID0gZnVuY3Rpb24gKG8sIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYWluKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX190aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChkZW1vXzEuRGVtbywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChkZW1vXzEuRGVtbywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoc2VsZWN0XzEuU2VsZWN0LCB7IGh0bWw6IHt9LCB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwuaWQgfSwgd3c6IHsgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5uYW1lLCAnbGFiZWwnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5sYWJlbCwgJ3ZhbHVlJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwudmFsdWUsICdzdHJpbmdpZmllcic6IF9fY29udGV4dC52YWx1ZXMubm9ybWFsLnN0cmluZ2lmaWVyLCAnb25TZWFyY2gnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5vblNlYXJjaCwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwub25DaGFuZ2UgfSB9LCBbXSlcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChzZWxlY3RfMS5TZWxlY3QsIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3MuaWQgfSwgd3c6IHsgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3MubmFtZSwgJ2xhYmVsJzogX19jb250ZXh0LnZhbHVlcy5zdWNjZXNzLmxhYmVsLCAnc3VjY2Vzcyc6IF9fY29udGV4dC52YWx1ZXMuc3VjY2Vzcy5tZXNzYWdlLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3Muc3RyaW5naWZpZXIsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMuc3VjY2Vzcy5vblNlYXJjaCwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5zdWNjZXNzLm9uQ2hhbmdlIH0gfSwgW10pXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChkZW1vXzEuRGVtbywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoc2VsZWN0XzEuU2VsZWN0LCB7IGh0bWw6IHt9LCB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy53YXJuaW5nLmlkIH0sIHd3OiB7ICduYW1lJzogX19jb250ZXh0LnZhbHVlcy53YXJuaW5nLm5hbWUsICdsYWJlbCc6IF9fY29udGV4dC52YWx1ZXMud2FybmluZy5sYWJlbCwgJ3dhcm5pbmcnOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcubWVzc2FnZSwgJ3N0cmluZ2lmaWVyJzogX19jb250ZXh0LnZhbHVlcy53YXJuaW5nLnN0cmluZ2lmaWVyLCAnb25TZWFyY2gnOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcub25TZWFyY2gsICdvbkNoYW5nZSc6IF9fY29udGV4dC52YWx1ZXMud2FybmluZy5vbkNoYW5nZSB9IH0sIFtdKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHNlbGVjdF8xLlNlbGVjdCwgeyBodG1sOiB7fSwgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuZXJyb3IuaWQgfSwgd3c6IHsgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLm5hbWUsICdsYWJlbCc6IF9fY29udGV4dC52YWx1ZXMuZXJyb3IubGFiZWwsICdlcnJvcic6IF9fY29udGV4dC52YWx1ZXMuZXJyb3IubWVzc2FnZSwgJ3N0cmluZ2lmaWVyJzogX19jb250ZXh0LnZhbHVlcy5lcnJvci5zdHJpbmdpZmllciwgJ29uU2VhcmNoJzogX19jb250ZXh0LnZhbHVlcy5lcnJvci5vblNlYXJjaCwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5lcnJvci5vbkNoYW5nZSB9IH0sIFtdKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHNlbGVjdF8xLlNlbGVjdCwgeyBodG1sOiB7fSwgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuYmxvY2suaWQgfSwgd3c6IHsgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLmJsb2NrLm5hbWUsICdsYWJlbCc6IF9fY29udGV4dC52YWx1ZXMuYmxvY2subGFiZWwsICdibG9jayc6IHRydWUsICdzdHJpbmdpZmllcic6IF9fY29udGV4dC52YWx1ZXMuYmxvY2suc3RyaW5naWZpZXIsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMuYmxvY2sub25TZWFyY2gsICdvbkNoYW5nZSc6IF9fY29udGV4dC52YWx1ZXMuYmxvY2sub25DaGFuZ2UgfSB9LCBbXSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWxlY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvc3RhY2stc2VsZWN0XCIpO1xudmFyIHJlc3VsdHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9maXh0dXJlcy9kYXRhL3Jlc3VsdHNcIik7XG52YXIgU3RhY2tTZWxlY3RQYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YWNrU2VsZWN0UGFnZSgpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgYXNjOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdhc2MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdhc2MnLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnQXNjZW5kaW5nJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0c18xLnJlc3VsdHNbMl0sXG4gICAgICAgICAgICAgICAgc3RyaW5naWZpZXI6IGZ1bmN0aW9uIChyKSB7IHJldHVybiByLnZhbHVlOyB9LFxuICAgICAgICAgICAgICAgIG9uU2VhcmNoOiBvblNlYXJjaCh0aGlzKSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogb25DaGFuZ2UodGhpcyksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVzYzoge1xuICAgICAgICAgICAgICAgIGlkOiAnZGVzYycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2Rlc2MnLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnRGVzY2VuZGluZycsXG4gICAgICAgICAgICAgICAgc3RyaW5naWZpZXI6IGZ1bmN0aW9uIChyKSB7IHJldHVybiByLnZhbHVlOyB9LFxuICAgICAgICAgICAgICAgIG9uU2VhcmNoOiBvblNlYXJjaCh0aGlzKSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogb25DaGFuZ2UodGhpcyksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3VjY2Vzczoge1xuICAgICAgICAgICAgICAgIGlkOiAnc3VjY2VzcycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3N1Y2Nlc3MnLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnU3VjY2VzcycsXG4gICAgICAgICAgICAgICAgc3RyaW5naWZpZXI6IGZ1bmN0aW9uIChyKSB7IHJldHVybiByLnZhbHVlOyB9LFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdUaGlzIGhhcyBhIHN1Y2Nlc3MgbWVzc2FnZS4nLFxuICAgICAgICAgICAgICAgIG9uU2VhcmNoOiBvblNlYXJjaCh0aGlzKSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogb25DaGFuZ2UodGhpcyksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd2FybmluZzoge1xuICAgICAgICAgICAgICAgIGlkOiAnd2FybmluZycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3dhcm5pbmcnLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnV2FybmluZycsXG4gICAgICAgICAgICAgICAgc3RyaW5naWZpZXI6IGZ1bmN0aW9uIChyKSB7IHJldHVybiByLnZhbHVlOyB9LFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdUaGlzIGhhcyBhIHdhcm5pbmcgbWVzc2FnZS4nLFxuICAgICAgICAgICAgICAgIG9uU2VhcmNoOiBvblNlYXJjaCh0aGlzKSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogb25DaGFuZ2UodGhpcyksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgICBpZDogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnRXJyb3InLFxuICAgICAgICAgICAgICAgIHN0cmluZ2lmaWVyOiBmdW5jdGlvbiAocikgeyByZXR1cm4gci52YWx1ZTsgfSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnVGhpcyBoYXMgYSBlcnJvciBtZXNzYWdlLicsXG4gICAgICAgICAgICAgICAgb25TZWFyY2g6IG9uU2VhcmNoKHRoaXMpLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBvbkNoYW5nZSh0aGlzKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBTdGFja1NlbGVjdFBhZ2U7XG59KCkpO1xuZXhwb3J0cy5TdGFja1NlbGVjdFBhZ2UgPSBTdGFja1NlbGVjdFBhZ2U7XG52YXIgb25TZWFyY2ggPSBmdW5jdGlvbiAocGFnZSkgeyByZXR1cm4gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIG5hbWUgPSBfYS5uYW1lLCB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgIHJldHVybiBwYWdlXG4gICAgICAgIC52aWV3XG4gICAgICAgIC5maW5kQnlJZChuYW1lKVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHZhciBoaXQgPSByZXN1bHRzXzEucmVzdWx0cy5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHJldHVybiBjLnZhbHVlLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCh2YWx1ZSkgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBzLnVwZGF0ZShoaXQpO1xuICAgIH0pO1xufTsgfTtcbnZhciBvbkNoYW5nZSA9IGZ1bmN0aW9uIChwYWdlKSB7IHJldHVybiBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgbmFtZSA9IF9hLm5hbWUsIHZhbHVlID0gX2EudmFsdWU7XG4gICAgcmV0dXJuIHBhZ2VcbiAgICAgICAgLnZpZXdcbiAgICAgICAgLmZpbmRCeUlkKG5hbWUpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdC5zZXRNZXNzYWdlKFwiQ291bnQ6IFwiICsgdmFsdWUubGVuZ3RoKTtcbiAgICB9KTtcbn07IH07XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgU3RhY2tTZWxlY3RQYWdlKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkZW1vXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vd2lkZ2V0cy9kZW1vXCIpO1xuO1xudmFyIHN0YWNrX3NlbGVjdF8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9jb250cm9sL3N0YWNrLXNlbGVjdFwiKTtcbjtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHN0YWNrX3NlbGVjdF8xLlN0YWNrU2VsZWN0LCB7IGh0bWw6IHt9LCB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5hc2MuaWQgfSwgd3c6IHsgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLmFzYy5uYW1lLCAnbGFiZWwnOiBfX2NvbnRleHQudmFsdWVzLmFzYy5sYWJlbCwgJ3N0cmluZ2lmaWVyJzogX19jb250ZXh0LnZhbHVlcy5hc2Muc3RyaW5naWZpZXIsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMuYXNjLm9uU2VhcmNoLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLmFzYy5vbkNoYW5nZSB9IH0sIFtdKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHN0YWNrX3NlbGVjdF8xLlN0YWNrU2VsZWN0LCB7IGh0bWw6IHt9LCB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5kZXNjLmlkIH0sIHd3OiB7ICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5kZXNjLm5hbWUsICdsYWJlbCc6IF9fY29udGV4dC52YWx1ZXMuZGVzYy5sYWJlbCwgJ2Rpcic6IC0xLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLmRlc2Muc3RyaW5naWZpZXIsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMuZGVzYy5vblNlYXJjaCwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5kZXNjLm9uQ2hhbmdlIH0gfSwgW10pXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChkZW1vXzEuRGVtbywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoc3RhY2tfc2VsZWN0XzEuU3RhY2tTZWxlY3QsIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3MuaWQgfSwgd3c6IHsgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3MubmFtZSwgJ2xhYmVsJzogX19jb250ZXh0LnZhbHVlcy5zdWNjZXNzLmxhYmVsLCAnc3VjY2Vzcyc6IF9fY29udGV4dC52YWx1ZXMuc3VjY2Vzcy5tZXNzYWdlLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3Muc3RyaW5naWZpZXIsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMuc3VjY2Vzcy5vblNlYXJjaCwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy5zdWNjZXNzLm9uQ2hhbmdlIH0gfSwgW10pXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChkZW1vXzEuRGVtbywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoc3RhY2tfc2VsZWN0XzEuU3RhY2tTZWxlY3QsIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcuaWQgfSwgd3c6IHsgJ25hbWUnOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcubmFtZSwgJ2xhYmVsJzogX19jb250ZXh0LnZhbHVlcy53YXJuaW5nLmxhYmVsLCAnd2FybmluZyc6IF9fY29udGV4dC52YWx1ZXMud2FybmluZy5tZXNzYWdlLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcuc3RyaW5naWZpZXIsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMud2FybmluZy5vblNlYXJjaCwgJ29uQ2hhbmdlJzogX19jb250ZXh0LnZhbHVlcy53YXJuaW5nLm9uQ2hhbmdlIH0gfSwgW10pXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChkZW1vXzEuRGVtbywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoc3RhY2tfc2VsZWN0XzEuU3RhY2tTZWxlY3QsIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLmlkIH0sIHd3OiB7ICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5lcnJvci5uYW1lLCAnbGFiZWwnOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLmxhYmVsLCAnZXJyb3InOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLm1lc3NhZ2UsICdzdHJpbmdpZmllcic6IF9fY29udGV4dC52YWx1ZXMuZXJyb3Iuc3RyaW5naWZpZXIsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMuZXJyb3Iub25TZWFyY2gsICdvbkNoYW5nZSc6IF9fY29udGV4dC52YWx1ZXMuZXJyb3Iub25DaGFuZ2UgfSB9LCBbXSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGFjay1zZWxlY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvc3RhY2tcIik7XG52YXIgX2dldFZhbHVlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IGxhYmVsOiAnQXN1cycsIHZhbHVlOiAnQXN1cycgfSxcbiAgICB7IGxhYmVsOiAnTVNJJywgdmFsdWU6ICdNU0knIH0sXG4gICAgeyBsYWJlbDogJ01TSScsIHZhbHVlOiAnTVNJJyB9LFxuICAgIHsgbGFiZWw6ICdHaWdhYnl0ZScsIHZhbHVlOiAnR2lnYWJ5dGUnIH1cbl07IH07XG52YXIgX2dldFRleHQgPSBmdW5jdGlvbiAobSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShtLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGxhYmVsID0gX2EubGFiZWw7XG4gICAgICAgIHJldHVybiBsYWJlbDtcbiAgICB9KS5qb2luKCcsJykpO1xufTtcbnZhciBTdGFja1BhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhY2tQYWdlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbih0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICB2YWx1ZXM6IF9nZXRWYWx1ZXMoKSxcbiAgICAgICAgICAgIHRleHQ6IF9nZXRUZXh0KF9nZXRWYWx1ZXMoKSksXG4gICAgICAgICAgICBkZWNvcmF0b3I6IGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLmxhYmVsOyB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZXMudmFsdWVzID0gX2dldFZhbHVlcygpO1xuICAgICAgICAgICAgX3RoaXMudmFsdWVzLnRleHQgPSBfZ2V0VGV4dChfdGhpcy52YWx1ZXMudmFsdWVzKTtcbiAgICAgICAgICAgIF90aGlzLnZpZXcuaW52YWxpZGF0ZSgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gU3RhY2tQYWdlO1xufSgpKTtcbmV4cG9ydHMuU3RhY2tQYWdlID0gU3RhY2tQYWdlO1xuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IFN0YWNrUGFnZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZGVtb18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3dpZGdldHMvZGVtb1wiKTtcbjtcbnZhciBzdGFja18xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9jb250cm9sL3N0YWNrXCIpO1xuO1xuLy9AdHMtaWdub3JlOiA2MTkyXG52YXIgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19pZiA9IGZ1bmN0aW9uIChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkge1xuICAgIHJldHVybiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCgpO1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JJbiA9IGZ1bmN0aW9uIChsaXN0LCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2Zvck9mID0gZnVuY3Rpb24gKG8sIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYWluKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX190aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChkZW1vXzEuRGVtbywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJNZW1iZXJzOiBcIiksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdiJywgeyBodG1sOiB7fSwgd21sOiB7ICdpZCc6IFwic2VsZWN0ZWRcIiB9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fY29udGV4dC52YWx1ZXMudGV4dFxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCIuXCIpXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChzdGFja18xLlN0YWNrLCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAnbmFtZSc6IFwic3RhY2tcIiwgJ3ZhbHVlJzogX19jb250ZXh0LnZhbHVlcy52YWx1ZXMsICdkZWNvcmF0b3InOiBfX2NvbnRleHQudmFsdWVzLmRlY29yYXRvciwgJ29uQ2hhbmdlJzogX19jb250ZXh0Lm9uQ2hhbmdlIH0gfSwgW10pXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBNYWluLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gTWFpbjtcbn0oKSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhY2suanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvc3dpdGNoXCIpO1xudmFyIFN3aXRjaFBhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3dpdGNoUGFnZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0cnVlO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgIF90aGlzLnZpZXcuZmluZEJ5SWQoJ2NvbnRlbnQnKVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZS5maXJzdENoaWxkKVxuICAgICAgICAgICAgICAgICAgICBlLnJlbW92ZUNoaWxkKGUuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWx1ZSA9PT0gdHJ1ZSA/XG4gICAgICAgICAgICAgICAgICAgICdvbicgOlxuICAgICAgICAgICAgICAgICAgICAodmFsdWUgPT09IGZhbHNlID8gJ29mZicgOiAnZXJyb3InKSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBTd2l0Y2hQYWdlO1xufSgpKTtcbmV4cG9ydHMuU3dpdGNoUGFnZSA9IFN3aXRjaFBhZ2U7XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgU3dpdGNoUGFnZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZGVtb18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3dpZGdldHMvZGVtb1wiKTtcbjtcbnZhciBzd2l0Y2hfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvY29udHJvbC9zd2l0Y2hcIik7XG47XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiVGhlIHN3aXRjaCBpcyBhbHJlYWR5IHNldC5cIilcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHN3aXRjaF8xLlN3aXRjaCwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ25hbWUnOiBcInN3aXRjaFwiLCAndmFsdWUnOiB0cnVlIH0gfSwgW10pXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChkZW1vXzEuRGVtbywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlRoZSBzd2l0Y2ggaXMgXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2InLCB7IGh0bWw6IHt9LCB3bWw6IHsgJ2lkJzogXCJjb250ZW50XCIgfSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJ1bnRvdWNoZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCIuXCIpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChzd2l0Y2hfMS5Td2l0Y2gsIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICduYW1lJzogXCJzd2l0Y2hcIiwgJ29uQ2hhbmdlJzogX19jb250ZXh0Lm9uQ2hhbmdlIH0gfSwgW10pXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBNYWluLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gTWFpbjtcbn0oKSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3dpdGNoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL3RhYi1iYXJcIik7XG52YXIgVGFiQmFyUGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWJCYXJQYWdlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbih0aGlzKTtcbiAgICAgICAgdGhpcy50YWIgPSAnRmlyc3QnO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnRmlyc3QgVGFiJyk7XG4gICAgICAgIHRoaXMuY2xpY2tlZCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBfYS5uYW1lO1xuICAgICAgICAgICAgX3RoaXMudGFiID0gbmFtZTtcbiAgICAgICAgICAgIF90aGlzLmNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShuYW1lICsgXCIgVGFiXCIpO1xuICAgICAgICAgICAgX3RoaXMudmlldy5pbnZhbGlkYXRlKCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBUYWJCYXJQYWdlO1xufSgpKTtcbmV4cG9ydHMuVGFiQmFyUGFnZSA9IFRhYkJhclBhZ2U7XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgVGFiQmFyUGFnZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZGVtb18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3dpZGdldHMvZGVtb1wiKTtcbjtcbnZhciB0YWJfYmFyXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRyb2wvdGFiLWJhclwiKTtcbjtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHRhYl9iYXJfMS5UYWJCYXIsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldCh0YWJfYmFyXzEuVGFiLCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAnYWN0aXZlJzogKF9fY29udGV4dC50YWIgPT09IFwiRmlyc3RcIiksICd0ZXh0JzogXCJGaXJzdFwiLCAnbmFtZSc6IFwiRmlyc3RcIiwgJ29uQ2xpY2snOiBfX2NvbnRleHQuY2xpY2tlZCB9IH0sIFtdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQodGFiX2Jhcl8xLlRhYiwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ2FjdGl2ZSc6IChfX2NvbnRleHQudGFiID09PSBcIlNlY29uZFwiKSwgJ3RleHQnOiBcIlNlY29uZFwiLCAnbmFtZSc6IFwiU2Vjb25kXCIsICdvbkNsaWNrJzogX19jb250ZXh0LmNsaWNrZWQgfSB9LCBbXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHRhYl9iYXJfMS5UYWIsIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdhY3RpdmUnOiAoX19jb250ZXh0LnRhYiA9PT0gXCJUaGlyZFwiKSwgJ3RleHQnOiBcIlRoaXJkXCIsICduYW1lJzogXCJUaGlyZFwiLCAnb25DbGljayc6IF9fY29udGV4dC5jbGlja2VkIH0gfSwgW10pXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChkZW1vXzEuRGVtbywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQodGFiX2Jhcl8xLlRhYkJhciwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ2p1c3RpZnknOiB0cnVlIH0gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldCh0YWJfYmFyXzEuVGFiLCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAnYWN0aXZlJzogKF9fY29udGV4dC50YWIgPT09IFwiRmlyc3RcIiksICd0ZXh0JzogXCJGaXJzdFwiLCAnbmFtZSc6IFwiRmlyc3RcIiwgJ29uQ2xpY2snOiBfX2NvbnRleHQuY2xpY2tlZCB9IH0sIFtdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQodGFiX2Jhcl8xLlRhYiwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ2FjdGl2ZSc6IChfX2NvbnRleHQudGFiID09PSBcIlNlY29uZFwiKSwgJ3RleHQnOiBcIlNlY29uZFwiLCAnbmFtZSc6IFwiU2Vjb25kXCIsICdvbkNsaWNrJzogX19jb250ZXh0LmNsaWNrZWQgfSB9LCBbXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHRhYl9iYXJfMS5UYWIsIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdhY3RpdmUnOiAoX19jb250ZXh0LnRhYiA9PT0gXCJUaGlyZFwiKSwgJ3RleHQnOiBcIlRoaXJkXCIsICduYW1lJzogXCJUaGlyZFwiLCAnb25DbGljayc6IF9fY29udGV4dC5jbGlja2VkIH0gfSwgW10pXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChkZW1vXzEuRGVtbywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywgeyBodG1sOiB7fSwgd21sOiB7ICdpZCc6IFwiY29udGVudFwiIH0gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX19jb250ZXh0LmNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWItYmFyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL3RhZ1wiKTtcbnZhciBzdHlsZV8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL2xpYi9jb250ZW50L3N0eWxlXCIpO1xudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICBzdHlsZV8xLlN0eWxlLkRlZmF1bHQsXG4gICAgc3R5bGVfMS5TdHlsZS5QcmltYXJ5LFxuICAgIHN0eWxlXzEuU3R5bGUuU3VjY2VzcyxcbiAgICBzdHlsZV8xLlN0eWxlLkluZm8sXG4gICAgc3R5bGVfMS5TdHlsZS5XYXJuaW5nLFxuICAgIHN0eWxlXzEuU3R5bGUuRXJyb3Jcbl07IH07XG52YXIgVGFnUGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWdQYWdlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbih0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBjYXBpdGFsaXplOiBmdW5jdGlvbiAocykgeyByZXR1cm4gXCJcIiArIHNbMF0udG9VcHBlckNhc2UoKSArIHMuc2xpY2UoMSk7IH0sXG4gICAgICAgICAgICBzdHlsZXM6IGdldFN0eWxlcygpLFxuICAgICAgICAgICAgb25EaXNtaXNzOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHZhciBpZHggPSBfdGhpcy52YWx1ZXMuc3R5bGVzLmluZGV4T2YoZS5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoaWR4ID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnZhbHVlcy5zdHlsZXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnZhbHVlcy5zdHlsZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZXMuc3R5bGVzID0gZ2V0U3R5bGVzKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMudmlldy5pbnZhbGlkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBUYWdQYWdlO1xufSgpKTtcbmV4cG9ydHMuVGFnUGFnZSA9IFRhZ1BhZ2U7XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgVGFnUGFnZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19zcHJlYWRBcnJheXMgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xuICAgIHJldHVybiByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0YWdfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvY29udHJvbC90YWdcIik7XG47XG52YXIgZGVtb18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3dpZGdldHMvZGVtb1wiKTtcbjtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaDEnLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiVGFnXCIpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgX19zcHJlYWRBcnJheXMoW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2gyJywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJTdHlsZXNcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgIF0sIF9fZm9ySW4oX19jb250ZXh0LnZhbHVlcy5zdHlsZXMsIGZ1bmN0aW9uICh2LCBfJCRpLCBfJCRhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQodGFnXzEuVGFnLCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAnc3R5bGUnOiB2LCAndGV4dCc6IF9fY29udGV4dC52YWx1ZXMuY2FwaXRhbGl6ZSh2KSwgJ25hbWUnOiB2LCAnb25EaXNtaXNzJzogX19jb250ZXh0LnZhbHVlcy5vbkRpc21pc3MgfSB9LCBbXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiAoW10pOyB9KSkpXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBNYWluLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gTWFpbjtcbn0oKSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFnLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL3RleHQtZmllbGRcIik7XG52YXIgZmVlZGJhY2tfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi9saWIvY29udHJvbC9mZWVkYmFja1wiKTtcbnZhciBUZXh0RmllbGRQYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRleHRGaWVsZFBhZ2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuaWQgPSAndGV4dCc7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IF9hLm5hbWUsIHZhbHVlID0gX2EudmFsdWU7XG4gICAgICAgICAgICB2YXIgbWF5YmVGaWVsZCA9IF90aGlzLnZpZXcuZmluZEJ5SWQobmFtZSk7XG4gICAgICAgICAgICBpZiAobWF5YmVGaWVsZC5pc0p1c3QoKSkge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gbWF5YmVGaWVsZC5nZXQoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ25ldXRyYWwnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdC5zZXRWYWxpZGF0aW9uU3RhdGUoZmVlZGJhY2tfMS5WYWxpZGF0aW9uU3RhdGUuTmV1dHJhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgdC5zZXRWYWxpZGF0aW9uU3RhdGUoZmVlZGJhY2tfMS5WYWxpZGF0aW9uU3RhdGUuRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N1Y2Nlc3MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdC5zZXRWYWxpZGF0aW9uU3RhdGUoZmVlZGJhY2tfMS5WYWxpZGF0aW9uU3RhdGUuU3VjY2Vzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnd2FybmluZyc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0LnNldFZhbGlkYXRpb25TdGF0ZShmZWVkYmFja18xLlZhbGlkYXRpb25TdGF0ZS5XYXJuaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHQuc2V0TWVzc2FnZShcIk1lc3NhZ2U6IFwiICsgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gVGV4dEZpZWxkUGFnZTtcbn0oKSk7XG5leHBvcnRzLlRleHRGaWVsZFBhZ2UgPSBUZXh0RmllbGRQYWdlO1xuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IFRleHRGaWVsZFBhZ2UoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRlbW9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi93aWRnZXRzL2RlbW9cIik7XG47XG52YXIgZmVlZGJhY2tfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvY29udHJvbC9mZWVkYmFja1wiKTtcbjtcbnZhciB0ZXh0X2ZpZWxkXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRyb2wvdGV4dC1maWVsZFwiKTtcbjtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJUaGUgdmFsdWUgb2YgdGhlIGlucHV0IGlzOlwiKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdiJywgeyBodG1sOiB7fSwgd21sOiB7ICdpZCc6IFwiY29udGVudFwiIH0gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiTm90aGluZ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHRleHRfZmllbGRfMS5UZXh0RmllbGQsIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBcInRleHRcIiB9LCB3dzogeyAnbmFtZSc6IFwidGV4dFwiLCAnbWVzc2FnZSc6IFwiVGhpcyBpcyB0aGUgaGVscCBtZXNzYWdlXCIsICdvbkNoYW5nZSc6IF9fY29udGV4dC5vbkNoYW5nZSB9IH0sIFtdKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3N0cm9uZycsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiU3VjY2Vzc1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHRleHRfZmllbGRfMS5UZXh0RmllbGQsIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBcInN1Y2Nlc3NcIiB9LCB3dzogeyAnbmFtZSc6IFwic3VjY2Vzc1wiLCAndmFsaWRhdGlvblN0YXRlJzogZmVlZGJhY2tfMS5WYWxpZGF0aW9uU3RhdGUuU3VjY2VzcywgJ2xhYmVsJzogXCJUaGlzIGlzIGEgc3VjY2VzcyBsYWJlbFwiLCAnc3VjY2Vzcyc6IFwiVGhpcyB0ZXh0ZmllbGQgaGFzIGEgc3VjY2Vzc1wiLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQub25DaGFuZ2UgfSB9LCBbXSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdzdHJvbmcnLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIldhcm5pbmdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldCh0ZXh0X2ZpZWxkXzEuVGV4dEZpZWxkLCB7IGh0bWw6IHt9LCB3bWw6IHsgJ2lkJzogXCJ3YXJuaW5nXCIgfSwgd3c6IHsgJ25hbWUnOiBcIndhcm5pbmdcIiwgJ3ZhbGlkYXRpb25TdGF0ZSc6IGZlZWRiYWNrXzEuVmFsaWRhdGlvblN0YXRlLldhcm5pbmcsICdsYWJlbCc6IFwiVGhpcyBpcyBhIHdhcm5pbmcgbGFiZWxcIiwgJ3dhcm5pbmcnOiBcIlRoaXMgdGV4dGZpZWxkIGhhcyBhIHdhcm5pbmcuXCIsICdvbkNoYW5nZSc6IF9fY29udGV4dC5vbkNoYW5nZSB9IH0sIFtdKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3N0cm9uZycsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiRXJyb3JcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldCh0ZXh0X2ZpZWxkXzEuVGV4dEZpZWxkLCB7IGh0bWw6IHt9LCB3bWw6IHsgJ2lkJzogXCJlcnJvclwiIH0sIHd3OiB7ICduYW1lJzogXCJlcnJvclwiLCAndmFsaWRhdGlvblN0YXRlJzogZmVlZGJhY2tfMS5WYWxpZGF0aW9uU3RhdGUuRXJyb3IsICdsYWJlbCc6IFwiVGhpcyBpcyBhbiBlcnJvciBsYWJlbFwiLCAnZXJyb3InOiBcIlRoaXMgdGV4dGZpZWxkIGhhcyBhbiBlcnJvci5cIiwgJ29uQ2hhbmdlJzogX19jb250ZXh0Lm9uQ2hhbmdlIH0gfSwgW10pXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChkZW1vXzEuRGVtbywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlRoZSBvbmUgdXNlcyByb3dzIHRvIHJlbmRlciBhIHRleHQgYXJlYTpcIilcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHRleHRfZmllbGRfMS5UZXh0RmllbGQsIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBcImFyZWFcIiB9LCB3dzogeyAnbmFtZSc6IFwiYXJlYVwiLCAncm93cyc6IDUsICdsYWJlbCc6IFwiVGhpcyBpcyBhIHRleHRhcmVhIGxhYmVsXCIsICdvbkNoYW5nZSc6IF9fY29udGV4dC5vbkNoYW5nZSB9IH0sIFtdKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgTWFpbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIE1haW47XG59KCkpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRleHQtZmllbGQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvdGV4dC1pbnB1dFwiKTtcbnZhciBzaXplXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRlbnQvc2l6ZVwiKTtcbnZhciBUZXh0SW5wdXRQYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRleHRJbnB1dFBhZ2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnNpemVzID0gW1xuICAgICAgICAgICAgc2l6ZV8xLlNpemUuRXh0cmFTbWFsbCxcbiAgICAgICAgICAgIHNpemVfMS5TaXplLlNtYWxsLFxuICAgICAgICAgICAgc2l6ZV8xLlNpemUuTWVkaXVtLFxuICAgICAgICAgICAgc2l6ZV8xLlNpemUuTGFyZ2UsXG4gICAgICAgICAgICBzaXplXzEuU2l6ZS5FeHRyYUxhcmdlXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuY29udGVudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCd0aGlzJyk7IH07XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICAgICAgX3RoaXNcbiAgICAgICAgICAgICAgICAudmlld1xuICAgICAgICAgICAgICAgIC5maW5kQnlJZCgndHh0JylcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChoKSB7IHJldHVybiBoLmlubmVySFRNTCA9IHZhbHVlOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIFRleHRJbnB1dFBhZ2U7XG59KCkpO1xuZXhwb3J0cy5UZXh0SW5wdXRQYWdlID0gVGV4dElucHV0UGFnZTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBUZXh0SW5wdXRQYWdlKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3NwcmVhZEFycmF5cyA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheXMpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxuICAgICAgICAgICAgcltrXSA9IGFbal07XG4gICAgcmV0dXJuIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRleHRfaW5wdXRfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvY29udHJvbC90ZXh0LWlucHV0XCIpO1xuO1xudmFyIGRlbW9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi93aWRnZXRzL2RlbW9cIik7XG47XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiVGhpcyBpcyBhIHRleHQgaW5wdXQ6IFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQodGV4dF9pbnB1dF8xLlRleHRJbnB1dCwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ29uQ2hhbmdlJzogX19jb250ZXh0Lm9uQ2hhbmdlIH0gfSwgW10pLFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCIuXCIpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJBcyB5b3UgdHlwZSBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnYicsIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBcInR4dFwiIH0gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwidGhpc1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIiBjaGFuZ2VzLlwiKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgX19zcHJlYWRBcnJheXMoX19mb3JJbihfX2NvbnRleHQuc2l6ZXMsIGZ1bmN0aW9uICh2LCBfJCRpLCBfJCRhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgICBTaXplIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgodiArIFwiIG5ldXRyYWw6IFwiKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldCh0ZXh0X2lucHV0XzEuVGV4dElucHV0LCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAnb25DaGFuZ2UnOiBfX2NvbnRleHQub25DaGFuZ2UsICdzaXplJzogdiB9IH0sIFtdKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgICBTaXplIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgodiArIFwiIGVycm9yOiBcIikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQodGV4dF9pbnB1dF8xLlRleHRJbnB1dCwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ29uQ2hhbmdlJzogX19jb250ZXh0Lm9uQ2hhbmdlLCAnc2l6ZSc6IHYsICdjbGFzc05hbWUnOiBcIi1lcnJvclwiIH0gfSwgW10pXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICAgIFNpemUgXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCh2ICsgXCIgd2FybmluZzogXCIpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHRleHRfaW5wdXRfMS5UZXh0SW5wdXQsIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdvbkNoYW5nZSc6IF9fY29udGV4dC5vbkNoYW5nZSwgJ3NpemUnOiB2LCAnY2xhc3NOYW1lJzogXCItd2FybmluZ1wiIH0gfSwgW10pXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICAgIFNpemUgXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCh2ICsgXCIgc3VjY2VzczogXCIpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHRleHRfaW5wdXRfMS5UZXh0SW5wdXQsIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdvbkNoYW5nZSc6IF9fY29udGV4dC5vbkNoYW5nZSwgJ3NpemUnOiB2LCAnY2xhc3NOYW1lJzogXCItc3VjY2Vzc1wiIH0gfSwgW10pXG4gICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiAoW10pOyB9KSkpLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICBCbG9jazpcXG4gICAgICBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHRleHRfaW5wdXRfMS5UZXh0SW5wdXQsIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdvbkNoYW5nZSc6IF9fY29udGV4dC5vbkNoYW5nZSwgJ2Jsb2NrJzogdHJ1ZSB9IH0sIFtdKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiIFRleHRhcmVhOiBcIilcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIF9fc3ByZWFkQXJyYXlzKF9fZm9ySW4oX19jb250ZXh0LnNpemVzLCBmdW5jdGlvbiAodiwgXyQkaSwgXyQkYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICAgICAgU2l6ZSBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoKHYgKyBcIiBuZXV0cmFsOiBcIikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQodGV4dF9pbnB1dF8xLlRleHRJbnB1dCwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ29uQ2hhbmdlJzogX19jb250ZXh0Lm9uQ2hhbmdlLCAncm93cyc6IDUsICdzaXplJzogdiB9IH0sIFtdKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgICBTaXplIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgodiArIFwiIGVycm9yOiBcIikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQodGV4dF9pbnB1dF8xLlRleHRJbnB1dCwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ29uQ2hhbmdlJzogX19jb250ZXh0Lm9uQ2hhbmdlLCAnc2l6ZSc6IHYsICdyb3dzJzogNSwgJ2NsYXNzTmFtZSc6IFwiLWVycm9yXCIgfSB9LCBbXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICAgICAgU2l6ZSBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoKHYgKyBcIiB3YXJuaW5nOiBcIikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQodGV4dF9pbnB1dF8xLlRleHRJbnB1dCwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ29uQ2hhbmdlJzogX19jb250ZXh0Lm9uQ2hhbmdlLCAnc2l6ZSc6IHYsICdyb3dzJzogNSwgJ2NsYXNzTmFtZSc6IFwiLXdhcm5pbmdcIiB9IH0sIFtdKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgICBTaXplIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgodiArIFwiIHN1Y2Nlc3M6IFwiKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldCh0ZXh0X2lucHV0XzEuVGV4dElucHV0LCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAnb25DaGFuZ2UnOiBfX2NvbnRleHQub25DaGFuZ2UsICdzaXplJzogdiwgJ3Jvd3MnOiA1LCAnY2xhc3NOYW1lJzogXCItc3VjY2Vzc1wiIH0gfSwgW10pXG4gICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiAoW10pOyB9KSkpLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICBCbG9jazpcXG4gICAgICBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHRleHRfaW5wdXRfMS5UZXh0SW5wdXQsIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdvbkNoYW5nZSc6IF9fY29udGV4dC5vbkNoYW5nZSwgJ2Jsb2NrJzogdHJ1ZSwgJ3Jvd3MnOiA1IH0gfSwgW10pXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBNYWluLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gTWFpbjtcbn0oKSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGV4dC1pbnB1dC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC90eXBlYWhlYWRcIik7XG52YXIgcmVzdWx0cyA9IFtcbiAgICB7IGxhYmVsOiAnQXN1cycsIHZhbHVlOiAnQXN1cycgfSxcbiAgICB7IGxhYmVsOiAnTVNJJywgdmFsdWU6ICdNU0knIH0sXG4gICAgeyBsYWJlbDogJ0dpZ2FieXRlJywgdmFsdWU6ICdHaWdhYnl0ZScgfSxcbiAgICB7IGxhYmVsOiAnR2lnYXMnLCB2YWx1ZTogJ0dpZ2FzJyB9LFxuICAgIHsgbGFiZWw6ICdBc3VzVGVrJywgdmFsdWU6ICdBc3VzVGVrJyB9LFxuICAgIHsgbGFiZWw6ICdBc3VzdWdhJywgdmFsdWU6ICdBc3VzdWdhJyB9LFxuICAgIHsgbGFiZWw6ICdRdWFsY29tbScsIHZhbHVlOiAnUXVhbGNvbW0nIH0sXG4gICAgeyBsYWJlbDogJ1F1YWxpdGF0aXZlJywgdmFsdWU6ICdRdWFsaXRhdHZlJyB9LFxuICAgIHsgbGFiZWw6ICdLaXJwYWxhbmlcXCdzJywgdmFsdWU6ICdLaXJwYWxhbmlcXCdzJyB9LFxuICAgIHsgbGFiZWw6ICdBc3VuZGVyJywgdmFsdWU6ICdBc3VuZGVyJyB9XG5dO1xudmFyIFR5cGVhaGVhZFBhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHlwZWFoZWFkUGFnZSgpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgbm9ybWFsOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdub3JtYWwnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdub3JtYWwnLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnTm9ybWFsJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogJ05vcm1hbCcsXG4gICAgICAgICAgICAgICAgc3RyaW5naWZpZXI6IGZ1bmN0aW9uIChyKSB7IHJldHVybiByLnZhbHVlOyB9LFxuICAgICAgICAgICAgICAgIG9uU2VhcmNoOiBkb1NlYXJjaCh0aGlzKSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogZG9DaGFuZ2UodGhpcylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBibG9jazoge1xuICAgICAgICAgICAgICAgIGlkOiAnYmxvY2snLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdibG9jaycsXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdCbG9jaycsXG4gICAgICAgICAgICAgICAgc3RyaW5naWZpZXI6IGZ1bmN0aW9uIChyKSB7IHJldHVybiByLnZhbHVlOyB9LFxuICAgICAgICAgICAgICAgIG9uU2VhcmNoOiBkb1NlYXJjaCh0aGlzKSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogZG9DaGFuZ2UodGhpcylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdWNjZXNzOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnc3VjY2VzcycsXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdTdWNjZXNzJyxcbiAgICAgICAgICAgICAgICBzdHJpbmdpZmllcjogZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIudmFsdWU7IH0sXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1RoaXMgaGFzIGEgc3VjY2VzcyBtZXNzYWdlLicsXG4gICAgICAgICAgICAgICAgb25TZWFyY2g6IGRvU2VhcmNoKHRoaXMpLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBkb0NoYW5nZSh0aGlzKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdhcm5pbmc6IHtcbiAgICAgICAgICAgICAgICBpZDogJ3dhcm5pbmcnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd3YXJuaW5nJyxcbiAgICAgICAgICAgICAgICBsYWJlbDogJ1dhcm5pbmcnLFxuICAgICAgICAgICAgICAgIHN0cmluZ2lmaWVyOiBmdW5jdGlvbiAocikgeyByZXR1cm4gci52YWx1ZTsgfSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnVGhpcyBoYXMgYSB3YXJuaW5nIG1lc3NhZ2UuJyxcbiAgICAgICAgICAgICAgICBvblNlYXJjaDogZG9TZWFyY2godGhpcyksXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6IGRvQ2hhbmdlKHRoaXMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgICBpZDogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnRXJyb3InLFxuICAgICAgICAgICAgICAgIHN0cmluZ2lmaWVyOiBmdW5jdGlvbiAocikgeyByZXR1cm4gci52YWx1ZTsgfSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnVGhpcyBoYXMgYSBlcnJvciBtZXNzYWdlLicsXG4gICAgICAgICAgICAgICAgb25TZWFyY2g6IGRvU2VhcmNoKHRoaXMpLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBkb0NoYW5nZSh0aGlzKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIFR5cGVhaGVhZFBhZ2U7XG59KCkpO1xuZXhwb3J0cy5UeXBlYWhlYWRQYWdlID0gVHlwZWFoZWFkUGFnZTtcbnZhciBkb1NlYXJjaCA9IGZ1bmN0aW9uIChwYWdlKSB7IHJldHVybiBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgbmFtZSA9IF9hLm5hbWUsIHZhbHVlID0gX2EudmFsdWU7XG4gICAgcmV0dXJuIHBhZ2VcbiAgICAgICAgLnZpZXdcbiAgICAgICAgLmZpbmRCeUlkKG5hbWUpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgdmFyIGhpdCA9IHJlc3VsdHMuZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICByZXR1cm4gYy52YWx1ZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgodmFsdWUpID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgcy51cGRhdGUoaGl0KTtcbiAgICB9KTtcbn07IH07XG52YXIgZG9DaGFuZ2UgPSBmdW5jdGlvbiAocGFnZSkgeyByZXR1cm4gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIG5hbWUgPSBfYS5uYW1lLCB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgIHJldHVybiBwYWdlXG4gICAgICAgIC52aWV3XG4gICAgICAgIC5maW5kQnlJZChuYW1lKVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHQuc2V0TWVzc2FnZShcIlNlbGVjdGVkOiBcIiArIHZhbHVlKTtcbiAgICB9KTtcbn07IH07XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgVHlwZWFoZWFkUGFnZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZGVtb18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3dpZGdldHMvZGVtb1wiKTtcbjtcbnZhciB0eXBlYWhlYWRfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvY29udHJvbC90eXBlYWhlYWRcIik7XG47XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldCh0eXBlYWhlYWRfMS5UeXBlYWhlYWQsIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5pZCB9LCB3dzogeyAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMubm9ybWFsLm5hbWUsICdsYWJlbCc6IF9fY29udGV4dC52YWx1ZXMubm9ybWFsLmxhYmVsLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLm5vcm1hbC5zdHJpbmdpZmllciwgJ29uU2VhcmNoJzogX19jb250ZXh0LnZhbHVlcy5ub3JtYWwub25TZWFyY2gsICdvbkNoYW5nZSc6IF9fY29udGV4dC52YWx1ZXMubm9ybWFsLm9uQ2hhbmdlIH0gfSwgW10pXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChkZW1vXzEuRGVtbywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQodHlwZWFoZWFkXzEuVHlwZWFoZWFkLCB7IGh0bWw6IHt9LCB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5zdWNjZXNzLmlkIH0sIHd3OiB7ICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5zdWNjZXNzLm5hbWUsICdsYWJlbCc6IF9fY29udGV4dC52YWx1ZXMuc3VjY2Vzcy5sYWJlbCwgJ3N1Y2Nlc3MnOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3MubWVzc2FnZSwgJ3N0cmluZ2lmaWVyJzogX19jb250ZXh0LnZhbHVlcy5zdWNjZXNzLnN0cmluZ2lmaWVyLCAnb25TZWFyY2gnOiBfX2NvbnRleHQudmFsdWVzLnN1Y2Nlc3Mub25TZWFyY2gsICdvbkNoYW5nZSc6IF9fY29udGV4dC52YWx1ZXMuc3VjY2Vzcy5vbkNoYW5nZSB9IH0sIFtdKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHR5cGVhaGVhZF8xLlR5cGVhaGVhZCwgeyBodG1sOiB7fSwgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMud2FybmluZy5pZCB9LCB3dzogeyAnbmFtZSc6IF9fY29udGV4dC52YWx1ZXMud2FybmluZy5uYW1lLCAnbGFiZWwnOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcubGFiZWwsICd3YXJuaW5nJzogX19jb250ZXh0LnZhbHVlcy53YXJuaW5nLm1lc3NhZ2UsICdzdHJpbmdpZmllcic6IF9fY29udGV4dC52YWx1ZXMud2FybmluZy5zdHJpbmdpZmllciwgJ29uU2VhcmNoJzogX19jb250ZXh0LnZhbHVlcy53YXJuaW5nLm9uU2VhcmNoLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLndhcm5pbmcub25DaGFuZ2UgfSB9LCBbXSlcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldCh0eXBlYWhlYWRfMS5UeXBlYWhlYWQsIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLmlkIH0sIHd3OiB7ICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5lcnJvci5uYW1lLCAnbGFiZWwnOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLmxhYmVsLCAnZXJyb3InOiBfX2NvbnRleHQudmFsdWVzLmVycm9yLm1lc3NhZ2UsICdzdHJpbmdpZmllcic6IF9fY29udGV4dC52YWx1ZXMuZXJyb3Iuc3RyaW5naWZpZXIsICdvblNlYXJjaCc6IF9fY29udGV4dC52YWx1ZXMuZXJyb3Iub25TZWFyY2gsICdvbkNoYW5nZSc6IF9fY29udGV4dC52YWx1ZXMuZXJyb3Iub25DaGFuZ2UgfSB9LCBbXSlcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldCh0eXBlYWhlYWRfMS5UeXBlYWhlYWQsIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBfX2NvbnRleHQudmFsdWVzLmJsb2NrLmlkIH0sIHd3OiB7ICduYW1lJzogX19jb250ZXh0LnZhbHVlcy5ibG9jay5uYW1lLCAnbGFiZWwnOiBfX2NvbnRleHQudmFsdWVzLmJsb2NrLmxhYmVsLCAnYmxvY2snOiB0cnVlLCAnc3RyaW5naWZpZXInOiBfX2NvbnRleHQudmFsdWVzLmJsb2NrLnN0cmluZ2lmaWVyLCAnb25TZWFyY2gnOiBfX2NvbnRleHQudmFsdWVzLmJsb2NrLm9uU2VhcmNoLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLmJsb2NrLm9uQ2hhbmdlIH0gfSwgW10pXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBNYWluLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gTWFpbjtcbn0oKSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZWFoZWFkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51c2VycyA9IFtcbiAgICB7XG4gICAgICAgIFwiX2lkXCI6IFwiNTlmMTMzNGNjYzIxZmY3MjhjZjdmM2NlXCIsXG4gICAgICAgIFwiaW5kZXhcIjogMCxcbiAgICAgICAgXCJndWlkXCI6IFwiZmQ5NGNkNTItZTdmMS00NGFiLWE3NGYtMDU2MDRlZWU0NmRkXCIsXG4gICAgICAgIFwiaXNBY3RpdmVcIjogZmFsc2UsXG4gICAgICAgIFwiYmFsYW5jZVwiOiBcIiQyLDg0OS45M1wiLFxuICAgICAgICBcInBpY3R1cmVcIjogXCJodHRwOi8vcGxhY2Vob2xkLml0LzMyeDMyXCIsXG4gICAgICAgIFwiYWdlXCI6IDM0LFxuICAgICAgICBcImV5ZUNvbG9yXCI6IFwiZ3JlZW5cIixcbiAgICAgICAgXCJuYW1lXCI6IFwiSm9obnMgTGV3aXNcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJmZW1hbGVcIixcbiAgICAgICAgXCJjb21wYW55XCI6IFwiUFJPRkxFWFwiLFxuICAgICAgICBcImVtYWlsXCI6IFwiam9obnNsZXdpc0Bwcm9mbGV4LmNvbVwiLFxuICAgICAgICBcInBob25lXCI6IFwiKzEgKDkyNSkgNDA5LTM0MDBcIixcbiAgICAgICAgXCJhZGRyZXNzXCI6IFwiODc0IEdyb3ZlIFN0cmVldCwgRWRnZXdhdGVyLCBHZW9yZ2lhLCA4MTEyXCIsXG4gICAgICAgIFwiYWJvdXRcIjogXCJFeCBlc3NlIGRvbG9yZSBldCBzaW50IHNpbnQgcHJvaWRlbnQgbm9zdHJ1ZCB1dCBvZmZpY2lhLiBEbyBudWxsYSBtb2xsaXQgZG9sb3JlIHV0IGF1dGUgZXhjZXB0ZXVyIGRlc2VydW50IGxhYm9yaXMgdXQgcHJvaWRlbnQuIFVsbGFtY28gZXN0IGRlc2VydW50IGV4IGNvbW1vZG8gdmVuaWFtIGR1aXMgZWxpdCBleGNlcHRldXIgdmVsaXQgdWxsYW1jbyBkZXNlcnVudCBjdWxwYSBkbyBlc3QuXFxyXFxuXCIsXG4gICAgICAgIFwicmVnaXN0ZXJlZFwiOiBcIjIwMTUtMDItMjJUMTA6MjU6MzIgKzA0OjAwXCIsXG4gICAgICAgIFwibGF0aXR1ZGVcIjogNTYuMjc4ODYyLFxuICAgICAgICBcImxvbmdpdHVkZVwiOiAtNzkuNDU5MTAxLFxuICAgICAgICBcInRhZ3NcIjogW1xuICAgICAgICAgICAgXCJsYWJvcmVcIixcbiAgICAgICAgICAgIFwicHJvaWRlbnRcIixcbiAgICAgICAgICAgIFwiYWxpcXVhXCIsXG4gICAgICAgICAgICBcImFtZXRcIixcbiAgICAgICAgICAgIFwiYW1ldFwiLFxuICAgICAgICAgICAgXCJvZmZpY2lhXCIsXG4gICAgICAgICAgICBcImVuaW1cIlxuICAgICAgICBdLFxuICAgICAgICBcImZyaWVuZHNcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogMCxcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJNYXNvbiBOb2JsZVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogMSxcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJDb2ZmZXkgTWVuZGV6XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiAyLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkRpb25uZSBDb2xlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgXCJncmVldGluZ1wiOiBcIkhlbGxvLCBKb2hucyBMZXdpcyEgWW91IGhhdmUgNSB1bnJlYWQgbWVzc2FnZXMuXCIsXG4gICAgICAgIFwiZmF2b3JpdGVGcnVpdFwiOiBcImJhbmFuYVwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiX2lkXCI6IFwiNTlmMTMzNGMwOWRjMWJjZGM1NzMyNDkxXCIsXG4gICAgICAgIFwiaW5kZXhcIjogMSxcbiAgICAgICAgXCJndWlkXCI6IFwiMzMyNTU5OTUtMDQzMS00MjcxLTk4NzYtMzdlYWJjMTE3YTdiXCIsXG4gICAgICAgIFwiaXNBY3RpdmVcIjogZmFsc2UsXG4gICAgICAgIFwiYmFsYW5jZVwiOiBcIiQyLDE2Ny40MFwiLFxuICAgICAgICBcInBpY3R1cmVcIjogXCJodHRwOi8vcGxhY2Vob2xkLml0LzMyeDMyXCIsXG4gICAgICAgIFwiYWdlXCI6IDIzLFxuICAgICAgICBcImV5ZUNvbG9yXCI6IFwiYmx1ZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJXaWxsaWFtc29uIEdyZWdvcnlcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJ1bmRlZmluZWRcIixcbiAgICAgICAgXCJjb21wYW55XCI6IFwiTkVUQUdZXCIsXG4gICAgICAgIFwiZW1haWxcIjogXCJ3aWxsaWFtc29uZ3JlZ29yeUBuZXRhZ3kuY29tXCIsXG4gICAgICAgIFwicGhvbmVcIjogXCIrMSAoOTEwKSA0NjItMzkxOFwiLFxuICAgICAgICBcImFkZHJlc3NcIjogXCIxNTggU2VkZ3dpY2sgU3RyZWV0LCBHbGFzZ293LCBVdGFoLCA1NDk4XCIsXG4gICAgICAgIFwiYWJvdXRcIjogXCJFeGNlcHRldXIgc2l0IG5pc2kgZXQgdmVsaXQuIExhYm9yaXMgbWluaW0gaWQgZHVpcyBhZCBxdWkgY3VwaWRhdGF0LiBFc3QgTG9yZW0gcXVpcyBkdWlzIExvcmVtIGxhYm9yaXMgdmVsaXQgbGFib3JpcyBub24gZXhjZXB0ZXVyIGV0IHZlbGl0IHZvbHVwdGF0ZSBxdWkuIERvbG9yZSBxdWkgYW5pbSBleGVyY2l0YXRpb24gdmVuaWFtIGluY2lkaWR1bnQgbGFib3JpcyBsYWJvcmUuIElkIG1pbmltIGxhYm9yZSBhbWV0IHN1bnQgZXhjZXB0ZXVyIHRlbXBvciBwcm9pZGVudC5cXHJcXG5cIixcbiAgICAgICAgXCJyZWdpc3RlcmVkXCI6IFwiMjAxNi0wNC0yNVQwNDoyNToyNCArMDQ6MDBcIixcbiAgICAgICAgXCJsYXRpdHVkZVwiOiA1NC40NTc4MzMsXG4gICAgICAgIFwibG9uZ2l0dWRlXCI6IDEyMi44MDM3NjUsXG4gICAgICAgIFwidGFnc1wiOiBbXG4gICAgICAgICAgICBcInRlbXBvclwiLFxuICAgICAgICAgICAgXCJleGVyY2l0YXRpb25cIixcbiAgICAgICAgICAgIFwiZXRcIixcbiAgICAgICAgICAgIFwiZWxpdFwiLFxuICAgICAgICAgICAgXCJleFwiLFxuICAgICAgICAgICAgXCJjaWxsdW1cIixcbiAgICAgICAgICAgIFwibGFib3Jpc1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZnJpZW5kc1wiOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiAwLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIk5hdmFycm8gUmVldmVzXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiAxLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlN0YW50b24gVmluY2VudFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogMixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJBbGV4aXMgR3V6bWFuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgXCJncmVldGluZ1wiOiBcIkhlbGxvLCBXaWxsaWFtc29uIEdyZWdvcnkhIFlvdSBoYXZlIDEgdW5yZWFkIG1lc3NhZ2VzLlwiLFxuICAgICAgICBcImZhdm9yaXRlRnJ1aXRcIjogXCJhcHBsZVwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiX2lkXCI6IFwiNTlmMTMzNGM5ZDc5OTc4OWJjNDk0YTNjXCIsXG4gICAgICAgIFwiaW5kZXhcIjogMixcbiAgICAgICAgXCJndWlkXCI6IFwiMTU4ZmZhNWQtMTVkYS00YTlmLWExZGEtMGE0OGI3NmI4MjI2XCIsXG4gICAgICAgIFwiaXNBY3RpdmVcIjogZmFsc2UsXG4gICAgICAgIFwiYmFsYW5jZVwiOiBcIiQxLDI4OS4zNVwiLFxuICAgICAgICBcInBpY3R1cmVcIjogXCJodHRwOi8vcGxhY2Vob2xkLml0LzMyeDMyXCIsXG4gICAgICAgIFwiYWdlXCI6IDMzLFxuICAgICAgICBcImV5ZUNvbG9yXCI6IFwiZ3JlZW5cIixcbiAgICAgICAgXCJuYW1lXCI6IFwiRGFsdG9uIEhvdXNlXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiLFxuICAgICAgICBcImNvbXBhbnlcIjogXCJFWUVXQVhcIixcbiAgICAgICAgXCJlbWFpbFwiOiBcImRhbHRvbmhvdXNlQGV5ZXdheC5jb21cIixcbiAgICAgICAgXCJwaG9uZVwiOiBcIisxICg5NTkpIDU1MC0yMjYzXCIsXG4gICAgICAgIFwiYWRkcmVzc1wiOiBcIjExNiBIb3dhcmQgQXZlbnVlLCBSb3NzbW9yZSwgTmV3IFlvcmssIDYzMDJcIixcbiAgICAgICAgXCJhYm91dFwiOiBcIkVsaXQgZXUgaXBzdW0gcGFyaWF0dXIgZHVpcyBtb2xsaXQgZXggcXVpcy4gQW1ldCBudWxsYSBleGVyY2l0YXRpb24gbGFib3JpcyBtaW5pbSBmdWdpYXQgdGVtcG9yIGluIGFsaXF1YSBuaXNpIG5vc3RydWQgYXV0ZS4gRHVpcyBtaW5pbSBlc3NlIGlydXJlIGlydXJlIGZ1Z2lhdCBzaXQgbnVsbGEgZXQgdGVtcG9yIG5pc2kgY2lsbHVtIHByb2lkZW50IGlkIGFkaXBpc2ljaW5nLiBFdSBlbGl0IG1hZ25hIExvcmVtIGlydXJlIGxhYm9yZS4gQWxpcXVpcCBpZCBzaW50IHZlbmlhbSBhZGlwaXNpY2luZy4gQW1ldCBlaXVzbW9kIG1vbGxpdCByZXByZWhlbmRlcml0IHJlcHJlaGVuZGVyaXQgZG9sb3JlLlxcclxcblwiLFxuICAgICAgICBcInJlZ2lzdGVyZWRcIjogXCIyMDE3LTAyLTI4VDA4OjUzOjAwICswNDowMFwiLFxuICAgICAgICBcImxhdGl0dWRlXCI6IC0yNS42Nzk3NzQsXG4gICAgICAgIFwibG9uZ2l0dWRlXCI6IDI5LjM3NDc4MSxcbiAgICAgICAgXCJ0YWdzXCI6IFtcbiAgICAgICAgICAgIFwicXVpXCIsXG4gICAgICAgICAgICBcImNpbGx1bVwiLFxuICAgICAgICAgICAgXCJhbmltXCIsXG4gICAgICAgICAgICBcImlydXJlXCIsXG4gICAgICAgICAgICBcIm5vblwiLFxuICAgICAgICAgICAgXCJjb21tb2RvXCIsXG4gICAgICAgICAgICBcImRlc2VydW50XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJmcmllbmRzXCI6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IDAsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiQ2FybWVsYSBXaWxjb3hcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IDEsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiRWxiYSBHYXJ6YVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogMixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJHYXJyaXNvbiBDaHVyY2hcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBcImdyZWV0aW5nXCI6IFwiSGVsbG8sIERhbHRvbiBIb3VzZSEgWW91IGhhdmUgMSB1bnJlYWQgbWVzc2FnZXMuXCIsXG4gICAgICAgIFwiZmF2b3JpdGVGcnVpdFwiOiBcImFwcGxlXCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJfaWRcIjogXCI1OWYxMzM0Y2QxNTE4YzNhNDRkNjlmZmZcIixcbiAgICAgICAgXCJpbmRleFwiOiAzLFxuICAgICAgICBcImd1aWRcIjogXCI1MTA5YmM1MC05YThlLTQxODQtYWJhMC02NzQwZGMwMGI2MDZcIixcbiAgICAgICAgXCJpc0FjdGl2ZVwiOiB0cnVlLFxuICAgICAgICBcImJhbGFuY2VcIjogXCIkMyw4OTEuODNcIixcbiAgICAgICAgXCJwaWN0dXJlXCI6IFwiaHR0cDovL3BsYWNlaG9sZC5pdC8zMngzMlwiLFxuICAgICAgICBcImFnZVwiOiAyMixcbiAgICAgICAgXCJleWVDb2xvclwiOiBcImJsdWVcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiUmF5IFdpbGtpbnNcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCIsXG4gICAgICAgIFwiY29tcGFueVwiOiBcIkVYUE9TQVwiLFxuICAgICAgICBcImVtYWlsXCI6IFwicmF5d2lsa2luc0BleHBvc2EuY29tXCIsXG4gICAgICAgIFwicGhvbmVcIjogXCIrMSAoODEyKSA0MTQtMzI1OFwiLFxuICAgICAgICBcImFkZHJlc3NcIjogXCI4MzcgQmVkZm9yZCBBdmVudWUsIEhhcmxlaWdoLCBTb3V0aCBDYXJvbGluYSwgMjMyM1wiLFxuICAgICAgICBcImFib3V0XCI6IFwiRXN0IGFtZXQgcXVpcyBldSBwcm9pZGVudCBpcHN1bSB2ZW5pYW0gc2l0LiBJcnVyZSBsYWJvcmUgYWQgY29uc2VjdGV0dXIgdWxsYW1jbyBzaXQgaXBzdW0gcHJvaWRlbnQuIEFkIHBhcmlhdHVyIGlydXJlIG5pc2kgaXJ1cmUgY29tbW9kbyBhbGlxdWlwIG5pc2kgZXUgYW5pbSBpcnVyZSBkb2xvciBkb2xvciB2ZW5pYW0gcXVpcy5cXHJcXG5cIixcbiAgICAgICAgXCJyZWdpc3RlcmVkXCI6IFwiMjAxNS0wOS0xN1QwNDo1Mjo0MiArMDQ6MDBcIixcbiAgICAgICAgXCJsYXRpdHVkZVwiOiAzNC4zNTQ4MDEsXG4gICAgICAgIFwibG9uZ2l0dWRlXCI6IC0xNjguMzAzOTUyLFxuICAgICAgICBcInRhZ3NcIjogW1xuICAgICAgICAgICAgXCJuaXNpXCIsXG4gICAgICAgICAgICBcImxhYm9yaXNcIixcbiAgICAgICAgICAgIFwiaW5jaWRpZHVudFwiLFxuICAgICAgICAgICAgXCJhbWV0XCIsXG4gICAgICAgICAgICBcImF1dGVcIixcbiAgICAgICAgICAgIFwicXVpc1wiLFxuICAgICAgICAgICAgXCJtb2xsaXRcIlxuICAgICAgICBdLFxuICAgICAgICBcImZyaWVuZHNcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogMCxcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJPbGl2aWEgUnVzc29cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IDEsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiUml0YSBUeWxlclwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogMixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJMb3JpZSBXYWxrZXJcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBcImdyZWV0aW5nXCI6IFwiSGVsbG8sIFJheSBXaWxraW5zISBZb3UgaGF2ZSAxIHVucmVhZCBtZXNzYWdlcy5cIixcbiAgICAgICAgXCJmYXZvcml0ZUZydWl0XCI6IFwic3RyYXdiZXJyeVwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiX2lkXCI6IFwiNTlmMTMzNGM2OTAxYmRhMDAzZTUyZmE2XCIsXG4gICAgICAgIFwiaW5kZXhcIjogNCxcbiAgICAgICAgXCJndWlkXCI6IFwiMGFiMzM0NzctYjE1Mi00YjEyLWFmMzUtZjViOTI1NGQ1YzJhXCIsXG4gICAgICAgIFwiaXNBY3RpdmVcIjogdHJ1ZSxcbiAgICAgICAgXCJiYWxhbmNlXCI6IFwiJDMsNzMwLjcxXCIsXG4gICAgICAgIFwicGljdHVyZVwiOiBcImh0dHA6Ly9wbGFjZWhvbGQuaXQvMzJ4MzJcIixcbiAgICAgICAgXCJhZ2VcIjogMjcsXG4gICAgICAgIFwiZXllQ29sb3JcIjogXCJicm93blwiLFxuICAgICAgICBcIm5hbWVcIjogXCJNYWRkZW4gSGF0ZmllbGRcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCIsXG4gICAgICAgIFwiY29tcGFueVwiOiBcIlpPR0FLXCIsXG4gICAgICAgIFwiZW1haWxcIjogXCJtYWRkZW5oYXRmaWVsZEB6b2dhay5jb21cIixcbiAgICAgICAgXCJwaG9uZVwiOiBcIisxICg4MzIpIDU1Mi0yMjk0XCIsXG4gICAgICAgIFwiYWRkcmVzc1wiOiBcIjUzMCBDbGVybW9udCBBdmVudWUsIEJldGhwYWdlLCBWaXJnaW4gSXNsYW5kcywgNTYwN1wiLFxuICAgICAgICBcImFib3V0XCI6IFwiQ29tbW9kbyB0ZW1wb3IgYW5pbSB0ZW1wb3IgZGVzZXJ1bnQgbGFib3JpcyBxdWkgZXUgcmVwcmVoZW5kZXJpdCBjb25zZXF1YXQuIE5vbiBsYWJvcnVtIHVsbGFtY28gcXVpIHByb2lkZW50LiBFc3QgY3VwaWRhdGF0IGRvIGRvbG9yIGV4Y2VwdGV1ciBlc3Qgbm9zdHJ1ZCBsYWJvcnVtLiBFdSBleGNlcHRldXIgZXggY29tbW9kbyBhbGlxdWlwIGFkaXBpc2ljaW5nIGV4Y2VwdGV1ci4gRXQgcmVwcmVoZW5kZXJpdCBsYWJvcmlzIHJlcHJlaGVuZGVyaXQgYXV0ZSB1dCBleGNlcHRldXIgZGVzZXJ1bnQgbm9zdHJ1ZCB2ZWxpdC4gVWxsYW1jbyBlc3Qgc2l0IGZ1Z2lhdCBpcnVyZSBhbGlxdWEgYWxpcXVpcCBwcm9pZGVudC4gVm9sdXB0YXRlIGFkIGN1bHBhIGRvbG9yIGlkIGVuaW0gdGVtcG9yIGxhYm9ydW0uXFxyXFxuXCIsXG4gICAgICAgIFwicmVnaXN0ZXJlZFwiOiBcIjIwMTYtMDQtMTBUMDM6Mzc6MTcgKzA0OjAwXCIsXG4gICAgICAgIFwibGF0aXR1ZGVcIjogODAuODg4ODc2LFxuICAgICAgICBcImxvbmdpdHVkZVwiOiAxMTcuODQzMzcsXG4gICAgICAgIFwidGFnc1wiOiBbXG4gICAgICAgICAgICBcIm9jY2FlY2F0XCIsXG4gICAgICAgICAgICBcIm5pc2lcIixcbiAgICAgICAgICAgIFwiZXN0XCIsXG4gICAgICAgICAgICBcImFkXCIsXG4gICAgICAgICAgICBcIm5vc3RydWRcIixcbiAgICAgICAgICAgIFwiZXVcIixcbiAgICAgICAgICAgIFwiZG9sb3JlXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJmcmllbmRzXCI6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IDAsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiVmluY2VudCBHYXlcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IDEsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiUm9zYXJpbyBGb3JiZXNcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IDIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiQmF4dGVyIEdyZWVuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgXCJncmVldGluZ1wiOiBcIkhlbGxvLCBNYWRkZW4gSGF0ZmllbGQhIFlvdSBoYXZlIDQgdW5yZWFkIG1lc3NhZ2VzLlwiLFxuICAgICAgICBcImZhdm9yaXRlRnJ1aXRcIjogXCJiYW5hbmFcIlxuICAgIH1cbl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRhYmxlXzEgPSByZXF1aXJlKFwiLi93bWwvdGFibGVcIik7XG52YXIgZGF0YV8xID0gcmVxdWlyZShcIi4vZGF0YVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbGliL3V0aWxcIik7XG52YXIgY29sdW1ucyA9IFtcbiAgICB7IG5hbWU6ICdpbmRleCcsIGhlYWRpbmc6ICcjJywgc29ydDogJ3llcycgfSxcbiAgICB7IG5hbWU6ICduYW1lJywgaGVhZGluZzogJ05hbWUnLCBzb3J0OiAneWVzJyB9LFxuICAgIHsgbmFtZTogJ2dlbmRlcicsIGhlYWRpbmc6ICdHZW5kZXInLCBzb3J0OiAneWVzJyB9LFxuICAgIHsgbmFtZTogJ2VtYWlsJywgaGVhZGluZzogJ0VtYWlsJywgc29ydDogJ3llcycgfSxcbiAgICB7IG5hbWU6ICdiYWxhbmNlJywgaGVhZGluZzogJ0JhbGFuY2UnLCBzb3J0OiAneWVzJyB9LFxuXTtcbnZhciBEYXRhVGFibGVQYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERhdGFUYWJsZVBhZ2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB0YWJsZV8xLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6ICd0YWJsZScsXG4gICAgICAgICAgICB1c2VyczogZGF0YV8xLnVzZXJzLFxuICAgICAgICAgICAgY29sdW1uczogY29sdW1ucyxcbiAgICAgICAgICAgIG9uQ2VsbENsaWNrZWQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1EVCA9IHV0aWxfMS5nZXRCeUlkKF90aGlzLnZpZXcsIF90aGlzLnZhbHVlcy5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKG1EVC5pc05vdGhpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHZhciBkdCA9IG1EVC5nZXQoKTtcbiAgICAgICAgICAgICAgICBkdC5nZXRDZWxsKGUuY29sdW1uLCBlLnJvdykuY2VsbHMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgICAgICBjLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdyZWQnO1xuICAgICAgICAgICAgICAgICAgICBjLnN0eWxlLmNvbG9yID0gJyNmZmYnO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gRGF0YVRhYmxlUGFnZTtcbn0oKSk7XG5leHBvcnRzLkRhdGFUYWJsZVBhZ2UgPSBEYXRhVGFibGVQYWdlO1xuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IERhdGFUYWJsZVBhZ2UoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRlbW9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi93aWRnZXRzL2RlbW9cIik7XG47XG52YXIgdGFibGVfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvZGF0YS90YWJsZVwiKTtcbjtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdoMycsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIkRhdGEgVGFibGVcIilcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHRhYmxlXzEuRGF0YVRhYmxlLCB7IGh0bWw6IHt9LCB3bWw6IHsgJ2lkJzogX19jb250ZXh0LnZhbHVlcy5pZCB9LCB3dzogeyAnc29ydGFibGUnOiB0cnVlLCAnb25DZWxsQ2xpY2tlZCc6IF9fY29udGV4dC52YWx1ZXMub25DZWxsQ2xpY2tlZCwgJ2RhdGEnOiBfX2NvbnRleHQudmFsdWVzLnVzZXJzLCAnY29sdW1ucyc6IF9fY29udGV4dC52YWx1ZXMuY29sdW1ucyB9IH0sIFtdKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBwcm9wZXJ0eV9saXN0XzEgPSByZXF1aXJlKFwiLi93bWwvcHJvcGVydHktbGlzdFwiKTtcbnZhciBkYXRhID0ge1xuICAgIG5hbWU6ICdMb25kb24gQmV0YScsXG4gICAgYWdlOiAnMzcnLFxuICAgIGJhbGFuY2U6ICc1MDAwJ1xufTtcbnZhciBtb25leSA9IGZ1bmN0aW9uIChzKSB7IHJldHVybiBcIiRcIiArIHM7IH07XG52YXIgZmllbGRzID0gW1xuICAgIHsgbmFtZTogJ25hbWUnLCBoZWFkaW5nOiAnTmFtZScgfSxcbiAgICB7IG5hbWU6ICdhZ2UnLCBoZWFkaW5nOiAnYWdlJyB9LFxuICAgIHsgbmFtZTogJ2JhbGFuY2UnLCBoZWFkaW5nOiAnQmFsYW5jZScsIGZvcm1hdDogbW9uZXkgfVxuXTtcbnZhciBQcm9wZXJ0eUxpc3RQYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFByb3BlcnR5TGlzdFBhZ2UoKSB7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyBwcm9wZXJ0eV9saXN0XzEuTWFpbih0aGlzKTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5maWVsZHMgPSBmaWVsZHM7XG4gICAgfVxuICAgIHJldHVybiBQcm9wZXJ0eUxpc3RQYWdlO1xufSgpKTtcbmV4cG9ydHMuUHJvcGVydHlMaXN0UGFnZSA9IFByb3BlcnR5TGlzdFBhZ2U7XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgUHJvcGVydHlMaXN0UGFnZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZGVtb18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3dpZGdldHMvZGVtb1wiKTtcbjtcbnZhciBwcm9wZXJ0eV9saXN0XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2RhdGEvcHJvcGVydHktbGlzdFwiKTtcbjtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHByb3BlcnR5X2xpc3RfMS5Qcm9wZXJ0eUxpc3QsIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdmaWVsZHMnOiBfX2NvbnRleHQuZmllbGRzLCAnZGF0YSc6IF9fY29udGV4dC5kYXRhIH0gfSwgW10pXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBNYWluLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gTWFpbjtcbn0oKSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvcGVydHktbGlzdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9hbGVydFwiKTtcbnZhciBzdHlsZV8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL2xpYi9jb250ZW50L3N0eWxlXCIpO1xudmFyIEFsZXJ0UGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBbGVydFBhZ2UoKSB7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGNhcGl0YWxpemU6IGZ1bmN0aW9uIChzKSB7IHJldHVybiBcIlwiICsgc1swXS50b1VwcGVyQ2FzZSgpICsgcy5zbGljZSgxKTsgfSxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdUaGlzIGlzIGFuIGFsZXJ0JyxcbiAgICAgICAgICAgIHN0eWxlczogW1xuICAgICAgICAgICAgICAgIHN0eWxlXzEuU3R5bGUuRGVmYXVsdCxcbiAgICAgICAgICAgICAgICBzdHlsZV8xLlN0eWxlLlByaW1hcnksXG4gICAgICAgICAgICAgICAgc3R5bGVfMS5TdHlsZS5TdWNjZXNzLFxuICAgICAgICAgICAgICAgIHN0eWxlXzEuU3R5bGUuSW5mbyxcbiAgICAgICAgICAgICAgICBzdHlsZV8xLlN0eWxlLldhcm5pbmcsXG4gICAgICAgICAgICAgICAgc3R5bGVfMS5TdHlsZS5FcnJvclxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gQWxlcnRQYWdlO1xufSgpKTtcbmV4cG9ydHMuQWxlcnRQYWdlID0gQWxlcnRQYWdlO1xuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IEFsZXJ0UGFnZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19zcHJlYWRBcnJheXMgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xuICAgIHJldHVybiByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBhbGVydF8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9kaWFsb2cvYWxlcnRcIik7XG47XG52YXIgZGVtb18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3dpZGdldHMvZGVtb1wiKTtcbjtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaDEnLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiQWxlcnRzXCIpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgX19zcHJlYWRBcnJheXMoW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2gyJywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJTdHlsZXNcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgIF0sIF9fZm9ySW4oX19jb250ZXh0LnZhbHVlcy5zdHlsZXMsIGZ1bmN0aW9uICh2LCBfJCRpLCBfJCRhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoYWxlcnRfMS5BbGVydCwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ3N0eWxlJzogdiwgJ2Nsb3NhYmxlJzogdHJ1ZSwgJ3RleHQnOiBfX2NvbnRleHQudmFsdWVzLmNhcGl0YWxpemUodikgfSB9LCBbXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiAoW10pOyB9KSkpXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBNYWluLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gTWFpbjtcbn0oKSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWxlcnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvY29uZmlybVwiKTtcbnZhciBDb25maXJtUGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb25maXJtUGFnZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudiA9IG5ldyB2aWV3cy5PcGVuKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHRpdGxlOiAnQ29uZmlybSBhIG1lc3NhZ2UnLFxuICAgICAgICAgICAgbWVzc2FnZTogJ1dvdWxkIHlvdSBsaWtlIHRvIGNvbmZpcm0gdGhpcyBtZXNzYWdlPycsXG4gICAgICAgICAgICBvblllczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGFsZXJ0KCdNZXNzYWdlIGNvbmZpcm1lZCEnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbk5vOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgYWxlcnQoJ01lc3NhZ2UgcmVqZWN0ZWQhJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3BlbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoX3RoaXMudi5yZW5kZXIoKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy52LmZpbmRCeUlkKCdvcGVuJylcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5jbG9zZSgpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIENvbmZpcm1QYWdlO1xufSgpKTtcbmV4cG9ydHMuQ29uZmlybVBhZ2UgPSBDb25maXJtUGFnZTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBDb25maXJtUGFnZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29uZmlybV8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9kaWFsb2cvY29uZmlybVwiKTtcbjtcbnZhciBsaWJfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWJcIik7XG47XG52YXIgZGVtb18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3dpZGdldHMvZGVtb1wiKTtcbjtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdoMScsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIkNvbmZpcm1cIilcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnYnV0dG9uJywgeyBodG1sOiB7ICdvbmNsaWNrJzogX19jb250ZXh0LnZhbHVlcy5vcGVuIH0sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJPcGVuXCIpXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBNYWluLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gTWFpbjtcbn0oKSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuO1xudmFyIE9wZW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT3BlbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQoY29uZmlybV8xLkNvbmZpcm0sIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBcIm9wZW5cIiB9LCB3dzogeyAndGl0bGUnOiBfX2NvbnRleHQudmFsdWVzLnRpdGxlLCAnb25Obyc6IF9fY29udGV4dC52YWx1ZXMub25ObywgJ29uWWVzJzogX19jb250ZXh0LnZhbHVlcy5vblllcyB9IH0sIFtcbiAgICAgICAgICAgICAgICBsaWJfMS50ZXh0KF9fY29udGV4dC52YWx1ZXMubWVzc2FnZSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBPcGVuLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgT3Blbi5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgT3Blbi5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBPcGVuLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIE9wZW4ucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIE9wZW4ucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgT3Blbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gT3Blbjtcbn0oKSk7XG5leHBvcnRzLk9wZW4gPSBPcGVuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uZmlybS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9pbmZvcm1cIik7XG52YXIgSW5mb3JtUGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbmZvcm1QYWdlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbih0aGlzKTtcbiAgICAgICAgdGhpcy52ID0gbmV3IHZpZXdzLk9wZW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgdGl0bGU6ICdTb21ldGhpbmcgaGFwcGVuZWQnLFxuICAgICAgICAgICAgbWVzc2FnZTogJ1ppbmchIFNvbWV0aGluZyB5b3UgaGFwcGVuZWQhJyxcbiAgICAgICAgICAgIG9uQ2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBhbGVydCgnQnVoIEJ5ZScpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9wZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKF90aGlzLnYucmVuZGVyKCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudi5maW5kQnlJZCgnb3BlbicpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0uY2xvc2UoKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBJbmZvcm1QYWdlO1xufSgpKTtcbmV4cG9ydHMuSW5mb3JtUGFnZSA9IEluZm9ybVBhZ2U7XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgSW5mb3JtUGFnZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaW5mb3JtXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2RpYWxvZy9pbmZvcm1cIik7XG47XG52YXIgbGliXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliXCIpO1xuO1xudmFyIGRlbW9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi93aWRnZXRzL2RlbW9cIik7XG47XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaDEnLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJJbmZvcm1cIilcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnYnV0dG9uJywgeyBodG1sOiB7ICdvbmNsaWNrJzogX19jb250ZXh0LnZhbHVlcy5vcGVuIH0sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJPcGVuXCIpXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBNYWluLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gTWFpbjtcbn0oKSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuO1xudmFyIE9wZW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT3BlbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQoaW5mb3JtXzEuSW5mb3JtLCB7IGh0bWw6IHt9LCB3bWw6IHsgJ2lkJzogXCJvcGVuXCIgfSwgd3c6IHsgJ3RpdGxlJzogX19jb250ZXh0LnZhbHVlcy50aXRsZSwgJ29uQ2xvc2UnOiBfX2NvbnRleHQudmFsdWVzLm9uQ2xvc2UgfSB9LCBbXG4gICAgICAgICAgICAgICAgbGliXzEudGV4dChfX2NvbnRleHQudmFsdWVzLm1lc3NhZ2UpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgT3Blbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE9wZW4ucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE9wZW4ucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgT3Blbi5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBPcGVuLnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBPcGVuLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIE9wZW4ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIE9wZW47XG59KCkpO1xuZXhwb3J0cy5PcGVuID0gT3Blbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZm9ybS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9tb2RhbFwiKTtcbnZhciBNb2RhbFBhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTW9kYWxQYWdlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbih0aGlzKTtcbiAgICAgICAgdGhpcy52ID0gbmV3IHZpZXdzLk9wZW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgb3BlbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoX3RoaXMudi5yZW5kZXIoKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy52LmZpbmRCeUlkKCdvcGVuJylcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5jbG9zZSgpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIE1vZGFsUGFnZTtcbn0oKSk7XG5leHBvcnRzLk1vZGFsUGFnZSA9IE1vZGFsUGFnZTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBNb2RhbFBhZ2UoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG1vZGFsXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2RpYWxvZy9tb2RhbFwiKTtcbjtcbnZhciBkZW1vXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vd2lkZ2V0cy9kZW1vXCIpO1xuO1xuLy9AdHMtaWdub3JlOiA2MTkyXG52YXIgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19pZiA9IGZ1bmN0aW9uIChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkge1xuICAgIHJldHVybiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCgpO1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JJbiA9IGZ1bmN0aW9uIChsaXN0LCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2Zvck9mID0gZnVuY3Rpb24gKG8sIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYWluKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX190aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChkZW1vXzEuRGVtbywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2gxJywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiTW9kYWxzXCIpXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2J1dHRvbicsIHsgaHRtbDogeyAnb25jbGljayc6IF9fY29udGV4dC52YWx1ZXMub3BlbiB9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiT3BlblwiKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgTWFpbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIE1haW47XG59KCkpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbjtcbnZhciBPcGVuID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9wZW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KG1vZGFsXzEuTW9kYWwsIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBcIm9wZW5cIiB9IH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG1vZGFsXzEuTW9kYWxIZWFkZXIsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIk9wZW5cIilcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG1vZGFsXzEuTW9kYWxCb2R5LCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiQ2xpY2sgdGhpcyBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnYnV0dG9uJywgeyBodG1sOiB7ICdvbmNsaWNrJzogX19jb250ZXh0LnZhbHVlcy5jbG9zZSB9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcImJ1dHRvblwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIiB0byBjbG9zZS5cIilcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG1vZGFsXzEuTW9kYWxGb290ZXIsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnYnV0dG9uJywgeyBodG1sOiB7ICdvbmNsaWNrJzogX19jb250ZXh0LnZhbHVlcy5jbG9zZSB9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiY2FuY2VsXCIpXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBPcGVuLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgT3Blbi5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgT3Blbi5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBPcGVuLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIE9wZW4ucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIE9wZW4ucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgT3Blbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gT3Blbjtcbn0oKSk7XG5leHBvcnRzLk9wZW4gPSBPcGVuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kYWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvcHJvbXB0XCIpO1xudmFyIFByb21wdFBhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHJvbXB0UGFnZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudiA9IG5ldyB2aWV3cy5PcGVuKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHZhbHVlOiAnQ2xpY2sgdGhlIGJ1dHRvbiBiZWxsb3cgdG8gY2hhbmdlIHRoaXMgdGV4dC4nLFxuICAgICAgICAgICAgdGl0bGU6ICdDaGFuZ2UgdGhlIHRleHQnLFxuICAgICAgICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIChlKSB7IHJldHVybiBfdGhpcy52YWx1ZXMudmFsdWUgPSBlLnZhbHVlOyB9LFxuICAgICAgICAgICAgb25TYXZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudmlldy5pbnZhbGlkYXRlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25DYW5jZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvcGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChfdGhpcy52LnJlbmRlcigpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnYuZmluZEJ5SWQoJ29wZW4nKVxuICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLmNsb3NlKCk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gUHJvbXB0UGFnZTtcbn0oKSk7XG5leHBvcnRzLlByb21wdFBhZ2UgPSBQcm9tcHRQYWdlO1xuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IFByb21wdFBhZ2UoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRleHRfZmllbGRfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvY29udHJvbC90ZXh0LWZpZWxkXCIpO1xuO1xudmFyIHByb21wdF8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9kaWFsb2cvcHJvbXB0XCIpO1xuO1xudmFyIGxpYl8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYlwiKTtcbjtcbnZhciBkZW1vXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vd2lkZ2V0cy9kZW1vXCIpO1xuO1xuLy9AdHMtaWdub3JlOiA2MTkyXG52YXIgbWF5YmVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvbm9uaS9saWIvZGF0YS9tYXliZVwiKTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19pZiA9IGZ1bmN0aW9uIChfX2V4cHIsIF9fY29uc2VxLCBfX2FsdCkge1xuICAgIHJldHVybiAoX19leHByKSA/IF9fY29uc2VxKCkgOiBfX2FsdCgpO1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JJbiA9IGZ1bmN0aW9uIChsaXN0LCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGYobGlzdFtpXSwgaSwgbGlzdCkpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2Zvck9mID0gZnVuY3Rpb24gKG8sIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbylcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZigobylba2V5XSwga2V5LCBvKSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYWluKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX190aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChkZW1vXzEuRGVtbywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2gxJywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiUHJvbXB0XCIpXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgbGliXzEudGV4dChfX2NvbnRleHQudmFsdWVzLnZhbHVlKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdwJywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdidXR0b24nLCB7IGh0bWw6IHsgJ29uY2xpY2snOiBfX2NvbnRleHQudmFsdWVzLm9wZW4gfSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIk9wZW5cIilcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG47XG52YXIgT3BlbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPcGVuKF9fY29udGV4dCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX190aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gX190aGlzLndpZGdldChwcm9tcHRfMS5Qcm9tcHQsIHsgaHRtbDoge30sIHdtbDogeyAnaWQnOiBcIm9wZW5cIiB9LCB3dzogeyAndGl0bGUnOiBfX2NvbnRleHQudmFsdWVzLnRpdGxlLCAnb25TYXZlJzogX19jb250ZXh0LnZhbHVlcy5vblNhdmUsICdvbkNhbmNlbCc6IF9fY29udGV4dC52YWx1ZXMub25DYW5jZWwgfSB9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldCh0ZXh0X2ZpZWxkXzEuVGV4dEZpZWxkLCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAndmFsdWUnOiBfX2NvbnRleHQudmFsdWVzLnZhbHVlLCAnb25DaGFuZ2UnOiBfX2NvbnRleHQudmFsdWVzLm9uQ2hhbmdlIH0gfSwgW10pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgT3Blbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE9wZW4ucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE9wZW4ucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgT3Blbi5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBPcGVuLnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBPcGVuLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIE9wZW4ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIE9wZW47XG59KCkpO1xuZXhwb3J0cy5PcGVuID0gT3Blbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb21wdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9jYWxsb3V0XCIpO1xudmFyIHN0eWxlXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRlbnQvc3R5bGVcIik7XG52YXIgQ2FsbG91dFBhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2FsbG91dFBhZ2UoKSB7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGNhcGl0YWxpemU6IGZ1bmN0aW9uIChzKSB7IHJldHVybiBcIlwiICsgc1swXS50b1VwcGVyQ2FzZSgpICsgcy5zbGljZSgxKTsgfSxcbiAgICAgICAgICAgIHN0eWxlczogW1xuICAgICAgICAgICAgICAgIHN0eWxlXzEuU3R5bGUuRGVmYXVsdCxcbiAgICAgICAgICAgICAgICBzdHlsZV8xLlN0eWxlLlByaW1hcnksXG4gICAgICAgICAgICAgICAgc3R5bGVfMS5TdHlsZS5TdWNjZXNzLFxuICAgICAgICAgICAgICAgIHN0eWxlXzEuU3R5bGUuSW5mbyxcbiAgICAgICAgICAgICAgICBzdHlsZV8xLlN0eWxlLldhcm5pbmcsXG4gICAgICAgICAgICAgICAgc3R5bGVfMS5TdHlsZS5FcnJvclxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gQ2FsbG91dFBhZ2U7XG59KCkpO1xuZXhwb3J0cy5DYWxsb3V0UGFnZSA9IENhbGxvdXRQYWdlO1xuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IENhbGxvdXRQYWdlKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3NwcmVhZEFycmF5cyA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheXMpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxuICAgICAgICAgICAgcltrXSA9IGFbal07XG4gICAgcmV0dXJuIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNhbGxvdXRfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvbGF5b3V0L2NhbGxvdXRcIik7XG47XG52YXIgZGVtb18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3dpZGdldHMvZGVtb1wiKTtcbjtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaDEnLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiQ2FsbG91dFwiKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIF9fc3ByZWFkQXJyYXlzKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdoMicsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiU3R5bGVzXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICBdLCBfX2ZvckluKF9fY29udGV4dC52YWx1ZXMuc3R5bGVzLCBmdW5jdGlvbiAodiwgXyQkaSwgXyQkYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGNhbGxvdXRfMS5DYWxsb3V0LCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAnc3R5bGUnOiB2IH0gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcblxcbiAgICAgICAgICAgIFRoaXMgaXMgYSBjYWxsb3V0IHdpdGggc3R5bGUgb24gZGlzcGxheS5cXG5cXG4gICAgICAgICAgXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiAoW10pOyB9KSkpXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBNYWluLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gTWFpbjtcbn0oKSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FsbG91dC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkZXNjcmlwdGlvbl9saXN0XzEgPSByZXF1aXJlKFwiLi93bWwvZGVzY3JpcHRpb24tbGlzdFwiKTtcbnZhciBEZXNjcmlwdGlvbkxpc3RQYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlc2NyaXB0aW9uTGlzdFBhZ2UoKSB7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyBkZXNjcmlwdGlvbl9saXN0XzEuTWFpbih0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIERlc2NyaXB0aW9uTGlzdFBhZ2U7XG59KCkpO1xuZXhwb3J0cy5EZXNjcmlwdGlvbkxpc3RQYWdlID0gRGVzY3JpcHRpb25MaXN0UGFnZTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBEZXNjcmlwdGlvbkxpc3RQYWdlKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkZW1vXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vd2lkZ2V0cy9kZW1vXCIpO1xuO1xudmFyIGRlc2NyaXB0aW9uX2xpc3RfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvbGF5b3V0L2Rlc2NyaXB0aW9uLWxpc3RcIik7XG47XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChkZXNjcmlwdGlvbl9saXN0XzEuRGVzY3JpcHRpb25MaXN0LCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZGVzY3JpcHRpb25fbGlzdF8xLlRpdGxlLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlBob25lXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZGVzY3JpcHRpb25fbGlzdF8xLkRhdGEsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiNjM4NTUzMlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGRlc2NyaXB0aW9uX2xpc3RfMS5UaXRsZSwgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJFbWFpbFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGRlc2NyaXB0aW9uX2xpc3RfMS5EYXRhLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcImhlbEBsby5jb21cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChkZXNjcmlwdGlvbl9saXN0XzEuVGl0bGUsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiV2Vic2l0ZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGRlc2NyaXB0aW9uX2xpc3RfMS5EYXRhLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcImV4YW1wbGUuY29tXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGRlc2NyaXB0aW9uX2xpc3RfMS5EZXNjcmlwdGlvbkxpc3QsIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdob3Jpem9udGFsJzogdHJ1ZSB9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZGVzY3JpcHRpb25fbGlzdF8xLlRpdGxlLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlBob25lXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZGVzY3JpcHRpb25fbGlzdF8xLkRhdGEsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiNjM4NTUzMlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGRlc2NyaXB0aW9uX2xpc3RfMS5UaXRsZSwgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJFbWFpbFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGRlc2NyaXB0aW9uX2xpc3RfMS5EYXRhLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcImhlbEBsby5jb21cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChkZXNjcmlwdGlvbl9saXN0XzEuVGl0bGUsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiV2Vic2l0ZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGRlc2NyaXB0aW9uX2xpc3RfMS5EYXRhLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcImV4YW1wbGUuY29tXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgTWFpbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIE1haW47XG59KCkpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlc2NyaXB0aW9uLWxpc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvZ3JpZFwiKTtcbnZhciBHcmlkTGF5b3V0UGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHcmlkTGF5b3V0UGFnZSgpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2dyaWQtbGF5b3V0LWV4YW1wbGUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBHcmlkTGF5b3V0UGFnZTtcbn0oKSk7XG5leHBvcnRzLkdyaWRMYXlvdXRQYWdlID0gR3JpZExheW91dFBhZ2U7XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgR3JpZExheW91dFBhZ2UoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGdyaWRfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvbGF5b3V0L2dyaWRcIik7XG47XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KGdyaWRfMS5HcmlkTGF5b3V0LCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAnY2xhc3NOYW1lJzogX19jb250ZXh0LnZhbHVlcy5yb290LmNsYXNzTmFtZSB9IH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGdyaWRfMS5Sb3csIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGdyaWRfMS5Db2x1bW4sIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdzcGFuJzogMSB9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiU3BhbiAxXCIpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGdyaWRfMS5Db2x1bW4sIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdzcGFuJzogMSB9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiU3BhbiAxXCIpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGdyaWRfMS5Db2x1bW4sIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdzcGFuJzogMSB9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiU3BhbiAxXCIpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGdyaWRfMS5Db2x1bW4sIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdzcGFuJzogMSB9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiU3BhbiAxXCIpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGdyaWRfMS5Db2x1bW4sIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdzcGFuJzogMSB9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiU3BhbiAxXCIpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGdyaWRfMS5Db2x1bW4sIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdzcGFuJzogMSB9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiU3BhbiAxXCIpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGdyaWRfMS5Db2x1bW4sIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdzcGFuJzogMSB9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiU3BhbiAxXCIpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGdyaWRfMS5Db2x1bW4sIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdzcGFuJzogMSB9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiU3BhbiAxXCIpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGdyaWRfMS5Db2x1bW4sIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdzcGFuJzogMSB9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiU3BhbiAxXCIpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGdyaWRfMS5Db2x1bW4sIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdzcGFuJzogMSB9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiU3BhbiAxXCIpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGdyaWRfMS5Db2x1bW4sIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdzcGFuJzogMSB9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiU3BhbiAxXCIpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGdyaWRfMS5Db2x1bW4sIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdzcGFuJzogMSB9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiU3BhbiAxXCIpXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChncmlkXzEuUm93LCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChncmlkXzEuQ29sdW1uLCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAnc3Bhbic6IDggfSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlNwYW4gOFwiKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChncmlkXzEuQ29sdW1uLCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAnc3Bhbic6IDQgfSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlNwYW4gNFwiKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZ3JpZF8xLlJvdywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZ3JpZF8xLkNvbHVtbiwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ3NwYW4nOiA0IH0gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJTcGFuIDRcIilcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZ3JpZF8xLkNvbHVtbiwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ3NwYW4nOiA0IH0gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJTcGFuIDRcIilcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZ3JpZF8xLkNvbHVtbiwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ3NwYW4nOiA0IH0gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJTcGFuIDRcIilcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGdyaWRfMS5Sb3csIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGdyaWRfMS5Db2x1bW4sIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdzcGFuJzogNiB9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiU3BhbiA2XCIpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGdyaWRfMS5Db2x1bW4sIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdzcGFuJzogNiB9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiU3BhbiA2XCIpXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChncmlkXzEuUm93LCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChncmlkXzEuQ29sdW1uLCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAnc3Bhbic6IDYgfSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlNwYW4gNlwiKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChncmlkXzEuQ29sdW1uLCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAnc3Bhbic6IDYgfSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlNwYW4gNlwiKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChncmlkXzEuQ29sdW1uLCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAnc3Bhbic6IDYgfSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlNwYW4gNlwiKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChncmlkXzEuQ29sdW1uLCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAnc3Bhbic6IDYgfSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlNwYW4gNlwiKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZ3JpZF8xLlJvdywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZ3JpZF8xLkNvbHVtbiwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ3NwYW4nOiAxMiB9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiU3BhbiAxMlwiKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgTWFpbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIE1haW47XG59KCkpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyaWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvaG9yaXpvbnRhbFwiKTtcbnZhciBIb3Jpem9udGFsTGF5b3V0UGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIb3Jpem9udGFsTGF5b3V0UGFnZSgpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBIb3Jpem9udGFsTGF5b3V0UGFnZTtcbn0oKSk7XG5leHBvcnRzLkhvcml6b250YWxMYXlvdXRQYWdlID0gSG9yaXpvbnRhbExheW91dFBhZ2U7XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgSG9yaXpvbnRhbExheW91dFBhZ2UoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRlbW9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi93aWRnZXRzL2RlbW9cIik7XG47XG52YXIgaG9yaXpvbnRhbF8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9sYXlvdXQvaG9yaXpvbnRhbFwiKTtcbjtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGhvcml6b250YWxfMS5Ib3Jpem9udGFsTGF5b3V0LCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCd0ZXh0YXJlYScsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiQXJlYSAxXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCd0ZXh0YXJlYScsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiQXJlYSAyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCd0ZXh0YXJlYScsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiQXJlYSAzXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGhvcml6b250YWxfMS5Ib3Jpem9udGFsTGF5b3V0LCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAnb3JpZW50YXRpb24nOiBob3Jpem9udGFsXzEuSG9yaXpvbnRhbExheW91dE9yaWVudGF0aW9uLkxlZnQgfSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICAgIFRoaXMgaXMgb3JpZW50ZWQgdG8gdGhlIGxlZnQuXFxuICAgIFwiKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGhvcml6b250YWxfMS5Ib3Jpem9udGFsTGF5b3V0LCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAnb3JpZW50YXRpb24nOiBob3Jpem9udGFsXzEuSG9yaXpvbnRhbExheW91dE9yaWVudGF0aW9uLlJpZ2h0IH0gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICBUaGlzIGlzIG9yaWVudGVkIHRvIHRoZSByaWdodC5cXG4gICAgXCIpXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBNYWluLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gTWFpbjtcbn0oKSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG9yaXpvbnRhbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBsaXN0XzEgPSByZXF1aXJlKFwiLi93bWwvbGlzdFwiKTtcbnZhciBMaXN0TGF5b3V0UGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMaXN0TGF5b3V0UGFnZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IGxpc3RfMS5NYWluKHRoaXMpO1xuICAgICAgICB0aGlzLml0ZW1zID0ge1xuICAgICAgICAgICAgJ1RoaXMgaXMgdGhlIGZpcnN0IGl0ZW0uJzogZmFsc2UsXG4gICAgICAgICAgICAnVGhpcyBpcyB0aGUgc2Vjb25kIGl0ZW0uJzogdHJ1ZSxcbiAgICAgICAgICAgICdUaGlzIGlzIHRoZSB0aGlyZCBpdGVtLic6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2xpY2sgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXNcbiAgICAgICAgICAgICAgICAudmlld1xuICAgICAgICAgICAgICAgIC5maW5kQnlJZChrZXkpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobCkgeyByZXR1cm4gbC50b2dnbGVBY3RpdmUoKTsgfSlcbiAgICAgICAgICAgICAgICAub3JKdXN0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFsZXJ0KFwiQ2Fubm90IGZpbmQgZWxlbWVudCBieSBpZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIhXCIpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIExpc3RMYXlvdXRQYWdlO1xufSgpKTtcbmV4cG9ydHMuTGlzdExheW91dFBhZ2UgPSBMaXN0TGF5b3V0UGFnZTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBMaXN0TGF5b3V0UGFnZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19zcHJlYWRBcnJheXMgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xuICAgIHJldHVybiByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkZW1vXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vd2lkZ2V0cy9kZW1vXCIpO1xuO1xudmFyIGxpc3RfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvbGF5b3V0L2xpc3RcIik7XG47XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGxpc3RfMS5MaXN0TGF5b3V0LCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIF9fc3ByZWFkQXJyYXlzKF9fZm9yT2YoX19jb250ZXh0Lml0ZW1zLCBmdW5jdGlvbiAoeWVzLCBrZXksIF8kJGFsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobGlzdF8xLkxpc3RMYXlvdXRJdGVtLCB7IGh0bWw6IHt9LCB3bWw6IHsgJ2lkJzoga2V5IH0sIHd3OiB7ICduYW1lJzoga2V5LCAnYWN0aXZlJzogeWVzLCAnb25DbGljayc6IF9fY29udGV4dC5jbGljayB9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShrZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIChbXSk7IH0pKSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBNYWluLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gTWFpbjtcbn0oKSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGlzdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9tZXRlclwiKTtcbnZhciBNZXRlclBhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWV0ZXJQYWdlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbih0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBtZXNzYWdlOiAnVGhpcyBpcyBhbiBhbGVydCcsXG4gICAgICAgICAgICBiYXJzOiBbXG4gICAgICAgICAgICAgICAgeyB2YWx1ZTogMTAsIGNvbG9yOiAncmVkJyB9LFxuICAgICAgICAgICAgICAgIHsgdmFsdWU6IDUwLCBjb2xvcjogJ2dyZWVuJyB9LFxuICAgICAgICAgICAgICAgIHsgdmFsdWU6IDQwLCBjb2xvcjogJ2JsdWUnIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpbmM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbSA9IF90aGlzLnZpZXcuZmluZEJ5SWQoJ3NpbmdsZScpO1xuICAgICAgICAgICAgICAgIGlmIChtLmlzSnVzdCgpKVxuICAgICAgICAgICAgICAgICAgICBtLmdldCgpLmluY3JlYXNlKDEwKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbSA9IF90aGlzLnZpZXcuZmluZEJ5SWQoJ3NpbmdsZScpO1xuICAgICAgICAgICAgICAgIGlmIChtLmlzSnVzdCgpKVxuICAgICAgICAgICAgICAgICAgICBtLmdldCgpLmRlY3JlYXNlKDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIE1ldGVyUGFnZTtcbn0oKSk7XG5leHBvcnRzLk1ldGVyUGFnZSA9IE1ldGVyUGFnZTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBNZXRlclBhZ2UoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fc3ByZWFkQXJyYXlzID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5cykgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcbiAgICByZXR1cm4gcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbWV0ZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvbGF5b3V0L21ldGVyXCIpO1xuO1xudmFyIGRlbW9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi93aWRnZXRzL2RlbW9cIik7XG47XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaDEnLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJNZXRlclwiKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaDInLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiU2luZ2xlXCIpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgncCcsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2J1dHRvbicsIHsgaHRtbDogeyAnb25jbGljayc6IF9fY29udGV4dC52YWx1ZXMuZGVjIH0sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiLVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnYnV0dG9uJywgeyBodG1sOiB7ICdvbmNsaWNrJzogX19jb250ZXh0LnZhbHVlcy5pbmMgfSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCIrXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChtZXRlcl8xLk1ldGVyLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobWV0ZXJfMS5NZXRlckJhciwgeyBodG1sOiB7fSwgd21sOiB7ICdpZCc6IFwic2luZ2xlXCIgfSwgd3c6IHsgJ3ZhbHVlJzogNzUsICdjb2xvcic6IFwieWVsbG93XCIgfSB9LCBbXSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdoMicsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiQ29tYmluZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChtZXRlcl8xLk1ldGVyLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIF9fc3ByZWFkQXJyYXlzKF9fZm9ySW4oX19jb250ZXh0LnZhbHVlcy5iYXJzLCBmdW5jdGlvbiAodiwgXyQkaSwgXyQkYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobWV0ZXJfMS5NZXRlckJhciwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ3ZhbHVlJzogdi52YWx1ZSwgJ2NvbG9yJzogdi5jb2xvciB9IH0sIFtdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gKFtdKTsgfSkpKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgTWFpbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIE1haW47XG59KCkpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ldGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHBhbmVsXzEgPSByZXF1aXJlKFwiLi93bWwvcGFuZWxcIik7XG52YXIgUGFuZWxQYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhbmVsUGFnZSgpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHBhbmVsXzEuTWFpbih0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIFBhbmVsUGFnZTtcbn0oKSk7XG5leHBvcnRzLlBhbmVsUGFnZSA9IFBhbmVsUGFnZTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBQYW5lbFBhZ2UoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fc3ByZWFkQXJyYXlzID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5cykgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcbiAgICByZXR1cm4gcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ3JpZF8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9sYXlvdXQvZ3JpZFwiKTtcbjtcbnZhciBwYW5lbF8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9sYXlvdXQvcGFuZWxcIik7XG47XG52YXIgc3R5bGVfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvY29udGVudC9zdHlsZVwiKTtcbjtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQoZ3JpZF8xLkdyaWRMYXlvdXQsIHsgaHRtbDoge30sIHdtbDoge30gfSwgX19zcHJlYWRBcnJheXMoX19mb3JJbihzdHlsZV8xLnN0eWxlcywgZnVuY3Rpb24gKHN0eWxlLCBfJCRpLCBfJCRhbGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChncmlkXzEuUm93LCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZ3JpZF8xLkNvbHVtbiwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ3NwYW4nOiA0IH0gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQocGFuZWxfMS5QYW5lbCwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ3N0eWxlJzogc3R5bGUgfSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQocGFuZWxfMS5QYW5lbEJvZHksIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICAgICAgICBQYW5lbEJvZHkgb25seS5cXG4gICAgICAgICAgXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChncmlkXzEuQ29sdW1uLCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAnc3Bhbic6IDQgfSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChwYW5lbF8xLlBhbmVsLCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAnc3R5bGUnOiBzdHlsZSB9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChwYW5lbF8xLlBhbmVsSGVhZGVyLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgICAgICAgV2l0aCBQYW5lbEhlYWRlclxcbiAgICAgICAgICBcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQocGFuZWxfMS5QYW5lbEJvZHksIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICAgICAgICBMb3JlbSBpbXBzdW0gZGlsaXVtIG5ldCBzZXQuXFxuICAgICAgICAgIFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZ3JpZF8xLkNvbHVtbiwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ3NwYW4nOiA0IH0gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQocGFuZWxfMS5QYW5lbCwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ3N0eWxlJzogc3R5bGUgfSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQocGFuZWxfMS5QYW5lbEhlYWRlciwgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIldpdGggUGFuZWxGb290ZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQocGFuZWxfMS5QYW5lbEJvZHksIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJMb3JlbSBpbXBzdW0gZGlsaXVtIG5ldCBzZXQuXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHBhbmVsXzEuUGFuZWxGb290ZXIsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJNZWggZm9vdC5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIChbXSk7IH0pKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYW5lbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC90YWJcIik7XG52YXIgVGFiTGF5b3V0UGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWJMYXlvdXRQYWdlKCkge1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbih0aGlzKTtcbiAgICAgICAgdGhpcy50YWJzID0ge1xuICAgICAgICAgICAgZmlyc3Q6IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiAnRmlyc3QnLFxuICAgICAgICAgICAgICAgIGNvbnRlbnRGdW46IHZpZXdzLmZpcnN0VGFiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2Vjb25kOiB7XG4gICAgICAgICAgICAgICAgdGV4dDogJ1NlY29uZCcsXG4gICAgICAgICAgICAgICAgY29udGVudEZ1bjogdmlld3Muc2Vjb25kVGFiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGhpcmQ6IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiAnVGhpcmQnLFxuICAgICAgICAgICAgICAgIGNvbnRlbnRGdW46IHZpZXdzLnRoaXJkVGFiXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBUYWJMYXlvdXRQYWdlO1xufSgpKTtcbmV4cG9ydHMuVGFiTGF5b3V0UGFnZSA9IFRhYkxheW91dFBhZ2U7XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgVGFiTGF5b3V0UGFnZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZGVtb18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3dpZGdldHMvZGVtb1wiKTtcbjtcbnZhciB0YWJfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvbGF5b3V0L3RhYlwiKTtcbjtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xuZXhwb3J0cy5maXJzdFRhYiA9IGZ1bmN0aW9uIChfKSB7IHJldHVybiBmdW5jdGlvbiAoX190aGlzKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiQ2xpY2sgYSB0YWIgdG8gY2hhbmdlIGNvbnRlbnQuXCIpXG4gICAgICAgIF0pXG4gICAgXTtcbn07IH07XG47XG5leHBvcnRzLnNlY29uZFRhYiA9IGZ1bmN0aW9uIChfKSB7IHJldHVybiBmdW5jdGlvbiAoX190aGlzKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiU2Vjb25kIHRhYi5cIilcbiAgICAgICAgXSlcbiAgICBdO1xufTsgfTtcbjtcbmV4cG9ydHMudGhpcmRUYWIgPSBmdW5jdGlvbiAoXykgeyByZXR1cm4gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgIHJldHVybiBbXG4gICAgICAgIF9fdGhpcy5ub2RlKCdwJywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlRoaXJkIHRhYi5cIilcbiAgICAgICAgXSlcbiAgICBdO1xufTsgfTtcbjtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHRhYl8xLlRhYkxheW91dCwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ3RhYnMnOiBfX2NvbnRleHQudGFicywgJ2FjdGl2ZSc6IFwiZmlyc3RcIiB9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ3AnLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiQ2xpY2sgYSB0YWIgdG8gY2hhbmdlIGNvbnRlbnQuXCIpXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBNYWluLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gTWFpbjtcbn0oKSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFiLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRhYmxlXzEgPSByZXF1aXJlKFwiLi93bWwvdGFibGVcIik7XG52YXIgVGFibGVMYXlvdXRQYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRhYmxlTGF5b3V0UGFnZSgpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IHRhYmxlXzEuTWFpbih0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIFRhYmxlTGF5b3V0UGFnZTtcbn0oKSk7XG5leHBvcnRzLlRhYmxlTGF5b3V0UGFnZSA9IFRhYmxlTGF5b3V0UGFnZTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBUYWJsZUxheW91dFBhZ2UoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fc3ByZWFkQXJyYXlzID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5cykgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcbiAgICByZXR1cm4gcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZGVtb18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3dpZGdldHMvZGVtb1wiKTtcbjtcbnZhciB0YWJsZV8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9sYXlvdXQvdGFibGVcIik7XG47XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbmV4cG9ydHMuY29udGVudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBfX3RoaXMud2lkZ2V0KHRhYmxlXzEuVGFibGVIZWFkZXIsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgX190aGlzLndpZGdldCh0YWJsZV8xLlRhYmxlUm93LCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHRhYmxlXzEuVGFibGVIZWFkaW5nLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJOYW1lXCIpXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldCh0YWJsZV8xLlRhYmxlSGVhZGluZywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiRW1haWxcIilcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHRhYmxlXzEuVGFibGVIZWFkaW5nLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJCYWxhbmNlXCIpXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldCh0YWJsZV8xLlRhYmxlSGVhZGluZywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiVXNlcm5hbWVcIilcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHRhYmxlXzEuVGFibGVIZWFkaW5nLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJTdGF0dXNcIilcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgXSksXG4gICAgICAgIF9fdGhpcy53aWRnZXQodGFibGVfMS5UYWJsZUJvZHksIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgX190aGlzLndpZGdldCh0YWJsZV8xLlRhYmxlUm93LCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHRhYmxlXzEuVGFibGVDZWxsLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJMZW5ndGggV2lzZVwiKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQodGFibGVfMS5UYWJsZUNlbGwsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcImx3QHRoZWVtYWlscGxhY2UuY29tXCIpXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldCh0YWJsZV8xLlRhYmxlQ2VsbCwgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiJDUwMDBcIilcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHRhYmxlXzEuVGFibGVDZWxsLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJsd1wiKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQodGFibGVfMS5UYWJsZUNlbGwsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIkFjdGl2ZVwiKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIF9fdGhpcy53aWRnZXQodGFibGVfMS5UYWJsZVJvdywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldCh0YWJsZV8xLlRhYmxlQ2VsbCwgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiRmlyc3QgQ2hhbmNlXCIpXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldCh0YWJsZV8xLlRhYmxlQ2VsbCwgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiZmNoYWNuZUBsaXZlLnR0XCIpXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldCh0YWJsZV8xLlRhYmxlQ2VsbCwgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiJDEuMDBcIilcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHRhYmxlXzEuVGFibGVDZWxsLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJjaGFuY2VcIilcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHRhYmxlXzEuVGFibGVDZWxsLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJJbmFjdGl2ZVwiKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIF9fdGhpcy53aWRnZXQodGFibGVfMS5UYWJsZVJvdywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldCh0YWJsZV8xLlRhYmxlQ2VsbCwgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiRHUgUGVhclwiKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQodGFibGVfMS5UYWJsZUNlbGwsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcImR1cGVhckBnbWFpbC5jb21cIilcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHRhYmxlXzEuVGFibGVDZWxsLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCIkMTAsMDAwLjAwXCIpXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldCh0YWJsZV8xLlRhYmxlQ2VsbCwgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwicGVhcmJveVwiKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQodGFibGVfMS5UYWJsZUNlbGwsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIkFjdGl2ZVwiKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIF9fdGhpcy53aWRnZXQodGFibGVfMS5UYWJsZVJvdywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldCh0YWJsZV8xLlRhYmxlQ2VsbCwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ3Jvd3NwYW4nOiAyLCAnY29sc3Bhbic6IDUgfSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiVGhpcyBzcGFucyAyIHJvd3MgNSBjb2x1bW5zLlwiKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKVxuICAgICAgICBdKSxcbiAgICAgICAgX190aGlzLndpZGdldCh0YWJsZV8xLlRhYmxlRm9vdGVyLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgIF9fdGhpcy53aWRnZXQodGFibGVfMS5UYWJsZVJvdywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldCh0YWJsZV8xLlRhYmxlQ2VsbCwgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiMVwiKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQodGFibGVfMS5UYWJsZUNlbGwsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIjJcIilcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHRhYmxlXzEuVGFibGVDZWxsLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCIzXCIpXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldCh0YWJsZV8xLlRhYmxlQ2VsbCwgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiNFwiKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQodGFibGVfMS5UYWJsZUNlbGwsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIjVcIilcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgXSlcbiAgICBdO1xufTsgfTtcbjtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2gzJywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIk5vcm1hbFwiKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldCh0YWJsZV8xLlRhYmxlTGF5b3V0LCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIF9fc3ByZWFkQXJyYXlzKChleHBvcnRzLmNvbnRlbnQoKShfX3RoaXMpKSkpXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChkZW1vXzEuRGVtbywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdoMycsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCIgQWx0ZXJuYXRlXCIpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHRhYmxlXzEuVGFibGVMYXlvdXQsIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdhbHRlcm5hdGUnOiB0cnVlIH0gfSwgX19zcHJlYWRBcnJheXMoKGV4cG9ydHMuY29udGVudCgpKF9fdGhpcykpKSlcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2gzJywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIkJvcmRlcmVkXCIpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHRhYmxlXzEuVGFibGVMYXlvdXQsIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdib3JkZXJlZCc6IHRydWUgfSB9LCBfX3NwcmVhZEFycmF5cygoZXhwb3J0cy5jb250ZW50KCkoX190aGlzKSkpKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaDMnLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiSG92ZXJhYmxlXCIpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KHRhYmxlXzEuVGFibGVMYXlvdXQsIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdob3ZlcmFibGUnOiB0cnVlIH0gfSwgX19zcHJlYWRBcnJheXMoKGV4cG9ydHMuY29udGVudCgpKF9fdGhpcykpKSlcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLm5vZGUoJ2gzJywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIkNvbXBhY3RcIilcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQodGFibGVfMS5UYWJsZUxheW91dCwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ2NvbXBhY3QnOiB0cnVlIH0gfSwgX19zcHJlYWRBcnJheXMoKGV4cG9ydHMuY29udGVudCgpKF9fdGhpcykpKSlcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldCh0YWJsZV8xLlRhYmxlV2luZG93LCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQodGFibGVfMS5UYWJsZUxheW91dCwgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBfX3NwcmVhZEFycmF5cygoZXhwb3J0cy5jb250ZW50KCkoX190aGlzKSkpKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgTWFpbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIE1haW47XG59KCkpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG1lbnVfMSA9IHJlcXVpcmUoXCIuL3dtbC9tZW51XCIpO1xudmFyIE1lbnVQYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1lbnVQYWdlKCkge1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgbWVudV8xLk1haW4odGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBNZW51UGFnZTtcbn0oKSk7XG5leHBvcnRzLk1lbnVQYWdlID0gTWVudVBhZ2U7XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgTWVudVBhZ2UoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRlbW9fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi93aWRnZXRzL2RlbW9cIik7XG47XG52YXIgbWVudV8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9tZW51L21lbnVcIik7XG47XG52YXIgaXRlbV8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9tZW51L2l0ZW1cIik7XG47XG52YXIgbGlua18xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9jb250ZW50L2xpbmtcIik7XG47XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KGRlbW9fMS5EZW1vLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG1lbnVfMS5NZW51LCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChpdGVtXzEuSXRlbSwgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaDYnLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIk1lbnVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGl0ZW1fMS5JdGVtLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobGlua18xLkxpbmssIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdkaXNhYmxlZCc6IHRydWUsICd0ZXh0JzogXCJCYWNrXCIgfSB9LCBbXSlcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoaXRlbV8xLkl0ZW0sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChsaW5rXzEuTGluaywgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ2Rpc2FibGVkJzogdHJ1ZSwgJ3RleHQnOiBcIlJlZnJlc2hcIiB9IH0sIFtdKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChpdGVtXzEuSXRlbSwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ2RpdmlkZXInOiB0cnVlIH0gfSwgW10pLFxuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGl0ZW1fMS5JdGVtLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdhJywgeyBodG1sOiB7ICdocmVmJzogXCIjL21lbnVcIiB9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlF1aXRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBNYWluLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gTWFpbjtcbn0oKSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVudS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuYXZfMSA9IHJlcXVpcmUoXCIuL3dtbC9uYXZcIik7XG52YXIgTmF2UGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOYXZQYWdlKCkge1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgbmF2XzEuTWFpbih0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIE5hdlBhZ2U7XG59KCkpO1xuZXhwb3J0cy5OYXZQYWdlID0gTmF2UGFnZTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBOYXZQYWdlKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkZW1vXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vd2lkZ2V0cy9kZW1vXCIpO1xuO1xudmFyIG5hdl8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9tZW51L25hdlwiKTtcbjtcbnZhciBpdGVtXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL21lbnUvaXRlbVwiKTtcbjtcbnZhciBsaW5rXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRlbnQvbGlua1wiKTtcbjtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoZGVtb18xLkRlbW8sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMubm9kZSgnaDMnLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiVGhpcyBpcyBhIGhvcml6b250YWwgbmF2LlwiKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuYXZfMS5OYXYsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChpdGVtXzEuSXRlbSwgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChsaW5rXzEuTGluaywgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ3RleHQnOiBcIkhvbWVcIiB9IH0sIFtdKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGl0ZW1fMS5JdGVtLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGxpbmtfMS5MaW5rLCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAnZGlzYWJsZWQnOiB0cnVlLCAndGV4dCc6IFwiVXNlcnNcIiB9IH0sIFtdKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGl0ZW1fMS5JdGVtLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGxpbmtfMS5MaW5rLCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAndGV4dCc6IFwiTG9nb3V0XCIgfSB9LCBbXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChkZW1vXzEuRGVtbywgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy5ub2RlKCdoMycsIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJUaGlzIGlzIGEgdmVydGljYWwgbmF2LlwiKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChuYXZfMS5OYXYsIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICd2ZXJ0aWNhbCc6IHRydWUgfSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGl0ZW1fMS5JdGVtLCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGxpbmtfMS5MaW5rLCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAndGV4dCc6IFwiSG9tZVwiIH0gfSwgW10pXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoaXRlbV8xLkl0ZW0sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobGlua18xLkxpbmssIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdkaXNhYmxlZCc6IHRydWUsICd0ZXh0JzogXCJVc2Vyc1wiIH0gfSwgW10pXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoaXRlbV8xLkl0ZW0sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobGlua18xLkxpbmssIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICd0ZXh0JzogXCJMb2dvdXRcIiB9IH0sIFtdKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW4ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLndtbC5pZDtcbiAgICAgICAgdmFyIGdyb3VwID0gYXR0cnMud21sLmdyb3VwO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IHNldHRpbmcgdGhpbmdzIGxpa2UgZGlzYWJsZWQ9JydcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQodG4pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgYyArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS53aWRnZXQgPSBmdW5jdGlvbiAoQywgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IEMoYXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih3LCBhdHRycyk7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21OdWxsYWJsZSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tQXJyYXkodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbbmFtZV0gOlxuICAgICAgICAgICAgW10pO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6ICcgKyAnQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyAgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgdHJlZSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID9cbiAgICAgICAgICAgIHRoaXMuaWRzWydyb290J10gOlxuICAgICAgICAgICAgdGhpcy50cmVlO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluO1xufSgpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uYXYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhZ2VzID0ge1xuICAgICdjb250ZW50X2VtYmVkJzogcmVxdWlyZSgnLi9wYWdlL2NvbnRlbnRfZW1iZWQnKS5kZWZhdWx0LFxuICAgICdjb250ZW50X21lZGlhLWRlc2NyaXB0aW9uJzogcmVxdWlyZSgnLi9wYWdlL2NvbnRlbnRfbWVkaWEtZGVzY3JpcHRpb24nKS5kZWZhdWx0LFxuICAgICdjb250ZW50X292ZXJsYXknOiByZXF1aXJlKCcuL3BhZ2UvY29udGVudF9vdmVybGF5JykuZGVmYXVsdCxcbiAgICAnY29udGVudF90YWcnOiByZXF1aXJlKCcuL3BhZ2UvY29udGVudF90YWcnKS5kZWZhdWx0LFxuICAgICdjb250ZW50X3RodW1ibmFpbCc6IHJlcXVpcmUoJy4vcGFnZS9jb250ZW50X3RodW1ibmFpbCcpLmRlZmF1bHQsXG4gICAgJ2NvbnRyb2xfYnV0dG9uJzogcmVxdWlyZSgnLi9wYWdlL2NvbnRyb2xfYnV0dG9uJykuZGVmYXVsdCxcbiAgICAnY29udHJvbF9idXR0b24tZ3JvdXAnOiByZXF1aXJlKCcuL3BhZ2UvY29udHJvbF9idXR0b24tZ3JvdXAnKS5kZWZhdWx0LFxuICAgICdjb250cm9sX2J1dHRvbi1zZWxlY3QnOiByZXF1aXJlKCcuL3BhZ2UvY29udHJvbF9idXR0b24tc2VsZWN0JykuZGVmYXVsdCxcbiAgICAnY29udHJvbF9jaGVja2JveCc6IHJlcXVpcmUoJy4vcGFnZS9jb250cm9sX2NoZWNrYm94JykuZGVmYXVsdCxcbiAgICAnY29udHJvbF9kYXRlLWZpZWxkJzogcmVxdWlyZSgnLi9wYWdlL2NvbnRyb2xfZGF0ZS1maWVsZCcpLmRlZmF1bHQsXG4gICAgJ2NvbnRyb2xfZGlzcGxheS1maWVsZCc6IHJlcXVpcmUoJy4vcGFnZS9jb250cm9sX2Rpc3BsYXktZmllbGQnKS5kZWZhdWx0LFxuICAgICdjb250cm9sX2Ryb3AtZG93bic6IHJlcXVpcmUoJy4vcGFnZS9jb250cm9sX2Ryb3AtZG93bicpLmRlZmF1bHQsXG4gICAgJ2NvbnRyb2xfZHJvcC1saXN0JzogcmVxdWlyZSgnLi9wYWdlL2NvbnRyb2xfZHJvcC1saXN0JykuZGVmYXVsdCxcbiAgICAnY29udHJvbF9kcm9wLWxpc3QtZmllbGQnOiByZXF1aXJlKCcuL3BhZ2UvY29udHJvbF9kcm9wLWxpc3QtZmllbGQnKS5kZWZhdWx0LFxuICAgICdjb250cm9sX2ZpbGUtdXBsb2FkLXN1cmZhY2UnOiByZXF1aXJlKCcuL3BhZ2UvY29udHJvbF9maWxlLXVwbG9hZC1zdXJmYWNlJykuZGVmYXVsdCxcbiAgICAnY29udHJvbF9tdWx0aS1zZWxlY3QnOiByZXF1aXJlKCcuL3BhZ2UvY29udHJvbF9tdWx0aS1zZWxlY3QnKS5kZWZhdWx0LFxuICAgICdjb250cm9sX3BhZ2luYXRvcic6IHJlcXVpcmUoJy4vcGFnZS9jb250cm9sX3BhZ2luYXRvcicpLmRlZmF1bHQsXG4gICAgJ2NvbnRyb2xfc2VhcmNoJzogcmVxdWlyZSgnLi9wYWdlL2NvbnRyb2xfc2VhcmNoJykuZGVmYXVsdCxcbiAgICAnY29udHJvbF9zZWxlY3QnOiByZXF1aXJlKCcuL3BhZ2UvY29udHJvbF9zZWxlY3QnKS5kZWZhdWx0LFxuICAgICdjb250cm9sX3N0YWNrJzogcmVxdWlyZSgnLi9wYWdlL2NvbnRyb2xfc3RhY2snKS5kZWZhdWx0LFxuICAgICdjb250cm9sX3N0YWNrLXNlbGVjdCc6IHJlcXVpcmUoJy4vcGFnZS9jb250cm9sX3N0YWNrLXNlbGVjdCcpLmRlZmF1bHQsXG4gICAgJ2NvbnRyb2xfc3dpdGNoJzogcmVxdWlyZSgnLi9wYWdlL2NvbnRyb2xfc3dpdGNoJykuZGVmYXVsdCxcbiAgICAnY29udHJvbF90YWItYmFyJzogcmVxdWlyZSgnLi9wYWdlL2NvbnRyb2xfdGFiLWJhcicpLmRlZmF1bHQsXG4gICAgJ2NvbnRyb2xfdGFnLWNvbnRyb2wnOiByZXF1aXJlKCcuL3BhZ2UvY29udHJvbF90YWctY29udHJvbCcpLmRlZmF1bHQsXG4gICAgJ2NvbnRyb2xfdGV4dC1maWVsZCc6IHJlcXVpcmUoJy4vcGFnZS9jb250cm9sX3RleHQtZmllbGQnKS5kZWZhdWx0LFxuICAgICdjb250cm9sX3RleHQtaW5wdXQnOiByZXF1aXJlKCcuL3BhZ2UvY29udHJvbF90ZXh0LWlucHV0JykuZGVmYXVsdCxcbiAgICAnY29udHJvbF90eXBlYWhlYWQnOiByZXF1aXJlKCcuL3BhZ2UvY29udHJvbF90eXBlYWhlYWQnKS5kZWZhdWx0LFxuICAgICdkYXRhX2RhdGEtdGFibGUnOiByZXF1aXJlKCcuL3BhZ2UvZGF0YV9kYXRhLXRhYmxlJykuZGVmYXVsdCxcbiAgICAnZGF0YV9wcm9wZXJ0eS1saXN0JzogcmVxdWlyZSgnLi9wYWdlL2RhdGFfcHJvcGVydHktbGlzdCcpLmRlZmF1bHQsXG4gICAgJ2RpYWxvZ19hbGVydCc6IHJlcXVpcmUoJy4vcGFnZS9kaWFsb2dfYWxlcnQnKS5kZWZhdWx0LFxuICAgICdkaWFsb2dfY29uZmlybSc6IHJlcXVpcmUoJy4vcGFnZS9kaWFsb2dfY29uZmlybScpLmRlZmF1bHQsXG4gICAgJ2RpYWxvZ19pbmZvcm0nOiByZXF1aXJlKCcuL3BhZ2UvZGlhbG9nX2luZm9ybScpLmRlZmF1bHQsXG4gICAgJ2RpYWxvZ19tb2RhbCc6IHJlcXVpcmUoJy4vcGFnZS9kaWFsb2dfbW9kYWwnKS5kZWZhdWx0LFxuICAgICdkaWFsb2dfcHJvbXB0JzogcmVxdWlyZSgnLi9wYWdlL2RpYWxvZ19wcm9tcHQnKS5kZWZhdWx0LFxuICAgICdsYXlvdXRfY2FsbG91dCc6IHJlcXVpcmUoJy4vcGFnZS9sYXlvdXRfY2FsbG91dCcpLmRlZmF1bHQsXG4gICAgJ2xheW91dF9kZXNjcmlwdGlvbi1saXN0JzogcmVxdWlyZSgnLi9wYWdlL2xheW91dF9kZXNjcmlwdGlvbi1saXN0JykuZGVmYXVsdCxcbiAgICAnbGF5b3V0X2dyaWQnOiByZXF1aXJlKCcuL3BhZ2UvbGF5b3V0X2dyaWQnKS5kZWZhdWx0LFxuICAgICdsYXlvdXRfaG9yaXpvbnRhbCc6IHJlcXVpcmUoJy4vcGFnZS9sYXlvdXRfaG9yaXpvbnRhbCcpLmRlZmF1bHQsXG4gICAgJ2xheW91dF9saXN0JzogcmVxdWlyZSgnLi9wYWdlL2xheW91dF9saXN0JykuZGVmYXVsdCxcbiAgICAnbGF5b3V0X21ldGVyJzogcmVxdWlyZSgnLi9wYWdlL2xheW91dF9tZXRlcicpLmRlZmF1bHQsXG4gICAgJ2xheW91dF9wYW5lbCc6IHJlcXVpcmUoJy4vcGFnZS9sYXlvdXRfcGFuZWwnKS5kZWZhdWx0LFxuICAgICdsYXlvdXRfdGFiJzogcmVxdWlyZSgnLi9wYWdlL2xheW91dF90YWInKS5kZWZhdWx0LFxuICAgICdsYXlvdXRfdGFibGUnOiByZXF1aXJlKCcuL3BhZ2UvbGF5b3V0X3RhYmxlJykuZGVmYXVsdCxcbiAgICAnbWVudV9tZW51JzogcmVxdWlyZSgnLi9wYWdlL21lbnVfbWVudScpLmRlZmF1bHQsXG4gICAgJ21lbnVfbmF2JzogcmVxdWlyZSgnLi9wYWdlL21lbnVfbmF2JykuZGVmYXVsdCxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWdlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHdtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2RlbW9cIik7XG52YXIgRGVtbyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGVtbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZW1vKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgc2l6ZTogX3RoaXMuYXR0cnMuc2l6ZSxcbiAgICAgICAgICAgIG9mZnNldDogX3RoaXMuYXR0cnMub2Zmc2V0XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIERlbW87XG59KHdtbC5Db21wb25lbnQpKTtcbmV4cG9ydHMuRGVtbyA9IERlbW87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3NwcmVhZEFycmF5cyA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheXMpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxuICAgICAgICAgICAgcltrXSA9IGFbal07XG4gICAgcmV0dXJuIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGdyaWRfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9saWIvbGF5b3V0L2dyaWRcIik7XG47XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KGdyaWRfMS5HcmlkTGF5b3V0LCB7IGh0bWw6IHt9LCB3bWw6IHt9IH0sIFtcbiAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGdyaWRfMS5Sb3csIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGdyaWRfMS5Db2x1bW4sIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdzcGFuJzogX19jb250ZXh0LnZhbHVlcy5zaXplIH0gfSwgX19zcHJlYWRBcnJheXMoKF9fY29udGV4dC5jaGlsZHJlbikpKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgTWFpbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMud21sLmlkO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhdHRycy53bWwuZ3JvdXA7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgc2V0dGluZyB0aGluZ3MgbGlrZSBkaXNhYmxlZD0nJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh0bik7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLndpZGdldCA9IGZ1bmN0aW9uIChDLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQyhhdHRycywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHcsIGF0dHJzKTtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB3LnJlbmRlcigpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbU51bGxhYmxlKHRoaXMuaWRzW2lkXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXliZV8xLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tuYW1lXSA6XG4gICAgICAgICAgICBbXSk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogJyArICdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3ICB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0cmVlKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgP1xuICAgICAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA6XG4gICAgICAgICAgICB0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIE1haW47XG59KCkpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlbW8uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19zcHJlYWRBcnJheXMgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xuICAgIHJldHVybiByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkcmF3ZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9saWIvbGF5b3V0L2RyYXdlclwiKTtcbjtcbnZhciBhY3Rpb25fYmFyXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vbGliL2xheW91dC9hY3Rpb24tYmFyXCIpO1xuO1xuO1xudmFyIGxpbmtfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9saWIvY29udGVudC9saW5rXCIpO1xuO1xudmFyIG1lbnVfaWNvbl8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2xpYi9jb250ZW50L21lbnUtaWNvblwiKTtcbjtcbnZhciBtYWluXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vbGliL2xheW91dC9tYWluXCIpO1xuO1xudmFyIG5hdmlnYXRpb25fMSA9IHJlcXVpcmUoXCIuL25hdmlnYXRpb25cIik7XG4vL0B0cy1pZ25vcmU6IDYxOTJcbnZhciBtYXliZV8xID0gcmVxdWlyZShcIkBxdWVuay9ub25pL2xpYi9kYXRhL21heWJlXCIpO1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2lmID0gZnVuY3Rpb24gKF9fZXhwciwgX19jb25zZXEsIF9fYWx0KSB7XG4gICAgcmV0dXJuIChfX2V4cHIpID8gX19jb25zZXEoKSA6IF9fYWx0KCk7XG59O1xuLy9AdHMtaWdub3JlOjYxOTJcbnZhciBfX2ZvckluID0gZnVuY3Rpb24gKGxpc3QsIGYsIGFsdCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoZihsaXN0W2ldLCBpLCBsaXN0KSk7XG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBhbHQoKSA6IHJldDtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9yT2YgPSBmdW5jdGlvbiAobywgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvKVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKChvKVtrZXldLCBrZXksIG8pKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW4oX19jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3RoaXMud2lkZ2V0KGRyYXdlcl8xLkRyYXdlckxheW91dCwgeyBodG1sOiB7fSwgd21sOiB7ICdpZCc6IF9fY29udGV4dC52YWx1ZXMuaWQubGF5b3V0IH0sIHd3OiB7ICdkcmF3ZXJDb250ZW50JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgKG5ldyBuYXZpZ2F0aW9uXzEuTmF2aWdhdGlvbihfX2NvbnRleHQpKS5yZW5kZXIoKVxuICAgICAgICAgICAgICAgICAgICBdIH0gfSwgW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoYWN0aW9uX2Jhcl8xLkFjdGlvbkJhciwgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobGlua18xLkxpbmssIHsgaHRtbDoge30sIHdtbDoge30sIHd3OiB7ICdvbkNsaWNrJzogX19jb250ZXh0LnRvZ2dsZURyYXdlciB9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQobWVudV9pY29uXzEuTWVudUljb24sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW10pXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX190aGlzLndpZGdldChtYWluXzEuTWFpbkxheW91dCwgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBfX3NwcmVhZEFycmF5cygoX19jb250ZXh0LmNvbnRlbnQpKSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBNYWluLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBNYWluLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIE1haW4ucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgTWFpbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gTWFpbjtcbn0oKSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fc3ByZWFkQXJyYXlzID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5cykgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcbiAgICByZXR1cm4gcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG47XG52YXIgbmF2XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vbGliL21lbnUvbmF2XCIpO1xuO1xudmFyIGl0ZW1fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9saWIvbWVudS9pdGVtXCIpO1xuO1xudmFyIGhlYWRlcl8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2xpYi9tZW51L2hlYWRlclwiKTtcbjtcbnZhciBsaW5rXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vbGliL2NvbnRlbnQvbGlua1wiKTtcbi8vQHRzLWlnbm9yZTogNjE5MlxudmFyIG1heWJlXzEgPSByZXF1aXJlKFwiQHF1ZW5rL25vbmkvbGliL2RhdGEvbWF5YmVcIik7XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9faWYgPSBmdW5jdGlvbiAoX19leHByLCBfX2NvbnNlcSwgX19hbHQpIHtcbiAgICByZXR1cm4gKF9fZXhwcikgPyBfX2NvbnNlcSgpIDogX19hbHQoKTtcbn07XG4vL0B0cy1pZ25vcmU6NjE5MlxudmFyIF9fZm9ySW4gPSBmdW5jdGlvbiAobGlzdCwgZiwgYWx0KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChmKGxpc3RbaV0sIGksIGxpc3QpKTtcbiAgICByZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IGFsdCgpIDogcmV0O1xufTtcbi8vQHRzLWlnbm9yZTo2MTkyXG52YXIgX19mb3JPZiA9IGZ1bmN0aW9uIChvLCBmLCBhbHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGYoKG8pW2tleV0sIGtleSwgbykpO1xuICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gYWx0KCkgOiByZXQ7XG59O1xudmFyIE5hdmlnYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmF2aWdhdGlvbihfX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMudHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fdGhpcy53aWRnZXQobmF2XzEuTmF2LCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAndmVydGljYWwnOiB0cnVlIH0gfSwgX19zcHJlYWRBcnJheXMoW1xuICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoaXRlbV8xLkl0ZW0sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGxpbmtfMS5MaW5rLCB7IGh0bWw6IHt9LCB3bWw6IHsgJ2dyb3VwJzogXCJsaW5rc1wiIH0sIHd3OiB7ICdhY3RpdmUnOiAoX19jb250ZXh0LnBhZ2UgPT09IFwiaG9tZVwiKSwgJ25hbWUnOiBcImhvbWVcIiwgJ2hyZWYnOiBcIiNcIiwgJ29uQ2xpY2snOiBfX2NvbnRleHQubmF2aWdhdGUsICd0ZXh0JzogXCJIb21lXCIgfSB9LCBbXSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSwgX19mb3JPZihfX2NvbnRleHQucGFnZXMsIGZ1bmN0aW9uIChpdGVtcywgc2VjdGlvbiwgXyQkYWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChbXG4gICAgICAgICAgICAgICAgICAgIF9fdGhpcy53aWRnZXQoaXRlbV8xLkl0ZW0sIHsgaHRtbDoge30sIHdtbDoge30gfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChoZWFkZXJfMS5NZW51SGVhZGVyLCB7IGh0bWw6IHt9LCB3bWw6IHt9LCB3dzogeyAndGV4dCc6IHNlY3Rpb24gfSB9LCBbXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KG5hdl8xLk5hdiwgeyBodG1sOiB7fSwgd21sOiB7fSwgd3c6IHsgJ3ZlcnRpY2FsJzogdHJ1ZSB9IH0sIF9fc3ByZWFkQXJyYXlzKF9fZm9yT2YoaXRlbXMsIGZ1bmN0aW9uIChfLCBuYW1lLCBfJCRhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGlzLndpZGdldChpdGVtXzEuSXRlbSwgeyBodG1sOiB7fSwgd21sOiB7fSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoaXMud2lkZ2V0KGxpbmtfMS5MaW5rLCB7IGh0bWw6IHt9LCB3bWw6IHsgJ2dyb3VwJzogXCJsaW5rc1wiIH0sIHd3OiB7ICduYW1lJzogbmFtZSwgJ2hyZWYnOiAoXCIjL1wiICsgbmFtZSksICdvbkNsaWNrJzogX19jb250ZXh0Lm5hdmlnYXRlLCAnYWN0aXZlJzogKF9fY29udGV4dC5wYWdlID09PSBuYW1lKSwgJ3RleHQnOiBuYW1lIH0gfSwgW10pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiAoW10pOyB9KSkpXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiAoW10pOyB9KSkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBOYXZpZ2F0aW9uLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChlLCBhdHRycykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy53bWwuaWQ7XG4gICAgICAgIHZhciBncm91cCA9IGF0dHJzLndtbC5ncm91cDtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTmF2aWdhdGlvbi5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBzZXR0aW5nIHRoaW5ncyBsaWtlIGRpc2FibGVkPScnXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHRuKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGMgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgTmF2aWdhdGlvbi5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKEMsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgdyA9IG5ldyBDKGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIodywgYXR0cnMpO1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHcucmVuZGVyKCk7XG4gICAgfTtcbiAgICBOYXZpZ2F0aW9uLnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVfMS5mcm9tTnVsbGFibGUodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIE5hdmlnYXRpb24ucHJvdG90eXBlLmZpbmRCeUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlXzEuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW25hbWVdIDpcbiAgICAgICAgICAgIFtdKTtcbiAgICB9O1xuICAgIE5hdmlnYXRpb24ucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignaW52YWxpZGF0ZSgpOiAnICsgJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHRyZWUpO1xuICAgIH07XG4gICAgTmF2aWdhdGlvbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/XG4gICAgICAgICAgICB0aGlzLmlkc1sncm9vdCddIDpcbiAgICAgICAgICAgIHRoaXMudHJlZTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gTmF2aWdhdGlvbjtcbn0oKSk7XG5leHBvcnRzLk5hdmlnYXRpb24gPSBOYXZpZ2F0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmF2aWdhdGlvbi5qcy5tYXAiXX0=
