import { Component } from '@quenk/wml';
import { Maybe } from '@quenk/noni/lib/data/maybe';
import { WidgetAttrs, HTMLElementAttrs } from '../';
/**
 * This module provides the parent interfaces for most of the
 * widgets considered 'controls'.
 *
 * Controls allow users to manipulate the state of an application
 * by interacting with widgets on screen. In simpler terms,
 * they are the widgets that accept user input or trigger
 * reactions when the user manipulates them.
 *
 * Generally, we use a streaming based workflow, that is
 * as the user preforms a supported action and event is generated
 * each and every time and some handler is applied to the event.
 */
/**
 * ControlAttrs
 */
export interface ControlAttrs<V> extends HTMLElementAttrs {
    /**
     * name of the control.
     *
     * Used by controls to tag events with names.
     */
    name?: string;
    /**
     * value of the control.
     *
     * Used to intialize controls and may also be the
     * value of an Event.
     */
    value?: V;
    /**
     * disabled indicates the control should not be interactable.
     */
    disabled?: boolean;
}
/**
 * Control
 */
export interface Control<V, A extends ControlAttrs<V>> extends Component<WidgetAttrs<A>> {
}
/**
 * Event is the parent class of all events generated by controls.
 */
export declare class Event<V> {
    name: string;
    value: V;
    constructor(name: string, value: V);
}
/**
 * AbstractControl implements the methods of the Control interface.
 */
export declare abstract class AbstractControl<V, A extends ControlAttrs<V>> extends Component<WidgetAttrs<A>> implements Control<V, A> {
}
/**
 * getName
 */
export declare const getName: <V>(attrs: WidgetAttrs<ControlAttrs<V>>) => string;
/**
 * getDisabled
 */
export declare const getDisabled: <V>(attrs: WidgetAttrs<ControlAttrs<V>>) => boolean;
/**
 * getValue
 */
export declare const getValue: <V>(attrs: WidgetAttrs<ControlAttrs<V>>) => Maybe<V>;
