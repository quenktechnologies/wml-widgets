(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var app_1 = require("./wml/app");
var navigation_1 = require("./wml/navigation");
var home_1 = require("./pages/home");
var panel_1 = require("./pages/panel");
var list_group_1 = require("./pages/list-group");
var table_1 = require("./pages/table");
var text_field_1 = require("./pages/text-field");
var date_1 = require("./pages/date");
var select_1 = require("./pages/select");
var button_select_1 = require("./pages/button-select");
var checkbox_1 = require("./pages/checkbox");
var switch_1 = require("./pages/switch");
var tabs_1 = require("./pages/tabs");
var stack_1 = require("./pages/stack");
var search_stack_1 = require("./pages/search-stack");
var autocomplete_1 = require("./pages/autocomplete");
var breadcrumbs_1 = require("./pages/breadcrumbs");
var busy_indicator_1 = require("./pages/busy-indicator");
var menu_1 = require("./pages/menu");
var button_menu_1 = require("./pages/button-menu");
var App = /** @class */ (function () {
    function App() {
        var _this = this;
        /**
         * page currently displayed.
         */
        this.page = 'home';
        /**
         * pages to show the user.
         */
        this.pages = {
            home: new home_1.HomePage(this),
            panel: new panel_1.PanelPage(this),
            'list-group': new list_group_1.ListGroupPage(this),
            table: new table_1.TablePage(this),
            'text-field': new text_field_1.TextFieldPage(this),
            date: new date_1.DatePage(this),
            select: new select_1.SelectPage(this),
            autocomplete: new autocomplete_1.AutocompletePage(this),
            'button-select': new button_select_1.ButtonSelectPage(this),
            tabs: new tabs_1.TabsPage(this),
            stack: new stack_1.StackPage(this),
            checkbox: new checkbox_1.CheckboxPage(this),
            'switch': new switch_1.SwitchPage(this),
            'busy-indicator': new busy_indicator_1.BusyIndicatorPage(this),
            'search-stack': new search_stack_1.SearchStackPage(this),
            breadcrumbs: new breadcrumbs_1.BreadCrumbsPage(this),
            menu: new menu_1.MenuPage(this),
            'button-menu': new button_menu_1.ButtonMenuPage(this)
        };
        /**
         * navigation view
         */
        this.navigation = new navigation_1.Navigation(this);
        /**
         * values used within the template.
         */
        this.values = {
            id: {
                layout: 'layout'
            }
        };
        /**
         * view is the current application view.
         */
        this.view = new app_1.Main(this);
        /**
         * content displayed as the main content.
         */
        this.content = this.pages.home.view;
        /**
         * toggleDrawer
         */
        this.toggleDrawer = function () {
            _this
                .view
                .findById(_this.values.id.layout)
                .map(function (d) { return d.toggleDrawer(); });
        };
        /**
         * navigate is called when the user clicks on a
         * navigation link.
         */
        this.navigate = function (_a) {
            var name = _a.name;
            return _this.route(name);
        };
    }
    /**
     * route the main content based on the passed string.
     */
    App.prototype.route = function (name) {
        console.info('name-> ', name);
        console.info(this.pages.hasOwnProperty(name));
        this.page = name;
        if (this.pages.hasOwnProperty(name))
            this.content = this.pages[name].view;
        this.view.invalidate();
        this.navigation.invalidate();
    };
    /**
     * run the application.
     */
    App.prototype.run = function () {
        var root = document.getElementById('app');
        while (root.lastChild)
            root.removeChild(root.lastChild);
        root.appendChild(this.view.render());
        this.layout = this.view.findById(this.values.id.layout);
        var path = window.location.hash.split('#')[1];
        path = path ? path.split('/').join('') : '';
        this.route(path);
    };
    App.main = function () {
        return new App();
    };
    return App;
}());
exports.App = App;
var w = window;
w.app = App.main();
w.app.run();

},{"./pages/autocomplete":3,"./pages/breadcrumbs":5,"./pages/busy-indicator":7,"./pages/button-menu":9,"./pages/button-select":11,"./pages/checkbox":13,"./pages/date":15,"./pages/home":17,"./pages/list-group":19,"./pages/menu":21,"./pages/panel":23,"./pages/search-stack":25,"./pages/select":27,"./pages/stack":29,"./pages/switch":31,"./pages/table":34,"./pages/tabs":36,"./pages/text-field":38,"./wml/app":40,"./wml/navigation":41}],2:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Page = /** @class */ (function () {
    function Page(app) {
        this.app = app;
    }
    Page.prototype.get = function (id, fn) {
        this
            .view
            .findById(id)
            .map(fn)
            .orJust(function () { return console.warn(id + ": is missing"); });
    };
    return Page;
}());
exports.Page = Page;

},{}],3:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/autocomplete");
var Page_1 = require("../Page");
var AutocompletePage = /** @class */ (function (_super) {
    __extends(AutocompletePage, _super);
    function AutocompletePage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            id: 'search',
            name: 'search',
            results: [
                { label: 'Asus', value: 'Asus' },
                { label: 'MSI', value: 'MSI' },
                { label: 'Gigabyte', value: 'Gigabyte' },
                { label: 'Gigas', value: 'Gigas' },
                { label: 'AsusTek', value: 'AsusTek' },
                { label: 'Asusuga', value: 'Asusuga' },
                { label: 'Qualcomm', value: 'Qualcomm' },
                { label: 'Qualitative', value: 'Qualitatve' },
                { label: 'Asunder', value: 'Asunder' }
            ]
        };
        _this.onSearch = function (_a) {
            var value = _a.value;
            _this
                .view
                .findById(_this.values.id)
                .map(function (s) {
                var hit = _this.values.results.filter(function (c) {
                    return c.value.toLowerCase().startsWith(value) ? true : false;
                });
                s.update(hit);
            });
        };
        _this.onSelect = function (_a) {
            var value = _a.value;
            _this.view.findById('selected')
                .map(function (e) {
                while (e.lastChild)
                    e.removeChild(e.lastChild);
                e.appendChild(document.createTextNode(value.value));
            });
        };
        return _this;
    }
    return AutocompletePage;
}(Page_1.Page));
exports.AutocompletePage = AutocompletePage;

},{"../Page":2,"./wml/autocomplete":4}],4:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Grid_1 = require("@package/self/layout/grid/Grid");
;
var autocomplete_1 = require("@package/self/control/autocomplete");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Grid_1.Grid, {
                html: {},
                wml: {}
            }, [___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {},
                        ww: {
                            'size': 6
                        }
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.text("You selected: "), ___wml.node('b', {
                                html: {},
                                wml: {
                                    'id': "selected"
                                }
                            }, [___wml.text("(nothing)")], ___view), ___wml.text(".")], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(autocomplete_1.Autocomplete, {
                                html: {},
                                wml: {
                                    'id': ___context.values.id
                                },
                                ww: {
                                    'name': ___context.values.name,
                                    'stringifier': function (r) { return r.value; },
                                    'onSearch': ___context.onSearch,
                                    'onSelect': ___context.onSelect
                                }
                            }, [], ___view)], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/control/autocomplete":57,"@package/self/layout/grid/Grid":109,"@quenk/wml":162}],5:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Page_1 = require("../Page");
var breadcrumbs_1 = require("./wml/breadcrumbs");
var BreadCrumbsPage = /** @class */ (function (_super) {
    __extends(BreadCrumbsPage, _super);
    function BreadCrumbsPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new breadcrumbs_1.Main(_this);
        return _this;
    }
    return BreadCrumbsPage;
}(Page_1.Page));
exports.BreadCrumbsPage = BreadCrumbsPage;

},{"../Page":2,"./wml/breadcrumbs":6}],6:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Grid_1 = require("@package/self/layout/grid/Grid");
;
var BreadCrumbs_1 = require("@package/self/nav/breadcrumbs/BreadCrumbs");
;
var Item_1 = require("@package/self/nav/breadcrumbs/Item");
;
var Link_1 = require("@package/self/nav/link/Link");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Grid_1.Grid, {
                html: {},
                wml: {}
            }, [___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.widget(BreadCrumbs_1.BreadCrumbs, {
                            html: {},
                            wml: {}
                        }, [___wml.widget(Item_1.Item, {
                                html: {},
                                wml: {}
                            }, [___wml.widget(Link_1.Link, {
                                    html: {},
                                    wml: {},
                                    ww: {
                                        'text': "One"
                                    }
                                }, [], ___view)], ___view), ___wml.widget(Item_1.Item, {
                                html: {},
                                wml: {}
                            }, [___wml.widget(Link_1.Link, {
                                    html: {},
                                    wml: {},
                                    ww: {
                                        'text': "Two"
                                    }
                                }, [], ___view)], ___view), ___wml.widget(Item_1.Item, {
                                html: {},
                                wml: {}
                            }, [___wml.widget(Link_1.Link, {
                                    html: {},
                                    wml: {},
                                    ww: {
                                        'text': "Three"
                                    }
                                }, [], ___view)], ___view)], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/layout/grid/Grid":109,"@package/self/nav/breadcrumbs/BreadCrumbs":133,"@package/self/nav/breadcrumbs/Item":134,"@package/self/nav/link/Link":136,"@quenk/wml":162}],7:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var busy_indicator_1 = require("./wml/busy-indicator");
var Page_1 = require("../Page");
var BusyIndicatorPage = /** @class */ (function (_super) {
    __extends(BusyIndicatorPage, _super);
    function BusyIndicatorPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new busy_indicator_1.Main(_this);
        return _this;
    }
    return BusyIndicatorPage;
}(Page_1.Page));
exports.BusyIndicatorPage = BusyIndicatorPage;

},{"../Page":2,"./wml/busy-indicator":8}],8:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var BusyIndicator_1 = require("@package/self/app/busy-indicator/BusyIndicator");
;
var Grid_1 = require("@package/self/layout/grid/Grid");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Grid_1.Grid, {
                html: {},
                wml: {}
            }, [___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.widget(BusyIndicator_1.BusyIndicator, {
                            html: {},
                            wml: {}
                        }, [], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/app/busy-indicator/BusyIndicator":44,"@package/self/layout/grid/Grid":109,"@quenk/wml":162}],9:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/button-menu");
var Page_1 = require("../Page");
var ButtonMenuPage = /** @class */ (function (_super) {
    __extends(ButtonMenuPage, _super);
    function ButtonMenuPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.onClick = function (msg) { return function (e) {
            e.preventDefault();
            alert(msg);
        }; };
        return _this;
    }
    return ButtonMenuPage;
}(Page_1.Page));
exports.ButtonMenuPage = ButtonMenuPage;

},{"../Page":2,"./wml/button-menu":10}],10:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Grid_1 = require("@package/self/layout/grid/Grid");
;
var button_menu_1 = require("@package/self/menu/button-menu");
;
var menu_1 = require("@package/self/menu");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Grid_1.Grid, {
                html: {},
                wml: {}
            }, [___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {},
                        ww: {
                            'size': 6
                        }
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(button_menu_1.ButtonMenu, {
                                html: {},
                                wml: {},
                                ww: {
                                    'text': "Click Me"
                                }
                            }, [___wml.widget(menu_1.MenuItem, {
                                    html: {},
                                    wml: {}
                                }, [___wml.node('a', {
                                        html: {
                                            'href': "#",
                                            'onclick': ___context.onClick("You clicked one")
                                        },
                                        wml: {}
                                    }, [___wml.text("One")], ___view)], ___view), ___wml.widget(menu_1.MenuItem, {
                                    html: {},
                                    wml: {}
                                }, [___wml.node('a', {
                                        html: {
                                            'href': "#",
                                            'onclick': ___context.onClick("You clicked two")
                                        },
                                        wml: {}
                                    }, [___wml.text("Two")], ___view)], ___view), ___wml.widget(menu_1.MenuItem, {
                                    html: {},
                                    wml: {}
                                }, [___wml.node('a', {
                                        html: {
                                            'href': "#",
                                            'onclick': ___context.onClick("You clicked three")
                                        },
                                        wml: {}
                                    }, [___wml.text("Three")], ___view)], ___view)], ___view)], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/layout/grid/Grid":109,"@package/self/menu":128,"@package/self/menu/button-menu":126,"@quenk/wml":162}],11:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/button-select");
var Page_1 = require("../Page");
var ButtonSelectPage = /** @class */ (function (_super) {
    __extends(ButtonSelectPage, _super);
    function ButtonSelectPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            options: [
                { text: 'Asus', value: 'Asus' },
                { text: 'MSI', value: 'MSI' },
                { text: 'Gigabyte', value: 'Gigabyte' }
            ]
        };
        _this.onChange = function (_a) {
            var value = _a.value, name = _a.name;
            _this
                .view
                .findById(name + "-content")
                .map(function (e) {
                while (e.lastChild)
                    e.removeChild(e.lastChild);
                e.appendChild(document.createTextNode(String(value)));
            });
        };
        return _this;
    }
    return ButtonSelectPage;
}(Page_1.Page));
exports.ButtonSelectPage = ButtonSelectPage;

},{"../Page":2,"./wml/button-select":12}],12:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Grid_1 = require("@package/self/layout/grid/Grid");
;
var button_select_1 = require("@package/self/control/button-select");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Grid_1.Grid, {
                html: {},
                wml: {}
            }, [___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.text("You selected: "), ___wml.node('b', {
                                html: {},
                                wml: {
                                    'id': "select-content"
                                }
                            }, [___wml.text("(None)")], ___view), ___wml.text(".")], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(button_select_1.ButtonSelect, {
                                html: {},
                                wml: {
                                    'id': "select"
                                },
                                ww: {
                                    'name': "select",
                                    'variant': "-primary",
                                    'options': ___context.values.options,
                                    'onChange': ___context.onChange
                                }
                            }, [], ___view)], ___view)], ___view)], ___view), ___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.text("You can also use MultiButtonSelect instead: "), ___wml.node('b', {
                                html: {},
                                wml: {
                                    'id': "multi-content"
                                }
                            }, [___wml.text("(None)")], ___view), ___wml.text(".")], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(button_select_1.MultiButtonSelect, {
                                html: {},
                                wml: {
                                    'id': "multi"
                                },
                                ww: {
                                    'name': "multi",
                                    'variant': "-primary",
                                    'options': ___context.values.options,
                                    'onChange': ___context.onChange
                                }
                            }, [], ___view)], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/control/button-select":63,"@package/self/layout/grid/Grid":109,"@quenk/wml":162}],13:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/checkbox");
var Page_1 = require("../Page");
var CheckboxPage = /** @class */ (function (_super) {
    __extends(CheckboxPage, _super);
    function CheckboxPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.value = true;
        _this.onChange = function (_a) {
            var value = _a.value;
            _this.view.findById('content')
                .map(function (e) {
                while (e.firstChild)
                    e.removeChild(e.firstChild);
                e.appendChild(document.createTextNode(value === true ?
                    'on' :
                    (value === false ? 'off' : 'error')));
            });
        };
        return _this;
    }
    return CheckboxPage;
}(Page_1.Page));
exports.CheckboxPage = CheckboxPage;

},{"../Page":2,"./wml/checkbox":14}],14:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Grid_1 = require("@package/self/layout/grid/Grid");
;
var Checkbox_1 = require("@package/self/control/checkbox/Checkbox");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Grid_1.Grid, {
                html: {},
                wml: {}
            }, [___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.text("The checkbox is "), ___wml.node('b', {
                                html: {},
                                wml: {
                                    'id': "content"
                                }
                            }, [___wml.text("untouched")], ___view), ___wml.text(".")], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(Checkbox_1.Checkbox, {
                                html: {},
                                wml: {},
                                ww: {
                                    'name': "checkbox",
                                    'onChange': ___context.onChange
                                }
                            }, [], ___view)], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/control/checkbox/Checkbox":67,"@package/self/layout/grid/Grid":109,"@quenk/wml":162}],15:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/date");
var Page_1 = require("../Page");
var DatePage = /** @class */ (function (_super) {
    __extends(DatePage, _super);
    function DatePage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.onChange = function (_a) {
            var value = _a.value;
            _this
                .view
                .findById('selected')
                .map(function (e) {
                while (e.lastChild)
                    e.removeChild(e.lastChild);
                e.appendChild(document.createTextNode(value));
            });
        };
        return _this;
    }
    return DatePage;
}(Page_1.Page));
exports.DatePage = DatePage;

},{"../Page":2,"./wml/date":16}],16:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Grid_1 = require("@package/self/layout/grid/Grid");
;
var Date_1 = require("@package/self/control/date/Date");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Grid_1.Grid, {
                html: {},
                wml: {}
            }, [___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.text("The date is : "), ___wml.node('b', {
                                html: {},
                                wml: {
                                    'id': "selected"
                                }
                            }, [___wml.text("(None selected)")], ___view), ___wml.text(".")], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(Date_1.Date, {
                                html: {},
                                wml: {
                                    'id': "date"
                                },
                                ww: {
                                    'name': "date",
                                    'onChange': ___context.onChange
                                }
                            }, [], ___view)], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/control/date/Date":70,"@package/self/layout/grid/Grid":109,"@quenk/wml":162}],17:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Page_1 = require("../Page");
var home_1 = require("./wml/home");
var HomePage = /** @class */ (function (_super) {
    __extends(HomePage, _super);
    function HomePage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new home_1.Main(_this);
        return _this;
    }
    return HomePage;
}(Page_1.Page));
exports.HomePage = HomePage;

},{"../Page":2,"./wml/home":18}],18:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('b', {
                html: {},
                wml: {}
            }, [___wml.text("Index")], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":162}],19:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Page_1 = require("../Page");
var list_group_1 = require("./wml/list-group");
var ListGroupPage = /** @class */ (function (_super) {
    __extends(ListGroupPage, _super);
    function ListGroupPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new list_group_1.Main(_this);
        return _this;
    }
    return ListGroupPage;
}(Page_1.Page));
exports.ListGroupPage = ListGroupPage;

},{"../Page":2,"./wml/list-group":20}],20:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Grid_1 = require("@package/self/layout/grid/Grid");
;
var list_group_1 = require("@package/self/layout/list-group");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Grid_1.Grid, {
                html: {},
                wml: {}
            }, [___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.widget(list_group_1.ListGroup, {
                            html: {},
                            wml: {}
                        }, [___wml.widget(list_group_1.ListGroupItem, {
                                html: {},
                                wml: {}
                            }, [___wml.node('p', {
                                    html: {},
                                    wml: {}
                                }, [___wml.text("This is the first item.")], ___view)], ___view), ___wml.widget(list_group_1.ListGroupItem, {
                                html: {},
                                wml: {}
                            }, [___wml.node('b', {
                                    html: {},
                                    wml: {}
                                }, [___wml.text("This is the second item.")], ___view)], ___view), ___wml.widget(list_group_1.ListGroupItem, {
                                html: {},
                                wml: {}
                            }, [___wml.node('h3', {
                                    html: {},
                                    wml: {}
                                }, [___wml.text("Whoa!")], ___view), ___wml.node('p', {
                                    html: {},
                                    wml: {}
                                }, [___wml.text("This is a third item!")], ___view)], ___view)], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/layout/grid/Grid":109,"@package/self/layout/list-group":113,"@quenk/wml":162}],21:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Page_1 = require("../Page");
var menu_1 = require("./wml/menu");
var MenuPage = /** @class */ (function (_super) {
    __extends(MenuPage, _super);
    function MenuPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new menu_1.Main(_this);
        return _this;
    }
    return MenuPage;
}(Page_1.Page));
exports.MenuPage = MenuPage;

},{"../Page":2,"./wml/menu":22}],22:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Grid_1 = require("@package/self/layout/grid/Grid");
;
var menu_1 = require("@package/self/menu");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Grid_1.Grid, {
                html: {},
                wml: {}
            }, [___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.widget(menu_1.Menu, {
                            html: {},
                            wml: {}
                        }, [___wml.widget(menu_1.Header, {
                                html: {},
                                wml: {},
                                ww: {
                                    'text': "Heading"
                                }
                            }, [], ___view), ___wml.widget(menu_1.MenuItem, {
                                html: {},
                                wml: {},
                                ww: {
                                    'disabled': true,
                                    'text': "Back"
                                }
                            }, [], ___view), ___wml.widget(menu_1.MenuItem, {
                                html: {},
                                wml: {},
                                ww: {
                                    'text': "Refresh"
                                }
                            }, [], ___view), ___wml.widget(menu_1.Divider, {
                                html: {},
                                wml: {}
                            }, [], ___view), ___wml.widget(menu_1.MenuItem, {
                                html: {},
                                wml: {}
                            }, [___wml.node('a', {
                                    html: {
                                        'href': "#/menu"
                                    },
                                    wml: {}
                                }, [___wml.text("Quit")], ___view)], ___view)], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/layout/grid/Grid":109,"@package/self/menu":128,"@quenk/wml":162}],23:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Page_1 = require("../Page");
var panel_1 = require("./wml/panel");
var PanelPage = /** @class */ (function (_super) {
    __extends(PanelPage, _super);
    function PanelPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new panel_1.Main(_this);
        return _this;
    }
    return PanelPage;
}(Page_1.Page));
exports.PanelPage = PanelPage;

},{"../Page":2,"./wml/panel":24}],24:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Grid_1 = require("@package/self/layout/grid/Grid");
;
var Panel_1 = require("@package/self/layout/panel/Panel");
;
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Grid_1.Grid, {
                html: {},
                wml: {}
            }, [___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {},
                        ww: {
                            'size': 4
                        }
                    }, [___wml.widget(Panel_1.Panel, {
                            html: {},
                            wml: {}
                        }, [___wml.widget(Panel_1.Body, {
                                html: {},
                                wml: {}
                            }, [___wml.text("Body only.")], ___view)], ___view)], ___view), ___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {},
                        ww: {
                            'size': 4
                        }
                    }, [___wml.widget(Panel_1.Panel, {
                            html: {},
                            wml: {}
                        }, [___wml.widget(Panel_1.Header, {
                                html: {},
                                wml: {}
                            }, [___wml.text("With Header")], ___view), ___wml.widget(Panel_1.Body, {
                                html: {},
                                wml: {}
                            }, [___wml.text("Lorem impsum dilium net set.")], ___view)], ___view)], ___view), ___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {},
                        ww: {
                            'size': 4
                        }
                    }, [___wml.widget(Panel_1.Panel, {
                            html: {},
                            wml: {}
                        }, [___wml.widget(Panel_1.Header, {
                                html: {},
                                wml: {}
                            }, [___wml.text("With Footer")], ___view), ___wml.widget(Panel_1.Body, {
                                html: {},
                                wml: {}
                            }, [___wml.text("Lorem impsum dilium net set.")], ___view), ___wml.widget(Panel_1.Footer, {
                                html: {},
                                wml: {}
                            }, [___wml.text("Meh foot.")], ___view)], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/layout/grid/Grid":109,"@package/self/layout/panel/Panel":118,"@quenk/wml":162}],25:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/search-stack");
var Page_1 = require("../Page");
var options = [
    { label: 'Asus', value: 'Asus' },
    { label: 'MSI', value: 'MSI' },
    { label: 'Gigabyte', value: 'Gigabyte' },
    { label: 'Gigas', value: 'Gigas' },
    { label: 'AsusTek', value: 'AsusTek' },
    { label: 'Asusuga', value: 'Asusuga' },
    { label: 'Qualcomm', value: 'Qualcomm' },
    { label: 'Qualitative', value: 'Qualitatve' },
    { label: 'Asunder', value: 'Asunder' }
];
var SearchStackPage = /** @class */ (function (_super) {
    __extends(SearchStackPage, _super);
    function SearchStackPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            id: 'search',
            name: 'search',
            text: function () { return _this.values.selected.map(function (m) { return m.label; }).join(','); },
            selected: [],
            options: options
        };
        _this.onSearch = function (_a) {
            var value = _a.value;
            _this.view.findById(_this.values.id).map(function (s) {
                return s.update(options.filter(function (s) { return s.value.toLowerCase().startsWith(value.toLowerCase()); }));
            });
        };
        _this.onChange = function (_a) {
            var value = _a.value;
            _this.values.selected = value;
            _this.view.invalidate();
        };
        return _this;
    }
    return SearchStackPage;
}(Page_1.Page));
exports.SearchStackPage = SearchStackPage;

},{"../Page":2,"./wml/search-stack":26}],26:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Grid_1 = require("@package/self/layout/grid/Grid");
;
var SearchStack_1 = require("@package/self/control/search-stack/SearchStack");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Grid_1.Grid, {
                html: {},
                wml: {}
            }, [___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {},
                        ww: {
                            'size': 6
                        }
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.text("You selected: "), ___wml.node('b', {
                                html: {},
                                wml: {
                                    'id': "text"
                                }
                            }, [___wml.domify(___context.values.text())], ___view), ___wml.text(".")], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(SearchStack_1.SearchStack, {
                                html: {},
                                wml: {
                                    'id': ___context.values.id
                                },
                                ww: {
                                    'name': ___context.values.name,
                                    'value': ___context.values.selected,
                                    'decorator': function (r) { return r.label; },
                                    'onChange': ___context.onChange,
                                    'onSearch': ___context.onSearch
                                }
                            }, [], ___view)], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/control/search-stack/SearchStack":81,"@package/self/layout/grid/Grid":109,"@quenk/wml":162}],27:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/select");
var Page_1 = require("../Page");
var SelectPage = /** @class */ (function (_super) {
    __extends(SelectPage, _super);
    function SelectPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            options: [
                { label: 'Asus', value: 'Asus' },
                { label: 'MSI', value: 'MSI' },
                { label: 'Gigabyte', value: 'Gigabyte' }
            ]
        };
        _this.onChange = function (_a) {
            var value = _a.value;
            _this
                .view
                .findById('selected')
                .map(function (e) {
                while (e.lastChild)
                    e.removeChild(e.lastChild);
                e.appendChild(document.createTextNode(value));
            });
        };
        return _this;
    }
    return SelectPage;
}(Page_1.Page));
exports.SelectPage = SelectPage;

},{"../Page":2,"./wml/select":28}],28:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Grid_1 = require("@package/self/layout/grid/Grid");
;
var Select_1 = require("@package/self/control/select/Select");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Grid_1.Grid, {
                html: {},
                wml: {}
            }, [___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.text("You selected: "), ___wml.node('b', {
                                html: {},
                                wml: {
                                    'id': "selected"
                                }
                            }, [___wml.text("(None)")], ___view), ___wml.text(".")], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(Select_1.Select, {
                                html: {},
                                wml: {
                                    'id': "select"
                                },
                                ww: {
                                    'name': "select",
                                    'options': ___context.values.options,
                                    'onChange': ___context.onChange
                                }
                            }, [], ___view)], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/control/select/Select":83,"@package/self/layout/grid/Grid":109,"@quenk/wml":162}],29:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/stack");
var Page_1 = require("../Page");
var _getValues = function () { return [
    { label: 'Asus', value: 'Asus' },
    { label: 'MSI', value: 'MSI' },
    { label: 'MSI', value: 'MSI' },
    { label: 'Gigabyte', value: 'Gigabyte' }
]; };
var _getText = function (m) { return m.map(function (_a) {
    var label = _a.label;
    return label;
}).join(','); };
var StackPage = /** @class */ (function (_super) {
    __extends(StackPage, _super);
    function StackPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            values: _getValues(),
            text: _getText(_getValues()),
            decorator: function (m) { return m.label; }
        };
        _this.onChange = function (_a) {
            var value = _a.value;
            if (value.length === 0)
                _this.values.values = _getValues();
            _this.values.text = _getText(_this.values.values);
            _this.view.invalidate();
        };
        return _this;
    }
    return StackPage;
}(Page_1.Page));
exports.StackPage = StackPage;

},{"../Page":2,"./wml/stack":30}],30:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Grid_1 = require("@package/self/layout/grid/Grid");
;
var stack_1 = require("@package/self/control/stack");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Grid_1.Grid, {
                html: {},
                wml: {}
            }, [___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {},
                        ww: {
                            'size': 4
                        }
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.text("Members: "), ___wml.node('b', {
                                html: {},
                                wml: {
                                    'id': "selected"
                                }
                            }, [___wml.domify(___context.values.text)], ___view), ___wml.text(".")], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(stack_1.Stack, {
                                html: {},
                                wml: {},
                                ww: {
                                    'name': "stack",
                                    'value': ___context.values.values,
                                    'decorator': ___context.values.decorator,
                                    'onChange': ___context.onChange
                                }
                            }, [], ___view)], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/control/stack":89,"@package/self/layout/grid/Grid":109,"@quenk/wml":162}],31:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/switch");
var Page_1 = require("../Page");
var SwitchPage = /** @class */ (function (_super) {
    __extends(SwitchPage, _super);
    function SwitchPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.value = true;
        _this.onChange = function (_a) {
            var value = _a.value;
            _this.view.findById('content')
                .map(function (e) {
                while (e.firstChild)
                    e.removeChild(e.firstChild);
                e.appendChild(document.createTextNode(value === true ?
                    'on' :
                    (value === false ? 'off' : 'error')));
            });
        };
        return _this;
    }
    return SwitchPage;
}(Page_1.Page));
exports.SwitchPage = SwitchPage;

},{"../Page":2,"./wml/switch":32}],32:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Grid_1 = require("@package/self/layout/grid/Grid");
;
var Switch_1 = require("@package/self/control/switch/Switch");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Grid_1.Grid, {
                html: {},
                wml: {}
            }, [___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.text("The switch is "), ___wml.node('b', {
                                html: {},
                                wml: {
                                    'id': "content"
                                }
                            }, [___wml.text("untouched")], ___view), ___wml.text(".")], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(Switch_1.Switch, {
                                html: {},
                                wml: {},
                                ww: {
                                    'name': "switch",
                                    'onChange': ___context.onChange
                                }
                            }, [], ___view)], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/control/switch/Switch":91,"@package/self/layout/grid/Grid":109,"@quenk/wml":162}],33:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.users = [
    {
        "_id": "59f1334ccc21ff728cf7f3ce",
        "index": 0,
        "guid": "fd94cd52-e7f1-44ab-a74f-05604eee46dd",
        "isActive": false,
        "balance": "$2,849.93",
        "picture": "http://placehold.it/32x32",
        "age": 34,
        "eyeColor": "green",
        "name": "Johns Lewis",
        "gender": "male",
        "company": "PROFLEX",
        "email": "johnslewis@proflex.com",
        "phone": "+1 (925) 409-3400",
        "address": "874 Grove Street, Edgewater, Georgia, 8112",
        "about": "Ex esse dolore et sint sint proident nostrud ut officia. Do nulla mollit dolore ut aute excepteur deserunt laboris ut proident. Ullamco est deserunt ex commodo veniam duis elit excepteur velit ullamco deserunt culpa do est.\r\n",
        "registered": "2015-02-22T10:25:32 +04:00",
        "latitude": 56.278862,
        "longitude": -79.459101,
        "tags": [
            "labore",
            "proident",
            "aliqua",
            "amet",
            "amet",
            "officia",
            "enim"
        ],
        "friends": [
            {
                "id": 0,
                "name": "Mason Noble"
            },
            {
                "id": 1,
                "name": "Coffey Mendez"
            },
            {
                "id": 2,
                "name": "Dionne Cole"
            }
        ],
        "greeting": "Hello, Johns Lewis! You have 5 unread messages.",
        "favoriteFruit": "banana"
    },
    {
        "_id": "59f1334c09dc1bcdc5732491",
        "index": 1,
        "guid": "33255995-0431-4271-9876-37eabc117a7b",
        "isActive": false,
        "balance": "$2,167.40",
        "picture": "http://placehold.it/32x32",
        "age": 23,
        "eyeColor": "blue",
        "name": "Williamson Gregory",
        "gender": "male",
        "company": "NETAGY",
        "email": "williamsongregory@netagy.com",
        "phone": "+1 (910) 462-3918",
        "address": "158 Sedgwick Street, Glasgow, Utah, 5498",
        "about": "Excepteur sit nisi et velit. Laboris minim id duis ad qui cupidatat. Est Lorem quis duis Lorem laboris velit laboris non excepteur et velit voluptate qui. Dolore qui anim exercitation veniam incididunt laboris labore. Id minim labore amet sunt excepteur tempor proident.\r\n",
        "registered": "2016-04-25T04:25:24 +04:00",
        "latitude": 54.457833,
        "longitude": 122.803765,
        "tags": [
            "tempor",
            "exercitation",
            "et",
            "elit",
            "ex",
            "cillum",
            "laboris"
        ],
        "friends": [
            {
                "id": 0,
                "name": "Navarro Reeves"
            },
            {
                "id": 1,
                "name": "Stanton Vincent"
            },
            {
                "id": 2,
                "name": "Alexis Guzman"
            }
        ],
        "greeting": "Hello, Williamson Gregory! You have 1 unread messages.",
        "favoriteFruit": "apple"
    },
    {
        "_id": "59f1334c9d799789bc494a3c",
        "index": 2,
        "guid": "158ffa5d-15da-4a9f-a1da-0a48b76b8226",
        "isActive": false,
        "balance": "$1,289.35",
        "picture": "http://placehold.it/32x32",
        "age": 33,
        "eyeColor": "green",
        "name": "Dalton House",
        "gender": "male",
        "company": "EYEWAX",
        "email": "daltonhouse@eyewax.com",
        "phone": "+1 (959) 550-2263",
        "address": "116 Howard Avenue, Rossmore, New York, 6302",
        "about": "Elit eu ipsum pariatur duis mollit ex quis. Amet nulla exercitation laboris minim fugiat tempor in aliqua nisi nostrud aute. Duis minim esse irure irure fugiat sit nulla et tempor nisi cillum proident id adipisicing. Eu elit magna Lorem irure labore. Aliquip id sint veniam adipisicing. Amet eiusmod mollit reprehenderit reprehenderit dolore.\r\n",
        "registered": "2017-02-28T08:53:00 +04:00",
        "latitude": -25.679774,
        "longitude": 29.374781,
        "tags": [
            "qui",
            "cillum",
            "anim",
            "irure",
            "non",
            "commodo",
            "deserunt"
        ],
        "friends": [
            {
                "id": 0,
                "name": "Carmela Wilcox"
            },
            {
                "id": 1,
                "name": "Elba Garza"
            },
            {
                "id": 2,
                "name": "Garrison Church"
            }
        ],
        "greeting": "Hello, Dalton House! You have 1 unread messages.",
        "favoriteFruit": "apple"
    },
    {
        "_id": "59f1334cd1518c3a44d69fff",
        "index": 3,
        "guid": "5109bc50-9a8e-4184-aba0-6740dc00b606",
        "isActive": true,
        "balance": "$3,891.83",
        "picture": "http://placehold.it/32x32",
        "age": 22,
        "eyeColor": "blue",
        "name": "Ray Wilkins",
        "gender": "male",
        "company": "EXPOSA",
        "email": "raywilkins@exposa.com",
        "phone": "+1 (812) 414-3258",
        "address": "837 Bedford Avenue, Harleigh, South Carolina, 2323",
        "about": "Est amet quis eu proident ipsum veniam sit. Irure labore ad consectetur ullamco sit ipsum proident. Ad pariatur irure nisi irure commodo aliquip nisi eu anim irure dolor dolor veniam quis.\r\n",
        "registered": "2015-09-17T04:52:42 +04:00",
        "latitude": 34.354801,
        "longitude": -168.303952,
        "tags": [
            "nisi",
            "laboris",
            "incididunt",
            "amet",
            "aute",
            "quis",
            "mollit"
        ],
        "friends": [
            {
                "id": 0,
                "name": "Olivia Russo"
            },
            {
                "id": 1,
                "name": "Rita Tyler"
            },
            {
                "id": 2,
                "name": "Lorie Walker"
            }
        ],
        "greeting": "Hello, Ray Wilkins! You have 1 unread messages.",
        "favoriteFruit": "strawberry"
    },
    {
        "_id": "59f1334c6901bda003e52fa6",
        "index": 4,
        "guid": "0ab33477-b152-4b12-af35-f5b9254d5c2a",
        "isActive": true,
        "balance": "$3,730.71",
        "picture": "http://placehold.it/32x32",
        "age": 27,
        "eyeColor": "brown",
        "name": "Madden Hatfield",
        "gender": "male",
        "company": "ZOGAK",
        "email": "maddenhatfield@zogak.com",
        "phone": "+1 (832) 552-2294",
        "address": "530 Clermont Avenue, Bethpage, Virgin Islands, 5607",
        "about": "Commodo tempor anim tempor deserunt laboris qui eu reprehenderit consequat. Non laborum ullamco qui proident. Est cupidatat do dolor excepteur est nostrud laborum. Eu excepteur ex commodo aliquip adipisicing excepteur. Et reprehenderit laboris reprehenderit aute ut excepteur deserunt nostrud velit. Ullamco est sit fugiat irure aliqua aliquip proident. Voluptate ad culpa dolor id enim tempor laborum.\r\n",
        "registered": "2016-04-10T03:37:17 +04:00",
        "latitude": 80.888876,
        "longitude": 117.84337,
        "tags": [
            "occaecat",
            "nisi",
            "est",
            "ad",
            "nostrud",
            "eu",
            "dolore"
        ],
        "friends": [
            {
                "id": 0,
                "name": "Vincent Gay"
            },
            {
                "id": 1,
                "name": "Rosario Forbes"
            },
            {
                "id": 2,
                "name": "Baxter Green"
            }
        ],
        "greeting": "Hello, Madden Hatfield! You have 4 unread messages.",
        "favoriteFruit": "banana"
    }
];

},{}],34:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Page_1 = require("../Page");
var table_1 = require("./wml/table");
var data_1 = require("./data");
var fields = [
    { name: 'index', heading: '#' },
    { name: 'name', heading: 'Name' },
    { name: 'balance', heading: 'Balance' }
];
var TablePage = /** @class */ (function (_super) {
    __extends(TablePage, _super);
    function TablePage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new table_1.Main(_this);
        _this.values = {
            users: data_1.users,
            fields: fields
        };
        return _this;
    }
    return TablePage;
}(Page_1.Page));
exports.TablePage = TablePage;

},{"../Page":2,"./data":33,"./wml/table":35}],35:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Grid_1 = require("@package/self/layout/grid/Grid");
;
var Table_1 = require("@package/self/table/table/Table");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Grid_1.Grid, {
                html: {},
                wml: {}
            }, [___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.widget(Table_1.Table, {
                            html: {},
                            wml: {},
                            ww: {
                                'selectable': true,
                                'data': ___context.values.users,
                                'fields': ___context.values.fields
                            }
                        }, [], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/layout/grid/Grid":109,"@package/self/table/table/Table":156,"@quenk/wml":162}],36:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/tabs");
var Page_1 = require("../Page");
var TabsPage = /** @class */ (function (_super) {
    __extends(TabsPage, _super);
    function TabsPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.tab = 'First';
        _this.content = 'First Tab';
        _this.clicked = function (_a) {
            var name = _a.name;
            _this.tab = name;
            _this.content = name + " Tab";
            _this.view.invalidate();
        };
        return _this;
    }
    return TabsPage;
}(Page_1.Page));
exports.TabsPage = TabsPage;

},{"../Page":2,"./wml/tabs":37}],37:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Grid_1 = require("@package/self/layout/grid/Grid");
;
var Tabs_1 = require("@package/self/control/tabs/Tabs");
;
var Tab_1 = require("@package/self/control/tabs/Tab");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Grid_1.Grid, {
                html: {},
                wml: {}
            }, [___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.widget(Tabs_1.Tabs, {
                            html: {},
                            wml: {}
                        }, [___wml.widget(Tab_1.Tab, {
                                html: {},
                                wml: {},
                                ww: {
                                    'active': (___context.tab === "First"),
                                    'text': "First",
                                    'name': "First",
                                    'onClick': ___context.clicked
                                }
                            }, [], ___view), ___wml.widget(Tab_1.Tab, {
                                html: {},
                                wml: {},
                                ww: {
                                    'active': (___context.tab === "Second"),
                                    'text': "Second",
                                    'name': "Second",
                                    'onClick': ___context.clicked
                                }
                            }, [], ___view), ___wml.widget(Tab_1.Tab, {
                                html: {},
                                wml: {},
                                ww: {
                                    'active': (___context.tab === "Third"),
                                    'text': "Third",
                                    'name': "Third",
                                    'onClick': ___context.clicked
                                }
                            }, [], ___view)], ___view), ___wml.node('p', {
                            html: {},
                            wml: {
                                'id': "content"
                            }
                        }, [___wml.domify(___context.content)], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/control/tabs/Tab":94,"@package/self/control/tabs/Tabs":96,"@package/self/layout/grid/Grid":109,"@quenk/wml":162}],38:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/text-field");
var Page_1 = require("../Page");
var TextFieldPage = /** @class */ (function (_super) {
    __extends(TextFieldPage, _super);
    function TextFieldPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.id = 'text';
        _this.view = new views.Main(_this);
        _this.onChange = function (_a) {
            var value = _a.value;
            (value === 'invalid') ?
                _this.get(_this.id, function (c) {
                    return c.setError('This control is now invalid!');
                }) :
                (value === 'valid') ?
                    _this.get(_this.id, function (c) {
                        return c.setSuccess('This control is now valid!');
                    }) :
                    (value === 'warn') ?
                        _this.get(_this.id, function (c) {
                            return c.setWarning('This control now has a warning!');
                        }) :
                        (value === 'reset') ?
                            _this.get(_this.id, function (c) {
                                return c.reset();
                            }) :
                            _this
                                .view
                                .findById('content')
                                .map(function (e) {
                                while (e.lastChild)
                                    e.removeChild(e.lastChild);
                                e.appendChild(document.createTextNode(value));
                            });
        };
        return _this;
    }
    return TextFieldPage;
}(Page_1.Page));
exports.TextFieldPage = TextFieldPage;

},{"../Page":2,"./wml/text-field":39}],39:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Grid_1 = require("@package/self/layout/grid/Grid");
;
var TextField_1 = require("@package/self/control/text-field/TextField");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Grid_1.Grid, {
                html: {},
                wml: {}
            }, [___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.text("The value of the input is:")], ___view), ___wml.node('p', {
                            html: {},
                            wml: {
                                'id': "content"
                            }
                        }, [___wml.domify("(Nothing)")], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(TextField_1.TextField, {
                                html: {},
                                wml: {
                                    'id': "text"
                                },
                                ww: {
                                    'name': "text",
                                    'onChange': ___context.onChange
                                }
                            }, [], ___view)], ___view)], ___view)], ___view), ___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.node('strong', {
                                html: {},
                                wml: {}
                            }, [___wml.text("Success")], ___view)], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(TextField_1.TextField, {
                                html: {},
                                wml: {},
                                ww: {
                                    'name': "text",
                                    'success': "This textfield has a success",
                                    'onChange': ___context.onChange
                                }
                            }, [], ___view)], ___view)], ___view)], ___view), ___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.node('strong', {
                                html: {},
                                wml: {}
                            }, [___wml.text("Warning")], ___view)], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(TextField_1.TextField, {
                                html: {},
                                wml: {},
                                ww: {
                                    'name': "text",
                                    'warning': "This textfield has a warning.",
                                    'onChange': ___context.onChange
                                }
                            }, [], ___view)], ___view)], ___view)], ___view), ___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.node('strong', {
                                html: {},
                                wml: {}
                            }, [___wml.text("Error")], ___view)], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(TextField_1.TextField, {
                                html: {},
                                wml: {},
                                ww: {
                                    'name': "text",
                                    'error': "This textfield has an error.",
                                    'onChange': ___context.onChange
                                }
                            }, [], ___view)], ___view)], ___view)], ___view), ___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.text("The one uses rows to render a text area:")], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(TextField_1.TextField, {
                                html: {},
                                wml: {},
                                ww: {
                                    'name': "text",
                                    'rows': 3,
                                    'onChange': ___context.onChange
                                }
                            }, [], ___view)], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/control/text-field/TextField":99,"@package/self/layout/grid/Grid":109,"@quenk/wml":162}],40:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Drawer_1 = require("@package/self/layout/drawer/Drawer");
;
var ActionBar_1 = require("@package/self/app/action-bar/ActionBar");
;
;
var IconButton_1 = require("@package/self/control/icon-button/IconButton");
;
var dash_1 = require("@package/self/app/dash");
;
var Main_1 = require("@package/self/layout/main/Main");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Drawer_1.Drawer, {
                html: {},
                wml: {
                    'id': ___context.values.id.layout
                },
                ww: {
                    'drawer': ___context.navigation
                }
            }, [___wml.widget(ActionBar_1.ActionBar, {
                    html: {},
                    wml: {}
                }, [___wml.widget(IconButton_1.IconButton, {
                        html: {},
                        wml: {},
                        ww: {
                            'onClick': ___context.toggleDrawer
                        }
                    }, [___wml.widget(dash_1.Dash, {
                            html: {},
                            wml: {}
                        }, [], ___view), ___wml.widget(dash_1.Dash, {
                            html: {},
                            wml: {}
                        }, [], ___view), ___wml.widget(dash_1.Dash, {
                            html: {},
                            wml: {}
                        }, [], ___view)], ___view)], ___view), ___wml.widget(Main_1.Main, {
                    html: {},
                    wml: {}
                }, [___wml.domify(___context.content.render())], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/app/action-bar/ActionBar":42,"@package/self/app/dash":47,"@package/self/control/icon-button/IconButton":73,"@package/self/layout/drawer/Drawer":105,"@package/self/layout/main/Main":116,"@quenk/wml":162}],41:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
;
var menu_1 = require("@package/self/nav/menu");
var Navigation = /** @class */ (function (_super) {
    __extends(Navigation, _super);
    function Navigation(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(menu_1.Menu, {
                html: {},
                wml: {}
            }, [___wml.widget(menu_1.Link, {
                    html: {},
                    wml: {
                        'group': "links"
                    },
                    ww: {
                        'active': (___context.page === "home"),
                        'name': "home",
                        'href': "#",
                        'onClick': ___context.navigate,
                        'text': "Home"
                    }
                }, [], ___view), ___wml.widget(menu_1.Header, {
                    html: {},
                    wml: {},
                    ww: {
                        'text': "Layout"
                    }
                }, [], ___view), ___wml.widget(menu_1.SubMenu, {
                    html: {},
                    wml: {}
                }, [___wml.widget(menu_1.Link, {
                        html: {},
                        wml: {
                            'group': "links"
                        },
                        ww: {
                            'name': "panel",
                            'href': "#/panel",
                            'onClick': ___context.navigate,
                            'active': (___context.page === "panel"),
                            'text': "Panels"
                        }
                    }, [], ___view), ___wml.widget(menu_1.Link, {
                        html: {},
                        wml: {
                            'group': "links"
                        },
                        ww: {
                            'name': "list-group",
                            'href': "#/list-group",
                            'onClick': ___context.navigate,
                            'active': (___context.page === "list-group"),
                            'text': "List Group"
                        }
                    }, [], ___view)], ___view), ___wml.widget(menu_1.Header, {
                    html: {},
                    wml: {},
                    ww: {
                        'text': "Table"
                    }
                }, [], ___view), ___wml.widget(menu_1.SubMenu, {
                    html: {},
                    wml: {}
                }, [___wml.widget(menu_1.Link, {
                        html: {},
                        wml: {
                            'group': "links"
                        },
                        ww: {
                            'name': "table",
                            'href': "#/table",
                            'onClick': ___context.navigate,
                            'active': (___context.page === "table"),
                            'text': "Table"
                        }
                    }, [], ___view)], ___view), ___wml.widget(menu_1.Header, {
                    html: {},
                    wml: {},
                    ww: {
                        'text': "Control"
                    }
                }, [], ___view), ___wml.widget(menu_1.SubMenu, {
                    html: {},
                    wml: {}
                }, [___wml.widget(menu_1.Link, {
                        html: {},
                        wml: {
                            'group': "links"
                        },
                        ww: {
                            'name': "text-field",
                            'href': "#/text-field",
                            'onClick': ___context.navigate,
                            'active': (___context.page === "text-field"),
                            'text': "Text Field"
                        }
                    }, [], ___view), ___wml.widget(menu_1.Link, {
                        html: {},
                        wml: {
                            'group': "links"
                        },
                        ww: {
                            'name': "date",
                            'href': "#/date",
                            'onClick': ___context.navigate,
                            'active': (___context.page === "date"),
                            'text': "Date"
                        }
                    }, [], ___view), ___wml.widget(menu_1.Link, {
                        html: {},
                        wml: {
                            'group': "links"
                        },
                        ww: {
                            'name': "select",
                            'href': "#/select",
                            'onClick': ___context.navigate,
                            'active': (___context.page === "select"),
                            'text': "Select"
                        }
                    }, [], ___view), ___wml.widget(menu_1.Link, {
                        html: {},
                        wml: {
                            'group': "links"
                        },
                        ww: {
                            'name': "autocomplete",
                            'href': "#/autocomplete",
                            'onClick': ___context.navigate,
                            'active': (___context.page === "autocomplete"),
                            'text': "Autocomplete"
                        }
                    }, [], ___view), ___wml.widget(menu_1.Link, {
                        html: {},
                        wml: {
                            'group': "links"
                        },
                        ww: {
                            'name': "button-select",
                            'href': "#/button-select",
                            'onClick': ___context.navigate,
                            'active': (___context.page === "button-select"),
                            'text': "Button Select"
                        }
                    }, [], ___view), ___wml.widget(menu_1.Link, {
                        html: {},
                        wml: {
                            'group': "links"
                        },
                        ww: {
                            'name': "checkbox",
                            'href': "#/checkbox",
                            'onClick': ___context.navigate,
                            'active': (___context.page === "checkbox"),
                            'text': "Checkbox"
                        }
                    }, [], ___view), ___wml.widget(menu_1.Link, {
                        html: {},
                        wml: {
                            'group': "links"
                        },
                        ww: {
                            'name': "switch",
                            'href': "#/switch",
                            'onClick': ___context.navigate,
                            'active': (___context.page === "switch"),
                            'text': "Switch"
                        }
                    }, [], ___view), ___wml.widget(menu_1.Link, {
                        html: {},
                        wml: {
                            'group': "links"
                        },
                        ww: {
                            'name': "tabs",
                            'href': "#/tabs",
                            'onClick': ___context.navigate,
                            'active': (___context.page === "tabs"),
                            'text': "Tabs"
                        }
                    }, [], ___view), ___wml.widget(menu_1.Link, {
                        html: {},
                        wml: {
                            'group': "links"
                        },
                        ww: {
                            'name': "stack",
                            'href': "#/stack",
                            'onClick': ___context.navigate,
                            'active': (___context.page === "stack"),
                            'text': "Stack"
                        }
                    }, [], ___view), ___wml.widget(menu_1.Link, {
                        html: {},
                        wml: {
                            'group': "links"
                        },
                        ww: {
                            'name': "search-stack",
                            'href': "#/search-stack",
                            'onClick': ___context.navigate,
                            'active': (___context.page === "search-stack"),
                            'text': "Search Stack"
                        }
                    }, [], ___view)], ___view), ___wml.widget(menu_1.Header, {
                    html: {},
                    wml: {},
                    ww: {
                        'text': "App"
                    }
                }, [], ___view), ___wml.widget(menu_1.SubMenu, {
                    html: {},
                    wml: {}
                }, [___wml.widget(menu_1.Link, {
                        html: {},
                        wml: {
                            'group': "links"
                        },
                        ww: {
                            'name': "busy-indicator",
                            'href': "#/busy-indicator",
                            'onClick': ___context.navigate,
                            'active': (___context.page === "busy-indicator"),
                            'text': "Busy Indicator"
                        }
                    }, [], ___view)], ___view), ___wml.widget(menu_1.Header, {
                    html: {},
                    wml: {},
                    ww: {
                        'text': "Nav"
                    }
                }, [], ___view), ___wml.widget(menu_1.SubMenu, {
                    html: {},
                    wml: {}
                }, [___wml.widget(menu_1.Link, {
                        html: {},
                        wml: {
                            'group': "links"
                        },
                        ww: {
                            'name': "breadcrumbs",
                            'href': "#/breadcrumbs",
                            'onClick': ___context.navigate,
                            'active': (___context.page === "breadcrumbs"),
                            'text': "BreadCrumbs"
                        }
                    }, [], ___view)], ___view), ___wml.widget(menu_1.Header, {
                    html: {},
                    wml: {},
                    ww: {
                        'text': "Menu"
                    }
                }, [], ___view), ___wml.widget(menu_1.SubMenu, {
                    html: {},
                    wml: {}
                }, [___wml.widget(menu_1.Link, {
                        html: {},
                        wml: {
                            'group': "links"
                        },
                        ww: {
                            'name': "menu",
                            'href': "#/menu",
                            'onClick': ___context.navigate,
                            'active': (___context.page === "menu"),
                            'text': "Menu"
                        }
                    }, [], ___view), ___wml.widget(menu_1.Link, {
                        html: {},
                        wml: {
                            'group': "links"
                        },
                        ww: {
                            'name': "button-menu",
                            'href': "#/button-menu",
                            'onClick': ___context.navigate,
                            'active': (___context.page === "button-menu"),
                            'text': "Button Menu"
                        }
                    }, [], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Navigation;
}(___wml.AppView));
exports.Navigation = Navigation;

},{"@package/self/nav/menu":146,"@quenk/wml":162}],42:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var util = require("@package/self/common/util");
var Group_1 = require("@package/self/content/Group");
var action_bar_1 = require("./wml/action_bar");
/**
 * ActionBar provides a bar across the screen that can be
 * used as a toolbar, navigation menu or something simillar.
 */
var ActionBar = /** @class */ (function (_super) {
    __extends(ActionBar, _super);
    function ActionBar() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new action_bar_1.Main(_this);
        _this.values = {
            id: {
                content: 'content'
            },
            class: {
                root: util.combine([names.ACTION_BAR, names.FIXED_PUSHABLE]),
                content: names.ACTION_BAR_CONTENT
            }
        };
        return _this;
    }
    return ActionBar;
}(Group_1.Group));
exports.ActionBar = ActionBar;

},{"./wml/action_bar":43,"@package/self/common/names":49,"@package/self/common/util":50,"@package/self/content/Group":51}],43:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [___wml.node('div', {
                    html: {
                        'class': ___context.values.class.content
                    },
                    wml: {
                        'id': ___context.values.id.content
                    }
                }, [___wml.domify(___context.children)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":162}],44:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml = require("@quenk/wml");
var busy_indicator_1 = require("./wml/busy_indicator");
var util_1 = require("@package/self/common/util");
/**
 * BusyIndicator provides a 'hamburger' menu button.
 */
var BusyIndicator = /** @class */ (function (_super) {
    __extends(BusyIndicator, _super);
    function BusyIndicator() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new busy_indicator_1.Main(_this);
        _this.values = {
            class: util_1.concat('loading', _this.attrs.ww ? _this.attrs.ww.class : '')
        };
        return _this;
    }
    return BusyIndicator;
}(wml.Component));
exports.BusyIndicator = BusyIndicator;

},{"./wml/busy_indicator":45,"@package/self/common/util":50,"@quenk/wml":162}],45:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.class
                },
                wml: {}
            }, [], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":162}],46:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var wml_1 = require("@quenk/wml");
var dash_1 = require("./wml/dash");
/**
 * Dash are literal horizontal dashes.
 *
 * These can be used with app/menu/Button to create 'hamburger' menus.
 */
var Dash = /** @class */ (function (_super) {
    __extends(Dash, _super);
    function Dash() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new dash_1.Main(_this);
        _this.values = {
            class: {
                root: names.DASH
            }
        };
        return _this;
    }
    return Dash;
}(wml_1.Component));
exports.Dash = Dash;

},{"./wml/dash":48,"@package/self/common/names":49,"@quenk/wml":162}],47:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Dash_1 = require("./Dash");
exports.Dash = Dash_1.Dash;

},{"./Dash":46}],48:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('span', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":162}],49:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * HIDDEN indicates an element should be hidden from sight.
 */
exports.HIDDEN = '-hidden';
/**
 * DISABLED indicates an element should appear to be inaccesible
 */
exports.DISABLED = '-disabled';
/**
 * ON indicates an 'on' state.
 */
exports.ON = '-on';
/**
 * OFF indicates an 'off' state.
 */
exports.OFF = '-off';
/**
 * open indicates an open state in collapsable widgets
 */
exports.OPEN = '-open';
/**
 * PUSHABLE is used by other styles to move an element around.
 */
exports.PUSHABLE = '-pushable';
/**
 * FIXED_PUSHABLE is like PUSHABLE but used for fixed elements.
 */
exports.FIXED_PUSHABLE = '-fixed-pushable';
/**
 * NO_HOVER indicates hover effects should be disabled.
 */
exports.NO_HOVER = '-no-hover';
exports.SPACED = '-spaced';
/**
 * DEFAULT style modifier.
 */
exports.DEFAULT = '-default';
/**
 * PRIMARY style modifier.
 */
exports.PRIMARY = '-primary';
/**
 * SUCCESS style modifier.
 */
exports.SUCCESS = '-success';
/**
 * INFO style modifier.
 */
exports.INFO = '-info';
/**
 * WARNING style modifier.
 */
exports.WARNING = '-warning';
/**
 * DANGER style modifier.
 */
exports.DANGER = '-danger';
exports.LARGE = '-large';
exports.SMALL = '-small';
exports.EXTRA_SMALL = '-extra-small';
exports.ACTIVE = 'active'; //@todo: refactor to flag syntax
exports.DRAWER = 'ww-drawer-layout';
exports.ASIDE = 'ww-drawer';
exports.ASIDE_CONTENT = 'ww-drawer__content';
exports.ASIDE_PUSHABLE = '-drawer-pushable';
exports.ASIDE_PUSHABLE_FIXED = '-drawer-pushable-fixed';
/**
 * ACTION_BAR class name. for the ActionBar root.
 */
exports.ACTION_BAR = 'ww-action-bar';
/**
 * ACTION_BAR_CONTENT class name.
 */
exports.ACTION_BAR_CONTENT = 'ww-action-bar__content';
/**
 * ICON_BUTTON clasess for IconButtons.
 */
exports.ICON_BUTTON = 'ww-icon-button';
/**
 * BUTTON_MENU class name.
 */
exports.BUTTON_MENU = 'ww-button-menu btn-group';
/**
 * BUTTON_MENU_BUTTON class name.
 */
exports.BUTTON_MENU_BUTTON = exports.BUTTON_MENU + "__button";
/**
 * BUTTON_MENU_MENU class name.
 */
exports.BUTTON_MENU_MENU = exports.BUTTON_MENU_BUTTON + "__menu";
/**
 * BUTTON_SELECT
 */
exports.BUTTON_SELECT = 'btn-group';
exports.BUTTON_SELECT_OPTION = exports.BUTTON_SELECT + "__option btn";
exports.MAIN_VIEW = 'ww-main-view';
/**
 * MENU class name.
 */
exports.MENU = 'ww-menu';
/**
 * MENU_ITEM class name.
 */
exports.MENU_ITEM = exports.MENU + "__item";
/**
 * MENU_HEADER class name.
 */
exports.MENU_HEADER = exports.MENU + "__header";
/**
 * MENU_DIVIDER class name.
 */
exports.MENU_DIVIDER = exports.MENU + "__divider";
/**
 * DASH class name.
 */
exports.DASH = 'ww-dash';
/**
 * NAV class name.
 */
exports.NAV = 'ww-nav';
/**
 * NAV_LINK class name.
 */
exports.NAV_LINK = 'ww-nav-link';
/**
 * NAV_MENU class name.
 */
exports.NAV_MENU = 'ww-nav-menu';
/**
 * NAV_MENU_ITEM class name.
 */
exports.NAV_MENU_ITEM = 'ww-nav-menu__item';
/**
 * NAV_MENU_HEADER class name.
 */
exports.NAV_MENU_HEADER = 'ww-nav-menu__header';
/**
 * NAV_MENU_LINK class name.
 */
exports.NAV_MENU_LINK = 'ww-nav-menu__link';
/**
 * NAV_MENU_SUBMENU class name.
 */
exports.NAV_MENU_SUBMENU = 'ww-nav-menu__submenu';
exports.BUTTON = 'ww-button';
exports.BUTTON_GROUP = 'ww-button-group';
//@todo: refactor this to be inline with other class names
exports.GRID = 'container-fluid';
exports.GRID_COLUMN = 'ww-grid-column';
exports.GRID_ROW = 'row';
/**
 * PANEL wrapper class.
 */
exports.PANEL = 'ww-panel';
/**
 * PANEL_HEADER class name.
 */
exports.PANEL_HEADER = 'ww-panel__header';
/**
 * PANEL_BODY class name.
 */
exports.PANEL_BODY = 'ww-panel__body';
/**
 * PANEL_FOOTER class name.
 */
exports.PANEL_FOOTER = 'ww-panel__footer';
/**
 * HEADER class name.
 */
exports.HEADER = 'ww-header';
exports.MODAL = 'ww-modal';
exports.MODAL_DIALOG = 'ww-modal__dialog';
exports.MODAL_CONTENT = 'ww-modal__content';
exports.MODAL_HEADER = 'ww-modal__header';
exports.MODAL_BODY = 'ww-modal__body';
exports.MODAL_FOOTER = 'ww-moadl__footer';
exports.FORM_GROUP = 'form-group';
exports.CONTROL_LABEL = 'control-label';
exports.INPUT = 'form-control';
exports.TEXTAREA = 'form-control';
exports.SELECT = 'form-control';
/**
 * TABS class name.
 */
exports.TABS = 'ww-tabs';
/**
 * TABS_TAB class name.
 */
exports.TABS_TAB = 'ww-tabs__tab';
/**
 * SWITCH class name.
 */
exports.SWITCH = 'ww-switch';
/**
 * SWITCH_SLIDER class name.
 */
exports.SWITCH_SLIDER = 'ww-switch__slider';
/**
 * CHECKBOX class name.
 */
exports.CHECKBOX = 'checkbox';
exports.TABLE = 'table'; //@todo un-bootstrap
/**
 * BREAD_CRUMBS clasess
 */
exports.BREAD_CRUMBS = 'breadcrumb'; //@todo un-bootstrap
/**
 * BREAD_CRUMBS_ITEM class name.
 */
exports.BREAD_CRUMBS_ITEM = exports.BREAD_CRUMBS + "__item";
exports.LIST = 'ww-list';
exports.LIST_ITEM = 'ww-list__item';
/**
 * SEARCH class name.
 */
exports.SEARCH = 'ww-search';
/**
 * SEARCH_INPUT class name.
 */
exports.SEARCH_INPUT = 'ww-search__input';
/**
 * DATE class name.
 */
exports.DATE = 'ww-date';
/**
 * DATE_DAY class name.
 */
exports.DATE_DAY = exports.DATE + "__day";
/**
 * DATE_MONTH class name.
 */
exports.DATE_MONTH = exports.DATE + "_month";
/**
 * DATE_YEAR class name.
 */
exports.DATE_YEAR = exports.DATE + "__year";
/**
 * STACK class name.
 */
exports.STACK = 'ww-stack';
/**
 * STACK_CLOSE class name.
 */
exports.STACK_CLOSE = exports.STACK + "__close";
/**
 * STACK_MEMBER class name.
 */
exports.STACK_MEMBER = exports.STACK + "__member";
/**
 * SEARCH_STACK class name.
 */
exports.SEARCH_STACK = 'ww-search-stack';
/**
 * LIST_GROUP class name.
 */
exports.LIST_GROUP = 'list-group';
/**
 * LIST_GROUP_ITEM class name.
 */
exports.LIST_GROUP_ITEM = 'list-group-item';

},{}],50:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * combine the members of an array into one string.
 */
exports.combine = function (str, joiner) {
    if (joiner === void 0) { joiner = ' '; }
    return str.filter(function (s) { return ((s != null) || s != ''); }).join(joiner);
};
/**
 * concat joins various strings together to form an html class attribute value.
 *
 * Removes empty strings, null and undefined values.
 */
exports.concat = function () {
    var str = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        str[_i] = arguments[_i];
    }
    return str.filter(function (s) { return ((s != null) || s != ''); }).join(' ');
};
/**
 * noop
 */
exports.noop = function () { };
/**
 * replaceContent
 */
exports.replaceContent = function (r, node) {
    while (node.lastChild)
        node.removeChild(node.lastChild);
    node.appendChild(r.render());
};
/**
 * debounce a function so that it is only called once after
 * a period of time.
 */
exports.debounce = function (f, delay) {
    var timer = null;
    return delay === 0 ? f : function (a) {
        if (!timer) {
            timer = window.setTimeout(function () { return f(a); }, delay);
        }
        else {
            clearTimeout(timer);
            timer = window.setTimeout(function () { return f(a); }, delay);
        }
    };
};

},{}],51:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml_1 = require("@quenk/wml");
/**
 * Group is an abstract class providing an api for
 * widgets whose primary purpose is displaying content.
 */
var Group = /** @class */ (function (_super) {
    __extends(Group, _super);
    function Group() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * setContent changes the content value.
     */
    Group.prototype.setContent = function (content) {
        this.content = content;
        this.view.invalidate();
        return this;
    };
    /**
     * removeContent removes existing content.
     */
    Group.prototype.removeContent = function () {
        this.content = null;
        return this;
    };
    return Group;
}(wml_1.Component));
exports.Group = Group;

},{"@quenk/wml":162}],52:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml_1 = require("@quenk/wml");
/**
 * Control
 */
var Control = /** @class */ (function (_super) {
    __extends(Control, _super);
    function Control() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Control;
}(wml_1.Component));
exports.Control = Control;

},{"@quenk/wml":162}],53:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * DefaultDelegate fowards all events to their corresponding
 * function handlers, specifed on the attributes of a control.
 */
var DefaultDelegate = /** @class */ (function () {
    function DefaultDelegate(attrs) {
        var _this = this;
        this.attrs = attrs;
        this.onInput = function (e) {
            return _this.attrs.onInput ? _this.attrs.onInput(e) : null;
        };
        this.onChange = function (e) {
            return _this.attrs.onChange ? _this.attrs.onChange(e) : null;
        };
    }
    return DefaultDelegate;
}());
exports.DefaultDelegate = DefaultDelegate;

},{}],54:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Event is the parent class of all events generated by controls.
 */
var Event = /** @class */ (function () {
    function Event(name, value) {
        this.name = name;
        this.value = value;
    }
    return Event;
}());
exports.Event = Event;

},{}],55:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Control_1 = require("./Control");
var DefaultDelegate_1 = require("./DefaultDelegate");
var INPUT_SUCCESS = 'has-success';
var INPUT_ERROR = 'has-error';
var INPUT_WARNING = 'has-warning';
var FormControl = /** @class */ (function (_super) {
    __extends(FormControl, _super);
    function FormControl() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.delegate = _this.attrs.ww.delegate ?
            _this.attrs.ww.delegate : new DefaultDelegate_1.DefaultDelegate(_this.attrs.ww);
        return _this;
    }
    /**
     * isFilled
     */
    //   abstract isFilled(): boolean;
    /**
     * clear
     */
    // abstract clear(): FormControl<V, A>;
    /**
     * isRequired tells if the Input was required.
     * @deprecated
     */
    FormControl.prototype.isRequired = function () {
        return (this.attrs.ww.required);
    };
    /**
     * hasClass queries whether a class exists on the root element on not.
     */
    FormControl.prototype.hasClass = function (cls) {
        return this
            .view
            .findById(this.values.root.id)
            .cata(function () { return false; }, (function (e) {
            return e.className.split(' ').indexOf(cls) === -1;
        }));
    };
    FormControl.prototype.hasError = function () {
        return this.hasClass(INPUT_ERROR);
    };
    FormControl.prototype.hasWarning = function () {
        return this.hasClass(INPUT_WARNING);
    };
    FormControl.prototype.hasSuccess = function () {
        return this.hasClass(INPUT_SUCCESS);
    };
    /**
     * setHelpText sets the message for the message portion of
     * this input.
     */
    FormControl.prototype.setHelpText = function (msg) {
        var _this = this;
        return this
            .view
            .findById(this.values.help.id)
            .map(function (message) {
            var node = document.createTextNode(msg);
            if (message.firstChild) {
                message.replaceChild(node, message.firstChild);
            }
            else {
                message.appendChild(node);
            }
        })
            .cata(function () { return _this; }, function () { return _this; });
    };
    FormControl.prototype.setState = function (state) {
        var _this = this;
        return this
            .view
            .findById(this.values.root.id)
            .map(function (e) { return e.classList.add(state); })
            .cata(function () { return _this; }, function () { return _this; });
    };
    /**
     * removeState removes the state validation state from the input.
     */
    FormControl.prototype.removeState = function () {
        var _this = this;
        return this
            .view
            .findById(this.values.root.id)
            .map(function (h) {
            h.classList.remove(INPUT_SUCCESS);
            h.classList.remove(INPUT_ERROR);
            h.classList.remove(INPUT_WARNING);
        })
            .cata(function () { return _this; }, function () { return _this; });
    };
    /**
     * state
     */
    FormControl.prototype.state = function () {
        return this.attrs.ww.success ?
            'has-success' :
            this.attrs.ww.error ?
                'has-error' :
                this.attrs.ww.warning ?
                    'has-warning' :
                    '';
    };
    /**
     * setSuccess
     */
    FormControl.prototype.setSuccess = function (message) {
        return this
            .removeState()
            .setHelpText(message)
            .setState(INPUT_SUCCESS);
    };
    /**
     * setError
     */
    FormControl.prototype.setError = function (message) {
        return this
            .removeState()
            .setHelpText(message)
            .setState(INPUT_ERROR);
    };
    /**
     * setWarning
     */
    FormControl.prototype.setWarning = function (message) {
        return this
            .removeState()
            .setHelpText(message)
            .setState(INPUT_WARNING);
    };
    /**
     * reset
     */
    FormControl.prototype.reset = function () {
        var _this = this;
        return this
            .view
            .findById(this.values.help.id)
            .map(function (m) {
            _this.removeState();
            while (m.firstChild)
                m.removeChild(m.firstChild);
            //  this.clear();
        })
            .cata(function () { return _this; }, function () { return _this; });
    };
    /**
     * rendered checks if the input should have a validation state set
     */
    FormControl.prototype.rendered = function () {
        var _a = this.attrs.ww, success = _a.success, error = _a.error, warning = _a.warning;
        if (success)
            this.setSuccess((typeof success === 'string') ? success : '');
        else if (error)
            this.setError((typeof error === 'string') ? error : '');
        else if (warning)
            this.setWarning((typeof warning === 'string') ? warning : '');
    };
    return FormControl;
}(Control_1.Control));
exports.FormControl = FormControl;

},{"./Control":52,"./DefaultDelegate":53}],56:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var views = require("./wml/autocomplete");
var util_1 = require("@package/self/common/util");
var lurch_1 = require("@package/self/control/lurch");
exports.ESCAPE = 27;
exports.INPUT_ID = 'input';
/**
 * Autocomplate provides an input with a dropdown menu that allows
 * the user to search and select form a list of options.
 */
var Autocomplete = /** @class */ (function (_super) {
    __extends(Autocomplete, _super);
    function Autocomplete() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.template = {
            populated: (_this.attrs.ww.populated) ?
                _this.attrs.ww.populated : views.populated,
            empty: (_this.attrs.ww.empty) ?
                _this.attrs.ww.empty : views.empty
        };
        _this.values = {
            id: {
                root: 'root',
                input: 'input',
                menu: 'menu',
                message: 'mesage',
            },
            class: {
                root: '',
                input: ''
            },
            root: {
                id: 'root',
                class: util_1.concat(names.SEARCH, _this.attrs.ww.class)
            },
            help: {
                id: 'help'
            },
            menu: {
                id: 'menu'
            },
            input: {
                id: 'input',
                class: util_1.concat('form-control', _this.attrs.ww.inputClass),
                placeholder: _this.attrs.ww.placeholder ?
                    _this.attrs.ww.placeholder : null,
                onKeyDown: _this.onKeyDown,
                onKeyUp: _this.onKeyUp,
                onInput: _this.onInput
            },
            search: {
                delay: _this.attrs.ww.debounce ?
                    _this.attrs.ww.debounce : _this.DEFAULT_DEBOUNCE_TIME,
                results: []
            },
            item: {
                template: _this.template,
                stringify: _this.attrs.ww.stringifier ?
                    _this.attrs.ww.stringifier : _this.stringify,
                click: function (index) {
                    _this
                        .close()
                        .delegate
                        .onSelect(new lurch_1.ItemSelectedEvent(_this.attrs.ww.name, _this.values.search.results[Number(index)]));
                }
            }
        };
        return _this;
    }
    Autocomplete.prototype.clear = function () {
        return this;
    };
    Autocomplete.prototype.open = function () {
        this
            .view
            .findById(this.values.id.menu)
            .map(function (m) { return m.show(); });
        return this;
    };
    Autocomplete.prototype.close = function () {
        this
            .view
            .findById(this.values.id.menu)
            .map(function (m) { return m.hide(); });
        return this;
    };
    Autocomplete.prototype.update = function (results) {
        var _this = this;
        this.values.search.results = results;
        this
            .view
            .findById(this.values.id.menu)
            .map(function (m) { return m.setContent(new views.Results(_this)).show(); });
        return this;
    };
    return Autocomplete;
}(lurch_1.SearchControl));
exports.Autocomplete = Autocomplete;

},{"./wml/autocomplete":58,"@package/self/common/names":49,"@package/self/common/util":50,"@package/self/control/lurch":80}],57:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Autocomplete_1 = require("./Autocomplete");
exports.Autocomplete = Autocomplete_1.Autocomplete;
var lurch_1 = require("@package/self/control/lurch");
exports.ItemSelectedEvent = lurch_1.ItemSelectedEvent;
exports.TermChangedEvent = lurch_1.TermChangedEvent;

},{"./Autocomplete":56,"@package/self/control/lurch":80}],58:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Menu_1 = require("@package/self/menu/Menu");
;
var MenuItem_1 = require("@package/self/menu/MenuItem");
;
var Fragment_1 = require("@package/self/layout/fragment/Fragment");
;
exports.populated = function (option, _index, _options) { return function (___context) { return function (___view) { return ___wml.domify(___context.values.item.stringify(option)); }; }; };
;
exports.empty = function () { return function (___context) { return function (___view) { return ___wml.domify("No results to display."); }; }; };
;
var Results = /** @class */ (function (_super) {
    __extends(Results, _super);
    function Results(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Fragment_1.Fragment, {
                html: {},
                wml: {}
            }, [___wml.map(___context.values.search.results, function _map(option, index) {
                    return ___wml.widget(MenuItem_1.MenuItem, {
                        html: {},
                        wml: {},
                        ww: {
                            'name': ("" + index),
                            'onClick': function () { return ___context.values.item.click(index); }
                        }
                    }, [___wml.domify(___context.values.item.template.populated(option, index, ___context.values.search.results)(___context)(___view))], ___view);
                }, function otherwise() {
                    return ___wml.domify(___context.values.item.template.empty()(___context)(___view));
                })], ___view);
        };
        return _this;
    }
    return Results;
}(___wml.AppView));
exports.Results = Results;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.node('input', {
                    html: {
                        'type': "text",
                        'class': ___context.values.input.class,
                        'onkeydown': ___context.values.input.onKeyDown,
                        'onkeyup': ___context.values.input.onKeyUp,
                        'oninput': ___context.values.input.onInput,
                        'placeholder': ___context.values.input.placeholder
                    },
                    wml: {
                        'id': ___context.values.input.id
                    }
                }, [], ___view), ___wml.widget(Menu_1.Menu, {
                    html: {},
                    wml: {
                        'id': ___context.values.menu.id
                    },
                    ww: {
                        'hidden': true
                    }
                }, [], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/layout/fragment/Fragment":107,"@package/self/menu/Menu":122,"@package/self/menu/MenuItem":123,"@quenk/wml":162}],59:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var control_1 = require("@package/self/control");
/**
 * ButtonChangedEvent
 */
var ButtonChangedEvent = /** @class */ (function (_super) {
    __extends(ButtonChangedEvent, _super);
    function ButtonChangedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ButtonChangedEvent;
}(control_1.Event));
exports.ButtonChangedEvent = ButtonChangedEvent;

},{"@package/self/control":75}],60:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ButtonChangedEvent_1 = require("./ButtonChangedEvent");
var ButtonSelectGroup_1 = require("./ButtonSelectGroup");
var Maybe_1 = require("afpl/lib/monad/Maybe");
/**
 * ButtonSelect
 */
var ButtonSelect = /** @class */ (function (_super) {
    __extends(ButtonSelect, _super);
    function ButtonSelect() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ButtonSelect.prototype.initialize = function (value) {
        return Maybe_1.Maybe.fromAny(value);
    };
    ButtonSelect.prototype.click = function (value) {
        this.values.select.value = Maybe_1.Maybe.fromAny(value);
        this.delegate.onChange(new ButtonChangedEvent_1.ButtonChangedEvent(this.attrs.ww.name, value));
        this.view.invalidate();
    };
    ButtonSelect.prototype.isSelected = function (v) {
        return this.values.select.value.cata(function () { return false; }, function (value) { return value === v; });
    };
    return ButtonSelect;
}(ButtonSelectGroup_1.ButtonSelectGroup));
exports.ButtonSelect = ButtonSelect;

},{"./ButtonChangedEvent":59,"./ButtonSelectGroup":61,"afpl/lib/monad/Maybe":169}],61:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var views = require("./wml/button-select");
var control_1 = require("@package/self/control");
var util_1 = require("@package/self/common/util");
/**
 * ButtonSelectGroup
 */
var ButtonSelectGroup = /** @class */ (function (_super) {
    __extends(ButtonSelectGroup, _super);
    function ButtonSelectGroup() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: {
                id: 'root',
                class: names.BUTTON_SELECT
            },
            help: {
                id: 'help',
                success: _this.attrs.ww.success,
                error: _this.attrs.ww.error,
                warning: _this.attrs.ww.warning
            },
            select: {
                value: _this.initialize(_this.attrs.ww.value),
                options: _this.attrs.ww.options,
                isSelected: function (v) { return _this.isSelected(v); }
            },
            click: function (v) { return function () { return _this.click(v); }; },
            calculateClass: function (_a) {
                var className = _a.className, value = _a.value;
                return util_1.concat(names.BUTTON_SELECT_OPTION, className, (_this.attrs.ww.variant) ? _this.attrs.ww.variant : names.DEFAULT, _this.values.select.isSelected(value) ? names.ACTIVE : '');
            },
        };
        return _this;
    }
    return ButtonSelectGroup;
}(control_1.FormControl));
exports.ButtonSelectGroup = ButtonSelectGroup;

},{"./wml/button-select":64,"@package/self/common/names":49,"@package/self/common/util":50,"@package/self/control":75}],62:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ButtonChangedEvent_1 = require("./ButtonChangedEvent");
var ButtonSelectGroup_1 = require("./ButtonSelectGroup");
var Maybe_1 = require("afpl/lib/monad/Maybe");
/**
 * MultiButtonSelect
 */
var MultiButtonSelect = /** @class */ (function (_super) {
    __extends(MultiButtonSelect, _super);
    function MultiButtonSelect() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MultiButtonSelect.prototype.initialize = function (v) {
        return Maybe_1.Maybe.fromAny(v).cata(function () { return Maybe_1.Maybe.fromArray([]); }, function (v) { return Maybe_1.Maybe.fromArray(v); });
    };
    MultiButtonSelect.prototype.click = function (v) {
        var _this = this;
        this.values.select.value = this
            .values
            .select
            .value
            .map(function (value) {
            var pos = value.indexOf(v);
            if (pos > -1)
                value.splice(pos, 1);
            else
                value.push(v);
            _this.delegate.onChange(new ButtonChangedEvent_1.ButtonChangedEvent(_this.attrs.ww.name, value.slice()));
            _this.view.invalidate();
            return value;
        })
            .orJust(function () { return [v]; });
    };
    MultiButtonSelect.prototype.isSelected = function (v) {
        return this.values.select.value.cata(function () { return false; }, function (value) { return value.indexOf(v) > -1; });
    };
    return MultiButtonSelect;
}(ButtonSelectGroup_1.ButtonSelectGroup));
exports.MultiButtonSelect = MultiButtonSelect;

},{"./ButtonChangedEvent":59,"./ButtonSelectGroup":61,"afpl/lib/monad/Maybe":169}],63:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ButtonSelectGroup_1 = require("./ButtonSelectGroup");
exports.ButtonSelectGroup = ButtonSelectGroup_1.ButtonSelectGroup;
var ButtonSelect_1 = require("./ButtonSelect");
exports.ButtonSelect = ButtonSelect_1.ButtonSelect;
var ButtonChangedEvent_1 = require("./ButtonChangedEvent");
exports.ButtonChangedEvent = ButtonChangedEvent_1.ButtonChangedEvent;
var MultiButtonSelect_1 = require("./MultiButtonSelect");
exports.MultiButtonSelect = MultiButtonSelect_1.MultiButtonSelect;

},{"./ButtonChangedEvent":59,"./ButtonSelect":60,"./ButtonSelectGroup":61,"./MultiButtonSelect":62}],64:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Button_1 = require("@package/self/control/button/Button");
;
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.map(___context.values.select.options, function _map(opt) {
                    return ___wml.widget(Button_1.Button, {
                        html: {},
                        wml: {},
                        ww: {
                            'class': ___context.values.calculateClass(opt),
                            'active': ___context.values.select.isSelected(opt.value),
                            'onClick': ___context.values.click(opt.value),
                            'text': opt.text
                        }
                    }, [], ___view);
                }, function otherwise() {
                    return document.createDocumentFragment();
                })], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/control/button/Button":65,"@quenk/wml":162}],65:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var G = require("@package/self/content/Group");
var names = require("@package/self/common/names");
var views = require("./wml/button");
var util_1 = require("@package/self/common/util");
/**
 * Group multiple buttons into one element.
 */
var Group = /** @class */ (function (_super) {
    __extends(Group, _super);
    function Group() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Group(_this);
        _this.values = {
            root: {
                class: util_1.concat('btn-group', (_this.attrs.ww) ? _this.attrs.ww.class : '')
            }
        };
        return _this;
    }
    return Group;
}(G.Group));
exports.Group = Group;
;
/**
 * Button is an improvement over HTMLButtionElement
 */
var Button = /** @class */ (function (_super) {
    __extends(Button, _super);
    function Button() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Button(_this);
        _this.values = {
            id: {
                button: 'button'
            },
            button: {
                class: _this.attrs.ww ?
                    util_1.concat(names.BUTTON, _this.attrs.ww.variant || names.DEFAULT, _this.attrs.ww.style, _this.attrs.ww.active ?
                        names.ACTIVE : '', _this.attrs.ww.class) :
                    names.BUTTON,
                type: (_this.attrs.ww && _this.attrs.ww.type) ? _this.attrs.ww.type : 'button',
                name: (_this.attrs.ww && _this.attrs.ww.name) ? _this.attrs.ww.name : '',
                disabled: (_this.attrs.ww && _this.attrs.ww.disabled) ? _this.attrs.ww.disabled : null,
                onclick: (_this.attrs.ww && _this.attrs.ww.onClick) ? _this.attrs.ww.onClick : function () { },
                text: (_this.attrs.ww && _this.attrs.ww.text) ? _this.attrs.ww.text : ''
            }
        };
        return _this;
    }
    /**
     * disable this button.
     */
    Button.prototype.disable = function () {
        this.view.findById(this.values.id.button)
            .map(function (b) { return b.setAttribute('disabled', 'disabled'); });
    };
    /**
     * enable this button.
     */
    Button.prototype.enable = function () {
        this.view.findById(this.values.id.button)
            .map(function (b) { return b.removeAttribute('disabled'); });
    };
    Button.prototype.rendered = function () {
        if (this.attrs.ww)
            if (this.attrs.ww.disabled)
                this.view.findById(this.values.id.button)
                    .map(function (b) { return b.setAttribute('disabled', 'disabled'); });
    };
    return Button;
}(G.Group));
exports.Button = Button;

},{"./wml/button":66,"@package/self/common/names":49,"@package/self/common/util":50,"@package/self/content/Group":51}],66:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Group = /** @class */ (function (_super) {
    __extends(Group, _super);
    function Group(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Group;
}(___wml.AppView));
exports.Group = Group;
;
var Button = /** @class */ (function (_super) {
    __extends(Button, _super);
    function Button(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('button', {
                html: {
                    'type': ___context.values.button.type,
                    'name': ___context.values.button.name,
                    'disabled': ___context.values.button.disabled,
                    'class': ___context.values.button.class,
                    'onclick': ___context.values.button.onclick
                },
                wml: {
                    'id': "button"
                }
            }, [___wml.domify(___context.values.button.text), ___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Button;
}(___wml.AppView));
exports.Button = Button;

},{"@quenk/wml":162}],67:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var wml_1 = require("@quenk/wml");
var checkbox_1 = require("./wml/checkbox");
var CheckboxChangedEvent_1 = require("./CheckboxChangedEvent");
/**
 * Checkbox control.
 *
 * This is an alternative to the native checkbox that can be styled.
 */
var Checkbox = /** @class */ (function (_super) {
    __extends(Checkbox, _super);
    function Checkbox() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new checkbox_1.Main(_this);
        _this.values = {
            class: {
                root: names.CHECKBOX,
            },
            input: {
                name: _this.attrs.ww.name,
                checked: _this.attrs.ww.checked || false,
                onChange: function () {
                    _this.values.input.checked = !_this.values.input.checked;
                    if (_this.attrs.ww.onChange)
                        _this.attrs.ww.onChange(new CheckboxChangedEvent_1.CheckboxChangedEvent(_this.values.input.name, _this.values.input.checked));
                }
            }
        };
        return _this;
    }
    return Checkbox;
}(wml_1.Component));
exports.Checkbox = Checkbox;

},{"./CheckboxChangedEvent":68,"./wml/checkbox":69,"@package/self/common/names":49,"@quenk/wml":162}],68:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Event_1 = require("@package/self/control/Event");
/**
 * CheckboxChangedEvent signals the user has changed the checkbox state.
 */
var CheckboxChangedEvent = /** @class */ (function (_super) {
    __extends(CheckboxChangedEvent, _super);
    function CheckboxChangedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return CheckboxChangedEvent;
}(Event_1.Event));
exports.CheckboxChangedEvent = CheckboxChangedEvent;

},{"@package/self/control/Event":54}],69:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [___wml.node('label', {
                    html: {},
                    wml: {}
                }, [___wml.node('input', {
                        html: {
                            'type': "checkbox",
                            'name': ___context.values.input.name,
                            'checked': (___context.values.input.checked || null),
                            'onchange': ___context.values.input.onChange
                        },
                        wml: {}
                    }, [], ___view), ___wml.domify(___context.children)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":162}],70:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/date");
var names = require("@package/self/common/names");
var moment = require("moment");
var util_1 = require("@package/self/common/util");
var control_1 = require("@package/self/control");
var DateChangedEvent_1 = require("./DateChangedEvent");
exports.format = {
    YYYYDDMM: 'YYYY-MM-DD',
    DD: 'DD',
    MM: 'MM',
    YYYY: 'YYYY'
};
exports.MONTHS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
;
var _inputValues = function (id, klass, value, date, cb) { return ({
    id: id,
    class: klass,
    value: value,
    disabled: (date.attrs.ww.disabled === true) ? true : null,
    readOnly: (date.attrs.ww.readOnly === true) ? true : null,
    onInput: function (_a) {
        var value = _a.value;
        cb(value);
        date.date.value = date.calculate();
        date.fireChange();
    }
}); };
var _prefix = function (s, inc) {
    if (inc === void 0) { inc = false; }
    var n = Number(s);
    if (inc)
        n = n + 1;
    if (isNaN(n))
        return '';
    return (n < 10) ? "0" + n : "" + n;
};
/**
 * Date input.
 */
var Date = /** @class */ (function (_super) {
    __extends(Date, _super);
    function Date() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.delegate = _this.attrs.ww.delegate ?
            _this.attrs.ww.delegate : new control_1.DefaultDelegate(_this.attrs.ww);
        _this.date = {
            value: _this.attrs.ww.value ? moment(_this.attrs.ww.value, exports.format.YYYYDDMM) : null,
            sep: '-',
            format: exports.format.YYYYDDMM
        };
        _this.values = {
            root: {
                id: 'root',
                class: util_1.concat(names.DATE, 'form-inline', _this.attrs.ww.class, _this.state()),
            },
            date: {
                months: exports.MONTHS.map(function (label, value) { return ({ label: label, value: _prefix(value + 1) }); }),
                prefix: _prefix
            },
            delegate: _this.delegate,
            day: _inputValues('day', names.DATE_DAY, (_this.date.value && _this.date.value.isValid()) ?
                _this.date.value.format(exports.format.DD) : '', _this, function (v) { return _this.values.day.value = _prefix(v); }),
            month: _inputValues('month', names.DATE_MONTH, (_this.date.value && _this.date.value.isValid()) ?
                _this.date.value.format(exports.format.MM) : '', _this, function (v) { return _this.values.month.value = v; }),
            year: _inputValues('year', names.DATE_YEAR, (_this.date.value && _this.date.value.isValid()) ?
                _this.date.value.format(exports.format.YYYY) : '', _this, function (v) { return _this.values.year.value = v; }),
            name: _this.attrs.ww.name,
            help: {
                id: 'help',
                success: _this.attrs.ww.success,
                error: _this.attrs.ww.error,
                warning: _this.attrs.ww.warning
            }
        };
        return _this;
    }
    /**
     * calculate the date based on the current value of the inputs.
     */
    Date.prototype.calculate = function () {
        var date = [
            this.values.year.value,
            this.values.month.value,
            this.values.day.value
        ].filter(function (d) { return d; });
        return (date.length != 3) ? null : moment(date.join(this.date.sep), moment.ISO_8601);
    };
    ;
    /**
     * fireChange
     * @private
     */
    Date.prototype.fireChange = function () {
        if (this.date.value && this.date.value.isValid())
            this.values.delegate.onChange(new DateChangedEvent_1.DateChangedEvent(this.values.name, this.date.value.format(this.date.format)));
    };
    return Date;
}(control_1.FormControl));
exports.Date = Date;

},{"./DateChangedEvent":71,"./wml/date":72,"@package/self/common/names":49,"@package/self/common/util":50,"@package/self/control":75,"moment":176}],71:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Event_1 = require("@package/self/control/Event");
/**
 * DateChangedEvent is generated when the date has
 * been changed to a valid date.
 */
var DateChangedEvent = /** @class */ (function (_super) {
    __extends(DateChangedEvent, _super);
    function DateChangedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return DateChangedEvent;
}(Event_1.Event));
exports.DateChangedEvent = DateChangedEvent;

},{"@package/self/control/Event":54}],72:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var wml_1 = require("@package/self/control/wml");
;
var select_1 = require("@package/self/control/select");
;
var text_field_1 = require("@package/self/control/text-field");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.widget(select_1.Select, {
                    html: {},
                    wml: {
                        'id': ___context.values.month.id
                    },
                    ww: {
                        'name': ___context.values.month.id,
                        'onChange': ___context.values.month.onInput,
                        'disabled': ___context.values.month.disabled,
                        'readOnly': ___context.values.month.readOnly,
                        'class': ___context.values.month.class,
                        'options': ___context.values.date.months
                    }
                }, [___wml.node('option', {
                        html: {
                            'selected': true,
                            'value': "",
                            'disabled': true
                        },
                        wml: {}
                    }, [___wml.text("Month")], ___view)], ___view), ___wml.widget(text_field_1.TextField, {
                    html: {},
                    wml: {
                        'id': ___context.values.day.id
                    },
                    ww: {
                        'name': ___context.values.day.id,
                        'onChange': ___context.values.day.onInput,
                        'value': ___context.values.day.value,
                        'disabled': ___context.values.day.disabled,
                        'readOnly': ___context.values.day.readOnly,
                        'class': ___context.values.day.class,
                        'placeholder': "DD"
                    }
                }, [], ___view), ___wml.widget(text_field_1.TextField, {
                    html: {},
                    wml: {
                        'id': ___context.values.year.id
                    },
                    ww: {
                        'name': ___context.values.year.id,
                        'onChange': ___context.values.year.onInput,
                        'value': ___context.values.year.value,
                        'disabled': ___context.values.year.disabled,
                        'readOnly': ___context.values.year.readOnly,
                        'class': ___context.values.year.class,
                        'placeholder': "YYYY"
                    }
                }, [], ___view), ___wml.domify(wml_1.message(___context.values.help.id, ___context.values.help)(___view))], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/control/select":85,"@package/self/control/text-field":100,"@package/self/control/wml":102,"@quenk/wml":162}],73:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var wml_1 = require("@quenk/wml");
var util_1 = require("@package/self/common/util");
var icon_button_1 = require("./wml/icon-button");
/**
 * IconButton provides a 'hamburger' menu button.
 */
var IconButton = /** @class */ (function (_super) {
    __extends(IconButton, _super);
    function IconButton() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new icon_button_1.Main(_this);
        _this.values = {
            class: {
                root: names.ICON_BUTTON
            },
            button: {
                class: util_1.concat(names.ICON_BUTTON, (_this.attrs.ww && _this.attrs.ww.class) ?
                    _this.attrs.ww.class : ''),
                onClick: (_this.attrs.ww && _this.attrs.ww.onClick) ? _this.attrs.ww.onClick : function () { }
            }
        };
        return _this;
    }
    return IconButton;
}(wml_1.Component));
exports.IconButton = IconButton;

},{"./wml/icon-button":74,"@package/self/common/names":49,"@package/self/common/util":50,"@quenk/wml":162}],74:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('button', {
                html: {
                    'class': ___context.values.button.class,
                    'onclick': ___context.values.button.onClick
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":162}],75:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Event_1 = require("./Event");
exports.Event = Event_1.Event;
var DefaultDelegate_1 = require("./DefaultDelegate");
exports.DefaultDelegate = DefaultDelegate_1.DefaultDelegate;
var Control_1 = require("./Control");
exports.Control = Control_1.Control;
var FormControl_1 = require("./FormControl");
exports.FormControl = FormControl_1.FormControl;

},{"./Control":52,"./DefaultDelegate":53,"./Event":54,"./FormControl":55}],76:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var control_1 = require("@package/self/control");
var ItemSelectedEvent = /** @class */ (function (_super) {
    __extends(ItemSelectedEvent, _super);
    function ItemSelectedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ItemSelectedEvent;
}(control_1.Event));
exports.ItemSelectedEvent = ItemSelectedEvent;

},{"@package/self/control":75}],77:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@package/self/common/util");
var TermChangedEvent_1 = require("./TermChangedEvent");
var SearchDefaultDelegate_1 = require("./SearchDefaultDelegate");
var control_1 = require("@package/self/control");
exports.ESCAPE = 27;
exports.DEFAULT_DEBOUNCE_TIME = 500;
exports.INPUT_ID = 'input';
/**
 * SearchControl
 */
var SearchControl = /** @class */ (function (_super) {
    __extends(SearchControl, _super);
    function SearchControl() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.DEFAULT_DEBOUNCE_TIME = exports.DEFAULT_DEBOUNCE_TIME;
        _this.delegate = _this.attrs.ww.delegate ?
            _this.attrs.ww.delegate : new SearchDefaultDelegate_1.SearchDefaultDelegate(_this.attrs.ww);
        _this.results = [];
        _this.onKeyDown = function (e) { return (e.keyCode !== exports.ESCAPE) ? _this.execute(null) : null; };
        _this.onKeyUp = function (e) {
            var target = e.target;
            if (e.keyCode === exports.ESCAPE) {
                target.blur();
                _this.close();
            }
        };
        _this.onInput = function (e) {
            //For compatability reasons
            e.target.onkeydown = null;
            _this.onKeyDown(e);
        };
        _this.execute = util_1.debounce(function () {
            _this
                .view
                .findById(_this.values.input.id)
                .map(function (_a) {
                var value = _a.value;
                return _this.delegate.onSearch(new TermChangedEvent_1.TermChangedEvent(_this.attrs.ww.name, value));
            });
        }, _this.attrs.ww.debounce || _this.DEFAULT_DEBOUNCE_TIME);
        _this.stringify = function (v) { return String(v); };
        return _this;
    }
    SearchControl.prototype.rendered = function () {
        document.addEventListener('click', this);
    };
    SearchControl.prototype.handleEvent = function (e) {
        var _this = this;
        this
            .view
            .findById(this.values.id.root)
            .map(function (root) {
            if (!root.contains(e.target))
                _this.close();
            if (!document.body.contains(root))
                document.removeEventListener('click', _this);
        });
    };
    return SearchControl;
}(control_1.FormControl));
exports.SearchControl = SearchControl;

},{"./SearchDefaultDelegate":78,"./TermChangedEvent":79,"@package/self/common/util":50,"@package/self/control":75}],78:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var control_1 = require("@package/self/control");
/**
 * SearchDefaultDelegate fowards all events to their corresponding
 * function handlers, specifed on the attributes of a control.
 */
var SearchDefaultDelegate = /** @class */ (function (_super) {
    __extends(SearchDefaultDelegate, _super);
    function SearchDefaultDelegate(attrs) {
        var _this = _super.call(this, attrs) || this;
        _this.attrs = attrs;
        _this.onSearch = function (e) {
            if (_this.attrs.onSearch)
                _this.attrs.onSearch(e);
        };
        _this.onSelect = function (e) {
            if (_this.attrs.onSelect)
                _this.attrs.onSelect(e);
        };
        return _this;
    }
    return SearchDefaultDelegate;
}(control_1.DefaultDelegate));
exports.SearchDefaultDelegate = SearchDefaultDelegate;

},{"@package/self/control":75}],79:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var control_1 = require("@package/self/control");
/**
 * TermChangedEvent signals the search term has changed.
 */
var TermChangedEvent = /** @class */ (function (_super) {
    __extends(TermChangedEvent, _super);
    function TermChangedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return TermChangedEvent;
}(control_1.Event));
exports.TermChangedEvent = TermChangedEvent;

},{"@package/self/control":75}],80:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var SearchControl_1 = require("./SearchControl");
exports.SearchControl = SearchControl_1.SearchControl;
var SearchDefaultDelegate_1 = require("./SearchDefaultDelegate");
exports.SearchDefaultDelegate = SearchDefaultDelegate_1.SearchDefaultDelegate;
var ItemSelectedEvent_1 = require("./ItemSelectedEvent");
exports.ItemSelectedEvent = ItemSelectedEvent_1.ItemSelectedEvent;
var TermChangedEvent_1 = require("./TermChangedEvent");
exports.TermChangedEvent = TermChangedEvent_1.TermChangedEvent;

},{"./ItemSelectedEvent":76,"./SearchControl":77,"./SearchDefaultDelegate":78,"./TermChangedEvent":79}],81:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var views = require("./wml/search-stack");
var control_1 = require("@package/self/control");
/**
 * SearchStack
 */
var SearchStack = /** @class */ (function (_super) {
    __extends(SearchStack, _super);
    function SearchStack() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            id: {
                root: 'root',
                input: 'button',
                search: 'search',
                message: 'message'
            },
            root: {
                id: 'root',
                class: names.SEARCH_STACK
            },
            help: {
                id: 'help'
            },
            search: {
                id: 'search',
                name: _this.attrs.ww.name,
                value: '',
                onSearch: function (evt) { if (_this.attrs.ww.onSearch)
                    _this.attrs.ww.onSearch(evt); },
                onSelect: function (_a) {
                    var value = _a.value;
                    return _this.push(value);
                }
            },
            stack: {
                id: 'stack',
                name: _this.attrs.ww.name,
                value: _this.attrs.ww.value,
                decorator: _this.attrs.ww.decorator ? _this.attrs.ww.decorator : function (v) { return String(v); },
                onChange: function (evt) { return _this.delegate.onChange(evt); }
            }
        };
        return _this;
    }
    /**
     * update the list of available options displayed to the user.
     */
    SearchStack.prototype.update = function (list) {
        this
            .view
            .findById(this.values.search.id)
            .map(function (s) { return s.update(list); });
        return this;
    };
    /**
     * push a value onto the stack.
     */
    SearchStack.prototype.push = function (v) {
        this
            .view
            .findById(this.values.stack.id)
            .map(function (s) { return s.push(v); });
        return this;
    };
    return SearchStack;
}(control_1.FormControl));
exports.SearchStack = SearchStack;

},{"./wml/search-stack":82,"@package/self/common/names":49,"@package/self/control":75}],82:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var autocomplete_1 = require("@package/self/control/autocomplete");
;
var stack_1 = require("@package/self/control/stack");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.widget(stack_1.Stack, {
                    html: {},
                    wml: {
                        'id': ___context.values.stack.id
                    },
                    ww: {
                        'name': ___context.values.stack.name,
                        'value': ___context.values.stack.value,
                        'decorator': ___context.values.stack.decorator,
                        'onChange': ___context.values.stack.onChange
                    }
                }, [], ___view), ___wml.widget(autocomplete_1.Autocomplete, {
                    html: {},
                    wml: {
                        'id': ___context.values.search.id
                    },
                    ww: {
                        'name': ___context.values.search.name,
                        'value': ___context.values.search.value,
                        'stringifier': ___context.values.stack.decorator,
                        'onSearch': ___context.values.search.onSearch,
                        'onSelect': ___context.values.search.onSelect
                    }
                }, [], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/control/autocomplete":57,"@package/self/control/stack":89,"@quenk/wml":162}],83:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/select");
var util_1 = require("@package/self/common/util");
var control_1 = require("@package/self/control");
var SelectChangedEvent_1 = require("./SelectChangedEvent");
/**
 * Select provides a dropdown list for selecting items.
 *
 * Note: Currently this relies on the native select but this
 * is likely to change in the future. Use the native <select>
 * directly if you must have that.
 */
var Select = /** @class */ (function (_super) {
    __extends(Select, _super);
    function Select() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: {
                id: 'root',
                class: util_1.concat('form-group', _this.attrs.ww.class, _this.state())
            },
            label: {
                id: _this.attrs.ww.name,
                text: _this.attrs.ww.label || ''
            },
            select: {
                id: 'select',
                name: _this.attrs.ww.name,
                class: 'form-control',
                value: _this.attrs.ww.value || '',
                disabled: (_this.attrs.ww.disabled === true) ? true : null,
                readOnly: (_this.attrs.ww.readOnly === true) ? true : null,
                options: _this.attrs.ww.options,
                placeholder: _this.attrs.ww.placeholder || 'Select one.',
                optValue: function (o) { return typeof o === 'string' ? o : o.value; },
                optLabel: function (o) { return typeof o === 'string' ? o : o.label; },
                isSelected: function (s) { return _this.values.select.value === s; },
                onChange: function (e) {
                    var target = e.target;
                    _this
                        .delegate
                        .onChange(new SelectChangedEvent_1.SelectChangedEvent(_this.attrs.ww.name, target.value));
                }
            },
            help: {
                id: 'message',
                success: _this.attrs.ww.success,
                error: _this.attrs.ww.error,
                warning: _this.attrs.ww.warning
            }
        };
        return _this;
    }
    return Select;
}(control_1.FormControl));
exports.Select = Select;

},{"./SelectChangedEvent":84,"./wml/select":86,"@package/self/common/util":50,"@package/self/control":75}],84:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var control_1 = require("@package/self/control");
var SelectChangedEvent = /** @class */ (function (_super) {
    __extends(SelectChangedEvent, _super);
    function SelectChangedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return SelectChangedEvent;
}(control_1.Event));
exports.SelectChangedEvent = SelectChangedEvent;

},{"@package/self/control":75}],85:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Select_1 = require("./Select");
exports.Select = Select_1.Select;
var SelectChangedEvent_1 = require("./SelectChangedEvent");
exports.SelectChangedEvent = SelectChangedEvent_1.SelectChangedEvent;

},{"./Select":83,"./SelectChangedEvent":84}],86:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
;
var wml_1 = require("@package/self/control/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.domify(wml_1.label(___context.values.label.id, ___context.values.label.text)(___view)), ___wml.node('select', {
                    html: {
                        'name': ___context.values.select.name,
                        'onchange': ___context.values.select.onChange,
                        'value': ___context.values.select.value,
                        'disabled': ___context.values.select.disabled,
                        'readonly': ___context.values.select.readOnly,
                        'class': ___context.values.select.class
                    },
                    wml: {
                        'id': ___context.values.select.id
                    }
                }, [___wml.node('option', {
                        html: {
                            'value': "",
                            'disabeld': true
                        },
                        wml: {}
                    }, [___wml.domify(___context.values.select.placeholder)], ___view), ___wml.map(___context.values.select.options, function _map(opt) {
                        return ___wml.node('option', {
                            html: {
                                'value': ___context.values.select.optValue(opt),
                                'selected': ___context.values.select.isSelected(___context.values.select.optValue(opt))
                            },
                            wml: {}
                        }, [___wml.domify(___context.values.select.optLabel(opt))], ___view);
                    }, function otherwise() {
                        return document.createDocumentFragment();
                    })], ___view), ___wml.domify(wml_1.message(___context.values.help.id, ___context.values.help)(___view))], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/control/wml":102,"@quenk/wml":162}],87:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml = require("@quenk/wml");
var names = require("@package/self/common/names");
var views = require("./wml/stack");
var StackChangedEvent_1 = require("./StackChangedEvent");
/**
 * Stack displays a list of items that can be modified
 * by releasing one or more at a time.
 */
var Stack = /** @class */ (function (_super) {
    __extends(Stack, _super);
    function Stack() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.template = _this.attrs.ww.template ?
            _this.attrs.ww.template : views.content;
        _this.values = {
            id: {
                root: 'root',
                a: 'link'
            },
            class: {
                root: names.STACK,
                close: names.STACK_CLOSE,
                member: names.STACK_MEMBER
            },
            item: {
                template: _this.template,
                close: function (index) { return function () {
                    _this.values.value.splice(Number(index), 1);
                    _this.fire();
                }; },
                decorator: _this.attrs.ww.decorator ? _this.attrs.ww.decorator : function (m) { return String(m); }
            },
            value: _this.attrs.ww.value ? _this.attrs.ww.value : []
        };
        return _this;
    }
    /**
     * push a new member onto the stack.
     */
    Stack.prototype.push = function (m) {
        this.values.value.push(m);
        this.fire();
        return this;
    };
    Stack.prototype.fire = function () {
        if (this.attrs.ww.onChange)
            this.attrs.ww.onChange(new StackChangedEvent_1.StackChangedEvent(this.attrs.ww.name, this.values.value.slice()));
        this.view.invalidate();
    };
    return Stack;
}(wml.Component));
exports.Stack = Stack;

},{"./StackChangedEvent":88,"./wml/stack":90,"@package/self/common/names":49,"@quenk/wml":162}],88:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var control_1 = require("@package/self/control");
/**
 * StackChangedEvent is generated when the user removes an item from the stack.
 */
var StackChangedEvent = /** @class */ (function (_super) {
    __extends(StackChangedEvent, _super);
    function StackChangedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return StackChangedEvent;
}(control_1.Event));
exports.StackChangedEvent = StackChangedEvent;

},{"@package/self/control":75}],89:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Stack_1 = require("./Stack");
exports.Stack = Stack_1.Stack;
var StackChangedEvent_1 = require("./StackChangedEvent");
exports.StackChangedEvent = StackChangedEvent_1.StackChangedEvent;

},{"./Stack":87,"./StackChangedEvent":88}],90:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
;
exports.content = function (m) { return function (___context) { return function (___view) { return ___wml.node('span', {
    html: {
        'class': ___context.values.class.member
    },
    wml: {}
}, [___wml.domify(___context.values.item.decorator(m))], ___view); }; }; };
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('ul', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [___wml.map(___context.values.value, function _map(m, index) {
                    return ___wml.node('li', {
                        html: {},
                        wml: {}
                    }, [___wml.domify(___context.values.item.template(m, index, ___context.values.value)(___context)(___view)), ___wml.node('button', {
                            html: {
                                'class': ___context.values.class.close,
                                'onclick': ___context.values.item.close(index)
                            },
                            wml: {}
                        }, [___wml.text("\u00D7")], ___view)], ___view);
                }, function otherwise() {
                    return document.createDocumentFragment();
                })], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":162}],91:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var wml_1 = require("@quenk/wml");
var switch_1 = require("./wml/switch");
var SwitchChangedEvent_1 = require("./SwitchChangedEvent");
/**
 * Switch allows the user to select between one or two values.
 */
var Switch = /** @class */ (function (_super) {
    __extends(Switch, _super);
    function Switch() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new switch_1.Main(_this);
        _this.values = {
            class: {
                label: names.SWITCH,
                slider: names.SWITCH_SLIDER
            },
            input: {
                name: _this.attrs.ww.name,
                on: _this.attrs.ww.on || false,
                disabled: _this.attrs.ww.disabled ? true : null,
                onChange: function () {
                    _this.values.input.on = !_this.values.input.on;
                    if (_this.attrs.ww.onChange)
                        _this.attrs.ww.onChange(new SwitchChangedEvent_1.SwitchChangedEvent(_this.values.input.name, _this.values.input.on));
                }
            }
        };
        return _this;
    }
    return Switch;
}(wml_1.Component));
exports.Switch = Switch;

},{"./SwitchChangedEvent":92,"./wml/switch":93,"@package/self/common/names":49,"@quenk/wml":162}],92:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var control_1 = require("@package/self/control");
/**
 * SwitchChangedEvent signals the user has changed the switch.
 */
var SwitchChangedEvent = /** @class */ (function (_super) {
    __extends(SwitchChangedEvent, _super);
    function SwitchChangedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return SwitchChangedEvent;
}(control_1.Event));
exports.SwitchChangedEvent = SwitchChangedEvent;

},{"@package/self/control":75}],93:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('label', {
                html: {
                    'class': ___context.values.class.label
                },
                wml: {}
            }, [___wml.node('input', {
                    html: {
                        'type': "checkbox",
                        'name': ___context.values.input.name,
                        'checked': (___context.values.input.on || null),
                        'disabled': ___context.values.input.disabled,
                        'onchange': ___context.values.input.onChange
                    },
                    wml: {}
                }, [], ___view), ___wml.node('div', {
                    html: {
                        'class': ___context.values.class.slider
                    },
                    wml: {}
                }, [], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":162}],94:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var view = require("./wml/tabs");
var afpl = require("afpl");
var util_1 = require("@package/self/common/util");
var TabClickedEvent_1 = require("./TabClickedEvent");
var wml_1 = require("@quenk/wml");
var _unknown = function (id) {
    return console.warn("Missing element with id " + id + ".");
};
/**
 * Tab provides a single tab item.
 *
 * When a tab is clicked, it attempts to remove the active class from
 * it's siblings and apply it to itself. Therefore the sibling of a
 * tab should always be a Tab.
 */
var Tab = /** @class */ (function (_super) {
    __extends(Tab, _super);
    function Tab() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new view.Tab(_this);
        _this.values = {
            id: {
                root: 'root',
                a: 'link'
            },
            class: {
                li: util_1.concat(names.TABS_TAB, _this.attrs.ww.active ? names.ACTIVE : '')
            },
            tab: {
                text: _this.attrs.ww.text
            }
        };
        _this.clicked = function (e) {
            e.preventDefault();
            _this
                .view
                .findById(_this.values.id.root)
                .chain(function (root) {
                var parent = root.parentNode;
                var us = parent.children;
                for (var i = 0; i < us.length; i++)
                    us[i].classList.remove(names.ACTIVE);
                return _this
                    .view
                    .findById(_this.values.id.root)
                    .map(function (el) { return el.classList.add(names.ACTIVE); })
                    .orJust(function () { return _unknown(_this.values.id.root); })
                    .chain(function () { return afpl.Maybe.fromAny(_this.attrs.ww.onClick); })
                    .map(function (f) {
                    return f(new TabClickedEvent_1.TabClickedEvent(_this.attrs.ww.name));
                });
            });
        };
        return _this;
    }
    /**
     * click this Tab
     */
    Tab.prototype.click = function () {
        var _this = this;
        this
            .view
            .findById(this.values.id.a)
            .cata(function () { return _unknown(_this.values.id.a); }, function (e) { return e.click(); });
    };
    return Tab;
}(wml_1.Component));
exports.Tab = Tab;

},{"./TabClickedEvent":95,"./wml/tabs":97,"@package/self/common/names":49,"@package/self/common/util":50,"@quenk/wml":162,"afpl":164}],95:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * TabClickedEvent is fired when a user clicks on a tab.
 *
 * It contains information about the tab that was clicked.
 */
var TabClickedEvent = /** @class */ (function () {
    function TabClickedEvent(name) {
        this.name = name;
    }
    return TabClickedEvent;
}());
exports.TabClickedEvent = TabClickedEvent;

},{}],96:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var view = require("./wml/tabs");
var util_1 = require("@package/self/common/util");
var wml_1 = require("@quenk/wml");
/**
 * Tabs acts as a parent container for a group of Tab.
 *
 * Use it to create a tabbed navigation or view for main layout,
 * sub views or forms etc.
 */
var Tabs = /** @class */ (function (_super) {
    __extends(Tabs, _super);
    function Tabs() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new view.Tabs(_this);
        _this.values = {
            root: {
                class: util_1.concat(names.TABS, 'nav nav-tabs', _this.attrs.ww ? _this.attrs.ww.class : '')
            }
        };
        return _this;
    }
    return Tabs;
}(wml_1.Component));
exports.Tabs = Tabs;

},{"./wml/tabs":97,"@package/self/common/names":49,"@package/self/common/util":50,"@quenk/wml":162}],97:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
;
var Tab = /** @class */ (function (_super) {
    __extends(Tab, _super);
    function Tab(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('li', {
                html: {
                    'class': ___context.values.class.li
                },
                wml: {
                    'id': ___context.values.id.root
                }
            }, [___wml.node('a', {
                    html: {
                        'href': "#",
                        'onclick': ___context.clicked
                    },
                    wml: {
                        'id': ___context.values.id.a
                    }
                }, [(___context.values.tab.text) ? ___wml.domify(___context.values.tab.text) : ___wml.domify(___context.children)], ___view)], ___view);
        };
        return _this;
    }
    return Tab;
}(___wml.AppView));
exports.Tab = Tab;
;
var Tabs = /** @class */ (function (_super) {
    __extends(Tabs, _super);
    function Tabs(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('ul', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Tabs;
}(___wml.AppView));
exports.Tabs = Tabs;

},{"@quenk/wml":162}],98:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var control_1 = require("@package/self/control");
/**
 * TextChangedEvent
 */
var TextChangedEvent = /** @class */ (function (_super) {
    __extends(TextChangedEvent, _super);
    function TextChangedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return TextChangedEvent;
}(control_1.Event));
exports.TextChangedEvent = TextChangedEvent;

},{"@package/self/control":75}],99:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/text-field");
var util_1 = require("@package/self/common/util");
var control_1 = require("@package/self/control");
var TextChangedEvent_1 = require("./TextChangedEvent");
/**
 * TextField
 */
var TextField = /** @class */ (function (_super) {
    __extends(TextField, _super);
    function TextField() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: {
                id: 'root',
                class: util_1.concat('form-group', _this.attrs.ww.class, _this.state()),
            },
            help: {
                id: 'message',
                success: _this.attrs.ww.success,
                error: _this.attrs.ww.error,
                warning: _this.attrs.ww.warning
            },
            label: {
                id: _this.attrs.ww.name,
                text: _this.attrs.ww.label || ''
            },
            input: {
                id: 'input',
                class: 'form-control',
                name: _this.attrs.ww.name,
                type: _this.attrs.ww.type || 'text',
                placeholder: _this.attrs.ww.placeholder || '',
                value: _this.attrs.ww.value || '',
                disabled: (_this.attrs.ww.disabled === true) ? true : null,
                readOnly: (_this.attrs.ww.readOnly === true) ? true : null,
                rows: _this.attrs.ww.rows || 1,
                onInput: function (e) { return _this.delegate.onChange(new TextChangedEvent_1.TextChangedEvent(_this.attrs.ww.name, e.target.value)); }
            }
        };
        return _this;
    }
    return TextField;
}(control_1.FormControl));
exports.TextField = TextField;

},{"./TextChangedEvent":98,"./wml/text-field":101,"@package/self/common/util":50,"@package/self/control":75}],100:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var TextField_1 = require("./TextField");
exports.TextField = TextField_1.TextField;
var TextChangedEvent_1 = require("./TextChangedEvent");
exports.TextChangedEvent = TextChangedEvent_1.TextChangedEvent;

},{"./TextChangedEvent":98,"./TextField":99}],101:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
;
var wml_1 = require("@package/self/control/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.domify(wml_1.label(___context.values.label.id, ___context.values.label.text)(___view)), ((___context.values.input.rows === 1)) ? ___wml.node('input', {
                    html: {
                        'name': ___context.values.input.name,
                        'type': ___context.values.input.type,
                        'placeholder': ___context.values.input.placeholder,
                        'oninput': ___context.values.input.onInput,
                        'value': ___context.values.input.value,
                        'disabled': ___context.values.input.disabled,
                        'readonly': ___context.values.input.readOnly,
                        'class': ___context.values.input.class
                    },
                    wml: {
                        'id': "input"
                    }
                }, [], ___view) : ___wml.node('textarea', {
                    html: {
                        'name': ___context.values.input.name,
                        'placeholder': ___context.values.input.placeholder,
                        'oninput': ___context.values.input.onInput,
                        'disabled': ___context.values.input.disabled,
                        'readonly': ___context.values.input.readOnly,
                        'rows': ___context.values.input.rows,
                        'class': ___context.values.input.class
                    },
                    wml: {
                        'id': "input"
                    }
                }, [___wml.domify(___context.values.input.value)], ___view), ___wml.domify(wml_1.message(___context.values.help.id, ___context.values.help)(___view))], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/control/wml":102,"@quenk/wml":162}],102:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
exports.label = function (id, text) { return function (___view) { return ___wml.node('label', {
    html: {
        'for': id,
        'class': "control-label"
    },
    wml: {}
}, [___wml.domify(text)], ___view); }; };
;
exports.message = function (id, m) { return function (___view) { return ___wml.box(___wml.domify(console.error(m)), (m.success) ? ___wml.node('span', {
    html: {
        'class': "help-text"
    },
    wml: {
        'id': id
    }
}, [___wml.domify(m.success)], ___view) : (m.error) ? ___wml.node('span', {
    html: {
        'class': "help-text"
    },
    wml: {
        'id': id
    }
}, [___wml.domify(m.error)], ___view) : (m.warning) ? ___wml.node('span', {
    html: {
        'class': "help-text"
    },
    wml: {
        'id': id
    }
}, [___wml.domify(m.warning)], ___view) : ___wml.node('span', {
    html: {
        'class': "help-text"
    },
    wml: {
        'id': id
    }
}, [], ___view)); }; };

},{"@quenk/wml":162}],103:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var Group_1 = require("@package/self/content/Group");
var aside_1 = require("./wml/aside");
/**
 * Aside provides a widget for displaying navigation and other sidebar content.
 *
 * It's api allows for toggling between hidden and shown states as well as querying the
 * current state.
 *
 * This widget's style intentionally gives it a high z-index so that it appears in-front
 * of other content. Adjust the respective style variables to change.
 */
var Aside = /** @class */ (function (_super) {
    __extends(Aside, _super);
    function Aside() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * values is a hash of values used in the template
         */
        _this.values = {
            id: {
                root: 'aside',
            },
            class: {
                root: names.ASIDE,
                content: names.ASIDE_CONTENT
            },
            attrs: {
                content: 'ww:content'
            },
            content: (_this.attrs.ww && _this.attrs.ww.content) ? _this.attrs.ww.content : null
        };
        _this.view = new aside_1.Main(_this);
        return _this;
    }
    Aside.prototype._getDrawerDOM = function (f) {
        return this.view.findById(this.values.id.root).cata(function () { return null; }, f);
    };
    /**
     * visible queries whether the Drawer is visible or not.
     */
    Aside.prototype.visible = function () {
        return !this._getDrawerDOM(function (e) { return e.classList.contains(names.HIDDEN); });
    };
    /**
     * hide the drawer.
     */
    Aside.prototype.hide = function () {
        if (this.visible())
            this._getDrawerDOM(function (e) { return e.classList.add(names.HIDDEN); });
    };
    /**
     * showDrawer shows the drawer
     */
    Aside.prototype.show = function () {
        if (!this.visible())
            this._getDrawerDOM(function (e) { return e.classList.remove(names.HIDDEN); });
    };
    /**
     * toggle the visibility of this Drawer
     */
    Aside.prototype.toggle = function () {
        this._getDrawerDOM(function (e) { return e.classList.toggle(names.HIDDEN); });
    };
    return Aside;
}(Group_1.Group));
exports.Aside = Aside;

},{"./wml/aside":104,"@package/self/common/names":49,"@package/self/content/Group":51}],104:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {
                    'id': ___context.values.id.root
                }
            }, [___wml.node('div', {
                    html: {
                        'class': ___context.values.class.content
                    },
                    wml: {}
                }, [(___context.values.content) ? ___wml.domify(___context.values.content.render()) : ___wml.domify(___context.children)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":162}],105:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Group_1 = require("@package/self/content/Group");
var names = require("@package/self/common/names");
var drawer_1 = require("./wml/drawer");
;
/**
 * Drawer provides a 2 column application layout with the first typically used as navaigation
 * and the second main application content.
 *
 * ```wml
 *
 *  <Drawer
 *   wml:id="layout"
 *   content={{this.getContent()}} />
 *
 * ```
 */
var Drawer = /** @class */ (function (_super) {
    __extends(Drawer, _super);
    function Drawer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new drawer_1.Main(_this);
        /**
         * values is a hash of values used in the template.
         */
        _this.values = {
            id: {
                root: 'content',
                drawer: 'drawer'
            },
            class: {
                root: names.DRAWER,
            },
            attrs: {
                DRAWER: 'ww:drawer',
                CONTENT: 'ww:content'
            },
            aside: {
                content: (_this.attrs.ww && _this.attrs.ww.drawer) ? _this.attrs.ww.drawer : null
            },
            content: (_this.attrs.ww && _this.attrs.ww.content) ? _this.attrs.ww.content : null
        };
        return _this;
    }
    Drawer.prototype._getAside = function (f) {
        return this.view.findById(this.values.id.drawer).cata(function () { return null; }, f);
    };
    Drawer.prototype._combine = function (classes) {
        return classes.join(' ');
    };
    /**
     * drawerVisible queries whether the Aside is visible or not.
     */
    Drawer.prototype.drawerVisible = function () {
        return this._getAside(function (a) { return a.visible(); });
    };
    /**
     * hideDrawer hides the drawer.
     */
    Drawer.prototype.hideDrawer = function () {
        return this._getAside(function (a) { return a.hide(); });
    };
    /**
     * showDrawer shows the drawer
     */
    Drawer.prototype.showDrawer = function () {
        return this._getAside(function (a) { return a.show(); });
    };
    /**
     * toggle the visibility of the Aside.
     */
    Drawer.prototype.toggleDrawer = function () {
        return this._getAside(function (a) { return a.toggle(); });
    };
    return Drawer;
}(Group_1.Group));
exports.Drawer = Drawer;

},{"./wml/drawer":106,"@package/self/common/names":49,"@package/self/content/Group":51}],106:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Aside_1 = require("@package/self/layout/aside/Aside");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {
                    'id': ___context.values.id.root
                }
            }, [___wml.widget(Aside_1.Aside, {
                    html: {},
                    wml: {
                        'id': ___context.values.id.drawer
                    },
                    ww: {
                        'content': ___context.values.aside.content
                    }
                }, [], ___view), (___context.content) ? ___wml.domify(___context.content) : (___context.values.content) ? ___wml.domify(___context.values.content.render()) : ___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/layout/aside/Aside":103,"@quenk/wml":162}],107:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/views");
var wml_1 = require("@quenk/wml");
var Fragment = /** @class */ (function (_super) {
    __extends(Fragment, _super);
    function Fragment() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(null);
        return _this;
    }
    Fragment.prototype.render = function () {
        var frag = document.createDocumentFragment();
        this.children.forEach(function (c) { return frag.appendChild(c); });
        return frag;
    };
    return Fragment;
}(wml_1.Component));
exports.Fragment = Fragment;

},{"./wml/views":108,"@quenk/wml":162}],108:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('fragment', {
                html: {},
                wml: {}
            }, [], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":162}],109:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var views = require("./wml/grid");
var wml_1 = require("@quenk/wml");
var util_1 = require("@package/self/common/util");
;
/**
 * Grid
 */
var Grid = /** @class */ (function (_super) {
    __extends(Grid, _super);
    function Grid() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Grid(_this);
        _this.values = {
            class: {
                root: util_1.concat(names.GRID, (_this.attrs.ww && _this.attrs.ww.class) ?
                    _this.attrs.ww.class : '')
            }
        };
        return _this;
    }
    return Grid;
}(wml_1.Component));
exports.Grid = Grid;
var Row = /** @class */ (function (_super) {
    __extends(Row, _super);
    function Row() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Row(_this);
        _this.values = {
            class: {
                root: util_1.concat(names.GRID_ROW, (_this.attrs.ww && _this.attrs.ww.class) ?
                    _this.attrs.ww.class : '')
            }
        };
        return _this;
    }
    return Row;
}(wml_1.Component));
exports.Row = Row;
var Column = /** @class */ (function (_super) {
    __extends(Column, _super);
    function Column() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Column(_this);
        _this.values = {
            class: {
                root: _this.attrs.ww ? util_1.concat(_this.attrs.ww.size ?
                    "col-md-" + _this.attrs.ww.size : 'col-md-12', _this.attrs.ww.class) : 'col-md-12'
            }
        };
        return _this;
    }
    return Column;
}(wml_1.Component));
exports.Column = Column;

},{"./wml/grid":110,"@package/self/common/names":49,"@package/self/common/util":50,"@quenk/wml":162}],110:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Grid = /** @class */ (function (_super) {
    __extends(Grid, _super);
    function Grid(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('section', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Grid;
}(___wml.AppView));
exports.Grid = Grid;
;
var Row = /** @class */ (function (_super) {
    __extends(Row, _super);
    function Row(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Row;
}(___wml.AppView));
exports.Row = Row;
;
var Column = /** @class */ (function (_super) {
    __extends(Column, _super);
    function Column(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Column;
}(___wml.AppView));
exports.Column = Column;

},{"@quenk/wml":162}],111:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml = require("@quenk/wml");
var views = require("./wml/list-group");
var names = require("@package/self/common/names");
/**
 * ListGroup is used to create a vertical list of content.
 *
 * Children must be ListGroupItems.
 */
var ListGroup = /** @class */ (function (_super) {
    __extends(ListGroup, _super);
    function ListGroup() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: {
                class: names.LIST_GROUP
            }
        };
        return _this;
    }
    return ListGroup;
}(wml.Component));
exports.ListGroup = ListGroup;

},{"./wml/list-group":115,"@package/self/common/names":49,"@quenk/wml":162}],112:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/list-group-item");
var wml = require("@quenk/wml");
var names = require("@package/self/common/names");
/**
 * ListGroupItem
 */
var ListGroupItem = /** @class */ (function (_super) {
    __extends(ListGroupItem, _super);
    function ListGroupItem() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: {
                class: names.LIST_GROUP_ITEM
            }
        };
        return _this;
    }
    return ListGroupItem;
}(wml.Component));
exports.ListGroupItem = ListGroupItem;

},{"./wml/list-group-item":114,"@package/self/common/names":49,"@quenk/wml":162}],113:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ListGroup_1 = require("./ListGroup");
exports.ListGroup = ListGroup_1.ListGroup;
var ListGroupItem_1 = require("./ListGroupItem");
exports.ListGroupItem = ListGroupItem_1.ListGroupItem;

},{"./ListGroup":111,"./ListGroupItem":112}],114:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('li', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":162}],115:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('ul', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":162}],116:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/main");
var names = require("@package/self/common/names");
var util_1 = require("@package/self/common/util");
var Group_1 = require("@package/self/content/Group");
/**
 * Main provides a container for the main content of an application.
 */
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            class: {
                root: util_1.concat(names.MAIN_VIEW, names.PUSHABLE, _this.attrs.ww ? _this.attrs.ww.class : '')
            }
        };
        return _this;
    }
    return Main;
}(Group_1.Group));
exports.Main = Main;

},{"./wml/main":117,"@package/self/common/names":49,"@package/self/common/util":50,"@package/self/content/Group":51}],117:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":162}],118:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var views = require("./wml/panel");
var wml_1 = require("@quenk/wml");
var util_1 = require("@package/self/common/util");
var Panel = /** @class */ (function (_super) {
    __extends(Panel, _super);
    function Panel() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Panel(_this);
        _this.values = {
            class: {
                root: util_1.concat(names.PANEL, _this.attrs.ww ?
                    _this.attrs.ww.style : names.DEFAULT, _this.attrs.ww ?
                    _this.attrs.ww.class : '')
            }
        };
        return _this;
    }
    return Panel;
}(wml_1.Component));
exports.Panel = Panel;
var Header = /** @class */ (function (_super) {
    __extends(Header, _super);
    function Header() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Header(_this);
        _this.values = {
            class: {
                root: util_1.concat(names.PANEL_HEADER, _this.attrs.ww ? _this.attrs.ww.class : '')
            }
        };
        return _this;
    }
    return Header;
}(wml_1.Component));
exports.Header = Header;
var Body = /** @class */ (function (_super) {
    __extends(Body, _super);
    function Body() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Body(_this);
        _this.values = {
            class: {
                root: util_1.concat(names.PANEL_BODY, _this.attrs.ww ? _this.attrs.ww.class : '')
            }
        };
        return _this;
    }
    return Body;
}(wml_1.Component));
exports.Body = Body;
var Footer = /** @class */ (function (_super) {
    __extends(Footer, _super);
    function Footer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Footer(_this);
        _this.values = {
            class: {
                root: util_1.concat(names.PANEL_FOOTER, _this.attrs.ww ? _this.attrs.ww.class : '')
            }
        };
        return _this;
    }
    return Footer;
}(wml_1.Component));
exports.Footer = Footer;

},{"./wml/panel":119,"@package/self/common/names":49,"@package/self/common/util":50,"@quenk/wml":162}],119:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Panel = /** @class */ (function (_super) {
    __extends(Panel, _super);
    function Panel(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Panel;
}(___wml.AppView));
exports.Panel = Panel;
;
var Header = /** @class */ (function (_super) {
    __extends(Header, _super);
    function Header(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Header;
}(___wml.AppView));
exports.Header = Header;
;
var Body = /** @class */ (function (_super) {
    __extends(Body, _super);
    function Body(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Body;
}(___wml.AppView));
exports.Body = Body;
;
var Footer = /** @class */ (function (_super) {
    __extends(Footer, _super);
    function Footer(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Footer;
}(___wml.AppView));
exports.Footer = Footer;

},{"@quenk/wml":162}],120:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var views = require("./wml/divider");
var wml = require("@quenk/wml");
/**
 * Divider
 */
var Divider = /** @class */ (function (_super) {
    __extends(Divider, _super);
    function Divider() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            class: {
                root: names.MENU_DIVIDER
            }
        };
        return _this;
    }
    return Divider;
}(wml.Component));
exports.Divider = Divider;

},{"./wml/divider":129,"@package/self/common/names":49,"@quenk/wml":162}],121:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var views = require("./wml/header");
var wml = require("@quenk/wml");
var util_1 = require("@package/self/common/util");
/**
 * Header
 */
var Header = /** @class */ (function (_super) {
    __extends(Header, _super);
    function Header() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            class: {
                root: util_1.concat(names.MENU_HEADER, _this.attrs.ww ? _this.attrs.ww.class : '')
            },
            text: (_this.attrs.ww && _this.attrs.ww.text) ?
                _this.attrs.ww.text : null
        };
        return _this;
    }
    return Header;
}(wml.Component));
exports.Header = Header;

},{"./wml/header":130,"@package/self/common/names":49,"@package/self/common/util":50,"@quenk/wml":162}],122:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml = require("@quenk/wml");
var names = require("@package/self/common/names");
var util_1 = require("@package/self/common/util");
var menu_1 = require("./wml/menu");
/**
 * Menu
 */
var Menu = /** @class */ (function (_super) {
    __extends(Menu, _super);
    function Menu() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new menu_1.Main(_this);
        _this.values = {
            id: {
                root: 'root',
                target: 'menu'
            },
            class: {
                root: util_1.concat(names.MENU, (_this.attrs.ww && _this.attrs.ww.class) ?
                    _this.attrs.ww.class : '', (_this.attrs.ww && _this.attrs.ww.hidden) ?
                    names.HIDDEN : '')
            },
            content: _this.children,
            click: {
                hideOnClick: (_this.attrs.ww && (_this.attrs.ww.hideOnClick != null)) ?
                    _this.attrs.ww.hideOnClick : true,
                hideOnExternalClick: (_this.attrs.ww && (_this.attrs.ww.hideOnExternalClick != null)) ?
                    _this.attrs.ww.hideOnExternalClick : true
            }
        };
        return _this;
    }
    /**
     * isHidden
     */
    Menu.prototype.isHidden = function () {
        return this.view.findById(this.values.id.root)
            .cata(function () { return false; }, function (e) { return e.classList.contains(names.HIDDEN); });
    };
    /**
     * hide the menu.
     */
    Menu.prototype.hide = function () {
        this.view.findById(this.values.id.root)
            .map(function (e) {
            return e.classList.add(names.HIDDEN);
        });
        return this;
    };
    /**
     * show this menu.
     */
    Menu.prototype.show = function () {
        this.view.findById(this.values.id.root)
            .map(function (e) {
            return e.classList.remove(names.HIDDEN);
        });
        return this;
    };
    /**
     * toggle this menu's visibility
     */
    Menu.prototype.toggle = function () {
        this.view.findById(this.values.id.root)
            .map(function (e) {
            return e.classList.toggle(names.HIDDEN);
        });
        return this;
    };
    /**
     * setContent of this menu.
     */
    Menu.prototype.setContent = function (view) {
        this.values.content = [view.render()];
        this.view.invalidate();
        return this;
    };
    Menu.prototype.handleEvent = function (e) {
        var _this = this;
        this
            .view
            .findById(this.values.id.root)
            .map(function (root) {
            if (!document.body.contains(root))
                document.removeEventListener('click', _this);
            if ((!root.contains(e.target)) && _this.values.click.hideOnExternalClick)
                _this.hide();
        });
    };
    Menu.prototype.rendered = function () {
        //window.addEventListener('click', this);
    };
    return Menu;
}(wml.Component));
exports.Menu = Menu;

},{"./wml/menu":132,"@package/self/common/names":49,"@package/self/common/util":50,"@quenk/wml":162}],123:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var views = require("./wml/menu-item");
var wml = require("@quenk/wml");
var util_1 = require("@package/self/common/util");
var MenuItemClickedEvent_1 = require("./MenuItemClickedEvent");
/**
 * MenuItem
 */
var MenuItem = /** @class */ (function (_super) {
    __extends(MenuItem, _super);
    function MenuItem() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            id: {
                root: 'root'
            },
            class: {
                root: util_1.concat(names.MENU_ITEM, (_this.attrs.ww && _this.attrs.ww.disabled) ?
                    names.DISABLED : null)
            },
            text: (_this.attrs.ww && _this.attrs.ww.text) ?
                _this.attrs.ww.text : null,
            clicked: function () { return (_this.attrs.ww && _this.attrs.ww.onClick) ?
                _this.attrs.ww.onClick(new MenuItemClickedEvent_1.MenuItemClickedEvent(_this.attrs.ww.name)) : function () { }; }
        };
        return _this;
    }
    return MenuItem;
}(wml.Component));
exports.MenuItem = MenuItem;

},{"./MenuItemClickedEvent":124,"./wml/menu-item":131,"@package/self/common/names":49,"@package/self/common/util":50,"@quenk/wml":162}],124:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * MenuItemClickedEvent indicates a menu item has been clicked.
 */
var MenuItemClickedEvent = /** @class */ (function () {
    function MenuItemClickedEvent(name) {
        this.name = name;
    }
    return MenuItemClickedEvent;
}());
exports.MenuItemClickedEvent = MenuItemClickedEvent;

},{}],125:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml = require("@quenk/wml");
var names = require("@package/self/common/names");
var views = require("./wml/button-menu");
var util_1 = require("@package/self/common/util");
/**
 * ButtonMenu
 */
var ButtonMenu = /** @class */ (function (_super) {
    __extends(ButtonMenu, _super);
    function ButtonMenu() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this._buttonTemplate = _this.attrs.ww.buttonTemplate ?
            _this.attrs.ww.buttonTemplate : views.button;
        _this.values = {
            id: {
                root: 'root',
                target: 'menu'
            },
            root: {
                class: util_1.concat(names.BUTTON_MENU, (_this.attrs.ww && _this.attrs.ww.class) ?
                    _this.attrs.ww.class : '')
            },
            button: {
                text: _this.attrs.ww.text ? _this.attrs.ww.text : '',
                template: _this._buttonTemplate,
                class: names.BUTTON_MENU_BUTTON,
                onClick: function () { _this.view.findById(_this.values.menu.id).map(function (m) { return m.toggle(); }); }
            },
            menu: {
                id: 'menu',
                content: _this.attrs.ww.content ? _this.attrs.ww.content : _this.children
            }
        };
        return _this;
    }
    /**
     * hide the menu.
     */
    ButtonMenu.prototype.hide = function () {
        this.view.findById(this.values.menu.id)
            .map(function (m) { return m.hide(); });
        return this;
    };
    /**
     * show the menu.
     */
    ButtonMenu.prototype.show = function () {
        this.view.findById(this.values.menu.id)
            .map(function (m) { return m.show(); });
        return this;
    };
    /**
     * toggle the menu.
     */
    ButtonMenu.prototype.toggle = function () {
        this.view.findById(this.values.menu.id)
            .map(function (m) { return m.toggle(); });
        return this;
    };
    /**
     * setContent of this menu.
     */
    ButtonMenu.prototype.setContent = function (view) {
        this.values.menu.content = [view.render()];
        this.view.invalidate();
        return this;
    };
    return ButtonMenu;
}(wml.Component));
exports.ButtonMenu = ButtonMenu;

},{"./wml/button-menu":127,"@package/self/common/names":49,"@package/self/common/util":50,"@quenk/wml":162}],126:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ButtonMenu_1 = require("./ButtonMenu");
exports.ButtonMenu = ButtonMenu_1.ButtonMenu;

},{"./ButtonMenu":125}],127:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Menu_1 = require("@package/self/menu/Menu");
;
exports.button = function () { return function (___context) { return function (___view) { return ___wml.node('button', {
    html: {
        'class': ___context.values.button.class,
        'type': "button",
        'onclick': ___context.values.button.onClick
    },
    wml: {}
}, [___wml.domify(___context.values.button.text)], ___view); }; }; };
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.domify(___context.values.button.template()(___context)(___view)), ___wml.widget(Menu_1.Menu, {
                    html: {},
                    wml: {
                        'id': ___context.values.menu.id
                    },
                    ww: {
                        'hidden': true
                    }
                }, [___wml.domify(___context.values.menu.content)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/menu/Menu":122,"@quenk/wml":162}],128:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Divider_1 = require("./Divider");
exports.Divider = Divider_1.Divider;
var Header_1 = require("./Header");
exports.Header = Header_1.Header;
var MenuItem_1 = require("./MenuItem");
exports.MenuItem = MenuItem_1.MenuItem;
var MenuItemClickedEvent_1 = require("./MenuItemClickedEvent");
exports.MenuItemClickedEvent = MenuItemClickedEvent_1.MenuItemClickedEvent;
var Menu_1 = require("./Menu");
exports.Menu = Menu_1.Menu;

},{"./Divider":120,"./Header":121,"./Menu":122,"./MenuItem":123,"./MenuItemClickedEvent":124}],129:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('li', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":162}],130:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('li', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [(___context.values.text) ? ___wml.domify(___context.values.text) : ___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":162}],131:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('li', {
                html: {
                    'class': ___context.values.class.root,
                    'onclick': ___context.values.clicked
                },
                wml: {}
            }, [(___context.values.text) ? ___wml.domify(___context.values.text) : ___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":162}],132:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('ul', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [___wml.domify(___context.values.content)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":162}],133:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var views = require("./wml/breadcrumbs");
var util_1 = require("@package/self/common/util");
var wml_1 = require("@quenk/wml");
;
/**
 * BreadCrumb
 */
var BreadCrumbs = /** @class */ (function (_super) {
    __extends(BreadCrumbs, _super);
    function BreadCrumbs() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.BreadCrumbs(_this);
        _this.values = {
            class: {
                root: util_1.concat(names.BREAD_CRUMBS, _this.attrs.ww ? _this.attrs.ww.class : '')
            }
        };
        return _this;
    }
    return BreadCrumbs;
}(wml_1.Component));
exports.BreadCrumbs = BreadCrumbs;

},{"./wml/breadcrumbs":135,"@package/self/common/names":49,"@package/self/common/util":50,"@quenk/wml":162}],134:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var views = require("./wml/breadcrumbs");
var wml_1 = require("@quenk/wml");
/**
 * Item for breadcrumb lists.
 */
var Item = /** @class */ (function (_super) {
    __extends(Item, _super);
    function Item() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Item(_this);
        _this.values = {
            class: {
                root: names.BREAD_CRUMBS_ITEM
            }
        };
        return _this;
    }
    return Item;
}(wml_1.Component));
exports.Item = Item;

},{"./wml/breadcrumbs":135,"@package/self/common/names":49,"@quenk/wml":162}],135:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
;
var BreadCrumbs = /** @class */ (function (_super) {
    __extends(BreadCrumbs, _super);
    function BreadCrumbs(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('ol', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return BreadCrumbs;
}(___wml.AppView));
exports.BreadCrumbs = BreadCrumbs;
;
var Item = /** @class */ (function (_super) {
    __extends(Item, _super);
    function Item(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('li', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Item;
}(___wml.AppView));
exports.Item = Item;

},{"@quenk/wml":162}],136:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml = require("@quenk/wml");
var names = require("@package/self/common/names");
var views = require("./wml/link");
var LinkClickedEvent_1 = require("./LinkClickedEvent");
var util_1 = require("@package/self/common/util");
/**
 * Link generates an <a> element.
 */
var Link = /** @class */ (function (_super) {
    __extends(Link, _super);
    function Link() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        /**
         * name assigned to this Link.
         */
        _this.name = (_this.attrs.ww && _this.attrs.ww.name) ?
            _this.attrs.ww.name : '';
        /**
         * title assigned to this Link.
         */
        _this.title = (_this.attrs.ww && _this.attrs.ww.title) ?
            _this.attrs.ww.title : '';
        /**
         * href assigned to this link
         */
        _this.href = (_this.attrs.ww && _this.attrs.ww.href) ?
            _this.attrs.ww.href : '';
        _this.values = {
            id: {
                root: 'root'
            },
            class: {
                root: util_1.concat(names.NAV_LINK, _this.attrs.ww ? _this.attrs.ww.class : '', (_this.attrs.ww && _this.attrs.ww.active) ?
                    names.ACTIVE : '')
            },
            a: {
                title: (_this.attrs.ww && _this.attrs.ww.title) ?
                    _this.attrs.ww.title : null,
                name: (_this.attrs.ww && _this.attrs.ww.name) ?
                    _this.attrs.ww.name : null,
                href: (_this.attrs.ww && _this.attrs.ww.href) ?
                    _this.attrs.ww.href : '#',
                active: (_this.attrs.ww && _this.attrs.ww.active) ?
                    _this.attrs.ww.active : false,
                text: (_this.attrs.ww && _this.attrs.ww.text) ?
                    _this.attrs.ww.text : ''
            }
        };
        _this.clicked = function (e) {
            if (_this.attrs.ww) {
                var _a = _this.attrs.ww, name_1 = _a.name, href = _a.href, onClick = _a.onClick;
                if (!href)
                    e.preventDefault();
                if (onClick)
                    onClick(new LinkClickedEvent_1.LinkClickedEvent(name_1, href));
            }
        };
        return _this;
    }
    /**
      * activate this nav list Item.
      */
    Link.prototype.activate = function () {
        this.view.findById(this.values.id.root)
            .map(function (w) {
            w.classList.remove(names.ACTIVE);
            w.classList.add(names.ACTIVE);
        });
    };
    /**
     * inactivate this nav list item.
     */
    Link.prototype.inactivate = function () {
        this.view.findById(this.values.id.root)
            .map(function (w) { return w.classList.remove(names.ACTIVE); });
    };
    return Link;
}(wml.Component));
exports.Link = Link;

},{"./LinkClickedEvent":137,"./wml/link":139,"@package/self/common/names":49,"@package/self/common/util":50,"@quenk/wml":162}],137:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * LinkClickedEvent indicates a link has been clicked.
 */
var LinkClickedEvent = /** @class */ (function () {
    function LinkClickedEvent(name, href) {
        this.name = name;
        this.href = href;
    }
    return LinkClickedEvent;
}());
exports.LinkClickedEvent = LinkClickedEvent;

},{}],138:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Link_1 = require("./Link");
exports.Link = Link_1.Link;
var LinkClickedEvent_1 = require("./LinkClickedEvent");
exports.LinkClickedEvent = LinkClickedEvent_1.LinkClickedEvent;

},{"./Link":136,"./LinkClickedEvent":137}],139:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('a', {
                html: {
                    'class': ___context.values.class.root,
                    'href': ___context.values.a.href,
                    'title': ___context.values.a.title,
                    'onclick': ___context.clicked
                },
                wml: {}
            }, [(___context.values.a.text) ? ___wml.domify(___context.values.a.text) : ___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":162}],140:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var views = require("./wml/header");
var wml = require("@quenk/wml");
var util_1 = require("@package/self/common/util");
/**
 * Header can be used to display non-clickable heading text in a nav list.
 */
var Header = /** @class */ (function (_super) {
    __extends(Header, _super);
    function Header() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            item: {
                class: ''
            },
            span: {
                class: util_1.concat(names.NAV_MENU_HEADER, _this.attrs.ww ? _this.attrs.ww.class : '')
            },
            text: (_this.attrs.ww && _this.attrs.ww.text) ?
                _this.attrs.ww.text : null
        };
        return _this;
    }
    return Header;
}(wml.Component));
exports.Header = Header;

},{"./wml/header":147,"@package/self/common/names":49,"@package/self/common/util":50,"@quenk/wml":162}],141:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var views = require("./wml/item");
var wml = require("@quenk/wml");
var util_1 = require("@package/self/common/util");
/**
 * Item wraps content in a navigation list.
 *
 * Items should not have any siblings that are not other Items.
 */
var Item = /** @class */ (function (_super) {
    __extends(Item, _super);
    function Item() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            id: {
                root: 'root'
            },
            class: {
                root: util_1.concat(names.NAV_MENU_ITEM, (_this.attrs.ww && _this.attrs.ww.active) ? names.ACTIVE : null)
            },
            text: (_this.attrs.ww && _this.attrs.ww.text) ?
                _this.attrs.ww.text : null
        };
        return _this;
    }
    /**
     * activate this nav list Item.
     */
    Item.prototype.activate = function () {
        this.view.findById(this.values.id.root)
            .map(function (w) {
            w.classList.remove(names.ACTIVE);
            w.classList.add(names.ACTIVE);
        });
    };
    /**
     * inactivate this nav list item.
     */
    Item.prototype.inactivate = function () {
        this.view.findById(this.values.id.root)
            .map(function (w) { return w.classList.remove(names.ACTIVE); });
    };
    return Item;
}(wml.Component));
exports.Item = Item;

},{"./wml/item":148,"@package/self/common/names":49,"@package/self/common/util":50,"@quenk/wml":162}],142:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * ItemClickedEvent is fired when the user clicks on an item in
 * a nav list.
 */
var ItemClickedEvent = /** @class */ (function () {
    function ItemClickedEvent(name) {
        this.name = name;
    }
    return ItemClickedEvent;
}());
exports.ItemClickedEvent = ItemClickedEvent;

},{}],143:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var link = require("@package/self/nav/link");
var names = require("@package/self/common/names");
var views = require("./wml/link");
var util_1 = require("@package/self/common/util");
/**
 * Link provides a link entry into a nav menu.
 */
var Link = /** @class */ (function (_super) {
    __extends(Link, _super);
    function Link() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            id: { root: '' },
            class: { root: '' },
            item: {
                class: util_1.concat(names.NAV_MENU_ITEM, (_this.attrs.ww && _this.attrs.ww.active) ? names.ACTIVE : '')
            },
            a: {
                class: util_1.concat((_this.attrs.ww && _this.attrs.ww.active) ?
                    names.ACTIVE : ''),
                title: (_this.attrs.ww && _this.attrs.ww.title) ?
                    _this.attrs.ww.title : '',
                name: (_this.attrs.ww && _this.attrs.ww.name) ?
                    _this.attrs.ww.name : '',
                href: (_this.attrs.ww && _this.attrs.ww.href) ?
                    _this.attrs.ww.href : '#',
                active: (_this.attrs.ww && _this.attrs.ww.active) ?
                    _this.attrs.ww.active : false,
                text: (_this.attrs.ww && _this.attrs.ww.text) ?
                    _this.attrs.ww.text : '',
                onClick: (_this.attrs.ww && _this.attrs.ww.onClick) ?
                    _this.attrs.ww.onClick : null
            }
        };
        return _this;
    }
    return Link;
}(link.Link));
exports.Link = Link;

},{"./wml/link":149,"@package/self/common/names":49,"@package/self/common/util":50,"@package/self/nav/link":138}],144:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var util = require("@package/self/common/util");
var views = require("./wml/menu");
var wml = require("@quenk/wml");
/**
 * Menu of navigation links.
 */
var Menu = /** @class */ (function (_super) {
    __extends(Menu, _super);
    function Menu() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            class: {
                root: util.concat(names.NAV_MENU, _this.attrs.ww ? _this.attrs.ww.class : '')
            }
        };
        return _this;
    }
    return Menu;
}(wml.Component));
exports.Menu = Menu;

},{"./wml/menu":150,"@package/self/common/names":49,"@package/self/common/util":50,"@quenk/wml":162}],145:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/sub-menu");
var Menu_1 = require("./Menu");
/**
 * SubMenu is used for nested menus.
 */
var SubMenu = /** @class */ (function (_super) {
    __extends(SubMenu, _super);
    function SubMenu() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        return _this;
    }
    return SubMenu;
}(Menu_1.Menu));
exports.SubMenu = SubMenu;

},{"./Menu":144,"./wml/sub-menu":151}],146:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Item_1 = require("./Item");
exports.Item = Item_1.Item;
var ItemClickedEvent_1 = require("./ItemClickedEvent");
exports.ItemClickedEvent = ItemClickedEvent_1.ItemClickedEvent;
var Menu_1 = require("./Menu");
exports.Menu = Menu_1.Menu;
var SubMenu_1 = require("./SubMenu");
exports.SubMenu = SubMenu_1.SubMenu;
var Header_1 = require("./Header");
exports.Header = Header_1.Header;
var Link_1 = require("./Link");
exports.Link = Link_1.Link;

},{"./Header":140,"./Item":141,"./ItemClickedEvent":142,"./Link":143,"./Menu":144,"./SubMenu":145}],147:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Item_1 = require("../Item");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Item_1.Item, {
                html: {},
                wml: {},
                ww: {
                    'class': ___context.values.item.class
                }
            }, [___wml.node('span', {
                    html: {
                        'class': ___context.values.span.class
                    },
                    wml: {}
                }, [(___context.values.text) ? ___wml.domify(___context.values.text) : ___wml.domify(___context.children)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../Item":141,"@quenk/wml":162}],148:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('li', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [(___context.values.text) ? ___wml.domify(___context.values.text) : ___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":162}],149:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var link_1 = require("@package/self/nav/link");
;
;
var Item_1 = require("../Item");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Item_1.Item, {
                html: {},
                wml: {},
                ww: {
                    'class': ___context.values.item.class
                }
            }, [___wml.widget(link_1.Link, {
                    html: {},
                    wml: {},
                    ww: {
                        'class': ___context.values.a.class,
                        'name': ___context.values.a.name,
                        'title': ___context.values.a.title,
                        'href': ___context.values.a.href,
                        'text': ___context.values.a.text,
                        'active': ___context.values.a.active,
                        'onClick': ___context.values.a.onClick
                    }
                }, [___wml.domify(___context.children)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../Item":141,"@package/self/nav/link":138,"@quenk/wml":162}],150:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('ul', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":162}],151:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
;
var Item_1 = require("../Item");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Item_1.Item, {
                html: {},
                wml: {}
            }, [___wml.node('ul', {
                    html: {
                        'class': ___context.values.class.root
                    },
                    wml: {}
                }, [___wml.domify(___context.children)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../Item":141,"@quenk/wml":162}],152:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * CellClickedEvent is triggered when the whitespace of a cell is clicked.
 */
var CellClickedEvent = /** @class */ (function () {
    function CellClickedEvent(value, name, index, row) {
        this.value = value;
        this.name = name;
        this.index = index;
        this.row = row;
    }
    return CellClickedEvent;
}());
exports.CellClickedEvent = CellClickedEvent;

},{}],153:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * HeadingClicked is triggered when the user clicks on
 * one of the column headings.
 */
var HeadingClickedEvent = /** @class */ (function () {
    function HeadingClickedEvent(name, field) {
        this.name = name;
        this.field = field;
    }
    return HeadingClickedEvent;
}());
exports.HeadingClickedEvent = HeadingClickedEvent;

},{}],154:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * RowClickedEvent is triggered when the user clicks on whitespace in
 * the row of a table.
 */
var RowClickedEvent = /** @class */ (function () {
    function RowClickedEvent(value, index, data) {
        this.value = value;
        this.index = index;
        this.data = data;
    }
    return RowClickedEvent;
}());
exports.RowClickedEvent = RowClickedEvent;

},{}],155:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var RowClickedEvent_1 = require("./RowClickedEvent");
/**
 * RowSelectedEvent is triggered when the checkbox (if displayed) is clicked
 * on for a row.
 */
var RowSelectedEvent = /** @class */ (function (_super) {
    __extends(RowSelectedEvent, _super);
    function RowSelectedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return RowSelectedEvent;
}(RowClickedEvent_1.RowClickedEvent));
exports.RowSelectedEvent = RowSelectedEvent;

},{"./RowClickedEvent":154}],156:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var view = require("./wml/table");
var util_1 = require("@package/self/common/util");
var wml_1 = require("@quenk/wml");
var property_seek_1 = require("property-seek");
var ASC_ARROW = '\u21e7';
var DESC_ARROW = '\u21e9';
exports.dateSort = function (a, b) {
    var na = new Date(a).getTime();
    var nb = new Date(b).getTime();
    return na > nb ? -1 : na < nb ? 1 : 0;
};
exports.stringSort = function (a, b) {
    var la = String(a).replace(/\s+/, '').toLowerCase();
    var lb = String(b).replace(/\s+/, '').toLowerCase();
    return (la > lb) ? -1 : (la < lb) ? 1 : 0;
};
exports.naturalSort = function (a, b) {
    if (a === void 0) { a = ''; }
    if (b === void 0) { b = ''; }
    //Source: http://stackoverflow.com/questions/4340227/sort-mixed-alpha-numeric-array
    var reA = /[^a-zA-Z]/g;
    var reN = /[^0-9]/g;
    var AInt = parseInt(a, 10);
    var BInt = parseInt(b, 10);
    if (isNaN(AInt) && isNaN(BInt)) {
        var aA = a.replace(reA, '');
        var bA = b.replace(reA, '');
        if (aA === bA) {
            var aN = parseInt(a.replace(reN, ''), 10);
            var bN = parseInt(b.replace(reN, ''), 10);
            return aN === bN ? 0 : aN > bN ? -1 : 1;
        }
        else {
            return aA > bA ? -1 : 1;
        }
    }
    else if (isNaN(AInt)) {
        return -1; //to make alphanumeric sort first return -1 here
    }
    else if (isNaN(BInt)) {
        return 1; //to make alphanumeric sort first return 1 here
    }
    else {
        return AInt > BInt ? -1 : 1;
    }
};
exports.numberSort = function (a, b) {
    var na = parseFloat(a);
    var nb = parseFloat(b);
    na = (isNaN(a)) ? -Infinity : a;
    nb = (isNaN(b)) ? -Infinity : b;
    return (na > nb) ? -1 : (na < nb) ? 1 : 0;
};
var DefaultTableModel = /** @class */ (function () {
    function DefaultTableModel(table) {
        this.table = table;
    }
    DefaultTableModel.prototype.allSelected = function () { };
    DefaultTableModel.prototype.cellClicked = function (_e) { };
    DefaultTableModel.prototype.headingClicked = function (_e) { };
    DefaultTableModel.prototype.rowClicked = function (_e) { };
    DefaultTableModel.prototype.rowSelected = function (_e) { };
    return DefaultTableModel;
}());
exports.DefaultTableModel = DefaultTableModel;
var SortTableModel = /** @class */ (function (_super) {
    __extends(SortTableModel, _super);
    function SortTableModel() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SortTableModel.prototype.headingClicked = function (e) { this.table.sort(e.name); };
    return SortTableModel;
}(DefaultTableModel));
exports.SortTableModel = SortTableModel;
/**
 * Table provides a smarter html table.
 */
var Table = /** @class */ (function (_super) {
    __extends(Table, _super);
    function Table() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.originalData = _this.attrs.ww.data;
        _this.view = new view.Table(_this);
        _this.model = _this.attrs.ww.model ?
            _this.attrs.ww.model :
            new SortTableModel(_this);
        _this.values = {
            id: {
                root: 'root',
            },
            class: {
                root: util_1.concat(names.TABLE, _this.attrs.ww.class),
                row: _this.attrs.ww.rowClass || '',
                cell: _this.attrs.ww.cellClass || '',
                heading: _this.attrs.ww.headingClass || ''
            },
            fragment: {
                empty: _this.attrs.ww.empty
            },
            options: {
                selectable: _this.attrs.ww.selectable
            },
            sortedOn: '',
            data: _this.originalData.slice(),
            fields: _this.attrs.ww.fields,
            arrow: ''
        };
        return _this;
    }
    Table.prototype.sort = function (name) {
        var fields = this.attrs.ww ? this.attrs.ww.fields ? this.attrs.ww.fields : [] : [];
        var field = fields.reduce(function (p, c) { return p ? p : (c.name === name ? c : null); });
        var sortOn;
        var strategy;
        if (!field)
            throw new Error("Table#sort: unknown field '" + name + "'");
        sortOn = field.sortAs || name;
        strategy = field.strategy || exports.stringSort;
        if (this.values.sortedOn === name) {
            this.values.data = this.values.data.reverse();
            this.values.arrow = (this.values.arrow === ASC_ARROW) ? DESC_ARROW : ASC_ARROW;
        }
        else {
            this.values.arrow = DESC_ARROW;
            this.values.data = this
                .originalData
                .slice()
                .sort(function (a, b) { return strategy(property_seek_1.get(sortOn, a), property_seek_1.get(sortOn, b)); });
        }
        this.values.sortedOn = name;
        this.view.invalidate();
    };
    /**
     * update the data the table displays
     */
    Table.prototype.update = function (data) {
        this.originalData = data.slice();
        this.values.data = data.slice();
        (this.values.sortedOn === '') ? this.view.invalidate() : this.sort(this.values.sortedOn);
    };
    return Table;
}(wml_1.Component));
exports.Table = Table;

},{"./wml/table":157,"@package/self/common/names":49,"@package/self/common/util":50,"@quenk/wml":162,"property-seek":177}],157:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
;
var names = require("@package/self/common/names");
;
var util_1 = require("@package/self/common/util");
;
var CellClickedEvent_1 = require("../CellClickedEvent");
;
var RowClickedEvent_1 = require("../RowClickedEvent");
;
var RowSelectedEvent_1 = require("../RowSelectedEvent");
;
var HeadingClickedEvent_1 = require("../HeadingClickedEvent");
;
var property_seek_1 = require("property-seek");
;
var Fragment_1 = require("@package/self/layout/fragment/Fragment");
;
exports.allSelectedCheckbox = function () { return function (___context) { return function (___view) { return ___wml.node('th', {
    html: {},
    wml: {}
}, [___wml.node('input', {
        html: {
            'type': "checkbox",
            'onclick': function () { return ___context.model.allSelected(); }
        },
        wml: {}
    }, [], ___view)], ___view); }; }; };
;
exports.headings = function (fields) { return function (___context) { return function (___view) { return ___wml.map(fields, function _map(field) {
    return (field.sortAs) ? ___wml.node('th', {
        html: {
            'class': util_1.concat(___context.values.class.heading, ((___context.values.sortedOn === field.name)) ? names.ACTIVE : ""),
            'onclick': function () { return ___context.model.headingClicked(new HeadingClickedEvent_1.HeadingClickedEvent(field.name, field)); }
        },
        wml: {}
    }, [___wml.domify(field.heading), ((___context.values.sortedOn === field.name)) ? ___wml.domify(___context.values.arrow) : ___wml.domify("")], ___view) : ___wml.node('th', {
        html: {
            'class': util_1.concat(___context.values.class.heading, ((___context.values.sortedOn === field.name)) ? names.ACTIVE : ""),
            'onclick': function () { return ___context.model.headingClicked(new HeadingClickedEvent_1.HeadingClickedEvent(field.name, field)); }
        },
        wml: {}
    }, [___wml.domify(field.heading), ___wml.domify(((___context.values.sortedOn === field.name)) ? ___context.values.arrow : "")], ___view);
}, function otherwise() {
    return document.createDocumentFragment();
}); }; }; };
;
exports.thead = function (fields) { return function (___context) { return function (___view) { return ___wml.node('tr', {
    html: {},
    wml: {}
}, [(___context.values.options.selectable) ? ___wml.box(___wml.domify(exports.allSelectedCheckbox()(___context)(___view)), ___wml.domify(exports.headings(fields)(___context)(___view))) : ___wml.domify(exports.headings(fields)(___context)(___view))], ___view); }; }; };
;
exports.rowSelectCheckbox = function (row, index, data) { return function (___context) { return function (___view) { return (___context.values.options.selectable) ? ___wml.node('td', {
    html: {},
    wml: {}
}, [___wml.node('input', {
        html: {
            'type': "checkbox",
            'onclick': function () { return ___context.model.rowSelected(new RowSelectedEvent_1.RowSelectedEvent(row, index, data)); }
        },
        wml: {}
    }, [], ___view)], ___view) : ___wml.domify(null); }; }; };
;
exports.rows = function (row, index, fields) { return function (___context) { return function (___view) { return ___wml.map(fields, function _map(field) {
    return ___wml.node('td', {
        html: {
            'class': ___context.values.class.cell,
            'onclick': function () { return ___context.model.cellClicked(new CellClickedEvent_1.CellClickedEvent(property_seek_1.get(field.name, row), field.name, index, row)); }
        },
        wml: {}
    }, [(field.fragment) ? ___wml.domify(field.fragment(property_seek_1.get(field.name, row), field.name, row)(___view)) : ___wml.domify(property_seek_1.get(field.name, row))], ___view);
}, function otherwise() {
    return document.createDocumentFragment();
}); }; }; };
;
exports.tbody = function (data, fields) { return function (___context) { return function (___view) { return ___wml.map(data, function _map(row, index) {
    return ___wml.node('tr', {
        html: {
            'class': ___context.values.class.row,
            'onclick': function () { return ___context.model.rowClicked(new RowClickedEvent_1.RowClickedEvent(row, index, data)); }
        },
        wml: {}
    }, [(___context.values.options.selectable) ? ___wml.box(___wml.domify(exports.rowSelectCheckbox(row, index, data)(___context)(___view)), ___wml.domify(exports.rows(row, index, fields)(___context)(___view))) : ___wml.domify(exports.rows(row, index, fields)(___context)(___view))], ___view);
}, function otherwise() {
    return document.createDocumentFragment();
}); }; }; };
;
exports.table = function () { return function (___context) { return function (___view) { return ___wml.node('table', {
    html: {
        'class': ___context.values.class.root
    },
    wml: {
        'id': ___context.values.id.root
    }
}, [___wml.node('thead', {
        html: {},
        wml: {
            'id': "head"
        }
    }, [___wml.domify(exports.thead(___context.values.fields)(___context)(___view))], ___view), ___wml.node('tbody', {
        html: {},
        wml: {
            'id': "body"
        }
    }, [___wml.domify(exports.tbody(___context.values.data, ___context.values.fields)(___context)(___view))], ___view)], ___view); }; }; };
;
var Table = /** @class */ (function (_super) {
    __extends(Table, _super);
    function Table(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Fragment_1.Fragment, {
                html: {},
                wml: {}
            }, [((___context.values.data.length === 0)) ? (___context.values.fragment.empty) ? ___wml.domify(___context.values.fragment.empty.render()) : ___wml.domify(exports.table()(___context)(___view)) : ___wml.domify(exports.table()(___context)(___view))], ___view);
        };
        return _this;
    }
    return Table;
}(___wml.AppView));
exports.Table = Table;

},{"../CellClickedEvent":152,"../HeadingClickedEvent":153,"../RowClickedEvent":154,"../RowSelectedEvent":155,"@package/self/common/names":49,"@package/self/common/util":50,"@package/self/layout/fragment/Fragment":107,"@quenk/wml":162,"property-seek":177}],158:[function(require,module,exports){
"use strict";
/**
 * Types corresponding to the WML AST.
 */
Object.defineProperty(exports, "__esModule", { value: true });
;
/**
 * Module is what a wml file compiles to.
 *
 * A module contains a list of imports and exported symbols.
 * All declarations in wml are exported. There is no such thing
 * as private here.
 */
var Module = /** @class */ (function () {
    function Module(imports, exports, main, location) {
        this.imports = imports;
        this.exports = exports;
        this.main = main;
        this.location = location;
        this.type = 'module';
    }
    return Module;
}());
exports.Module = Module;
/**
 * ImportStatement
 */
var ImportStatement = /** @class */ (function () {
    function ImportStatement(member, module, location) {
        this.member = member;
        this.module = module;
        this.location = location;
        this.type = 'import-statement';
    }
    return ImportStatement;
}());
exports.ImportStatement = ImportStatement;
/**
 * AliasedMember
 * @property {Identifier} alias - The identifier introduced to scope.
 * @property {Identifier} member - The identifier that is aliased.
 */
var AliasedMember = /** @class */ (function () {
    function AliasedMember(member, alias, location) {
        this.member = member;
        this.alias = alias;
        this.location = location;
        this.type = 'aliased-member';
    }
    return AliasedMember;
}());
exports.AliasedMember = AliasedMember;
/**
 * AggregateMember
 */
var AggregateMember = /** @class */ (function () {
    function AggregateMember(id, location) {
        this.id = id;
        this.location = location;
        this.type = 'qualified-member';
    }
    return AggregateMember;
}());
exports.AggregateMember = AggregateMember;
/**
 * CompositeMember
 * @property {...Identifier|Aliased_Member} members
 */
var CompositeMember = /** @class */ (function () {
    function CompositeMember(members, location) {
        this.members = members;
        this.location = location;
        this.type = 'composite-member';
    }
    return CompositeMember;
}());
exports.CompositeMember = CompositeMember;
var TypedMain = /** @class */ (function () {
    function TypedMain(id, typeClasses, context, parameters, tag, location) {
        this.id = id;
        this.typeClasses = typeClasses;
        this.context = context;
        this.parameters = parameters;
        this.tag = tag;
        this.location = location;
        this.type = 'typed-main';
    }
    return TypedMain;
}());
exports.TypedMain = TypedMain;
var UntypedMain = /** @class */ (function () {
    function UntypedMain(tag, location) {
        this.tag = tag;
        this.location = location;
        this.type = 'untyped-main';
    }
    return UntypedMain;
}());
exports.UntypedMain = UntypedMain;
var ExportStatement = /** @class */ (function () {
    function ExportStatement(members, module, location) {
        this.members = members;
        this.module = module;
        this.location = location;
        this.type = 'export-statement';
    }
    return ExportStatement;
}());
exports.ExportStatement = ExportStatement;
/**
 * ViewStatement
 */
var ViewStatement = /** @class */ (function () {
    function ViewStatement(id, typeClasses, context, parameters, tag, location) {
        this.id = id;
        this.typeClasses = typeClasses;
        this.context = context;
        this.parameters = parameters;
        this.tag = tag;
        this.location = location;
        this.type = 'view-statement';
    }
    return ViewStatement;
}());
exports.ViewStatement = ViewStatement;
var FunStatement = /** @class */ (function () {
    function FunStatement(id, typeClasses, context, parameters, body, location) {
        this.id = id;
        this.typeClasses = typeClasses;
        this.context = context;
        this.parameters = parameters;
        this.body = body;
        this.location = location;
        this.type = 'fun-statement';
    }
    return FunStatement;
}());
exports.FunStatement = FunStatement;
/**
 * TypeClass
 */
var TypeClass = /** @class */ (function () {
    function TypeClass(id, constraint, location) {
        this.id = id;
        this.constraint = constraint;
        this.location = location;
        this.type = 'type-class';
    }
    return TypeClass;
}());
exports.TypeClass = TypeClass;
var Type = /** @class */ (function () {
    function Type(id, typeClasses, list, location) {
        this.id = id;
        this.typeClasses = typeClasses;
        this.list = list;
        this.location = location;
        this.type = 'type';
    }
    return Type;
}());
exports.Type = Type;
var TypedParameter = /** @class */ (function () {
    function TypedParameter(id, hint, location) {
        this.id = id;
        this.hint = hint;
        this.location = location;
        this.type = 'typed-parameter';
    }
    return TypedParameter;
}());
exports.TypedParameter = TypedParameter;
var UntypedParameter = /** @class */ (function () {
    function UntypedParameter(id, location) {
        this.id = id;
        this.location = location;
        this.type = 'untyped-parameter';
    }
    return UntypedParameter;
}());
exports.UntypedParameter = UntypedParameter;
var Node = /** @class */ (function () {
    function Node(open, attributes, children, close) {
        this.open = open;
        this.attributes = attributes;
        this.children = children;
        this.close = close;
        this.type = 'node';
    }
    return Node;
}());
exports.Node = Node;
var Widget = /** @class */ (function () {
    function Widget(open, attributes, children, close) {
        this.open = open;
        this.attributes = attributes;
        this.children = children;
        this.close = close;
        this.type = 'widget';
    }
    return Widget;
}());
exports.Widget = Widget;
var Attribute = /** @class */ (function () {
    function Attribute(namespace, name, value, location) {
        this.namespace = namespace;
        this.name = name;
        this.value = value;
        this.location = location;
        this.type = 'attribute';
    }
    return Attribute;
}());
exports.Attribute = Attribute;
var Interpolation = /** @class */ (function () {
    function Interpolation(expression, filters, location) {
        this.expression = expression;
        this.filters = filters;
        this.location = location;
        this.type = 'interpolation';
    }
    return Interpolation;
}());
exports.Interpolation = Interpolation;
var ForStatement = /** @class */ (function () {
    function ForStatement(variable, index, all, list, body, otherwise, location) {
        this.variable = variable;
        this.index = index;
        this.all = all;
        this.list = list;
        this.body = body;
        this.otherwise = otherwise;
        this.location = location;
        this.type = 'for-statement';
    }
    return ForStatement;
}());
exports.ForStatement = ForStatement;
var IfStatement = /** @class */ (function () {
    function IfStatement(condition, then, elseClause, location) {
        this.condition = condition;
        this.then = then;
        this.elseClause = elseClause;
        this.location = location;
        this.type = 'if-statement';
    }
    return IfStatement;
}());
exports.IfStatement = IfStatement;
var ElseClause = /** @class */ (function () {
    function ElseClause(children, location) {
        this.children = children;
        this.location = location;
        this.type = 'else-clause';
    }
    return ElseClause;
}());
exports.ElseClause = ElseClause;
var ElseIfClause = /** @class */ (function () {
    function ElseIfClause(condition, then, elseClause, location) {
        this.condition = condition;
        this.then = then;
        this.elseClause = elseClause;
        this.location = location;
        this.type = 'else-if-clause';
    }
    return ElseIfClause;
}());
exports.ElseIfClause = ElseIfClause;
var Characters = /** @class */ (function () {
    function Characters(value, location) {
        this.value = value;
        this.location = location;
        this.type = 'characters';
    }
    return Characters;
}());
exports.Characters = Characters;
var IfThenExpression = /** @class */ (function () {
    function IfThenExpression(condition, iftrue, iffalse, location) {
        this.condition = condition;
        this.iftrue = iftrue;
        this.iffalse = iffalse;
        this.location = location;
        this.type = 'if-then-expression';
    }
    return IfThenExpression;
}());
exports.IfThenExpression = IfThenExpression;
var BinaryExpression = /** @class */ (function () {
    function BinaryExpression(left, operator, right, location) {
        this.left = left;
        this.operator = operator;
        this.right = right;
        this.location = location;
        this.type = 'binary-expression';
    }
    return BinaryExpression;
}());
exports.BinaryExpression = BinaryExpression;
var UnaryExpression = /** @class */ (function () {
    function UnaryExpression(operator, expression) {
        this.operator = operator;
        this.expression = expression;
        this.type = 'unary-expression';
    }
    return UnaryExpression;
}());
exports.UnaryExpression = UnaryExpression;
var ViewConstruction = /** @class */ (function () {
    function ViewConstruction(cons, context, location) {
        this.cons = cons;
        this.context = context;
        this.location = location;
        this.type = 'view-construction';
    }
    return ViewConstruction;
}());
exports.ViewConstruction = ViewConstruction;
var FunApplication = /** @class */ (function () {
    function FunApplication(target, typeArgs, context, args, location) {
        this.target = target;
        this.typeArgs = typeArgs;
        this.context = context;
        this.args = args;
        this.location = location;
        this.type = 'fun-application';
    }
    return FunApplication;
}());
exports.FunApplication = FunApplication;
var ConstructExpression = /** @class */ (function () {
    function ConstructExpression(cons, args, location) {
        this.cons = cons;
        this.args = args;
        this.location = location;
        this.type = 'construct-expression';
    }
    return ConstructExpression;
}());
exports.ConstructExpression = ConstructExpression;
var CallExpression = /** @class */ (function () {
    function CallExpression(target, typeArgs, args, location) {
        this.target = target;
        this.typeArgs = typeArgs;
        this.args = args;
        this.location = location;
        this.type = 'call-expression';
    }
    return CallExpression;
}());
exports.CallExpression = CallExpression;
/**
 * MemberExpression
 */
var MemberExpression = /** @class */ (function () {
    function MemberExpression(target, member, location) {
        this.target = target;
        this.member = member;
        this.location = location;
    }
    return MemberExpression;
}());
exports.MemberExpression = MemberExpression;
var ReadExpression = /** @class */ (function () {
    function ReadExpression(target, path, hint, defaults, location) {
        this.target = target;
        this.path = path;
        this.hint = hint;
        this.defaults = defaults;
        this.location = location;
        this.type = 'read-expression';
    }
    return ReadExpression;
}());
exports.ReadExpression = ReadExpression;
var FunctionExpression = /** @class */ (function () {
    function FunctionExpression(parameters, body, location) {
        this.parameters = parameters;
        this.body = body;
        this.location = location;
        this.type = 'function-expression';
    }
    return FunctionExpression;
}());
exports.FunctionExpression = FunctionExpression;
var List = /** @class */ (function () {
    function List(members, location) {
        this.members = members;
        this.location = location;
        this.type = 'list';
    }
    return List;
}());
exports.List = List;
var Record = /** @class */ (function () {
    function Record(properties, location) {
        this.properties = properties;
        this.location = location;
        this.type = 'record';
    }
    return Record;
}());
exports.Record = Record;
var Property = /** @class */ (function () {
    function Property(key, value, location) {
        this.key = key;
        this.value = value;
        this.location = location;
        this.type = 'property';
    }
    return Property;
}());
exports.Property = Property;
var StringLiteral = /** @class */ (function () {
    function StringLiteral(value, location) {
        this.value = value;
        this.location = location;
        this.type = 'string';
    }
    return StringLiteral;
}());
exports.StringLiteral = StringLiteral;
var NumberLiteral = /** @class */ (function () {
    function NumberLiteral(value, location) {
        this.value = value;
        this.location = location;
        this.type = 'number-literal';
    }
    return NumberLiteral;
}());
exports.NumberLiteral = NumberLiteral;
var BooleanLiteral = /** @class */ (function () {
    function BooleanLiteral(value, location) {
        this.value = value;
        this.location = location;
        this.type = 'boolean-literal';
    }
    return BooleanLiteral;
}());
exports.BooleanLiteral = BooleanLiteral;
var ContextProperty = /** @class */ (function () {
    function ContextProperty(member, location) {
        this.member = member;
        this.location = location;
        this.type = 'context-property';
    }
    return ContextProperty;
}());
exports.ContextProperty = ContextProperty;
var ContextVariable = /** @class */ (function () {
    function ContextVariable(location) {
        this.location = location;
        this.type = 'context-variable';
    }
    return ContextVariable;
}());
exports.ContextVariable = ContextVariable;
var UnqualifiedConstructor = /** @class */ (function () {
    function UnqualifiedConstructor(id, location) {
        this.id = id;
        this.location = location;
        this.type = 'unqualified-constructor';
    }
    return UnqualifiedConstructor;
}());
exports.UnqualifiedConstructor = UnqualifiedConstructor;
var QualifiedConstructor = /** @class */ (function () {
    function QualifiedConstructor(qualifier, member, location) {
        this.qualifier = qualifier;
        this.member = member;
        this.location = location;
        this.type = 'qualified-constructor';
    }
    return QualifiedConstructor;
}());
exports.QualifiedConstructor = QualifiedConstructor;
var UnqualifiedIdentifier = /** @class */ (function () {
    function UnqualifiedIdentifier(id, location) {
        this.id = id;
        this.location = location;
        this.type = 'unqualified-identifier';
    }
    return UnqualifiedIdentifier;
}());
exports.UnqualifiedIdentifier = UnqualifiedIdentifier;
/**
 * QualifiedIdentifier
 */
var QualifiedIdentifier = /** @class */ (function () {
    function QualifiedIdentifier(qualifier, member, location) {
        this.qualifier = qualifier;
        this.member = member;
        this.location = location;
        this.type = 'qualified-identifier';
    }
    return QualifiedIdentifier;
}());
exports.QualifiedIdentifier = QualifiedIdentifier;

},{}],159:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/// <reference path='Parser.d.ts' />
var Parser = require("./Parser");
var nodes = require("./AST");
var afpl = require("afpl");
var jsfmt = require("js-beautify");
var TypeScript = require("./TypeScript");
var afpl_1 = require("afpl");
var defaultOptions = {
    debug: false,
    main: 'Main',
    module: '@quenk/wml',
};
/**
 * parse a string as WML returning either an error or an AST.
 */
exports.parse = function (str, ast) {
    if (ast === void 0) { ast = nodes; }
    Parser.parser.yy = { ast: ast };
    try {
        return afpl_1.Either.right(Parser.parser.parse(str));
    }
    catch (e) {
        return afpl_1.Either.left(e);
    }
};
/**
 * pretty up the output.
 */
exports.pretty = function (doit) { return function (s) {
    return doit ? jsfmt(s, {}) : s;
}; };
/**
 * compile a string of WML turning it into typescript code.
 */
exports.compile = function (src, options) {
    if (options === void 0) { options = {}; }
    var opts = afpl.util.merge(defaultOptions, options);
    return exports.parse(src)
        .map(function (m) { return TypeScript.code(m, opts); })
        .map(exports.pretty(options.pretty));
};

},{"./AST":158,"./Parser":160,"./TypeScript":161,"afpl":164,"js-beautify":172}],160:[function(require,module,exports){

/* parser generated by jison 0.6.1-203 */

/*
 * Returns a Parser object of the following structure:
 *
 *  Parser: {
 *    yy: {}     The so-called "shared state" or rather the *source* of it;
 *               the real "shared state" `yy` passed around to
 *               the rule actions, etc. is a derivative/copy of this one,
 *               not a direct reference!
 *  }
 *
 *  Parser.prototype: {
 *    yy: {},
 *    EOF: 1,
 *    TERROR: 2,
 *
 *    trace: function(errorMessage, ...),
 *
 *    JisonParserError: function(msg, hash),
 *
 *    quoteName: function(name),
 *               Helper function which can be overridden by user code later on: put suitable
 *               quotes around literal IDs in a description string.
 *
 *    originalQuoteName: function(name),
 *               The basic quoteName handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function
 *               at the end of the `parse()`.
 *
 *    describeSymbol: function(symbol),
 *               Return a more-or-less human-readable description of the given symbol, when
 *               available, or the symbol itself, serving as its own 'description' for lack
 *               of something better to serve up.
 *
 *               Return NULL when the symbol is unknown to the parser.
 *
 *    symbols_: {associative list: name ==> number},
 *    terminals_: {associative list: number ==> name},
 *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},
 *    terminal_descriptions_: (if there are any) {associative list: number ==> description},
 *    productions_: [...],
 *
 *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack),
 *
 *               The function parameters and `this` have the following value/meaning:
 *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)
 *                             to store/reference the rule value `$$` and location info `@$`.
 *
 *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets
 *                 to see the same object via the `this` reference, i.e. if you wish to carry custom
 *                 data from one reduce action through to the next within a single parse run, then you
 *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.
 *
 *                 `this.yy` is a direct reference to the `yy` shared state object.
 *
 *                 `%parse-param`-specified additional `parse()` arguments have been added to this `yy`
 *                 object at `parse()` start and are therefore available to the action code via the
 *                 same named `yy.xxxx` attributes (where `xxxx` represents a identifier name from
 *                 the %parse-param` list.
 *
 *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used
 *                             to match this rule. This is *not* the look-ahead token, but the last token
 *                             that's actually part of this rule.
 *
 *                 Formulated another way, `yytext` is the value of the token immediately preceeding
 *                 the current look-ahead token.
 *                 Caveats apply for rules which don't require look-ahead, such as epsilon rules.
 *
 *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.
 *
 *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.
 *
 *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.
 *
 *                               WARNING: since jison 0.4.18-186 this entry may be NULL/UNDEFINED instead
 *                               of an empty object when no suitable location info can be provided.
 *
 *               - `yystate` : the current parser state number, used internally for dispatching and
 *                               executing the action code chunk matching the rule currently being reduced.
 *
 *               - `yysp`    : the current state stack position (a.k.a. 'stack pointer')
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *                 Also note that you can access this and other stack index values using the new double-hash
 *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things
 *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.
 *                 This is made available to write very advanced grammar action rules, e.g. when you want
 *                 to investigate the parse state stack in your action code, which would, for example,
 *                 be relevant when you wish to implement error diagnostics and reporting schemes similar
 *                 to the work described here:
 *
 *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.
 *                   In Journées Francophones des Languages Applicatifs.
 *
 *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.
 *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631–640.
 *
 *               - `yyrulelength`: the current rule's term count, i.e. the number of entries occupied on the stack.
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.
 *                             constructs.
 *
 *               - `yylstack`: reference to the parser token location stack. Also accessed via
 *                             the `@1` etc. constructs.
 *
 *                             WARNING: since jison 0.4.18-186 this array MAY contain slots which are
 *                             UNDEFINED rather than an empty (location) object, when the lexer/parser
 *                             action code did not provide a suitable location info object when such a
 *                             slot was filled!
 *
 *               - `yystack` : reference to the parser token id stack. Also accessed via the
 *                             `#1` etc. constructs.
 *
 *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to
 *                 its numeric token id value, hence that code wouldn't need the `yystack` but *you* might
 *                 want access this array for your own purposes, such as error analysis as mentioned above!
 *
 *                 Note that this stack stores the current stack of *tokens*, that is the sequence of
 *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*
 *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and
 *                 *reduced*.
 *
 *               - `yysstack`: reference to the parser state stack. This one carries the internal parser
 *                             *states* such as the one in `yystate`, which are used to represent
 *                             the parser state machine in the *parse table*. *Very* *internal* stuff,
 *                             what can I say? If you access this one, you're clearly doing wicked things
 *
 *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your
 *                             grammar definition file.
 *
 *    table: [...],
 *               State transition table
 *               ----------------------
 *
 *               index levels are:
 *               - `state`  --> hash table
 *               - `symbol` --> action (number or array)
 *
 *                 If the `action` is an array, these are the elements' meaning:
 *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept
 *                 - index [1]: GOTO `state`
 *
 *                 If the `action` is a number, it is the GOTO `state`
 *
 *    defaultActions: {...},
 *
 *    parseError: function(str, hash, ExceptionClass),
 *    yyError: function(str, ...),
 *    yyRecovering: function(),
 *    yyErrOk: function(),
 *    yyClearIn: function(),
 *
 *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
 *               See it's use in this parser kernel in many places; example usage:
 *
 *                   var infoObj = parser.constructParseErrorInfo('fail!', null,
 *                                     parser.collect_expected_token_set(state), true);
 *                   var retVal = parser.parseError(infoObj.errStr, infoObj, parser.JisonParserError);
 *
 *    originalParseError: function(str, hash, ExceptionClass),
 *               The basic `parseError` handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function
 *               at the end of the `parse()`.
 *
 *    options: { ... parser %options ... },
 *
 *    parse: function(input[, args...]),
 *               Parse the given `input` and return the parsed value (or `true` when none was provided by
 *               the root action, in which case the parser is acting as a *matcher*).
 *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:
 *               these extra `args...` are added verbatim to the `yy` object reference as member variables.
 *
 *               WARNING:
 *               Parser's additional `args...` parameters (via `%parse-param`) MAY conflict with
 *               any attributes already added to `yy` by the jison run-time;
 *               when such a collision is detected an exception is thrown to prevent the generated run-time
 *               from silently accepting this confusing and potentially hazardous situation!
 *
 *               The lexer MAY add its own set of additional parameters (via the `%parse-param` line in
 *               the lexer section of the grammar spec): these will be inserted in the `yy` shared state
 *               object and any collision with those will be reported by the lexer via a thrown exception.
 *
 *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown
 *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY
 *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and
 *               the internal parser gets properly garbage collected under these particular circumstances.
 *
 *    yyMergeLocationInfo: function(first_index, last_index, first_yylloc, last_yylloc, dont_look_back),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API can be invoked to calculate a spanning `yylloc` location info object.
 *
 *               Note: %epsilon rules MAY specify no `first_index` and `first_yylloc`, in which case
 *               this function will attempt to obtain a suitable location marker by inspecting the location stack
 *               backwards.
 *
 *               For more info see the documentation comment further below, immediately above this function's
 *               implementation.
 *
 *    lexer: {
 *        yy: {...},           A reference to the so-called "shared state" `yy` once
 *                             received via a call to the `.setInput(input, yy)` lexer API.
 *        EOF: 1,
 *        ERROR: 2,
 *        JisonLexerError: function(msg, hash),
 *        parseError: function(str, hash, ExceptionClass),
 *        setInput: function(input, [yy]),
 *        input: function(),
 *        unput: function(str),
 *        more: function(),
 *        reject: function(),
 *        less: function(n),
 *        pastInput: function(n),
 *        upcomingInput: function(n),
 *        showPosition: function(),
 *        test_match: function(regex_match_array, rule_index, ...),
 *        next: function(...),
 *        lex: function(...),
 *        begin: function(condition),
 *        pushState: function(condition),
 *        popState: function(),
 *        topState: function(),
 *        _currentRules: function(),
 *        stateStackSize: function(),
 *        cleanupAfterLex: function()
 *
 *        options: { ... lexer %options ... },
 *
 *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),
 *        rules: [...],
 *        conditions: {associative list: name ==> set},
 *    }
 *  }
 *
 *
 *  token location info (@$, _$, etc.): {
 *    first_line: n,
 *    last_line: n,
 *    first_column: n,
 *    last_column: n,
 *    range: [start_number, end_number]
 *               (where the numbers are indexes into the input string, zero-based)
 *  }
 *
 * ---
 *
 * The `parseError` function receives a 'hash' object with these members for lexer and
 * parser errors:
 *
 *  {
 *    text:        (matched text)
 *    token:       (the produced terminal token, if any)
 *    token_id:    (the produced terminal token numeric ID, if any)
 *    line:        (yylineno)
 *    loc:         (yylloc)
 *  }
 *
 * parser (grammar) errors will also provide these additional members:
 *
 *  {
 *    expected:    (array describing the set of expected tokens;
 *                  may be UNDEFINED when we cannot easily produce such a set)
 *    state:       (integer (or array when the table includes grammar collisions);
 *                  represents the current internal state of the parser kernel.
 *                  can, for example, be used to pass to the `collect_expected_token_set()`
 *                  API to obtain the expected token set)
 *    action:      (integer; represents the current internal action which will be executed)
 *    new_state:   (integer; represents the next/planned internal state, once the current
 *                  action has executed)
 *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
 *                  available for this particular error)
 *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    yy:          (object: the current parser internal "shared state" `yy`
 *                  as is also available in the rule actions; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    lexer:       (reference to the current lexer instance used by the parser)
 *    parser:      (reference to the current parser instance)
 *  }
 *
 * while `this` will reference the current parser instance.
 *
 * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    lexer:       (reference to the current lexer instance which reported the error)
 *  }
 *
 * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired
 * from either the parser or lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    exception:   (reference to the exception thrown)
 *  }
 *
 * Please do note that in the latter situation, the `expected` field will be omitted as
 * this type of failure is assumed not to be due to *parse errors* but rather due to user
 * action code in either parser or lexer failing unexpectedly.
 *
 * ---
 *
 * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.
 * These options are available:
 *
 * ### options which are global for all parser instances
 *
 *  Parser.pre_parse: function(yy)
 *                 optional: you can specify a pre_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`.
 *  Parser.post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: you can specify a post_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`. When it does not return any value,
 *                 the parser will return the original `retval`.
 *
 * ### options which can be set up per parser instance
 *
 *  yy: {
 *      pre_parse:  function(yy)
 *                 optional: is invoked before the parse cycle starts (and before the first
 *                 invocation of `lex()`) but immediately after the invocation of
 *                 `parser.pre_parse()`).
 *      post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: is invoked when the parse terminates due to success ('accept')
 *                 or failure (even when exceptions are thrown).
 *                 `retval` contains the return value to be produced by `Parser.parse()`;
 *                 this function can override the return value by returning another.
 *                 When it does not return any value, the parser will return the original
 *                 `retval`.
 *                 This function is invoked immediately before `parser.post_parse()`.
 *
 *      parseError: function(str, hash, ExceptionClass)
 *                 optional: overrides the default `parseError` function.
 *      quoteName: function(name),
 *                 optional: overrides the default `quoteName` function.
 *  }
 *
 *  parser.lexer.options: {
 *      pre_lex:  function()
 *                 optional: is invoked before the lexer is invoked to produce another token.
 *                 `this` refers to the Lexer object.
 *      post_lex: function(token) { return token; }
 *                 optional: is invoked when the lexer has produced a token `token`;
 *                 this function can override the returned token value by returning another.
 *                 When it does not return any (truthy) value, the lexer will return
 *                 the original `token`.
 *                 `this` refers to the Lexer object.
 *
 *      ranges: boolean
 *                 optional: `true` ==> token location info will include a .range[] member.
 *      flex: boolean
 *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
 *                 exhaustively to find the longest match.
 *      backtrack_lexer: boolean
 *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
 *                 the lexer terminates the scan when a token is returned by the action code.
 *      xregexp: boolean
 *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
 *                 `XRegExp` library. When this `%option` has not been specified at compile time, all lexer
 *                 rule regexes have been written as standard JavaScript RegExp expressions.
 *  }
 */

        
    
            var Parser = (function () {

// See also:
// http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
// but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
// with userland code which might access the derived class in a 'classic' way.
function JisonParserError(msg, hash) {
    Object.defineProperty(this, 'name', {
        enumerable: false,
        writable: false,
        value: 'JisonParserError'
    });

    if (msg == null) msg = '???';

    Object.defineProperty(this, 'message', {
        enumerable: false,
        writable: true,
        value: msg
    });

    this.hash = hash;

    var stacktrace;
    if (hash && hash.exception instanceof Error) {
        var ex2 = hash.exception;
        this.message = ex2.message || msg;
        stacktrace = ex2.stack;
    }
    if (!stacktrace) {
        if (Error.hasOwnProperty('captureStackTrace')) {        // V8/Chrome engine
            Error.captureStackTrace(this, this.constructor);
        } else {
            stacktrace = (new Error(msg)).stack;
        }
    }
    if (stacktrace) {
        Object.defineProperty(this, 'stack', {
            enumerable: false,
            writable: false,
            value: stacktrace
        });
    }
}

if (typeof Object.setPrototypeOf === 'function') {
    Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);
} else {
    JisonParserError.prototype = Object.create(Error.prototype);
}
JisonParserError.prototype.constructor = JisonParserError;
JisonParserError.prototype.name = 'JisonParserError';



        // helper: reconstruct the productions[] table
        function bp(s) {
            var rv = [];
            var p = s.pop;
            var r = s.rule;
            for (var i = 0, l = p.length; i < l; i++) {
                rv.push([
                    p[i],
                    r[i]
                ]);
            }
            return rv;
        }
    


        // helper: reconstruct the defaultActions[] table
        function bda(s) {
            var rv = {};
            var d = s.idx;
            var g = s.goto;
            for (var i = 0, l = d.length; i < l; i++) {
                var j = d[i];
                rv[j] = g[i];
            }
            return rv;
        }
    


        // helper: reconstruct the 'goto' table
        function bt(s) {
            var rv = [];
            var d = s.len;
            var y = s.symbol;
            var t = s.type;
            var a = s.state;
            var m = s.mode;
            var g = s.goto;
            for (var i = 0, l = d.length; i < l; i++) {
                var n = d[i];
                var q = {};
                for (var j = 0; j < n; j++) {
                    var z = y.shift();
                    switch (t.shift()) {
                    case 2:
                        q[z] = [
                            m.shift(),
                            g.shift()
                        ];
                        break;

                    case 0:
                        q[z] = a.shift();
                        break;

                    default:
                        // type === 1: accept
                        q[z] = [
                            3
                        ];
                    }
                }
                rv.push(q);
            }
            return rv;
        }
    


        // helper: runlength encoding with increment step: code, length: step (default step = 0)
        // `this` references an array
        function s(c, l, a) {
            a = a || 0;
            for (var i = 0; i < l; i++) {
                this.push(c);
                c += a;
            }
        }

        // helper: duplicate sequence from *relative* offset and length.
        // `this` references an array
        function c(i, l) {
            i = this.length - i;
            for (l += i; i < l; i++) {
                this.push(this[i]);
            }
        }

        // helper: unpack an array using helpers and data, all passed in an array argument 'a'.
        function u(a) {
            var rv = [];
            for (var i = 0, l = a.length; i < l; i++) {
                var e = a[i];
                // Is this entry a helper function?
                if (typeof e === 'function') {
                    i++;
                    e.apply(rv, a[i]);
                } else {
                    rv.push(e);
                }
            }
            return rv;
        }
    

var parser = {
    // Code Generator Information Report
    // ---------------------------------
    //
    // Options:
    //
    //   default action mode: ............. classic,merge
    //   no try..catch: ................... false
    //   no default resolve on conflict:    false
    //   on-demand look-ahead: ............ false
    //   error recovery token skip maximum: 3
    //   yyerror in parse actions is: ..... NOT recoverable,
    //   yyerror in lexer actions and other non-fatal lexer are:
    //   .................................. NOT recoverable,
    //   debug grammar/output: ............ false
    //   has partial LR conflict upgrade:   true
    //   rudimentary token-stack support:   false
    //   parser table compression mode: ... 2
    //   export debug tables: ............. false
    //   export *all* tables: ............. false
    //   module type: ..................... commonjs
    //   parser engine type: .............. lalr
    //   output main() in the module: ..... true
    //   has user-specified main(): ....... false
    //   has user-specified require()/import modules for main(): 
    //   .................................. false
    //   number of expected conflicts: .... 0
    //
    //
    // Parser Analysis flags:
    //
    //   no significant actions (parser is a language matcher only):
    //   .................................. false
    //   uses yyleng: ..................... false
    //   uses yylineno: ................... false
    //   uses yytext: ..................... false
    //   uses yylloc: ..................... false
    //   uses ParseError API: ............. false
    //   uses YYERROR: .................... false
    //   uses YYRECOVERING: ............... false
    //   uses YYERROK: .................... false
    //   uses YYCLEARIN: .................. false
    //   tracks rule values: .............. true
    //   assigns rule values: ............. true
    //   uses location tracking: .......... true
    //   assigns location: ................ true
    //   uses yystack: .................... false
    //   uses yysstack: ................... false
    //   uses yysp: ....................... true
    //   uses yyrulelength: ............... false
    //   uses yyMergeLocationInfo API: .... true
    //   has error recovery: .............. false
    //   has error reporting: ............. false
    //
    // --------- END OF REPORT -----------

trace: function no_op_trace() {},
JisonParserError: JisonParserError,
yy: {},
options: {
  type: "lalr",
  hasPartialLrUpgradeOnConflict: true,
  errorRecoveryTokenDiscardCount: 3,
  ebnf: true
},
symbols_: {
  "!": 16,
  "!=": 60,
  "$accept": 0,
  "$end": 1,
  "%}": 30,
  "&&": 61,
  "(": 7,
  ")": 8,
  "*": 3,
  "+": 21,
  ",": 6,
  "-": 23,
  ".": 17,
  "/": 22,
  "/>": 38,
  ":": 12,
  ";": 20,
  "<": 13,
  "</": 37,
  "<=": 58,
  "=": 9,
  "==": 59,
  "=>": 50,
  ">": 14,
  ">=": 57,
  "?": 18,
  "@": 19,
  "AS": 27,
  "CHARACTERS": 47,
  "CONSTRUCTOR": 56,
  "ELSE": 44,
  "ENDFOR": 43,
  "ENDFUN": 36,
  "ENDIF": 46,
  "ENDMAIN": 31,
  "ENDVIEW": 34,
  "EOF": 1,
  "EXPORT": 32,
  "FALSE": 54,
  "FOR": 41,
  "FROM": 26,
  "FUN": 35,
  "IDENTIFIER": 55,
  "IF": 45,
  "IMPORT": 25,
  "IN": 42,
  "INSTANCEOF": 63,
  "MAIN": 29,
  "NUMBER_LITERAL": 52,
  "STRING_LITERAL": 51,
  "THEN": 48,
  "TRUE": 53,
  "VIEW": 33,
  "[": 10,
  "\\\\": 49,
  "]": 11,
  "^": 24,
  "aggregate_member": 69,
  "aliased_member": 68,
  "argument_list": 105,
  "arguments": 104,
  "attribute": 94,
  "attribute_value": 95,
  "attribute_value_group": 155,
  "attributes": 93,
  "binary_expression": 108,
  "binary_operator": 138,
  "binary_operator_group": 161,
  "boolean_literal": 129,
  "call_expression": 117,
  "characters": 103,
  "child": 89,
  "child_group": 150,
  "children": 88,
  "composite_member": 70,
  "cons": 132,
  "construct_expression": 116,
  "context_property": 130,
  "context_type": 80,
  "context_variable": 131,
  "control": 99,
  "control_group": 156,
  "else_clause": 102,
  "end_main": 74,
  "error": 2,
  "export": 76,
  "export_statement": 77,
  "exports": 75,
  "expression": 106,
  "filter": 98,
  "filters": 97,
  "for_statement": 100,
  "fun_application": 112,
  "fun_statement": 79,
  "fun_target": 113,
  "function_expression": 121,
  "identifier": 135,
  "if_expression": 107,
  "if_statement": 101,
  "import_member": 67,
  "import_statement": 66,
  "import_statement_option": 139,
  "imports": 65,
  "interpolation": 96,
  "list": 126,
  "literal": 122,
  "literal_group": 159,
  "main": 73,
  "main_option": 143,
  "main_option2": 144,
  "main_option3": 145,
  "main_option4": 146,
  "member": 72,
  "member_expression": 118,
  "member_group": 142,
  "member_list": 71,
  "member_list_group": 140,
  "member_list_group2": 141,
  "module": 64,
  "node": 91,
  "node_option": 151,
  "node_option2": 152,
  "number_literal": 128,
  "parameter": 87,
  "parameter_list": 86,
  "parameters": 85,
  "properties": 124,
  "property": 125,
  "property_group": 160,
  "qualified_constructor": 133,
  "qualified_identifier": 136,
  "read_expression": 119,
  "readable_expression": 120,
  "readable_expression_group": 158,
  "record": 123,
  "simple_expression": 110,
  "simple_expression_group": 157,
  "string_literal": 127,
  "tag": 90,
  "type": 84,
  "type_arg_list": 115,
  "type_arguments": 114,
  "type_class": 83,
  "type_class_list": 82,
  "type_classes": 81,
  "type_option": 149,
  "unary_expression": 109,
  "unqualified_constructor": 134,
  "unqualified_identifier": 137,
  "view_construction": 111,
  "view_statement": 78,
  "view_statement_option": 147,
  "view_statement_option2": 148,
  "widget": 92,
  "widget_option": 153,
  "widget_option2": 154,
  "{": 4,
  "{%": 28,
  "{{": 39,
  "|": 15,
  "||": 62,
  "}": 5,
  "}}": 40
},
terminals_: {
  1: "EOF",
  2: "error",
  3: "*",
  4: "{",
  5: "}",
  6: ",",
  7: "(",
  8: ")",
  9: "=",
  10: "[",
  11: "]",
  12: ":",
  13: "<",
  14: ">",
  15: "|",
  16: "!",
  17: ".",
  18: "?",
  19: "@",
  20: ";",
  21: "+",
  22: "/",
  23: "-",
  24: "^",
  25: "IMPORT",
  26: "FROM",
  27: "AS",
  28: "{%",
  29: "MAIN",
  30: "%}",
  31: "ENDMAIN",
  32: "EXPORT",
  33: "VIEW",
  34: "ENDVIEW",
  35: "FUN",
  36: "ENDFUN",
  37: "</",
  38: "/>",
  39: "{{",
  40: "}}",
  41: "FOR",
  42: "IN",
  43: "ENDFOR",
  44: "ELSE",
  45: "IF",
  46: "ENDIF",
  47: "CHARACTERS",
  48: "THEN",
  49: "\\\\",
  50: "=>",
  51: "STRING_LITERAL",
  52: "NUMBER_LITERAL",
  53: "TRUE",
  54: "FALSE",
  55: "IDENTIFIER",
  56: "CONSTRUCTOR",
  57: ">=",
  58: "<=",
  59: "==",
  60: "!=",
  61: "&&",
  62: "||",
  63: "INSTANCEOF"
},
TERROR: 2,
EOF: 1,

// internals: defined here so the object *structure* doesn't get modified by parse() et al,
// thus helping JIT compilers like Chrome V8.
originalQuoteName: null,
originalParseError: null,
cleanupAfterParse: null,
constructParseErrorInfo: null,
yyMergeLocationInfo: null,

__reentrant_call_depth: 0, // INTERNAL USE ONLY
__error_infos: [], // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup
__error_recovery_infos: [], // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup

// APIs which will be set up depending on user action code analysis:
//yyRecovering: 0,
//yyErrOk: 0,
//yyClearIn: 0,

// Helper APIs
// -----------

// Helper function which can be overridden by user code later on: put suitable quotes around
// literal IDs in a description string.
quoteName: function parser_quoteName(id_str) {
    return '"' + id_str + '"';
},

// Return the name of the given symbol (terminal or non-terminal) as a string, when available.
//
// Return NULL when the symbol is unknown to the parser.
getSymbolName: function parser_getSymbolName(symbol) {
    if (this.terminals_[symbol]) {
        return this.terminals_[symbol];
    }

    // Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.
    //
    // An example of this may be where a rule's action code contains a call like this:
    //
    //      parser.getSymbolName(#$)
    //
    // to obtain a human-readable name of the current grammar rule.
    var s = this.symbols_;
    for (var key in s) {
        if (s[key] === symbol) {
            return key;
        }
    }
    return null;
},

// Return a more-or-less human-readable description of the given symbol, when available,
// or the symbol itself, serving as its own 'description' for lack of something better to serve up.
//
// Return NULL when the symbol is unknown to the parser.
describeSymbol: function parser_describeSymbol(symbol) {
    if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {
        return this.terminal_descriptions_[symbol];
    } else if (symbol === this.EOF) {
        return 'end of input';
    }
    var id = this.getSymbolName(symbol);
    if (id) {
        return this.quoteName(id);
    }
    return null;
},

// Produce a (more or less) human-readable list of expected tokens at the point of failure.
//
// The produced list may contain token or token set descriptions instead of the tokens
// themselves to help turning this output into something that easier to read by humans
// unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,
// expected terminals and nonterminals is produced.
//
// The returned list (array) will not contain any duplicate entries.
collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {
    var TERROR = this.TERROR;
    var tokenset = [];
    var check = {};
    // Has this (error?) state been outfitted with a custom expectations description text for human consumption?
    // If so, use that one instead of the less palatable token set.
    if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {
        return [this.state_descriptions_[state]];
    }
    for (var p in this.table[state]) {
        p = +p;
        if (p !== TERROR) {
            var d = do_not_describe ? p : this.describeSymbol(p);
            if (d && !check[d]) {
                tokenset.push(d);
                check[d] = true; // Mark this token description as already mentioned to prevent outputting duplicate entries.
            }
        }
    }
    return tokenset;
},
productions_: bp({
  pop: u([
  s,
  [64, 7],
  65,
  65,
  66,
  s,
  [67, 3],
  s,
  [68, 4, 1],
  71,
  72,
  73,
  73,
  74,
  75,
  75,
  s,
  [76, 3],
  77,
  78,
  s,
  [79, 16],
  80,
  81,
  82,
  82,
  s,
  [83, 4],
  s,
  [84, 3],
  85,
  85,
  86,
  86,
  87,
  87,
  88,
  88,
  89,
  90,
  90,
  s,
  [91, 4],
  s,
  [92, 4],
  93,
  93,
  s,
  [94, 4],
  95,
  96,
  96,
  97,
  s,
  [97, 4, 1],
  s,
  [100, 5],
  101,
  102,
  102,
  103,
  104,
  104,
  105,
  105,
  s,
  [106, 7],
  107,
  s,
  [108, 4],
  109,
  s,
  [109, 4, 1],
  s,
  [112, 3],
  s,
  [113, 3],
  114,
  115,
  115,
  116,
  s,
  [117, 8],
  s,
  [118, 10],
  s,
  [119, 10],
  120,
  120,
  121,
  121,
  122,
  123,
  123,
  124,
  124,
  125,
  126,
  s,
  [126, 4, 1],
  s,
  [129, 4, 1],
  132,
  133,
  133,
  134,
  135,
  135,
  136,
  s,
  [136, 4, 1],
  139,
  140,
  140,
  141,
  141,
  142,
  142,
  143,
  143,
  144,
  144,
  145,
  145,
  146,
  146,
  147,
  147,
  148,
  148,
  149,
  149,
  s,
  [150, 5],
  151,
  151,
  152,
  152,
  153,
  153,
  154,
  154,
  155,
  155,
  156,
  156,
  s,
  [157, 10],
  s,
  [158, 4],
  s,
  [159, 5],
  160,
  160,
  s,
  [161, 14]
]),
  rule: u([
  4,
  3,
  3,
  2,
  3,
  2,
  2,
  1,
  2,
  5,
  s,
  [1, 3],
  s,
  [3, 3],
  1,
  3,
  1,
  11,
  c,
  [4, 3],
  2,
  s,
  [1, 3],
  6,
  13,
  11,
  10,
  10,
  9,
  10,
  9,
  9,
  8,
  9,
  8,
  8,
  7,
  8,
  7,
  7,
  6,
  c,
  [31, 5],
  c,
  [4, 3],
  2,
  4,
  c,
  [53, 3],
  c,
  [46, 3],
  1,
  c,
  [40, 5],
  8,
  7,
  4,
  3,
  c,
  [4, 4],
  c,
  [68, 3],
  c,
  [19, 4],
  3,
  4,
  1,
  c,
  [80, 3],
  10,
  12,
  14,
  14,
  16,
  18,
  6,
  7,
  7,
  1,
  c,
  [42, 4],
  s,
  [1, 6],
  3,
  6,
  3,
  5,
  5,
  7,
  2,
  4,
  1,
  4,
  6,
  5,
  5,
  4,
  c,
  [111, 4],
  c,
  [75, 3],
  c,
  [127, 4],
  3,
  2,
  5,
  c,
  [136, 3],
  s,
  [3, 6],
  5,
  3,
  6,
  8,
  6,
  8,
  c,
  [4, 4],
  10,
  8,
  c,
  [76, 3],
  c,
  [154, 3],
  c,
  [106, 4],
  c,
  [5, 3],
  s,
  [1, 3],
  c,
  [110, 4],
  c,
  [99, 4],
  c,
  [5, 5],
  0,
  s,
  [1, 7],
  0,
  c,
  [10, 3],
  c,
  [4, 10],
  c,
  [19, 13],
  s,
  [1, 39]
])
}),
performAction: function parser__PerformAction(yyloc, yystate /* action[1] */, yysp, yyvstack, yylstack) {

          /* this == yyval */

          // the JS engine itself can go and remove these statements when `yy` turns out to be unused in any action code!
          var yy = this.yy;
          var yyparser = yy.parser;
          var yylexer = yy.lexer;

          

          switch (yystate) {
case 0:
    /*! Production::    $accept : module $end */

    // default action (generated by JISON mode classic/merge :: VT,VA,-,-,LT,LA,-,-):
    this.$ = yyvstack[yysp - 1];
    this._$ = yylstack[yysp - 1];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,-,-,LT,LA,-,-)
    break;

case 1:
    /*! Production::    module : imports exports main EOF */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ =
    new yy.ast.Module(yyvstack[yysp - 3], yyvstack[yysp - 2], yyvstack[yysp - 1], this._$); 
    return this.$;
    break;

case 2:
    /*! Production::    module : imports exports EOF */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ =
    new yy.ast.Module(yyvstack[yysp - 2], yyvstack[yysp - 1], null, this._$); 
    return this.$;
    break;

case 3:
    /*! Production::    module : imports main EOF */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ =
    new yy.ast.Module(yyvstack[yysp - 2], [], yyvstack[yysp - 1], this._$); 
    return this.$;
    break;

case 4:
    /*! Production::    module : imports EOF */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ =
    new yy.ast.Module(yyvstack[yysp - 1], [], null, this._$); 
    return this.$;
    break;

case 5:
    /*! Production::    module : exports main EOF */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ =
    new yy.ast.Module([], yyvstack[yysp - 2], yyvstack[yysp - 1], this._$); 
    return this.$;
    break;

case 6:
    /*! Production::    module : exports EOF */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ =
    new yy.ast.Module([], yyvstack[yysp - 1], null, this._$); 
    return this.$;
    break;

case 7:
    /*! Production::    module : main EOF */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ =
    new yy.ast.Module([], [], yyvstack[yysp - 1], this._$); 
    return this.$;
    break;

case 8:
    /*! Production::    imports : import_statement */
case 85:
    /*! Production::    filters : filter */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ =  [yyvstack[yysp]];
    break;

case 9:
    /*! Production::    imports : imports import_statement */
case 24:
    /*! Production::    exports : exports export */
case 64:
    /*! Production::    children : children child */
case 77:
    /*! Production::    attributes : attributes attribute */
case 86:
    /*! Production::    filters : filters filter */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp - 1].concat(yyvstack[yysp]);
    break;

case 10:
    /*! Production::    import_statement : IMPORT import_member FROM string_literal import_statement_option */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ImportStatement(yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
    break;

case 11:
    /*! Production::    import_member : aggregate_member */
case 12:
    /*! Production::    import_member : aliased_member */
case 13:
    /*! Production::    import_member : composite_member */
case 19:
    /*! Production::    member : member_group */
case 25:
    /*! Production::    export : export_statement */
case 26:
    /*! Production::    export : view_statement */
case 162:
    /*! Production::    literal : literal_group */

    // default action (generated by JISON mode classic/merge :: VT,VA,-,-,LT,LA,-,-):
    this.$ = yyvstack[yysp];
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,-,-,LT,LA,-,-)
    break;

case 14:
    /*! Production::    aliased_member : member AS member */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.AliasedMember(yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 15:
    /*! Production::    aggregate_member : "*" AS member */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.AggregateMember(yyvstack[yysp], this._$);
    break;

case 16:
    /*! Production::    composite_member : "{" member_list "}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.CompositeMember(yyvstack[yysp - 1], this._$);
    break;

case 17:
    /*! Production::    member_list : member_list_group */
case 23:
    /*! Production::    exports : export */
case 48:
    /*! Production::    type_class_list : type_class */
case 59:
    /*! Production::    parameter_list : parameter */
case 63:
    /*! Production::    children : child */
case 76:
    /*! Production::    attributes : attribute */
case 101:
    /*! Production::    argument_list : expression */
case 127:
    /*! Production::    type_arg_list : type */
case 165:
    /*! Production::    properties : property */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = [yyvstack[yysp]];
    break;

case 18:
    /*! Production::    member_list : member_list "," member_list_group2 */
case 49:
    /*! Production::    type_class_list : type_class_list "," type_class */
case 60:
    /*! Production::    parameter_list : parameter_list "," parameter */
case 102:
    /*! Production::    argument_list : argument_list "," expression */
case 128:
    /*! Production::    type_arg_list : type_arg_list "," type */
case 166:
    /*! Production::    properties : properties "," property */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp - 2].concat(yyvstack[yysp]);
    break;

case 20:
    /*! Production::    main : "{%" MAIN main_option main_option2 "(" type ")" main_option3 "%}" tag main_option4 */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 10, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.TypedMain(yyvstack[yysp - 8], yyvstack[yysp - 7]||[], yyvstack[yysp - 5], yyvstack[yysp - 3]||[], yyvstack[yysp - 1], this._$);
    break;

case 21:
    /*! Production::    main : tag */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.UntypedMain(yyvstack[yysp], this._$);
    break;

case 22:
    /*! Production::    end_main : "{%" ENDMAIN "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,-,-,LT,LA,-,-):
    this.$ = yyvstack[yysp - 2];
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,-,-,LT,LA,-,-)
    break;

case 27:
    /*! Production::    export : fun_statement */
case 65:
    /*! Production::    child : child_group */
case 66:
    /*! Production::    tag : node */
case 67:
    /*! Production::    tag : widget */
case 82:
    /*! Production::    attribute_value : attribute_value_group */
case 88:
    /*! Production::    control : control_group */
case 103:
    /*! Production::    expression : if_expression */
case 104:
    /*! Production::    expression : binary_expression */
case 106:
    /*! Production::    expression : simple_expression */
case 107:
    /*! Production::    expression : read_expression */
case 108:
    /*! Production::    expression : function_expression */
case 117:
    /*! Production::    simple_expression : simple_expression_group */
case 123:
    /*! Production::    fun_target : identifier */
case 124:
    /*! Production::    fun_target : context_property */
case 158:
    /*! Production::    readable_expression : readable_expression_group */
case 176:
    /*! Production::    cons : qualified_constructor */
case 177:
    /*! Production::    cons : unqualified_constructor */
case 181:
    /*! Production::    identifier : qualified_identifier */
case 182:
    /*! Production::    identifier : unqualified_identifier */
case 186:
    /*! Production::    binary_operator : binary_operator_group */
case 188:
    /*! Production::    import_statement_option : ";" */
case 189:
    /*! Production::    member_list_group : member */
case 190:
    /*! Production::    member_list_group : aliased_member */
case 191:
    /*! Production::    member_list_group2 : member */
case 192:
    /*! Production::    member_list_group2 : aliased_member */
case 193:
    /*! Production::    member_group : unqualified_identifier */
case 194:
    /*! Production::    member_group : unqualified_constructor */
case 196:
    /*! Production::    main_option : unqualified_constructor */
case 198:
    /*! Production::    main_option2 : type_classes */
case 200:
    /*! Production::    main_option3 : parameters */
case 202:
    /*! Production::    main_option4 : end_main */
case 204:
    /*! Production::    view_statement_option : type_classes */
case 206:
    /*! Production::    view_statement_option2 : parameters */
case 208:
    /*! Production::    type_option : type_classes */
case 209:
    /*! Production::    child_group : tag */
case 210:
    /*! Production::    child_group : interpolation */
case 211:
    /*! Production::    child_group : control */
case 212:
    /*! Production::    child_group : characters */
case 213:
    /*! Production::    child_group : identifier */
case 215:
    /*! Production::    node_option : children */
case 217:
    /*! Production::    node_option2 : children */
case 219:
    /*! Production::    widget_option : children */
case 221:
    /*! Production::    widget_option2 : children */
case 222:
    /*! Production::    attribute_value_group : interpolation */
case 223:
    /*! Production::    attribute_value_group : literal */
case 224:
    /*! Production::    control_group : for_statement */
case 225:
    /*! Production::    control_group : if_statement */
case 226:
    /*! Production::    simple_expression_group : view_construction */
case 227:
    /*! Production::    simple_expression_group : fun_application */
case 228:
    /*! Production::    simple_expression_group : construct_expression */
case 229:
    /*! Production::    simple_expression_group : call_expression */
case 230:
    /*! Production::    simple_expression_group : member_expression */
case 231:
    /*! Production::    simple_expression_group : literal */
case 232:
    /*! Production::    simple_expression_group : context_property */
case 233:
    /*! Production::    simple_expression_group : cons */
case 234:
    /*! Production::    simple_expression_group : identifier */
case 235:
    /*! Production::    simple_expression_group : context_variable */
case 236:
    /*! Production::    readable_expression_group : string_literal */
case 237:
    /*! Production::    readable_expression_group : member_expression */
case 238:
    /*! Production::    readable_expression_group : context_property */
case 239:
    /*! Production::    readable_expression_group : call_expression */
case 240:
    /*! Production::    literal_group : record */
case 241:
    /*! Production::    literal_group : list */
case 242:
    /*! Production::    literal_group : string_literal */
case 243:
    /*! Production::    literal_group : number_literal */
case 244:
    /*! Production::    literal_group : boolean_literal */
case 245:
    /*! Production::    property_group : unqualified_identifier */
case 246:
    /*! Production::    property_group : string_literal */
case 247:
    /*! Production::    binary_operator_group : ">" */
case 248:
    /*! Production::    binary_operator_group : ">=" */
case 249:
    /*! Production::    binary_operator_group : "<" */
case 250:
    /*! Production::    binary_operator_group : "<=" */
case 251:
    /*! Production::    binary_operator_group : "==" */
case 252:
    /*! Production::    binary_operator_group : "!=" */
case 253:
    /*! Production::    binary_operator_group : "+" */
case 254:
    /*! Production::    binary_operator_group : "/" */
case 255:
    /*! Production::    binary_operator_group : "-" */
case 256:
    /*! Production::    binary_operator_group : "=" */
case 257:
    /*! Production::    binary_operator_group : "&&" */
case 258:
    /*! Production::    binary_operator_group : "||" */
case 259:
    /*! Production::    binary_operator_group : "^" */
case 260:
    /*! Production::    binary_operator_group : INSTANCEOF */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp];
    break;

case 28:
    /*! Production::    export_statement : "{%" EXPORT composite_member FROM string_literal "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ExportStatement(yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
    break;

case 29:
    /*! Production::    view_statement : "{%" VIEW unqualified_constructor view_statement_option "(" type ")" view_statement_option2 "%}" tag "{%" ENDVIEW "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 12, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ViewStatement(yyvstack[yysp - 10], yyvstack[yysp - 9]||[], yyvstack[yysp - 7], yyvstack[yysp - 5]||[], yyvstack[yysp - 3], this._$);
    break;

case 30:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier type_classes context_type parameters "%}" children "{%" ENDFUN "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 10, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 8], yyvstack[yysp - 7], yyvstack[yysp - 6], yyvstack[yysp - 5], yyvstack[yysp - 3], this._$);
    break;

case 31:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier type_classes context_type "%}" children "{%" ENDFUN "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 9, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 7], yyvstack[yysp - 6], yyvstack[yysp - 5], [], yyvstack[yysp - 3], this._$);
    break;

case 32:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier type_classes parameters "%}" children "{%" ENDFUN "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 9, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 7], yyvstack[yysp - 6], null, yyvstack[yysp - 5], yyvstack[yysp - 3], this._$);
    break;

case 33:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier type_classes "%}" children "{%" ENDFUN "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 8, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 6], yyvstack[yysp - 5], null, [], yyvstack[yysp - 3], this._$);
    break;

case 34:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier context_type parameters "%}" children "{%" ENDFUN "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 9, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 7], [], yyvstack[yysp - 6], yyvstack[yysp - 5], yyvstack[yysp - 3], this._$);
    break;

case 35:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier context_type "%}" children "{%" ENDFUN "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 8, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 6], [], yyvstack[yysp - 5], [], yyvstack[yysp - 3], this._$);
    break;

case 36:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier parameters "%}" children "{%" ENDFUN "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 8, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 6],[],null,yyvstack[yysp - 5],yyvstack[yysp - 3],this._$);
    break;

case 37:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier "%}" children "{%" ENDFUN "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 7, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 5],[],null,[],yyvstack[yysp - 3],this._$);
    break;

case 38:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier type_classes context_type parameters "=" child "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 8, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 6], yyvstack[yysp - 5], yyvstack[yysp - 4], yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
    break;

case 39:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier type_classes context_type "=" child "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 7, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 5], yyvstack[yysp - 4], yyvstack[yysp - 3], [], yyvstack[yysp - 1], this._$);
    break;

case 40:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier type_classes parameters "=" child "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 7, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 5], yyvstack[yysp - 4], null, yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
    break;

case 41:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier type_classes "=" child "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 4], yyvstack[yysp - 3], null, [], yyvstack[yysp - 1], this._$);
    break;

case 42:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier context_type parameters "=" child "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 7, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 5], [], yyvstack[yysp - 4], yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
    break;

case 43:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier context_type "=" child "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 4], [], yyvstack[yysp - 3], [], yyvstack[yysp - 1], this._$);
    break;

case 44:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier parameters "=" child "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 4],[],null,yyvstack[yysp - 3],yyvstack[yysp - 1],this._$);
    break;

case 45:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier "=" child "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 3],[],null,[],yyvstack[yysp - 1],this._$);
    break;

case 46:
    /*! Production::    context_type : "(" type ")" */
case 47:
    /*! Production::    type_classes : "[" type_class_list "]" */
case 58:
    /*! Production::    parameters : "(" parameter_list ")" */
case 100:
    /*! Production::    arguments : "(" argument_list ")" */
case 109:
    /*! Production::    expression : "(" expression ")" */
case 125:
    /*! Production::    fun_target : "(" expression ")" */
case 126:
    /*! Production::    type_arguments : "[" type_arg_list "]" */
case 159:
    /*! Production::    readable_expression : "(" expression ")" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp - 1];
    break;

case 50:
    /*! Production::    type_class : unqualified_identifier */
case 52:
    /*! Production::    type_class : unqualified_constructor */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.TypeClass(yyvstack[yysp], null, this._$);
    break;

case 51:
    /*! Production::    type_class : unqualified_identifier ":" type */
case 53:
    /*! Production::    type_class : unqualified_constructor ":" type */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.TypeClass(yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 54:
    /*! Production::    type : cons type_option */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Type(yyvstack[yysp - 1], yyvstack[yysp]||[], false, this._$);
    break;

case 55:
    /*! Production::    type : cons type_classes "[" "]" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Type(yyvstack[yysp - 3], yyvstack[yysp - 2], true, this._$);
    break;

case 56:
    /*! Production::    type : cons "[" "]" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Type(yyvstack[yysp - 2], [], true, this._$);
    break;

case 57:
    /*! Production::    parameters : "(" ")" */
case 99:
    /*! Production::    arguments : "(" ")" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = [];
    break;

case 61:
    /*! Production::    parameter : unqualified_identifier ":" type */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.TypedParameter(yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 62:
    /*! Production::    parameter : unqualified_identifier */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.UntypedParameter(yyvstack[yysp], this._$);
    break;

case 68:
    /*! Production::    node : "<" identifier attributes ">" node_option "</" identifier ">" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 7, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Node(yyvstack[yysp - 6], yyvstack[yysp - 5], yyvstack[yysp - 3]||[], yyvstack[yysp - 1], this._$);
    break;

case 69:
    /*! Production::    node : "<" identifier ">" node_option2 "</" identifier ">" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Node(yyvstack[yysp - 5], [], yyvstack[yysp - 3]||[], yyvstack[yysp - 1], this._$);
    break;

case 70:
    /*! Production::    node : "<" identifier attributes "/>" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Node(yyvstack[yysp - 2], yyvstack[yysp - 1], [], yyvstack[yysp - 2], this._$);
    break;

case 71:
    /*! Production::    node : "<" identifier "/>" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Node(yyvstack[yysp - 1], [], [], yyvstack[yysp - 1], this._$);
    break;

case 72:
    /*! Production::    widget : "<" cons attributes ">" widget_option "</" cons ">" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 7, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Widget(yyvstack[yysp - 6], yyvstack[yysp - 5], yyvstack[yysp - 3]||[], yyvstack[yysp - 1], this._$);
    break;

case 73:
    /*! Production::    widget : "<" cons ">" widget_option2 "</" cons ">" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Widget(yyvstack[yysp - 5], [], yyvstack[yysp - 3]||[], yyvstack[yysp - 1], this._$);
    break;

case 74:
    /*! Production::    widget : "<" cons attributes "/>" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Widget(yyvstack[yysp - 2], yyvstack[yysp - 1], [], yyvstack[yysp - 2], this._$);
    break;

case 75:
    /*! Production::    widget : "<" cons "/>" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Widget(yyvstack[yysp - 1], [], [], yyvstack[yysp - 1], this._$);
    break;

case 78:
    /*! Production::    attribute : unqualified_identifier ":" unqualified_identifier "=" attribute_value */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Attribute(yyvstack[yysp - 4], yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 79:
    /*! Production::    attribute : unqualified_identifier "=" attribute_value */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ =
    new yy.ast.Attribute(new yy.ast.UnqualifiedIdentifier('html', this._$),
    yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 80:
    /*! Production::    attribute : unqualified_identifier ":" unqualified_identifier */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Attribute(yyvstack[yysp - 2], yyvstack[yysp], new yy.ast.BooleanLiteral(true, this._$), this._$);
    break;

case 81:
    /*! Production::    attribute : unqualified_identifier */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Attribute(
    new yy.ast.UnqualifiedIdentifier('html', this._$),
    yyvstack[yysp], new yy.ast.BooleanLiteral(true, this._$), this._$);
    break;

case 83:
    /*! Production::    interpolation : "{{" expression "}}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Interpolation(yyvstack[yysp - 1], [], this._$);
    break;

case 84:
    /*! Production::    interpolation : "{{" expression filters "}}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Interpolation(yyvstack[yysp - 2], yyvstack[yysp - 1], this._$);
    break;

case 87:
    /*! Production::    filter : "|" expression */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp]
    break;

case 89:
    /*! Production::    for_statement : "{%" FOR parameter IN expression "%}" children "{%" ENDFOR "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 9, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ForStatement(yyvstack[yysp - 7], null, null, yyvstack[yysp - 5], yyvstack[yysp - 3], [], this._$);
    break;

case 90:
    /*! Production::    for_statement : "{%" FOR parameter "," parameter IN expression "%}" children "{%" ENDFOR "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 11, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ForStatement(yyvstack[yysp - 9], yyvstack[yysp - 7], null, yyvstack[yysp - 5], yyvstack[yysp - 3], [], this._$);
    break;

case 91:
    /*! Production::    for_statement : "{%" FOR parameter "," parameter "," parameter IN expression "%}" children "{%" ENDFOR "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 13, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ForStatement(yyvstack[yysp - 11], yyvstack[yysp - 9], yyvstack[yysp - 7], yyvstack[yysp - 5], yyvstack[yysp - 3], [], this._$);
    break;

case 92:
    /*! Production::    for_statement : "{%" FOR parameter IN expression "%}" children "{%" ELSE "%}" children "{%" ENDFOR "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 13, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ForStatement(yyvstack[yysp - 11], null, null, yyvstack[yysp - 9], yyvstack[yysp - 7], yyvstack[yysp - 3], this._$);
    break;

case 93:
    /*! Production::    for_statement : "{%" FOR parameter "," parameter IN expression "%}" children "{%" ELSE "%}" children "{%" ENDFOR "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 15, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ForStatement(yyvstack[yysp - 13], yyvstack[yysp - 11], null, yyvstack[yysp - 9], yyvstack[yysp - 7], yyvstack[yysp - 3], this._$);
    break;

case 94:
    /*! Production::    for_statement : "{%" FOR parameter "," parameter "," parameter IN expression "%}" children "{%" ELSE "%}" children "{%" ENDFOR "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 17, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ForStatement(yyvstack[yysp - 15], yyvstack[yysp - 13], null, yyvstack[yysp - 11], yyvstack[yysp - 9], yyvstack[yysp - 3], this._$);
    break;

case 95:
    /*! Production::    if_statement : "{%" IF expression "%}" children else_clause */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.IfStatement(yyvstack[yysp - 3], yyvstack[yysp - 1], yyvstack[yysp], this._$);
    break;

case 96:
    /*! Production::    else_clause : "{%" ELSE "%}" children "{%" ENDIF "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ElseClause(yyvstack[yysp - 3], this._$);
    break;

case 97:
    /*! Production::    else_clause : "{%" ELSE IF expression "%}" children else_clause */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ElseIfClause(yyvstack[yysp - 3], yyvstack[yysp - 1], yyvstack[yysp], this._$);
    break;

case 98:
    /*! Production::    characters : CHARACTERS */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Characters(yyvstack[yysp], this._$);
    break;

case 105:
    /*! Production::    expression : unary_expression */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ =yyvstack[yysp];
    break;

case 110:
    /*! Production::    if_expression : IF expression THEN expression ELSE expression */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.IfThenExpression(yyvstack[yysp - 4], yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 111:
    /*! Production::    binary_expression : simple_expression binary_operator simple_expression */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.BinaryExpression(yyvstack[yysp - 2], yyvstack[yysp - 1], yyvstack[yysp], this._$);
    break;

case 112:
    /*! Production::    binary_expression : simple_expression binary_operator "(" expression ")" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.BinaryExpression(yyvstack[yysp - 4], yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
    break;

case 113:
    /*! Production::    binary_expression : "(" expression ")" binary_operator simple_expression */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.BinaryExpression(yyvstack[yysp - 3], yyvstack[yysp - 1], yyvstack[yysp], this._$);
    break;

case 114:
    /*! Production::    binary_expression : "(" expression ")" binary_operator "(" expression ")" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.BinaryExpression(yyvstack[yysp - 5], yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
    break;

case 115:
    /*! Production::    unary_expression : "!" simple_expression */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.UnaryExpression(yyvstack[yysp - 1], yyvstack[yysp], this._$);
    break;

case 116:
    /*! Production::    unary_expression : "!" "(" expression ")" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.UnaryExpression(yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
    break;

case 118:
    /*! Production::    view_construction : "<" cons arguments ">" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ViewConstruction(yyvstack[yysp - 2], yyvstack[yysp - 1], this._$);
    break;

case 119:
    /*! Production::    fun_application : "<" fun_target type_arguments arguments arguments ">" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunApplication(yyvstack[yysp - 4], yyvstack[yysp - 3], yyvstack[yysp - 2], yyvstack[yysp - 1], this._$);
    break;

case 120:
    /*! Production::    fun_application : "<" fun_target type_arguments arguments ">" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunApplication(yyvstack[yysp - 3], yyvstack[yysp - 2], [], yyvstack[yysp - 1], this._$);
    break;

case 121:
    /*! Production::    fun_application : "<" fun_target arguments arguments ">" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunApplication(yyvstack[yysp - 3], [], yyvstack[yysp - 2], yyvstack[yysp - 1], this._$);
    break;

case 122:
    /*! Production::    fun_application : "<" fun_target arguments ">" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunApplication(yyvstack[yysp - 2], [], [], yyvstack[yysp - 1], this._$);
    break;

case 129:
    /*! Production::    construct_expression : cons arguments */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ConstructExpression(yyvstack[yysp - 1], yyvstack[yysp], this._$);
    break;

case 130:
    /*! Production::    call_expression : identifier type_arguments arguments */
case 132:
    /*! Production::    call_expression : context_property type_arguments arguments */
case 134:
    /*! Production::    call_expression : member_expression type_arguments arguments */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.CallExpression(yyvstack[yysp - 2], yyvstack[yysp - 1], yyvstack[yysp], this._$);
    break;

case 131:
    /*! Production::    call_expression : identifier arguments */
case 133:
    /*! Production::    call_expression : context_property arguments */
case 135:
    /*! Production::    call_expression : member_expression arguments */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.CallExpression(yyvstack[yysp - 1], [], yyvstack[yysp], this._$);
    break;

case 136:
    /*! Production::    call_expression : "(" expression ")" type_arguments arguments */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.CallExpression(yyvstack[yysp - 3], yyvstack[yysp - 1], yyvstack[yysp], this._$);
    break;

case 137:
    /*! Production::    call_expression : "(" expression ")" arguments */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.CallExpression(yyvstack[yysp - 2], [], yyvstack[yysp], this._$);
    break;

case 138:
    /*! Production::    member_expression : qualified_identifier "." unqualified_identifier */
case 139:
    /*! Production::    member_expression : qualified_constructor "." unqualified_identifier */
case 140:
    /*! Production::    member_expression : context_variable "." unqualified_identifier */
case 141:
    /*! Production::    member_expression : context_property "." unqualified_identifier */
case 142:
    /*! Production::    member_expression : list "." unqualified_identifier */
case 143:
    /*! Production::    member_expression : record "." unqualified_identifier */
case 144:
    /*! Production::    member_expression : string_literal "." unqualified_identifier */
case 145:
    /*! Production::    member_expression : call_expression "." unqualified_identifier */
case 147:
    /*! Production::    member_expression : member_expression "." unqualified_identifier */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.MemberExpression(yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 146:
    /*! Production::    member_expression : "(" expression ")" "." unqualified_identifier */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.MemberExpression(yyvstack[yysp - 3], yyvstack[yysp], this._$);
    break;

case 148:
    /*! Production::    read_expression : identifier "[" readable_expression AS type "]" */
case 150:
    /*! Production::    read_expression : context_variable "[" readable_expression AS type "]" */
case 152:
    /*! Production::    read_expression : context_property "[" readable_expression AS type "]" */
case 154:
    /*! Production::    read_expression : member_expression "[" readable_expression AS type "]" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ReadExpression(yyvstack[yysp - 5], yyvstack[yysp - 3], yyvstack[yysp - 1], null, this._$);
    break;

case 149:
    /*! Production::    read_expression : identifier "[" readable_expression AS type "?" expression "]" */
case 151:
    /*! Production::    read_expression : context_variable "[" readable_expression AS type "?" expression "]" */
case 153:
    /*! Production::    read_expression : context_property "[" readable_expression AS type "?" expression "]" */
case 155:
    /*! Production::    read_expression : member_expression "[" readable_expression AS type "?" expression "]" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 7, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ReadExpression(yyvstack[yysp - 7], yyvstack[yysp - 5], yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
    break;

case 156:
    /*! Production::    read_expression : "(" expression ")" "[" expression AS type "?" expression "]" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 9, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ReadExpression(yyvstack[yysp - 9], yyvstack[yysp - 7], yyvstack[yysp - 5], yyvstack[yysp - 3], this._$);
    break;

case 157:
    /*! Production::    read_expression : "(" expression ")" "[" expression AS type "]" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 7, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ReadExpression(yyvstack[yysp - 7], yyvstack[yysp - 5], yyvstack[yysp - 3], null, this._$);
    break;

case 160:
    /*! Production::    function_expression : "\\" parameter_list "=>" expression */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunctionExpression(yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 161:
    /*! Production::    function_expression : "=>" expression */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunctionExpression([], yyvstack[yysp], this._$);
    break;

case 163:
    /*! Production::    record : "{" "}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Record([], this._$);
    break;

case 164:
    /*! Production::    record : "{" properties "}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Record(yyvstack[yysp - 1], this._$);
    break;

case 167:
    /*! Production::    property : property_group ":" expression */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Property(yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 168:
    /*! Production::    list : "[" "]" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.List([], this._$);
    break;

case 169:
    /*! Production::    list : "[" argument_list "]" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.List(yyvstack[yysp - 1], this._$);
    break;

case 170:
    /*! Production::    string_literal : STRING_LITERAL */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.StringLiteral(yyvstack[yysp].slice(1, yyvstack[yysp].length - 1, this._$));
    break;

case 171:
    /*! Production::    number_literal : NUMBER_LITERAL */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.NumberLiteral(yyvstack[yysp], this._$);
    break;

case 172:
    /*! Production::    boolean_literal : TRUE */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.BooleanLiteral(true, this._$);
    break;

case 173:
    /*! Production::    boolean_literal : FALSE */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.BooleanLiteral(false, this._$);
    break;

case 174:
    /*! Production::    context_property : "@" unqualified_identifier */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ContextProperty(yyvstack[yysp], this._$)
    break;

case 175:
    /*! Production::    context_variable : "@" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ContextVariable(this._$);
    break;

case 178:
    /*! Production::    qualified_constructor : IDENTIFIER "." CONSTRUCTOR */
case 179:
    /*! Production::    qualified_constructor : CONSTRUCTOR "." CONSTRUCTOR */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.QualifiedConstructor(yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 180:
    /*! Production::    unqualified_constructor : CONSTRUCTOR */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.UnqualifiedConstructor(yyvstack[yysp], this._$);
    break;

case 183:
    /*! Production::    qualified_identifier : IDENTIFIER "." IDENTIFIER */
case 184:
    /*! Production::    qualified_identifier : CONSTRUCTOR "." IDENTIFIER */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.QualifiedIdentifier(yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 185:
    /*! Production::    unqualified_identifier : IDENTIFIER */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.UnqualifiedIdentifier(yyvstack[yysp], this._$);
    break;

case 187:
    /*! Production::    import_statement_option : %epsilon */
case 195:
    /*! Production::    main_option : %epsilon */
case 197:
    /*! Production::    main_option2 : %epsilon */
case 199:
    /*! Production::    main_option3 : %epsilon */
case 201:
    /*! Production::    main_option4 : %epsilon */
case 203:
    /*! Production::    view_statement_option : %epsilon */
case 205:
    /*! Production::    view_statement_option2 : %epsilon */
case 207:
    /*! Production::    type_option : %epsilon */
case 214:
    /*! Production::    node_option : %epsilon */
case 216:
    /*! Production::    node_option2 : %epsilon */
case 218:
    /*! Production::    widget_option : %epsilon */
case 220:
    /*! Production::    widget_option2 : %epsilon */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(null, null, null, null, true);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = undefined;
    break;

}
},
table: bt({
  len: u([
  15,
  1,
  14,
  11,
  1,
  0,
  0,
  4,
  0,
  12,
  s,
  [0, 5],
  8,
  c,
  [13, 4],
  c,
  [3, 3],
  0,
  5,
  s,
  [2, 3],
  c,
  [8, 4],
  1,
  1,
  9,
  s,
  [0, 5],
  6,
  6,
  s,
  [0, 4],
  29,
  29,
  c,
  [20, 4],
  4,
  0,
  1,
  4,
  7,
  2,
  6,
  6,
  2,
  0,
  3,
  0,
  5,
  23,
  c,
  [44, 3],
  c,
  [5, 3],
  2,
  2,
  c,
  [55, 3],
  6,
  c,
  [51, 3],
  5,
  4,
  2,
  21,
  20,
  10,
  c,
  [46, 5],
  8,
  c,
  [28, 3],
  1,
  21,
  s,
  [0, 7],
  43,
  s,
  [0, 4],
  10,
  1,
  2,
  2,
  17,
  23,
  c,
  [21, 7],
  c,
  [64, 4],
  3,
  1,
  6,
  c,
  [48, 4],
  c,
  [3, 3],
  5,
  21,
  20,
  20,
  1,
  1,
  0,
  2,
  9,
  c,
  [66, 3],
  c,
  [115, 4],
  3,
  c,
  [38, 3],
  5,
  c,
  [107, 3],
  0,
  0,
  26,
  c,
  [61, 3],
  43,
  33,
  0,
  28,
  26,
  29,
  29,
  4,
  c,
  [70, 4],
  25,
  0,
  26,
  27,
  28,
  27,
  s,
  [25, 3],
  12,
  0,
  45,
  8,
  s,
  [0, 5],
  1,
  1,
  3,
  43,
  c,
  [42, 4],
  c,
  [12, 5],
  21,
  5,
  c,
  [71, 3],
  5,
  c,
  [176, 3],
  1,
  c,
  [86, 3],
  c,
  [85, 4],
  c,
  [4, 4],
  20,
  1,
  3,
  c,
  [84, 5],
  7,
  7,
  6,
  1,
  1,
  5,
  1,
  c,
  [10, 3],
  c,
  [82, 3],
  s,
  [0, 14],
  c,
  [54, 3],
  43,
  15,
  15,
  14,
  11,
  24,
  2,
  0,
  45,
  20,
  2,
  24,
  c,
  [209, 3],
  c,
  [4, 4],
  2,
  0,
  c,
  [4, 5],
  s,
  [2, 4],
  c,
  [98, 3],
  43,
  c,
  [13, 4],
  c,
  [3, 3],
  c,
  [262, 3],
  2,
  1,
  17,
  5,
  1,
  c,
  [117, 4],
  4,
  c,
  [96, 8],
  c,
  [4, 4],
  c,
  [182, 3],
  c,
  [29, 4],
  c,
  [294, 4],
  c,
  [46, 3],
  31,
  43,
  1,
  7,
  1,
  2,
  c,
  [251, 3],
  c,
  [301, 4],
  s,
  [1, 3],
  c,
  [47, 3],
  c,
  [7, 4],
  c,
  [34, 7],
  c,
  [274, 5],
  c,
  [10, 3],
  2,
  3,
  c,
  [122, 3],
  0,
  6,
  43,
  43,
  3,
  21,
  c,
  [62, 5],
  1,
  c,
  [74, 8],
  c,
  [3, 3],
  c,
  [387, 5],
  33,
  45,
  c,
  [350, 4],
  15,
  6,
  0,
  6,
  c,
  [355, 3],
  c,
  [393, 4],
  c,
  [49, 3],
  c,
  [58, 6],
  21,
  0,
  4,
  4,
  c,
  [38, 5],
  c,
  [17, 3],
  15,
  0,
  43,
  1,
  22,
  c,
  [163, 5],
  6,
  c,
  [444, 6],
  21,
  43,
  c,
  [70, 3],
  4,
  c,
  [67, 6],
  c,
  [53, 3],
  43,
  c,
  [101, 3],
  c,
  [4, 4],
  c,
  [358, 3],
  c,
  [196, 3],
  c,
  [23, 3],
  15,
  c,
  [140, 4],
  1,
  4,
  21,
  43,
  21,
  43,
  1,
  1,
  c,
  [141, 6],
  1,
  c,
  [201, 3],
  20,
  c,
  [158, 5],
  21,
  4,
  21,
  c,
  [143, 3],
  c,
  [44, 3],
  c,
  [320, 3],
  3,
  c,
  [14, 3],
  c,
  [20, 3],
  c,
  [415, 4],
  c,
  [11, 3],
  1,
  20,
  c,
  [128, 4]
]),
  symbol: u([
  13,
  25,
  28,
  64,
  65,
  66,
  73,
  s,
  [75, 5, 1],
  90,
  91,
  92,
  1,
  1,
  c,
  [17, 3],
  c,
  [15, 11],
  13,
  28,
  73,
  c,
  [11, 8],
  29,
  32,
  33,
  35,
  3,
  4,
  55,
  56,
  s,
  [67, 4, 1],
  72,
  134,
  137,
  142,
  55,
  56,
  s,
  [132, 6, 1],
  c,
  [36, 12],
  1,
  7,
  10,
  56,
  134,
  143,
  4,
  70,
  56,
  134,
  55,
  137,
  26,
  27,
  27,
  55,
  56,
  68,
  71,
  c,
  [43, 3],
  140,
  142,
  14,
  38,
  55,
  93,
  94,
  137,
  c,
  [6, 6],
  s,
  [5, 7, 1],
  13,
  14,
  15,
  17,
  s,
  [21, 4, 1],
  27,
  30,
  38,
  40,
  44,
  48,
  55,
  s,
  [57, 7, 1],
  c,
  [29, 29],
  c,
  [94, 3],
  81,
  144,
  26,
  c,
  [5, 3],
  147,
  7,
  9,
  10,
  30,
  80,
  81,
  85,
  51,
  127,
  55,
  56,
  c,
  [139, 6],
  c,
  [6, 4],
  5,
  6,
  5,
  6,
  27,
  c,
  [100, 3],
  94,
  137,
  13,
  28,
  37,
  39,
  47,
  55,
  56,
  s,
  [88, 5, 1],
  96,
  99,
  100,
  101,
  103,
  c,
  [167, 3],
  150,
  152,
  156,
  9,
  12,
  c,
  [30, 3],
  c,
  [33, 26],
  154,
  156,
  55,
  56,
  55,
  56,
  7,
  55,
  56,
  82,
  83,
  134,
  137,
  51,
  127,
  7,
  7,
  9,
  30,
  80,
  85,
  c,
  [5, 3],
  85,
  9,
  30,
  13,
  28,
  c,
  [47, 18],
  156,
  c,
  [21, 6],
  c,
  [20, 14],
  8,
  55,
  56,
  84,
  86,
  87,
  c,
  [281, 3],
  c,
  [279, 3],
  20,
  25,
  28,
  139,
  c,
  [258, 3],
  c,
  [155, 3],
  141,
  142,
  c,
  [113, 21],
  151,
  156,
  37,
  c,
  [24, 7],
  c,
  [69, 14],
  s,
  [4, 6, 3],
  45,
  s,
  [49, 8, 1],
  s,
  [106, 7, 1],
  s,
  [116, 4, 1],
  121,
  122,
  123,
  s,
  [126, 12, 1],
  157,
  159,
  13,
  14,
  17,
  28,
  30,
  c,
  [67, 5],
  17,
  41,
  45,
  55,
  137,
  4,
  10,
  39,
  c,
  [52, 4],
  95,
  96,
  c,
  [40, 6],
  155,
  159,
  c,
  [120, 21],
  153,
  c,
  [120, 23],
  c,
  [188, 3],
  c,
  [88, 3],
  6,
  11,
  6,
  11,
  12,
  c,
  [3, 3],
  30,
  c,
  [15, 6],
  c,
  [257, 47],
  c,
  [300, 45],
  86,
  87,
  c,
  [394, 3],
  c,
  [46, 39],
  c,
  [20, 20],
  30,
  8,
  6,
  8,
  6,
  8,
  10,
  11,
  18,
  42,
  50,
  81,
  149,
  6,
  8,
  12,
  42,
  50,
  c,
  [5, 3],
  17,
  c,
  [18, 4],
  14,
  17,
  c,
  [20, 3],
  c,
  [527, 3],
  c,
  [233, 24],
  c,
  [7, 3],
  15,
  40,
  97,
  98,
  5,
  6,
  8,
  9,
  c,
  [621, 4],
  c,
  [620, 6],
  c,
  [619, 3],
  c,
  [618, 7],
  138,
  161,
  c,
  [388, 43],
  c,
  [43, 47],
  19,
  c,
  [39, 6],
  c,
  [35, 6],
  c,
  [33, 16],
  c,
  [768, 10],
  c,
  [147, 16],
  104,
  114,
  c,
  [173, 4],
  c,
  [795, 12],
  c,
  [28, 10],
  c,
  [822, 17],
  c,
  [55, 14],
  c,
  [29, 27],
  c,
  [387, 4],
  c,
  [192, 43],
  c,
  [304, 8],
  c,
  [130, 22],
  c,
  [183, 21],
  c,
  [127, 27],
  c,
  [209, 19],
  c,
  [1003, 8],
  c,
  [1062, 18],
  c,
  [55, 14],
  c,
  [25, 71],
  7,
  19,
  55,
  56,
  113,
  130,
  c,
  [222, 6],
  c,
  [263, 3],
  11,
  c,
  [264, 12],
  s,
  [105, 8, 1],
  c,
  [265, 22],
  51,
  55,
  124,
  125,
  127,
  137,
  160,
  s,
  [55, 3],
  c,
  [321, 45],
  9,
  c,
  [1151, 3],
  c,
  [660, 24],
  c,
  [36, 3],
  8,
  17,
  55,
  56,
  c,
  [1149, 3],
  c,
  [890, 6],
  c,
  [6, 6],
  8,
  c,
  [850, 43],
  c,
  [845, 62],
  c,
  [62, 68],
  c,
  [21, 15],
  36,
  c,
  [1173, 3],
  87,
  137,
  c,
  [931, 7],
  11,
  c,
  [1370, 6],
  c,
  [215, 6],
  56,
  c,
  [1387, 3],
  c,
  [36, 3],
  14,
  15,
  40,
  98,
  c,
  [832, 76],
  8,
  48,
  c,
  [718, 45],
  7,
  c,
  [154, 3],
  15,
  17,
  c,
  [530, 5],
  c,
  [809, 6],
  c,
  [15, 18],
  c,
  [14, 9],
  8,
  c,
  [27, 8],
  c,
  [98, 3],
  19,
  51,
  c,
  [198, 3],
  115,
  117,
  118,
  120,
  c,
  [82, 3],
  c,
  [80, 8],
  158,
  7,
  104,
  4,
  c,
  [50, 3],
  c,
  [579, 41],
  c,
  [71, 7],
  c,
  [69, 8],
  133,
  c,
  [67, 4],
  c,
  [1474, 3],
  c,
  [93, 23],
  55,
  137,
  c,
  [95, 4],
  c,
  [28, 26],
  6,
  50,
  55,
  137,
  55,
  137,
  c,
  [4, 8],
  7,
  104,
  7,
  10,
  104,
  114,
  c,
  [267, 43],
  55,
  137,
  6,
  11,
  5,
  6,
  12,
  6,
  42,
  30,
  c,
  [1603, 17],
  c,
  [665, 5],
  14,
  7,
  30,
  85,
  145,
  c,
  [4, 3],
  148,
  c,
  [549, 86],
  c,
  [24, 24],
  c,
  [3, 3],
  30,
  11,
  14,
  c,
  [467, 47],
  c,
  [1261, 25],
  c,
  [1494, 45],
  c,
  [1994, 4],
  115,
  c,
  [13, 3],
  27,
  6,
  11,
  c,
  [54, 43],
  17,
  27,
  7,
  10,
  17,
  27,
  104,
  114,
  c,
  [6, 6],
  17,
  27,
  s,
  [17, 3],
  c,
  [394, 4],
  6,
  8,
  c,
  [10, 3],
  27,
  27,
  c,
  [73, 43],
  14,
  c,
  [451, 3],
  14,
  104,
  8,
  c,
  [50, 43],
  51,
  55,
  c,
  [1169, 4],
  c,
  [1720, 86],
  c,
  [965, 3],
  c,
  [505, 21],
  14,
  30,
  c,
  [467, 25],
  c,
  [443, 4],
  c,
  [4, 4],
  30,
  c,
  [196, 5],
  c,
  [949, 29],
  c,
  [137, 15],
  84,
  c,
  [138, 7],
  s,
  [115, 5, 1],
  c,
  [682, 19],
  7,
  104,
  44,
  c,
  [939, 15],
  c,
  [1328, 13],
  c,
  [13, 12],
  c,
  [2243, 7],
  14,
  104,
  14,
  30,
  6,
  42,
  c,
  [170, 14],
  102,
  c,
  [679, 7],
  c,
  [15, 3],
  c,
  [4, 4],
  c,
  [171, 5],
  30,
  c,
  [88, 15],
  c,
  [290, 43],
  27,
  6,
  c,
  [2708, 3],
  c,
  [632, 3],
  c,
  [630, 5],
  c,
  [626, 7],
  81,
  104,
  149,
  c,
  [66, 43],
  11,
  18,
  c,
  [565, 6],
  11,
  18,
  11,
  18,
  11,
  18,
  14,
  c,
  [368, 21],
  c,
  [435, 46],
  41,
  44,
  45,
  1,
  28,
  74,
  146,
  28,
  30,
  c,
  [276, 7],
  c,
  [2260, 90],
  c,
  [43, 82],
  c,
  [599, 21],
  42,
  30,
  45,
  31,
  34,
  c,
  [420, 15],
  c,
  [301, 3],
  s,
  [11, 3],
  41,
  43,
  44,
  c,
  [1093, 7],
  c,
  [306, 58],
  c,
  [64, 64],
  30,
  30,
  c,
  [45, 45],
  c,
  [1313, 42],
  11,
  c,
  [154, 21],
  c,
  [243, 25],
  41,
  45,
  46,
  c,
  [1446, 41],
  c,
  [135, 37],
  c,
  [811, 7],
  41,
  43,
  c,
  [112, 23],
  c,
  [137, 3],
  c,
  [71, 22],
  30,
  c,
  [51, 24],
  c,
  [47, 21],
  c,
  [45, 3],
  30
]),
  type: u([
  s,
  [2, 3],
  s,
  [0, 12],
  1,
  s,
  [2, 4],
  s,
  [0, 10],
  c,
  [13, 11],
  s,
  [2, 9],
  c,
  [17, 10],
  c,
  [36, 22],
  c,
  [7, 3],
  0,
  2,
  c,
  [4, 4],
  c,
  [45, 11],
  c,
  [10, 6],
  c,
  [6, 9],
  s,
  [2, 58],
  c,
  [69, 7],
  c,
  [91, 7],
  c,
  [101, 4],
  c,
  [139, 10],
  c,
  [36, 13],
  c,
  [200, 14],
  c,
  [195, 14],
  c,
  [33, 32],
  c,
  [11, 5],
  c,
  [100, 7],
  c,
  [5, 4],
  c,
  [250, 16],
  c,
  [46, 13],
  c,
  [20, 17],
  c,
  [268, 13],
  c,
  [293, 11],
  c,
  [146, 30],
  c,
  [22, 20],
  c,
  [53, 23],
  c,
  [43, 26],
  c,
  [103, 18],
  c,
  [120, 47],
  c,
  [83, 15],
  c,
  [210, 8],
  c,
  [257, 46],
  c,
  [43, 42],
  c,
  [25, 23],
  c,
  [89, 27],
  c,
  [254, 25],
  c,
  [600, 31],
  c,
  [122, 21],
  c,
  [52, 26],
  c,
  [388, 59],
  c,
  [43, 40],
  c,
  [76, 37],
  c,
  [225, 42],
  c,
  [55, 53],
  c,
  [743, 4],
  c,
  [235, 60],
  c,
  [128, 36],
  c,
  [1000, 55],
  s,
  [2, 106],
  c,
  [220, 24],
  s,
  [0, 29],
  c,
  [32, 8],
  c,
  [556, 60],
  c,
  [782, 23],
  c,
  [905, 11],
  c,
  [1400, 21],
  c,
  [804, 47],
  c,
  [845, 48],
  c,
  [62, 76],
  c,
  [642, 17],
  c,
  [215, 14],
  c,
  [1118, 15],
  c,
  [832, 85],
  c,
  [718, 41],
  c,
  [15, 29],
  c,
  [762, 20],
  c,
  [79, 18],
  c,
  [579, 49],
  c,
  [36, 17],
  c,
  [1474, 19],
  c,
  [26, 10],
  c,
  [28, 32],
  c,
  [1912, 8],
  c,
  [16, 7],
  c,
  [664, 46],
  c,
  [45, 26],
  c,
  [1979, 10],
  c,
  [84, 10],
  c,
  [549, 81],
  c,
  [1798, 34],
  c,
  [1185, 65],
  c,
  [1451, 50],
  c,
  [82, 23],
  c,
  [128, 34],
  c,
  [735, 8],
  c,
  [1412, 31],
  c,
  [73, 30],
  c,
  [3, 6],
  c,
  [50, 45],
  c,
  [1485, 61],
  c,
  [543, 30],
  c,
  [505, 28],
  c,
  [443, 64],
  c,
  [822, 44],
  c,
  [777, 12],
  c,
  [351, 11],
  c,
  [257, 13],
  c,
  [13, 12],
  c,
  [332, 9],
  c,
  [1351, 24],
  c,
  [4, 8],
  c,
  [2053, 78],
  c,
  [48, 8],
  c,
  [571, 55],
  c,
  [1525, 30],
  c,
  [435, 45],
  c,
  [7, 9],
  c,
  [2260, 99],
  c,
  [43, 81],
  c,
  [356, 33],
  c,
  [1975, 33],
  c,
  [115, 63],
  c,
  [515, 61],
  c,
  [45, 36],
  c,
  [1313, 43],
  c,
  [111, 25],
  c,
  [917, 38],
  c,
  [2991, 43],
  c,
  [88, 52],
  c,
  [2975, 32],
  c,
  [232, 38]
]),
  state: u([
  1,
  2,
  5,
  4,
  3,
  6,
  10,
  11,
  12,
  8,
  13,
  14,
  19,
  17,
  16,
  c,
  [10, 7],
  20,
  22,
  c,
  [8, 6],
  28,
  30,
  29,
  31,
  33,
  37,
  36,
  35,
  41,
  44,
  45,
  40,
  42,
  43,
  48,
  c,
  [22, 7],
  53,
  52,
  54,
  55,
  56,
  63,
  60,
  62,
  37,
  36,
  61,
  35,
  64,
  67,
  68,
  69,
  67,
  68,
  76,
  75,
  80,
  79,
  82,
  81,
  83,
  87,
  89,
  c,
  [44, 3],
  90,
  c,
  [4, 3],
  95,
  68,
  97,
  98,
  100,
  13,
  14,
  101,
  102,
  108,
  109,
  103,
  104,
  42,
  43,
  99,
  96,
  106,
  95,
  68,
  118,
  c,
  [18, 13],
  117,
  106,
  124,
  125,
  127,
  126,
  128,
  130,
  131,
  134,
  140,
  c,
  [24, 13],
  106,
  141,
  c,
  [14, 13],
  142,
  144,
  146,
  145,
  44,
  45,
  147,
  150,
  154,
  153,
  37,
  36,
  152,
  35,
  156,
  c,
  [43, 13],
  155,
  106,
  158,
  c,
  [44, 13],
  s,
  [159, 5, 1],
  s,
  [176, 4, 1],
  173,
  164,
  165,
  180,
  186,
  185,
  187,
  192,
  193,
  172,
  171,
  181,
  184,
  45,
  170,
  182,
  43,
  169,
  189,
  201,
  202,
  s,
  [204, 5, 1],
  192,
  193,
  203,
  189,
  210,
  c,
  [69, 13],
  209,
  c,
  [69, 15],
  212,
  c,
  [111, 3],
  219,
  c,
  [4, 3],
  220,
  225,
  c,
  [151, 14],
  226,
  c,
  [14, 13],
  229,
  c,
  [29, 14],
  230,
  c,
  [14, 13],
  144,
  146,
  147,
  231,
  c,
  [32, 14],
  232,
  c,
  [14, 13],
  c,
  [113, 14],
  239,
  238,
  c,
  [16, 14],
  245,
  42,
  43,
  247,
  248,
  250,
  251,
  266,
  c,
  [205, 27],
  267,
  c,
  [28, 27],
  268,
  c,
  [24, 4],
  270,
  c,
  [22, 6],
  271,
  273,
  c,
  [22, 3],
  272,
  c,
  [22, 4],
  276,
  275,
  283,
  282,
  287,
  286,
  288,
  146,
  147,
  289,
  c,
  [59, 27],
  291,
  293,
  299,
  301,
  298,
  44,
  45,
  300,
  42,
  43,
  305,
  306,
  c,
  [39, 27],
  308,
  309,
  312,
  311,
  310,
  313,
  147,
  314,
  c,
  [35, 27],
  c,
  [210, 14],
  317,
  44,
  45,
  319,
  127,
  126,
  320,
  c,
  [341, 3],
  321,
  c,
  [4, 3],
  325,
  c,
  [283, 14],
  326,
  c,
  [14, 13],
  327,
  c,
  [29, 14],
  328,
  c,
  [312, 27],
  331,
  c,
  [43, 14],
  332,
  c,
  [43, 27],
  c,
  [14, 14],
  338,
  147,
  c,
  [634, 4],
  341,
  c,
  [139, 3],
  342,
  42,
  43,
  345,
  346,
  c,
  [199, 27],
  347,
  c,
  [332, 21],
  351,
  c,
  [50, 27],
  287,
  286,
  283,
  282,
  276,
  275,
  357,
  354,
  361,
  359,
  353,
  364,
  363,
  358,
  360,
  362,
  145,
  184,
  45,
  365,
  182,
  43,
  355,
  366,
  368,
  c,
  [337, 28],
  361,
  359,
  369,
  c,
  [45, 5],
  370,
  c,
  [43, 4],
  372,
  c,
  [61, 4],
  373,
  c,
  [61, 12],
  374,
  375,
  c,
  [19, 4],
  376,
  c,
  [19, 12],
  377,
  378,
  s,
  [380, 7, 1],
  388,
  387,
  389,
  c,
  [89, 27],
  293,
  398,
  c,
  [757, 9],
  399,
  44,
  45,
  402,
  401,
  404,
  403,
  405,
  c,
  [309, 14],
  406,
  c,
  [309, 41],
  c,
  [14, 14],
  419,
  c,
  [117, 27],
  424,
  423,
  420,
  251,
  425,
  c,
  [32, 27],
  357,
  354,
  c,
  [378, 3],
  430,
  c,
  [324, 33],
  435,
  c,
  [34, 27],
  437,
  438,
  441,
  c,
  [30, 27],
  442,
  c,
  [671, 3],
  443,
  c,
  [32, 27],
  444,
  c,
  [28, 27],
  445,
  147,
  446,
  c,
  [290, 14],
  c,
  [248, 14],
  459,
  c,
  [529, 21],
  357,
  461,
  c,
  [82, 6],
  354,
  c,
  [83, 13],
  462,
  c,
  [83, 7],
  463,
  464,
  424,
  423,
  466,
  c,
  [243, 3],
  467,
  c,
  [4, 3],
  469,
  c,
  [4, 3],
  470,
  c,
  [4, 3],
  471,
  c,
  [4, 3],
  472,
  c,
  [91, 8],
  478,
  c,
  [92, 6],
  480,
  13,
  14,
  481,
  13,
  14,
  424,
  423,
  486,
  c,
  [159, 27],
  239,
  291,
  238,
  488,
  c,
  [379, 29],
  498,
  c,
  [190, 14],
  499,
  c,
  [45, 27],
  500,
  147,
  503,
  502,
  508,
  c,
  [136, 3],
  509,
  c,
  [36, 27],
  510,
  c,
  [28, 27],
  511,
  c,
  [28, 27],
  512,
  c,
  [1052, 41],
  424,
  423,
  528,
  c,
  [179, 14],
  529,
  c,
  [59, 27],
  530,
  c,
  [43, 14],
  531,
  c,
  [43, 27],
  534,
  c,
  [130, 41],
  c,
  [14, 14],
  542,
  c,
  [99, 14],
  545,
  c,
  [15, 14],
  547,
  c,
  [541, 28],
  c,
  [14, 22],
  553,
  c,
  [15, 6],
  555,
  c,
  [58, 28],
  563,
  c,
  [29, 28]
]),
  mode: u([
  s,
  [1, 26],
  2,
  2,
  c,
  [17, 17],
  s,
  [2, 8],
  c,
  [11, 11],
  s,
  [2, 18],
  c,
  [29, 19],
  1,
  c,
  [75, 3],
  c,
  [78, 13],
  c,
  [92, 8],
  c,
  [7, 8],
  c,
  [16, 7],
  c,
  [114, 16],
  c,
  [152, 24],
  c,
  [47, 6],
  c,
  [46, 8],
  c,
  [54, 20],
  c,
  [135, 10],
  c,
  [23, 14],
  c,
  [51, 16],
  c,
  [77, 9],
  s,
  [1, 55],
  c,
  [104, 9],
  c,
  [7, 6],
  c,
  [6, 13],
  c,
  [104, 14],
  c,
  [261, 10],
  c,
  [151, 18],
  c,
  [246, 41],
  c,
  [372, 29],
  c,
  [377, 21],
  c,
  [27, 50],
  c,
  [122, 18],
  c,
  [472, 27],
  s,
  [2, 31],
  c,
  [33, 33],
  c,
  [36, 21],
  c,
  [231, 30],
  c,
  [25, 62],
  c,
  [370, 44],
  c,
  [45, 4],
  c,
  [541, 60],
  c,
  [560, 26],
  c,
  [62, 59],
  c,
  [731, 12],
  c,
  [13, 17],
  c,
  [249, 16],
  s,
  [1, 96],
  c,
  [725, 5],
  c,
  [270, 62],
  c,
  [355, 5],
  c,
  [1023, 7],
  c,
  [179, 48],
  c,
  [417, 8],
  c,
  [135, 63],
  c,
  [483, 82],
  c,
  [408, 9],
  c,
  [44, 60],
  c,
  [467, 16],
  c,
  [79, 23],
  c,
  [251, 33],
  c,
  [707, 83],
  c,
  [224, 40],
  s,
  [1, 143]
]),
  goto: u([
  15,
  9,
  7,
  18,
  c,
  [4, 3],
  21,
  15,
  7,
  s,
  [23, 5, 1],
  32,
  34,
  38,
  39,
  46,
  47,
  49,
  15,
  7,
  50,
  51,
  195,
  195,
  39,
  34,
  39,
  38,
  57,
  58,
  59,
  38,
  39,
  65,
  66,
  38,
  70,
  71,
  38,
  s,
  [185, 10],
  72,
  s,
  [185, 18],
  s,
  [180, 10],
  73,
  s,
  [180, 18],
  74,
  197,
  77,
  78,
  203,
  77,
  86,
  85,
  77,
  84,
  88,
  38,
  39,
  38,
  39,
  91,
  92,
  189,
  189,
  59,
  93,
  94,
  38,
  15,
  112,
  216,
  105,
  107,
  110,
  111,
  114,
  113,
  s,
  [81, 3],
  115,
  116,
  c,
  [15, 3],
  220,
  c,
  [15, 4],
  s,
  [119, 5, 1],
  38,
  39,
  88,
  129,
  86,
  133,
  132,
  137,
  136,
  135,
  139,
  138,
  15,
  112,
  c,
  [23, 4],
  c,
  [6, 6],
  143,
  148,
  149,
  187,
  187,
  151,
  187,
  187,
  38,
  39,
  15,
  112,
  214,
  c,
  [17, 4],
  157,
  15,
  112,
  217,
  c,
  [8, 4],
  191,
  166,
  190,
  188,
  168,
  183,
  167,
  174,
  175,
  88,
  194,
  195,
  196,
  46,
  47,
  185,
  185,
  197,
  s,
  [185, 7],
  198,
  199,
  200,
  38,
  191,
  190,
  105,
  c,
  [23, 4],
  15,
  112,
  218,
  c,
  [43, 4],
  211,
  15,
  112,
  221,
  c,
  [8, 4],
  213,
  149,
  215,
  214,
  50,
  50,
  216,
  52,
  52,
  217,
  218,
  213,
  149,
  137,
  222,
  221,
  224,
  223,
  c,
  [106, 12],
  228,
  227,
  c,
  [120, 13],
  c,
  [158, 3],
  c,
  [14, 10],
  15,
  233,
  c,
  [6, 4],
  234,
  235,
  237,
  236,
  207,
  207,
  240,
  s,
  [207, 4],
  62,
  62,
  241,
  62,
  62,
  s,
  [185, 3],
  242,
  s,
  [180, 5],
  243,
  s,
  [180, 3],
  191,
  191,
  59,
  244,
  15,
  112,
  215,
  c,
  [40, 4],
  110,
  111,
  249,
  246,
  s,
  [106, 3],
  261,
  106,
  254,
  252,
  106,
  258,
  259,
  260,
  264,
  s,
  [106, 5],
  253,
  255,
  256,
  257,
  262,
  263,
  265,
  c,
  [183, 15],
  c,
  [15, 16],
  269,
  190,
  188,
  183,
  c,
  [11, 6],
  234,
  234,
  277,
  234,
  234,
  274,
  s,
  [234, 20],
  s,
  [235, 4],
  278,
  s,
  [235, 4],
  279,
  s,
  [235, 16],
  232,
  232,
  277,
  232,
  232,
  280,
  s,
  [232, 4],
  281,
  s,
  [232, 16],
  230,
  230,
  277,
  230,
  230,
  284,
  s,
  [230, 4],
  285,
  s,
  [230, 16],
  38,
  c,
  [133, 15],
  s,
  [229, 8],
  290,
  s,
  [229, 16],
  233,
  233,
  277,
  s,
  [233, 22],
  s,
  [181, 10],
  292,
  s,
  [181, 16],
  s,
  [175, 19],
  38,
  s,
  [175, 7],
  s,
  [176, 10],
  294,
  s,
  [176, 16],
  s,
  [241, 8],
  295,
  s,
  [241, 16],
  s,
  [240, 8],
  296,
  s,
  [240, 16],
  s,
  [242, 8],
  297,
  s,
  [242, 16],
  302,
  303,
  c,
  [358, 5],
  304,
  c,
  [226, 12],
  307,
  88,
  38,
  119,
  121,
  c,
  [247, 16],
  315,
  s,
  [80, 3],
  316,
  15,
  112,
  219,
  c,
  [554, 6],
  318,
  242,
  38,
  39,
  213,
  149,
  213,
  149,
  322,
  324,
  323,
  c,
  [521, 13],
  c,
  [6, 12],
  329,
  c,
  [6, 4],
  330,
  c,
  [19, 13],
  333,
  c,
  [6, 4],
  334,
  15,
  335,
  c,
  [7, 4],
  336,
  337,
  c,
  [650, 3],
  208,
  208,
  339,
  s,
  [208, 4],
  340,
  c,
  [78, 4],
  120,
  122,
  110,
  111,
  343,
  249,
  344,
  c,
  [500, 16],
  348,
  c,
  [500, 9],
  349,
  350,
  c,
  [28, 15],
  c,
  [438, 4],
  352,
  c,
  [435, 8],
  c,
  [478, 4],
  352,
  c,
  [475, 8],
  c,
  [543, 4],
  352,
  c,
  [529, 11],
  c,
  [525, 7],
  191,
  356,
  190,
  183,
  88,
  46,
  47,
  277,
  191,
  166,
  367,
  c,
  [101, 14],
  c,
  [24, 5],
  371,
  38,
  c,
  [32, 7],
  38,
  277,
  c,
  [9, 9],
  237,
  379,
  s,
  [38, 6],
  277,
  277,
  352,
  c,
  [125, 15],
  38,
  391,
  390,
  392,
  393,
  394,
  396,
  395,
  397,
  c,
  [846, 7],
  213,
  149,
  400,
  137,
  199,
  137,
  205,
  c,
  [240, 13],
  407,
  c,
  [6, 4],
  408,
  15,
  409,
  c,
  [7, 4],
  410,
  411,
  199,
  200,
  15,
  412,
  c,
  [10, 4],
  413,
  414,
  199,
  200,
  415,
  199,
  200,
  416,
  417,
  418,
  c,
  [83, 15],
  109,
  109,
  277,
  109,
  261,
  421,
  109,
  254,
  252,
  109,
  422,
  c,
  [793, 4],
  s,
  [109, 5],
  c,
  [793, 22],
  426,
  213,
  149,
  427,
  429,
  428,
  c,
  [21, 15],
  297,
  236,
  277,
  352,
  285,
  237,
  277,
  352,
  281,
  238,
  290,
  239,
  279,
  295,
  296,
  277,
  352,
  391,
  431,
  432,
  294,
  73,
  433,
  434,
  c,
  [39, 15],
  436,
  277,
  277,
  439,
  440,
  c,
  [20, 15],
  88,
  c,
  [495, 16],
  c,
  [237, 16],
  c,
  [209, 6],
  447,
  448,
  449,
  15,
  450,
  c,
  [9, 4],
  451,
  452,
  199,
  200,
  453,
  199,
  200,
  454,
  455,
  199,
  200,
  456,
  457,
  458,
  191,
  460,
  c,
  [420, 9],
  c,
  [56, 16],
  277,
  465,
  116,
  116,
  277,
  116,
  352,
  116,
  116,
  422,
  s,
  [116, 5],
  c,
  [564, 4],
  468,
  c,
  [5, 4],
  213,
  149,
  277,
  473,
  474,
  475,
  477,
  476,
  15,
  479,
  c,
  [297, 5],
  15,
  482,
  199,
  200,
  483,
  484,
  485,
  112,
  112,
  277,
  112,
  352,
  112,
  112,
  422,
  s,
  [112, 5],
  c,
  [75, 15],
  487,
  207,
  277,
  233,
  240,
  207,
  s,
  [233, 14],
  c,
  [35, 15],
  489,
  490,
  277,
  352,
  422,
  159,
  s,
  [491, 7, 1],
  c,
  [178, 6],
  c,
  [144, 16],
  199,
  501,
  200,
  201,
  s,
  [504, 4, 1],
  213,
  149,
  c,
  [1131, 31],
  c,
  [15, 29],
  15,
  513,
  c,
  [92, 4],
  s,
  [514, 6, 1],
  114,
  114,
  277,
  114,
  352,
  114,
  114,
  422,
  s,
  [114, 5],
  521,
  520,
  s,
  [522, 4, 1],
  199,
  526,
  527,
  200,
  c,
  [127, 21],
  c,
  [21, 21],
  532,
  533,
  c,
  [17, 15],
  535,
  536,
  15,
  537,
  c,
  [40, 4],
  538,
  15,
  539,
  c,
  [7, 4],
  540,
  541,
  c,
  [55, 6],
  199,
  543,
  544,
  c,
  [86, 7],
  199,
  200,
  546,
  c,
  [609, 7],
  548,
  c,
  [6, 4],
  549,
  550,
  15,
  551,
  c,
  [8, 4],
  552,
  c,
  [333, 6],
  199,
  554,
  c,
  [39, 8],
  556,
  557,
  200,
  558,
  15,
  559,
  c,
  [11, 4],
  560,
  561,
  199,
  562,
  c,
  [22, 7],
  564,
  15,
  565,
  c,
  [29, 5],
  566,
  200,
  567
])
}),
defaultActions: bda({
  idx: u([
  5,
  6,
  8,
  s,
  [10, 5, 1],
  18,
  19,
  21,
  22,
  23,
  29,
  30,
  31,
  s,
  [35, 5, 1],
  s,
  [42, 4, 1],
  49,
  50,
  51,
  53,
  61,
  63,
  66,
  67,
  71,
  74,
  76,
  80,
  s,
  [88, 4, 1],
  94,
  95,
  s,
  [98, 7, 1],
  s,
  [106, 4, 1],
  116,
  s,
  [119, 4, 1],
  125,
  143,
  146,
  150,
  151,
  152,
  154,
  158,
  160,
  161,
  162,
  164,
  165,
  169,
  176,
  177,
  178,
  180,
  189,
  s,
  [192, 5, 1],
  s,
  [202, 7, 1],
  214,
  218,
  234,
  235,
  236,
  238,
  246,
  248,
  s,
  [251, 15, 1],
  268,
  276,
  283,
  s,
  [287, 4, 2],
  300,
  301,
  304,
  306,
  307,
  309,
  311,
  312,
  319,
  320,
  321,
  330,
  s,
  [334, 4, 2],
  341,
  s,
  [343, 5, 1],
  355,
  357,
  366,
  367,
  372,
  374,
  375,
  377,
  378,
  s,
  [380, 6, 1],
  390,
  392,
  s,
  [398, 4, 2],
  408,
  410,
  413,
  416,
  417,
  418,
  424,
  428,
  431,
  435,
  436,
  s,
  [439, 5, 1],
  447,
  451,
  454,
  456,
  457,
  459,
  463,
  464,
  467,
  473,
  474,
  478,
  483,
  484,
  485,
  488,
  s,
  [489, 5, 2],
  502,
  503,
  506,
  s,
  [521, 5, 1],
  532,
  533,
  535,
  541,
  549,
  552,
  553,
  558,
  560,
  564,
  567
]),
  goto: u([
  8,
  23,
  21,
  25,
  26,
  27,
  66,
  67,
  4,
  9,
  6,
  24,
  7,
  11,
  12,
  13,
  19,
  193,
  194,
  185,
  180,
  181,
  182,
  176,
  177,
  2,
  3,
  5,
  196,
  17,
  190,
  71,
  76,
  75,
  1,
  198,
  204,
  170,
  15,
  14,
  16,
  70,
  77,
  63,
  65,
  s,
  [209, 5, 1],
  88,
  98,
  224,
  225,
  74,
  183,
  178,
  184,
  179,
  48,
  57,
  59,
  10,
  188,
  18,
  192,
  64,
  103,
  104,
  105,
  107,
  108,
  117,
  226,
  227,
  228,
  231,
  162,
  243,
  244,
  171,
  172,
  173,
  79,
  82,
  222,
  223,
  240,
  241,
  242,
  47,
  28,
  45,
  46,
  58,
  54,
  83,
  85,
  186,
  s,
  [247, 14, 1],
  115,
  131,
  133,
  135,
  161,
  129,
  174,
  123,
  124,
  168,
  101,
  163,
  165,
  245,
  246,
  49,
  51,
  53,
  41,
  43,
  44,
  60,
  56,
  61,
  69,
  84,
  86,
  87,
  111,
  158,
  127,
  130,
  99,
  140,
  141,
  132,
  147,
  134,
  145,
  138,
  139,
  142,
  143,
  144,
  169,
  164,
  78,
  73,
  200,
  206,
  39,
  40,
  42,
  37,
  55,
  68,
  137,
  126,
  100,
  160,
  118,
  122,
  125,
  102,
  166,
  167,
  72,
  38,
  33,
  35,
  36,
  113,
  146,
  136,
  128,
  120,
  121,
  95,
  31,
  32,
  34,
  110,
  s,
  [148, 4, 2],
  119,
  20,
  202,
  30,
  157,
  s,
  [149, 4, 2],
  22,
  29,
  89,
  156,
  90,
  96,
  97,
  92,
  91,
  93,
  94
])
}),
parseError: function parseError(str, hash, ExceptionClass) {
    if (hash.recoverable && typeof this.trace === 'function') {
        this.trace(str);
        hash.destroy(); // destroy... well, *almost*!
    } else {
        if (!ExceptionClass) {
            ExceptionClass = this.JisonParserError;
        }
        throw new ExceptionClass(str, hash);
    }
},
parse: function parse(input) {
    var self = this;
    var stack = new Array(128);         // token stack: stores token which leads to state at the same index (column storage)
    var sstack = new Array(128);        // state stack: stores states (column storage)

    var vstack = new Array(128);        // semantic value stack
    var lstack = new Array(128);        // location stack
    var table = this.table;
    var sp = 0;                         // 'stack pointer': index into the stacks
    var yyloc;

    var yylineno;


    var symbol = 0;



    var TERROR = this.TERROR;
    var EOF = this.EOF;
    var ERROR_RECOVERY_TOKEN_DISCARD_COUNT = (this.options.errorRecoveryTokenDiscardCount | 0) || 3;
    var NO_ACTION = [0, 568 /* === table.length :: ensures that anyone using this new state will fail dramatically! */];

    var lexer;
    if (this.__lexer__) {
        lexer = this.__lexer__;
    } else {
        lexer = this.__lexer__ = Object.create(this.lexer);
    }

    var sharedState_yy = {
        parseError: undefined,
        quoteName: undefined,
        lexer: undefined,
        parser: undefined,
        pre_parse: undefined,
        post_parse: undefined,
        pre_lex: undefined,
        post_lex: undefined      // WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!
    };

    var ASSERT;
    if (typeof assert !== 'function') {
        ASSERT = function JisonAssert(cond, msg) {
            if (!cond) {
                throw new Error('assertion failed: ' + (msg || '***'));
            }
        };
    } else {
        ASSERT = assert;
    }

    this.yyGetSharedState = function yyGetSharedState() {
        return sharedState_yy;
    };


    // shallow clone objects, straight copy of simple `src` values
    // e.g. `lexer.yytext` MAY be a complex value object,
    // rather than a simple string/value.
    function shallow_copy(src) {
        if (typeof src === 'object') {
            var dst = {};
            for (var k in src) {
                if (Object.prototype.hasOwnProperty.call(src, k)) {
                    dst[k] = src[k];
                }
            }
            return dst;
        }
        return src;
    }
    function shallow_copy_noclobber(dst, src) {
        for (var k in src) {
            if (typeof dst[k] === 'undefined' && Object.prototype.hasOwnProperty.call(src, k)) {
                dst[k] = src[k];
            }
        }
    }
    function copy_yylloc(loc) {
        var rv = shallow_copy(loc);
        if (rv && rv.range) {
            rv.range = rv.range.slice(0);
        }
        return rv;
    }

    // copy state
    shallow_copy_noclobber(sharedState_yy, this.yy);

    sharedState_yy.lexer = lexer;
    sharedState_yy.parser = this;






    // Does the shared state override the default `parseError` that already comes with this instance?
    if (typeof sharedState_yy.parseError === 'function') {
        this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {
            if (!ExceptionClass) {
                ExceptionClass = this.JisonParserError;
            }
            return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);
        };
    } else {
        this.parseError = this.originalParseError;
    }

    // Does the shared state override the default `quoteName` that already comes with this instance?
    if (typeof sharedState_yy.quoteName === 'function') {
        this.quoteName = function quoteNameAlt(id_str) {
            return sharedState_yy.quoteName.call(this, id_str);
        };
    } else {
        this.quoteName = this.originalQuoteName;
    }

    // set up the cleanup function; make it an API so that external code can re-use this one in case of
    // calamities or when the `%options no-try-catch` option has been specified for the grammar, in which
    // case this parse() API method doesn't come with a `finally { ... }` block any more!
    //
    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
    //       or else your `sharedState`, etc. references will be *wrong*!
    this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {
        var rv;

        if (invoke_post_methods) {
            var hash;

            if (sharedState_yy.post_parse || this.post_parse) {
                // create an error hash info instance: we re-use this API in a **non-error situation**
                // as this one delivers all parser internals ready for access by userland code.
                hash = this.constructParseErrorInfo(null /* no error! */, null /* no exception! */, null, false);
            }

            if (sharedState_yy.post_parse) {
                rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);
                if (typeof rv !== 'undefined') resultValue = rv;
            }
            if (this.post_parse) {
                rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);
                if (typeof rv !== 'undefined') resultValue = rv;
            }

            // cleanup:
            if (hash && hash.destroy) {
                hash.destroy();
            }
        }

        if (this.__reentrant_call_depth > 1) return resultValue;        // do not (yet) kill the sharedState when this is a reentrant run.

        // clean up the lingering lexer structures as well:
        if (lexer.cleanupAfterLex) {
            lexer.cleanupAfterLex(do_not_nuke_errorinfos);
        }

        // prevent lingering circular references from causing memory leaks:
        if (sharedState_yy) {
            sharedState_yy.lexer = undefined;
            sharedState_yy.parser = undefined;
            if (lexer.yy === sharedState_yy) {
                lexer.yy = undefined;
            }
        }
        sharedState_yy = undefined;
        this.parseError = this.originalParseError;
        this.quoteName = this.originalQuoteName;

        // nuke the vstack[] array at least as that one will still reference obsoleted user values.
        // To be safe, we nuke the other internal stack columns as well...
        stack.length = 0;               // fastest way to nuke an array without overly bothering the GC
        sstack.length = 0;
        lstack.length = 0;
        vstack.length = 0;
        sp = 0;

        // nuke the error hash info instances created during this run.
        // Userland code must COPY any data/references
        // in the error hash instance(s) it is more permanently interested in.
        if (!do_not_nuke_errorinfos) {
            for (var i = this.__error_infos.length - 1; i >= 0; i--) {
                var el = this.__error_infos[i];
                if (el && typeof el.destroy === 'function') {
                    el.destroy();
                }
            }
            this.__error_infos.length = 0;


        }

        return resultValue;
    };

    // merge yylloc info into a new yylloc instance.
    //
    // `first_index` and `last_index` MAY be UNDEFINED/NULL or these are indexes into the `lstack[]` location stack array.
    //
    // `first_yylloc` and `last_yylloc` MAY be UNDEFINED/NULL or explicit (custom or regular) `yylloc` instances, in which
    // case these override the corresponding first/last indexes.
    //
    // `dont_look_back` is an optional flag (default: FALSE), which instructs this merge operation NOT to search
    // through the parse location stack for a location, which would otherwise be used to construct the new (epsilon!)
    // yylloc info.
    //
    // Note: epsilon rule's yylloc situation is detected by passing both `first_index` and `first_yylloc` as UNDEFINED/NULL.
    this.yyMergeLocationInfo = function parser_yyMergeLocationInfo(first_index, last_index, first_yylloc, last_yylloc, dont_look_back) {
        var i1 = first_index | 0,
            i2 = last_index | 0;
        var l1 = first_yylloc,
            l2 = last_yylloc;
        var rv;

        // rules:
        // - first/last yylloc entries override first/last indexes

        if (!l1) {
            if (first_index != null) {
                for (var i = i1; i <= i2; i++) {
                    l1 = lstack[i];
                    if (l1) {
                        break;
                    }
                }
            }
        }

        if (!l2) {
            if (last_index != null) {
                for (var i = i2; i >= i1; i--) {
                    l2 = lstack[i];
                    if (l2) {
                        break;
                    }
                }
            }
        }

        // - detect if an epsilon rule is being processed and act accordingly:
        if (!l1 && first_index == null) {
            // epsilon rule span merger. With optional look-ahead in l2.
            if (!dont_look_back) {
                for (var i = (i1 || sp) - 1; i >= 0; i--) {
                    l1 = lstack[i];
                    if (l1) {
                        break;
                    }
                }
            }
            if (!l1) {
                if (!l2) {
                    // when we still don't have any valid yylloc info, we're looking at an epsilon rule
                    // without look-ahead and no preceding terms and/or `dont_look_back` set:
                    // in that case we ca do nothing but return NULL/UNDEFINED:
                    return undefined;
                } else {
                    // shallow-copy L2: after all, we MAY be looking
                    // at unconventional yylloc info objects...
                    rv = shallow_copy(l2);
                    if (rv.range) {
                        // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:
                        rv.range = rv.range.slice(0);
                    }
                    return rv;
                }
            } else {
                // shallow-copy L1, then adjust first col/row 1 column past the end.
                rv = shallow_copy(l1);
                rv.first_line = rv.last_line;
                rv.first_column = rv.last_column;
                if (rv.range) {
                    // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:
                    rv.range = rv.range.slice(0);
                    rv.range[0] = rv.range[1];
                }

                if (l2) {
                    // shallow-mixin L2, then adjust last col/row accordingly.
                    shallow_copy_noclobber(rv, l2);
                    rv.last_line = l2.last_line;
                    rv.last_column = l2.last_column;
                    if (rv.range && l2.range) {
                        rv.range[1] = l2.range[1];
                    }
                }
                return rv;
            }
        }

        if (!l1) {
            l1 = l2;
            l2 = null;
        }
        if (!l1) {
            return undefined;
        }

        // shallow-copy L1|L2, before we try to adjust the yylloc values: after all, we MAY be looking
        // at unconventional yylloc info objects...
        rv = shallow_copy(l1);

        // first_line: ...,
        // first_column: ...,
        // last_line: ...,
        // last_column: ...,
        if (rv.range) {
            // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:
            rv.range = rv.range.slice(0);
        }

        if (l2) {
            shallow_copy_noclobber(rv, l2);
            rv.last_line = l2.last_line;
            rv.last_column = l2.last_column;
            if (rv.range && l2.range) {
                rv.range[1] = l2.range[1];
            }
        }

        return rv;
    };

    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
    //       or else your `lexer`, `sharedState`, etc. references will be *wrong*!
    this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected, recoverable) {
        var pei = {
            errStr: msg,
            exception: ex,
            text: lexer.match,
            value: lexer.yytext,
            token: this.describeSymbol(symbol) || symbol,
            token_id: symbol,
            line: lexer.yylineno,
            loc: copy_yylloc(lexer.yylloc),
            expected: expected,
            recoverable: recoverable,
            state: state,
            action: action,
            new_state: newState,
            symbol_stack: stack,
            state_stack: sstack,
            value_stack: vstack,
            location_stack: lstack,
            stack_pointer: sp,
            yy: sharedState_yy,
            lexer: lexer,
            parser: this,

            // and make sure the error info doesn't stay due to potential
            // ref cycle via userland code manipulations.
            // These would otherwise all be memory leak opportunities!
            //
            // Note that only array and object references are nuked as those
            // constitute the set of elements which can produce a cyclic ref.
            // The rest of the members is kept intact as they are harmless.
            destroy: function destructParseErrorInfo() {
                // remove cyclic references added to error info:
                // info.yy = null;
                // info.lexer = null;
                // info.value = null;
                // info.value_stack = null;
                // ...
                var rec = !!this.recoverable;
                for (var key in this) {
                    if (this.hasOwnProperty(key) && typeof key === 'object') {
                        this[key] = undefined;
                    }
                }
                this.recoverable = rec;
            }
        };
        // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
        this.__error_infos.push(pei);
        return pei;
    };













    function getNonTerminalFromCode(symbol) {
        var tokenName = self.getSymbolName(symbol);
        if (!tokenName) {
            tokenName = symbol;
        }
        return tokenName;
    }


    function lex() {
        var token = lexer.lex();
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }

        return token || EOF;
    }


    var state, action, r, t;
    var yyval = {
        $: true,
        _$: undefined,
        yy: sharedState_yy
    };
    var p;
    var yyrulelen;
    var this_production;
    var newState;
    var retval = false;


    try {
        this.__reentrant_call_depth++;

        lexer.setInput(input, sharedState_yy);

        yyloc = lexer.yylloc;
        lstack[sp] = yyloc;
        vstack[sp] = null;
        sstack[sp] = 0;
        stack[sp] = 0;
        ++sp;





        if (this.pre_parse) {
            this.pre_parse.call(this, sharedState_yy);
        }
        if (sharedState_yy.pre_parse) {
            sharedState_yy.pre_parse.call(this, sharedState_yy);
        }

        newState = sstack[sp - 1];
        for (;;) {
            // retrieve state number from top of stack
            state = newState;               // sstack[sp - 1];

            // use default actions if available
            if (this.defaultActions[state]) {
                action = 2;
                newState = this.defaultActions[state];
            } else {
                // The single `==` condition below covers both these `===` comparisons in a single
                // operation:
                //
                //     if (symbol === null || typeof symbol === 'undefined') ...
                if (!symbol) {
                    symbol = lex();
                }
                // read action for current state and first input
                t = (table[state] && table[state][symbol]) || NO_ACTION;
                newState = t[1];
                action = t[0];











                // handle parse error
                if (!action) {
                    var errStr;
                    var errSymbolDescr = (this.describeSymbol(symbol) || symbol);
                    var expected = this.collect_expected_token_set(state);

                    // Report error
                    if (typeof lexer.yylineno === 'number') {
                        errStr = 'Parse error on line ' + (lexer.yylineno + 1) + ': ';
                    } else {
                        errStr = 'Parse error: ';
                    }
                    if (typeof lexer.showPosition === 'function') {
                        errStr += '\n' + lexer.showPosition(79 - 10, 10) + '\n';
                    }
                    if (expected.length) {
                        errStr += 'Expecting ' + expected.join(', ') + ', got unexpected ' + errSymbolDescr;
                    } else {
                        errStr += 'Unexpected ' + errSymbolDescr;
                    }
                    // we cannot recover from the error!
                    p = this.constructParseErrorInfo(errStr, null, expected, false);
                    retval = this.parseError(p.errStr, p, this.JisonParserError);
                    break;
                }


            }










            switch (action) {
            // catch misc. parse failures:
            default:
                // this shouldn't happen, unless resolve defaults are off
                if (action instanceof Array) {
                    p = this.constructParseErrorInfo('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol, null, null, false);
                    retval = this.parseError(p.errStr, p, this.JisonParserError);
                    break;
                }
                // Another case of better safe than sorry: in case state transitions come out of another error recovery process
                // or a buggy LUT (LookUp Table):
                p = this.constructParseErrorInfo('Parsing halted. No viable error recovery approach available due to internal system failure.', null, null, false);
                retval = this.parseError(p.errStr, p, this.JisonParserError);
                break;

            // shift:
            case 1:
                stack[sp] = symbol;
                vstack[sp] = lexer.yytext;
                lstack[sp] = copy_yylloc(lexer.yylloc);
                sstack[sp] = newState; // push state

                ++sp;
                symbol = 0;


                    // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:



                    yyloc = lexer.yylloc;






                




                continue;

            // reduce:
            case 2:
                this_production = this.productions_[newState - 1];  // `this.productions_[]` is zero-based indexed while states start from 1 upwards...
                yyrulelen = this_production[1];










                r = this.performAction.call(yyval, yyloc, newState, sp - 1, vstack, lstack);

                if (typeof r !== 'undefined') {
                    retval = r;
                    break;
                }

                // pop off stack
                sp -= yyrulelen;

                // don't overwrite the `symbol` variable: use a local var to speed things up:
                var ntsymbol = this_production[0];    // push nonterminal (reduce)
                stack[sp] = ntsymbol;
                vstack[sp] = yyval.$;
                lstack[sp] = yyval._$;
                // goto new state = table[STATE][NONTERMINAL]
                newState = table[sstack[sp - 1]][ntsymbol];
                sstack[sp] = newState;
                ++sp;









                continue;

            // accept:
            case 3:
                retval = true;
                // Return the `$accept` rule's `$$` result, if available.
                //
                // Also note that JISON always adds this top-most `$accept` rule (with implicit,
                // default, action):
                //
                //     $accept: <startSymbol> $end
                //                  %{ $$ = $1; @$ = @1; %}
                //
                // which, combined with the parse kernel's `$accept` state behaviour coded below,
                // will produce the `$$` value output of the <startSymbol> rule as the parse result,
                // IFF that result is *not* `undefined`. (See also the parser kernel code.)
                //
                // In code:
                //
                //                  %{
                //                      @$ = @1;            // if location tracking support is included
                //                      if (typeof $1 !== 'undefined')
                //                          return $1;
                //                      else
                //                          return true;           // the default parse result if the rule actions don't produce anything
                //                  %}
                sp--;
                if (typeof vstack[sp] !== 'undefined') {
                    retval = vstack[sp];
                }

                break;
            }

            // break out of loop: we accept or fail with error
            break;
        }
    } catch (ex) {
        // report exceptions through the parseError callback too, but keep the exception intact
        // if it is a known parser or lexer error which has been thrown by parseError() already:
        if (ex instanceof this.JisonParserError) {
            throw ex;
        }
        else if (lexer && typeof lexer.JisonLexerError === 'function' && ex instanceof lexer.JisonLexerError) {
            throw ex;
        }
        else {
            p = this.constructParseErrorInfo('Parsing aborted due to exception.', ex, null, false);
            retval = this.parseError(p.errStr, p, this.JisonParserError);
        }
    } finally {
        retval = this.cleanupAfterParse(retval, true, true);
        this.__reentrant_call_depth--;
    }   // /finally

    return retval;
}
};
parser.originalParseError = parser.parseError;
parser.originalQuoteName = parser.quoteName;


/* lexer generated by jison-lex 0.6.1-203 */

/*
 * Returns a Lexer object of the following structure:
 *
 *  Lexer: {
 *    yy: {}     The so-called "shared state" or rather the *source* of it;
 *               the real "shared state" `yy` passed around to
 *               the rule actions, etc. is a direct reference!
 *
 *               This "shared context" object was passed to the lexer by way of 
 *               the `lexer.setInput(str, yy)` API before you may use it.
 *
 *               This "shared context" object is passed to the lexer action code in `performAction()`
 *               so userland code in the lexer actions may communicate with the outside world 
 *               and/or other lexer rules' actions in more or less complex ways.
 *
 *  }
 *
 *  Lexer.prototype: {
 *    EOF: 1,
 *    ERROR: 2,
 *
 *    yy:        The overall "shared context" object reference.
 *
 *    JisonLexerError: function(msg, hash),
 *
 *    performAction: function lexer__performAction(yy, yyrulenumber, YY_START),
 *
 *               The function parameters and `this` have the following value/meaning:
 *               - `this`    : reference to the `lexer` instance. 
 *                               `yy_` is an alias for `this` lexer instance reference used internally.
 *
 *               - `yy`      : a reference to the `yy` "shared state" object which was passed to the lexer
 *                             by way of the `lexer.setInput(str, yy)` API before.
 *
 *                             Note:
 *                             The extra arguments you specified in the `%parse-param` statement in your
 *                             **parser** grammar definition file are passed to the lexer via this object
 *                             reference as member variables.
 *
 *               - `yyrulenumber`   : index of the matched lexer rule (regex), used internally.
 *
 *               - `YY_START`: the current lexer "start condition" state.
 *
 *    parseError: function(str, hash, ExceptionClass),
 *
 *    constructLexErrorInfo: function(error_message, is_recoverable),
 *               Helper function.
 *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
 *               See it's use in this lexer kernel in many places; example usage:
 *
 *                   var infoObj = lexer.constructParseErrorInfo('fail!', true);
 *                   var retVal = lexer.parseError(infoObj.errStr, infoObj, lexer.JisonLexerError);
 *
 *    options: { ... lexer %options ... },
 *
 *    lex: function(),
 *               Produce one token of lexed input, which was passed in earlier via the `lexer.setInput()` API.
 *               You MAY use the additional `args...` parameters as per `%parse-param` spec of the **lexer** grammar:
 *               these extra `args...` are added verbatim to the `yy` object reference as member variables.
 *
 *               WARNING:
 *               Lexer's additional `args...` parameters (via lexer's `%parse-param`) MAY conflict with
 *               any attributes already added to `yy` by the **parser** or the jison run-time; 
 *               when such a collision is detected an exception is thrown to prevent the generated run-time 
 *               from silently accepting this confusing and potentially hazardous situation! 
 *
 *    cleanupAfterLex: function(do_not_nuke_errorinfos),
 *               Helper function.
 *
 *               This helper API is invoked when the **parse process** has completed: it is the responsibility
 *               of the **parser** (or the calling userland code) to invoke this method once cleanup is desired. 
 *
 *               This helper may be invoked by user code to ensure the internal lexer gets properly garbage collected.
 *
 *    setInput: function(input, [yy]),
 *
 *
 *    input: function(),
 *
 *
 *    unput: function(str),
 *
 *
 *    more: function(),
 *
 *
 *    reject: function(),
 *
 *
 *    less: function(n),
 *
 *
 *    pastInput: function(n),
 *
 *
 *    upcomingInput: function(n),
 *
 *
 *    showPosition: function(),
 *
 *
 *    test_match: function(regex_match_array, rule_index),
 *
 *
 *    next: function(),
 *
 *
 *    begin: function(condition),
 *
 *
 *    pushState: function(condition),
 *
 *
 *    popState: function(),
 *
 *
 *    topState: function(),
 *
 *
 *    _currentRules: function(),
 *
 *
 *    stateStackSize: function(),
 *
 *
 *    performAction: function(yy, yy_, yyrulenumber, YY_START),
 *
 *
 *    rules: [...],
 *
 *
 *    conditions: {associative list: name ==> set},
 *  }
 *
 *
 *  token location info (`yylloc`): {
 *    first_line: n,
 *    last_line: n,
 *    first_column: n,
 *    last_column: n,
 *    range: [start_number, end_number]
 *               (where the numbers are indexes into the input string, zero-based)
 *  }
 *
 * ---
 *
 * The `parseError` function receives a 'hash' object with these members for lexer errors:
 *
 *  {
 *    text:        (matched text)
 *    token:       (the produced terminal token, if any)
 *    token_id:    (the produced terminal token numeric ID, if any)
 *    line:        (yylineno)
 *    loc:         (yylloc)
 *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
 *                  available for this particular error)
 *    yy:          (object: the current parser internal "shared state" `yy`
 *                  as is also available in the rule actions; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    lexer:       (reference to the current lexer instance used by the parser)
 *  }
 *
 * while `this` will reference the current lexer instance.
 *
 * When `parseError` is invoked by the lexer, the default implementation will
 * attempt to invoke `yy.parser.parseError()`; when this callback is not provided
 * it will try to invoke `yy.parseError()` instead. When that callback is also not
 * provided, a `JisonLexerError` exception will be thrown containing the error
 * message and `hash`, as constructed by the `constructLexErrorInfo()` API.
 *
 * Note that the lexer's `JisonLexerError` error class is passed via the
 * `ExceptionClass` argument, which is invoked to construct the exception
 * instance to be thrown, so technically `parseError` will throw the object
 * produced by the `new ExceptionClass(str, hash)` JavaScript expression.
 *
 * ---
 *
 * You can specify lexer options by setting / modifying the `.options` object of your Lexer instance.
 * These options are available:
 *
 * (Options are permanent.)
 *  
 *  yy: {
 *      parseError: function(str, hash, ExceptionClass)
 *                 optional: overrides the default `parseError` function.
 *  }
 *
 *  lexer.options: {
 *      pre_lex:  function()
 *                 optional: is invoked before the lexer is invoked to produce another token.
 *                 `this` refers to the Lexer object.
 *      post_lex: function(token) { return token; }
 *                 optional: is invoked when the lexer has produced a token `token`;
 *                 this function can override the returned token value by returning another.
 *                 When it does not return any (truthy) value, the lexer will return
 *                 the original `token`.
 *                 `this` refers to the Lexer object.
 *
 * WARNING: the next set of options are not meant to be changed. They echo the abilities of
 * the lexer as per when it was compiled!
 *
 *      ranges: boolean
 *                 optional: `true` ==> token location info will include a .range[] member.
 *      flex: boolean
 *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
 *                 exhaustively to find the longest match.
 *      backtrack_lexer: boolean
 *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
 *                 the lexer terminates the scan when a token is returned by the action code.
 *      xregexp: boolean
 *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
 *                 `XRegExp` library. When this %option has not been specified at compile time, all lexer
 *                 rule regexes have been written as standard JavaScript RegExp expressions.
 *  }
 */


var lexer = function() {
  /**
   * See also:
   * http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
   * but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
   * with userland code which might access the derived class in a 'classic' way.
   *
   * @public
   * @constructor
   * @nocollapse
   */
  function JisonLexerError(msg, hash) {
    Object.defineProperty(this, 'name', {
      enumerable: false,
      writable: false,
      value: 'JisonLexerError'
    });

    if (msg == null)
      msg = '???';

    Object.defineProperty(this, 'message', {
      enumerable: false,
      writable: true,
      value: msg
    });

    this.hash = hash;
    var stacktrace;

    if (hash && hash.exception instanceof Error) {
      var ex2 = hash.exception;
      this.message = ex2.message || msg;
      stacktrace = ex2.stack;
    }

    if (!stacktrace) {
      if (Error.hasOwnProperty('captureStackTrace')) {
        // V8
        Error.captureStackTrace(this, this.constructor);
      } else {
        stacktrace = new Error(msg).stack;
      }
    }

    if (stacktrace) {
      Object.defineProperty(this, 'stack', {
        enumerable: false,
        writable: false,
        value: stacktrace
      });
    }
  }

  if (typeof Object.setPrototypeOf === 'function') {
    Object.setPrototypeOf(JisonLexerError.prototype, Error.prototype);
  } else {
    JisonLexerError.prototype = Object.create(Error.prototype);
  }

  JisonLexerError.prototype.constructor = JisonLexerError;
  JisonLexerError.prototype.name = 'JisonLexerError';

  var lexer = {
    
// Code Generator Information Report
// ---------------------------------
//
// Options:
//
//   backtracking: .................... false
//   location.ranges: ................. false
//   location line+column tracking: ... true
//
//
// Forwarded Parser Analysis flags:
//
//   uses yyleng: ..................... false
//   uses yylineno: ................... false
//   uses yytext: ..................... false
//   uses yylloc: ..................... false
//   uses lexer values: ............... true / true
//   location tracking: ............... true
//   location assignment: ............. true
//
//
// Lexer Analysis flags:
//
//   uses yyleng: ..................... ???
//   uses yylineno: ................... ???
//   uses yytext: ..................... ???
//   uses yylloc: ..................... ???
//   uses ParseError API: ............. ???
//   uses yyerror: .................... ???
//   uses location tracking & editing:  ???
//   uses more() API: ................. ???
//   uses unput() API: ................ ???
//   uses reject() API: ............... ???
//   uses less() API: ................. ???
//   uses display APIs pastInput(), upcomingInput(), showPosition():
//        ............................. ???
//   uses describeYYLLOC() API: ....... ???
//
// --------- END OF REPORT -----------

EOF: 1,
    ERROR: 2,

    // JisonLexerError: JisonLexerError,        /// <-- injected by the code generator

    // options: {},                             /// <-- injected by the code generator

    // yy: ...,                                 /// <-- injected by setInput()

    __currentRuleSet__: null,                   /// INTERNAL USE ONLY: internal rule set cache for the current lexer state  

    __error_infos: [],                          /// INTERNAL USE ONLY: the set of lexErrorInfo objects created since the last cleanup  
    __decompressed: false,                      /// INTERNAL USE ONLY: mark whether the lexer instance has been 'unfolded' completely and is now ready for use  
    done: false,                                /// INTERNAL USE ONLY  
    _backtrack: false,                          /// INTERNAL USE ONLY  
    _input: '',                                 /// INTERNAL USE ONLY  
    _more: false,                               /// INTERNAL USE ONLY  
    _signaled_error_token: false,               /// INTERNAL USE ONLY  
    conditionStack: [],                         /// INTERNAL USE ONLY; managed via `pushState()`, `popState()`, `topState()` and `stateStackSize()`  
    match: '',                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction. `match` is identical to `yytext` except that this one still contains the matched input string after `lexer.performAction()` has been invoked, where userland code MAY have changed/replaced the `yytext` value entirely!  
    matched: '',                                /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks entire input which has been matched so far  
    matches: false,                             /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks RE match result for last (successful) match attempt  
    yytext: '',                                 /// ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction; this value is transferred to the parser as the 'token value' when the parser consumes the lexer token produced through a call to the `lex()` API.  
    offset: 0,                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks the 'cursor position' in the input string, i.e. the number of characters matched so far  
    yyleng: 0,                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: length of matched input for the token under construction (`yytext`)  
    yylineno: 0,                                /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: 'line number' at which the token under construction is located  
    yylloc: null,                               /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks location info (lines + columns) for the token under construction  

    /**
     * INTERNAL USE: construct a suitable error info hash object instance for `parseError`.
     * 
     * @public
     * @this {RegExpLexer}
     */
    constructLexErrorInfo: function lexer_constructLexErrorInfo(msg, recoverable) {
      /** @constructor */
      var pei = {
        errStr: msg,
        recoverable: !!recoverable,
        text: this.match,           // This one MAY be empty; userland code should use the `upcomingInput` API to obtain more text which follows the 'lexer cursor position'...  
        token: null,
        line: this.yylineno,
        loc: this.yylloc,
        yy: this.yy,
        lexer: this,

        /**
         * and make sure the error info doesn't stay due to potential
         * ref cycle via userland code manipulations.
         * These would otherwise all be memory leak opportunities!
         * 
         * Note that only array and object references are nuked as those
         * constitute the set of elements which can produce a cyclic ref.
         * The rest of the members is kept intact as they are harmless.
         * 
         * @public
         * @this {LexErrorInfo}
         */
        destroy: function destructLexErrorInfo() {
          // remove cyclic references added to error info:
          // info.yy = null;
          // info.lexer = null;
          // ...
          var rec = !!this.recoverable;

          for (var key in this) {
            if (this.hasOwnProperty(key) && typeof key === 'object') {
              this[key] = undefined;
            }
          }

          this.recoverable = rec;
        }
      };

      // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
      this.__error_infos.push(pei);

      return pei;
    },

    /**
     * handler which is invoked when a lexer error occurs.
     * 
     * @public
     * @this {RegExpLexer}
     */
    parseError: function lexer_parseError(str, hash, ExceptionClass) {
      if (!ExceptionClass) {
        ExceptionClass = this.JisonLexerError;
      }

      if (this.yy) {
        if (this.yy.parser && typeof this.yy.parser.parseError === 'function') {
          return this.yy.parser.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;
        } else if (typeof this.yy.parseError === 'function') {
          return this.yy.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;
        }
      }

      throw new ExceptionClass(str, hash);
    },

    /**
     * method which implements `yyerror(str, ...args)` functionality for use inside lexer actions.
     * 
     * @public
     * @this {RegExpLexer}
     */
    yyerror: function yyError(str /*, ...args */) {
      var lineno_msg = '';

      if (this.options.trackPosition) {
        lineno_msg = ' on line ' + (this.yylineno + 1);
      }

      var p = this.constructLexErrorInfo(
        'Lexical error' + lineno_msg + ': ' + str,
        this.options.lexerErrorsAreRecoverable
      );

      // Add any extra args to the hash under the name `extra_error_attributes`:
      var args = Array.prototype.slice.call(arguments, 1);

      if (args.length) {
        p.extra_error_attributes = args;
      }

      return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
    },

    /**
     * final cleanup function for when we have completed lexing the input;
     * make it an API so that external code can use this one once userland
     * code has decided it's time to destroy any lingering lexer error
     * hash object instances and the like: this function helps to clean
     * up these constructs, which *may* carry cyclic references which would
     * otherwise prevent the instances from being properly and timely
     * garbage-collected, i.e. this function helps prevent memory leaks!
     * 
     * @public
     * @this {RegExpLexer}
     */
    cleanupAfterLex: function lexer_cleanupAfterLex(do_not_nuke_errorinfos) {
      // prevent lingering circular references from causing memory leaks:
      this.setInput('', {});

      // nuke the error hash info instances created during this run.
      // Userland code must COPY any data/references
      // in the error hash instance(s) it is more permanently interested in.
      if (!do_not_nuke_errorinfos) {
        for (var i = this.__error_infos.length - 1; i >= 0; i--) {
          var el = this.__error_infos[i];

          if (el && typeof el.destroy === 'function') {
            el.destroy();
          }
        }

        this.__error_infos.length = 0;
      }

      return this;
    },

    /**
     * clear the lexer token context; intended for internal use only
     * 
     * @public
     * @this {RegExpLexer}
     */
    clear: function lexer_clear() {
      this.yytext = '';
      this.yyleng = 0;
      this.match = '';

      // - DO NOT reset `this.matched`
      this.matches = false;

      this._more = false;
      this._backtrack = false;
      var col = (this.yylloc ? this.yylloc.last_column : 0);

      this.yylloc = {
        first_line: this.yylineno + 1,
        first_column: col,
        last_line: this.yylineno + 1,
        last_column: col,
        range: [this.offset, this.offset]
      };
    },

    /**
     * resets the lexer, sets new input
     * 
     * @public
     * @this {RegExpLexer}
     */
    setInput: function lexer_setInput(input, yy) {
      this.yy = yy || this.yy || {};

      // also check if we've fully initialized the lexer instance,
      // including expansion work to be done to go from a loaded
      // lexer to a usable lexer:
      if (!this.__decompressed) {
        // step 1: decompress the regex list:
        var rules = this.rules;

        for (var i = 0, len = rules.length; i < len; i++) {
          var rule_re = rules[i];

          // compression: is the RE an xref to another RE slot in the rules[] table?
          if (typeof rule_re === 'number') {
            rules[i] = rules[rule_re];
          }
        }

        // step 2: unfold the conditions[] set to make these ready for use:
        var conditions = this.conditions;

        for (var k in conditions) {
          var spec = conditions[k];
          var rule_ids = spec.rules;
          var len = rule_ids.length;
          var rule_regexes = new Array(len + 1);             // slot 0 is unused; we use a 1-based index approach here to keep the hottest code in `lexer_next()` fast and simple! 
          var rule_new_ids = new Array(len + 1);

          for (var i = 0; i < len; i++) {
            var idx = rule_ids[i];
            var rule_re = rules[idx];
            rule_regexes[i + 1] = rule_re;
            rule_new_ids[i + 1] = idx;
          }

          spec.rules = rule_new_ids;
          spec.__rule_regexes = rule_regexes;
          spec.__rule_count = len;
        }

        this.__decompressed = true;
      }

      this._input = input || '';
      this.clear();
      this._signaled_error_token = false;
      this.done = false;
      this.yylineno = 0;
      this.matched = '';
      this.conditionStack = ['INITIAL'];
      this.__currentRuleSet__ = null;

      this.yylloc = {
        first_line: 1,
        first_column: 0,
        last_line: 1,
        last_column: 0,
        range: [0, 0]
      };

      this.offset = 0;
      return this;
    },

    /**
     * edit the remaining input via user-specified callback.
     * This can be used to forward-adjust the input-to-parse, 
     * e.g. inserting macro expansions and alike in the
     * input which has yet to be lexed.
     * The behaviour of this API contrasts the `unput()` et al
     * APIs as those act on the *consumed* input, while this
     * one allows one to manipulate the future, without impacting
     * the current `yyloc` cursor location or any history. 
     * 
     * Use this API to help implement C-preprocessor-like
     * `#include` statements, etc.
     * 
     * The provided callback must be synchronous and is
     * expected to return the edited input (string).
     *
     * The `cpsArg` argument value is passed to the callback
     * as-is.
     *
     * `callback` interface: 
     * `function callback(input, cpsArg)`
     * 
     * - `input` will carry the remaining-input-to-lex string
     *   from the lexer.
     * - `cpsArg` is `cpsArg` passed into this API.
     * 
     * The `this` reference for the callback will be set to
     * reference this lexer instance so that userland code
     * in the callback can easily and quickly access any lexer
     * API. 
     *
     * When the callback returns a non-string-type falsey value,
     * we assume the callback did not edit the input and we
     * will using the input as-is.
     *
     * When the callback returns a non-string-type value, it
     * is converted to a string for lexing via the `"" + retval`
     * operation. (See also why: http://2ality.com/2012/03/converting-to-string.html 
     * -- that way any returned object's `toValue()` and `toString()`
     * methods will be invoked in a proper/desirable order.)
     * 
     * @public
     * @this {RegExpLexer}
     */
    editRemainingInput: function lexer_editRemainingInput(callback, cpsArg) {
      var rv = callback.call(this, this._input, cpsArg);

      if (typeof rv !== 'string') {
        if (rv) {
          this._input = '' + rv;
        } 
        // else: keep `this._input` as is.  
      } else {
        this._input = rv;
      }

      return this;
    },

    /**
     * consumes and returns one char from the input
     * 
     * @public
     * @this {RegExpLexer}
     */
    input: function lexer_input() {
      if (!this._input) {
        //this.done = true;    -- don't set `done` as we want the lex()/next() API to be able to produce one custom EOF token match after this anyhow. (lexer can match special <<EOF>> tokens and perform user action code for a <<EOF>> match, but only does so *once*)
        return null;
      }

      var ch = this._input[0];
      this.yytext += ch;
      this.yyleng++;
      this.offset++;
      this.match += ch;
      this.matched += ch;

      // Count the linenumber up when we hit the LF (or a stand-alone CR).
      // On CRLF, the linenumber is incremented when you fetch the CR or the CRLF combo
      // and we advance immediately past the LF as well, returning both together as if
      // it was all a single 'character' only.
      var slice_len = 1;

      var lines = false;

      if (ch === '\n') {
        lines = true;
      } else if (ch === '\r') {
        lines = true;
        var ch2 = this._input[1];

        if (ch2 === '\n') {
          slice_len++;
          ch += ch2;
          this.yytext += ch2;
          this.yyleng++;
          this.offset++;
          this.match += ch2;
          this.matched += ch2;
          this.yylloc.range[1]++;
        }
      }

      if (lines) {
        this.yylineno++;
        this.yylloc.last_line++;
        this.yylloc.last_column = 0;
      } else {
        this.yylloc.last_column++;
      }

      this.yylloc.range[1]++;
      this._input = this._input.slice(slice_len);
      return ch;
    },

    /**
     * unshifts one char (or an entire string) into the input
     * 
     * @public
     * @this {RegExpLexer}
     */
    unput: function lexer_unput(ch) {
      var len = ch.length;
      var lines = ch.split(/(?:\r\n?|\n)/g);
      this._input = ch + this._input;
      this.yytext = this.yytext.substr(0, this.yytext.length - len);
      this.yyleng = this.yytext.length;
      this.offset -= len;
      this.match = this.match.substr(0, this.match.length - len);
      this.matched = this.matched.substr(0, this.matched.length - len);

      if (lines.length > 1) {
        this.yylineno -= lines.length - 1;
        this.yylloc.last_line = this.yylineno + 1;
        var pre = this.match;
        var pre_lines = pre.split(/(?:\r\n?|\n)/g);

        if (pre_lines.length === 1) {
          pre = this.matched;
          pre_lines = pre.split(/(?:\r\n?|\n)/g);
        }

        this.yylloc.last_column = pre_lines[pre_lines.length - 1].length;
      } else {
        this.yylloc.last_column -= len;
      }

      this.yylloc.range[1] = this.yylloc.range[0] + this.yyleng;
      this.done = false;
      return this;
    },

    /**
     * cache matched text and append it on next action
     * 
     * @public
     * @this {RegExpLexer}
     */
    more: function lexer_more() {
      this._more = true;
      return this;
    },

    /**
     * signal the lexer that this rule fails to match the input, so the
     * next matching rule (regex) should be tested instead.
     * 
     * @public
     * @this {RegExpLexer}
     */
    reject: function lexer_reject() {
      if (this.options.backtrack_lexer) {
        this._backtrack = true;
      } else {
        // when the `parseError()` call returns, we MUST ensure that the error is registered.
        // We accomplish this by signaling an 'error' token to be produced for the current
        // `.lex()` run.
        var lineno_msg = '';

        if (this.options.trackPosition) {
          lineno_msg = ' on line ' + (this.yylineno + 1);
        }

        var pos_str = '';

        if (typeof this.showPosition === 'function') {
          pos_str = this.showPosition();

          if (pos_str && pos_str[0] !== '\n') {
            pos_str = '\n' + pos_str;
          }
        }

        var p = this.constructLexErrorInfo(
          'Lexical error' + lineno_msg + ': You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).' + pos_str,
          false
        );

        this._signaled_error_token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
      }

      return this;
    },

    /**
     * retain first n characters of the match
     * 
     * @public
     * @this {RegExpLexer}
     */
    less: function lexer_less(n) {
      return this.unput(this.match.slice(n));
    },

    /**
     * return (part of the) already matched input, i.e. for error
     * messages.
     * 
     * Limit the returned string length to `maxSize` (default: 20).
     * 
     * Limit the returned string to the `maxLines` number of lines of
     * input (default: 1).
     * 
     * Negative limit values equal *unlimited*.
     * 
     * @public
     * @this {RegExpLexer}
     */
    pastInput: function lexer_pastInput(maxSize, maxLines) {
      var past = this.matched.substring(0, this.matched.length - this.match.length);

      if (maxSize < 0)
        maxSize = past.length;
      else if (!maxSize)
        maxSize = 20;

      if (maxLines < 0)
        maxLines = past.length;          // can't ever have more input lines than this! 
      else if (!maxLines)
        maxLines = 1;

      // `substr` anticipation: treat \r\n as a single character and take a little
      // more than necessary so that we can still properly check against maxSize
      // after we've transformed and limited the newLines in here:
      past = past.substr(-maxSize * 2 - 2);

      // now that we have a significantly reduced string to process, transform the newlines
      // and chop them, then limit them:
      var a = past.replace(/\r\n|\r/g, '\n').split('\n');

      a = a.slice(-maxLines);
      past = a.join('\n');

      // When, after limiting to maxLines, we still have too much to return,
      // do add an ellipsis prefix...
      if (past.length > maxSize) {
        past = '...' + past.substr(-maxSize);
      }

      return past;
    },

    /**
     * return (part of the) upcoming input, i.e. for error messages.
     * 
     * Limit the returned string length to `maxSize` (default: 20).
     * 
     * Limit the returned string to the `maxLines` number of lines of input (default: 1).
     * 
     * Negative limit values equal *unlimited*.
     *
     * > ### NOTE ###
     * >
     * > *"upcoming input"* is defined as the whole of the both
     * > the *currently lexed* input, together with any remaining input
     * > following that. *"currently lexed"* input is the input 
     * > already recognized by the lexer but not yet returned with
     * > the lexer token. This happens when you are invoking this API
     * > from inside any lexer rule action code block. 
     * >
     * 
     * @public
     * @this {RegExpLexer}
     */
    upcomingInput: function lexer_upcomingInput(maxSize, maxLines) {
      var next = this.match;

      if (maxSize < 0)
        maxSize = next.length + this._input.length;
      else if (!maxSize)
        maxSize = 20;

      if (maxLines < 0)
        maxLines = maxSize;          // can't ever have more input lines than this! 
      else if (!maxLines)
        maxLines = 1;

      // `substring` anticipation: treat \r\n as a single character and take a little
      // more than necessary so that we can still properly check against maxSize
      // after we've transformed and limited the newLines in here:
      if (next.length < maxSize * 2 + 2) {
        next += this._input.substring(0, maxSize * 2 + 2);   // substring is faster on Chrome/V8 
      }

      // now that we have a significantly reduced string to process, transform the newlines
      // and chop them, then limit them:
      var a = next.replace(/\r\n|\r/g, '\n').split('\n');

      a = a.slice(0, maxLines);
      next = a.join('\n');

      // When, after limiting to maxLines, we still have too much to return,
      // do add an ellipsis postfix...
      if (next.length > maxSize) {
        next = next.substring(0, maxSize) + '...';
      }

      return next;
    },

    /**
     * return a string which displays the character position where the
     * lexing error occurred, i.e. for error messages
     * 
     * @public
     * @this {RegExpLexer}
     */
    showPosition: function lexer_showPosition(maxPrefix, maxPostfix) {
      var pre = this.pastInput(maxPrefix).replace(/\s/g, ' ');
      var c = new Array(pre.length + 1).join('-');
      return pre + this.upcomingInput(maxPostfix).replace(/\s/g, ' ') + '\n' + c + '^';
    },

    /**
     * return a string which displays the lines & columns of input which are referenced 
     * by the given location info range, plus a few lines of context.
     * 
     * This function pretty-prints the indicated section of the input, with line numbers 
     * and everything!
     * 
     * This function is very useful to provide highly readable error reports, while
     * the location range may be specified in various flexible ways:
     * 
     * - `loc` is the location info object which references the area which should be
     *   displayed and 'marked up': these lines & columns of text are marked up by `^`
     *   characters below each character in the entire input range.
     * 
     * - `context_loc` is the *optional* location info object which instructs this
     *   pretty-printer how much *leading* context should be displayed alongside
     *   the area referenced by `loc`. This can help provide context for the displayed
     *   error, etc.
     * 
     *   When this location info is not provided, a default context of 3 lines is
     *   used.
     * 
     * - `context_loc2` is another *optional* location info object, which serves
     *   a similar purpose to `context_loc`: it specifies the amount of *trailing*
     *   context lines to display in the pretty-print output.
     * 
     *   When this location info is not provided, a default context of 1 line only is
     *   used.
     * 
     * Special Notes:
     * 
     * - when the `loc`-indicated range is very large (about 5 lines or more), then
     *   only the first and last few lines of this block are printed while a
     *   `...continued...` message will be printed between them.
     * 
     *   This serves the purpose of not printing a huge amount of text when the `loc`
     *   range happens to be huge: this way a manageable & readable output results
     *   for arbitrary large ranges.
     * 
     * - this function can display lines of input which whave not yet been lexed.
     *   `prettyPrintRange()` can access the entire input!
     * 
     * @public
     * @this {RegExpLexer}
     */
    prettyPrintRange: function lexer_prettyPrintRange(loc, context_loc, context_loc2) {
      var error_size = loc.last_line - loc.first_line;
      const CONTEXT = 3;
      const CONTEXT_TAIL = 1;
      const MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT = 2;
      var input = this.matched + this._input;
      var lines = input.split('\n');

      //var show_context = (error_size < 5 || context_loc);
      var l0 = Math.max(1, (context_loc ? context_loc.first_line : loc.first_line - CONTEXT));

      var l1 = Math.max(1, (context_loc2 ? context_loc2.last_line : loc.last_line + CONTEXT_TAIL));
      var lineno_display_width = 1 + Math.log10(l1 | 1) | 0;
      var ws_prefix = new Array(lineno_display_width).join(' ');
      var nonempty_line_indexes = [];

      var rv = lines.slice(l0 - 1, l1 + 1).map(function injectLineNumber(line, index) {
        var lno = index + l0;
        var lno_pfx = (ws_prefix + lno).substr(-lineno_display_width);
        var rv = lno_pfx + ': ' + line;
        var errpfx = new Array(lineno_display_width + 1).join('^');

        if (lno === loc.first_line) {
          var offset = loc.first_column + 2;

          var len = Math.max(
            2,
            ((lno === loc.last_line ? loc.last_column : line.length)) - loc.first_column + 1
          );

          var lead = new Array(offset).join('.');
          var mark = new Array(len).join('^');
          rv += '\n' + errpfx + lead + mark;

          if (line.trim().length > 0) {
            nonempty_line_indexes.push(index);
          }
        } else if (lno === loc.last_line) {
          var offset = 2 + 1;
          var len = Math.max(2, loc.last_column + 1);
          var lead = new Array(offset).join('.');
          var mark = new Array(len).join('^');
          rv += '\n' + errpfx + lead + mark;

          if (line.trim().length > 0) {
            nonempty_line_indexes.push(index);
          }
        } else if (lno > loc.first_line && lno < loc.last_line) {
          var offset = 2 + 1;
          var len = Math.max(2, line.length + 1);
          var lead = new Array(offset).join('.');
          var mark = new Array(len).join('^');
          rv += '\n' + errpfx + lead + mark;

          if (line.trim().length > 0) {
            nonempty_line_indexes.push(index);
          }
        }

        rv = rv.replace(/\t/g, ' ');
        return rv;
      });

      // now make sure we don't print an overly large amount of error area: limit it 
      // to the top and bottom line count:
      if (nonempty_line_indexes.length > 2 * MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT) {
        var clip_start = nonempty_line_indexes[MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT - 1] + 1;
        var clip_end = nonempty_line_indexes[nonempty_line_indexes.length - MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT] - 1;

        console.log('clip off: ', {
          start: clip_start,
          end: clip_end,
          len: clip_end - clip_start + 1,
          arr: nonempty_line_indexes,
          rv
        });

        var intermediate_line = new Array(lineno_display_width + 1).join(' ') + '  (...continued...)';
        intermediate_line += '\n' + new Array(lineno_display_width + 1).join('-') + '  (---------------)';
        rv.splice(clip_start, clip_end - clip_start + 1, intermediate_line);
      }

      return rv.join('\n');
    },

    /**
     * helper function, used to produce a human readable description as a string, given
     * the input `yylloc` location object.
     * 
     * Set `display_range_too` to TRUE to include the string character index position(s)
     * in the description if the `yylloc.range` is available.
     * 
     * @public
     * @this {RegExpLexer}
     */
    describeYYLLOC: function lexer_describe_yylloc(yylloc, display_range_too) {
      var l1 = yylloc.first_line;
      var l2 = yylloc.last_line;
      var c1 = yylloc.first_column;
      var c2 = yylloc.last_column;
      var dl = l2 - l1;
      var dc = c2 - c1;
      var rv;

      if (dl === 0) {
        rv = 'line ' + l1 + ', ';

        if (dc <= 1) {
          rv += 'column ' + c1;
        } else {
          rv += 'columns ' + c1 + ' .. ' + c2;
        }
      } else {
        rv = 'lines ' + l1 + '(column ' + c1 + ') .. ' + l2 + '(column ' + c2 + ')';
      }

      if (yylloc.range && display_range_too) {
        var r1 = yylloc.range[0];
        var r2 = yylloc.range[1] - 1;

        if (r2 <= r1) {
          rv += ' {String Offset: ' + r1 + '}';
        } else {
          rv += ' {String Offset range: ' + r1 + ' .. ' + r2 + '}';
        }
      }

      return rv;
    },

    /**
     * test the lexed token: return FALSE when not a match, otherwise return token.
     * 
     * `match` is supposed to be an array coming out of a regex match, i.e. `match[0]`
     * contains the actually matched text string.
     * 
     * Also move the input cursor forward and update the match collectors:
     * 
     * - `yytext`
     * - `yyleng`
     * - `match`
     * - `matches`
     * - `yylloc`
     * - `offset`
     * 
     * @public
     * @this {RegExpLexer}
     */
    test_match: function lexer_test_match(match, indexed_rule) {
      var token, lines, backup, match_str, match_str_len;

      if (this.options.backtrack_lexer) {
        // save context
        backup = {
          yylineno: this.yylineno,

          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.yylloc.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column,
            range: this.yylloc.range.slice(0)
          },

          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,

          //_signaled_error_token: this._signaled_error_token,
          yy: this.yy,

          conditionStack: this.conditionStack.slice(0),
          done: this.done
        };
      }

      match_str = match[0];
      match_str_len = match_str.length;

      // if (match_str.indexOf('\n') !== -1 || match_str.indexOf('\r') !== -1) {
      lines = match_str.split(/(?:\r\n?|\n)/g);

      if (lines.length > 1) {
        this.yylineno += lines.length - 1;
        this.yylloc.last_line = this.yylineno + 1;
        this.yylloc.last_column = lines[lines.length - 1].length;
      } else {
        this.yylloc.last_column += match_str_len;
      }

      // }
      this.yytext += match_str;

      this.match += match_str;
      this.matched += match_str;
      this.matches = match;
      this.yyleng = this.yytext.length;
      this.yylloc.range[1] += match_str_len;

      // previous lex rules MAY have invoked the `more()` API rather than producing a token:
      // those rules will already have moved this `offset` forward matching their match lengths,
      // hence we must only add our own match length now:
      this.offset += match_str_len;

      this._more = false;
      this._backtrack = false;
      this._input = this._input.slice(match_str_len);

      // calling this method:
      //
      //   function lexer__performAction(yy, yyrulenumber, YY_START) {...}
      token = this.performAction.call(
        this,
        this.yy,
        indexed_rule,
        this.conditionStack[this.conditionStack.length - 1] /* = YY_START */
      );

      // otherwise, when the action codes are all simple return token statements:
      //token = this.simpleCaseActionClusters[indexed_rule];

      if (this.done && this._input) {
        this.done = false;
      }

      if (token) {
        return token;
      } else if (this._backtrack) {
        // recover context
        for (var k in backup) {
          this[k] = backup[k];
        }

        this.__currentRuleSet__ = null;
        return false;  // rule action called reject() implying the next rule should be tested instead. 
      } else if (this._signaled_error_token) {
        // produce one 'error' token as `.parseError()` in `reject()`
        // did not guarantee a failure signal by throwing an exception!
        token = this._signaled_error_token;

        this._signaled_error_token = false;
        return token;
      }

      return false;
    },

    /**
     * return next match in input
     * 
     * @public
     * @this {RegExpLexer}
     */
    next: function lexer_next() {
      if (this.done) {
        this.clear();
        return this.EOF;
      }

      if (!this._input) {
        this.done = true;
      }

      var token, match, tempMatch, index;

      if (!this._more) {
        this.clear();
      }

      var spec = this.__currentRuleSet__;

      if (!spec) {
        // Update the ruleset cache as we apparently encountered a state change or just started lexing.
        // The cache is set up for fast lookup -- we assume a lexer will switch states much less often than it will
        // invoke the `lex()` token-producing API and related APIs, hence caching the set for direct access helps
        // speed up those activities a tiny bit.
        spec = this.__currentRuleSet__ = this._currentRules();

        // Check whether a *sane* condition has been pushed before: this makes the lexer robust against
        // user-programmer bugs such as https://github.com/zaach/jison-lex/issues/19
        if (!spec || !spec.rules) {
          var lineno_msg = '';

          if (this.options.trackPosition) {
            lineno_msg = ' on line ' + (this.yylineno + 1);
          }

          var pos_str = '';

          if (typeof this.showPosition === 'function') {
            pos_str = this.showPosition();

            if (pos_str && pos_str[0] !== '\n') {
              pos_str = '\n' + pos_str;
            }
          }

          var p = this.constructLexErrorInfo(
            'Internal lexer engine error' + lineno_msg + ': The lex grammar programmer pushed a non-existing condition name "' + this.topState() + '"; this is a fatal error and should be reported to the application programmer team!' + pos_str,
            false
          );

          // produce one 'error' token until this situation has been resolved, most probably by parse termination!
          return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
        }
      }

      var rule_ids = spec.rules;
      var regexes = spec.__rule_regexes;
      var len = spec.__rule_count;

      // Note: the arrays are 1-based, while `len` itself is a valid index,
      // hence the non-standard less-or-equal check in the next loop condition!
      for (var i = 1; i <= len; i++) {
        tempMatch = this._input.match(regexes[i]);

        if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
          match = tempMatch;
          index = i;

          if (this.options.backtrack_lexer) {
            token = this.test_match(tempMatch, rule_ids[i]);

            if (token !== false) {
              return token;
            } else if (this._backtrack) {
              match = undefined;
              continue;  // rule action called reject() implying a rule MISmatch. 
            } else {
              // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
              return false;
            }
          } else if (!this.options.flex) {
            break;
          }
        }
      }

      if (match) {
        token = this.test_match(match, rule_ids[index]);

        if (token !== false) {
          return token;
        }

        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
        return false;
      }

      if (!this._input) {
        this.done = true;
        this.clear();
        return this.EOF;
      } else {
        var lineno_msg = '';

        if (this.options.trackPosition) {
          lineno_msg = ' on line ' + (this.yylineno + 1);
        }

        var pos_str = '';

        if (typeof this.showPosition === 'function') {
          pos_str = this.showPosition();

          if (pos_str && pos_str[0] !== '\n') {
            pos_str = '\n' + pos_str;
          }
        }

        var p = this.constructLexErrorInfo(
          'Lexical error' + lineno_msg + ': Unrecognized text.' + pos_str,
          this.options.lexerErrorsAreRecoverable
        );

        token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;

        if (token === this.ERROR) {
          // we can try to recover from a lexer error that `parseError()` did not 'recover' for us
          // by moving forward at least one character at a time:
          if (!this.match.length) {
            this.input();
          }
        }

        return token;
      }
    },

    /**
     * return next match that has a token
     * 
     * @public
     * @this {RegExpLexer}
     */
    lex: function lexer_lex() {
      var r;

      // allow the PRE/POST handlers set/modify the return token for maximum flexibility of the generated lexer:
      if (typeof this.options.pre_lex === 'function') {
        r = this.options.pre_lex.call(this);
      }

      while (!r) {
        r = this.next();
      }

      if (typeof this.options.post_lex === 'function') {
        // (also account for a userdef function which does not return any value: keep the token as is)
        r = this.options.post_lex.call(this, r) || r;
      }

      return r;
    },

    /**
     * backwards compatible alias for `pushState()`;
     * the latter is symmetrical with `popState()` and we advise to use
     * those APIs in any modern lexer code, rather than `begin()`.
     * 
     * @public
     * @this {RegExpLexer}
     */
    begin: function lexer_begin(condition) {
      return this.pushState(condition);
    },

    /**
     * activates a new lexer condition state (pushes the new lexer
     * condition state onto the condition stack)
     * 
     * @public
     * @this {RegExpLexer}
     */
    pushState: function lexer_pushState(condition) {
      this.conditionStack.push(condition);
      this.__currentRuleSet__ = null;
      return this;
    },

    /**
     * pop the previously active lexer condition state off the condition
     * stack
     * 
     * @public
     * @this {RegExpLexer}
     */
    popState: function lexer_popState() {
      var n = this.conditionStack.length - 1;

      if (n > 0) {
        this.__currentRuleSet__ = null;
        return this.conditionStack.pop();
      } else {
        return this.conditionStack[0];
      }
    },

    /**
     * return the currently active lexer condition state; when an index
     * argument is provided it produces the N-th previous condition state,
     * if available
     * 
     * @public
     * @this {RegExpLexer}
     */
    topState: function lexer_topState(n) {
      n = this.conditionStack.length - 1 - Math.abs(n || 0);

      if (n >= 0) {
        return this.conditionStack[n];
      } else {
        return 'INITIAL';
      }
    },

    /**
     * (internal) determine the lexer rule set which is active for the
     * currently active lexer condition state
     * 
     * @public
     * @this {RegExpLexer}
     */
    _currentRules: function lexer__currentRules() {
      if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
        return this.conditions[this.conditionStack[this.conditionStack.length - 1]];
      } else {
        return this.conditions['INITIAL'];
      }
    },

    /**
     * return the number of states currently on the stack
     * 
     * @public
     * @this {RegExpLexer}
     */
    stateStackSize: function lexer_stateStackSize() {
      return this.conditionStack.length;
    },

    options: {
      flex: true,
      trackPosition: true,
      parseActionsUseYYMERGELOCATIONINFO: true
    },

    JisonLexerError: JisonLexerError,

    performAction: function lexer__performAction(yy, yyrulenumber, YY_START) {
      var yy_ = this;
      var YYSTATE = YY_START;

      switch (yyrulenumber) {
      case 0:
        /*! Conditions:: * */
        /*! Rule::       \s+ */
        return;

        break;

      case 5:
        /*! Conditions:: INITIAL */
        /*! Rule::       \{% */
        this.begin('CONTROL');

        return 28;
        break;

      case 6:
        /*! Conditions:: INITIAL */
        /*! Rule::       <!-- */
        this.begin('COMMENT');

        return;
        break;

      case 7:
        /*! Conditions:: INITIAL */
        /*! Rule::       < */
        this.begin('TAG');

        return 13;
        break;

      case 8:
        /*! Conditions:: INITIAL */
        /*! Rule::       \{\{ */
        this.begin('EXPRESSION');

        return 39;
        break;

      case 17:
        /*! Conditions:: TAG */
        /*! Rule::       \/> */
        this.popState();

        return 38;
        break;

      case 19:
        /*! Conditions:: TAG */
        /*! Rule::       > */
        this.begin('CHILDREN');

        return 14;
        break;

      case 20:
        /*! Conditions:: TAG */
        /*! Rule::       \{\{ */
        this.begin('EXPRESSION');

        return 39;
        break;

      case 23:
        /*! Conditions:: CHILDREN */
        /*! Rule::       \{\{ */
        this.begin('EXPRESSION');

        return 39;
        break;

      case 24:
        /*! Conditions:: CHILDREN */
        /*! Rule::       \{% */
        this.begin('CONTROL');

        return 28;
        break;

      case 25:
        /*! Conditions:: CHILDREN */
        /*! Rule::       <!-- */
        this.begin('COMMENT');

        return;
        break;

      case 26:
        /*! Conditions:: CHILDREN */
        /*! Rule::       <\/ */
        this.begin('TAG');

        return 37;
        break;

      case 27:
        /*! Conditions:: CHILDREN */
        /*! Rule::       < */
        this.begin('TAG');

        return 13;
        break;

      case 57:
        /*! Conditions:: CONTROL */
        /*! Rule::       = */
        this.popState();

        this.begin('CONTROL_CHILD');
        return 9;
        break;

      case 60:
        /*! Conditions:: CONTROL */
        /*! Rule::       %\} */
        this.popState();

        return 30;
        break;

      case 63:
        /*! Conditions:: CONTROL_CHILD */
        /*! Rule::       < */
        this.begin('TAG');

        return 13;
        break;

      case 64:
        /*! Conditions:: CONTROL_CHILD */
        /*! Rule::       \{\{ */
        this.begin('EXPRESSION');

        return 39;
        break;

      case 65:
        /*! Conditions:: CONTROL_CHILD */
        /*! Rule::       %\} */
        this.popState();

        return 30;
        break;

      case 83:
        /*! Conditions:: EXPRESSION */
        /*! Rule::       \}\} */
        this.popState();

        return 40;
        break;

      case 86:
        /*! Conditions:: COMMENT */
        /*! Rule::       (.|\r|\n)*?--> */
        this.popState();

        return;
        break;

      case 115:
        /*! Conditions:: INITIAL */
        /*! Rule::       . */
        console.log('', yy_.yytext);

        /* `flex` lexing mode: the last resort rule! */
        break;

      default:
        return this.simpleCaseActionClusters[yyrulenumber];
      }
    },

    simpleCaseActionClusters: {
      /*! Conditions:: INITIAL */
      /*! Rule::       import */
      1: 25,

      /*! Conditions:: INITIAL */
      /*! Rule::       from */
      2: 26,

      /*! Conditions:: INITIAL */
      /*! Rule::       using */
      3: 'USING',

      /*! Conditions:: INITIAL */
      /*! Rule::       as */
      4: 27,

      /*! Conditions:: INITIAL */
      /*! Rule::       {Constructor} */
      9: 56,

      /*! Conditions:: INITIAL */
      /*! Rule::       {Identifier} */
      10: 55,

      /*! Conditions:: INITIAL */
      /*! Rule::       \{ */
      11: 4,

      /*! Conditions:: INITIAL */
      /*! Rule::       \} */
      12: 5,

      /*! Conditions:: TAG */
      /*! Rule::       true */
      13: 53,

      /*! Conditions:: TAG */
      /*! Rule::       false */
      14: 54,

      /*! Conditions:: TAG */
      /*! Rule::       {Constructor} */
      15: 56,

      /*! Conditions:: TAG */
      /*! Rule::       {Identifier} */
      16: 55,

      /*! Conditions:: TAG */
      /*! Rule::       \/ */
      18: 'NOSE',

      /*! Conditions:: TAG */
      /*! Rule::       \{ */
      21: 4,

      /*! Conditions:: TAG */
      /*! Rule::       \} */
      22: 5,

      /*! Conditions:: CHILDREN */
      /*! Rule::       \{ */
      28: 4,

      /*! Conditions:: CHILDREN */
      /*! Rule::       \} */
      29: 5,

      /*! Conditions:: CHILDREN */
      /*! Rule::       [^/<>{%}]+ */
      30: 47,

      /*! Conditions:: CONTROL */
      /*! Rule::       main */
      31: 29,

      /*! Conditions:: CONTROL */
      /*! Rule::       endmain */
      32: 31,

      /*! Conditions:: CONTROL */
      /*! Rule::       macro */
      33: 'MACRO',

      /*! Conditions:: CONTROL */
      /*! Rule::       endmacro */
      34: 'ENDMACRO',

      /*! Conditions:: CONTROL */
      /*! Rule::       for */
      35: 41,

      /*! Conditions:: CONTROL */
      /*! Rule::       endfor */
      36: 43,

      /*! Conditions:: CONTROL */
      /*! Rule::       if */
      37: 45,

      /*! Conditions:: CONTROL */
      /*! Rule::       endif */
      38: 46,

      /*! Conditions:: CONTROL */
      /*! Rule::       else */
      39: 44,

      /*! Conditions:: CONTROL */
      /*! Rule::       elseif */
      40: 'ELSEIF',

      /*! Conditions:: CONTROL */
      /*! Rule::       in */
      41: 42,

      /*! Conditions:: CONTROL */
      /*! Rule::       case */
      42: 'CASE',

      /*! Conditions:: CONTROL */
      /*! Rule::       endcase */
      43: 'ENDCASE',

      /*! Conditions:: CONTROL */
      /*! Rule::       export */
      44: 32,

      /*! Conditions:: CONTROL */
      /*! Rule::       from */
      45: 26,

      /*! Conditions:: CONTROL */
      /*! Rule::       view */
      46: 33,

      /*! Conditions:: CONTROL */
      /*! Rule::       using */
      47: 'USING',

      /*! Conditions:: CONTROL */
      /*! Rule::       endview */
      48: 34,

      /*! Conditions:: CONTROL */
      /*! Rule::       instanceof */
      49: 63,

      /*! Conditions:: CONTROL */
      /*! Rule::       this */
      50: 'THIS',

      /*! Conditions:: CONTROL */
      /*! Rule::       fun */
      51: 35,

      /*! Conditions:: CONTROL */
      /*! Rule::       endfun */
      52: 36,

      /*! Conditions:: CONTROL */
      /*! Rule::       as */
      53: 27,

      /*! Conditions:: CONTROL */
      /*! Rule::       :: */
      54: '::',

      /*! Conditions:: CONTROL */
      /*! Rule::       @ */
      55: 19,

      /*! Conditions:: CONTROL */
      /*! Rule::       \(\) */
      56: '()',

      /*! Conditions:: CONTROL */
      /*! Rule::       {Constructor} */
      58: 56,

      /*! Conditions:: CONTROL */
      /*! Rule::       {Identifier} */
      59: 55,

      /*! Conditions:: CONTROL */
      /*! Rule::       \{ */
      61: 4,

      /*! Conditions:: CONTROL */
      /*! Rule::       \} */
      62: 5,

      /*! Conditions:: CONTROL_CHILD */
      /*! Rule::       {Constructor} */
      66: 56,

      /*! Conditions:: CONTROL_CHILD */
      /*! Rule::       {Identifier} */
      67: 55,

      /*! Conditions:: CONTROL_CHILD */
      /*! Rule::       \{ */
      68: 4,

      /*! Conditions:: CONTROL_CHILD */
      /*! Rule::       \} */
      69: 5,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       \| */
      70: 15,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       => */
      71: 50,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       -> */
      72: '->',

      /*! Conditions:: EXPRESSION */
      /*! Rule::       @ */
      73: 19,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       instanceof */
      74: 63,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       true */
      75: 53,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       false */
      76: 54,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       if */
      77: 45,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       then */
      78: 48,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       else */
      79: 44,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       as */
      80: 27,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       {Constructor} */
      81: 56,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       {Identifier} */
      82: 55,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       \{ */
      84: 4,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       \} */
      85: 5,

      /*! Conditions:: * */
      /*! Rule::       {NumberLiteral} */
      87: 52,

      /*! Conditions:: * */
      /*! Rule::       {StringLiteral} */
      88: 51,

      /*! Conditions:: * */
      /*! Rule::       > */
      89: 14,

      /*! Conditions:: * */
      /*! Rule::       < */
      90: 13,

      /*! Conditions:: * */
      /*! Rule::       \( */
      91: 7,

      /*! Conditions:: * */
      /*! Rule::       \) */
      92: 8,

      /*! Conditions:: * */
      /*! Rule::       \[ */
      93: 10,

      /*! Conditions:: * */
      /*! Rule::       \] */
      94: 11,

      /*! Conditions:: * */
      /*! Rule::       ; */
      95: 20,

      /*! Conditions:: * */
      /*! Rule::       : */
      96: 12,

      /*! Conditions:: * */
      /*! Rule::       = */
      97: 9,

      /*! Conditions:: * */
      /*! Rule::       == */
      98: 59,

      /*! Conditions:: * */
      /*! Rule::       != */
      99: 60,

      /*! Conditions:: * */
      /*! Rule::       >= */
      100: 57,

      /*! Conditions:: * */
      /*! Rule::       <= */
      101: 58,

      /*! Conditions:: * */
      /*! Rule::       \+ */
      102: 21,

      /*! Conditions:: * */
      /*! Rule::       - */
      103: 23,

      /*! Conditions:: * */
      /*! Rule::       \* */
      104: 3,

      /*! Conditions:: * */
      /*! Rule::       \/ */
      105: 22,

      /*! Conditions:: * */
      /*! Rule::       \\ */
      106: 49,

      /*! Conditions:: * */
      /*! Rule::       && */
      107: 61,

      /*! Conditions:: * */
      /*! Rule::       \|\| */
      108: 62,

      /*! Conditions:: * */
      /*! Rule::       \^ */
      109: 24,

      /*! Conditions:: * */
      /*! Rule::       ! */
      110: 16,

      /*! Conditions:: * */
      /*! Rule::       , */
      111: 6,

      /*! Conditions:: * */
      /*! Rule::       \? */
      112: 18,

      /*! Conditions:: * */
      /*! Rule::       \. */
      113: 17,

      /*! Conditions:: * */
      /*! Rule::       $ */
      114: 1
    },

    rules: [
      /*   0: */  /^(?:\s+)/,
      /*   1: */  /^(?:import)/,
      /*   2: */  /^(?:from)/,
      /*   3: */  /^(?:using)/,
      /*   4: */  /^(?:as)/,
      /*   5: */  /^(?:\{%)/,
      /*   6: */  /^(?:<!--)/,
      /*   7: */  /^(?:<)/,
      /*   8: */  /^(?:\{\{)/,
      /*   9: */  /^(?:([A-Z][\w$\-]*))/,
      /*  10: */  /^(?:([$_a-z][\w$\-]*))/,
      /*  11: */  /^(?:\{)/,
      /*  12: */  /^(?:\})/,
      /*  13: */  /^(?:true)/,
      /*  14: */  /^(?:false)/,
      /*  15: */  /^(?:([A-Z][\w$\-]*))/,
      /*  16: */  /^(?:([$_a-z][\w$\-]*))/,
      /*  17: */  /^(?:\/>)/,
      /*  18: */  /^(?:\/)/,
      /*  19: */  /^(?:>)/,
      /*  20: */  /^(?:\{\{)/,
      /*  21: */  /^(?:\{)/,
      /*  22: */  /^(?:\})/,
      /*  23: */  /^(?:\{\{)/,
      /*  24: */  /^(?:\{%)/,
      /*  25: */  /^(?:<!--)/,
      /*  26: */  /^(?:<\/)/,
      /*  27: */  /^(?:<)/,
      /*  28: */  /^(?:\{)/,
      /*  29: */  /^(?:\})/,
      /*  30: */  /^(?:[^\/<>{%}]+)/,
      /*  31: */  /^(?:main)/,
      /*  32: */  /^(?:endmain)/,
      /*  33: */  /^(?:macro)/,
      /*  34: */  /^(?:endmacro)/,
      /*  35: */  /^(?:for)/,
      /*  36: */  /^(?:endfor)/,
      /*  37: */  /^(?:if)/,
      /*  38: */  /^(?:endif)/,
      /*  39: */  /^(?:else)/,
      /*  40: */  /^(?:elseif)/,
      /*  41: */  /^(?:in)/,
      /*  42: */  /^(?:case)/,
      /*  43: */  /^(?:endcase)/,
      /*  44: */  /^(?:export)/,
      /*  45: */  /^(?:from)/,
      /*  46: */  /^(?:view)/,
      /*  47: */  /^(?:using)/,
      /*  48: */  /^(?:endview)/,
      /*  49: */  /^(?:instanceof)/,
      /*  50: */  /^(?:this)/,
      /*  51: */  /^(?:fun)/,
      /*  52: */  /^(?:endfun)/,
      /*  53: */  /^(?:as)/,
      /*  54: */  /^(?:::)/,
      /*  55: */  /^(?:@)/,
      /*  56: */  /^(?:\(\))/,
      /*  57: */  /^(?:=)/,
      /*  58: */  /^(?:([A-Z][\w$\-]*))/,
      /*  59: */  /^(?:([$_a-z][\w$\-]*))/,
      /*  60: */  /^(?:%\})/,
      /*  61: */  /^(?:\{)/,
      /*  62: */  /^(?:\})/,
      /*  63: */  /^(?:<)/,
      /*  64: */  /^(?:\{\{)/,
      /*  65: */  /^(?:%\})/,
      /*  66: */  /^(?:([A-Z][\w$\-]*))/,
      /*  67: */  /^(?:([$_a-z][\w$\-]*))/,
      /*  68: */  /^(?:\{)/,
      /*  69: */  /^(?:\})/,
      /*  70: */  /^(?:\|)/,
      /*  71: */  /^(?:=>)/,
      /*  72: */  /^(?:->)/,
      /*  73: */  /^(?:@)/,
      /*  74: */  /^(?:instanceof)/,
      /*  75: */  /^(?:true)/,
      /*  76: */  /^(?:false)/,
      /*  77: */  /^(?:if)/,
      /*  78: */  /^(?:then)/,
      /*  79: */  /^(?:else)/,
      /*  80: */  /^(?:as)/,
      /*  81: */  /^(?:([A-Z][\w$\-]*))/,
      /*  82: */  /^(?:([$_a-z][\w$\-]*))/,
      /*  83: */  /^(?:\}\})/,
      /*  84: */  /^(?:\{)/,
      /*  85: */  /^(?:\})/,
      /*  86: */  /^(?:(.|\r|\n)*?-->)/,
      /*  87: */  /^(?:((?:([-]?(?:[-]?([0]|((?:[1-9])(?:\d+)*)))\.(?:\d+)*(?:(?:[Ee])(?:[+-]?\d+))?)|(\.(?:\d+)(?:(?:[Ee])(?:[+-]?\d+))?)|((?:[-]?([0]|((?:[1-9])(?:\d+)*)))(?:(?:[Ee])(?:[+-]?\d+))?))|(?:[0][Xx](?:[\dA-Fa-f])+)|(?:[0](?:[0-7])+)))/,
      /*  88: */  /^(?:(("(?:([^\n\r"\\]+)|(\\(?:(?:(?:["'\\bfnrtv])|(?:[^\d"'\\bfnrt-vx]))|(?:(?:[1-7][0-7]{0,2}|[0-7]{2,3}))|(?:[x](?:[\dA-Fa-f]){2})|(?:[u](?:[\dA-Fa-f]){4})))|(?:\\(\r\n|\r|\n)))*")|('(?:([^\n\r'\\]+)|(\\(?:(?:(?:["'\\bfnrtv])|(?:[^\d"'\\bfnrt-vx]))|(?:(?:[1-7][0-7]{0,2}|[0-7]{2,3}))|(?:[x](?:[\dA-Fa-f]){2})|(?:[u](?:[\dA-Fa-f]){4})))|(?:\\(\r\n|\r|\n)))*')|(`(?:([^\n\r\\`]+)|(\\(?:(?:(?:["'\\bfnrtv])|(?:[^\d"'\\bfnrt-vx]))|(?:(?:[1-7][0-7]{0,2}|[0-7]{2,3}))|(?:[x](?:[\dA-Fa-f]){2})|(?:[u](?:[\dA-Fa-f]){4})))|(?:\\(\r\n|\r|\n)))*`)))/,
      /*  89: */  /^(?:>)/,
      /*  90: */  /^(?:<)/,
      /*  91: */  /^(?:\()/,
      /*  92: */  /^(?:\))/,
      /*  93: */  /^(?:\[)/,
      /*  94: */  /^(?:\])/,
      /*  95: */  /^(?:;)/,
      /*  96: */  /^(?::)/,
      /*  97: */  /^(?:=)/,
      /*  98: */  /^(?:==)/,
      /*  99: */  /^(?:!=)/,
      /* 100: */  /^(?:>=)/,
      /* 101: */  /^(?:<=)/,
      /* 102: */  /^(?:\+)/,
      /* 103: */  /^(?:-)/,
      /* 104: */  /^(?:\*)/,
      /* 105: */  /^(?:\/)/,
      /* 106: */  /^(?:\\)/,
      /* 107: */  /^(?:&&)/,
      /* 108: */  /^(?:\|\|)/,
      /* 109: */  /^(?:\^)/,
      /* 110: */  /^(?:!)/,
      /* 111: */  /^(?:,)/,
      /* 112: */  /^(?:\?)/,
      /* 113: */  /^(?:\.)/,
      /* 114: */  /^(?:$)/,
      /* 115: */  /^(?:.)/
    ],

    conditions: {
      'CHILDREN': {
        rules: [
          0,
          23,
          24,
          25,
          26,
          27,
          28,
          29,
          30,
          87,
          88,
          89,
          90,
          91,
          92,
          93,
          94,
          95,
          96,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114
        ],

        inclusive: false
      },

      'COMMENT': {
        rules: [
          0,
          86,
          87,
          88,
          89,
          90,
          91,
          92,
          93,
          94,
          95,
          96,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114
        ],

        inclusive: false
      },

      'CONTROL': {
        rules: [
          0,
          31,
          32,
          33,
          34,
          35,
          36,
          37,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          46,
          47,
          48,
          49,
          50,
          51,
          52,
          53,
          54,
          55,
          56,
          57,
          58,
          59,
          60,
          61,
          62,
          87,
          88,
          89,
          90,
          91,
          92,
          93,
          94,
          95,
          96,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114
        ],

        inclusive: false
      },

      'EXPRESSION': {
        rules: [
          0,
          70,
          71,
          72,
          73,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          82,
          83,
          84,
          85,
          87,
          88,
          89,
          90,
          91,
          92,
          93,
          94,
          95,
          96,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114
        ],

        inclusive: false
      },

      'CONTROL_CHILD': {
        rules: [
          0,
          63,
          64,
          65,
          66,
          67,
          68,
          69,
          87,
          88,
          89,
          90,
          91,
          92,
          93,
          94,
          95,
          96,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114
        ],

        inclusive: false
      },

      'TAG': {
        rules: [
          0,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          87,
          88,
          89,
          90,
          91,
          92,
          93,
          94,
          95,
          96,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114
        ],

        inclusive: false
      },

      'INITIAL': {
        rules: [
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          87,
          88,
          89,
          90,
          91,
          92,
          93,
          94,
          95,
          96,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115
        ],

        inclusive: true
      }
    }
  };

  return lexer;
}();
parser.lexer = lexer;

function Parser() {
  this.yy = {};
}
Parser.prototype = parser;
parser.Parser = Parser;

return new Parser();
})();

        


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
  exports.parser = Parser;
  exports.Parser = Parser.Parser;
  exports.parse = function () {
    return Parser.parse.apply(Parser, arguments);
  };
  
}

},{}],161:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var nodes = require("./AST");
var afpl = require("afpl");
var CONTEXT = '___context';
var VIEW = '___view';
var WML = '___wml';
var prims = ['String', 'Boolean', 'Number', 'Object', 'Undefined', 'Null', 'Void', 'Never', 'Any'];
/**
 * Types and functions for generating typescript program text.
 */
var _throwNotKnown = function (n) {
    throw new Error("Unsupported AST node " + (typeof n === 'object' ? n.constructor.name : n) + "!");
};
var noop = function () { return "function () {}"; };
/**
 * view template.
 */
exports.view = function (id, typeClasses, params, ctx, tag) {
    return "export class " + id + typeClasses + " extends " + WML + ".AppView<" + ctx + "> {\n\n    constructor(context: " + ctx + (params ? ',' + params : '') + ") {\n\n        super(context);\n\n        this.template = (" + CONTEXT + ":" + ctx + ", " + VIEW + ":" + WML + ".AppView<" + ctx + ">) =>\n          " + (tag ? tag : '<Node>document.createDocumentFragment()') + ";\n\n       }\n\n     }\n";
};
/**
 * code turns an AST into typescript code.
 */
exports.code = function (n, o) { return exports.module2TS(n, o); };
/**
 * module2TS converts a module to a typescript module.
 */
exports.module2TS = function (n, _a) {
    var module = _a.module;
    return "\nimport * as " + WML + " from '" + module + "';\n" + n.imports.map(exports.importStatement2TS).join(';\n') + "\n\n" + n.exports.map(exports.exports2TS).join(';\n') + "\n\n" + (n.main ? exports.main2TS(n.main) : '') + "\n";
};
/**
 * exports2TS converts various exports to typescript.
 */
exports.exports2TS = function (n) {
    if (n instanceof nodes.ExportStatement)
        return exports.exportStatement2TS(n);
    else if (n instanceof nodes.FunStatement)
        return exports.funStatement2TS(n);
    else if (n instanceof nodes.ViewStatement)
        return exports.viewStatement2TS(n);
    else
        return _throwNotKnown(n);
};
/**
 * importStatement2TS converts an import statement.
 */
exports.importStatement2TS = function (n) {
    return "import " + exports.importMember2TS(n.member) + " from '" + n.module.value + "'; ";
};
/**
 * importMember2TS converts the members of an import to typescript.
 */
exports.importMember2TS = function (n) {
    if (n instanceof nodes.AggregateMember)
        return exports.aggregateMember2TS(n);
    else if (n instanceof nodes.AliasedMember)
        return exports.aliasedMember2TS(n);
    else if (n instanceof nodes.CompositeMember)
        return exports.compositeMember2TS(n);
    else
        return _throwNotKnown;
};
/**
 * aliasedMember2TS converts a member alias to typescript.
 */
exports.aliasedMember2TS = function (n) {
    return exports.identifierOrConstructor2TS(n.member) + " as " + exports.identifierOrConstructor2TS(n.alias) + " ";
};
/**
 * aggregateMember2TS converts a qualified member to typescript.
 */
exports.aggregateMember2TS = function (n) {
    return "* as " + exports.identifierOrConstructor2TS(n.id) + " ";
};
/**
 * compositeMember2TS coverts to typescript.
 */
exports.compositeMember2TS = function (n) {
    return '{' + (n.members.map(function (m) { return (m instanceof nodes.AliasedMember) ?
        exports.aliasedMember2TS(m) :
        exports.identifierOrConstructor2TS(m); }).join(',')) + '}';
};
/**
 * main2TS converts to typescript.
 */
exports.main2TS = function (n) {
    return (n instanceof nodes.TypedMain) ?
        exports.typedMain2TS(n) :
        exports.untypedMain2TS(n);
};
/**
 * typedMain2TS converts a typed main file to typescript.
 */
exports.typedMain2TS = function (n) {
    return exports.view(n.id ? exports.unqualifiedIdentifier2TS(n.id) : 'Main', exports.typeClasses2TS(n.typeClasses), n.parameters.map(exports.parameter2TS).join(','), exports.type2TS(n.context), exports.tag2TS(n.tag));
};
/**
 * untypedMain2TS converts an untyped main file to typescript.
 */
exports.untypedMain2TS = function (n) {
    return exports.view('Main', '', '', 'void', exports.tag2TS(n.tag));
};
/**
 * exportStatement2TS converts an export statement to typescript.
 */
exports.exportStatement2TS = function (n) {
    return "export " + exports.compositeMember2TS(n.members) + " from '" + n.module.value + "';\n";
};
/**
 * viewStatement2TS converts a view statement into a typescript class.
 */
exports.viewStatement2TS = function (n) {
    return exports.view(exports.constructor2TS(n.id), exports.typeClasses2TS(n.typeClasses), n.parameters.map(exports.parameter2TS).join(','), exports.type2TS(n.context), exports.tag2TS(n.tag));
};
var _funContext = function (n) { return "(" + CONTEXT + ":" + exports.type2TS(n) + ")=>"; };
var _funView = function () { return "(" + VIEW + ":" + WML + ".View)=>"; };
/**
 * funStatement2TS converts a function statement to typescript.
 */
exports.funStatement2TS = function (n) {
    return "export const " + exports.unqualifiedIdentifier2TS(n.id) + " = " +
        (exports.typeClasses2TS(n.typeClasses) + "(" + n.parameters.map(exports.parameter2TS).join(',') + ")=>") +
        ((n.context != null) ? _funContext(n.context) : '') +
        _funView() +
        ((Array.isArray(n.body) ? exports.children2TS(n.body) : exports.child2TS(n.body)) + ";");
};
/**
 * typeClasses2TS converts a list of typeclasses into the a list of typescript typeclasses.
 */
exports.typeClasses2TS = function (ns) {
    return (ns.length === 0) ? '' : "< " + ns.map(exports.typeClass2TS).join(',') + ">";
};
/**
 * typeClass2TS converts a typeclass into a typescript typeclass.
 */
exports.typeClass2TS = function (n) {
    return exports.identifierOrConstructor2TS(n.id) + " " +
        ((n.constraint ? 'extends ' + exports.type2TS(n.constraint) : '') + " ");
};
var _toPrim = function (typ) {
    return prims.indexOf(typ) > -1 ? typ.toLowerCase() : typ;
};
/**
 * type2TS converts a type hint to a typescript type hint.
 */
exports.type2TS = function (n) {
    return _toPrim(exports.identifierOrConstructor2TS(n.id)) + " " +
        (exports.typeClasses2TS(n.typeClasses) + " " + (n.list ? '[]' : ''));
};
/**
 * parameter2TS converts a parameter to a typescript parameter.
 */
exports.parameter2TS = function (n) {
    return (n instanceof nodes.TypedParameter) ? exports.typedParameter2TS(n) :
        (n instanceof nodes.UntypedParameter) ? exports.untypedParameter2TS(n) :
            _throwNotKnown;
};
/**
 * typedParameter2TS converts a typed parameter into a non-any typescript parameter.
 */
exports.typedParameter2TS = function (n) {
    return exports.identifier2TS(n.id) + ":" + exports.type2TS(n.hint) + " ";
};
/**
 * untypedParameter2TS converts an type inferred parameter to a typescript parameter.
 */
exports.untypedParameter2TS = function (n) {
    return exports.identifier2TS(n.id) + " ";
};
/**
 * children2TS converts a list of children to typescript.
 */
exports.children2TS = function (list) {
    return (list.length === 0) ? 'document.createDocumentFragment();' :
        (list.length === 1) ? exports.child2TS(list[0]) :
            WML + ".box(" + list.map(function (l) { return exports.child2TS(l); }).join(',') + ") ";
};
/**
 * child2TS converts children to typescript.
 */
exports.child2TS = function (n) {
    if ((n instanceof nodes.Node) || (n instanceof nodes.Widget))
        return exports.tag2TS(n);
    else if (n instanceof nodes.Interpolation)
        return WML + ".domify(" + exports.interpolation2TS(n) + ") ";
    else if (n instanceof nodes.IfStatement)
        return exports.ifStatement2TS(n);
    else if (n instanceof nodes.ForStatement)
        return exports.forStatement2TS(n);
    else if (n instanceof nodes.Characters)
        return exports.characters2TS(n);
    else if (n instanceof nodes.ContextProperty)
        return exports.contextProperty2TS(n);
    else if (n instanceof nodes.QualifiedConstructor)
        return exports.qualifiedConstructor2TS(n);
    else if (n instanceof nodes.UnqualifiedConstructor)
        return exports.unqualifiedConstructor2TS(n);
    else if (n instanceof nodes.UnqualifiedIdentifier)
        return exports.unqualifiedIdentifier2TS(n);
    else if (n instanceof nodes.QualifiedIdentifier)
        return exports.qualifiedIdentifier2TS(n);
    else
        return _throwNotKnown(n);
};
/**
 * tag2TS converts a tag (node/widget) to typescript.
 */
exports.tag2TS = function (n) {
    var children = n.children.map(exports.child2TS);
    var attrs = exports.attrs2String(exports.groupAttrs(n.attributes));
    var name = exports.identifierOrConstructor2TS(n.open);
    return (n.type === 'widget') ? WML + ".widget(" + name + ", " + attrs + ", [" + children + "], " + VIEW + ")" :
        WML + ".node('" + name + "', " + attrs + ", [" + children + "], " + VIEW + ") ";
};
/**
 * attrs2String
 */
exports.attrs2String = function (attrs) { return '{' +
    (Object.keys(attrs).map(function (ns) { return ns + " : { " + attrs[ns].join(',') + " } "; })) + '}'; };
/**
 * groupAttrs groups attributes according to their namespace.
 */
exports.groupAttrs = function (ns) { return ns.reduce(function (p, c) {
    return afpl.util.merge(p, (_a = {},
        _a[c.namespace.id || 'html'] = (p[c.namespace.id || 'html'] || []).concat(exports.attribute2TS(c)),
        _a));
    var _a;
}, { html: [], wml: [] }); };
/**
 * attribute2Value
 */
exports.attribute2TS = function (n) {
    return "'" + exports.unqualifiedIdentifier2TS(n.name) + "' : " + exports.attributeValue2TS(n.value) + " ";
};
/**
 * attributeValue2TS converts an attribute value to typescript.
 */
exports.attributeValue2TS = function (n) {
    return (n instanceof nodes.Interpolation) ? exports.interpolation2TS(n) : exports.literal2TS(n);
};
/**
 * interpolation2TS converts interpolation expressions to typescript.
 */
exports.interpolation2TS = function (n) {
    return n.filters.reduce(function (p, c) { return exports.expression2TS(c) + " (" + p + ")"; }, exports.expression2TS(n.expression));
};
/**
 * forStatement2TS converts a for statement to typescript.
 */
exports.forStatement2TS = function (n) {
    return WML + ".map(" + exports.expression2TS(n.list) + ", function _map" +
        ("(" + [n.variable, n.index, n.all].filter(function (x) { return x; }).map(exports.parameter2TS).join(',') + ") ") +
        ("{ return " + exports.children2TS(n.body) + " }, ") +
        ("function otherwise() { return " + exports.children2TS(n.otherwise) + " }) ");
};
/**
 * ifStatement2TS converts an if statement to typescript.
 */
exports.ifStatement2TS = function (n) {
    return "(" + exports.expression2TS(n.condition) + ")? " +
        (exports.children2TS(n.then) + ":") +
        ("" + (n.elseClause ? else2TS(n.elseClause) : noop()));
};
var else2TS = function (n) {
    return (n instanceof nodes.ElseClause) ? exports.children2TS(n.children) :
        (n instanceof nodes.ElseIfClause) ? exports.ifStatement2TS(n) :
            _throwNotKnown(n);
};
/**
 * characters2TS converts character text to a typescript string.
 */
exports.characters2TS = function (n) { return WML + ".text(`" + n.value + "`)"; };
/**
 * expression2TS converts a wml expression to a typescript expression.
 */
exports.expression2TS = function (n) {
    if (n instanceof nodes.IfThenExpression)
        return exports.ifThenExpression2TS(n);
    else if (n instanceof nodes.BinaryExpression)
        return exports.binaryExpression2TS(n);
    else if (n instanceof nodes.UnaryExpression)
        return exports.unaryExpression2TS(n);
    else if (n instanceof nodes.ViewConstruction)
        return exports.viewConstruction2TS(n);
    else if (n instanceof nodes.FunApplication)
        return exports.funApplication2TS(n);
    else if (n instanceof nodes.ConstructExpression)
        return exports.constructExpression2TS(n);
    else if (n instanceof nodes.CallExpression)
        return exports.callExpression2TS(n);
    else if (n instanceof nodes.MemberExpression)
        return exports.memberExpression2TS(n);
    else if (n instanceof nodes.ReadExpression)
        return exports.readExpression2TS(n);
    else if (n instanceof nodes.FunctionExpression)
        return exports.functionExpression2TS(n);
    else if (n instanceof nodes.Record)
        return exports.record2TS(n);
    else if (n instanceof nodes.List)
        return exports.list2TS(n);
    else if (n instanceof nodes.BooleanLiteral)
        return exports.boolean2TS(n);
    else if (n instanceof nodes.NumberLiteral)
        return exports.number2TS(n);
    else if (n instanceof nodes.StringLiteral)
        return exports.string2TS(n);
    else if (n instanceof nodes.ContextProperty)
        return exports.contextProperty2TS(n);
    else if (n instanceof nodes.QualifiedConstructor)
        return exports.qualifiedConstructor2TS(n);
    else if (n instanceof nodes.UnqualifiedConstructor)
        return exports.unqualifiedConstructor2TS(n);
    else if (n instanceof nodes.UnqualifiedIdentifier)
        return exports.unqualifiedIdentifier2TS(n);
    else if (n instanceof nodes.QualifiedIdentifier)
        return exports.qualifiedIdentifier2TS(n);
    else if (n instanceof nodes.ContextVariable)
        return exports.contextVariable2TS(n);
    else
        _throwNotKnown(n);
};
/**
 * ifThenExpression2TS converts an if-then-else expression to typescript.
 */
exports.ifThenExpression2TS = function (n) {
    return "(" + exports.expression2TS(n.condition) + ") ? " + exports.expression2TS(n.iftrue) + " : " + exports.expression2TS(n.iffalse) + " ";
};
/**
 * binaryExpression2TS converts a binary expression to typescript.
 */
exports.binaryExpression2TS = function (n) {
    return "(" + exports.expression2TS(n.left) + " " + exports.convertOperator(n.operator) + " " + exports.expression2TS(n.right) + ") ";
};
/**
 * convertOperator for strictness.
 */
exports.convertOperator = function (op) {
    return (op === '==') ? '===' :
        (op === '!=') ? '!==' :
            op;
};
/**
 * unaryExpression2TS converts a unary expression to typescript.
 */
exports.unaryExpression2TS = function (n) {
    return n.operator + " (" + exports.expression2TS(n.expression) + ")";
};
/**
 * viewConstruction2TS convers a view construction to typescript.
 */
exports.viewConstruction2TS = function (n) {
    return "(new " + exports.constructor2TS(n.cons) + "(" + exports.args2TS(n.context) + ")).render()";
};
var _applyFun = function (context) {
    return (context.length > 0 ? "(" + exports.args2TS(context) + ")" : '') + ("(" + VIEW + ")");
};
/**
 * funApplication2TS converts a fun application to typescript.
 */
exports.funApplication2TS = function (n) {
    return exports.expression2TS(n.target) + " " + exports.typeArgs2TS(n.typeArgs) + " " +
        ("(" + exports.args2TS(n.args) + ")" + _applyFun(n.context));
};
/**
 * constructExpression2TS converts a construct expression to a typescript new expression.
 */
exports.constructExpression2TS = function (n) {
    return "new " + exports.constructor2TS(n.cons) + " (" + exports.args2TS(n.args) + ")";
};
/**
 * callExpression2TS converts a call expression (apply) to a typescript invocation.
 */
exports.callExpression2TS = function (n) {
    return exports.expression2TS(n.target) + " " + exports.typeArgs2TS(n.typeArgs) + " (" + exports.args2TS(n.args) + ")";
};
/**
 * typeArgs2TS converts passed type arguments to typescript
 */
exports.typeArgs2TS = function (ns) {
    return ns.length === 0 ? '' : "< " + ns.map(exports.type2TS).join(',') + ">";
};
/**
 * args2TS converts a list of arguments to a typescript argument tupple.
 */
exports.args2TS = function (ns) {
    return (ns.length === 0) ? '' : ns.map(exports.expression2TS).join(',');
};
/**
 * memberExpression2TS converts a member expression into a typescript member expression.
 */
exports.memberExpression2TS = function (n) {
    return exports.expression2TS(n.target) + "." + exports.identifier2TS(n.member) + " ";
};
/**
 * readExpression2TS converts a read expression to side effect full property look up.
 *
 * NOTE: this part of the language is most likely to change.
 */
exports.readExpression2TS = function (n) {
    return WML + ".read < " + exports.type2TS(n.hint) + ">(" + exports.expression2TS(n.path) + ", " + exports.expression2TS(n.target) + " " +
        ((n.defaults ? ',' + exports.expression2TS(n.defaults) : '') + ")");
};
/**
 * functionExpression2TS converts a function expression to a typescript function expression.
 */
exports.functionExpression2TS = function (n) {
    return "(" + n.parameters.map(exports.parameter2TS).join(',') + ")=>" +
        ("" + exports.expression2TS(n.body));
};
/**
 * literal2TS converts literals.
 */
exports.literal2TS = function (n) {
    return (n instanceof nodes.BooleanLiteral) ? exports.boolean2TS(n) :
        (n instanceof nodes.StringLiteral) ? exports.string2TS(n) :
            (n instanceof nodes.NumberLiteral) ? exports.number2TS(n) :
                (n instanceof nodes.Record) ? exports.record2TS(n) :
                    (n instanceof nodes.List) ? exports.list2TS(n) :
                        _throwNotKnown(n);
};
/**
 * boolean2TS converts a boolean literal to a typescript boolean literal.
 */
exports.boolean2TS = function (n) { return n.value + " "; };
/**
 * string2TS converts a string literal to a typescript string literal.
 */
exports.string2TS = function (n) { return "`" + n.value + "`"; };
/**
 * number2TS converts a number literal to a typecript number literal.
 */
exports.number2TS = function (n) { return "" + parseFloat(n.value); };
/**
 * record2TS converts a record to a typescript object literal.
 */
exports.record2TS = function (n) {
    return "{" + n.properties.map(exports.property2TS).join(',') + "}";
};
/**
 * list2TS converts a list to a typescript array literal.
 */
exports.list2TS = function (n) {
    return "[" + n.members.map(exports.expression2TS).join(',') + "]";
};
/**
 * property2TS converts a property of a a record to typescript.
 */
exports.property2TS = function (n) {
    return "'" + exports.key2TS(n.key) + "' : " + exports.expression2TS(n.value);
};
/**
 * key2TS converts a single key on a record.
 */
exports.key2TS = function (n) {
    return (n instanceof nodes.StringLiteral) ? exports.string2TS(n) : exports.identifier2TS(n);
};
/**
 * contextProperty2TS turns property access on the context to regular TS
 * property access.
 */
exports.contextProperty2TS = function (n) {
    return CONTEXT + "." + exports.identifier2TS(n.member);
};
/**
 * contextVariable2TS turns the context variable into the context identifier.
 */
exports.contextVariable2TS = function (_) { return "" + CONTEXT; };
/**
 * identifierOrConstructor2TS
 */
exports.identifierOrConstructor2TS = function (n) {
    if ((n instanceof nodes.UnqualifiedIdentifier) ||
        (n instanceof nodes.QualifiedIdentifier))
        return exports.identifier2TS(n);
    else if ((n instanceof nodes.UnqualifiedConstructor) ||
        (n instanceof nodes.QualifiedConstructor))
        return exports.constructor2TS(n);
    else
        return _throwNotKnown(n);
};
/**
 * constructor2TS turns a constructor to a typescript identifier.
 *
 * Remember constructors are proper cased.
 */
exports.constructor2TS = function (n) {
    return (n instanceof nodes.QualifiedConstructor) ? exports.qualifiedConstructor2TS(n) :
        (n instanceof nodes.UnqualifiedConstructor) ? exports.unqualifiedConstructor2TS(n) :
            _throwNotKnown(n);
};
/**
 * unqualifiedConstructor2TS converts an unqualified constructor to typescript
 */
exports.unqualifiedConstructor2TS = function (n) { return "" + n.id; };
/**
 * qualifiedConstructor converts a qualified constructor to typescript.
 */
exports.qualifiedConstructor2TS = function (n) {
    return n.qualifier + "." + n.member;
};
/**
 * identifier2TS turns an identifier to a typescript identifier.
 */
exports.identifier2TS = function (n) {
    return (n instanceof nodes.QualifiedIdentifier) ? exports.qualifiedIdentifier2TS(n) :
        (n instanceof nodes.UnqualifiedIdentifier) ? exports.unqualifiedIdentifier2TS(n) :
            _throwNotKnown(n);
};
/**
 * qualifiedIdentifier2TS converts a qualified identifier to typescript
 */
exports.qualifiedIdentifier2TS = function (n) {
    return n.qualifier + "." + n.member;
};
/**
 * unqualifiedIdentifier2TS converts an unqualified identifier to typescript
 */
exports.unqualifiedIdentifier2TS = function (n) { return "" + n.id; };

},{"./AST":158,"afpl":164}],162:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var property = require("property-seek");
var Maybe_1 = require("afpl/lib/monad/Maybe");
var Compiler_1 = require("./Compiler");
exports.parse = Compiler_1.parse;
exports.compile = Compiler_1.compile;
;
/**
 * Component is an abstract Widget implementation
 * that can be used instead of manually implementing the whole interface.
 *
 */
var Component = /** @class */ (function () {
    /**
     * attrs is the attributes this Component excepts.
     */
    /**
     * children is an array of content passed to this Component.
     */
    function Component(attrs, children) {
        this.attrs = attrs;
        this.children = children;
    }
    Component.prototype.rendered = function () { };
    Component.prototype.removed = function () { };
    Component.prototype.render = function () { return this.view.render(); };
    return Component;
}());
exports.Component = Component;
;
/**
 * read a value form an object.
 *
 * This is an alternative to regular property access that will throw exceptions
 * if any of the values in the part are null.
 * @param {string} path - The path to look up on the object.
 * @param {object} o - The object
 * @param {A} [defaultValue] - This value is returned if the value is not set.
 * @private
 */
exports.read = function (path, o, defaultValue) {
    var ret = property.get(path.split(':').join('.'), o);
    return (ret != null) ? ret : defaultValue;
};
/**
 * @private
 */
var adopt = function (child, e) {
    switch (typeof child) {
        case 'string':
        case 'number':
        case 'boolean':
            e.appendChild(document.createTextNode('' + child));
        case 'object':
            e.appendChild(child);
            break;
        default:
            throw new TypeError("Can not adopt child " + child + " of type " + typeof child);
    }
};
/**
 * @private
 */
exports.box = function () {
    var content = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        content[_i] = arguments[_i];
    }
    var frag = document.createDocumentFragment();
    content.forEach(function (c) { return frag.appendChild(c); });
    return frag;
};
/**
 * @private
 */
exports.domify = function (a) {
    if (a instanceof Array) {
        return exports.box.apply(null, a.map(exports.domify));
    }
    else if ((typeof a === 'string') ||
        (typeof a === 'number') ||
        (typeof a === 'boolean')) {
        return exports.text(a);
    }
    else if (a instanceof Node) {
        return a;
    }
    else if (a == null) {
        return document.createDocumentFragment();
    }
    else {
        throw new TypeError("Can not use '" + a + "'(typeof " + typeof a + ") as Content!");
    }
};
/**
 * text creates a new TextNode.
 * @private
 */
exports.text = function (value) {
    return document.createTextNode('' + value);
};
/**
 * node is called to create a regular DOM node
 * @private
 */
exports.node = function (tag, attributes, children, view) {
    var e = document.createElement(tag);
    if (typeof attributes['html'] === 'object')
        Object.keys(attributes['html']).forEach(function (key) {
            var value = attributes['html'][key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, "" + value);
            }
        });
    children.forEach(function (c) { return adopt(c, e); });
    var id = attributes['wml'].id;
    var group = attributes.wml.group;
    if (id)
        view.registerById(id, e);
    if (group)
        view.registerByGroup(group, e);
    return e;
};
/**
 * widget creates and renders a new wml widget instance.
 * @param {function} Construtor
 * @param {object} attributes
 * @param {array<string|number|Widget>} children
 * @param {View} view
 * @private
 * @return {Widget}
 */
exports.widget = function (Constructor, attributes, children, view) {
    var childs = [];
    var w;
    children.forEach(function (child) { return (child instanceof Array) ?
        childs.push.apply(childs, child) : childs.push(child); });
    w = new Constructor(attributes, childs);
    var id = attributes.wml.id;
    var group = attributes.wml.group;
    if (id)
        view.registerById(id, w);
    if (group)
        view.registerByGroup(group, w);
    view.registerWidget(w);
    return w.render();
};
/**
 * ifthen provides an if then expression
 * @private
 */
exports.ifthen = function (predicate, positive, negative) {
    return (predicate) ? positive() : negative();
};
/**
 * forE provides a for expression
 * @private
 */
exports.map = function (collection, cb, cb2) {
    var frag = document.createDocumentFragment();
    if (collection instanceof Array) {
        if (collection.length > 0)
            collection.forEach(function (v, k, a) { return frag.appendChild(cb(v, k, a)); });
        else
            frag.appendChild(cb2());
    }
    else if (typeof collection === 'object') {
        var l = Object.keys(collection);
        if (l.length > 0)
            l.forEach(function (k) { return frag.appendChild(cb(collection[k], k, collection)); });
        else
            frag.appendChild(cb2());
    }
    return frag;
};
/**
 * AppView is the concrete implementation of a View.
 *
 * @property {<C>} context - The context the view is rendered in.
 */
var AppView = /** @class */ (function () {
    function AppView(context) {
        this.context = context;
        this.ids = {};
        this.groups = {};
        this.widgets = [];
    }
    AppView.prototype.registerWidget = function (w) {
        this.widgets.push(w);
        return this;
    };
    AppView.prototype.registerById = function (id, w) {
        if (this.ids.hasOwnProperty(id))
            throw new Error("Duplicate id '" + id + "' detected!");
        this.ids[id] = w;
        return this;
    };
    AppView.prototype.registerByGroup = function (group, e) {
        this.groups[group] = this.groups[group] || [];
        this.groups[group].push(e);
        return this;
    };
    AppView.prototype.findById = function (id) {
        return Maybe_1.Maybe
            .fromAny(this.ids[id])
            .orElse(function () {
            console.warn("The id '" + id + "' is missing!");
            return Maybe_1.Maybe.nothing();
        });
    };
    AppView.prototype.findGroupByName = function (name) {
        return Maybe_1.Maybe.fromArray(this.groups.hasOwnProperty(name) ? this.groups[name] : []);
    };
    AppView.prototype.invalidate = function () {
        var childs;
        var realFirstChild;
        var realFirstChildIndex;
        var tree = (this._fragRoot) ? this._fragRoot : this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            throw new ReferenceError('Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new ReferenceError('Attempt to invalidate a view that has not been inserted to DOM!');
        childs = tree.parentNode.children;
        //for some reason the reference stored does not have the correct parent node.
        //we do this to get a 'live' version of the node.
        for (var i = 0; i < childs.length; i++)
            if (childs[i] === tree) {
                realFirstChild = childs[i];
                realFirstChildIndex = i;
            }
        parent.replaceChild(this.render(), realFirstChild);
    };
    AppView.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this._fragRoot = null;
        this.tree = this.template(this.context, this);
        this.ids['root'] = (this.ids['root']) ? this.ids['root'] : this.tree;
        if (this.tree.nodeName === (document.createDocumentFragment()).nodeName)
            this._fragRoot = this.tree.firstChild;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return AppView;
}());
exports.AppView = AppView;

},{"./Compiler":159,"afpl/lib/monad/Maybe":169,"property-seek":177}],163:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.f1 = function (f) { return f; };
exports.f2 = function (f) { return function (a) { return function (b) { return f(a, b); }; }; };
exports.f3 = function (f) {
    return function (a) { return function (b) { return function (c) { return f(a, b, c); }; }; };
};
exports.f4 = function (f) {
    return function (a) { return function (b) { return function (c) { return function (d) { return f(a, b, c, d); }; }; }; };
};
exports.f5 = function (f) {
    return function (a) { return function (b) { return function (c) { return function (d) { return function (e) { return f(a, b, c, d, e); }; }; }; }; };
};
exports.f6 = function (f) {
    return function (a) { return function (b) { return function (c) { return function (d) { return function (e) { return function (_f) { return f(a, b, c, d, e, _f); }; }; }; }; }; };
};

},{}],164:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("./util");
exports.util = util;
var curry = require("./curry");
exports.curry = curry;
var Identity_1 = require("./monad/Identity");
exports.Identity = Identity_1.Identity;
var Maybe_1 = require("./monad/Maybe");
exports.Maybe = Maybe_1.Maybe;
var Either_1 = require("./monad/Either");
exports.Either = Either_1.Either;
var State_1 = require("./monad/State");
exports.State = State_1.State;
var Free_1 = require("./monad/Free");
exports.Free = Free_1.Free;
var IO_1 = require("./monad/IO");
exports.IO = IO_1.IO;

},{"./curry":163,"./monad/Either":165,"./monad/Free":166,"./monad/IO":167,"./monad/Identity":168,"./monad/Maybe":169,"./monad/State":170,"./util":171}],165:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * left wraps a value on the left side.
 */
exports.left = function (a) { return new Left(a); };
/**
 * right wraps a value on the right side.
 */
exports.right = function (b) { return new Right(b); };
/**
 * fromBoolean constructs an Either using a boolean value.
 */
exports.fromBoolean = function (b) {
    return b ? exports.right(true) : exports.left(false);
};
/**
 * Either monad implementation
 */
var Either = (function () {
    function Either() {
    }
    Either.prototype.of = function (v) {
        return new Right(v);
    };
    Either.left = exports.left;
    Either.right = exports.right;
    Either.fromBoolean = exports.fromBoolean;
    return Either;
}());
exports.Either = Either;
var Left = (function (_super) {
    __extends(Left, _super);
    function Left(l) {
        var _this = _super.call(this) || this;
        _this.l = l;
        return _this;
    }
    Left.prototype.map = function (_) {
        return new Left(this.l);
    };
    Left.prototype.mapLeft = function (f) {
        return new Left(f(this.l));
    };
    Left.prototype.bimap = function (f, _) {
        return exports.left(f(this.l));
    };
    Left.prototype.chain = function (_) {
        return new Left(this.l);
    };
    Left.prototype.orElse = function (f) {
        return f(this.l);
    };
    Left.prototype.orRight = function (f) {
        return new Right(f(this.l));
    };
    Left.prototype.ap = function (_) {
        return new Left(this.l);
    };
    Left.prototype.takeLeft = function () {
        return this.l;
    };
    Left.prototype.takeRight = function () {
        throw new TypeError("Not right!");
    };
    Left.prototype.cata = function (f, _) {
        return f(this.l);
    };
    return Left;
}(Either));
exports.Left = Left;
var Right = (function (_super) {
    __extends(Right, _super);
    function Right(r) {
        var _this = _super.call(this) || this;
        _this.r = r;
        return _this;
    }
    Right.prototype.map = function (f) {
        return new Right(f(this.r));
    };
    Right.prototype.mapLeft = function (_) {
        return new Right(this.r);
    };
    Right.prototype.bimap = function (_, g) {
        return exports.right(g(this.r));
    };
    Right.prototype.chain = function (f) {
        return f(this.r);
    };
    /**
     * orElse returns the result of f if the Either is left.
     */
    Right.prototype.orElse = function (_) {
        return this;
    };
    Right.prototype.orRight = function (_) {
        return this;
    };
    /**
     * ap
     */
    Right.prototype.ap = function (e) {
        var _this = this;
        return e.map(function (f) { return f(_this.r); });
    };
    /**
      * takeLeft extracts the left value of an Either, throwing an error if the Either is right.
      */
    Right.prototype.takeLeft = function () {
        throw new TypeError("Not left!");
    };
    Right.prototype.takeRight = function () {
        return this.r;
    };
    /**
     * cata
     */
    Right.prototype.cata = function (_, g) {
        return g(this.r);
    };
    return Right;
}(Either));
exports.Right = Right;

},{}],166:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var Either_1 = require("./Either");
/**
 * free wraps a value in a free
 */
exports.free = function (a) { return new Return(a); };
/**
 * suspend lifts a function into a Free monad to mimic tail call recursion.
 */
exports.suspend = function (f) { return new Suspend(util_1.compose(exports.free, f)); };
/**
 * liftF lifts a Functor into a Free.
 */
exports.liftF = function (f) { return new Suspend(f.map(exports.free)); };
/**
 * Free is a Free monad that also implements a Free Applicative (almost).
 *
 * Inspired by https://cwmyers.github.io/monet.js/#free
 */
var Free = (function () {
    function Free() {
    }
    /**
     * of
     */
    Free.prototype.of = function (a) {
        return new Return(a);
    };
    /**
     * map
     */
    Free.prototype.map = function (f) {
        return this.chain(function (a) { return exports.free(f(a)); });
    };
    /**
     * chain
     */
    Free.prototype.chain = function (g) {
        if (this instanceof Suspend) {
            var f_1 = this.f;
            return (typeof f_1 === 'function') ?
                new Suspend(function (x) { return f_1(x).chain(g); }) :
                new Suspend(f_1.map(function (free) { return free.chain(g); }));
        }
        else if (this instanceof Return) {
            g(this.a);
        }
    };
    /**
     * resume the next stage of the computation
     */
    Free.prototype.resume = function () {
        if (this instanceof Suspend) {
            return Either_1.left(this.f);
        }
        else if (this instanceof Return) {
            return Either_1.right(this.a);
        }
    };
    /**
     * hoist
    hoist<B>(func: (fb: Functor<B>) => Functor<B>): Free<F, A> {

        if (this instanceof Suspend) {

            return new Suspend((func(this.f))
                .map((fr: Free<F, B>) => fr.hoist<any>(func)))
        } else {

            return this;

        }

    }
    */
    /**
     * cata
     */
    Free.prototype.cata = function (f, g) {
        return this.resume().cata(f, g);
    };
    /**
     * go runs the computation to completion using f to extract each stage.
     * @summmary go :: Free<F<*>, A> →  (F<Free<F,A>> →  Free<F,A>) →  A
     */
    Free.prototype.go = function (f) {
        if (this instanceof Suspend) {
            var r = this.resume();
            while (r instanceof Either_1.Left)
                r = (f(r.takeLeft())).resume();
            return r.takeRight();
        }
        else if (this instanceof Return) {
            return this.a;
        }
    };
    /**
     * run the Free chain to completion
     * @summary run :: Free<A→ A,A> →  A
     */
    Free.prototype.run = function () {
        return this.go(function (next) { return next(); });
    };
    Free.free = exports.free;
    Free.suspend = exports.suspend;
    Free.liftF = exports.liftF;
    return Free;
}());
exports.Free = Free;
var Suspend = (function (_super) {
    __extends(Suspend, _super);
    function Suspend(f) {
        var _this = _super.call(this) || this;
        _this.f = f;
        return _this;
    }
    return Suspend;
}(Free));
exports.Suspend = Suspend;
var Return = (function (_super) {
    __extends(Return, _super);
    function Return(a) {
        var _this = _super.call(this) || this;
        _this.a = a;
        return _this;
    }
    return Return;
}(Free));
exports.Return = Return;

},{"../util":171,"./Either":165}],167:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * wrapIO a value in the IO monad
 */
exports.wrapIO = function (a) { return new IO(function () { return a; }); };
/**
 * safeIO accepts a function that has side effects and wrapIOs it in an IO Monad.
 */
exports.safeIO = function (f) { return new IO(f); };
exports.pure = exports.wrapIO;
exports.suspend = exports.safeIO;
/**
 * IO monadic type for containing interactions with the 'real world'.
 */
var IO = (function () {
    function IO(effect) {
        this.effect = effect;
    }
    IO.prototype.of = function (v) {
        return new IO(function () { return v; });
    };
    IO.prototype.map = function (f) {
        var _this = this;
        return new IO(function () { return f(_this.effect()); });
    };
    IO.prototype.mapIn = function (b) {
        return this.map(function () { return b; });
    };
    /**
     * chain
     */
    IO.prototype.chain = function (f) {
        var _this = this;
        return new IO(function () { return f(_this.effect()).run(); });
    };
    IO.prototype.chainIn = function (b) {
        return this.chain(function () { return exports.wrapIO(b); });
    };
    /**
     * run
     */
    IO.prototype.run = function () {
        return this.effect();
    };
    IO.safeIO = exports.safeIO;
    IO.pure = exports.pure;
    IO.suspend = exports.suspend;
    IO.chain = function (f) { return function (m) { return m.chain(f); }; };
    return IO;
}());
exports.IO = IO;

},{}],168:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Identity
 */
var Identity = (function () {
    function Identity(a) {
        this.a = a;
    }
    /**
     * of
     */
    Identity.prototype.of = function (a) {
        return new Identity(a);
    };
    /**
     * map
     */
    Identity.prototype.map = function (f) {
        return new Identity(f(this.get()));
    };
    /**
     * chain
     */
    Identity.prototype.chain = function (f) {
        return f(this.get());
    };
    /**
     * ap
     */
    Identity.prototype.ap = function (i) {
        var _this = this;
        return i.map(function (f) { return f(_this.get()); });
    };
    /**
     * get the value of an Identity
     * @summary get :: Identity<A> →  A
     */
    Identity.prototype.get = function () {
        return this.a;
    };
    return Identity;
}());
exports.Identity = Identity;

},{}],169:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Either_1 = require("./Either");
/**
 * just wraps a value in a Just
 */
exports.just = function (a) { return new Just(a); };
;
/**
 * nothing constructs nothing
 */
exports.nothing = function () { return new Nothing(); };
/**
 * fromAny constructs a Maybe from a value that may be null.
 */
exports.fromAny = function (a) { return a == null ? exports.nothing() : exports.just(a); };
/**
 * fromArray checks an array to see if it's empty (or full of nulls)
 * and returns a Maybe.
 */
exports.fromArray = function (a) {
    return ((a.length === 0) || (a.reduce(function (c, v) { return (v == null) ? c + 1 : c; }, 0) === a.length)) ?
        exports.nothing() : exports.just(a);
};
/**
 * fromOBject uses Object.keys to turn see if an object has any own properties.
 */
exports.fromObject = function (o) {
    return Object.keys(o).length === 0 ? exports.nothing() : exports.just(o);
};
/**
 * fromString constructs nothing if the string is empty or just otherwise.
 */
exports.fromString = function (s) {
    return (s === '') ? exports.nothing() : exports.just(s);
};
/**
 * fromBoolean constructs nothing if b is false, just otherwise
 */
exports.fromBoolean = function (b) {
    return (b === false) ? exports.nothing() : exports.just(b);
};
/**
 * fromNumber constructs nothing if n is 0 just otherwise.
 */
exports.fromNumber = function (n) {
    return (n === 0) ? exports.nothing() : exports.just(n);
};
/**
 * Maybe
 */
var Maybe = (function () {
    function Maybe() {
    }
    Maybe.prototype.of = function (a) {
        return new Just(a);
    };
    Maybe.just = exports.just;
    Maybe.nothing = exports.nothing;
    Maybe.fromAny = exports.fromAny;
    Maybe.fromObject = exports.fromObject;
    Maybe.fromArray = exports.fromArray;
    Maybe.fromString = exports.fromString;
    Maybe.fromBoolean = exports.fromBoolean;
    Maybe.fromNumber = exports.fromNumber;
    return Maybe;
}());
exports.Maybe = Maybe;
/**
 * Nothing
 */
var Nothing = (function (_super) {
    __extends(Nothing, _super);
    function Nothing() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Nothing.prototype.map = function (_) {
        return new Nothing();
    };
    Nothing.prototype.chain = function (_) {
        return new Nothing();
    };
    Nothing.prototype.get = function () {
        throw new TypeError('Cannot get anything from Nothing!');
    };
    Nothing.prototype.orElse = function (f) {
        return f();
    };
    /**
     * orJust will turn Nothing into Just, wrapping the value specified.
     */
    Nothing.prototype.orJust = function (f) {
        return exports.just(f());
    };
    /**
     * cata applies the corresponding function to the Maybe
     */
    Nothing.prototype.cata = function (f, _g) {
        return f();
    };
    Nothing.prototype.toEither = function () {
        return Either_1.left(undefined);
    };
    return Nothing;
}(Maybe));
exports.Nothing = Nothing;
/**
 * Just
 */
var Just = (function (_super) {
    __extends(Just, _super);
    function Just(a) {
        var _this = _super.call(this) || this;
        _this.a = a;
        return _this;
    }
    Just.prototype.map = function (f) {
        return new Just(f(this.a));
    };
    Just.prototype.join = function () {
        return this.a;
    };
    Just.prototype.chain = function (f) {
        return f(this.a);
    };
    Just.prototype.get = function () {
        return this.a;
    };
    Just.prototype.orElse = function (_f) {
        return this;
    };
    Just.prototype.orJust = function (_f) {
        return this;
    };
    Just.prototype.cata = function (_f, g) {
        return g(this.a);
    };
    Just.prototype.toEither = function () {
        return Either_1.right(this.a);
    };
    return Just;
}(Maybe));
exports.Just = Just;

},{"./Either":165}],170:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * get the state from the internals of the monad
 */
exports.get = function () { return new State(function (s) { return ([s, s]); }); };
/**
 * put
 */
exports.put = function (s) { return new State(function () { return ([null, s]); }); };
/**
 * modify the state
 * @summary  (S →  S) →  State<S →  {A, S} >
 */
exports.modify = function (f) { return exports.get().chain(function (s) { return exports.put(f(s)); }); };
/**
 * gets applies a function to the state putting using the result
 * as the result of the computation.
 * @summary (S →  A) →  State<S →  {A, S}>
 */
exports.gets = function (f) { return exports.get().chain(function (s) { return exports.state(f(s)); }); };
/**
 * state create a new State monad
 */
exports.state = function (a) { return new State(function (s) { return ([a, s]); }); };
/**
 * State is a monadic class that we use to hold information that changes
 * during computation.
 *
 * This implementation is influenced by:
 * @link https://en.wikipedia.org/wiki/Monad_(functional_programming)#State_monads
 * @property {s →  (a, s)} a
 */
var State = (function () {
    function State(f) {
        this.f = f;
    }
    /**
     * of wraps a value in the State monad.
     * @summary A →  State<S→ {A,S}>
     */
    State.prototype.of = function (a) {
        return new State(function (s) { return ([a, s]); });
    };
    /**
     * map
     * @summary State<S → {A,S}> →  (A →  B) →  State<S →  {C, S}>
     */
    State.prototype.map = function (f) {
        var _this = this;
        return new State(function (xs) {
            var _a = _this.run(xs), a = _a[0], s = _a[1];
            return [f(a), s];
        });
    };
    /**
     * join replaces the outer State with an inner State
     */
    State.prototype.join = function () {
        var _this = this;
        return new State(function (xs) {
            var _a = _this.run(xs), a = _a[0], s = _a[1];
            return a.run(s);
        });
    };
    /**
     * chain
     */
    State.prototype.chain = function (f) {
        return this.map(f).join();
    };
    /**
     * evaluate the State returning the final value
     */
    State.prototype.evaluate = function (s) {
        return this.run(s)[0];
    };
    /**
     * execute the State returning the final state.
     */
    State.prototype.execute = function (s) {
        return this.run(s)[1];
    };
    /**
     * run the State yielding the final value and state.
     * @summary State<S→ {A<S}> →  S →  {A,S}
     */
    State.prototype.run = function (s) {
        return this.f(s);
    };
    State.get = exports.get;
    State.put = exports.put;
    State.modify = exports.modify;
    State.gets = exports.gets;
    State.state = exports.state;
    return State;
}());
exports.State = State;

},{}],171:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
;
/**
 * identity is the famed identity function.
 */
exports.identity = function (a) { return a; };
/**
 * merge two objects easily
 */
exports.merge = function () {
    var o = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        o[_i] = arguments[_i];
    }
    return Object.assign.apply(Object, [{}].concat(o));
};
/**
 * fuse is the deep version of merge
 */
exports.fuse = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return args.reduce(function (o, c) {
        if (c === void 0) { c = {}; }
        return exports.reduce(c, function (co, cc, k) {
            return Array.isArray(cc) ?
                (Array.isArray(co[k]) ?
                    exports.merge(co, (_a = {}, _a[k] = (co[k]).map(exports.copy).concat(cc.map(exports.copy)), _a)) :
                    exports.merge(co, (_b = {}, _b[k] = cc.map(exports.copy), _b))) :
                typeof cc !== 'object' ?
                    exports.merge(co, (_c = {}, _c[k] = cc, _c)) :
                    exports.merge(co, (_d = {},
                        _d[k] = (typeof co[k] !== 'object') ?
                            exports.merge(co[k], cc) :
                            exports.fuse(co[k], cc),
                        _d));
            var _a, _b, _c, _d;
        }, o);
    }, {});
};
exports.copy = function (o) {
    return (Array.isArray(o)) ?
        o.map(exports.copy) :
        (typeof o === 'object') ?
            exports.reduce(o, function (p, c, k) {
                return exports.merge(p, (_a = {}, _a[k] = exports.copy(c), _a));
                var _a;
            }, {}) : o;
};
/**
 * reduce an object's keys (in no guaranteed order)
 */
exports.reduce = function (o, f, accum) {
    return Object.keys(o).reduce(function (p, k) { return f(p, o[k], k, o); }, accum);
};
/**
 * map over an object (in no guaranteed oreder)
 */
exports.map = function (o, f) {
    return Object.keys(o).map((function (k) { return f(o[k], k, o); }));
};
/**
 * compose two functions into one.
 */
exports.compose = function (f, g) { return function (x) { return f(g(x)); }; };
/**
 * fling removes a key from an object
 * @param {string} key
 * @param {object} object
 * @return {Object}
 * @summary {(string,Object) →  Object}
 */
exports.fling = function (s, o) {
    if ((o == null) || (o.constructor !== Object))
        throw new TypeError('fling(): only works with object literals!');
    return Object.keys(o).reduce(function (o2, k) {
        return k === s ? o2 : exports.merge(o2, (_a = {},
            _a[k] = o[k],
            _a));
        var _a;
    }, {});
};
/**
 * head returns the item at index 0 of an array
 * @param {Array} list
 * @return {*}
 * @summary { Array →  * }
 */
exports.head = function (list) { return list[0]; };
/**
 * tail returns the last item in an array
 * @param {Array} list
 * @return {*}
 * @summary {Array →  *}
 */
exports.tail = function (list) { return list[list.length - 1]; };
/**
 * constant given a value, return a function that always returns this value.
 * @summary constant X →  * →  X
 *
 */
exports.constant = function (a) { return function () { return a; }; };
/**
 * f1 partial application.
 */
exports.f1 = function (f) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return function (a) { return f.apply(null, args.concat(a)); };
};
/**
 * f2 partial application
 */
exports.f2 = function (f) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return function (a) { return function (aa) { return f.apply(null, args.concat(a, aa)); }; };
};
/**
 * f3 partial application
 */
exports.f3 = function (f) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return function (a) { return function (aa) { return function (aaa) { return f.apply(null, args.concat(a, aa, aaa)); }; }; };
};
/**
 * f4 partial application
 */
exports.f4 = function (f) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return function (a) { return function (aa) { return function (aaa) { return function (aaaa) {
        return f.apply(null, args.concat(a, aa, aaa, aaaa));
    }; }; }; };
};
/**
 * f5 partial application
 */
exports.f5 = function (f) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return function (a) { return function (aa) { return function (aaa) { return function (aaaa) { return function (aaaaa) {
        return f.apply(null, args.concat(a, aa, aaa, aaaa, aaaaa));
    }; }; }; }; };
};
/**
 * except copies an object removing a single key.
 */
exports.except = function (keys, o) {
    return exports.reduce(o, function (p, c, k) {
        return keys.indexOf(k) > -1 ? p : exports.merge(p, (_a = {}, _a[k] = c, _a));
        var _a;
    }, {});
};

},{}],172:[function(require,module,exports){
/*
  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

*/

/**
The following batches are equivalent:

var beautify_js = require('js-beautify');
var beautify_js = require('js-beautify').js;
var beautify_js = require('js-beautify').js_beautify;

var beautify_css = require('js-beautify').css;
var beautify_css = require('js-beautify').css_beautify;

var beautify_html = require('js-beautify').html;
var beautify_html = require('js-beautify').html_beautify;

All methods returned accept two arguments, the source string and an options object.
**/

function get_beautify(js_beautify, css_beautify, html_beautify) {
    // the default is js
    var beautify = function(src, config) {
        return js_beautify.js_beautify(src, config);
    };

    // short aliases
    beautify.js = js_beautify.js_beautify;
    beautify.css = css_beautify.css_beautify;
    beautify.html = html_beautify.html_beautify;

    // legacy aliases
    beautify.js_beautify = js_beautify.js_beautify;
    beautify.css_beautify = css_beautify.css_beautify;
    beautify.html_beautify = html_beautify.html_beautify;

    return beautify;
}

if (typeof define === "function" && define.amd) {
    // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
    define([
        "./lib/beautify",
        "./lib/beautify-css",
        "./lib/beautify-html"
    ], function(js_beautify, css_beautify, html_beautify) {
        return get_beautify(js_beautify, css_beautify, html_beautify);
    });
} else {
    (function(mod) {
        var js_beautify = require('./lib/beautify');
        var css_beautify = require('./lib/beautify-css');
        var html_beautify = require('./lib/beautify-html');

        mod.exports = get_beautify(js_beautify, css_beautify, html_beautify);

    })(module);
}
},{"./lib/beautify":175,"./lib/beautify-css":173,"./lib/beautify-html":174}],173:[function(require,module,exports){
(function (global){
/*jshint curly:false, eqeqeq:true, laxbreak:true, noempty:false */
/* AUTO-GENERATED. DO NOT MODIFY. */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.


 CSS Beautifier
---------------

    Written by Harutyun Amirjanyan, (amirjanyan@gmail.com)

    Based on code initially developed by: Einar Lielmanis, <einar@jsbeautifier.org>
        http://jsbeautifier.org/

    Usage:
        css_beautify(source_text);
        css_beautify(source_text, options);

    The options are (default in brackets):
        indent_size (4)                         — indentation size,
        indent_char (space)                     — character to indent with,
        selector_separator_newline (true)       - separate selectors with newline or
                                                  not (e.g. "a,\nbr" or "a, br")
        end_with_newline (false)                - end with a newline
        newline_between_rules (true)            - add a new line after every css rule
        space_around_selector_separator (false) - ensure space around selector separators:
                                                  '>', '+', '~' (e.g. "a>b" -> "a > b")
    e.g

    css_beautify(css_source_text, {
      'indent_size': 1,
      'indent_char': '\t',
      'selector_separator': ' ',
      'end_with_newline': false,
      'newline_between_rules': true,
      'space_around_selector_separator': true
    });
*/

// http://www.w3.org/TR/CSS21/syndata.html#tokenization
// http://www.w3.org/TR/css3-syntax/

(function() {
var legacy_beautify_css =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 4);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

var mergeOpts = __webpack_require__(2).mergeOpts;
var acorn = __webpack_require__(1);
var Output = __webpack_require__(3).Output;


var lineBreak = acorn.lineBreak;
var allLineBreaks = acorn.allLineBreaks;

function Beautifier(source_text, options) {
    options = options || {};

    // Allow the setting of language/file-type specific options
    // with inheritance of overall settings
    options = mergeOpts(options, 'css');

    source_text = source_text || '';

    var newlinesFromLastWSEat = 0;
    var indentSize = options.indent_size ? parseInt(options.indent_size, 10) : 4;
    var indentCharacter = options.indent_char || ' ';
    var preserve_newlines = (options.preserve_newlines === undefined) ? false : options.preserve_newlines;
    var selectorSeparatorNewline = (options.selector_separator_newline === undefined) ? true : options.selector_separator_newline;
    var end_with_newline = (options.end_with_newline === undefined) ? false : options.end_with_newline;
    var newline_between_rules = (options.newline_between_rules === undefined) ? true : options.newline_between_rules;
    var space_around_combinator = (options.space_around_combinator === undefined) ? false : options.space_around_combinator;
    space_around_combinator = space_around_combinator || ((options.space_around_selector_separator === undefined) ? false : options.space_around_selector_separator);
    var eol = options.eol ? options.eol : 'auto';

    if (options.indent_with_tabs) {
        indentCharacter = '\t';
        indentSize = 1;
    }

    if (eol === 'auto') {
        eol = '\n';
        if (source_text && lineBreak.test(source_text || '')) {
            eol = source_text.match(lineBreak)[0];
        }
    }

    eol = eol.replace(/\\r/, '\r').replace(/\\n/, '\n');

    // HACK: newline parsing inconsistent. This brute force normalizes the input.
    source_text = source_text.replace(allLineBreaks, '\n');

    // tokenizer
    var whiteRe = /^\s+$/;

    var pos = -1,
        ch;
    var parenLevel = 0;

    function next() {
        ch = source_text.charAt(++pos);
        return ch || '';
    }

    function peek(skipWhitespace) {
        var result = '';
        var prev_pos = pos;
        if (skipWhitespace) {
            eatWhitespace();
        }
        result = source_text.charAt(pos + 1) || '';
        pos = prev_pos - 1;
        next();
        return result;
    }

    function eatString(endChars) {
        var start = pos;
        while (next()) {
            if (ch === "\\") {
                next();
            } else if (endChars.indexOf(ch) !== -1) {
                break;
            } else if (ch === "\n") {
                break;
            }
        }
        return source_text.substring(start, pos + 1);
    }

    function peekString(endChar) {
        var prev_pos = pos;
        var str = eatString(endChar);
        pos = prev_pos - 1;
        next();
        return str;
    }

    function eatWhitespace(preserve_newlines_local) {
        var result = 0;
        while (whiteRe.test(peek())) {
            next();
            if (ch === '\n' && preserve_newlines_local && preserve_newlines) {
                output.add_new_line(true);
                result++;
            }
        }
        newlinesFromLastWSEat = result;
        return result;
    }

    function skipWhitespace() {
        var result = '';
        if (ch && whiteRe.test(ch)) {
            result = ch;
        }
        while (whiteRe.test(next())) {
            result += ch;
        }
        return result;
    }

    function eatComment() {
        var start = pos;
        var singleLine = peek() === "/";
        next();
        while (next()) {
            if (!singleLine && ch === "*" && peek() === "/") {
                next();
                break;
            } else if (singleLine && ch === "\n") {
                return source_text.substring(start, pos);
            }
        }

        return source_text.substring(start, pos) + ch;
    }


    function lookBack(str) {
        return source_text.substring(pos - str.length, pos).toLowerCase() ===
            str;
    }

    // Nested pseudo-class if we are insideRule
    // and the next special character found opens
    // a new block
    function foundNestedPseudoClass() {
        var openParen = 0;
        for (var i = pos + 1; i < source_text.length; i++) {
            var ch = source_text.charAt(i);
            if (ch === "{") {
                return true;
            } else if (ch === '(') {
                // pseudoclasses can contain ()
                openParen += 1;
            } else if (ch === ')') {
                if (openParen === 0) {
                    return false;
                }
                openParen -= 1;
            } else if (ch === ";" || ch === "}") {
                return false;
            }
        }
        return false;
    }

    // printer
    var baseIndentString = '';
    var preindent_index = 0;
    if (source_text && source_text.length) {
        while ((source_text.charAt(preindent_index) === ' ' ||
                source_text.charAt(preindent_index) === '\t')) {
            preindent_index += 1;
        }
        baseIndentString = source_text.substring(0, preindent_index);
        js_source_text = source_text.substring(preindent_index);
    }


    var singleIndent = new Array(indentSize + 1).join(indentCharacter);
    var indentLevel;
    var nestedLevel;
    var output;

    function print_string(output_string) {
        if (output.just_added_newline()) {
            output.set_indent(indentLevel);
        }
        output.add_token(output_string);
    }

    function preserveSingleSpace(isAfterSpace) {
        if (isAfterSpace) {
            output.space_before_token = true;
        }
    }

    function indent() {
        indentLevel++;
    }

    function outdent() {
        if (indentLevel > 0) {
            indentLevel--;
        }
    }

    /*_____________________--------------------_____________________*/

    this.beautify = function() {
        // reset
        output = new Output(singleIndent, baseIndentString);
        indentLevel = 0;
        nestedLevel = 0;

        pos = -1;
        ch = null;
        parenLevel = 0;

        var insideRule = false;
        var insidePropertyValue = false;
        var enteringConditionalGroup = false;
        var top_ch = '';
        var last_top_ch = '';

        while (true) {
            var whitespace = skipWhitespace();
            var isAfterSpace = whitespace !== '';
            var isAfterNewline = whitespace.indexOf('\n') !== -1;
            last_top_ch = top_ch;
            top_ch = ch;

            if (!ch) {
                break;
            } else if (ch === '/' && peek() === '*') { /* css comment */
                var header = indentLevel === 0;

                if (isAfterNewline || header) {
                    output.add_new_line();
                }

                print_string(eatComment());
                output.add_new_line();
                if (header) {
                    output.add_new_line(true);
                }
            } else if (ch === '/' && peek() === '/') { // single line comment
                if (!isAfterNewline && last_top_ch !== '{') {
                    output.trim(true);
                }
                output.space_before_token = true;
                print_string(eatComment());
                output.add_new_line();
            } else if (ch === '@') {
                preserveSingleSpace(isAfterSpace);

                // deal with less propery mixins @{...}
                if (peek() === '{') {
                    print_string(eatString('}'));
                } else {
                    print_string(ch);

                    // strip trailing space, if present, for hash property checks
                    var variableOrRule = peekString(": ,;{}()[]/='\"");

                    if (variableOrRule.match(/[ :]$/)) {
                        // we have a variable or pseudo-class, add it and insert one space before continuing
                        next();
                        variableOrRule = eatString(": ").replace(/\s$/, '');
                        print_string(variableOrRule);
                        output.space_before_token = true;
                    }

                    variableOrRule = variableOrRule.replace(/\s$/, '');

                    // might be a nesting at-rule
                    if (variableOrRule in this.NESTED_AT_RULE) {
                        nestedLevel += 1;
                        if (variableOrRule in this.CONDITIONAL_GROUP_RULE) {
                            enteringConditionalGroup = true;
                        }
                    }
                }
            } else if (ch === '#' && peek() === '{') {
                preserveSingleSpace(isAfterSpace);
                print_string(eatString('}'));
            } else if (ch === '{') {
                if (peek(true) === '}') {
                    eatWhitespace();
                    next();
                    output.space_before_token = true;
                    print_string("{}");
                    if (!eatWhitespace(true)) {
                        output.add_new_line();
                    }

                    if (newlinesFromLastWSEat < 2 && newline_between_rules && indentLevel === 0) {
                        output.add_new_line(true);
                    }
                } else {
                    indent();
                    output.space_before_token = true;
                    print_string(ch);
                    if (!eatWhitespace(true)) {
                        output.add_new_line();
                    }

                    // when entering conditional groups, only rulesets are allowed
                    if (enteringConditionalGroup) {
                        enteringConditionalGroup = false;
                        insideRule = (indentLevel > nestedLevel);
                    } else {
                        // otherwise, declarations are also allowed
                        insideRule = (indentLevel >= nestedLevel);
                    }
                }
            } else if (ch === '}') {
                outdent();
                output.add_new_line();
                print_string(ch);
                insideRule = false;
                insidePropertyValue = false;
                if (nestedLevel) {
                    nestedLevel--;
                }

                if (!eatWhitespace(true)) {
                    output.add_new_line();
                }

                if (newlinesFromLastWSEat < 2 && newline_between_rules && indentLevel === 0) {
                    output.add_new_line(true);
                }
            } else if (ch === ":") {
                eatWhitespace();
                if ((insideRule || enteringConditionalGroup) &&
                    !(lookBack("&") || foundNestedPseudoClass()) &&
                    !lookBack("(")) {
                    // 'property: value' delimiter
                    // which could be in a conditional group query
                    print_string(':');
                    if (!insidePropertyValue) {
                        insidePropertyValue = true;
                        output.space_before_token = true;
                    }
                } else {
                    // sass/less parent reference don't use a space
                    // sass nested pseudo-class don't use a space

                    // preserve space before pseudoclasses/pseudoelements, as it means "in any child"
                    if (lookBack(" ")) {
                        output.space_before_token = true;
                    }
                    if (peek() === ":") {
                        // pseudo-element
                        next();
                        print_string("::");
                    } else {
                        // pseudo-class
                        print_string(':');
                    }
                }
            } else if (ch === '"' || ch === '\'') {
                preserveSingleSpace(isAfterSpace);
                print_string(eatString(ch));
            } else if (ch === ';') {
                insidePropertyValue = false;
                print_string(ch);
                if (!eatWhitespace(true)) {
                    output.add_new_line();
                }
            } else if (ch === '(') { // may be a url
                if (lookBack("url")) {
                    print_string(ch);
                    eatWhitespace();
                    if (next()) {
                        if (ch !== ')' && ch !== '"' && ch !== '\'') {
                            print_string(eatString(')'));
                        } else {
                            pos--;
                        }
                    }
                } else {
                    parenLevel++;
                    preserveSingleSpace(isAfterSpace);
                    print_string(ch);
                    eatWhitespace();
                }
            } else if (ch === ')') {
                print_string(ch);
                parenLevel--;
            } else if (ch === ',') {
                print_string(ch);
                if (!eatWhitespace(true) && selectorSeparatorNewline && !insidePropertyValue && parenLevel < 1) {
                    output.add_new_line();
                } else {
                    output.space_before_token = true;
                }
            } else if ((ch === '>' || ch === '+' || ch === '~') &&
                !insidePropertyValue && parenLevel < 1) {
                //handle combinator spacing
                if (space_around_combinator) {
                    output.space_before_token = true;
                    print_string(ch);
                    output.space_before_token = true;
                } else {
                    print_string(ch);
                    eatWhitespace();
                    // squash extra whitespace
                    if (ch && whiteRe.test(ch)) {
                        ch = '';
                    }
                }
            } else if (ch === ']') {
                print_string(ch);
            } else if (ch === '[') {
                preserveSingleSpace(isAfterSpace);
                print_string(ch);
            } else if (ch === '=') { // no whitespace before or after
                eatWhitespace();
                print_string('=');
                if (whiteRe.test(ch)) {
                    ch = '';
                }

            } else {
                preserveSingleSpace(isAfterSpace);
                print_string(ch);
            }
        }

        var sweetCode = output.get_code(end_with_newline, eol);

        return sweetCode;
    };

    // https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule
    this.NESTED_AT_RULE = {
        "@page": true,
        "@font-face": true,
        "@keyframes": true,
        // also in CONDITIONAL_GROUP_RULE below
        "@media": true,
        "@supports": true,
        "@document": true
    };
    this.CONDITIONAL_GROUP_RULE = {
        "@media": true,
        "@supports": true,
        "@document": true
    };
}

module.exports.Beautifier = Beautifier;


/***/ }),
/* 1 */
/***/ (function(module, exports) {

/* jshint curly: false */
// This section of code is taken from acorn.
//
// Acorn was written by Marijn Haverbeke and released under an MIT
// license. The Unicode regexps (for identifiers and whitespace) were
// taken from [Esprima](http://esprima.org) by Ariya Hidayat.
//
// Git repositories for Acorn are available at
//
//     http://marijnhaverbeke.nl/git/acorn
//     https://github.com/marijnh/acorn.git

// ## Character categories

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.

var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/; // jshint ignore:line
var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
var nonASCIIidentifierChars = "\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

// Whether a single character denotes a newline.

exports.newline = /[\n\r\u2028\u2029]/;

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

// in javascript, these two differ
// in python they are the same, different methods are called on them
exports.lineBreak = new RegExp('\r\n|' + exports.newline.source);
exports.allLineBreaks = new RegExp(exports.lineBreak.source, 'g');


// Test whether a given character code starts an identifier.

exports.isIdentifierStart = function(code) {
    // permit $ (36) and @ (64). @ is used in ES7 decorators.
    if (code < 65) return code === 36 || code === 64;
    // 65 through 91 are uppercase letters.
    if (code < 91) return true;
    // permit _ (95).
    if (code < 97) return code === 95;
    // 97 through 123 are lowercase letters.
    if (code < 123) return true;
    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
};

// Test whether a given character is part of an identifier.

exports.isIdentifierChar = function(code) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code < 91) return true;
    if (code < 97) return code === 95;
    if (code < 123) return true;
    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
};


/***/ }),
/* 2 */
/***/ (function(module, exports) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

    The MIT License (MIT)

    Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

function mergeOpts(allOptions, targetType) {
    var finalOpts = {};
    var name;

    for (name in allOptions) {
        if (name !== targetType) {
            finalOpts[name] = allOptions[name];
        }
    }

    //merge in the per type settings for the targetType
    if (targetType in allOptions) {
        for (name in allOptions[targetType]) {
            finalOpts[name] = allOptions[targetType][name];
        }
    }
    return finalOpts;
}

module.exports.mergeOpts = mergeOpts;


/***/ }),
/* 3 */
/***/ (function(module, exports) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

function OutputLine(parent) {
    var _character_count = 0;
    // use indent_count as a marker for lines that have preserved indentation
    var _indent_count = -1;

    var _items = [];
    var _empty = true;

    this.set_indent = function(level) {
        _character_count = parent.baseIndentLength + level * parent.indent_length;
        _indent_count = level;
    };

    this.get_character_count = function() {
        return _character_count;
    };

    this.is_empty = function() {
        return _empty;
    };

    this.last = function() {
        if (!this._empty) {
            return _items[_items.length - 1];
        } else {
            return null;
        }
    };

    this.push = function(input) {
        _items.push(input);
        _character_count += input.length;
        _empty = false;
    };

    this.pop = function() {
        var item = null;
        if (!_empty) {
            item = _items.pop();
            _character_count -= item.length;
            _empty = _items.length === 0;
        }
        return item;
    };

    this.remove_indent = function() {
        if (_indent_count > 0) {
            _indent_count -= 1;
            _character_count -= parent.indent_length;
        }
    };

    this.trim = function() {
        while (this.last() === ' ') {
            _items.pop();
            _character_count -= 1;
        }
        _empty = _items.length === 0;
    };

    this.toString = function() {
        var result = '';
        if (!this._empty) {
            if (_indent_count >= 0) {
                result = parent.indent_cache[_indent_count];
            }
            result += _items.join('');
        }
        return result;
    };
}

function Output(indent_string, baseIndentString) {
    baseIndentString = baseIndentString || '';
    this.indent_cache = [baseIndentString];
    this.baseIndentLength = baseIndentString.length;
    this.indent_length = indent_string.length;
    this.raw = false;

    var lines = [];
    this.baseIndentString = baseIndentString;
    this.indent_string = indent_string;
    this.previous_line = null;
    this.current_line = null;
    this.space_before_token = false;

    this.add_outputline = function() {
        this.previous_line = this.current_line;
        this.current_line = new OutputLine(this);
        lines.push(this.current_line);
    };

    // initialize
    this.add_outputline();


    this.get_line_number = function() {
        return lines.length;
    };

    // Using object instead of string to allow for later expansion of info about each line
    this.add_new_line = function(force_newline) {
        if (this.get_line_number() === 1 && this.just_added_newline()) {
            return false; // no newline on start of file
        }

        if (force_newline || !this.just_added_newline()) {
            if (!this.raw) {
                this.add_outputline();
            }
            return true;
        }

        return false;
    };

    this.get_code = function(end_with_newline, eol) {
        var sweet_code = lines.join('\n').replace(/[\r\n\t ]+$/, '');

        if (end_with_newline) {
            sweet_code += '\n';
        }

        if (eol !== '\n') {
            sweet_code = sweet_code.replace(/[\n]/g, eol);
        }

        return sweet_code;
    };

    this.set_indent = function(level) {
        // Never indent your first output indent at the start of the file
        if (lines.length > 1) {
            while (level >= this.indent_cache.length) {
                this.indent_cache.push(this.indent_cache[this.indent_cache.length - 1] + this.indent_string);
            }

            this.current_line.set_indent(level);
            return true;
        }
        this.current_line.set_indent(0);
        return false;
    };

    this.add_raw_token = function(token) {
        for (var x = 0; x < token.newlines; x++) {
            this.add_outputline();
        }
        this.current_line.push(token.whitespace_before);
        this.current_line.push(token.text);
        this.space_before_token = false;
    };

    this.add_token = function(printable_token) {
        this.add_space_before_token();
        this.current_line.push(printable_token);
    };

    this.add_space_before_token = function() {
        if (this.space_before_token && !this.just_added_newline()) {
            this.current_line.push(' ');
        }
        this.space_before_token = false;
    };

    this.remove_indent = function(index) {
        var output_length = lines.length;
        while (index < output_length) {
            lines[index].remove_indent();
            index++;
        }
    };

    this.trim = function(eat_newlines) {
        eat_newlines = (eat_newlines === undefined) ? false : eat_newlines;

        this.current_line.trim(indent_string, baseIndentString);

        while (eat_newlines && lines.length > 1 &&
            this.current_line.is_empty()) {
            lines.pop();
            this.current_line = lines[lines.length - 1];
            this.current_line.trim();
        }

        this.previous_line = lines.length > 1 ? lines[lines.length - 2] : null;
    };

    this.just_added_newline = function() {
        return this.current_line.is_empty();
    };

    this.just_added_blankline = function() {
        if (this.just_added_newline()) {
            if (lines.length === 1) {
                return true; // start of the file and newline = blank
            }

            var line = lines[lines.length - 2];
            return line.is_empty();
        }
        return false;
    };
}

module.exports.Output = Output;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

    The MIT License (MIT)

    Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

var Beautifier = __webpack_require__(0).Beautifier;

function css_beautify(source_text, options) {
    var beautifier = new Beautifier(source_text, options);
    return beautifier.beautify();
}

module.exports = css_beautify;

/***/ })
/******/ ]);
var css_beautify = legacy_beautify_css;
/* Footer */
if (typeof define === "function" && define.amd) {
    // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
    define([], function() {
        return {
            css_beautify: css_beautify
        };
    });
} else if (typeof exports !== "undefined") {
    // Add support for CommonJS. Just put this file somewhere on your require.paths
    // and you will be able to `var html_beautify = require("beautify").html_beautify`.
    exports.css_beautify = css_beautify;
} else if (typeof window !== "undefined") {
    // If we're running a web page and don't have either of the above, add our one global
    window.css_beautify = css_beautify;
} else if (typeof global !== "undefined") {
    // If we don't even have window, try global.
    global.css_beautify = css_beautify;
}

}());

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],174:[function(require,module,exports){
(function (global){
/*jshint curly:false, eqeqeq:true, laxbreak:true, noempty:false */
/* AUTO-GENERATED. DO NOT MODIFY. */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.


 Style HTML
---------------

  Written by Nochum Sossonko, (nsossonko@hotmail.com)

  Based on code initially developed by: Einar Lielmanis, <einar@jsbeautifier.org>
    http://jsbeautifier.org/

  Usage:
    style_html(html_source);

    style_html(html_source, options);

  The options are:
    indent_inner_html (default false)  — indent <head> and <body> sections,
    indent_size (default 4)          — indentation size,
    indent_char (default space)      — character to indent with,
    wrap_line_length (default 250)            -  maximum amount of characters per line (0 = disable)
    brace_style (default "collapse") - "collapse" | "expand" | "end-expand" | "none"
            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.
    unformatted (defaults to inline tags) - list of tags, that shouldn't be reformatted
    content_unformatted (defaults to pre tag) - list of tags, whose content shouldn't be reformatted
    indent_scripts (default normal)  - "keep"|"separate"|"normal"
    preserve_newlines (default true) - whether existing line breaks before elements should be preserved
                                        Only works before elements, not inside tags or for text.
    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk
    indent_handlebars (default false) - format and indent {{#foo}} and {{/foo}}
    end_with_newline (false)          - end with a newline
    extra_liners (default [head,body,/html]) -List of tags that should have an extra newline before them.

    e.g.

    style_html(html_source, {
      'indent_inner_html': false,
      'indent_size': 2,
      'indent_char': ' ',
      'wrap_line_length': 78,
      'brace_style': 'expand',
      'preserve_newlines': true,
      'max_preserve_newlines': 5,
      'indent_handlebars': false,
      'extra_liners': ['/html']
    });
*/

(function() {
var legacy_beautify_html =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 3);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

var mergeOpts = __webpack_require__(2).mergeOpts;
var acorn = __webpack_require__(1);


var lineBreak = acorn.lineBreak;
var allLineBreaks = acorn.allLineBreaks;

// function trim(s) {
//     return s.replace(/^\s+|\s+$/g, '');
// }

function ltrim(s) {
    return s.replace(/^\s+/g, '');
}

function rtrim(s) {
    return s.replace(/\s+$/g, '');
}

function Beautifier(html_source, options, js_beautify, css_beautify) {
    //Wrapper function to invoke all the necessary constructors and deal with the output.
    html_source = html_source || '';

    var multi_parser,
        indent_inner_html,
        indent_body_inner_html,
        indent_head_inner_html,
        indent_size,
        indent_character,
        wrap_line_length,
        brace_style,
        unformatted,
        content_unformatted,
        preserve_newlines,
        max_preserve_newlines,
        indent_handlebars,
        wrap_attributes,
        wrap_attributes_indent_size,
        is_wrap_attributes_force,
        is_wrap_attributes_force_expand_multiline,
        is_wrap_attributes_force_aligned,
        end_with_newline,
        extra_liners,
        eol;

    options = options || {};

    // Allow the setting of language/file-type specific options
    // with inheritance of overall settings
    options = mergeOpts(options, 'html');

    // backwards compatibility to 1.3.4
    if ((options.wrap_line_length === undefined || parseInt(options.wrap_line_length, 10) === 0) &&
        (options.max_char !== undefined && parseInt(options.max_char, 10) !== 0)) {
        options.wrap_line_length = options.max_char;
    }

    indent_inner_html = (options.indent_inner_html === undefined) ? false : options.indent_inner_html;
    indent_body_inner_html = (options.indent_body_inner_html === undefined) ? true : options.indent_body_inner_html;
    indent_head_inner_html = (options.indent_head_inner_html === undefined) ? true : options.indent_head_inner_html;
    indent_size = (options.indent_size === undefined) ? 4 : parseInt(options.indent_size, 10);
    indent_character = (options.indent_char === undefined) ? ' ' : options.indent_char;
    brace_style = (options.brace_style === undefined) ? 'collapse' : options.brace_style;
    wrap_line_length = parseInt(options.wrap_line_length, 10) === 0 ? 32786 : parseInt(options.wrap_line_length || 250, 10);
    unformatted = options.unformatted || [
        // https://www.w3.org/TR/html5/dom.html#phrasing-content
        'a', 'abbr', 'area', 'audio', 'b', 'bdi', 'bdo', 'br', 'button', 'canvas', 'cite',
        'code', 'data', 'datalist', 'del', 'dfn', 'em', 'embed', 'i', 'iframe', 'img',
        'input', 'ins', 'kbd', 'keygen', 'label', 'map', 'mark', 'math', 'meter', 'noscript',
        'object', 'output', 'progress', 'q', 'ruby', 's', 'samp', /* 'script', */ 'select', 'small',
        'span', 'strong', 'sub', 'sup', 'svg', 'template', 'textarea', 'time', 'u', 'var',
        'video', 'wbr', 'text',
        // prexisting - not sure of full effect of removing, leaving in
        'acronym', 'address', 'big', 'dt', 'ins', 'strike', 'tt',
    ];
    content_unformatted = options.content_unformatted || [
        'pre',
    ];
    preserve_newlines = (options.preserve_newlines === undefined) ? true : options.preserve_newlines;
    max_preserve_newlines = preserve_newlines ?
        (isNaN(parseInt(options.max_preserve_newlines, 10)) ? 32786 : parseInt(options.max_preserve_newlines, 10)) :
        0;
    indent_handlebars = (options.indent_handlebars === undefined) ? false : options.indent_handlebars;
    wrap_attributes = (options.wrap_attributes === undefined) ? 'auto' : options.wrap_attributes;
    wrap_attributes_indent_size = (isNaN(parseInt(options.wrap_attributes_indent_size, 10))) ? indent_size : parseInt(options.wrap_attributes_indent_size, 10);
    is_wrap_attributes_force = wrap_attributes.substr(0, 'force'.length) === 'force';
    is_wrap_attributes_force_expand_multiline = (wrap_attributes === 'force-expand-multiline');
    is_wrap_attributes_force_aligned = (wrap_attributes === 'force-aligned');
    end_with_newline = (options.end_with_newline === undefined) ? false : options.end_with_newline;
    extra_liners = (typeof options.extra_liners === 'object') && options.extra_liners ?
        options.extra_liners.concat() : (typeof options.extra_liners === 'string') ?
        options.extra_liners.split(',') : 'head,body,/html'.split(',');
    eol = options.eol ? options.eol : 'auto';

    if (options.indent_with_tabs) {
        indent_character = '\t';
        indent_size = 1;
    }

    if (eol === 'auto') {
        eol = '\n';
        if (html_source && lineBreak.test(html_source || '')) {
            eol = html_source.match(lineBreak)[0];
        }
    }

    eol = eol.replace(/\\r/, '\r').replace(/\\n/, '\n');

    // HACK: newline parsing inconsistent. This brute force normalizes the input.
    html_source = html_source.replace(allLineBreaks, '\n');

    function Parser() {

        this.pos = 0; //Parser position
        this.token = '';
        this.current_mode = 'CONTENT'; //reflects the current Parser mode: TAG/CONTENT
        this.tags = { //An object to hold tags, their position, and their parent-tags, initiated with default values
            parent: 'parent1',
            parentcount: 1,
            parent1: ''
        };
        this.tag_type = '';
        this.token_text = this.last_token = this.last_text = this.token_type = '';
        this.newlines = 0;
        this.indent_content = indent_inner_html;
        this.indent_body_inner_html = indent_body_inner_html;
        this.indent_head_inner_html = indent_head_inner_html;

        this.Utils = { //Uilities made available to the various functions
            whitespace: "\n\r\t ".split(''),

            single_token: options.void_elements || [
                // HTLM void elements - aka self-closing tags - aka singletons
                // https://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements
                'area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen',
                'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr',
                // NOTE: Optional tags - are not understood.
                // https://www.w3.org/TR/html5/syntax.html#optional-tags
                // The rules for optional tags are too complex for a simple list
                // Also, the content of these tags should still be indented in many cases.
                // 'li' is a good exmple.

                // Doctype and xml elements
                '!doctype', '?xml',
                // ?php tag
                '?php',
                // other tags that were in this list, keeping just in case
                'basefont', 'isindex'
            ],
            extra_liners: extra_liners, //for tags that need a line of whitespace before them
            in_array: function(what, arr) {
                for (var i = 0; i < arr.length; i++) {
                    if (what === arr[i]) {
                        return true;
                    }
                }
                return false;
            }
        };

        // Return true if the given text is composed entirely of whitespace.
        this.is_whitespace = function(text) {
            for (var n = 0; n < text.length; n++) {
                if (!this.Utils.in_array(text.charAt(n), this.Utils.whitespace)) {
                    return false;
                }
            }
            return true;
        };

        this.traverse_whitespace = function() {
            var input_char = '';

            input_char = this.input.charAt(this.pos);
            if (this.Utils.in_array(input_char, this.Utils.whitespace)) {
                this.newlines = 0;
                while (this.Utils.in_array(input_char, this.Utils.whitespace)) {
                    if (preserve_newlines && input_char === '\n' && this.newlines <= max_preserve_newlines) {
                        this.newlines += 1;
                    }

                    this.pos++;
                    input_char = this.input.charAt(this.pos);
                }
                return true;
            }
            return false;
        };

        // Append a space to the given content (string array) or, if we are
        // at the wrap_line_length, append a newline/indentation.
        // return true if a newline was added, false if a space was added
        this.space_or_wrap = function(content) {
            if (this.line_char_count >= this.wrap_line_length) { //insert a line when the wrap_line_length is reached
                this.print_newline(false, content);
                this.print_indentation(content);
                return true;
            } else {
                this.line_char_count++;
                content.push(' ');
                return false;
            }
        };

        this.get_content = function() { //function to capture regular content between tags
            var input_char = '',
                content = [],
                handlebarsStarted = 0;

            while (this.input.charAt(this.pos) !== '<' || handlebarsStarted === 2) {
                if (this.pos >= this.input.length) {
                    return content.length ? content.join('') : ['', 'TK_EOF'];
                }

                if (handlebarsStarted < 2 && this.traverse_whitespace()) {
                    this.space_or_wrap(content);
                    continue;
                }

                input_char = this.input.charAt(this.pos);

                if (indent_handlebars) {
                    if (input_char === '{') {
                        handlebarsStarted += 1;
                    } else if (handlebarsStarted < 2) {
                        handlebarsStarted = 0;
                    }

                    if (input_char === '}' && handlebarsStarted > 0) {
                        if (handlebarsStarted-- === 0) {
                            break;
                        }
                    }
                    // Handlebars parsing is complicated.
                    // {{#foo}} and {{/foo}} are formatted tags.
                    // {{something}} should get treated as content, except:
                    // {{else}} specifically behaves like {{#if}} and {{/if}}
                    var peek3 = this.input.substr(this.pos, 3);
                    if (peek3 === '{{#' || peek3 === '{{/') {
                        // These are tags and not content.
                        break;
                    } else if (peek3 === '{{!') {
                        return [this.get_tag(), 'TK_TAG_HANDLEBARS_COMMENT'];
                    } else if (this.input.substr(this.pos, 2) === '{{') {
                        if (this.get_tag(true) === '{{else}}') {
                            break;
                        }
                    }
                }

                this.pos++;
                this.line_char_count++;
                content.push(input_char); //letter at-a-time (or string) inserted to an array
            }
            return content.length ? content.join('') : '';
        };

        this.get_contents_to = function(name) { //get the full content of a script or style to pass to js_beautify
            if (this.pos === this.input.length) {
                return ['', 'TK_EOF'];
            }
            var content = '';
            var reg_match = new RegExp('</' + name + '\\s*>', 'igm');
            reg_match.lastIndex = this.pos;
            var reg_array = reg_match.exec(this.input);
            var end_script = reg_array ? reg_array.index : this.input.length; //absolute end of script
            if (this.pos < end_script) { //get everything in between the script tags
                content = this.input.substring(this.pos, end_script);
                this.pos = end_script;
            }
            return content;
        };

        this.record_tag = function(tag) { //function to record a tag and its parent in this.tags Object
            if (this.tags[tag + 'count']) { //check for the existence of this tag type
                this.tags[tag + 'count']++;
                this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level
            } else { //otherwise initialize this tag type
                this.tags[tag + 'count'] = 1;
                this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level
            }
            this.tags[tag + this.tags[tag + 'count'] + 'parent'] = this.tags.parent; //set the parent (i.e. in the case of a div this.tags.div1parent)
            this.tags.parent = tag + this.tags[tag + 'count']; //and make this the current parent (i.e. in the case of a div 'div1')
        };

        this.retrieve_tag = function(tag) { //function to retrieve the opening tag to the corresponding closer
            if (this.tags[tag + 'count']) { //if the openener is not in the Object we ignore it
                var temp_parent = this.tags.parent; //check to see if it's a closable tag.
                while (temp_parent) { //till we reach '' (the initial value);
                    if (tag + this.tags[tag + 'count'] === temp_parent) { //if this is it use it
                        break;
                    }
                    temp_parent = this.tags[temp_parent + 'parent']; //otherwise keep on climbing up the DOM Tree
                }
                if (temp_parent) { //if we caught something
                    this.indent_level = this.tags[tag + this.tags[tag + 'count']]; //set the indent_level accordingly
                    this.tags.parent = this.tags[temp_parent + 'parent']; //and set the current parent
                }
                delete this.tags[tag + this.tags[tag + 'count'] + 'parent']; //delete the closed tags parent reference...
                delete this.tags[tag + this.tags[tag + 'count']]; //...and the tag itself
                if (this.tags[tag + 'count'] === 1) {
                    delete this.tags[tag + 'count'];
                } else {
                    this.tags[tag + 'count']--;
                }
            }
        };

        this.indent_to_tag = function(tag) {
            // Match the indentation level to the last use of this tag, but don't remove it.
            if (!this.tags[tag + 'count']) {
                return;
            }
            var temp_parent = this.tags.parent;
            while (temp_parent) {
                if (tag + this.tags[tag + 'count'] === temp_parent) {
                    break;
                }
                temp_parent = this.tags[temp_parent + 'parent'];
            }
            if (temp_parent) {
                this.indent_level = this.tags[tag + this.tags[tag + 'count']];
            }
        };

        this.get_tag = function(peek) { //function to get a full tag and parse its type
            var input_char = '',
                content = [],
                comment = '',
                space = false,
                first_attr = true,
                has_wrapped_attrs = false,
                tag_start, tag_end,
                tag_start_char,
                orig_pos = this.pos,
                orig_line_char_count = this.line_char_count,
                is_tag_closed = false,
                tail;

            peek = peek !== undefined ? peek : false;

            do {
                if (this.pos >= this.input.length) {
                    if (peek) {
                        this.pos = orig_pos;
                        this.line_char_count = orig_line_char_count;
                    }
                    return content.length ? content.join('') : ['', 'TK_EOF'];
                }

                input_char = this.input.charAt(this.pos);
                this.pos++;

                if (this.Utils.in_array(input_char, this.Utils.whitespace)) { //don't want to insert unnecessary space
                    space = true;
                    continue;
                }

                if (input_char === "'" || input_char === '"') {
                    input_char += this.get_unformatted(input_char);
                    space = true;
                }

                if (input_char === '=') { //no space before =
                    space = false;
                }
                tail = this.input.substr(this.pos - 1);
                if (is_wrap_attributes_force_expand_multiline && has_wrapped_attrs && !is_tag_closed && (input_char === '>' || input_char === '/')) {
                    if (tail.match(/^\/?\s*>/)) {
                        space = false;
                        is_tag_closed = true;
                        this.print_newline(false, content);
                        this.print_indentation(content);
                    }
                }
                if (content.length && content[content.length - 1] !== '=' && input_char !== '>' && space) {
                    //no space after = or before >
                    var wrapped = this.space_or_wrap(content);
                    var indentAttrs = wrapped && input_char !== '/' && !is_wrap_attributes_force;
                    space = false;

                    if (is_wrap_attributes_force && input_char !== '/') {
                        var force_first_attr_wrap = false;
                        if (is_wrap_attributes_force_expand_multiline && first_attr) {
                            var is_only_attribute = tail.match(/^\S*(="([^"]|\\")*")?\s*\/?\s*>/) !== null;
                            force_first_attr_wrap = !is_only_attribute;
                        }
                        if (!first_attr || force_first_attr_wrap) {
                            this.print_newline(false, content);
                            this.print_indentation(content);
                            indentAttrs = true;
                        }
                    }
                    if (indentAttrs) {
                        has_wrapped_attrs = true;

                        //indent attributes an auto, forced, or forced-align line-wrap
                        var alignment_size = wrap_attributes_indent_size;
                        if (is_wrap_attributes_force_aligned) {
                            alignment_size = content.indexOf(' ') + 1;
                        }

                        for (var count = 0; count < alignment_size; count++) {
                            // only ever further indent with spaces since we're trying to align characters
                            content.push(' ');
                        }
                    }
                    if (first_attr) {
                        for (var i = 0; i < content.length; i++) {
                            if (content[i] === ' ') {
                                first_attr = false;
                                break;
                            }
                        }
                    }
                }

                if (indent_handlebars && tag_start_char === '<') {
                    // When inside an angle-bracket tag, put spaces around
                    // handlebars not inside of strings.
                    if ((input_char + this.input.charAt(this.pos)) === '{{') {
                        input_char += this.get_unformatted('}}');
                        if (content.length && content[content.length - 1] !== ' ' && content[content.length - 1] !== '<') {
                            input_char = ' ' + input_char;
                        }
                        space = true;
                    }
                }

                if (input_char === '<' && !tag_start_char) {
                    tag_start = this.pos - 1;
                    tag_start_char = '<';
                }

                if (indent_handlebars && !tag_start_char) {
                    if (content.length >= 2 && content[content.length - 1] === '{' && content[content.length - 2] === '{') {
                        if (input_char === '#' || input_char === '/' || input_char === '!') {
                            tag_start = this.pos - 3;
                        } else {
                            tag_start = this.pos - 2;
                        }
                        tag_start_char = '{';
                    }
                }

                this.line_char_count++;
                content.push(input_char); //inserts character at-a-time (or string)

                if (content[1] && (content[1] === '!' || content[1] === '?' || content[1] === '%')) { //if we're in a comment, do something special
                    // We treat all comments as literals, even more than preformatted tags
                    // we just look for the appropriate close tag
                    content = [this.get_comment(tag_start)];
                    break;
                }

                if (indent_handlebars && content[1] && content[1] === '{' && content[2] && content[2] === '!') { //if we're in a comment, do something special
                    // We treat all comments as literals, even more than preformatted tags
                    // we just look for the appropriate close tag
                    content = [this.get_comment(tag_start)];
                    break;
                }

                if (indent_handlebars && tag_start_char === '{' && content.length > 2 && content[content.length - 2] === '}' && content[content.length - 1] === '}') {
                    break;
                }
            } while (input_char !== '>');

            var tag_complete = content.join('');
            var tag_index;
            var tag_offset;

            // must check for space first otherwise the tag could have the first attribute included, and
            // then not un-indent correctly
            if (tag_complete.indexOf(' ') !== -1) { //if there's whitespace, thats where the tag name ends
                tag_index = tag_complete.indexOf(' ');
            } else if (tag_complete.indexOf('\n') !== -1) { //if there's a line break, thats where the tag name ends
                tag_index = tag_complete.indexOf('\n');
            } else if (tag_complete.charAt(0) === '{') {
                tag_index = tag_complete.indexOf('}');
            } else { //otherwise go with the tag ending
                tag_index = tag_complete.indexOf('>');
            }
            if (tag_complete.charAt(0) === '<' || !indent_handlebars) {
                tag_offset = 1;
            } else {
                tag_offset = tag_complete.charAt(2) === '#' ? 3 : 2;
            }
            var tag_check = tag_complete.substring(tag_offset, tag_index).toLowerCase();
            if (tag_complete.charAt(tag_complete.length - 2) === '/' ||
                this.Utils.in_array(tag_check, this.Utils.single_token)) { //if this tag name is a single tag type (either in the list or has a closing /)
                if (!peek) {
                    this.tag_type = 'SINGLE';
                }
            } else if (indent_handlebars && tag_complete.charAt(0) === '{' && tag_check === 'else') {
                if (!peek) {
                    this.indent_to_tag('if');
                    this.tag_type = 'HANDLEBARS_ELSE';
                    this.indent_content = true;
                    this.traverse_whitespace();
                }
            } else if (this.is_unformatted(tag_check, unformatted) ||
                this.is_unformatted(tag_check, content_unformatted)) {
                // do not reformat the "unformatted" or "content_unformatted" tags
                comment = this.get_unformatted('</' + tag_check + '>', tag_complete); //...delegate to get_unformatted function
                content.push(comment);
                tag_end = this.pos - 1;
                this.tag_type = 'SINGLE';
            } else if (tag_check === 'script' &&
                (tag_complete.search('type') === -1 ||
                    (tag_complete.search('type') > -1 &&
                        tag_complete.search(/\b(text|application|dojo)\/(x-)?(javascript|ecmascript|jscript|livescript|(ld\+)?json|method|aspect)/) > -1))) {
                if (!peek) {
                    this.record_tag(tag_check);
                    this.tag_type = 'SCRIPT';
                }
            } else if (tag_check === 'style' &&
                (tag_complete.search('type') === -1 ||
                    (tag_complete.search('type') > -1 && tag_complete.search('text/css') > -1))) {
                if (!peek) {
                    this.record_tag(tag_check);
                    this.tag_type = 'STYLE';
                }
            } else if (tag_check.charAt(0) === '!') { //peek for <! comment
                // for comments content is already correct.
                if (!peek) {
                    this.tag_type = 'SINGLE';
                    this.traverse_whitespace();
                }
            } else if (!peek) {
                if (tag_check.charAt(0) === '/') { //this tag is a double tag so check for tag-ending
                    this.retrieve_tag(tag_check.substring(1)); //remove it and all ancestors
                    this.tag_type = 'END';
                } else { //otherwise it's a start-tag
                    this.record_tag(tag_check); //push it on the tag stack
                    if (tag_check.toLowerCase() !== 'html') {
                        this.indent_content = true;
                    }
                    this.tag_type = 'START';
                }

                // Allow preserving of newlines after a start or end tag
                if (this.traverse_whitespace()) {
                    this.space_or_wrap(content);
                }

                if (this.Utils.in_array(tag_check, this.Utils.extra_liners)) { //check if this double needs an extra line
                    this.print_newline(false, this.output);
                    if (this.output.length && this.output[this.output.length - 2] !== '\n') {
                        this.print_newline(true, this.output);
                    }
                }
            }

            if (peek) {
                this.pos = orig_pos;
                this.line_char_count = orig_line_char_count;
            }

            return content.join(''); //returns fully formatted tag
        };

        this.get_comment = function(start_pos) { //function to return comment content in its entirety
            // this is will have very poor perf, but will work for now.
            var comment = '',
                delimiter = '>',
                matched = false;

            this.pos = start_pos;
            var input_char = this.input.charAt(this.pos);
            this.pos++;

            while (this.pos <= this.input.length) {
                comment += input_char;

                // only need to check for the delimiter if the last chars match
                if (comment.charAt(comment.length - 1) === delimiter.charAt(delimiter.length - 1) &&
                    comment.indexOf(delimiter) !== -1) {
                    break;
                }

                // only need to search for custom delimiter for the first few characters
                if (!matched && comment.length < 10) {
                    if (comment.indexOf('<![if') === 0) { //peek for <![if conditional comment
                        delimiter = '<![endif]>';
                        matched = true;
                    } else if (comment.indexOf('<![cdata[') === 0) { //if it's a <[cdata[ comment...
                        delimiter = ']]>';
                        matched = true;
                    } else if (comment.indexOf('<![') === 0) { // some other ![ comment? ...
                        delimiter = ']>';
                        matched = true;
                    } else if (comment.indexOf('<!--') === 0) { // <!-- comment ...
                        delimiter = '-->';
                        matched = true;
                    } else if (comment.indexOf('{{!--') === 0) { // {{!-- handlebars comment
                        delimiter = '--}}';
                        matched = true;
                    } else if (comment.indexOf('{{!') === 0) { // {{! handlebars comment
                        if (comment.length === 5 && comment.indexOf('{{!--') === -1) {
                            delimiter = '}}';
                            matched = true;
                        }
                    } else if (comment.indexOf('<?') === 0) { // {{! handlebars comment
                        delimiter = '?>';
                        matched = true;
                    } else if (comment.indexOf('<%') === 0) { // {{! handlebars comment
                        delimiter = '%>';
                        matched = true;
                    }
                }

                input_char = this.input.charAt(this.pos);
                this.pos++;
            }

            return comment;
        };

        function tokenMatcher(delimiter) {
            var token = '';

            var add = function(str) {
                var newToken = token + str.toLowerCase();
                token = newToken.length <= delimiter.length ? newToken : newToken.substr(newToken.length - delimiter.length, delimiter.length);
            };

            var doesNotMatch = function() {
                return token.indexOf(delimiter) === -1;
            };

            return {
                add: add,
                doesNotMatch: doesNotMatch
            };
        }

        this.get_unformatted = function(delimiter, orig_tag) { //function to return unformatted content in its entirety
            if (orig_tag && orig_tag.toLowerCase().indexOf(delimiter) !== -1) {
                return '';
            }
            var input_char = '';
            var content = '';
            var space = true;

            var delimiterMatcher = tokenMatcher(delimiter);

            do {

                if (this.pos >= this.input.length) {
                    return content;
                }

                input_char = this.input.charAt(this.pos);
                this.pos++;

                if (this.Utils.in_array(input_char, this.Utils.whitespace)) {
                    if (!space) {
                        this.line_char_count--;
                        continue;
                    }
                    if (input_char === '\n' || input_char === '\r') {
                        content += '\n';
                        /*  Don't change tab indention for unformatted blocks.  If using code for html editing, this will greatly affect <pre> tags if they are specified in the 'unformatted array'
            for (var i=0; i<this.indent_level; i++) {
              content += this.indent_string;
            }
            space = false; //...and make sure other indentation is erased
            */
                        this.line_char_count = 0;
                        continue;
                    }
                }
                content += input_char;
                delimiterMatcher.add(input_char);
                this.line_char_count++;
                space = true;

                if (indent_handlebars && input_char === '{' && content.length && content.charAt(content.length - 2) === '{') {
                    // Handlebars expressions in strings should also be unformatted.
                    content += this.get_unformatted('}}');
                    // Don't consider when stopping for delimiters.
                }
            } while (delimiterMatcher.doesNotMatch());

            return content;
        };

        this.get_token = function() { //initial handler for token-retrieval
            var token;

            if (this.last_token === 'TK_TAG_SCRIPT' || this.last_token === 'TK_TAG_STYLE') { //check if we need to format javascript
                var type = this.last_token.substr(7);
                token = this.get_contents_to(type);
                if (typeof token !== 'string') {
                    return token;
                }
                return [token, 'TK_' + type];
            }
            if (this.current_mode === 'CONTENT') {
                token = this.get_content();
                if (typeof token !== 'string') {
                    return token;
                } else {
                    return [token, 'TK_CONTENT'];
                }
            }

            if (this.current_mode === 'TAG') {
                token = this.get_tag();
                if (typeof token !== 'string') {
                    return token;
                } else {
                    var tag_name_type = 'TK_TAG_' + this.tag_type;
                    return [token, tag_name_type];
                }
            }
        };

        this.get_full_indent = function(level) {
            level = this.indent_level + level || 0;
            if (level < 1) {
                return '';
            }

            return Array(level + 1).join(this.indent_string);
        };

        this.is_unformatted = function(tag_check, unformatted) {
            //is this an HTML5 block-level link?
            if (!this.Utils.in_array(tag_check, unformatted)) {
                return false;
            }

            if (tag_check.toLowerCase() !== 'a' || !this.Utils.in_array('a', unformatted)) {
                return true;
            }

            //at this point we have an  tag; is its first child something we want to remain
            //unformatted?
            var next_tag = this.get_tag(true /* peek. */ );

            // test next_tag to see if it is just html tag (no external content)
            var tag = (next_tag || "").match(/^\s*<\s*\/?([a-z]*)\s*[^>]*>\s*$/);

            // if next_tag comes back but is not an isolated tag, then
            // let's treat the 'a' tag as having content
            // and respect the unformatted option
            if (!tag || this.Utils.in_array(tag[1], unformatted)) {
                return true;
            } else {
                return false;
            }
        };

        this.printer = function(js_source, indent_character, indent_size, wrap_line_length, brace_style) { //handles input/output and some other printing functions

            this.input = js_source || ''; //gets the input for the Parser

            // HACK: newline parsing inconsistent. This brute force normalizes the input.
            this.input = this.input.replace(/\r\n|[\r\u2028\u2029]/g, '\n');

            this.output = [];
            this.indent_character = indent_character;
            this.indent_string = '';
            this.indent_size = indent_size;
            this.brace_style = brace_style;
            this.indent_level = 0;
            this.wrap_line_length = wrap_line_length;
            this.line_char_count = 0; //count to see if wrap_line_length was exceeded

            for (var i = 0; i < this.indent_size; i++) {
                this.indent_string += this.indent_character;
            }

            this.print_newline = function(force, arr) {
                this.line_char_count = 0;
                if (!arr || !arr.length) {
                    return;
                }
                if (force || (arr[arr.length - 1] !== '\n')) { //we might want the extra line
                    if ((arr[arr.length - 1] !== '\n')) {
                        arr[arr.length - 1] = rtrim(arr[arr.length - 1]);
                    }
                    arr.push('\n');
                }
            };

            this.print_indentation = function(arr) {
                for (var i = 0; i < this.indent_level; i++) {
                    arr.push(this.indent_string);
                    this.line_char_count += this.indent_string.length;
                }
            };

            this.print_token = function(text) {
                // Avoid printing initial whitespace.
                if (this.is_whitespace(text) && !this.output.length) {
                    return;
                }
                if (text || text !== '') {
                    if (this.output.length && this.output[this.output.length - 1] === '\n') {
                        this.print_indentation(this.output);
                        text = ltrim(text);
                    }
                }
                this.print_token_raw(text);
            };

            this.print_token_raw = function(text) {
                // If we are going to print newlines, truncate trailing
                // whitespace, as the newlines will represent the space.
                if (this.newlines > 0) {
                    text = rtrim(text);
                }

                if (text && text !== '') {
                    if (text.length > 1 && text.charAt(text.length - 1) === '\n') {
                        // unformatted tags can grab newlines as their last character
                        this.output.push(text.slice(0, -1));
                        this.print_newline(false, this.output);
                    } else {
                        this.output.push(text);
                    }
                }

                for (var n = 0; n < this.newlines; n++) {
                    this.print_newline(n > 0, this.output);
                }
                this.newlines = 0;
            };

            this.indent = function() {
                this.indent_level++;
            };

            this.unindent = function() {
                if (this.indent_level > 0) {
                    this.indent_level--;
                }
            };
        };
        return this;
    }

    /*_____________________--------------------_____________________*/

    this.beautify = function() {
        multi_parser = new Parser(); //wrapping functions Parser
        multi_parser.printer(html_source, indent_character, indent_size, wrap_line_length, brace_style); //initialize starting values
        while (true) {
            var t = multi_parser.get_token();
            multi_parser.token_text = t[0];
            multi_parser.token_type = t[1];

            if (multi_parser.token_type === 'TK_EOF') {
                break;
            }

            switch (multi_parser.token_type) {
                case 'TK_TAG_START':
                    multi_parser.print_newline(false, multi_parser.output);
                    multi_parser.print_token(multi_parser.token_text);
                    if (multi_parser.indent_content) {
                        if ((multi_parser.indent_body_inner_html || !multi_parser.token_text.match(/<body(?:.*)>/)) &&
                            (multi_parser.indent_head_inner_html || !multi_parser.token_text.match(/<head(?:.*)>/))) {

                            multi_parser.indent();
                        }

                        multi_parser.indent_content = false;
                    }
                    multi_parser.current_mode = 'CONTENT';
                    break;
                case 'TK_TAG_STYLE':
                case 'TK_TAG_SCRIPT':
                    multi_parser.print_newline(false, multi_parser.output);
                    multi_parser.print_token(multi_parser.token_text);
                    multi_parser.current_mode = 'CONTENT';
                    break;
                case 'TK_TAG_END':
                    //Print new line only if the tag has no content and has child
                    if (multi_parser.last_token === 'TK_CONTENT' && multi_parser.last_text === '') {
                        var tag_name = (multi_parser.token_text.match(/\w+/) || [])[0];
                        var tag_extracted_from_last_output = null;
                        if (multi_parser.output.length) {
                            tag_extracted_from_last_output = multi_parser.output[multi_parser.output.length - 1].match(/(?:<|{{#)\s*(\w+)/);
                        }
                        if (tag_extracted_from_last_output === null ||
                            (tag_extracted_from_last_output[1] !== tag_name && !multi_parser.Utils.in_array(tag_extracted_from_last_output[1], unformatted))) {
                            multi_parser.print_newline(false, multi_parser.output);
                        }
                    }
                    multi_parser.print_token(multi_parser.token_text);
                    multi_parser.current_mode = 'CONTENT';
                    break;
                case 'TK_TAG_SINGLE':
                    // Don't add a newline before elements that should remain unformatted.
                    var tag_check = multi_parser.token_text.match(/^\s*<([a-z-]+)/i);
                    if (!tag_check || !multi_parser.Utils.in_array(tag_check[1], unformatted)) {
                        multi_parser.print_newline(false, multi_parser.output);
                    }
                    multi_parser.print_token(multi_parser.token_text);
                    multi_parser.current_mode = 'CONTENT';
                    break;
                case 'TK_TAG_HANDLEBARS_ELSE':
                    // Don't add a newline if opening {{#if}} tag is on the current line
                    var foundIfOnCurrentLine = false;
                    for (var lastCheckedOutput = multi_parser.output.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--) {
                        if (multi_parser.output[lastCheckedOutput] === '\n') {
                            break;
                        } else {
                            if (multi_parser.output[lastCheckedOutput].match(/{{#if/)) {
                                foundIfOnCurrentLine = true;
                                break;
                            }
                        }
                    }
                    if (!foundIfOnCurrentLine) {
                        multi_parser.print_newline(false, multi_parser.output);
                    }
                    multi_parser.print_token(multi_parser.token_text);
                    if (multi_parser.indent_content) {
                        multi_parser.indent();
                        multi_parser.indent_content = false;
                    }
                    multi_parser.current_mode = 'CONTENT';
                    break;
                case 'TK_TAG_HANDLEBARS_COMMENT':
                    multi_parser.print_token(multi_parser.token_text);
                    multi_parser.current_mode = 'TAG';
                    break;
                case 'TK_CONTENT':
                    multi_parser.print_token(multi_parser.token_text);
                    multi_parser.current_mode = 'TAG';
                    break;
                case 'TK_STYLE':
                case 'TK_SCRIPT':
                    if (multi_parser.token_text !== '') {
                        multi_parser.print_newline(false, multi_parser.output);
                        var text = multi_parser.token_text,
                            _beautifier,
                            script_indent_level = 1;
                        if (multi_parser.token_type === 'TK_SCRIPT') {
                            _beautifier = typeof js_beautify === 'function' && js_beautify;
                        } else if (multi_parser.token_type === 'TK_STYLE') {
                            _beautifier = typeof css_beautify === 'function' && css_beautify;
                        }

                        if (options.indent_scripts === "keep") {
                            script_indent_level = 0;
                        } else if (options.indent_scripts === "separate") {
                            script_indent_level = -multi_parser.indent_level;
                        }

                        var indentation = multi_parser.get_full_indent(script_indent_level);
                        if (_beautifier) {

                            // call the Beautifier if avaliable
                            var Child_options = function() {
                                this.eol = '\n';
                            };
                            Child_options.prototype = options;
                            var child_options = new Child_options();
                            text = _beautifier(text.replace(/^\s*/, indentation), child_options);
                        } else {
                            // simply indent the string otherwise
                            var white = text.match(/^\s*/)[0];
                            var _level = white.match(/[^\n\r]*$/)[0].split(multi_parser.indent_string).length - 1;
                            var reindent = multi_parser.get_full_indent(script_indent_level - _level);
                            text = text.replace(/^\s*/, indentation)
                                .replace(/\r\n|\r|\n/g, '\n' + reindent)
                                .replace(/\s+$/, '');
                        }
                        if (text) {
                            multi_parser.print_token_raw(text);
                            multi_parser.print_newline(true, multi_parser.output);
                        }
                    }
                    multi_parser.current_mode = 'TAG';
                    break;
                default:
                    // We should not be getting here but we don't want to drop input on the floor
                    // Just output the text and move on
                    if (multi_parser.token_text !== '') {
                        multi_parser.print_token(multi_parser.token_text);
                    }
                    break;
            }
            multi_parser.last_token = multi_parser.token_type;
            multi_parser.last_text = multi_parser.token_text;
        }
        var sweet_code = multi_parser.output.join('').replace(/[\r\n\t ]+$/, '');

        // establish end_with_newline
        if (end_with_newline) {
            sweet_code += '\n';
        }

        if (eol !== '\n') {
            sweet_code = sweet_code.replace(/[\n]/g, eol);
        }

        return sweet_code;
    };
}

module.exports.Beautifier = Beautifier;


/***/ }),
/* 1 */
/***/ (function(module, exports) {

/* jshint curly: false */
// This section of code is taken from acorn.
//
// Acorn was written by Marijn Haverbeke and released under an MIT
// license. The Unicode regexps (for identifiers and whitespace) were
// taken from [Esprima](http://esprima.org) by Ariya Hidayat.
//
// Git repositories for Acorn are available at
//
//     http://marijnhaverbeke.nl/git/acorn
//     https://github.com/marijnh/acorn.git

// ## Character categories

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.

var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/; // jshint ignore:line
var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
var nonASCIIidentifierChars = "\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

// Whether a single character denotes a newline.

exports.newline = /[\n\r\u2028\u2029]/;

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

// in javascript, these two differ
// in python they are the same, different methods are called on them
exports.lineBreak = new RegExp('\r\n|' + exports.newline.source);
exports.allLineBreaks = new RegExp(exports.lineBreak.source, 'g');


// Test whether a given character code starts an identifier.

exports.isIdentifierStart = function(code) {
    // permit $ (36) and @ (64). @ is used in ES7 decorators.
    if (code < 65) return code === 36 || code === 64;
    // 65 through 91 are uppercase letters.
    if (code < 91) return true;
    // permit _ (95).
    if (code < 97) return code === 95;
    // 97 through 123 are lowercase letters.
    if (code < 123) return true;
    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
};

// Test whether a given character is part of an identifier.

exports.isIdentifierChar = function(code) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code < 91) return true;
    if (code < 97) return code === 95;
    if (code < 123) return true;
    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
};


/***/ }),
/* 2 */
/***/ (function(module, exports) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

    The MIT License (MIT)

    Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

function mergeOpts(allOptions, targetType) {
    var finalOpts = {};
    var name;

    for (name in allOptions) {
        if (name !== targetType) {
            finalOpts[name] = allOptions[name];
        }
    }

    //merge in the per type settings for the targetType
    if (targetType in allOptions) {
        for (name in allOptions[targetType]) {
            finalOpts[name] = allOptions[targetType][name];
        }
    }
    return finalOpts;
}

module.exports.mergeOpts = mergeOpts;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

    The MIT License (MIT)

    Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

var Beautifier = __webpack_require__(0).Beautifier;

function style_html(html_source, options, js_beautify, css_beautify) {
    var beautifier = new Beautifier(html_source, options, js_beautify, css_beautify);
    return beautifier.beautify();
}

module.exports = style_html;

/***/ })
/******/ ]);
var style_html = legacy_beautify_html;
/* Footer */
if (typeof define === "function" && define.amd) {
    // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
    define(["require", "./beautify", "./beautify-css"], function(requireamd) {
        var js_beautify = requireamd("./beautify");
        var css_beautify = requireamd("./beautify-css");

        return {
            html_beautify: function(html_source, options) {
                return style_html(html_source, options, js_beautify.js_beautify, css_beautify.css_beautify);
            }
        };
    });
} else if (typeof exports !== "undefined") {
    // Add support for CommonJS. Just put this file somewhere on your require.paths
    // and you will be able to `var html_beautify = require("beautify").html_beautify`.
    var js_beautify = require('./beautify.js');
    var css_beautify = require('./beautify-css.js');

    exports.html_beautify = function(html_source, options) {
        return style_html(html_source, options, js_beautify.js_beautify, css_beautify.css_beautify);
    };
} else if (typeof window !== "undefined") {
    // If we're running a web page and don't have either of the above, add our one global
    window.html_beautify = function(html_source, options) {
        return style_html(html_source, options, window.js_beautify, window.css_beautify);
    };
} else if (typeof global !== "undefined") {
    // If we don't even have window, try global.
    global.html_beautify = function(html_source, options) {
        return style_html(html_source, options, global.js_beautify, global.css_beautify);
    };
}

}());

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./beautify-css.js":173,"./beautify.js":175}],175:[function(require,module,exports){
(function (global){
/*jshint curly:false, eqeqeq:true, laxbreak:true, noempty:false */
/* AUTO-GENERATED. DO NOT MODIFY. */
/* see js/src/javascript/index.js */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

 JS Beautifier
---------------


  Written by Einar Lielmanis, <einar@jsbeautifier.org>
      http://jsbeautifier.org/

  Originally converted to javascript by Vital, <vital76@gmail.com>
  "End braces on own line" added by Chris J. Shull, <chrisjshull@gmail.com>
  Parsing improvements for brace-less statements by Liam Newman <bitwiseman@gmail.com>


  Usage:
    js_beautify(js_source_text);
    js_beautify(js_source_text, options);

  The options are:
    indent_size (default 4)          - indentation size,
    indent_char (default space)      - character to indent with,
    preserve_newlines (default true) - whether existing line breaks should be preserved,
    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk,

    jslint_happy (default false) - if true, then jslint-stricter mode is enforced.

            jslint_happy        !jslint_happy
            ---------------------------------
            function ()         function()

            switch () {         switch() {
            case 1:               case 1:
              break;                break;
            }                   }

    space_after_anon_function (default false) - should the space before an anonymous function's parens be added, "function()" vs "function ()",
          NOTE: This option is overriden by jslint_happy (i.e. if jslint_happy is true, space_after_anon_function is true by design)

    brace_style (default "collapse") - "collapse" | "expand" | "end-expand" | "none" | any of the former + ",preserve-inline"
            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.
            preserve-inline will try to preserve inline blocks of curly braces

    space_before_conditional (default true) - should the space before conditional statement be added, "if(true)" vs "if (true)",

    unescape_strings (default false) - should printable characters in strings encoded in \xNN notation be unescaped, "example" vs "\x65\x78\x61\x6d\x70\x6c\x65"

    wrap_line_length (default unlimited) - lines should wrap at next opportunity after this number of characters.
          NOTE: This is not a hard limit. Lines will continue until a point where a newline would
                be preserved if it were present.

    end_with_newline (default false)  - end output with a newline


    e.g

    js_beautify(js_source_text, {
      'indent_size': 1,
      'indent_char': '\t'
    });

*/

(function() {
var legacy_beautify_js =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 6);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

/* jshint curly: false */
// This section of code is taken from acorn.
//
// Acorn was written by Marijn Haverbeke and released under an MIT
// license. The Unicode regexps (for identifiers and whitespace) were
// taken from [Esprima](http://esprima.org) by Ariya Hidayat.
//
// Git repositories for Acorn are available at
//
//     http://marijnhaverbeke.nl/git/acorn
//     https://github.com/marijnh/acorn.git

// ## Character categories

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.

var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/; // jshint ignore:line
var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
var nonASCIIidentifierChars = "\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

// Whether a single character denotes a newline.

exports.newline = /[\n\r\u2028\u2029]/;

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

// in javascript, these two differ
// in python they are the same, different methods are called on them
exports.lineBreak = new RegExp('\r\n|' + exports.newline.source);
exports.allLineBreaks = new RegExp(exports.lineBreak.source, 'g');


// Test whether a given character code starts an identifier.

exports.isIdentifierStart = function(code) {
    // permit $ (36) and @ (64). @ is used in ES7 decorators.
    if (code < 65) return code === 36 || code === 64;
    // 65 through 91 are uppercase letters.
    if (code < 91) return true;
    // permit _ (95).
    if (code < 97) return code === 95;
    // 97 through 123 are lowercase letters.
    if (code < 123) return true;
    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
};

// Test whether a given character is part of an identifier.

exports.isIdentifierChar = function(code) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code < 91) return true;
    if (code < 97) return code === 95;
    if (code < 123) return true;
    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
};


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

    The MIT License (MIT)

    Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

var mergeOpts = __webpack_require__(3).mergeOpts;
var acorn = __webpack_require__(0);
var Output = __webpack_require__(4).Output;
var Tokenizer = __webpack_require__(7).Tokenizer;

function remove_redundant_indentation(output, frame) {
    // This implementation is effective but has some issues:
    //     - can cause line wrap to happen too soon due to indent removal
    //           after wrap points are calculated
    // These issues are minor compared to ugly indentation.

    if (frame.multiline_frame ||
        frame.mode === MODE.ForInitializer ||
        frame.mode === MODE.Conditional) {
        return;
    }

    // remove one indent from each line inside this section
    var start_index = frame.start_line_index;

    output.remove_indent(start_index);
}

function in_array(what, arr) {
    for (var i = 0; i < arr.length; i += 1) {
        if (arr[i] === what) {
            return true;
        }
    }
    return false;
}

function trim(s) {
    return s.replace(/^\s+|\s+$/g, '');
}

function ltrim(s) {
    return s.replace(/^\s+/g, '');
}

// function rtrim(s) {
//     return s.replace(/\s+$/g, '');
// }


function generateMapFromStrings(list) {
    var result = {};
    for (var x = 0; x < list.length; x++) {
        // make the mapped names underscored instead of dash
        result[list[x].replace(/-/g, '_')] = list[x];
    }
    return result;
}

function sanitizeOperatorPosition(opPosition) {
    opPosition = opPosition || OPERATOR_POSITION.before_newline;

    if (!in_array(opPosition, validPositionValues)) {
        throw new Error("Invalid Option Value: The option 'operator_position' must be one of the following values\n" +
            validPositionValues +
            "\nYou passed in: '" + opPosition + "'");
    }

    return opPosition;
}

var validPositionValues = ['before-newline', 'after-newline', 'preserve-newline'];

// Generate map from array
var OPERATOR_POSITION = generateMapFromStrings(validPositionValues);

var OPERATOR_POSITION_BEFORE_OR_PRESERVE = [OPERATOR_POSITION.before_newline, OPERATOR_POSITION.preserve_newline];

var MODE = {
    BlockStatement: 'BlockStatement', // 'BLOCK'
    Statement: 'Statement', // 'STATEMENT'
    ObjectLiteral: 'ObjectLiteral', // 'OBJECT',
    ArrayLiteral: 'ArrayLiteral', //'[EXPRESSION]',
    ForInitializer: 'ForInitializer', //'(FOR-EXPRESSION)',
    Conditional: 'Conditional', //'(COND-EXPRESSION)',
    Expression: 'Expression' //'(EXPRESSION)'
};

function Beautifier(js_source_text, options) {
    "use strict";
    var output;
    var tokens = [],
        token_pos;
    var tokenizer;
    var current_token;
    var last_type, last_last_text, indent_string;
    var flags, previous_flags, flag_store;
    var prefix;

    var handlers, opt;
    var baseIndentString = '';

    handlers = {
        'TK_START_EXPR': handle_start_expr,
        'TK_END_EXPR': handle_end_expr,
        'TK_START_BLOCK': handle_start_block,
        'TK_END_BLOCK': handle_end_block,
        'TK_WORD': handle_word,
        'TK_RESERVED': handle_word,
        'TK_SEMICOLON': handle_semicolon,
        'TK_STRING': handle_string,
        'TK_EQUALS': handle_equals,
        'TK_OPERATOR': handle_operator,
        'TK_COMMA': handle_comma,
        'TK_BLOCK_COMMENT': handle_block_comment,
        'TK_COMMENT': handle_comment,
        'TK_DOT': handle_dot,
        'TK_UNKNOWN': handle_unknown,
        'TK_EOF': handle_eof
    };

    function create_flags(flags_base, mode) {
        var next_indent_level = 0;
        if (flags_base) {
            next_indent_level = flags_base.indentation_level;
            if (!output.just_added_newline() &&
                flags_base.line_indent_level > next_indent_level) {
                next_indent_level = flags_base.line_indent_level;
            }
        }

        var next_flags = {
            mode: mode,
            parent: flags_base,
            last_text: flags_base ? flags_base.last_text : '', // last token text
            last_word: flags_base ? flags_base.last_word : '', // last 'TK_WORD' passed
            declaration_statement: false,
            declaration_assignment: false,
            multiline_frame: false,
            inline_frame: false,
            if_block: false,
            else_block: false,
            do_block: false,
            do_while: false,
            import_block: false,
            in_case_statement: false, // switch(..){ INSIDE HERE }
            in_case: false, // we're on the exact line with "case 0:"
            case_body: false, // the indented case-action block
            indentation_level: next_indent_level,
            line_indent_level: flags_base ? flags_base.line_indent_level : next_indent_level,
            start_line_index: output.get_line_number(),
            ternary_depth: 0
        };
        return next_flags;
    }

    // Some interpreters have unexpected results with foo = baz || bar;
    options = options ? options : {};

    // Allow the setting of language/file-type specific options
    // with inheritance of overall settings
    options = mergeOpts(options, 'js');

    opt = {};

    // compatibility, re
    if (options.brace_style === "expand-strict") { //graceful handling of deprecated option
        options.brace_style = "expand";
    } else if (options.brace_style === "collapse-preserve-inline") { //graceful handling of deprecated option
        options.brace_style = "collapse,preserve-inline";
    } else if (options.braces_on_own_line !== undefined) { //graceful handling of deprecated option
        options.brace_style = options.braces_on_own_line ? "expand" : "collapse";
    } else if (!options.brace_style) //Nothing exists to set it
    {
        options.brace_style = "collapse";
    }


    var brace_style_split = options.brace_style.split(/[^a-zA-Z0-9_\-]+/);
    opt.brace_style = brace_style_split[0];
    opt.brace_preserve_inline = brace_style_split[1] ? brace_style_split[1] : false;

    opt.indent_size = options.indent_size ? parseInt(options.indent_size, 10) : 4;
    opt.indent_char = options.indent_char ? options.indent_char : ' ';
    opt.eol = options.eol ? options.eol : 'auto';
    opt.preserve_newlines = (options.preserve_newlines === undefined) ? true : options.preserve_newlines;
    opt.unindent_chained_methods = (options.unindent_chained_methods === undefined) ? false : options.unindent_chained_methods;
    opt.break_chained_methods = (options.break_chained_methods === undefined) ? false : options.break_chained_methods;
    opt.max_preserve_newlines = (options.max_preserve_newlines === undefined) ? 0 : parseInt(options.max_preserve_newlines, 10);
    opt.space_in_paren = (options.space_in_paren === undefined) ? false : options.space_in_paren;
    opt.space_in_empty_paren = (options.space_in_empty_paren === undefined) ? false : options.space_in_empty_paren;
    opt.jslint_happy = (options.jslint_happy === undefined) ? false : options.jslint_happy;
    opt.space_after_anon_function = (options.space_after_anon_function === undefined) ? false : options.space_after_anon_function;
    opt.keep_array_indentation = (options.keep_array_indentation === undefined) ? false : options.keep_array_indentation;
    opt.space_before_conditional = (options.space_before_conditional === undefined) ? true : options.space_before_conditional;
    opt.unescape_strings = (options.unescape_strings === undefined) ? false : options.unescape_strings;
    opt.wrap_line_length = (options.wrap_line_length === undefined) ? 0 : parseInt(options.wrap_line_length, 10);
    opt.e4x = (options.e4x === undefined) ? false : options.e4x;
    opt.end_with_newline = (options.end_with_newline === undefined) ? false : options.end_with_newline;
    opt.comma_first = (options.comma_first === undefined) ? false : options.comma_first;
    opt.operator_position = sanitizeOperatorPosition(options.operator_position);

    // For testing of beautify ignore:start directive
    opt.test_output_raw = (options.test_output_raw === undefined) ? false : options.test_output_raw;

    // force opt.space_after_anon_function to true if opt.jslint_happy
    if (opt.jslint_happy) {
        opt.space_after_anon_function = true;
    }

    if (options.indent_with_tabs) {
        opt.indent_char = '\t';
        opt.indent_size = 1;
    }

    if (opt.eol === 'auto') {
        opt.eol = '\n';
        if (js_source_text && acorn.lineBreak.test(js_source_text || '')) {
            opt.eol = js_source_text.match(acorn.lineBreak)[0];
        }
    }

    opt.eol = opt.eol.replace(/\\r/, '\r').replace(/\\n/, '\n');

    //----------------------------------
    indent_string = '';
    while (opt.indent_size > 0) {
        indent_string += opt.indent_char;
        opt.indent_size -= 1;
    }

    var preindent_index = 0;
    if (js_source_text && js_source_text.length) {
        while ((js_source_text.charAt(preindent_index) === ' ' ||
                js_source_text.charAt(preindent_index) === '\t')) {
            preindent_index += 1;
        }
        baseIndentString = js_source_text.substring(0, preindent_index);
        js_source_text = js_source_text.substring(preindent_index);
    }

    last_type = 'TK_START_BLOCK'; // last token type
    last_last_text = ''; // pre-last token text
    output = new Output(indent_string, baseIndentString);

    // If testing the ignore directive, start with output disable set to true
    output.raw = opt.test_output_raw;


    // Stack of parsing/formatting states, including MODE.
    // We tokenize, parse, and output in an almost purely a forward-only stream of token input
    // and formatted output.  This makes the beautifier less accurate than full parsers
    // but also far more tolerant of syntax errors.
    //
    // For example, the default mode is MODE.BlockStatement. If we see a '{' we push a new frame of type
    // MODE.BlockStatement on the the stack, even though it could be object literal.  If we later
    // encounter a ":", we'll switch to to MODE.ObjectLiteral.  If we then see a ";",
    // most full parsers would die, but the beautifier gracefully falls back to
    // MODE.BlockStatement and continues on.
    flag_store = [];
    set_mode(MODE.BlockStatement);

    this.beautify = function() {

        /*jshint onevar:true */
        var sweet_code;
        tokenizer = new Tokenizer(js_source_text, opt, indent_string);
        tokens = tokenizer.tokenize();
        token_pos = 0;

        current_token = get_token();
        while (current_token) {
            handlers[current_token.type]();

            last_last_text = flags.last_text;
            last_type = current_token.type;
            flags.last_text = current_token.text;

            token_pos += 1;
            current_token = get_token();
        }

        sweet_code = output.get_code(opt.end_with_newline, opt.eol);

        return sweet_code;
    };

    function handle_whitespace_and_comments(local_token, preserve_statement_flags) {
        var newlines = local_token.newlines;
        var keep_whitespace = opt.keep_array_indentation && is_array(flags.mode);
        var temp_token = current_token;

        for (var h = 0; h < local_token.comments_before.length; h++) {
            // The cleanest handling of inline comments is to treat them as though they aren't there.
            // Just continue formatting and the behavior should be logical.
            // Also ignore unknown tokens.  Again, this should result in better behavior.
            current_token = local_token.comments_before[h];
            handle_whitespace_and_comments(current_token, preserve_statement_flags);
            handlers[current_token.type](preserve_statement_flags);
        }
        current_token = temp_token;

        if (keep_whitespace) {
            for (var i = 0; i < newlines; i += 1) {
                print_newline(i > 0, preserve_statement_flags);
            }
        } else {
            if (opt.max_preserve_newlines && newlines > opt.max_preserve_newlines) {
                newlines = opt.max_preserve_newlines;
            }

            if (opt.preserve_newlines) {
                if (local_token.newlines > 1) {
                    print_newline(false, preserve_statement_flags);
                    for (var j = 1; j < newlines; j += 1) {
                        print_newline(true, preserve_statement_flags);
                    }
                }
            }
        }

    }

    // we could use just string.split, but
    // IE doesn't like returning empty strings
    function split_linebreaks(s) {
        //return s.split(/\x0d\x0a|\x0a/);

        s = s.replace(acorn.allLineBreaks, '\n');
        var out = [],
            idx = s.indexOf("\n");
        while (idx !== -1) {
            out.push(s.substring(0, idx));
            s = s.substring(idx + 1);
            idx = s.indexOf("\n");
        }
        if (s.length) {
            out.push(s);
        }
        return out;
    }

    var newline_restricted_tokens = ['break', 'continue', 'return', 'throw', 'yield'];

    function allow_wrap_or_preserved_newline(force_linewrap) {
        force_linewrap = (force_linewrap === undefined) ? false : force_linewrap;

        // Never wrap the first token on a line
        if (output.just_added_newline()) {
            return;
        }

        var shouldPreserveOrForce = (opt.preserve_newlines && current_token.wanted_newline) || force_linewrap;
        var operatorLogicApplies = in_array(flags.last_text, tokenizer.positionable_operators) || in_array(current_token.text, tokenizer.positionable_operators);

        if (operatorLogicApplies) {
            var shouldPrintOperatorNewline = (
                    in_array(flags.last_text, tokenizer.positionable_operators) &&
                    in_array(opt.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)
                ) ||
                in_array(current_token.text, tokenizer.positionable_operators);
            shouldPreserveOrForce = shouldPreserveOrForce && shouldPrintOperatorNewline;
        }

        if (shouldPreserveOrForce) {
            print_newline(false, true);
        } else if (opt.wrap_line_length) {
            if (last_type === 'TK_RESERVED' && in_array(flags.last_text, newline_restricted_tokens)) {
                // These tokens should never have a newline inserted
                // between them and the following expression.
                return;
            }
            var proposed_line_length = output.current_line.get_character_count() + current_token.text.length +
                (output.space_before_token ? 1 : 0);
            if (proposed_line_length >= opt.wrap_line_length) {
                print_newline(false, true);
            }
        }
    }

    function print_newline(force_newline, preserve_statement_flags) {
        if (!preserve_statement_flags) {
            if (flags.last_text !== ';' && flags.last_text !== ',' && flags.last_text !== '=' && last_type !== 'TK_OPERATOR') {
                var next_token = get_token(1);
                while (flags.mode === MODE.Statement &&
                    !(flags.if_block && next_token && next_token.type === 'TK_RESERVED' && next_token.text === 'else') &&
                    !flags.do_block) {
                    restore_mode();
                }
            }
        }

        if (output.add_new_line(force_newline)) {
            flags.multiline_frame = true;
        }
    }

    function print_token_line_indentation() {
        if (output.just_added_newline()) {
            if (opt.keep_array_indentation && is_array(flags.mode) && current_token.wanted_newline) {
                output.current_line.push(current_token.whitespace_before);
                output.space_before_token = false;
            } else if (output.set_indent(flags.indentation_level)) {
                flags.line_indent_level = flags.indentation_level;
            }
        }
    }

    function print_token(printable_token) {
        if (output.raw) {
            output.add_raw_token(current_token);
            return;
        }

        if (opt.comma_first && last_type === 'TK_COMMA' &&
            output.just_added_newline()) {
            if (output.previous_line.last() === ',') {
                var popped = output.previous_line.pop();
                // if the comma was already at the start of the line,
                // pull back onto that line and reprint the indentation
                if (output.previous_line.is_empty()) {
                    output.previous_line.push(popped);
                    output.trim(true);
                    output.current_line.pop();
                    output.trim();
                }

                // add the comma in front of the next token
                print_token_line_indentation();
                output.add_token(',');
                output.space_before_token = true;
            }
        }

        printable_token = printable_token || current_token.text;
        print_token_line_indentation();
        output.add_token(printable_token);
    }

    function indent() {
        flags.indentation_level += 1;
    }

    function deindent() {
        if (flags.indentation_level > 0 &&
            ((!flags.parent) || flags.indentation_level > flags.parent.indentation_level)) {
            flags.indentation_level -= 1;

        }
    }

    function set_mode(mode) {
        if (flags) {
            flag_store.push(flags);
            previous_flags = flags;
        } else {
            previous_flags = create_flags(null, mode);
        }

        flags = create_flags(previous_flags, mode);
    }

    function is_array(mode) {
        return mode === MODE.ArrayLiteral;
    }

    function is_expression(mode) {
        return in_array(mode, [MODE.Expression, MODE.ForInitializer, MODE.Conditional]);
    }

    function restore_mode() {
        if (flag_store.length > 0) {
            previous_flags = flags;
            flags = flag_store.pop();
            if (previous_flags.mode === MODE.Statement && !opt.unindent_chained_methods) {
                remove_redundant_indentation(output, previous_flags);
            }
        }
    }

    function start_of_object_property() {
        return flags.parent.mode === MODE.ObjectLiteral && flags.mode === MODE.Statement && (
            (flags.last_text === ':' && flags.ternary_depth === 0) || (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set'])));
    }

    function start_of_statement() {
        if (
            (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const']) && current_token.type === 'TK_WORD') ||
            (last_type === 'TK_RESERVED' && flags.last_text === 'do') ||
            (last_type === 'TK_RESERVED' && in_array(flags.last_text, newline_restricted_tokens) && !current_token.wanted_newline) ||
            (last_type === 'TK_RESERVED' && flags.last_text === 'else' &&
                !(current_token.type === 'TK_RESERVED' && current_token.text === 'if' && !current_token.comments_before.length)) ||
            (last_type === 'TK_END_EXPR' && (previous_flags.mode === MODE.ForInitializer || previous_flags.mode === MODE.Conditional)) ||
            (last_type === 'TK_WORD' && flags.mode === MODE.BlockStatement &&
                !flags.in_case &&
                !(current_token.text === '--' || current_token.text === '++') &&
                last_last_text !== 'function' &&
                current_token.type !== 'TK_WORD' && current_token.type !== 'TK_RESERVED') ||
            (flags.mode === MODE.ObjectLiteral && (
                (flags.last_text === ':' && flags.ternary_depth === 0) || (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set']))))
        ) {

            set_mode(MODE.Statement);
            if (!opt.unindent_chained_methods) {
                indent();
            }

            handle_whitespace_and_comments(current_token, true);

            // Issue #276:
            // If starting a new statement with [if, for, while, do], push to a new line.
            // if (a) if (b) if(c) d(); else e(); else f();
            if (!start_of_object_property()) {
                allow_wrap_or_preserved_newline(
                    current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['do', 'for', 'if', 'while']));
            }

            return true;
        }
        return false;
    }

    function all_lines_start_with(lines, c) {
        for (var i = 0; i < lines.length; i++) {
            var line = trim(lines[i]);
            if (line.charAt(0) !== c) {
                return false;
            }
        }
        return true;
    }

    function each_line_matches_indent(lines, indent) {
        var i = 0,
            len = lines.length,
            line;
        for (; i < len; i++) {
            line = lines[i];
            // allow empty lines to pass through
            if (line && line.indexOf(indent) !== 0) {
                return false;
            }
        }
        return true;
    }

    function is_special_word(word) {
        return in_array(word, ['case', 'return', 'do', 'if', 'throw', 'else']);
    }

    function get_token(offset) {
        var index = token_pos + (offset || 0);
        return (index < 0 || index >= tokens.length) ? null : tokens[index];
    }

    function handle_start_expr() {
        // The conditional starts the statement if appropriate.
        if (!start_of_statement()) {
            handle_whitespace_and_comments(current_token);
        }

        var next_mode = MODE.Expression;
        if (current_token.text === '[') {

            if (last_type === 'TK_WORD' || flags.last_text === ')') {
                // this is array index specifier, break immediately
                // a[x], fn()[x]
                if (last_type === 'TK_RESERVED' && in_array(flags.last_text, tokenizer.line_starters)) {
                    output.space_before_token = true;
                }
                set_mode(next_mode);
                print_token();
                indent();
                if (opt.space_in_paren) {
                    output.space_before_token = true;
                }
                return;
            }

            next_mode = MODE.ArrayLiteral;
            if (is_array(flags.mode)) {
                if (flags.last_text === '[' ||
                    (flags.last_text === ',' && (last_last_text === ']' || last_last_text === '}'))) {
                    // ], [ goes to new line
                    // }, [ goes to new line
                    if (!opt.keep_array_indentation) {
                        print_newline();
                    }
                }
            }

        } else {
            if (last_type === 'TK_RESERVED' && flags.last_text === 'for') {
                next_mode = MODE.ForInitializer;
            } else if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['if', 'while'])) {
                next_mode = MODE.Conditional;
            } else {
                // next_mode = MODE.Expression;
            }
        }

        if (flags.last_text === ';' || last_type === 'TK_START_BLOCK') {
            print_newline();
        } else if (last_type === 'TK_END_EXPR' || last_type === 'TK_START_EXPR' || last_type === 'TK_END_BLOCK' || flags.last_text === '.') {
            // TODO: Consider whether forcing this is required.  Review failing tests when removed.
            allow_wrap_or_preserved_newline(current_token.wanted_newline);
            // do nothing on (( and )( and ][ and ]( and .(
        } else if (!(last_type === 'TK_RESERVED' && current_token.text === '(') && last_type !== 'TK_WORD' && last_type !== 'TK_OPERATOR') {
            output.space_before_token = true;
        } else if ((last_type === 'TK_RESERVED' && (flags.last_word === 'function' || flags.last_word === 'typeof')) ||
            (flags.last_text === '*' &&
                (in_array(last_last_text, ['function', 'yield']) ||
                    (flags.mode === MODE.ObjectLiteral && in_array(last_last_text, ['{', ',']))))) {
            // function() vs function ()
            // yield*() vs yield* ()
            // function*() vs function* ()
            if (opt.space_after_anon_function) {
                output.space_before_token = true;
            }
        } else if (last_type === 'TK_RESERVED' && (in_array(flags.last_text, tokenizer.line_starters) || flags.last_text === 'catch')) {
            if (opt.space_before_conditional) {
                output.space_before_token = true;
            }
        }

        // Should be a space between await and an IIFE, or async and an arrow function
        if (current_token.text === '(' && last_type === 'TK_RESERVED' && in_array(flags.last_word, ['await', 'async'])) {
            output.space_before_token = true;
        }

        // Support of this kind of newline preservation.
        // a = (b &&
        //     (c || d));
        if (current_token.text === '(') {
            if (last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
                if (!start_of_object_property()) {
                    allow_wrap_or_preserved_newline();
                }
            }
        }

        // Support preserving wrapped arrow function expressions
        // a.b('c',
        //     () => d.e
        // )
        if (current_token.text === '(' && last_type !== 'TK_WORD' && last_type !== 'TK_RESERVED') {
            allow_wrap_or_preserved_newline();
        }

        set_mode(next_mode);
        print_token();
        if (opt.space_in_paren) {
            output.space_before_token = true;
        }

        // In all cases, if we newline while inside an expression it should be indented.
        indent();
    }

    function handle_end_expr() {
        // statements inside expressions are not valid syntax, but...
        // statements must all be closed when their container closes
        while (flags.mode === MODE.Statement) {
            restore_mode();
        }

        handle_whitespace_and_comments(current_token);

        if (flags.multiline_frame) {
            allow_wrap_or_preserved_newline(current_token.text === ']' && is_array(flags.mode) && !opt.keep_array_indentation);
        }

        if (opt.space_in_paren) {
            if (last_type === 'TK_START_EXPR' && !opt.space_in_empty_paren) {
                // () [] no inner space in empty parens like these, ever, ref #320
                output.trim();
                output.space_before_token = false;
            } else {
                output.space_before_token = true;
            }
        }
        if (current_token.text === ']' && opt.keep_array_indentation) {
            print_token();
            restore_mode();
        } else {
            restore_mode();
            print_token();
        }
        remove_redundant_indentation(output, previous_flags);

        // do {} while () // no statement required after
        if (flags.do_while && previous_flags.mode === MODE.Conditional) {
            previous_flags.mode = MODE.Expression;
            flags.do_block = false;
            flags.do_while = false;

        }
    }

    function handle_start_block() {
        handle_whitespace_and_comments(current_token);

        // Check if this is should be treated as a ObjectLiteral
        var next_token = get_token(1);
        var second_token = get_token(2);
        if (second_token && (
                (in_array(second_token.text, [':', ',']) && in_array(next_token.type, ['TK_STRING', 'TK_WORD', 'TK_RESERVED'])) ||
                (in_array(next_token.text, ['get', 'set', '...']) && in_array(second_token.type, ['TK_WORD', 'TK_RESERVED']))
            )) {
            // We don't support TypeScript,but we didn't break it for a very long time.
            // We'll try to keep not breaking it.
            if (!in_array(last_last_text, ['class', 'interface'])) {
                set_mode(MODE.ObjectLiteral);
            } else {
                set_mode(MODE.BlockStatement);
            }
        } else if (last_type === 'TK_OPERATOR' && flags.last_text === '=>') {
            // arrow function: (param1, paramN) => { statements }
            set_mode(MODE.BlockStatement);
        } else if (in_array(last_type, ['TK_EQUALS', 'TK_START_EXPR', 'TK_COMMA', 'TK_OPERATOR']) ||
            (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['return', 'throw', 'import', 'default']))
        ) {
            // Detecting shorthand function syntax is difficult by scanning forward,
            //     so check the surrounding context.
            // If the block is being returned, imported, export default, passed as arg,
            //     assigned with = or assigned in a nested object, treat as an ObjectLiteral.
            set_mode(MODE.ObjectLiteral);
        } else {
            set_mode(MODE.BlockStatement);
        }

        var empty_braces = !next_token.comments_before.length && next_token.text === '}';
        var empty_anonymous_function = empty_braces && flags.last_word === 'function' &&
            last_type === 'TK_END_EXPR';

        if (opt.brace_preserve_inline) // check for inline, set inline_frame if so
        {
            // search forward for a newline wanted inside this block
            var index = 0;
            var check_token = null;
            flags.inline_frame = true;
            do {
                index += 1;
                check_token = get_token(index);
                if (check_token.wanted_newline) {
                    flags.inline_frame = false;
                    break;
                }
            } while (check_token.type !== 'TK_EOF' &&
                !(check_token.type === 'TK_END_BLOCK' && check_token.opened === current_token));
        }

        if ((opt.brace_style === "expand" ||
                (opt.brace_style === "none" && current_token.wanted_newline)) &&
            !flags.inline_frame) {
            if (last_type !== 'TK_OPERATOR' &&
                (empty_anonymous_function ||
                    last_type === 'TK_EQUALS' ||
                    (last_type === 'TK_RESERVED' && is_special_word(flags.last_text) && flags.last_text !== 'else'))) {
                output.space_before_token = true;
            } else {
                print_newline(false, true);
            }
        } else { // collapse || inline_frame
            if (is_array(previous_flags.mode) && (last_type === 'TK_START_EXPR' || last_type === 'TK_COMMA')) {
                if (last_type === 'TK_COMMA' || opt.space_in_paren) {
                    output.space_before_token = true;
                }

                if (last_type === 'TK_COMMA' || (last_type === 'TK_START_EXPR' && flags.inline_frame)) {
                    allow_wrap_or_preserved_newline();
                    previous_flags.multiline_frame = previous_flags.multiline_frame || flags.multiline_frame;
                    flags.multiline_frame = false;
                }
            }
            if (last_type !== 'TK_OPERATOR' && last_type !== 'TK_START_EXPR') {
                if (last_type === 'TK_START_BLOCK' && !flags.inline_frame) {
                    print_newline();
                } else {
                    output.space_before_token = true;
                }
            }
        }
        print_token();
        indent();
    }

    function handle_end_block() {
        // statements must all be closed when their container closes
        handle_whitespace_and_comments(current_token);

        while (flags.mode === MODE.Statement) {
            restore_mode();
        }

        var empty_braces = last_type === 'TK_START_BLOCK';

        if (flags.inline_frame && !empty_braces) { // try inline_frame (only set if opt.braces-preserve-inline) first
            output.space_before_token = true;
        } else if (opt.brace_style === "expand") {
            if (!empty_braces) {
                print_newline();
            }
        } else {
            // skip {}
            if (!empty_braces) {
                if (is_array(flags.mode) && opt.keep_array_indentation) {
                    // we REALLY need a newline here, but newliner would skip that
                    opt.keep_array_indentation = false;
                    print_newline();
                    opt.keep_array_indentation = true;

                } else {
                    print_newline();
                }
            }
        }
        restore_mode();
        print_token();
    }

    function handle_word() {
        if (current_token.type === 'TK_RESERVED') {
            if (in_array(current_token.text, ['set', 'get']) && flags.mode !== MODE.ObjectLiteral) {
                current_token.type = 'TK_WORD';
            } else if (in_array(current_token.text, ['as', 'from']) && !flags.import_block) {
                current_token.type = 'TK_WORD';
            } else if (flags.mode === MODE.ObjectLiteral) {
                var next_token = get_token(1);
                if (next_token.text === ':') {
                    current_token.type = 'TK_WORD';
                }
            }
        }

        if (start_of_statement()) {
            // The conditional starts the statement if appropriate.
            if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const']) && current_token.type === 'TK_WORD') {
                flags.declaration_statement = true;
            }
        } else if (current_token.wanted_newline && !is_expression(flags.mode) &&
            (last_type !== 'TK_OPERATOR' || (flags.last_text === '--' || flags.last_text === '++')) &&
            last_type !== 'TK_EQUALS' &&
            (opt.preserve_newlines || !(last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const', 'set', 'get'])))) {
            handle_whitespace_and_comments(current_token);
            print_newline();
        } else {
            handle_whitespace_and_comments(current_token);
        }

        if (flags.do_block && !flags.do_while) {
            if (current_token.type === 'TK_RESERVED' && current_token.text === 'while') {
                // do {} ## while ()
                output.space_before_token = true;
                print_token();
                output.space_before_token = true;
                flags.do_while = true;
                return;
            } else {
                // do {} should always have while as the next word.
                // if we don't see the expected while, recover
                print_newline();
                flags.do_block = false;
            }
        }

        // if may be followed by else, or not
        // Bare/inline ifs are tricky
        // Need to unwind the modes correctly: if (a) if (b) c(); else d(); else e();
        if (flags.if_block) {
            if (!flags.else_block && (current_token.type === 'TK_RESERVED' && current_token.text === 'else')) {
                flags.else_block = true;
            } else {
                while (flags.mode === MODE.Statement) {
                    restore_mode();
                }
                flags.if_block = false;
                flags.else_block = false;
            }
        }

        if (current_token.type === 'TK_RESERVED' && (current_token.text === 'case' || (current_token.text === 'default' && flags.in_case_statement))) {
            print_newline();
            if (flags.case_body || opt.jslint_happy) {
                // switch cases following one another
                deindent();
                flags.case_body = false;
            }
            print_token();
            flags.in_case = true;
            flags.in_case_statement = true;
            return;
        }

        if (last_type === 'TK_COMMA' || last_type === 'TK_START_EXPR' || last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
            if (!start_of_object_property()) {
                allow_wrap_or_preserved_newline();
            }
        }

        if (current_token.type === 'TK_RESERVED' && current_token.text === 'function') {
            if (in_array(flags.last_text, ['}', ';']) ||
                (output.just_added_newline() && !(in_array(flags.last_text, ['(', '[', '{', ':', '=', ',']) || last_type === 'TK_OPERATOR'))) {
                // make sure there is a nice clean space of at least one blank line
                // before a new function definition
                if (!output.just_added_blankline() && !current_token.comments_before.length) {
                    print_newline();
                    print_newline(true);
                }
            }
            if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD') {
                if (last_type === 'TK_RESERVED' && (
                        in_array(flags.last_text, ['get', 'set', 'new', 'export', 'async']) ||
                        in_array(flags.last_text, newline_restricted_tokens))) {
                    output.space_before_token = true;
                } else if (last_type === 'TK_RESERVED' && flags.last_text === 'default' && last_last_text === 'export') {
                    output.space_before_token = true;
                } else {
                    print_newline();
                }
            } else if (last_type === 'TK_OPERATOR' || flags.last_text === '=') {
                // foo = function
                output.space_before_token = true;
            } else if (!flags.multiline_frame && (is_expression(flags.mode) || is_array(flags.mode))) {
                // (function
            } else {
                print_newline();
            }

            print_token();
            flags.last_word = current_token.text;
            return;
        }

        prefix = 'NONE';

        if (last_type === 'TK_END_BLOCK') {

            if (previous_flags.inline_frame) {
                prefix = 'SPACE';
            } else if (!(current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['else', 'catch', 'finally', 'from']))) {
                prefix = 'NEWLINE';
            } else {
                if (opt.brace_style === "expand" ||
                    opt.brace_style === "end-expand" ||
                    (opt.brace_style === "none" && current_token.wanted_newline)) {
                    prefix = 'NEWLINE';
                } else {
                    prefix = 'SPACE';
                    output.space_before_token = true;
                }
            }
        } else if (last_type === 'TK_SEMICOLON' && flags.mode === MODE.BlockStatement) {
            // TODO: Should this be for STATEMENT as well?
            prefix = 'NEWLINE';
        } else if (last_type === 'TK_SEMICOLON' && is_expression(flags.mode)) {
            prefix = 'SPACE';
        } else if (last_type === 'TK_STRING') {
            prefix = 'NEWLINE';
        } else if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD' ||
            (flags.last_text === '*' &&
                (in_array(last_last_text, ['function', 'yield']) ||
                    (flags.mode === MODE.ObjectLiteral && in_array(last_last_text, ['{', ',']))))) {
            prefix = 'SPACE';
        } else if (last_type === 'TK_START_BLOCK') {
            if (flags.inline_frame) {
                prefix = 'SPACE';
            } else {
                prefix = 'NEWLINE';
            }
        } else if (last_type === 'TK_END_EXPR') {
            output.space_before_token = true;
            prefix = 'NEWLINE';
        }

        if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, tokenizer.line_starters) && flags.last_text !== ')') {
            if (flags.inline_frame || flags.last_text === 'else' || flags.last_text === 'export') {
                prefix = 'SPACE';
            } else {
                prefix = 'NEWLINE';
            }

        }

        if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['else', 'catch', 'finally'])) {
            if ((!(last_type === 'TK_END_BLOCK' && previous_flags.mode === MODE.BlockStatement) ||
                    opt.brace_style === "expand" ||
                    opt.brace_style === "end-expand" ||
                    (opt.brace_style === "none" && current_token.wanted_newline)) &&
                !flags.inline_frame) {
                print_newline();
            } else {
                output.trim(true);
                var line = output.current_line;
                // If we trimmed and there's something other than a close block before us
                // put a newline back in.  Handles '} // comment' scenario.
                if (line.last() !== '}') {
                    print_newline();
                }
                output.space_before_token = true;
            }
        } else if (prefix === 'NEWLINE') {
            if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {
                // no newline between 'return nnn'
                output.space_before_token = true;
            } else if (last_type !== 'TK_END_EXPR') {
                if ((last_type !== 'TK_START_EXPR' || !(current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['var', 'let', 'const']))) && flags.last_text !== ':') {
                    // no need to force newline on 'var': for (var x = 0...)
                    if (current_token.type === 'TK_RESERVED' && current_token.text === 'if' && flags.last_text === 'else') {
                        // no newline for } else if {
                        output.space_before_token = true;
                    } else {
                        print_newline();
                    }
                }
            } else if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, tokenizer.line_starters) && flags.last_text !== ')') {
                print_newline();
            }
        } else if (flags.multiline_frame && is_array(flags.mode) && flags.last_text === ',' && last_last_text === '}') {
            print_newline(); // }, in lists get a newline treatment
        } else if (prefix === 'SPACE') {
            output.space_before_token = true;
        }
        print_token();
        flags.last_word = current_token.text;

        if (current_token.type === 'TK_RESERVED') {
            if (current_token.text === 'do') {
                flags.do_block = true;
            } else if (current_token.text === 'if') {
                flags.if_block = true;
            } else if (current_token.text === 'import') {
                flags.import_block = true;
            } else if (flags.import_block && current_token.type === 'TK_RESERVED' && current_token.text === 'from') {
                flags.import_block = false;
            }
        }
    }

    function handle_semicolon() {
        if (start_of_statement()) {
            // The conditional starts the statement if appropriate.
            // Semicolon can be the start (and end) of a statement
            output.space_before_token = false;
        } else {
            handle_whitespace_and_comments(current_token);
        }

        var next_token = get_token(1);
        while (flags.mode === MODE.Statement &&
            !(flags.if_block && next_token && next_token.type === 'TK_RESERVED' && next_token.text === 'else') &&
            !flags.do_block) {
            restore_mode();
        }

        // hacky but effective for the moment
        if (flags.import_block) {
            flags.import_block = false;
        }
        print_token();
    }

    function handle_string() {
        if (start_of_statement()) {
            // The conditional starts the statement if appropriate.
            // One difference - strings want at least a space before
            output.space_before_token = true;
        } else {
            handle_whitespace_and_comments(current_token);
            if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD' || flags.inline_frame) {
                output.space_before_token = true;
            } else if (last_type === 'TK_COMMA' || last_type === 'TK_START_EXPR' || last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
                if (!start_of_object_property()) {
                    allow_wrap_or_preserved_newline();
                }
            } else {
                print_newline();
            }
        }
        print_token();
    }

    function handle_equals() {
        if (start_of_statement()) {
            // The conditional starts the statement if appropriate.
        } else {
            handle_whitespace_and_comments(current_token);
        }

        if (flags.declaration_statement) {
            // just got an '=' in a var-line, different formatting/line-breaking, etc will now be done
            flags.declaration_assignment = true;
        }
        output.space_before_token = true;
        print_token();
        output.space_before_token = true;
    }

    function handle_comma() {
        handle_whitespace_and_comments(current_token, true);

        print_token();
        output.space_before_token = true;
        if (flags.declaration_statement) {
            if (is_expression(flags.parent.mode)) {
                // do not break on comma, for(var a = 1, b = 2)
                flags.declaration_assignment = false;
            }

            if (flags.declaration_assignment) {
                flags.declaration_assignment = false;
                print_newline(false, true);
            } else if (opt.comma_first) {
                // for comma-first, we want to allow a newline before the comma
                // to turn into a newline after the comma, which we will fixup later
                allow_wrap_or_preserved_newline();
            }
        } else if (flags.mode === MODE.ObjectLiteral ||
            (flags.mode === MODE.Statement && flags.parent.mode === MODE.ObjectLiteral)) {
            if (flags.mode === MODE.Statement) {
                restore_mode();
            }

            if (!flags.inline_frame) {
                print_newline();
            }
        } else if (opt.comma_first) {
            // EXPR or DO_BLOCK
            // for comma-first, we want to allow a newline before the comma
            // to turn into a newline after the comma, which we will fixup later
            allow_wrap_or_preserved_newline();
        }
    }

    function handle_operator() {
        var isGeneratorAsterisk = current_token.text === '*' &&
            ((last_type === 'TK_RESERVED' && in_array(flags.last_text, ['function', 'yield'])) ||
                (in_array(last_type, ['TK_START_BLOCK', 'TK_COMMA', 'TK_END_BLOCK', 'TK_SEMICOLON']))
            );
        var isUnary = in_array(current_token.text, ['-', '+']) && (
            in_array(last_type, ['TK_START_BLOCK', 'TK_START_EXPR', 'TK_EQUALS', 'TK_OPERATOR']) ||
            in_array(flags.last_text, tokenizer.line_starters) ||
            flags.last_text === ','
        );

        if (start_of_statement()) {
            // The conditional starts the statement if appropriate.
        } else {
            var preserve_statement_flags = !isGeneratorAsterisk;
            handle_whitespace_and_comments(current_token, preserve_statement_flags);
        }

        if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {
            // "return" had a special handling in TK_WORD. Now we need to return the favor
            output.space_before_token = true;
            print_token();
            return;
        }

        // hack for actionscript's import .*;
        if (current_token.text === '*' && last_type === 'TK_DOT') {
            print_token();
            return;
        }

        if (current_token.text === '::') {
            // no spaces around exotic namespacing syntax operator
            print_token();
            return;
        }

        // Allow line wrapping between operators when operator_position is
        //   set to before or preserve
        if (last_type === 'TK_OPERATOR' && in_array(opt.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)) {
            allow_wrap_or_preserved_newline();
        }

        if (current_token.text === ':' && flags.in_case) {
            flags.case_body = true;
            indent();
            print_token();
            print_newline();
            flags.in_case = false;
            return;
        }

        var space_before = true;
        var space_after = true;
        var in_ternary = false;
        if (current_token.text === ':') {
            if (flags.ternary_depth === 0) {
                // Colon is invalid javascript outside of ternary and object, but do our best to guess what was meant.
                space_before = false;
            } else {
                flags.ternary_depth -= 1;
                in_ternary = true;
            }
        } else if (current_token.text === '?') {
            flags.ternary_depth += 1;
        }

        // let's handle the operator_position option prior to any conflicting logic
        if (!isUnary && !isGeneratorAsterisk && opt.preserve_newlines && in_array(current_token.text, tokenizer.positionable_operators)) {
            var isColon = current_token.text === ':';
            var isTernaryColon = (isColon && in_ternary);
            var isOtherColon = (isColon && !in_ternary);

            switch (opt.operator_position) {
                case OPERATOR_POSITION.before_newline:
                    // if the current token is : and it's not a ternary statement then we set space_before to false
                    output.space_before_token = !isOtherColon;

                    print_token();

                    if (!isColon || isTernaryColon) {
                        allow_wrap_or_preserved_newline();
                    }

                    output.space_before_token = true;
                    return;

                case OPERATOR_POSITION.after_newline:
                    // if the current token is anything but colon, or (via deduction) it's a colon and in a ternary statement,
                    //   then print a newline.

                    output.space_before_token = true;

                    if (!isColon || isTernaryColon) {
                        if (get_token(1).wanted_newline) {
                            print_newline(false, true);
                        } else {
                            allow_wrap_or_preserved_newline();
                        }
                    } else {
                        output.space_before_token = false;
                    }

                    print_token();

                    output.space_before_token = true;
                    return;

                case OPERATOR_POSITION.preserve_newline:
                    if (!isOtherColon) {
                        allow_wrap_or_preserved_newline();
                    }

                    // if we just added a newline, or the current token is : and it's not a ternary statement,
                    //   then we set space_before to false
                    space_before = !(output.just_added_newline() || isOtherColon);

                    output.space_before_token = space_before;
                    print_token();
                    output.space_before_token = true;
                    return;
            }
        }

        if (isGeneratorAsterisk) {
            allow_wrap_or_preserved_newline();
            space_before = false;
            var next_token = get_token(1);
            space_after = next_token && in_array(next_token.type, ['TK_WORD', 'TK_RESERVED']);
        } else if (current_token.text === '...') {
            allow_wrap_or_preserved_newline();
            space_before = last_type === 'TK_START_BLOCK';
            space_after = false;
        } else if (in_array(current_token.text, ['--', '++', '!', '~']) || isUnary) {
            // unary operators (and binary +/- pretending to be unary) special cases

            space_before = false;
            space_after = false;

            // http://www.ecma-international.org/ecma-262/5.1/#sec-7.9.1
            // if there is a newline between -- or ++ and anything else we should preserve it.
            if (current_token.wanted_newline && (current_token.text === '--' || current_token.text === '++')) {
                print_newline(false, true);
            }

            if (flags.last_text === ';' && is_expression(flags.mode)) {
                // for (;; ++i)
                //        ^^^
                space_before = true;
            }

            if (last_type === 'TK_RESERVED') {
                space_before = true;
            } else if (last_type === 'TK_END_EXPR') {
                space_before = !(flags.last_text === ']' && (current_token.text === '--' || current_token.text === '++'));
            } else if (last_type === 'TK_OPERATOR') {
                // a++ + ++b;
                // a - -b
                space_before = in_array(current_token.text, ['--', '-', '++', '+']) && in_array(flags.last_text, ['--', '-', '++', '+']);
                // + and - are not unary when preceeded by -- or ++ operator
                // a-- + b
                // a * +b
                // a - -b
                if (in_array(current_token.text, ['+', '-']) && in_array(flags.last_text, ['--', '++'])) {
                    space_after = true;
                }
            }


            if (((flags.mode === MODE.BlockStatement && !flags.inline_frame) || flags.mode === MODE.Statement) &&
                (flags.last_text === '{' || flags.last_text === ';')) {
                // { foo; --i }
                // foo(); --bar;
                print_newline();
            }
        }

        output.space_before_token = output.space_before_token || space_before;
        print_token();
        output.space_before_token = space_after;
    }

    function handle_block_comment(preserve_statement_flags) {
        if (output.raw) {
            output.add_raw_token(current_token);
            if (current_token.directives && current_token.directives.preserve === 'end') {
                // If we're testing the raw output behavior, do not allow a directive to turn it off.
                output.raw = opt.test_output_raw;
            }
            return;
        }

        if (current_token.directives) {
            print_newline(false, preserve_statement_flags);
            print_token();
            if (current_token.directives.preserve === 'start') {
                output.raw = true;
            }
            print_newline(false, true);
            return;
        }

        // inline block
        if (!acorn.newline.test(current_token.text) && !current_token.wanted_newline) {
            output.space_before_token = true;
            print_token();
            output.space_before_token = true;
            return;
        }

        var lines = split_linebreaks(current_token.text);
        var j; // iterator for this case
        var javadoc = false;
        var starless = false;
        var lastIndent = current_token.whitespace_before;
        var lastIndentLength = lastIndent.length;

        // block comment starts with a new line
        print_newline(false, preserve_statement_flags);
        if (lines.length > 1) {
            javadoc = all_lines_start_with(lines.slice(1), '*');
            starless = each_line_matches_indent(lines.slice(1), lastIndent);
        }

        // first line always indented
        print_token(lines[0]);
        for (j = 1; j < lines.length; j++) {
            print_newline(false, true);
            if (javadoc) {
                // javadoc: reformat and re-indent
                print_token(' ' + ltrim(lines[j]));
            } else if (starless && lines[j].length > lastIndentLength) {
                // starless: re-indent non-empty content, avoiding trim
                print_token(lines[j].substring(lastIndentLength));
            } else {
                // normal comments output raw
                output.add_token(lines[j]);
            }
        }

        // for comments of more than one line, make sure there's a new line after
        print_newline(false, preserve_statement_flags);
    }

    function handle_comment(preserve_statement_flags) {
        if (current_token.wanted_newline) {
            print_newline(false, preserve_statement_flags);
        } else {
            output.trim(true);
        }

        output.space_before_token = true;
        print_token();
        print_newline(false, preserve_statement_flags);
    }

    function handle_dot() {
        if (start_of_statement()) {
            // The conditional starts the statement if appropriate.
        } else {
            handle_whitespace_and_comments(current_token, true);
        }

        if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {
            output.space_before_token = true;
        } else {
            // allow preserved newlines before dots in general
            // force newlines on dots after close paren when break_chained - for bar().baz()
            allow_wrap_or_preserved_newline(flags.last_text === ')' && opt.break_chained_methods);
        }

        print_token();
    }

    function handle_unknown(preserve_statement_flags) {
        print_token();

        if (current_token.text[current_token.text.length - 1] === '\n') {
            print_newline(false, preserve_statement_flags);
        }
    }

    function handle_eof() {
        // Unwind any open statements
        while (flags.mode === MODE.Statement) {
            restore_mode();
        }
        handle_whitespace_and_comments(current_token);
    }
}

module.exports.Beautifier = Beautifier;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

function InputScanner(input) {
    var _input = input;
    var _input_length = _input.length;
    var _position = 0;

    this.back = function() {
        _position -= 1;
    };

    this.hasNext = function() {
        return _position < _input_length;
    };

    this.next = function() {
        var val = null;
        if (this.hasNext()) {
            val = _input.charAt(_position);
            _position += 1;
        }
        return val;
    };

    this.peek = function(index) {
        var val = null;
        index = index || 0;
        index += _position;
        if (index >= 0 && index < _input_length) {
            val = _input.charAt(index);
        }
        return val;
    };

    this.peekCharCode = function(index) {
        var val = 0;
        index = index || 0;
        index += _position;
        if (index >= 0 && index < _input_length) {
            val = _input.charCodeAt(index);
        }
        return val;
    };

    this.test = function(pattern, index) {
        index = index || 0;
        pattern.lastIndex = _position + index;
        return pattern.test(_input);
    };

    this.testChar = function(pattern, index) {
        var val = this.peek(index);
        return val !== null && pattern.test(val);
    };

    this.match = function(pattern) {
        pattern.lastIndex = _position;
        var pattern_match = pattern.exec(_input);
        if (pattern_match && pattern_match.index === _position) {
            _position += pattern_match[0].length;
        } else {
            pattern_match = null;
        }
        return pattern_match;
    };
}


module.exports.InputScanner = InputScanner;


/***/ }),
/* 3 */
/***/ (function(module, exports) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

    The MIT License (MIT)

    Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

function mergeOpts(allOptions, targetType) {
    var finalOpts = {};
    var name;

    for (name in allOptions) {
        if (name !== targetType) {
            finalOpts[name] = allOptions[name];
        }
    }

    //merge in the per type settings for the targetType
    if (targetType in allOptions) {
        for (name in allOptions[targetType]) {
            finalOpts[name] = allOptions[targetType][name];
        }
    }
    return finalOpts;
}

module.exports.mergeOpts = mergeOpts;


/***/ }),
/* 4 */
/***/ (function(module, exports) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

function OutputLine(parent) {
    var _character_count = 0;
    // use indent_count as a marker for lines that have preserved indentation
    var _indent_count = -1;

    var _items = [];
    var _empty = true;

    this.set_indent = function(level) {
        _character_count = parent.baseIndentLength + level * parent.indent_length;
        _indent_count = level;
    };

    this.get_character_count = function() {
        return _character_count;
    };

    this.is_empty = function() {
        return _empty;
    };

    this.last = function() {
        if (!this._empty) {
            return _items[_items.length - 1];
        } else {
            return null;
        }
    };

    this.push = function(input) {
        _items.push(input);
        _character_count += input.length;
        _empty = false;
    };

    this.pop = function() {
        var item = null;
        if (!_empty) {
            item = _items.pop();
            _character_count -= item.length;
            _empty = _items.length === 0;
        }
        return item;
    };

    this.remove_indent = function() {
        if (_indent_count > 0) {
            _indent_count -= 1;
            _character_count -= parent.indent_length;
        }
    };

    this.trim = function() {
        while (this.last() === ' ') {
            _items.pop();
            _character_count -= 1;
        }
        _empty = _items.length === 0;
    };

    this.toString = function() {
        var result = '';
        if (!this._empty) {
            if (_indent_count >= 0) {
                result = parent.indent_cache[_indent_count];
            }
            result += _items.join('');
        }
        return result;
    };
}

function Output(indent_string, baseIndentString) {
    baseIndentString = baseIndentString || '';
    this.indent_cache = [baseIndentString];
    this.baseIndentLength = baseIndentString.length;
    this.indent_length = indent_string.length;
    this.raw = false;

    var lines = [];
    this.baseIndentString = baseIndentString;
    this.indent_string = indent_string;
    this.previous_line = null;
    this.current_line = null;
    this.space_before_token = false;

    this.add_outputline = function() {
        this.previous_line = this.current_line;
        this.current_line = new OutputLine(this);
        lines.push(this.current_line);
    };

    // initialize
    this.add_outputline();


    this.get_line_number = function() {
        return lines.length;
    };

    // Using object instead of string to allow for later expansion of info about each line
    this.add_new_line = function(force_newline) {
        if (this.get_line_number() === 1 && this.just_added_newline()) {
            return false; // no newline on start of file
        }

        if (force_newline || !this.just_added_newline()) {
            if (!this.raw) {
                this.add_outputline();
            }
            return true;
        }

        return false;
    };

    this.get_code = function(end_with_newline, eol) {
        var sweet_code = lines.join('\n').replace(/[\r\n\t ]+$/, '');

        if (end_with_newline) {
            sweet_code += '\n';
        }

        if (eol !== '\n') {
            sweet_code = sweet_code.replace(/[\n]/g, eol);
        }

        return sweet_code;
    };

    this.set_indent = function(level) {
        // Never indent your first output indent at the start of the file
        if (lines.length > 1) {
            while (level >= this.indent_cache.length) {
                this.indent_cache.push(this.indent_cache[this.indent_cache.length - 1] + this.indent_string);
            }

            this.current_line.set_indent(level);
            return true;
        }
        this.current_line.set_indent(0);
        return false;
    };

    this.add_raw_token = function(token) {
        for (var x = 0; x < token.newlines; x++) {
            this.add_outputline();
        }
        this.current_line.push(token.whitespace_before);
        this.current_line.push(token.text);
        this.space_before_token = false;
    };

    this.add_token = function(printable_token) {
        this.add_space_before_token();
        this.current_line.push(printable_token);
    };

    this.add_space_before_token = function() {
        if (this.space_before_token && !this.just_added_newline()) {
            this.current_line.push(' ');
        }
        this.space_before_token = false;
    };

    this.remove_indent = function(index) {
        var output_length = lines.length;
        while (index < output_length) {
            lines[index].remove_indent();
            index++;
        }
    };

    this.trim = function(eat_newlines) {
        eat_newlines = (eat_newlines === undefined) ? false : eat_newlines;

        this.current_line.trim(indent_string, baseIndentString);

        while (eat_newlines && lines.length > 1 &&
            this.current_line.is_empty()) {
            lines.pop();
            this.current_line = lines[lines.length - 1];
            this.current_line.trim();
        }

        this.previous_line = lines.length > 1 ? lines[lines.length - 2] : null;
    };

    this.just_added_newline = function() {
        return this.current_line.is_empty();
    };

    this.just_added_blankline = function() {
        if (this.just_added_newline()) {
            if (lines.length === 1) {
                return true; // start of the file and newline = blank
            }

            var line = lines[lines.length - 2];
            return line.is_empty();
        }
        return false;
    };
}

module.exports.Output = Output;


/***/ }),
/* 5 */
/***/ (function(module, exports) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

function Token(type, text, newlines, whitespace_before, parent) {
    this.type = type;
    this.text = text;

    // comments_before are
    // comments that have a new line before them
    // and may or may not have a newline after
    // this is a set of comments before
    this.comments_before = /* inline comment*/ [];


    this.comments_after = []; // no new line before and newline after
    this.newlines = newlines || 0;
    this.wanted_newline = newlines > 0;
    this.whitespace_before = whitespace_before || '';
    this.parent = parent || null;
    this.opened = null;
    this.directives = null;
}

module.exports.Token = Token;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

    The MIT License (MIT)

    Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

var Beautifier = __webpack_require__(1).Beautifier;

function js_beautify(js_source_text, options) {
    var beautifier = new Beautifier(js_source_text, options);
    return beautifier.beautify();
}

module.exports = js_beautify;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

    The MIT License (MIT)

    Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

var InputScanner = __webpack_require__(2).InputScanner;
var Token = __webpack_require__(5).Token;
var acorn = __webpack_require__(0);

function trim(s) {
    return s.replace(/^\s+|\s+$/g, '');
}

function in_array(what, arr) {
    for (var i = 0; i < arr.length; i += 1) {
        if (arr[i] === what) {
            return true;
        }
    }
    return false;
}

function Tokenizer(input_string, opts) {

    var whitespace = "\n\r\t ".split('');
    var digit = /[0-9]/;
    var digit_bin = /[01]/;
    var digit_oct = /[01234567]/;
    var digit_hex = /[0123456789abcdefABCDEF]/;

    this.positionable_operators = '!= !== % & && * ** + - / : < << <= == === > >= >> >>> ? ^ | ||'.split(' ');
    var punct = this.positionable_operators.concat(
        // non-positionable operators - these do not follow operator position settings
        '! %= &= *= **= ++ += , -- -= /= :: <<= = => >>= >>>= ^= |= ~ ...'.split(' '));

    // words which should always start on new line.
    this.line_starters = 'continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,import,export'.split(',');
    var reserved_words = this.line_starters.concat(['do', 'in', 'of', 'else', 'get', 'set', 'new', 'catch', 'finally', 'typeof', 'yield', 'async', 'await', 'from', 'as']);

    //  /* ... */ comment ends with nearest */ or end of file
    var block_comment_pattern = /([\s\S]*?)((?:\*\/)|$)/g;

    // comment ends just before nearest linefeed or end of file
    var comment_pattern = /([^\n\r\u2028\u2029]*)/g;

    var directives_block_pattern = /\/\* beautify( \w+[:]\w+)+ \*\//g;
    var directive_pattern = / (\w+)[:](\w+)/g;
    var directives_end_ignore_pattern = /([\s\S]*?)((?:\/\*\sbeautify\signore:end\s\*\/)|$)/g;

    var template_pattern = /((<\?php|<\?=)[\s\S]*?\?>)|(<%[\s\S]*?%>)/g;

    var n_newlines, whitespace_before_token, in_html_comment, tokens;
    var input;

    this.tokenize = function() {
        input = new InputScanner(input_string);
        in_html_comment = false;
        tokens = [];

        var next, last;
        var token_values;
        var open = null;
        var open_stack = [];
        var comments = [];

        while (!(last && last.type === 'TK_EOF')) {
            token_values = tokenize_next();
            next = new Token(token_values[1], token_values[0], n_newlines, whitespace_before_token);
            while (next.type === 'TK_COMMENT' || next.type === 'TK_BLOCK_COMMENT' || next.type === 'TK_UNKNOWN') {
                if (next.type === 'TK_BLOCK_COMMENT') {
                    next.directives = token_values[2];
                }
                comments.push(next);
                token_values = tokenize_next();
                next = new Token(token_values[1], token_values[0], n_newlines, whitespace_before_token);
            }

            if (comments.length) {
                next.comments_before = comments;
                comments = [];
            }

            if (next.type === 'TK_START_BLOCK' || next.type === 'TK_START_EXPR') {
                next.parent = last;
                open_stack.push(open);
                open = next;
            } else if ((next.type === 'TK_END_BLOCK' || next.type === 'TK_END_EXPR') &&
                (open && (
                    (next.text === ']' && open.text === '[') ||
                    (next.text === ')' && open.text === '(') ||
                    (next.text === '}' && open.text === '{')))) {
                next.parent = open.parent;
                next.opened = open;

                open = open_stack.pop();
            }

            tokens.push(next);
            last = next;
        }

        return tokens;
    };

    function get_directives(text) {
        if (!text.match(directives_block_pattern)) {
            return null;
        }

        var directives = {};
        directive_pattern.lastIndex = 0;
        var directive_match = directive_pattern.exec(text);

        while (directive_match) {
            directives[directive_match[1]] = directive_match[2];
            directive_match = directive_pattern.exec(text);
        }

        return directives;
    }

    function tokenize_next() {
        var resulting_string;
        var whitespace_on_this_line = [];

        n_newlines = 0;
        whitespace_before_token = '';

        var c = input.next();

        if (c === null) {
            return ['', 'TK_EOF'];
        }

        var last_token;
        if (tokens.length) {
            last_token = tokens[tokens.length - 1];
        } else {
            // For the sake of tokenizing we can pretend that there was on open brace to start
            last_token = new Token('TK_START_BLOCK', '{');
        }

        while (in_array(c, whitespace)) {

            if (acorn.newline.test(c)) {
                if (!(c === '\n' && input.peek(-2) === '\r')) {
                    n_newlines += 1;
                    whitespace_on_this_line = [];
                }
            } else {
                whitespace_on_this_line.push(c);
            }

            c = input.next();

            if (c === null) {
                return ['', 'TK_EOF'];
            }
        }

        if (whitespace_on_this_line.length) {
            whitespace_before_token = whitespace_on_this_line.join('');
        }

        if (digit.test(c) || (c === '.' && input.testChar(digit))) {
            var allow_decimal = true;
            var allow_e = true;
            var local_digit = digit;

            if (c === '0' && input.testChar(/[XxOoBb]/)) {
                // switch to hex/oct/bin number, no decimal or e, just hex/oct/bin digits
                allow_decimal = false;
                allow_e = false;
                if (input.testChar(/[Bb]/)) {
                    local_digit = digit_bin;
                } else if (input.testChar(/[Oo]/)) {
                    local_digit = digit_oct;
                } else {
                    local_digit = digit_hex;
                }
                c += input.next();
            } else if (c === '.') {
                // Already have a decimal for this literal, don't allow another
                allow_decimal = false;
            } else {
                // we know this first loop will run.  It keeps the logic simpler.
                c = '';
                input.back();
            }

            // Add the digits
            while (input.testChar(local_digit)) {
                c += input.next();

                if (allow_decimal && input.peek() === '.') {
                    c += input.next();
                    allow_decimal = false;
                }

                // a = 1.e-7 is valid, so we test for . then e in one loop
                if (allow_e && input.testChar(/[Ee]/)) {
                    c += input.next();

                    if (input.testChar(/[+-]/)) {
                        c += input.next();
                    }

                    allow_e = false;
                    allow_decimal = false;
                }
            }

            return [c, 'TK_WORD'];
        }

        if (acorn.isIdentifierStart(input.peekCharCode(-1))) {
            if (input.hasNext()) {
                while (acorn.isIdentifierChar(input.peekCharCode())) {
                    c += input.next();
                    if (!input.hasNext()) {
                        break;
                    }
                }
            }

            if (!(last_token.type === 'TK_DOT' ||
                    (last_token.type === 'TK_RESERVED' && in_array(last_token.text, ['set', 'get']))) &&
                in_array(c, reserved_words)) {
                if (c === 'in' || c === 'of') { // hack for 'in' and 'of' operators
                    return [c, 'TK_OPERATOR'];
                }
                return [c, 'TK_RESERVED'];
            }

            return [c, 'TK_WORD'];
        }

        if (c === '(' || c === '[') {
            return [c, 'TK_START_EXPR'];
        }

        if (c === ')' || c === ']') {
            return [c, 'TK_END_EXPR'];
        }

        if (c === '{') {
            return [c, 'TK_START_BLOCK'];
        }

        if (c === '}') {
            return [c, 'TK_END_BLOCK'];
        }

        if (c === ';') {
            return [c, 'TK_SEMICOLON'];
        }

        if (c === '/') {
            var comment = '';
            var comment_match;
            // peek for comment /* ... */
            if (input.peek() === '*') {
                input.next();
                comment_match = input.match(block_comment_pattern);
                comment = '/*' + comment_match[0];
                var directives = get_directives(comment);
                if (directives && directives.ignore === 'start') {
                    comment_match = input.match(directives_end_ignore_pattern);
                    comment += comment_match[0];
                }
                comment = comment.replace(acorn.allLineBreaks, '\n');
                return [comment, 'TK_BLOCK_COMMENT', directives];
            }
            // peek for comment // ...
            if (input.peek() === '/') {
                input.next();
                comment_match = input.match(comment_pattern);
                comment = '//' + comment_match[0];
                return [comment, 'TK_COMMENT'];
            }

        }

        var startXmlRegExp = /<()([-a-zA-Z:0-9_.]+|{[\s\S]+?}|!\[CDATA\[[\s\S]*?\]\])(\s+{[\s\S]+?}|\s+[-a-zA-Z:0-9_.]+|\s+[-a-zA-Z:0-9_.]+\s*=\s*('[^']*'|"[^"]*"|{[\s\S]+?}))*\s*(\/?)\s*>/g;

        if (c === '`' || c === "'" || c === '"' || // string
            (
                (c === '/') || // regexp
                (opts.e4x && c === "<" && input.test(startXmlRegExp, -1)) // xml
            ) && ( // regex and xml can only appear in specific locations during parsing
                (last_token.type === 'TK_RESERVED' && in_array(last_token.text, ['return', 'case', 'throw', 'else', 'do', 'typeof', 'yield'])) ||
                (last_token.type === 'TK_END_EXPR' && last_token.text === ')' &&
                    last_token.parent && last_token.parent.type === 'TK_RESERVED' && in_array(last_token.parent.text, ['if', 'while', 'for'])) ||
                (in_array(last_token.type, ['TK_COMMENT', 'TK_START_EXPR', 'TK_START_BLOCK',
                    'TK_END_BLOCK', 'TK_OPERATOR', 'TK_EQUALS', 'TK_EOF', 'TK_SEMICOLON', 'TK_COMMA'
                ]))
            )) {

            var sep = c,
                esc = false,
                has_char_escapes = false;

            resulting_string = c;

            if (sep === '/') {
                //
                // handle regexp
                //
                var in_char_class = false;
                while (input.hasNext() &&
                    ((esc || in_char_class || input.peek() !== sep) &&
                        !input.testChar(acorn.newline))) {
                    resulting_string += input.peek();
                    if (!esc) {
                        esc = input.peek() === '\\';
                        if (input.peek() === '[') {
                            in_char_class = true;
                        } else if (input.peek() === ']') {
                            in_char_class = false;
                        }
                    } else {
                        esc = false;
                    }
                    input.next();
                }
            } else if (opts.e4x && sep === '<') {
                //
                // handle e4x xml literals
                //

                var xmlRegExp = /[\s\S]*?<(\/?)([-a-zA-Z:0-9_.]+|{[\s\S]+?}|!\[CDATA\[[\s\S]*?\]\])(\s+{[\s\S]+?}|\s+[-a-zA-Z:0-9_.]+|\s+[-a-zA-Z:0-9_.]+\s*=\s*('[^']*'|"[^"]*"|{[\s\S]+?}))*\s*(\/?)\s*>/g;
                input.back();
                var xmlStr = '';
                var match = input.match(startXmlRegExp);
                if (match) {
                    // Trim root tag to attempt to
                    var rootTag = match[2].replace(/^{\s+/, '{').replace(/\s+}$/, '}');
                    var isCurlyRoot = rootTag.indexOf('{') === 0;
                    var depth = 0;
                    while (match) {
                        var isEndTag = !!match[1];
                        var tagName = match[2];
                        var isSingletonTag = (!!match[match.length - 1]) || (tagName.slice(0, 8) === "![CDATA[");
                        if (!isSingletonTag &&
                            (tagName === rootTag || (isCurlyRoot && tagName.replace(/^{\s+/, '{').replace(/\s+}$/, '}')))) {
                            if (isEndTag) {
                                --depth;
                            } else {
                                ++depth;
                            }
                        }
                        xmlStr += match[0];
                        if (depth <= 0) {
                            break;
                        }
                        match = input.match(xmlRegExp);
                    }
                    // if we didn't close correctly, keep unformatted.
                    if (!match) {
                        xmlStr += input.match(/[\s\S]*/g)[0];
                    }
                    xmlStr = xmlStr.replace(acorn.allLineBreaks, '\n');
                    return [xmlStr, "TK_STRING"];
                }
            } else {
                //
                // handle string
                //
                var parse_string = function(delimiter, allow_unescaped_newlines, start_sub) {
                    // Template strings can travers lines without escape characters.
                    // Other strings cannot
                    var current_char;
                    while (input.hasNext()) {
                        current_char = input.peek();
                        if (!(esc || (current_char !== delimiter &&
                                (allow_unescaped_newlines || !acorn.newline.test(current_char))))) {
                            break;
                        }

                        // Handle \r\n linebreaks after escapes or in template strings
                        if ((esc || allow_unescaped_newlines) && acorn.newline.test(current_char)) {
                            if (current_char === '\r' && input.peek(1) === '\n') {
                                input.next();
                                current_char = input.peek();
                            }
                            resulting_string += '\n';
                        } else {
                            resulting_string += current_char;
                        }

                        if (esc) {
                            if (current_char === 'x' || current_char === 'u') {
                                has_char_escapes = true;
                            }
                            esc = false;
                        } else {
                            esc = current_char === '\\';
                        }

                        input.next();

                        if (start_sub && resulting_string.indexOf(start_sub, resulting_string.length - start_sub.length) !== -1) {
                            if (delimiter === '`') {
                                parse_string('}', allow_unescaped_newlines, '`');
                            } else {
                                parse_string('`', allow_unescaped_newlines, '${');
                            }

                            if (input.hasNext()) {
                                resulting_string += input.next();
                            }
                        }
                    }
                };

                if (sep === '`') {
                    parse_string('`', true, '${');
                } else {
                    parse_string(sep);
                }
            }

            if (has_char_escapes && opts.unescape_strings) {
                resulting_string = unescape_string(resulting_string);
            }

            if (input.peek() === sep) {
                resulting_string += sep;
                input.next();

                if (sep === '/') {
                    // regexps may have modifiers /regexp/MOD , so fetch those, too
                    // Only [gim] are valid, but if the user puts in garbage, do what we can to take it.
                    while (input.hasNext() && acorn.isIdentifierStart(input.peekCharCode())) {
                        resulting_string += input.next();
                    }
                }
            }
            return [resulting_string, 'TK_STRING'];
        }

        if (c === '#') {

            if (tokens.length === 0 && input.peek() === '!') {
                // shebang
                resulting_string = c;
                while (input.hasNext() && c !== '\n') {
                    c = input.next();
                    resulting_string += c;
                }
                return [trim(resulting_string) + '\n', 'TK_UNKNOWN'];
            }



            // Spidermonkey-specific sharp variables for circular references
            // https://developer.mozilla.org/En/Sharp_variables_in_JavaScript
            // http://mxr.mozilla.org/mozilla-central/source/js/src/jsscan.cpp around line 1935
            var sharp = '#';
            if (input.hasNext() && input.testChar(digit)) {
                do {
                    c = input.next();
                    sharp += c;
                } while (input.hasNext() && c !== '#' && c !== '=');
                if (c === '#') {
                    //
                } else if (input.peek() === '[' && input.peek(1) === ']') {
                    sharp += '[]';
                    input.next();
                    input.next();
                } else if (input.peek() === '{' && input.peek(1) === '}') {
                    sharp += '{}';
                    input.next();
                    input.next();
                }
                return [sharp, 'TK_WORD'];
            }
        }

        if (c === '<' && (input.peek() === '?' || input.peek() === '%')) {
            input.back();
            var template_match = input.match(template_pattern);
            if (template_match) {
                c = template_match[0];
                c = c.replace(acorn.allLineBreaks, '\n');
                return [c, 'TK_STRING'];
            }
        }

        if (c === '<' && input.match(/\!--/g)) {
            c = '<!--';
            while (input.hasNext() && !input.testChar(acorn.newline)) {
                c += input.next();
            }
            in_html_comment = true;
            return [c, 'TK_COMMENT'];
        }

        if (c === '-' && in_html_comment && input.match(/->/g)) {
            in_html_comment = false;
            return ['-->', 'TK_COMMENT'];
        }

        if (c === '.') {
            if (input.peek() === '.' && input.peek(1) === '.') {
                c += input.next() + input.next();
                return [c, 'TK_OPERATOR'];
            }
            return [c, 'TK_DOT'];
        }

        if (in_array(c, punct)) {
            while (input.hasNext() && in_array(c + input.peek(), punct)) {
                c += input.next();
                if (!input.hasNext()) {
                    break;
                }
            }

            if (c === ',') {
                return [c, 'TK_COMMA'];
            } else if (c === '=') {
                return [c, 'TK_EQUALS'];
            } else {
                return [c, 'TK_OPERATOR'];
            }
        }

        return [c, 'TK_UNKNOWN'];
    }


    function unescape_string(s) {
        // You think that a regex would work for this
        // return s.replace(/\\x([0-9a-f]{2})/gi, function(match, val) {
        //         return String.fromCharCode(parseInt(val, 16));
        //     })
        // However, dealing with '\xff', '\\xff', '\\\xff' makes this more fun.
        var out = '',
            escaped = 0;

        var input_scan = new InputScanner(s);
        var matched = null;

        while (input_scan.hasNext()) {
            // Keep any whitespace, non-slash characters
            // also keep slash pairs.
            matched = input_scan.match(/([\s]|[^\\]|\\\\)+/g);

            if (matched) {
                out += matched[0];
            }

            if (input_scan.peek() === '\\') {
                input_scan.next();
                if (input_scan.peek() === 'x') {
                    matched = input_scan.match(/x([0-9A-Fa-f]{2})/g);
                } else if (input_scan.peek() === 'u') {
                    matched = input_scan.match(/u([0-9A-Fa-f]{4})/g);
                } else {
                    out += '\\';
                    if (input_scan.hasNext()) {
                        out += input_scan.next();
                    }
                    continue;
                }

                // If there's some error decoding, return the original string
                if (!matched) {
                    return s;
                }

                escaped = parseInt(matched[1], 16);

                if (escaped > 0x7e && escaped <= 0xff && matched[0].indexOf('x') === 0) {
                    // we bail out on \x7f..\xff,
                    // leaving whole string escaped,
                    // as it's probably completely binary
                    return s;
                } else if (escaped >= 0x00 && escaped < 0x20) {
                    // leave 0x00...0x1f escaped
                    out += '\\' + matched[0];
                    continue;
                } else if (escaped === 0x22 || escaped === 0x27 || escaped === 0x5c) {
                    // single-quote, apostrophe, backslash - escape these
                    out += '\\' + String.fromCharCode(escaped);
                } else {
                    out += String.fromCharCode(escaped);
                }
            }
        }

        return out;
    }
}

module.exports.Tokenizer = Tokenizer;

/***/ })
/******/ ]);
var js_beautify = legacy_beautify_js;
/* Footer */
if (typeof define === "function" && define.amd) {
    // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
    define([], function() {
        return { js_beautify: js_beautify };
    });
} else if (typeof exports !== "undefined") {
    // Add support for CommonJS. Just put this file somewhere on your require.paths
    // and you will be able to `var js_beautify = require("beautify").js_beautify`.
    exports.js_beautify = js_beautify;
} else if (typeof window !== "undefined") {
    // If we're running a web page and don't have either of the above, add our one global
    window.js_beautify = js_beautify;
} else if (typeof global !== "undefined") {
    // If we don't even have window, try global.
    global.js_beautify = js_beautify;
}

}());

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],176:[function(require,module,exports){
//! moment.js
//! version : 2.19.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

var hookCallback;

function hooks () {
    return hookCallback.apply(null, arguments);
}

// This is done to register the method called with moment()
// without creating circular dependencies.
function setHookCallback (callback) {
    hookCallback = callback;
}

function isArray(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
}

function isObject(input) {
    // IE8 will treat undefined and null as object if it wasn't for
    // input != null
    return input != null && Object.prototype.toString.call(input) === '[object Object]';
}

function isObjectEmpty(obj) {
    if (Object.getOwnPropertyNames) {
        return (Object.getOwnPropertyNames(obj).length === 0);
    } else {
        var k;
        for (k in obj) {
            if (obj.hasOwnProperty(k)) {
                return false;
            }
        }
        return true;
    }
}

function isUndefined(input) {
    return input === void 0;
}

function isNumber(input) {
    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
}

function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
}

function map(arr, fn) {
    var res = [], i;
    for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
    }
    return res;
}

function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
}

function extend(a, b) {
    for (var i in b) {
        if (hasOwnProp(b, i)) {
            a[i] = b[i];
        }
    }

    if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
    }

    if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
    }

    return a;
}

function createUTC (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
}

function defaultParsingFlags() {
    // We need to deep clone this object.
    return {
        empty           : false,
        unusedTokens    : [],
        unusedInput     : [],
        overflow        : -2,
        charsLeftOver   : 0,
        nullInput       : false,
        invalidMonth    : null,
        invalidFormat   : false,
        userInvalidated : false,
        iso             : false,
        parsedDateParts : [],
        meridiem        : null,
        rfc2822         : false,
        weekdayMismatch : false
    };
}

function getParsingFlags(m) {
    if (m._pf == null) {
        m._pf = defaultParsingFlags();
    }
    return m._pf;
}

var some;
if (Array.prototype.some) {
    some = Array.prototype.some;
} else {
    some = function (fun) {
        var t = Object(this);
        var len = t.length >>> 0;

        for (var i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
                return true;
            }
        }

        return false;
    };
}

function isValid(m) {
    if (m._isValid == null) {
        var flags = getParsingFlags(m);
        var parsedParts = some.call(flags.parsedDateParts, function (i) {
            return i != null;
        });
        var isNowValid = !isNaN(m._d.getTime()) &&
            flags.overflow < 0 &&
            !flags.empty &&
            !flags.invalidMonth &&
            !flags.invalidWeekday &&
            !flags.weekdayMismatch &&
            !flags.nullInput &&
            !flags.invalidFormat &&
            !flags.userInvalidated &&
            (!flags.meridiem || (flags.meridiem && parsedParts));

        if (m._strict) {
            isNowValid = isNowValid &&
                flags.charsLeftOver === 0 &&
                flags.unusedTokens.length === 0 &&
                flags.bigHour === undefined;
        }

        if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
        }
        else {
            return isNowValid;
        }
    }
    return m._isValid;
}

function createInvalid (flags) {
    var m = createUTC(NaN);
    if (flags != null) {
        extend(getParsingFlags(m), flags);
    }
    else {
        getParsingFlags(m).userInvalidated = true;
    }

    return m;
}

// Plugins that add properties should also add the key here (null value),
// so we can properly clone ourselves.
var momentProperties = hooks.momentProperties = [];

function copyConfig(to, from) {
    var i, prop, val;

    if (!isUndefined(from._isAMomentObject)) {
        to._isAMomentObject = from._isAMomentObject;
    }
    if (!isUndefined(from._i)) {
        to._i = from._i;
    }
    if (!isUndefined(from._f)) {
        to._f = from._f;
    }
    if (!isUndefined(from._l)) {
        to._l = from._l;
    }
    if (!isUndefined(from._strict)) {
        to._strict = from._strict;
    }
    if (!isUndefined(from._tzm)) {
        to._tzm = from._tzm;
    }
    if (!isUndefined(from._isUTC)) {
        to._isUTC = from._isUTC;
    }
    if (!isUndefined(from._offset)) {
        to._offset = from._offset;
    }
    if (!isUndefined(from._pf)) {
        to._pf = getParsingFlags(from);
    }
    if (!isUndefined(from._locale)) {
        to._locale = from._locale;
    }

    if (momentProperties.length > 0) {
        for (i = 0; i < momentProperties.length; i++) {
            prop = momentProperties[i];
            val = from[prop];
            if (!isUndefined(val)) {
                to[prop] = val;
            }
        }
    }

    return to;
}

var updateInProgress = false;

// Moment prototype object
function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
    if (!this.isValid()) {
        this._d = new Date(NaN);
    }
    // Prevent infinite loop in case updateOffset creates new moment
    // objects.
    if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
    }
}

function isMoment (obj) {
    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
}

function absFloor (number) {
    if (number < 0) {
        // -0 -> 0
        return Math.ceil(number) || 0;
    } else {
        return Math.floor(number);
    }
}

function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion,
        value = 0;

    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
    }

    return value;
}

// compare two arrays, return the number of differences
function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length),
        lengthDiff = Math.abs(array1.length - array2.length),
        diffs = 0,
        i;
    for (i = 0; i < len; i++) {
        if ((dontConvert && array1[i] !== array2[i]) ||
            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
            diffs++;
        }
    }
    return diffs + lengthDiff;
}

function warn(msg) {
    if (hooks.suppressDeprecationWarnings === false &&
            (typeof console !==  'undefined') && console.warn) {
        console.warn('Deprecation warning: ' + msg);
    }
}

function deprecate(msg, fn) {
    var firstTime = true;

    return extend(function () {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
            var args = [];
            var arg;
            for (var i = 0; i < arguments.length; i++) {
                arg = '';
                if (typeof arguments[i] === 'object') {
                    arg += '\n[' + i + '] ';
                    for (var key in arguments[0]) {
                        arg += key + ': ' + arguments[0][key] + ', ';
                    }
                    arg = arg.slice(0, -2); // Remove trailing comma and space
                } else {
                    arg = arguments[i];
                }
                args.push(arg);
            }
            warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
            firstTime = false;
        }
        return fn.apply(this, arguments);
    }, fn);
}

var deprecations = {};

function deprecateSimple(name, msg) {
    if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
    }
    if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
    }
}

hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;

function isFunction(input) {
    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
}

function set (config) {
    var prop, i;
    for (i in config) {
        prop = config[i];
        if (isFunction(prop)) {
            this[i] = prop;
        } else {
            this['_' + i] = prop;
        }
    }
    this._config = config;
    // Lenient ordinal parsing accepts just a number in addition to
    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
    // TODO: Remove "ordinalParse" fallback in next major release.
    this._dayOfMonthOrdinalParseLenient = new RegExp(
        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
            '|' + (/\d{1,2}/).source);
}

function mergeConfigs(parentConfig, childConfig) {
    var res = extend({}, parentConfig), prop;
    for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
            } else {
                delete res[prop];
            }
        }
    }
    for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])) {
            // make sure changes to properties don't modify parent config
            res[prop] = extend({}, res[prop]);
        }
    }
    return res;
}

function Locale(config) {
    if (config != null) {
        this.set(config);
    }
}

var keys;

if (Object.keys) {
    keys = Object.keys;
} else {
    keys = function (obj) {
        var i, res = [];
        for (i in obj) {
            if (hasOwnProp(obj, i)) {
                res.push(i);
            }
        }
        return res;
    };
}

var defaultCalendar = {
    sameDay : '[Today at] LT',
    nextDay : '[Tomorrow at] LT',
    nextWeek : 'dddd [at] LT',
    lastDay : '[Yesterday at] LT',
    lastWeek : '[Last] dddd [at] LT',
    sameElse : 'L'
};

function calendar (key, mom, now) {
    var output = this._calendar[key] || this._calendar['sameElse'];
    return isFunction(output) ? output.call(mom, now) : output;
}

var defaultLongDateFormat = {
    LTS  : 'h:mm:ss A',
    LT   : 'h:mm A',
    L    : 'MM/DD/YYYY',
    LL   : 'MMMM D, YYYY',
    LLL  : 'MMMM D, YYYY h:mm A',
    LLLL : 'dddd, MMMM D, YYYY h:mm A'
};

function longDateFormat (key) {
    var format = this._longDateFormat[key],
        formatUpper = this._longDateFormat[key.toUpperCase()];

    if (format || !formatUpper) {
        return format;
    }

    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
        return val.slice(1);
    });

    return this._longDateFormat[key];
}

var defaultInvalidDate = 'Invalid date';

function invalidDate () {
    return this._invalidDate;
}

var defaultOrdinal = '%d';
var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

function ordinal (number) {
    return this._ordinal.replace('%d', number);
}

var defaultRelativeTime = {
    future : 'in %s',
    past   : '%s ago',
    s  : 'a few seconds',
    ss : '%d seconds',
    m  : 'a minute',
    mm : '%d minutes',
    h  : 'an hour',
    hh : '%d hours',
    d  : 'a day',
    dd : '%d days',
    M  : 'a month',
    MM : '%d months',
    y  : 'a year',
    yy : '%d years'
};

function relativeTime (number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return (isFunction(output)) ?
        output(number, withoutSuffix, string, isFuture) :
        output.replace(/%d/i, number);
}

function pastFuture (diff, output) {
    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
}

var aliases = {};

function addUnitAlias (unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
}

function normalizeUnits(units) {
    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
}

function normalizeObjectUnits(inputObject) {
    var normalizedInput = {},
        normalizedProp,
        prop;

    for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
            }
        }
    }

    return normalizedInput;
}

var priorities = {};

function addUnitPriority(unit, priority) {
    priorities[unit] = priority;
}

function getPrioritizedUnits(unitsObj) {
    var units = [];
    for (var u in unitsObj) {
        units.push({unit: u, priority: priorities[u]});
    }
    units.sort(function (a, b) {
        return a.priority - b.priority;
    });
    return units;
}

function zeroFill(number, targetLength, forceSign) {
    var absNumber = '' + Math.abs(number),
        zerosToFill = targetLength - absNumber.length,
        sign = number >= 0;
    return (sign ? (forceSign ? '+' : '') : '-') +
        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}

var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

var formatFunctions = {};

var formatTokenFunctions = {};

// token:    'M'
// padded:   ['MM', 2]
// ordinal:  'Mo'
// callback: function () { this.month() + 1 }
function addFormatToken (token, padded, ordinal, callback) {
    var func = callback;
    if (typeof callback === 'string') {
        func = function () {
            return this[callback]();
        };
    }
    if (token) {
        formatTokenFunctions[token] = func;
    }
    if (padded) {
        formatTokenFunctions[padded[0]] = function () {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
    }
    if (ordinal) {
        formatTokenFunctions[ordinal] = function () {
            return this.localeData().ordinal(func.apply(this, arguments), token);
        };
    }
}

function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
    }
    return input.replace(/\\/g, '');
}

function makeFormatFunction(format) {
    var array = format.match(formattingTokens), i, length;

    for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
        } else {
            array[i] = removeFormattingTokens(array[i]);
        }
    }

    return function (mom) {
        var output = '', i;
        for (i = 0; i < length; i++) {
            output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
        }
        return output;
    };
}

// format date using native date object
function formatMoment(m, format) {
    if (!m.isValid()) {
        return m.localeData().invalidDate();
    }

    format = expandFormat(format, m.localeData());
    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

    return formatFunctions[format](m);
}

function expandFormat(format, locale) {
    var i = 5;

    function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
    }

    localFormattingTokens.lastIndex = 0;
    while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
    }

    return format;
}

var match1         = /\d/;            //       0 - 9
var match2         = /\d\d/;          //      00 - 99
var match3         = /\d{3}/;         //     000 - 999
var match4         = /\d{4}/;         //    0000 - 9999
var match6         = /[+-]?\d{6}/;    // -999999 - 999999
var match1to2      = /\d\d?/;         //       0 - 99
var match3to4      = /\d\d\d\d?/;     //     999 - 9999
var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
var match1to3      = /\d{1,3}/;       //       0 - 999
var match1to4      = /\d{1,4}/;       //       0 - 9999
var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

var matchUnsigned  = /\d+/;           //       0 - inf
var matchSigned    = /[+-]?\d+/;      //    -inf - inf

var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

// any word (or two) characters or numbers including two/three word month in arabic.
// includes scottish gaelic two word and hyphenated months
var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


var regexes = {};

function addRegexToken (token, regex, strictRegex) {
    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
        return (isStrict && strictRegex) ? strictRegex : regex;
    };
}

function getParseRegexForToken (token, config) {
    if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
    }

    return regexes[token](config._strict, config._locale);
}

// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
function unescapeFormat(s) {
    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
    }));
}

function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
}

var tokens = {};

function addParseToken (token, callback) {
    var i, func = callback;
    if (typeof token === 'string') {
        token = [token];
    }
    if (isNumber(callback)) {
        func = function (input, array) {
            array[callback] = toInt(input);
        };
    }
    for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
    }
}

function addWeekParseToken (token, callback) {
    addParseToken(token, function (input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
    });
}

function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
    }
}

var YEAR = 0;
var MONTH = 1;
var DATE = 2;
var HOUR = 3;
var MINUTE = 4;
var SECOND = 5;
var MILLISECOND = 6;
var WEEK = 7;
var WEEKDAY = 8;

// FORMATTING

addFormatToken('Y', 0, 0, function () {
    var y = this.year();
    return y <= 9999 ? '' + y : '+' + y;
});

addFormatToken(0, ['YY', 2], 0, function () {
    return this.year() % 100;
});

addFormatToken(0, ['YYYY',   4],       0, 'year');
addFormatToken(0, ['YYYYY',  5],       0, 'year');
addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

// ALIASES

addUnitAlias('year', 'y');

// PRIORITIES

addUnitPriority('year', 1);

// PARSING

addRegexToken('Y',      matchSigned);
addRegexToken('YY',     match1to2, match2);
addRegexToken('YYYY',   match1to4, match4);
addRegexToken('YYYYY',  match1to6, match6);
addRegexToken('YYYYYY', match1to6, match6);

addParseToken(['YYYYY', 'YYYYYY'], YEAR);
addParseToken('YYYY', function (input, array) {
    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken('YY', function (input, array) {
    array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken('Y', function (input, array) {
    array[YEAR] = parseInt(input, 10);
});

// HELPERS

function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
}

function isLeapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
}

// HOOKS

hooks.parseTwoDigitYear = function (input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
};

// MOMENTS

var getSetYear = makeGetSet('FullYear', true);

function getIsLeapYear () {
    return isLeapYear(this.year());
}

function makeGetSet (unit, keepTime) {
    return function (value) {
        if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
        } else {
            return get(this, unit);
        }
    };
}

function get (mom, unit) {
    return mom.isValid() ?
        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
}

function set$1 (mom, unit, value) {
    if (mom.isValid() && !isNaN(value)) {
        if (unit === 'FullYear' && isLeapYear(mom.year())) {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
        }
        else {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }
}

// MOMENTS

function stringGet (units) {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
        return this[units]();
    }
    return this;
}


function stringSet (units, value) {
    if (typeof units === 'object') {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units);
        for (var i = 0; i < prioritized.length; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
        }
    } else {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units](value);
        }
    }
    return this;
}

function mod(n, x) {
    return ((n % x) + x) % x;
}

var indexOf;

if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
} else {
    indexOf = function (o) {
        // I know
        var i;
        for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
                return i;
            }
        }
        return -1;
    };
}

function daysInMonth(year, month) {
    if (isNaN(year) || isNaN(month)) {
        return NaN;
    }
    var modMonth = mod(month, 12);
    year += (month - modMonth) / 12;
    return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
}

// FORMATTING

addFormatToken('M', ['MM', 2], 'Mo', function () {
    return this.month() + 1;
});

addFormatToken('MMM', 0, 0, function (format) {
    return this.localeData().monthsShort(this, format);
});

addFormatToken('MMMM', 0, 0, function (format) {
    return this.localeData().months(this, format);
});

// ALIASES

addUnitAlias('month', 'M');

// PRIORITY

addUnitPriority('month', 8);

// PARSING

addRegexToken('M',    match1to2);
addRegexToken('MM',   match1to2, match2);
addRegexToken('MMM',  function (isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
});
addRegexToken('MMMM', function (isStrict, locale) {
    return locale.monthsRegex(isStrict);
});

addParseToken(['M', 'MM'], function (input, array) {
    array[MONTH] = toInt(input) - 1;
});

addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    // if we didn't find a month name, mark the date as invalid.
    if (month != null) {
        array[MONTH] = month;
    } else {
        getParsingFlags(config).invalidMonth = input;
    }
});

// LOCALES

var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
function localeMonths (m, format) {
    if (!m) {
        return isArray(this._months) ? this._months :
            this._months['standalone'];
    }
    return isArray(this._months) ? this._months[m.month()] :
        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
}

var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
function localeMonthsShort (m, format) {
    if (!m) {
        return isArray(this._monthsShort) ? this._monthsShort :
            this._monthsShort['standalone'];
    }
    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
}

function handleStrictParse(monthName, format, strict) {
    var i, ii, mom, llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) {
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0; i < 12; ++i) {
            mom = createUTC([2000, i]);
            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'MMM') {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'MMM') {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeMonthsParse (monthName, format, strict) {
    var i, mom, regex;

    if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format, strict);
    }

    if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
    }

    // TODO: add sorting
    // Sorting makes sure if one month (or abbr) is a prefix of another
    // see sorting in computeMonthsParse
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }
        if (!strict && !this._monthsParse[i]) {
            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
            return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
            return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
        }
    }
}

// MOMENTS

function setMonth (mom, value) {
    var dayOfMonth;

    if (!mom.isValid()) {
        // No op
        return mom;
    }

    if (typeof value === 'string') {
        if (/^\d+$/.test(value)) {
            value = toInt(value);
        } else {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (!isNumber(value)) {
                return mom;
            }
        }
    }

    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
    return mom;
}

function getSetMonth (value) {
    if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
    } else {
        return get(this, 'Month');
    }
}

function getDaysInMonth () {
    return daysInMonth(this.year(), this.month());
}

var defaultMonthsShortRegex = matchWord;
function monthsShortRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsShortStrictRegex;
        } else {
            return this._monthsShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsShortRegex')) {
            this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ?
            this._monthsShortStrictRegex : this._monthsShortRegex;
    }
}

var defaultMonthsRegex = matchWord;
function monthsRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsStrictRegex;
        } else {
            return this._monthsRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsRegex')) {
            this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ?
            this._monthsStrictRegex : this._monthsRegex;
    }
}

function computeMonthsParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom;
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
    }
    // Sorting makes sure if one month (or abbr) is a prefix of another it
    // will match the longer piece.
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
    }
    for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
}

function createDate (y, m, d, h, M, s, ms) {
    // can't just apply() to create a date:
    // https://stackoverflow.com/q/181348
    var date = new Date(y, m, d, h, M, s, ms);

    // the date constructor remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
        date.setFullYear(y);
    }
    return date;
}

function createUTCDate (y) {
    var date = new Date(Date.UTC.apply(null, arguments));

    // the Date.UTC function remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
        date.setUTCFullYear(y);
    }
    return date;
}

// start-of-first-week - start-of-year
function firstWeekOffset(year, dow, doy) {
    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
        fwd = 7 + dow - doy,
        // first-week day local weekday -- which local weekday is fwd
        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

    return -fwdlw + fwd - 1;
}

// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7,
        weekOffset = firstWeekOffset(year, dow, doy),
        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
        resYear, resDayOfYear;

    if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
    } else {
        resYear = year;
        resDayOfYear = dayOfYear;
    }

    return {
        year: resYear,
        dayOfYear: resDayOfYear
    };
}

function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
        resWeek, resYear;

    if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
    } else {
        resYear = mom.year();
        resWeek = week;
    }

    return {
        week: resWeek,
        year: resYear
    };
}

function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy),
        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}

// FORMATTING

addFormatToken('w', ['ww', 2], 'wo', 'week');
addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

// ALIASES

addUnitAlias('week', 'w');
addUnitAlias('isoWeek', 'W');

// PRIORITIES

addUnitPriority('week', 5);
addUnitPriority('isoWeek', 5);

// PARSING

addRegexToken('w',  match1to2);
addRegexToken('ww', match1to2, match2);
addRegexToken('W',  match1to2);
addRegexToken('WW', match1to2, match2);

addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
});

// HELPERS

// LOCALES

function localeWeek (mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
}

var defaultLocaleWeek = {
    dow : 0, // Sunday is the first day of the week.
    doy : 6  // The week that contains Jan 1st is the first week of the year.
};

function localeFirstDayOfWeek () {
    return this._week.dow;
}

function localeFirstDayOfYear () {
    return this._week.doy;
}

// MOMENTS

function getSetWeek (input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, 'd');
}

function getSetISOWeek (input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, 'd');
}

// FORMATTING

addFormatToken('d', 0, 'do', 'day');

addFormatToken('dd', 0, 0, function (format) {
    return this.localeData().weekdaysMin(this, format);
});

addFormatToken('ddd', 0, 0, function (format) {
    return this.localeData().weekdaysShort(this, format);
});

addFormatToken('dddd', 0, 0, function (format) {
    return this.localeData().weekdays(this, format);
});

addFormatToken('e', 0, 0, 'weekday');
addFormatToken('E', 0, 0, 'isoWeekday');

// ALIASES

addUnitAlias('day', 'd');
addUnitAlias('weekday', 'e');
addUnitAlias('isoWeekday', 'E');

// PRIORITY
addUnitPriority('day', 11);
addUnitPriority('weekday', 11);
addUnitPriority('isoWeekday', 11);

// PARSING

addRegexToken('d',    match1to2);
addRegexToken('e',    match1to2);
addRegexToken('E',    match1to2);
addRegexToken('dd',   function (isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
});
addRegexToken('ddd',   function (isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
});
addRegexToken('dddd',   function (isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
});

addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
    var weekday = config._locale.weekdaysParse(input, token, config._strict);
    // if we didn't get a weekday name, mark the date as invalid
    if (weekday != null) {
        week.d = weekday;
    } else {
        getParsingFlags(config).invalidWeekday = input;
    }
});

addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
    week[token] = toInt(input);
});

// HELPERS

function parseWeekday(input, locale) {
    if (typeof input !== 'string') {
        return input;
    }

    if (!isNaN(input)) {
        return parseInt(input, 10);
    }

    input = locale.weekdaysParse(input);
    if (typeof input === 'number') {
        return input;
    }

    return null;
}

function parseIsoWeekday(input, locale) {
    if (typeof input === 'string') {
        return locale.weekdaysParse(input) % 7 || 7;
    }
    return isNaN(input) ? null : input;
}

// LOCALES

var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
function localeWeekdays (m, format) {
    if (!m) {
        return isArray(this._weekdays) ? this._weekdays :
            this._weekdays['standalone'];
    }
    return isArray(this._weekdays) ? this._weekdays[m.day()] :
        this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
}

var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
function localeWeekdaysShort (m) {
    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}

var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
function localeWeekdaysMin (m) {
    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}

function handleStrictParse$1(weekdayName, format, strict) {
    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];

        for (i = 0; i < 7; ++i) {
            mom = createUTC([2000, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'dddd') {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'dddd') {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeWeekdaysParse (weekdayName, format, strict) {
    var i, mom, regex;

    if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format, strict);
    }

    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
    }

    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already

        mom = createUTC([2000, 1]).day(i);
        if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
        }
        if (!this._weekdaysParse[i]) {
            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
        }
    }
}

// MOMENTS

function getSetDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
    } else {
        return day;
    }
}

function getSetLocaleDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, 'd');
}

function getSetISODayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }

    // behaves the same as moment#day except
    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
    // as a setter, sunday should belong to the previous week.

    if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
    } else {
        return this.day() || 7;
    }
}

var defaultWeekdaysRegex = matchWord;
function weekdaysRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysStrictRegex;
        } else {
            return this._weekdaysRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ?
            this._weekdaysStrictRegex : this._weekdaysRegex;
    }
}

var defaultWeekdaysShortRegex = matchWord;
function weekdaysShortRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysShortStrictRegex;
        } else {
            return this._weekdaysShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ?
            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
}

var defaultWeekdaysMinRegex = matchWord;
function weekdaysMinRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysMinStrictRegex;
        } else {
            return this._weekdaysMinRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ?
            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    }
}


function computeWeekdaysParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom, minp, shortp, longp;
    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);
        minp = this.weekdaysMin(mom, '');
        shortp = this.weekdaysShort(mom, '');
        longp = this.weekdays(mom, '');
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
    }
    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
    // will match the longer piece.
    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 7; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;

    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
}

// FORMATTING

function hFormat() {
    return this.hours() % 12 || 12;
}

function kFormat() {
    return this.hours() || 24;
}

addFormatToken('H', ['HH', 2], 0, 'hour');
addFormatToken('h', ['hh', 2], 0, hFormat);
addFormatToken('k', ['kk', 2], 0, kFormat);

addFormatToken('hmm', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});

addFormatToken('hmmss', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

addFormatToken('Hmm', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2);
});

addFormatToken('Hmmss', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

function meridiem (token, lowercase) {
    addFormatToken(token, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
}

meridiem('a', true);
meridiem('A', false);

// ALIASES

addUnitAlias('hour', 'h');

// PRIORITY
addUnitPriority('hour', 13);

// PARSING

function matchMeridiem (isStrict, locale) {
    return locale._meridiemParse;
}

addRegexToken('a',  matchMeridiem);
addRegexToken('A',  matchMeridiem);
addRegexToken('H',  match1to2);
addRegexToken('h',  match1to2);
addRegexToken('k',  match1to2);
addRegexToken('HH', match1to2, match2);
addRegexToken('hh', match1to2, match2);
addRegexToken('kk', match1to2, match2);

addRegexToken('hmm', match3to4);
addRegexToken('hmmss', match5to6);
addRegexToken('Hmm', match3to4);
addRegexToken('Hmmss', match5to6);

addParseToken(['H', 'HH'], HOUR);
addParseToken(['k', 'kk'], function (input, array, config) {
    var kInput = toInt(input);
    array[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(['a', 'A'], function (input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
});
addParseToken(['h', 'hh'], function (input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
});
addParseToken('Hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
});
addParseToken('Hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
});

// LOCALES

function localeIsPM (input) {
    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
    // Using charAt should be more compatible.
    return ((input + '').toLowerCase().charAt(0) === 'p');
}

var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
function localeMeridiem (hours, minutes, isLower) {
    if (hours > 11) {
        return isLower ? 'pm' : 'PM';
    } else {
        return isLower ? 'am' : 'AM';
    }
}


// MOMENTS

// Setting the hour should keep the time, because the user explicitly
// specified which hour he wants. So trying to maintain the same hour (in
// a new timezone) makes sense. Adding/subtracting hours does not follow
// this rule.
var getSetHour = makeGetSet('Hours', true);

// months
// week
// weekdays
// meridiem
var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
    relativeTime: defaultRelativeTime,

    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,

    week: defaultLocaleWeek,

    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,

    meridiemParse: defaultLocaleMeridiemParse
};

// internal storage for locale config files
var locales = {};
var localeFamilies = {};
var globalLocale;

function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
}

// pick the locale from the array
// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
function chooseLocale(names) {
    var i = 0, j, next, locale, split;

    while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;
        while (j > 0) {
            locale = loadLocale(split.slice(0, j).join('-'));
            if (locale) {
                return locale;
            }
            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                //the next array item is better than a shallower substring of this one
                break;
            }
            j--;
        }
        i++;
    }
    return null;
}

function loadLocale(name) {
    var oldLocale = null;
    // TODO: Find a better way to register and load all the locales in Node
    if (!locales[name] && (typeof module !== 'undefined') &&
            module && module.exports) {
        try {
            oldLocale = globalLocale._abbr;
            var aliasedRequire = require;
            aliasedRequire('./locale/' + name);
            getSetGlobalLocale(oldLocale);
        } catch (e) {}
    }
    return locales[name];
}

// This function will load locale and then set the global locale.  If
// no arguments are passed in, it will simply return the current global
// locale key.
function getSetGlobalLocale (key, values) {
    var data;
    if (key) {
        if (isUndefined(values)) {
            data = getLocale(key);
        }
        else {
            data = defineLocale(key, values);
        }

        if (data) {
            // moment.duration._locale = moment._locale = data;
            globalLocale = data;
        }
    }

    return globalLocale._abbr;
}

function defineLocale (name, config) {
    if (config !== null) {
        var parentConfig = baseConfig;
        config.abbr = name;
        if (locales[name] != null) {
            deprecateSimple('defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                    'an existing locale. moment.defineLocale(localeName, ' +
                    'config) should only be used for creating a new locale ' +
                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
            parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
            } else {
                if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                    name: name,
                    config: config
                });
                return null;
            }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
            localeFamilies[name].forEach(function (x) {
                defineLocale(x.name, x.config);
            });
        }

        // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.
        getSetGlobalLocale(name);


        return locales[name];
    } else {
        // useful for testing
        delete locales[name];
        return null;
    }
}

function updateLocale(name, config) {
    if (config != null) {
        var locale, parentConfig = baseConfig;
        // MERGE
        if (locales[name] != null) {
            parentConfig = locales[name]._config;
        }
        config = mergeConfigs(parentConfig, config);
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale;

        // backwards compat for now: also set the locale
        getSetGlobalLocale(name);
    } else {
        // pass null for config to unupdate, useful for tests
        if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
            } else if (locales[name] != null) {
                delete locales[name];
            }
        }
    }
    return locales[name];
}

// returns locale data
function getLocale (key) {
    var locale;

    if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
    }

    if (!key) {
        return globalLocale;
    }

    if (!isArray(key)) {
        //short-circuit everything else
        locale = loadLocale(key);
        if (locale) {
            return locale;
        }
        key = [key];
    }

    return chooseLocale(key);
}

function listLocales() {
    return keys(locales);
}

function checkOverflow (m) {
    var overflow;
    var a = m._a;

    if (a && getParsingFlags(m).overflow === -2) {
        overflow =
            a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
            a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
            a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
            a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
            -1;

        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
        }
        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
        }
        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
        }

        getParsingFlags(m).overflow = overflow;
    }

    return m;
}

// Pick the first defined of two or three arguments.
function defaults(a, b, c) {
    if (a != null) {
        return a;
    }
    if (b != null) {
        return b;
    }
    return c;
}

function currentDateArray(config) {
    // hooks is actually the exported moment object
    var nowValue = new Date(hooks.now());
    if (config._useUTC) {
        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
    }
    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}

// convert an array to a date.
// the array should mirror the parameters below
// note: all values past the year are optional and will default to the lowest possible value.
// [year, month, day , hour, minute, second, millisecond]
function configFromArray (config) {
    var i, date, input = [], currentDate, yearToUse;

    if (config._d) {
        return;
    }

    currentDate = currentDateArray(config);

    //compute day of the year from weeks and weekdays
    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
    }

    //if the day of the year is set, figure out what it is
    if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
        }

        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
    }

    // Default to current date.
    // * if no year, month, day of month are given, default to today
    // * if day of month is given, default month and year
    // * if month is given, default only year
    // * if year is given, don't default anything
    for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
    }

    // Zero out whatever was not defaulted, including time
    for (; i < 7; i++) {
        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
    }

    // Check for 24:00:00.000
    if (config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
    }

    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
    // Apply timezone offset from input. The actual utcOffset can be changed
    // with parseZone.
    if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }

    if (config._nextDay) {
        config._a[HOUR] = 24;
    }

    // check for mismatching day of week
    if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== config._d.getDay()) {
        getParsingFlags(config).weekdayMismatch = true;
    }
}

function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4;

        // TODO: We need to take the current isoWeekYear, but that depends on
        // how we interpret now (local, utc, fixed offset). So create
        // a now version of current config (take local/utc/offset flags, and
        // create now).
        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);
        if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
        }
    } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;

        var curWeek = weekOfYear(createLocal(), dow, doy);

        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

        // Default to current week.
        week = defaults(w.w, curWeek.week);

        if (w.d != null) {
            // weekday -- low day numbers are considered next week
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
            }
        } else if (w.e != null) {
            // local weekday -- counting starts from begining of week
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
            }
        } else {
            // default to begining of week
            weekday = dow;
        }
    }
    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
    } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }
}

// iso 8601 regex
// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

var isoDates = [
    ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
    ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
    ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
    ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
    ['YYYY-DDD', /\d{4}-\d{3}/],
    ['YYYY-MM', /\d{4}-\d\d/, false],
    ['YYYYYYMMDD', /[+-]\d{10}/],
    ['YYYYMMDD', /\d{8}/],
    // YYYYMM is NOT allowed by the standard
    ['GGGG[W]WWE', /\d{4}W\d{3}/],
    ['GGGG[W]WW', /\d{4}W\d{2}/, false],
    ['YYYYDDD', /\d{7}/]
];

// iso time formats and regexes
var isoTimes = [
    ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
    ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
    ['HH:mm:ss', /\d\d:\d\d:\d\d/],
    ['HH:mm', /\d\d:\d\d/],
    ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
    ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
    ['HHmmss', /\d\d\d\d\d\d/],
    ['HHmm', /\d\d\d\d/],
    ['HH', /\d\d/]
];

var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

// date from iso format
function configFromISO(config) {
    var i, l,
        string = config._i,
        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
        allowTime, dateFormat, timeFormat, tzFormat;

    if (match) {
        getParsingFlags(config).iso = true;

        for (i = 0, l = isoDates.length; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
            }
        }
        if (dateFormat == null) {
            config._isValid = false;
            return;
        }
        if (match[3]) {
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(match[3])) {
                    // match[2] should be 'T' or space
                    timeFormat = (match[2] || ' ') + isoTimes[i][0];
                    break;
                }
            }
            if (timeFormat == null) {
                config._isValid = false;
                return;
            }
        }
        if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
        }
        if (match[4]) {
            if (tzRegex.exec(match[4])) {
                tzFormat = 'Z';
            } else {
                config._isValid = false;
                return;
            }
        }
        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
        configFromStringAndFormat(config);
    } else {
        config._isValid = false;
    }
}

// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
    var result = [
        untruncateYear(yearStr),
        defaultLocaleMonthsShort.indexOf(monthStr),
        parseInt(dayStr, 10),
        parseInt(hourStr, 10),
        parseInt(minuteStr, 10)
    ];

    if (secondStr) {
        result.push(parseInt(secondStr, 10));
    }

    return result;
}

function untruncateYear(yearStr) {
    var year = parseInt(yearStr, 10);
    if (year <= 49) {
        return 2000 + year;
    } else if (year <= 999) {
        return 1900 + year;
    }
    return year;
}

function preprocessRFC2822(s) {
    // Remove comments and folding whitespace and replace multiple-spaces with a single space
    return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').trim();
}

function checkWeekday(weekdayStr, parsedInput, config) {
    if (weekdayStr) {
        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
            weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
        if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
        }
    }
    return true;
}

var obsOffsets = {
    UT: 0,
    GMT: 0,
    EDT: -4 * 60,
    EST: -5 * 60,
    CDT: -5 * 60,
    CST: -6 * 60,
    MDT: -6 * 60,
    MST: -7 * 60,
    PDT: -7 * 60,
    PST: -8 * 60
};

function calculateOffset(obsOffset, militaryOffset, numOffset) {
    if (obsOffset) {
        return obsOffsets[obsOffset];
    } else if (militaryOffset) {
        // the only allowed military tz is Z
        return 0;
    } else {
        var hm = parseInt(numOffset, 10);
        var m = hm % 100, h = (hm - m) / 100;
        return h * 60 + m;
    }
}

// date and time from ref 2822 format
function configFromRFC2822(config) {
    var match = rfc2822.exec(preprocessRFC2822(config._i));
    if (match) {
        var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
        if (!checkWeekday(match[1], parsedArray, config)) {
            return;
        }

        config._a = parsedArray;
        config._tzm = calculateOffset(match[8], match[9], match[10]);

        config._d = createUTCDate.apply(null, config._a);
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

        getParsingFlags(config).rfc2822 = true;
    } else {
        config._isValid = false;
    }
}

// date from iso format or fallback
function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);

    if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
    }

    configFromISO(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    configFromRFC2822(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    // Final attempt, use Input Fallback
    hooks.createFromInputFallback(config);
}

hooks.createFromInputFallback = deprecate(
    'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
    'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
    'discouraged and will be removed in an upcoming major release. Please refer to ' +
    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
    function (config) {
        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    }
);

// constant that refers to the ISO standard
hooks.ISO_8601 = function () {};

// constant that refers to the RFC 2822 form
hooks.RFC_2822 = function () {};

// date from string and format string
function configFromStringAndFormat(config) {
    // TODO: Move this to another part of the creation flow to prevent circular deps
    if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
    }
    if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
    }
    config._a = [];
    getParsingFlags(config).empty = true;

    // This array is used to make a Date, either with `new Date` or `Date.UTC`
    var string = '' + config._i,
        i, parsedInput, tokens, token, skipped,
        stringLength = string.length,
        totalParsedInputLength = 0;

    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

    for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
        // console.log('token', token, 'parsedInput', parsedInput,
        //         'regex', getParseRegexForToken(token, config));
        if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
        }
        // don't parse if it's not a known token
        if (formatTokenFunctions[token]) {
            if (parsedInput) {
                getParsingFlags(config).empty = false;
            }
            else {
                getParsingFlags(config).unusedTokens.push(token);
            }
            addTimeToArrayFromToken(token, parsedInput, config);
        }
        else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token);
        }
    }

    // add remaining unparsed input length to the string
    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
    }

    // clear _12h flag if hour is <= 12
    if (config._a[HOUR] <= 12 &&
        getParsingFlags(config).bigHour === true &&
        config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
    }

    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem;
    // handle meridiem
    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

    configFromArray(config);
    checkOverflow(config);
}


function meridiemFixWrap (locale, hour, meridiem) {
    var isPm;

    if (meridiem == null) {
        // nothing to do
        return hour;
    }
    if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
        // Fallback
        isPm = locale.isPM(meridiem);
        if (isPm && hour < 12) {
            hour += 12;
        }
        if (!isPm && hour === 12) {
            hour = 0;
        }
        return hour;
    } else {
        // this is not supposed to happen
        return hour;
    }
}

// date from string and array of format strings
function configFromStringAndArray(config) {
    var tempConfig,
        bestMoment,

        scoreToBeat,
        i,
        currentScore;

    if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
    }

    for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);

        if (!isValid(tempConfig)) {
            continue;
        }

        // if there is any input that was not parsed add a penalty for that format
        currentScore += getParsingFlags(tempConfig).charsLeftOver;

        //or tokens
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

        getParsingFlags(tempConfig).score = currentScore;

        if (scoreToBeat == null || currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
        }
    }

    extend(config, bestMoment || tempConfig);
}

function configFromObject(config) {
    if (config._d) {
        return;
    }

    var i = normalizeObjectUnits(config._i);
    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
        return obj && parseInt(obj, 10);
    });

    configFromArray(config);
}

function createFromConfig (config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));
    if (res._nextDay) {
        // Adding is smart enough around DST
        res.add(1, 'd');
        res._nextDay = undefined;
    }

    return res;
}

function prepareConfig (config) {
    var input = config._i,
        format = config._f;

    config._locale = config._locale || getLocale(config._l);

    if (input === null || (format === undefined && input === '')) {
        return createInvalid({nullInput: true});
    }

    if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
    }

    if (isMoment(input)) {
        return new Moment(checkOverflow(input));
    } else if (isDate(input)) {
        config._d = input;
    } else if (isArray(format)) {
        configFromStringAndArray(config);
    } else if (format) {
        configFromStringAndFormat(config);
    }  else {
        configFromInput(config);
    }

    if (!isValid(config)) {
        config._d = null;
    }

    return config;
}

function configFromInput(config) {
    var input = config._i;
    if (isUndefined(input)) {
        config._d = new Date(hooks.now());
    } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
    } else if (typeof input === 'string') {
        configFromString(config);
    } else if (isArray(input)) {
        config._a = map(input.slice(0), function (obj) {
            return parseInt(obj, 10);
        });
        configFromArray(config);
    } else if (isObject(input)) {
        configFromObject(config);
    } else if (isNumber(input)) {
        // from milliseconds
        config._d = new Date(input);
    } else {
        hooks.createFromInputFallback(config);
    }
}

function createLocalOrUTC (input, format, locale, strict, isUTC) {
    var c = {};

    if (locale === true || locale === false) {
        strict = locale;
        locale = undefined;
    }

    if ((isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)) {
        input = undefined;
    }
    // object construction must be done this way.
    // https://github.com/moment/moment/issues/1423
    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;

    return createFromConfig(c);
}

function createLocal (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
}

var prototypeMin = deprecate(
    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

var prototypeMax = deprecate(
    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

// Pick a moment m from moments so that m[fn](other) is true for all
// other. This relies on the function fn to be transitive.
//
// moments should either be an array of moment objects or an array, whose
// first element is an array of moment objects.
function pickBy(fn, moments) {
    var res, i;
    if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
    }
    if (!moments.length) {
        return createLocal();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
        }
    }
    return res;
}

// TODO: Use [].sort instead?
function min () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isBefore', args);
}

function max () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isAfter', args);
}

var now = function () {
    return Date.now ? Date.now() : +(new Date());
};

var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

function isDurationValid(m) {
    for (var key in m) {
        if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
        }
    }

    var unitHasDecimal = false;
    for (var i = 0; i < ordering.length; ++i) {
        if (m[ordering[i]]) {
            if (unitHasDecimal) {
                return false; // only allow non-integers for smallest unit
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                unitHasDecimal = true;
            }
        }
    }

    return true;
}

function isValid$1() {
    return this._isValid;
}

function createInvalid$1() {
    return createDuration(NaN);
}

function Duration (duration) {
    var normalizedInput = normalizeObjectUnits(duration),
        years = normalizedInput.year || 0,
        quarters = normalizedInput.quarter || 0,
        months = normalizedInput.month || 0,
        weeks = normalizedInput.week || 0,
        days = normalizedInput.day || 0,
        hours = normalizedInput.hour || 0,
        minutes = normalizedInput.minute || 0,
        seconds = normalizedInput.second || 0,
        milliseconds = normalizedInput.millisecond || 0;

    this._isValid = isDurationValid(normalizedInput);

    // representation for dateAddRemove
    this._milliseconds = +milliseconds +
        seconds * 1e3 + // 1000
        minutes * 6e4 + // 1000 * 60
        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
    // Because of dateAddRemove treats 24 hours as different from a
    // day when working around DST, we need to store them separately
    this._days = +days +
        weeks * 7;
    // It is impossible to translate months into days without knowing
    // which months you are are talking about, so we have to store
    // it separately.
    this._months = +months +
        quarters * 3 +
        years * 12;

    this._data = {};

    this._locale = getLocale();

    this._bubble();
}

function isDuration (obj) {
    return obj instanceof Duration;
}

function absRound (number) {
    if (number < 0) {
        return Math.round(-1 * number) * -1;
    } else {
        return Math.round(number);
    }
}

// FORMATTING

function offset (token, separator) {
    addFormatToken(token, 0, 0, function () {
        var offset = this.utcOffset();
        var sign = '+';
        if (offset < 0) {
            offset = -offset;
            sign = '-';
        }
        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
    });
}

offset('Z', ':');
offset('ZZ', '');

// PARSING

addRegexToken('Z',  matchShortOffset);
addRegexToken('ZZ', matchShortOffset);
addParseToken(['Z', 'ZZ'], function (input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
});

// HELPERS

// timezone chunker
// '+10:00' > ['10',  '00']
// '-1530'  > ['-15', '30']
var chunkOffset = /([\+\-]|\d\d)/gi;

function offsetFromString(matcher, string) {
    var matches = (string || '').match(matcher);

    if (matches === null) {
        return null;
    }

    var chunk   = matches[matches.length - 1] || [];
    var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
    var minutes = +(parts[1] * 60) + toInt(parts[2]);

    return minutes === 0 ?
      0 :
      parts[0] === '+' ? minutes : -minutes;
}

// Return a moment from input, that is local/utc/zone equivalent to model.
function cloneWithOffset(input, model) {
    var res, diff;
    if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        // Use low-level api, because this fn is low-level api.
        res._d.setTime(res._d.valueOf() + diff);
        hooks.updateOffset(res, false);
        return res;
    } else {
        return createLocal(input).local();
    }
}

function getDateOffset (m) {
    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
    // https://github.com/moment/moment/pull/1871
    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
}

// HOOKS

// This function will be called whenever a moment is mutated.
// It is intended to keep the offset in sync with the timezone.
hooks.updateOffset = function () {};

// MOMENTS

// keepLocalTime = true means only change the timezone, without
// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
// +0200, so we adjust the time as needed, to be valid.
//
// Keeping the time actually adds/subtracts (one hour)
// from the actual represented time. That is why we call updateOffset
// a second time. In case it wants us to change the offset again
// _changeInProgress == true case, then we have to adjust, because
// there is no such time in the given timezone.
function getSetOffset (input, keepLocalTime, keepMinutes) {
    var offset = this._offset || 0,
        localAdjust;
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    if (input != null) {
        if (typeof input === 'string') {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
                return this;
            }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
            this.add(localAdjust, 'm');
        }
        if (offset !== input) {
            if (!keepLocalTime || this._changeInProgress) {
                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
            } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
            }
        }
        return this;
    } else {
        return this._isUTC ? offset : getDateOffset(this);
    }
}

function getSetZone (input, keepLocalTime) {
    if (input != null) {
        if (typeof input !== 'string') {
            input = -input;
        }

        this.utcOffset(input, keepLocalTime);

        return this;
    } else {
        return -this.utcOffset();
    }
}

function setOffsetToUTC (keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
}

function setOffsetToLocal (keepLocalTime) {
    if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;

        if (keepLocalTime) {
            this.subtract(getDateOffset(this), 'm');
        }
    }
    return this;
}

function setOffsetToParsedOffset () {
    if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
    } else if (typeof this._i === 'string') {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
            this.utcOffset(tZone);
        }
        else {
            this.utcOffset(0, true);
        }
    }
    return this;
}

function hasAlignedHourOffset (input) {
    if (!this.isValid()) {
        return false;
    }
    input = input ? createLocal(input).utcOffset() : 0;

    return (this.utcOffset() - input) % 60 === 0;
}

function isDaylightSavingTime () {
    return (
        this.utcOffset() > this.clone().month(0).utcOffset() ||
        this.utcOffset() > this.clone().month(5).utcOffset()
    );
}

function isDaylightSavingTimeShifted () {
    if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
    }

    var c = {};

    copyConfig(c, this);
    c = prepareConfig(c);

    if (c._a) {
        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() &&
            compareArrays(c._a, other.toArray()) > 0;
    } else {
        this._isDSTShifted = false;
    }

    return this._isDSTShifted;
}

function isLocal () {
    return this.isValid() ? !this._isUTC : false;
}

function isUtcOffset () {
    return this.isValid() ? this._isUTC : false;
}

function isUtc () {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
}

// ASP.NET json date format regex
var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
// and further modified to allow for strings containing both week and day
var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

function createDuration (input, key) {
    var duration = input,
        // matching against regexp is expensive, do it on demand
        match = null,
        sign,
        ret,
        diffRes;

    if (isDuration(input)) {
        duration = {
            ms : input._milliseconds,
            d  : input._days,
            M  : input._months
        };
    } else if (isNumber(input)) {
        duration = {};
        if (key) {
            duration[key] = input;
        } else {
            duration.milliseconds = input;
        }
    } else if (!!(match = aspNetRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y  : 0,
            d  : toInt(match[DATE])                         * sign,
            h  : toInt(match[HOUR])                         * sign,
            m  : toInt(match[MINUTE])                       * sign,
            s  : toInt(match[SECOND])                       * sign,
            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
        };
    } else if (!!(match = isoRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : (match[1] === '+') ? 1 : 1;
        duration = {
            y : parseIso(match[2], sign),
            M : parseIso(match[3], sign),
            w : parseIso(match[4], sign),
            d : parseIso(match[5], sign),
            h : parseIso(match[6], sign),
            m : parseIso(match[7], sign),
            s : parseIso(match[8], sign)
        };
    } else if (duration == null) {// checks for null or undefined
        duration = {};
    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
    }

    ret = new Duration(duration);

    if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
    }

    return ret;
}

createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;

function parseIso (inp, sign) {
    // We'd normally use ~~inp for this, but unfortunately it also
    // converts floats to ints.
    // inp may be undefined, so careful calling replace on it.
    var res = inp && parseFloat(inp.replace(',', '.'));
    // apply sign while we're at it
    return (isNaN(res) ? 0 : res) * sign;
}

function positiveMomentsDifference(base, other) {
    var res = {milliseconds: 0, months: 0};

    res.months = other.month() - base.month() +
        (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
    }

    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

    return res;
}

function momentsDifference(base, other) {
    var res;
    if (!(base.isValid() && other.isValid())) {
        return {milliseconds: 0, months: 0};
    }

    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
    } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
    }

    return res;
}

// TODO: remove 'name' arg after deprecation is removed
function createAdder(direction, name) {
    return function (val, period) {
        var dur, tmp;
        //invert the arguments, but complain about it
        if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
            tmp = val; val = period; period = tmp;
        }

        val = typeof val === 'string' ? +val : val;
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
    };
}

function addSubtract (mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds,
        days = absRound(duration._days),
        months = absRound(duration._months);

    if (!mom.isValid()) {
        // No op
        return;
    }

    updateOffset = updateOffset == null ? true : updateOffset;

    if (months) {
        setMonth(mom, get(mom, 'Month') + months * isAdding);
    }
    if (days) {
        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
    }
    if (milliseconds) {
        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
    }
    if (updateOffset) {
        hooks.updateOffset(mom, days || months);
    }
}

var add      = createAdder(1, 'add');
var subtract = createAdder(-1, 'subtract');

function getCalendarFormat(myMoment, now) {
    var diff = myMoment.diff(now, 'days', true);
    return diff < -6 ? 'sameElse' :
            diff < -1 ? 'lastWeek' :
            diff < 0 ? 'lastDay' :
            diff < 1 ? 'sameDay' :
            diff < 2 ? 'nextDay' :
            diff < 7 ? 'nextWeek' : 'sameElse';
}

function calendar$1 (time, formats) {
    // We want to compare the start of today, vs this.
    // Getting start-of-today depends on whether we're local/utc/offset or not.
    var now = time || createLocal(),
        sod = cloneWithOffset(now, this).startOf('day'),
        format = hooks.calendarFormat(this, sod) || 'sameElse';

    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
}

function clone () {
    return new Moment(this);
}

function isAfter (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() > localInput.valueOf();
    } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
}

function isBefore (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() < localInput.valueOf();
    } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
}

function isBetween (from, to, units, inclusivity) {
    inclusivity = inclusivity || '()';
    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
}

function isSame (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input),
        inputMs;
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(units || 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() === localInput.valueOf();
    } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
}

function isSameOrAfter (input, units) {
    return this.isSame(input, units) || this.isAfter(input,units);
}

function isSameOrBefore (input, units) {
    return this.isSame(input, units) || this.isBefore(input,units);
}

function diff (input, units, asFloat) {
    var that,
        zoneDelta,
        delta, output;

    if (!this.isValid()) {
        return NaN;
    }

    that = cloneWithOffset(input, this);

    if (!that.isValid()) {
        return NaN;
    }

    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

    units = normalizeUnits(units);

    switch (units) {
        case 'year': output = monthDiff(this, that) / 12; break;
        case 'month': output = monthDiff(this, that); break;
        case 'quarter': output = monthDiff(this, that) / 3; break;
        case 'second': output = (this - that) / 1e3; break; // 1000
        case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
        case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
        case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
        case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
        default: output = this - that;
    }

    return asFloat ? output : absFloor(output);
}

function monthDiff (a, b) {
    // difference in months
    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
        // b is in (anchor - 1 month, anchor + 1 month)
        anchor = a.clone().add(wholeMonthDiff, 'months'),
        anchor2, adjust;

    if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor - anchor2);
    } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor2 - anchor);
    }

    //check for negative zero, return zero if negative zero
    return -(wholeMonthDiff + adjust) || 0;
}

hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

function toString () {
    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
}

function toISOString() {
    if (!this.isValid()) {
        return null;
    }
    var m = this.clone().utc();
    if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
    }
    if (isFunction(Date.prototype.toISOString)) {
        // native implementation is ~50x faster, use it when we can
        return this.toDate().toISOString();
    }
    return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
}

/**
 * Return a human readable representation of a moment that can
 * also be evaluated to get a new moment which is the same
 *
 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
 */
function inspect () {
    if (!this.isValid()) {
        return 'moment.invalid(/* ' + this._i + ' */)';
    }
    var func = 'moment';
    var zone = '';
    if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
        zone = 'Z';
    }
    var prefix = '[' + func + '("]';
    var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
    var datetime = '-MM-DD[T]HH:mm:ss.SSS';
    var suffix = zone + '[")]';

    return this.format(prefix + year + datetime + suffix);
}

function format (inputString) {
    if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
    }
    var output = formatMoment(this, inputString);
    return this.localeData().postformat(output);
}

function from (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function fromNow (withoutSuffix) {
    return this.from(createLocal(), withoutSuffix);
}

function to (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function toNow (withoutSuffix) {
    return this.to(createLocal(), withoutSuffix);
}

// If passed a locale key, it will set the locale for this
// instance.  Otherwise, it will return the locale configuration
// variables for this instance.
function locale (key) {
    var newLocaleData;

    if (key === undefined) {
        return this._locale._abbr;
    } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
            this._locale = newLocaleData;
        }
        return this;
    }
}

var lang = deprecate(
    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
    function (key) {
        if (key === undefined) {
            return this.localeData();
        } else {
            return this.locale(key);
        }
    }
);

function localeData () {
    return this._locale;
}

function startOf (units) {
    units = normalizeUnits(units);
    // the following switch intentionally omits break keywords
    // to utilize falling through the cases.
    switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
        case 'date':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
    }

    // weeks are a special case
    if (units === 'week') {
        this.weekday(0);
    }
    if (units === 'isoWeek') {
        this.isoWeekday(1);
    }

    // quarters are also special
    if (units === 'quarter') {
        this.month(Math.floor(this.month() / 3) * 3);
    }

    return this;
}

function endOf (units) {
    units = normalizeUnits(units);
    if (units === undefined || units === 'millisecond') {
        return this;
    }

    // 'date' is an alias for 'day', so it should be considered as such.
    if (units === 'date') {
        units = 'day';
    }

    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
}

function valueOf () {
    return this._d.valueOf() - ((this._offset || 0) * 60000);
}

function unix () {
    return Math.floor(this.valueOf() / 1000);
}

function toDate () {
    return new Date(this.valueOf());
}

function toArray () {
    var m = this;
    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
}

function toObject () {
    var m = this;
    return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
    };
}

function toJSON () {
    // new Date(NaN).toJSON() === null
    return this.isValid() ? this.toISOString() : null;
}

function isValid$2 () {
    return isValid(this);
}

function parsingFlags () {
    return extend({}, getParsingFlags(this));
}

function invalidAt () {
    return getParsingFlags(this).overflow;
}

function creationData() {
    return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
    };
}

// FORMATTING

addFormatToken(0, ['gg', 2], 0, function () {
    return this.weekYear() % 100;
});

addFormatToken(0, ['GG', 2], 0, function () {
    return this.isoWeekYear() % 100;
});

function addWeekYearFormatToken (token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
}

addWeekYearFormatToken('gggg',     'weekYear');
addWeekYearFormatToken('ggggg',    'weekYear');
addWeekYearFormatToken('GGGG',  'isoWeekYear');
addWeekYearFormatToken('GGGGG', 'isoWeekYear');

// ALIASES

addUnitAlias('weekYear', 'gg');
addUnitAlias('isoWeekYear', 'GG');

// PRIORITY

addUnitPriority('weekYear', 1);
addUnitPriority('isoWeekYear', 1);


// PARSING

addRegexToken('G',      matchSigned);
addRegexToken('g',      matchSigned);
addRegexToken('GG',     match1to2, match2);
addRegexToken('gg',     match1to2, match2);
addRegexToken('GGGG',   match1to4, match4);
addRegexToken('gggg',   match1to4, match4);
addRegexToken('GGGGG',  match1to6, match6);
addRegexToken('ggggg',  match1to6, match6);

addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
    week[token.substr(0, 2)] = toInt(input);
});

addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
    week[token] = hooks.parseTwoDigitYear(input);
});

// MOMENTS

function getSetWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy);
}

function getSetISOWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input, this.isoWeek(), this.isoWeekday(), 1, 4);
}

function getISOWeeksInYear () {
    return weeksInYear(this.year(), 1, 4);
}

function getWeeksInYear () {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}

function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;
    if (input == null) {
        return weekOfYear(this, dow, doy).year;
    } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
            week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
}

function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
}

// FORMATTING

addFormatToken('Q', 0, 'Qo', 'quarter');

// ALIASES

addUnitAlias('quarter', 'Q');

// PRIORITY

addUnitPriority('quarter', 7);

// PARSING

addRegexToken('Q', match1);
addParseToken('Q', function (input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
});

// MOMENTS

function getSetQuarter (input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}

// FORMATTING

addFormatToken('D', ['DD', 2], 'Do', 'date');

// ALIASES

addUnitAlias('date', 'D');

// PRIOROITY
addUnitPriority('date', 9);

// PARSING

addRegexToken('D',  match1to2);
addRegexToken('DD', match1to2, match2);
addRegexToken('Do', function (isStrict, locale) {
    // TODO: Remove "ordinalParse" fallback in next major release.
    return isStrict ?
      (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
      locale._dayOfMonthOrdinalParseLenient;
});

addParseToken(['D', 'DD'], DATE);
addParseToken('Do', function (input, array) {
    array[DATE] = toInt(input.match(match1to2)[0], 10);
});

// MOMENTS

var getSetDayOfMonth = makeGetSet('Date', true);

// FORMATTING

addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

// ALIASES

addUnitAlias('dayOfYear', 'DDD');

// PRIORITY
addUnitPriority('dayOfYear', 4);

// PARSING

addRegexToken('DDD',  match1to3);
addRegexToken('DDDD', match3);
addParseToken(['DDD', 'DDDD'], function (input, array, config) {
    config._dayOfYear = toInt(input);
});

// HELPERS

// MOMENTS

function getSetDayOfYear (input) {
    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
}

// FORMATTING

addFormatToken('m', ['mm', 2], 0, 'minute');

// ALIASES

addUnitAlias('minute', 'm');

// PRIORITY

addUnitPriority('minute', 14);

// PARSING

addRegexToken('m',  match1to2);
addRegexToken('mm', match1to2, match2);
addParseToken(['m', 'mm'], MINUTE);

// MOMENTS

var getSetMinute = makeGetSet('Minutes', false);

// FORMATTING

addFormatToken('s', ['ss', 2], 0, 'second');

// ALIASES

addUnitAlias('second', 's');

// PRIORITY

addUnitPriority('second', 15);

// PARSING

addRegexToken('s',  match1to2);
addRegexToken('ss', match1to2, match2);
addParseToken(['s', 'ss'], SECOND);

// MOMENTS

var getSetSecond = makeGetSet('Seconds', false);

// FORMATTING

addFormatToken('S', 0, 0, function () {
    return ~~(this.millisecond() / 100);
});

addFormatToken(0, ['SS', 2], 0, function () {
    return ~~(this.millisecond() / 10);
});

addFormatToken(0, ['SSS', 3], 0, 'millisecond');
addFormatToken(0, ['SSSS', 4], 0, function () {
    return this.millisecond() * 10;
});
addFormatToken(0, ['SSSSS', 5], 0, function () {
    return this.millisecond() * 100;
});
addFormatToken(0, ['SSSSSS', 6], 0, function () {
    return this.millisecond() * 1000;
});
addFormatToken(0, ['SSSSSSS', 7], 0, function () {
    return this.millisecond() * 10000;
});
addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
    return this.millisecond() * 100000;
});
addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
    return this.millisecond() * 1000000;
});


// ALIASES

addUnitAlias('millisecond', 'ms');

// PRIORITY

addUnitPriority('millisecond', 16);

// PARSING

addRegexToken('S',    match1to3, match1);
addRegexToken('SS',   match1to3, match2);
addRegexToken('SSS',  match1to3, match3);

var token;
for (token = 'SSSS'; token.length <= 9; token += 'S') {
    addRegexToken(token, matchUnsigned);
}

function parseMs(input, array) {
    array[MILLISECOND] = toInt(('0.' + input) * 1000);
}

for (token = 'S'; token.length <= 9; token += 'S') {
    addParseToken(token, parseMs);
}
// MOMENTS

var getSetMillisecond = makeGetSet('Milliseconds', false);

// FORMATTING

addFormatToken('z',  0, 0, 'zoneAbbr');
addFormatToken('zz', 0, 0, 'zoneName');

// MOMENTS

function getZoneAbbr () {
    return this._isUTC ? 'UTC' : '';
}

function getZoneName () {
    return this._isUTC ? 'Coordinated Universal Time' : '';
}

var proto = Moment.prototype;

proto.add               = add;
proto.calendar          = calendar$1;
proto.clone             = clone;
proto.diff              = diff;
proto.endOf             = endOf;
proto.format            = format;
proto.from              = from;
proto.fromNow           = fromNow;
proto.to                = to;
proto.toNow             = toNow;
proto.get               = stringGet;
proto.invalidAt         = invalidAt;
proto.isAfter           = isAfter;
proto.isBefore          = isBefore;
proto.isBetween         = isBetween;
proto.isSame            = isSame;
proto.isSameOrAfter     = isSameOrAfter;
proto.isSameOrBefore    = isSameOrBefore;
proto.isValid           = isValid$2;
proto.lang              = lang;
proto.locale            = locale;
proto.localeData        = localeData;
proto.max               = prototypeMax;
proto.min               = prototypeMin;
proto.parsingFlags      = parsingFlags;
proto.set               = stringSet;
proto.startOf           = startOf;
proto.subtract          = subtract;
proto.toArray           = toArray;
proto.toObject          = toObject;
proto.toDate            = toDate;
proto.toISOString       = toISOString;
proto.inspect           = inspect;
proto.toJSON            = toJSON;
proto.toString          = toString;
proto.unix              = unix;
proto.valueOf           = valueOf;
proto.creationData      = creationData;

// Year
proto.year       = getSetYear;
proto.isLeapYear = getIsLeapYear;

// Week Year
proto.weekYear    = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;

// Quarter
proto.quarter = proto.quarters = getSetQuarter;

// Month
proto.month       = getSetMonth;
proto.daysInMonth = getDaysInMonth;

// Week
proto.week           = proto.weeks        = getSetWeek;
proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
proto.weeksInYear    = getWeeksInYear;
proto.isoWeeksInYear = getISOWeeksInYear;

// Day
proto.date       = getSetDayOfMonth;
proto.day        = proto.days             = getSetDayOfWeek;
proto.weekday    = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear  = getSetDayOfYear;

// Hour
proto.hour = proto.hours = getSetHour;

// Minute
proto.minute = proto.minutes = getSetMinute;

// Second
proto.second = proto.seconds = getSetSecond;

// Millisecond
proto.millisecond = proto.milliseconds = getSetMillisecond;

// Offset
proto.utcOffset            = getSetOffset;
proto.utc                  = setOffsetToUTC;
proto.local                = setOffsetToLocal;
proto.parseZone            = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST                = isDaylightSavingTime;
proto.isLocal              = isLocal;
proto.isUtcOffset          = isUtcOffset;
proto.isUtc                = isUtc;
proto.isUTC                = isUtc;

// Timezone
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;

// Deprecations
proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

function createUnix (input) {
    return createLocal(input * 1000);
}

function createInZone () {
    return createLocal.apply(null, arguments).parseZone();
}

function preParsePostFormat (string) {
    return string;
}

var proto$1 = Locale.prototype;

proto$1.calendar        = calendar;
proto$1.longDateFormat  = longDateFormat;
proto$1.invalidDate     = invalidDate;
proto$1.ordinal         = ordinal;
proto$1.preparse        = preParsePostFormat;
proto$1.postformat      = preParsePostFormat;
proto$1.relativeTime    = relativeTime;
proto$1.pastFuture      = pastFuture;
proto$1.set             = set;

// Month
proto$1.months            =        localeMonths;
proto$1.monthsShort       =        localeMonthsShort;
proto$1.monthsParse       =        localeMonthsParse;
proto$1.monthsRegex       = monthsRegex;
proto$1.monthsShortRegex  = monthsShortRegex;

// Week
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;

// Day of Week
proto$1.weekdays       =        localeWeekdays;
proto$1.weekdaysMin    =        localeWeekdaysMin;
proto$1.weekdaysShort  =        localeWeekdaysShort;
proto$1.weekdaysParse  =        localeWeekdaysParse;

proto$1.weekdaysRegex       =        weekdaysRegex;
proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

// Hours
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;

function get$1 (format, index, field, setter) {
    var locale = getLocale();
    var utc = createUTC().set(setter, index);
    return locale[field](utc, format);
}

function listMonthsImpl (format, index, field) {
    if (isNumber(format)) {
        index = format;
        format = undefined;
    }

    format = format || '';

    if (index != null) {
        return get$1(format, index, field, 'month');
    }

    var i;
    var out = [];
    for (i = 0; i < 12; i++) {
        out[i] = get$1(format, i, field, 'month');
    }
    return out;
}

// ()
// (5)
// (fmt, 5)
// (fmt)
// (true)
// (true, 5)
// (true, fmt, 5)
// (true, fmt)
function listWeekdaysImpl (localeSorted, format, index, field) {
    if (typeof localeSorted === 'boolean') {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    } else {
        format = localeSorted;
        index = format;
        localeSorted = false;

        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    }

    var locale = getLocale(),
        shift = localeSorted ? locale._week.dow : 0;

    if (index != null) {
        return get$1(format, (index + shift) % 7, field, 'day');
    }

    var i;
    var out = [];
    for (i = 0; i < 7; i++) {
        out[i] = get$1(format, (i + shift) % 7, field, 'day');
    }
    return out;
}

function listMonths (format, index) {
    return listMonthsImpl(format, index, 'months');
}

function listMonthsShort (format, index) {
    return listMonthsImpl(format, index, 'monthsShort');
}

function listWeekdays (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
}

function listWeekdaysShort (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
}

function listWeekdaysMin (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
}

getSetGlobalLocale('en', {
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (toInt(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    }
});

// Side effect imports
hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

var mathAbs = Math.abs;

function abs () {
    var data           = this._data;

    this._milliseconds = mathAbs(this._milliseconds);
    this._days         = mathAbs(this._days);
    this._months       = mathAbs(this._months);

    data.milliseconds  = mathAbs(data.milliseconds);
    data.seconds       = mathAbs(data.seconds);
    data.minutes       = mathAbs(data.minutes);
    data.hours         = mathAbs(data.hours);
    data.months        = mathAbs(data.months);
    data.years         = mathAbs(data.years);

    return this;
}

function addSubtract$1 (duration, input, value, direction) {
    var other = createDuration(input, value);

    duration._milliseconds += direction * other._milliseconds;
    duration._days         += direction * other._days;
    duration._months       += direction * other._months;

    return duration._bubble();
}

// supports only 2.0-style add(1, 's') or add(duration)
function add$1 (input, value) {
    return addSubtract$1(this, input, value, 1);
}

// supports only 2.0-style subtract(1, 's') or subtract(duration)
function subtract$1 (input, value) {
    return addSubtract$1(this, input, value, -1);
}

function absCeil (number) {
    if (number < 0) {
        return Math.floor(number);
    } else {
        return Math.ceil(number);
    }
}

function bubble () {
    var milliseconds = this._milliseconds;
    var days         = this._days;
    var months       = this._months;
    var data         = this._data;
    var seconds, minutes, hours, years, monthsFromDays;

    // if we have a mix of positive and negative values, bubble down first
    // check: https://github.com/moment/moment/issues/2166
    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
            (milliseconds <= 0 && days <= 0 && months <= 0))) {
        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
        days = 0;
        months = 0;
    }

    // The following code bubbles up values, see the tests for
    // examples of what that means.
    data.milliseconds = milliseconds % 1000;

    seconds           = absFloor(milliseconds / 1000);
    data.seconds      = seconds % 60;

    minutes           = absFloor(seconds / 60);
    data.minutes      = minutes % 60;

    hours             = absFloor(minutes / 60);
    data.hours        = hours % 24;

    days += absFloor(hours / 24);

    // convert days to months
    monthsFromDays = absFloor(daysToMonths(days));
    months += monthsFromDays;
    days -= absCeil(monthsToDays(monthsFromDays));

    // 12 months -> 1 year
    years = absFloor(months / 12);
    months %= 12;

    data.days   = days;
    data.months = months;
    data.years  = years;

    return this;
}

function daysToMonths (days) {
    // 400 years have 146097 days (taking into account leap year rules)
    // 400 years have 12 months === 4800
    return days * 4800 / 146097;
}

function monthsToDays (months) {
    // the reverse of daysToMonths
    return months * 146097 / 4800;
}

function as (units) {
    if (!this.isValid()) {
        return NaN;
    }
    var days;
    var months;
    var milliseconds = this._milliseconds;

    units = normalizeUnits(units);

    if (units === 'month' || units === 'year') {
        days   = this._days   + milliseconds / 864e5;
        months = this._months + daysToMonths(days);
        return units === 'month' ? months : months / 12;
    } else {
        // handle milliseconds separately because of floating point math errors (issue #1867)
        days = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
            case 'week'   : return days / 7     + milliseconds / 6048e5;
            case 'day'    : return days         + milliseconds / 864e5;
            case 'hour'   : return days * 24    + milliseconds / 36e5;
            case 'minute' : return days * 1440  + milliseconds / 6e4;
            case 'second' : return days * 86400 + milliseconds / 1000;
            // Math.floor prevents floating point math errors here
            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
            default: throw new Error('Unknown unit ' + units);
        }
    }
}

// TODO: Use this.as('ms')?
function valueOf$1 () {
    if (!this.isValid()) {
        return NaN;
    }
    return (
        this._milliseconds +
        this._days * 864e5 +
        (this._months % 12) * 2592e6 +
        toInt(this._months / 12) * 31536e6
    );
}

function makeAs (alias) {
    return function () {
        return this.as(alias);
    };
}

var asMilliseconds = makeAs('ms');
var asSeconds      = makeAs('s');
var asMinutes      = makeAs('m');
var asHours        = makeAs('h');
var asDays         = makeAs('d');
var asWeeks        = makeAs('w');
var asMonths       = makeAs('M');
var asYears        = makeAs('y');

function clone$1 () {
    return createDuration(this);
}

function get$2 (units) {
    units = normalizeUnits(units);
    return this.isValid() ? this[units + 's']() : NaN;
}

function makeGetter(name) {
    return function () {
        return this.isValid() ? this._data[name] : NaN;
    };
}

var milliseconds = makeGetter('milliseconds');
var seconds      = makeGetter('seconds');
var minutes      = makeGetter('minutes');
var hours        = makeGetter('hours');
var days         = makeGetter('days');
var months       = makeGetter('months');
var years        = makeGetter('years');

function weeks () {
    return absFloor(this.days() / 7);
}

var round = Math.round;
var thresholds = {
    ss: 44,         // a few seconds to seconds
    s : 45,         // seconds to minute
    m : 45,         // minutes to hour
    h : 22,         // hours to day
    d : 26,         // days to month
    M : 11          // months to year
};

// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}

function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
    var duration = createDuration(posNegDuration).abs();
    var seconds  = round(duration.as('s'));
    var minutes  = round(duration.as('m'));
    var hours    = round(duration.as('h'));
    var days     = round(duration.as('d'));
    var months   = round(duration.as('M'));
    var years    = round(duration.as('y'));

    var a = seconds <= thresholds.ss && ['s', seconds]  ||
            seconds < thresholds.s   && ['ss', seconds] ||
            minutes <= 1             && ['m']           ||
            minutes < thresholds.m   && ['mm', minutes] ||
            hours   <= 1             && ['h']           ||
            hours   < thresholds.h   && ['hh', hours]   ||
            days    <= 1             && ['d']           ||
            days    < thresholds.d   && ['dd', days]    ||
            months  <= 1             && ['M']           ||
            months  < thresholds.M   && ['MM', months]  ||
            years   <= 1             && ['y']           || ['yy', years];

    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
}

// This function allows you to set the rounding function for relative time strings
function getSetRelativeTimeRounding (roundingFunction) {
    if (roundingFunction === undefined) {
        return round;
    }
    if (typeof(roundingFunction) === 'function') {
        round = roundingFunction;
        return true;
    }
    return false;
}

// This function allows you to set a threshold for relative time strings
function getSetRelativeTimeThreshold (threshold, limit) {
    if (thresholds[threshold] === undefined) {
        return false;
    }
    if (limit === undefined) {
        return thresholds[threshold];
    }
    thresholds[threshold] = limit;
    if (threshold === 's') {
        thresholds.ss = limit - 1;
    }
    return true;
}

function humanize (withSuffix) {
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var locale = this.localeData();
    var output = relativeTime$1(this, !withSuffix, locale);

    if (withSuffix) {
        output = locale.pastFuture(+this, output);
    }

    return locale.postformat(output);
}

var abs$1 = Math.abs;

function sign(x) {
    return ((x > 0) - (x < 0)) || +x;
}

function toISOString$1() {
    // for ISO strings we do not use the normal bubbling rules:
    //  * milliseconds bubble up until they become hours
    //  * days do not bubble at all
    //  * months bubble up until they become years
    // This is because there is no context-free conversion between hours and days
    // (think of clock changes)
    // and also not between days and months (28-31 days per month)
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var seconds = abs$1(this._milliseconds) / 1000;
    var days         = abs$1(this._days);
    var months       = abs$1(this._months);
    var minutes, hours, years;

    // 3600 seconds -> 60 minutes -> 1 hour
    minutes           = absFloor(seconds / 60);
    hours             = absFloor(minutes / 60);
    seconds %= 60;
    minutes %= 60;

    // 12 months -> 1 year
    years  = absFloor(months / 12);
    months %= 12;


    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
    var Y = years;
    var M = months;
    var D = days;
    var h = hours;
    var m = minutes;
    var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
    var total = this.asSeconds();

    if (!total) {
        // this is the same as C#'s (Noda) and python (isodate)...
        // but not other JS (goog.date)
        return 'P0D';
    }

    var totalSign = total < 0 ? '-' : '';
    var ymSign = sign(this._months) !== sign(total) ? '-' : '';
    var daysSign = sign(this._days) !== sign(total) ? '-' : '';
    var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

    return totalSign + 'P' +
        (Y ? ymSign + Y + 'Y' : '') +
        (M ? ymSign + M + 'M' : '') +
        (D ? daysSign + D + 'D' : '') +
        ((h || m || s) ? 'T' : '') +
        (h ? hmsSign + h + 'H' : '') +
        (m ? hmsSign + m + 'M' : '') +
        (s ? hmsSign + s + 'S' : '');
}

var proto$2 = Duration.prototype;

proto$2.isValid        = isValid$1;
proto$2.abs            = abs;
proto$2.add            = add$1;
proto$2.subtract       = subtract$1;
proto$2.as             = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds      = asSeconds;
proto$2.asMinutes      = asMinutes;
proto$2.asHours        = asHours;
proto$2.asDays         = asDays;
proto$2.asWeeks        = asWeeks;
proto$2.asMonths       = asMonths;
proto$2.asYears        = asYears;
proto$2.valueOf        = valueOf$1;
proto$2._bubble        = bubble;
proto$2.clone          = clone$1;
proto$2.get            = get$2;
proto$2.milliseconds   = milliseconds;
proto$2.seconds        = seconds;
proto$2.minutes        = minutes;
proto$2.hours          = hours;
proto$2.days           = days;
proto$2.weeks          = weeks;
proto$2.months         = months;
proto$2.years          = years;
proto$2.humanize       = humanize;
proto$2.toISOString    = toISOString$1;
proto$2.toString       = toISOString$1;
proto$2.toJSON         = toISOString$1;
proto$2.locale         = locale;
proto$2.localeData     = localeData;

// Deprecations
proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
proto$2.lang = lang;

// Side effect imports

// FORMATTING

addFormatToken('X', 0, 0, 'unix');
addFormatToken('x', 0, 0, 'valueOf');

// PARSING

addRegexToken('x', matchSigned);
addRegexToken('X', matchTimestamp);
addParseToken('X', function (input, array, config) {
    config._d = new Date(parseFloat(input, 10) * 1000);
});
addParseToken('x', function (input, array, config) {
    config._d = new Date(toInt(input));
});

// Side effect imports


hooks.version = '2.19.1';

setHookCallback(createLocal);

hooks.fn                    = proto;
hooks.min                   = min;
hooks.max                   = max;
hooks.now                   = now;
hooks.utc                   = createUTC;
hooks.unix                  = createUnix;
hooks.months                = listMonths;
hooks.isDate                = isDate;
hooks.locale                = getSetGlobalLocale;
hooks.invalid               = createInvalid;
hooks.duration              = createDuration;
hooks.isMoment              = isMoment;
hooks.weekdays              = listWeekdays;
hooks.parseZone             = createInZone;
hooks.localeData            = getLocale;
hooks.isDuration            = isDuration;
hooks.monthsShort           = listMonthsShort;
hooks.weekdaysMin           = listWeekdaysMin;
hooks.defineLocale          = defineLocale;
hooks.updateLocale          = updateLocale;
hooks.locales               = listLocales;
hooks.weekdaysShort         = listWeekdaysShort;
hooks.normalizeUnits        = normalizeUnits;
hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat        = getCalendarFormat;
hooks.prototype             = proto;

return hooks;

})));

},{}],177:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function boundary_to_dot(value) {
    return value.split('][').join('.').split('[').join('.');
}
function strip_braces(value) {
    return value.split('[').join('.').split(']').join('');
}
function escape_dots(value) {
    var val = value.split('\'');
    return (val.length < 3) ? val.join('\'') : val.map(function (seg) {
        if (seg.length < 3)
            return seg;
        if ((seg[0] === '.') || (seg[seg.length - 1] === '.'))
            return seg;
        return seg.split('.').join('&&');
    }).join('');
}
function unescape_dots(value) {
    return value.split('&&').join('.');
}
function partify(value) {
    if (!value)
        return;
    return escape_dots(strip_braces(boundary_to_dot('' + value))).split('.');
}
function canClone(o) {
    return (typeof o.__CLONE__ === 'function');
}
function clone(o) {
    if ((typeof o !== 'object') || (o === null))
        return o;
    if (Array.isArray(o))
        return o.map(clone);
    return (canClone(o)) ?
        o.__CLONE__(clone) : (o.constructor !== Object) ? o :
        Object.keys(o).reduce(function (pre, k) {
            pre[k] = (typeof o[k] === 'object') ?
                clone(o[k]) : o[k];
            return pre;
        }, {});
}
function get(path, o) {
    var parts = partify(path);
    var first;
    if (typeof o === 'object') {
        if (parts.length === 1)
            return o[unescape_dots(parts[0])];
        if (parts.length === 0)
            return;
        first = o[parts.shift()];
        return ((typeof o === 'object') && (o !== null)) ?
            parts.reduce(function (target, prop) {
                if (target == null)
                    return target;
                return target[unescape_dots(prop)];
            }, first) : null;
    }
    else {
        throw new TypeError('get(): expects an object got ' + typeof o);
    }
}
exports.get = get;
;
function set(path, value, obj) {
    var parts = partify(path);
    if ((typeof obj !== 'object') || (obj == null)) {
        return clone(obj);
    }
    else {
        return _set(obj, value, parts);
    }
}
exports.set = set;
;
function _set(obj, value, parts) {
    var o;
    var k;
    if (parts.length === 0)
        return value;
    o = ((typeof obj !== 'object') || (obj === null)) ? {} : clone(obj);
    k = unescape_dots(parts[0]);
    o[k] = _set(o[k], value, parts.slice(1));
    return o;
}
function default_1(k, v, o) {
    if (o == null)
        return get(k, v);
    else
        return set(k, v, o);
}
exports.default = default_1;
;

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJleGFtcGxlL2J1aWxkL2FwcC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvUGFnZS5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvYXV0b2NvbXBsZXRlL2luZGV4LmpzIiwiZXhhbXBsZS9idWlsZC9wYWdlcy9hdXRvY29tcGxldGUvd21sL2F1dG9jb21wbGV0ZS5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvYnJlYWRjcnVtYnMvaW5kZXguanMiLCJleGFtcGxlL2J1aWxkL3BhZ2VzL2JyZWFkY3J1bWJzL3dtbC9icmVhZGNydW1icy5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvYnVzeS1pbmRpY2F0b3IvaW5kZXguanMiLCJleGFtcGxlL2J1aWxkL3BhZ2VzL2J1c3ktaW5kaWNhdG9yL3dtbC9idXN5LWluZGljYXRvci5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvYnV0dG9uLW1lbnUvaW5kZXguanMiLCJleGFtcGxlL2J1aWxkL3BhZ2VzL2J1dHRvbi1tZW51L3dtbC9idXR0b24tbWVudS5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvYnV0dG9uLXNlbGVjdC9pbmRleC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvYnV0dG9uLXNlbGVjdC93bWwvYnV0dG9uLXNlbGVjdC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvY2hlY2tib3gvaW5kZXguanMiLCJleGFtcGxlL2J1aWxkL3BhZ2VzL2NoZWNrYm94L3dtbC9jaGVja2JveC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvZGF0ZS9pbmRleC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvZGF0ZS93bWwvZGF0ZS5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvaG9tZS9pbmRleC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvaG9tZS93bWwvaG9tZS5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvbGlzdC1ncm91cC9pbmRleC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvbGlzdC1ncm91cC93bWwvbGlzdC1ncm91cC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvbWVudS9pbmRleC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvbWVudS93bWwvbWVudS5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvcGFuZWwvaW5kZXguanMiLCJleGFtcGxlL2J1aWxkL3BhZ2VzL3BhbmVsL3dtbC9wYW5lbC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvc2VhcmNoLXN0YWNrL2luZGV4LmpzIiwiZXhhbXBsZS9idWlsZC9wYWdlcy9zZWFyY2gtc3RhY2svd21sL3NlYXJjaC1zdGFjay5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvc2VsZWN0L2luZGV4LmpzIiwiZXhhbXBsZS9idWlsZC9wYWdlcy9zZWxlY3Qvd21sL3NlbGVjdC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvc3RhY2svaW5kZXguanMiLCJleGFtcGxlL2J1aWxkL3BhZ2VzL3N0YWNrL3dtbC9zdGFjay5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvc3dpdGNoL2luZGV4LmpzIiwiZXhhbXBsZS9idWlsZC9wYWdlcy9zd2l0Y2gvd21sL3N3aXRjaC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvdGFibGUvZGF0YS5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvdGFibGUvaW5kZXguanMiLCJleGFtcGxlL2J1aWxkL3BhZ2VzL3RhYmxlL3dtbC90YWJsZS5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvdGFicy9pbmRleC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvdGFicy93bWwvdGFicy5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvdGV4dC1maWVsZC9pbmRleC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvdGV4dC1maWVsZC93bWwvdGV4dC1maWVsZC5qcyIsImV4YW1wbGUvYnVpbGQvd21sL2FwcC5qcyIsImV4YW1wbGUvYnVpbGQvd21sL25hdmlnYXRpb24uanMiLCJsaWIvYXBwL2FjdGlvbi1iYXIvQWN0aW9uQmFyLmpzIiwibGliL2FwcC9hY3Rpb24tYmFyL3dtbC9hY3Rpb25fYmFyLmpzIiwibGliL2FwcC9idXN5LWluZGljYXRvci9CdXN5SW5kaWNhdG9yLmpzIiwibGliL2FwcC9idXN5LWluZGljYXRvci93bWwvYnVzeV9pbmRpY2F0b3IuanMiLCJsaWIvYXBwL2Rhc2gvRGFzaC5qcyIsImxpYi9hcHAvZGFzaC9pbmRleC5qcyIsImxpYi9hcHAvZGFzaC93bWwvZGFzaC5qcyIsImxpYi9jb21tb24vbmFtZXMuanMiLCJsaWIvY29tbW9uL3V0aWwuanMiLCJsaWIvY29udGVudC9Hcm91cC5qcyIsImxpYi9jb250cm9sL0NvbnRyb2wuanMiLCJsaWIvY29udHJvbC9EZWZhdWx0RGVsZWdhdGUuanMiLCJsaWIvY29udHJvbC9FdmVudC5qcyIsImxpYi9jb250cm9sL0Zvcm1Db250cm9sLmpzIiwibGliL2NvbnRyb2wvYXV0b2NvbXBsZXRlL0F1dG9jb21wbGV0ZS5qcyIsImxpYi9jb250cm9sL2F1dG9jb21wbGV0ZS9pbmRleC5qcyIsImxpYi9jb250cm9sL2F1dG9jb21wbGV0ZS93bWwvYXV0b2NvbXBsZXRlLmpzIiwibGliL2NvbnRyb2wvYnV0dG9uLXNlbGVjdC9CdXR0b25DaGFuZ2VkRXZlbnQuanMiLCJsaWIvY29udHJvbC9idXR0b24tc2VsZWN0L0J1dHRvblNlbGVjdC5qcyIsImxpYi9jb250cm9sL2J1dHRvbi1zZWxlY3QvQnV0dG9uU2VsZWN0R3JvdXAuanMiLCJsaWIvY29udHJvbC9idXR0b24tc2VsZWN0L011bHRpQnV0dG9uU2VsZWN0LmpzIiwibGliL2NvbnRyb2wvYnV0dG9uLXNlbGVjdC9pbmRleC5qcyIsImxpYi9jb250cm9sL2J1dHRvbi1zZWxlY3Qvd21sL2J1dHRvbi1zZWxlY3QuanMiLCJsaWIvY29udHJvbC9idXR0b24vQnV0dG9uLmpzIiwibGliL2NvbnRyb2wvYnV0dG9uL3dtbC9idXR0b24uanMiLCJsaWIvY29udHJvbC9jaGVja2JveC9DaGVja2JveC5qcyIsImxpYi9jb250cm9sL2NoZWNrYm94L0NoZWNrYm94Q2hhbmdlZEV2ZW50LmpzIiwibGliL2NvbnRyb2wvY2hlY2tib3gvd21sL2NoZWNrYm94LmpzIiwibGliL2NvbnRyb2wvZGF0ZS9EYXRlLmpzIiwibGliL2NvbnRyb2wvZGF0ZS9EYXRlQ2hhbmdlZEV2ZW50LmpzIiwibGliL2NvbnRyb2wvZGF0ZS93bWwvZGF0ZS5qcyIsImxpYi9jb250cm9sL2ljb24tYnV0dG9uL0ljb25CdXR0b24uanMiLCJsaWIvY29udHJvbC9pY29uLWJ1dHRvbi93bWwvaWNvbi1idXR0b24uanMiLCJsaWIvY29udHJvbC9pbmRleC5qcyIsImxpYi9jb250cm9sL2x1cmNoL0l0ZW1TZWxlY3RlZEV2ZW50LmpzIiwibGliL2NvbnRyb2wvbHVyY2gvU2VhcmNoQ29udHJvbC5qcyIsImxpYi9jb250cm9sL2x1cmNoL1NlYXJjaERlZmF1bHREZWxlZ2F0ZS5qcyIsImxpYi9jb250cm9sL2x1cmNoL1Rlcm1DaGFuZ2VkRXZlbnQuanMiLCJsaWIvY29udHJvbC9sdXJjaC9pbmRleC5qcyIsImxpYi9jb250cm9sL3NlYXJjaC1zdGFjay9TZWFyY2hTdGFjay5qcyIsImxpYi9jb250cm9sL3NlYXJjaC1zdGFjay93bWwvc2VhcmNoLXN0YWNrLmpzIiwibGliL2NvbnRyb2wvc2VsZWN0L1NlbGVjdC5qcyIsImxpYi9jb250cm9sL3NlbGVjdC9TZWxlY3RDaGFuZ2VkRXZlbnQuanMiLCJsaWIvY29udHJvbC9zZWxlY3QvaW5kZXguanMiLCJsaWIvY29udHJvbC9zZWxlY3Qvd21sL3NlbGVjdC5qcyIsImxpYi9jb250cm9sL3N0YWNrL1N0YWNrLmpzIiwibGliL2NvbnRyb2wvc3RhY2svU3RhY2tDaGFuZ2VkRXZlbnQuanMiLCJsaWIvY29udHJvbC9zdGFjay9pbmRleC5qcyIsImxpYi9jb250cm9sL3N0YWNrL3dtbC9zdGFjay5qcyIsImxpYi9jb250cm9sL3N3aXRjaC9Td2l0Y2guanMiLCJsaWIvY29udHJvbC9zd2l0Y2gvU3dpdGNoQ2hhbmdlZEV2ZW50LmpzIiwibGliL2NvbnRyb2wvc3dpdGNoL3dtbC9zd2l0Y2guanMiLCJsaWIvY29udHJvbC90YWJzL1RhYi5qcyIsImxpYi9jb250cm9sL3RhYnMvVGFiQ2xpY2tlZEV2ZW50LmpzIiwibGliL2NvbnRyb2wvdGFicy9UYWJzLmpzIiwibGliL2NvbnRyb2wvdGFicy93bWwvdGFicy5qcyIsImxpYi9jb250cm9sL3RleHQtZmllbGQvVGV4dENoYW5nZWRFdmVudC5qcyIsImxpYi9jb250cm9sL3RleHQtZmllbGQvVGV4dEZpZWxkLmpzIiwibGliL2NvbnRyb2wvdGV4dC1maWVsZC9pbmRleC5qcyIsImxpYi9jb250cm9sL3RleHQtZmllbGQvd21sL3RleHQtZmllbGQuanMiLCJsaWIvY29udHJvbC93bWwvaW5kZXguanMiLCJsaWIvbGF5b3V0L2FzaWRlL0FzaWRlLmpzIiwibGliL2xheW91dC9hc2lkZS93bWwvYXNpZGUuanMiLCJsaWIvbGF5b3V0L2RyYXdlci9EcmF3ZXIuanMiLCJsaWIvbGF5b3V0L2RyYXdlci93bWwvZHJhd2VyLmpzIiwibGliL2xheW91dC9mcmFnbWVudC9GcmFnbWVudC5qcyIsImxpYi9sYXlvdXQvZnJhZ21lbnQvd21sL3ZpZXdzLmpzIiwibGliL2xheW91dC9ncmlkL0dyaWQuanMiLCJsaWIvbGF5b3V0L2dyaWQvd21sL2dyaWQuanMiLCJsaWIvbGF5b3V0L2xpc3QtZ3JvdXAvTGlzdEdyb3VwLmpzIiwibGliL2xheW91dC9saXN0LWdyb3VwL0xpc3RHcm91cEl0ZW0uanMiLCJsaWIvbGF5b3V0L2xpc3QtZ3JvdXAvaW5kZXguanMiLCJsaWIvbGF5b3V0L2xpc3QtZ3JvdXAvd21sL2xpc3QtZ3JvdXAtaXRlbS5qcyIsImxpYi9sYXlvdXQvbGlzdC1ncm91cC93bWwvbGlzdC1ncm91cC5qcyIsImxpYi9sYXlvdXQvbWFpbi9NYWluLmpzIiwibGliL2xheW91dC9tYWluL3dtbC9tYWluLmpzIiwibGliL2xheW91dC9wYW5lbC9QYW5lbC5qcyIsImxpYi9sYXlvdXQvcGFuZWwvd21sL3BhbmVsLmpzIiwibGliL21lbnUvRGl2aWRlci5qcyIsImxpYi9tZW51L0hlYWRlci5qcyIsImxpYi9tZW51L01lbnUuanMiLCJsaWIvbWVudS9NZW51SXRlbS5qcyIsImxpYi9tZW51L01lbnVJdGVtQ2xpY2tlZEV2ZW50LmpzIiwibGliL21lbnUvYnV0dG9uLW1lbnUvQnV0dG9uTWVudS5qcyIsImxpYi9tZW51L2J1dHRvbi1tZW51L2luZGV4LmpzIiwibGliL21lbnUvYnV0dG9uLW1lbnUvd21sL2J1dHRvbi1tZW51LmpzIiwibGliL21lbnUvaW5kZXguanMiLCJsaWIvbWVudS93bWwvZGl2aWRlci5qcyIsImxpYi9tZW51L3dtbC9oZWFkZXIuanMiLCJsaWIvbWVudS93bWwvbWVudS1pdGVtLmpzIiwibGliL21lbnUvd21sL21lbnUuanMiLCJsaWIvbmF2L2JyZWFkY3J1bWJzL0JyZWFkQ3J1bWJzLmpzIiwibGliL25hdi9icmVhZGNydW1icy9JdGVtLmpzIiwibGliL25hdi9icmVhZGNydW1icy93bWwvYnJlYWRjcnVtYnMuanMiLCJsaWIvbmF2L2xpbmsvTGluay5qcyIsImxpYi9uYXYvbGluay9MaW5rQ2xpY2tlZEV2ZW50LmpzIiwibGliL25hdi9saW5rL2luZGV4LmpzIiwibGliL25hdi9saW5rL3dtbC9saW5rLmpzIiwibGliL25hdi9tZW51L0hlYWRlci5qcyIsImxpYi9uYXYvbWVudS9JdGVtLmpzIiwibGliL25hdi9tZW51L0l0ZW1DbGlja2VkRXZlbnQuanMiLCJsaWIvbmF2L21lbnUvTGluay5qcyIsImxpYi9uYXYvbWVudS9NZW51LmpzIiwibGliL25hdi9tZW51L1N1Yk1lbnUuanMiLCJsaWIvbmF2L21lbnUvaW5kZXguanMiLCJsaWIvbmF2L21lbnUvd21sL2hlYWRlci5qcyIsImxpYi9uYXYvbWVudS93bWwvaXRlbS5qcyIsImxpYi9uYXYvbWVudS93bWwvbGluay5qcyIsImxpYi9uYXYvbWVudS93bWwvbWVudS5qcyIsImxpYi9uYXYvbWVudS93bWwvc3ViLW1lbnUuanMiLCJsaWIvdGFibGUvdGFibGUvQ2VsbENsaWNrZWRFdmVudC5qcyIsImxpYi90YWJsZS90YWJsZS9IZWFkaW5nQ2xpY2tlZEV2ZW50LmpzIiwibGliL3RhYmxlL3RhYmxlL1Jvd0NsaWNrZWRFdmVudC5qcyIsImxpYi90YWJsZS90YWJsZS9Sb3dTZWxlY3RlZEV2ZW50LmpzIiwibGliL3RhYmxlL3RhYmxlL1RhYmxlLmpzIiwibGliL3RhYmxlL3RhYmxlL3dtbC90YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9AcXVlbmsvd21sL2xpYi9BU1QuanMiLCJub2RlX21vZHVsZXMvQHF1ZW5rL3dtbC9saWIvQ29tcGlsZXIuanMiLCJub2RlX21vZHVsZXMvQHF1ZW5rL3dtbC9saWIvUGFyc2VyLmpzIiwibm9kZV9tb2R1bGVzL0BxdWVuay93bWwvbGliL1R5cGVTY3JpcHQuanMiLCJub2RlX21vZHVsZXMvQHF1ZW5rL3dtbC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYWZwbC9saWIvY3VycnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYWZwbC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYWZwbC9saWIvbW9uYWQvRWl0aGVyLmpzIiwibm9kZV9tb2R1bGVzL2FmcGwvbGliL21vbmFkL0ZyZWUuanMiLCJub2RlX21vZHVsZXMvYWZwbC9saWIvbW9uYWQvSU8uanMiLCJub2RlX21vZHVsZXMvYWZwbC9saWIvbW9uYWQvSWRlbnRpdHkuanMiLCJub2RlX21vZHVsZXMvYWZwbC9saWIvbW9uYWQvTWF5YmUuanMiLCJub2RlX21vZHVsZXMvYWZwbC9saWIvbW9uYWQvU3RhdGUuanMiLCJub2RlX21vZHVsZXMvYWZwbC9saWIvdXRpbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qcy1iZWF1dGlmeS9qcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qcy1iZWF1dGlmeS9qcy9saWIvYmVhdXRpZnktY3NzLmpzIiwibm9kZV9tb2R1bGVzL2pzLWJlYXV0aWZ5L2pzL2xpYi9iZWF1dGlmeS1odG1sLmpzIiwibm9kZV9tb2R1bGVzL2pzLWJlYXV0aWZ5L2pzL2xpYi9iZWF1dGlmeS5qcyIsIm5vZGVfbW9kdWxlcy9tb21lbnQvbW9tZW50LmpzIiwibm9kZV9tb2R1bGVzL3Byb3BlcnR5LXNlZWsvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmxTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN0aENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDMzJDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3B3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2w2SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYXBwXzEgPSByZXF1aXJlKFwiLi93bWwvYXBwXCIpO1xudmFyIG5hdmlnYXRpb25fMSA9IHJlcXVpcmUoXCIuL3dtbC9uYXZpZ2F0aW9uXCIpO1xudmFyIGhvbWVfMSA9IHJlcXVpcmUoXCIuL3BhZ2VzL2hvbWVcIik7XG52YXIgcGFuZWxfMSA9IHJlcXVpcmUoXCIuL3BhZ2VzL3BhbmVsXCIpO1xudmFyIGxpc3RfZ3JvdXBfMSA9IHJlcXVpcmUoXCIuL3BhZ2VzL2xpc3QtZ3JvdXBcIik7XG52YXIgdGFibGVfMSA9IHJlcXVpcmUoXCIuL3BhZ2VzL3RhYmxlXCIpO1xudmFyIHRleHRfZmllbGRfMSA9IHJlcXVpcmUoXCIuL3BhZ2VzL3RleHQtZmllbGRcIik7XG52YXIgZGF0ZV8xID0gcmVxdWlyZShcIi4vcGFnZXMvZGF0ZVwiKTtcbnZhciBzZWxlY3RfMSA9IHJlcXVpcmUoXCIuL3BhZ2VzL3NlbGVjdFwiKTtcbnZhciBidXR0b25fc2VsZWN0XzEgPSByZXF1aXJlKFwiLi9wYWdlcy9idXR0b24tc2VsZWN0XCIpO1xudmFyIGNoZWNrYm94XzEgPSByZXF1aXJlKFwiLi9wYWdlcy9jaGVja2JveFwiKTtcbnZhciBzd2l0Y2hfMSA9IHJlcXVpcmUoXCIuL3BhZ2VzL3N3aXRjaFwiKTtcbnZhciB0YWJzXzEgPSByZXF1aXJlKFwiLi9wYWdlcy90YWJzXCIpO1xudmFyIHN0YWNrXzEgPSByZXF1aXJlKFwiLi9wYWdlcy9zdGFja1wiKTtcbnZhciBzZWFyY2hfc3RhY2tfMSA9IHJlcXVpcmUoXCIuL3BhZ2VzL3NlYXJjaC1zdGFja1wiKTtcbnZhciBhdXRvY29tcGxldGVfMSA9IHJlcXVpcmUoXCIuL3BhZ2VzL2F1dG9jb21wbGV0ZVwiKTtcbnZhciBicmVhZGNydW1ic18xID0gcmVxdWlyZShcIi4vcGFnZXMvYnJlYWRjcnVtYnNcIik7XG52YXIgYnVzeV9pbmRpY2F0b3JfMSA9IHJlcXVpcmUoXCIuL3BhZ2VzL2J1c3ktaW5kaWNhdG9yXCIpO1xudmFyIG1lbnVfMSA9IHJlcXVpcmUoXCIuL3BhZ2VzL21lbnVcIik7XG52YXIgYnV0dG9uX21lbnVfMSA9IHJlcXVpcmUoXCIuL3BhZ2VzL2J1dHRvbi1tZW51XCIpO1xudmFyIEFwcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBcHAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwYWdlIGN1cnJlbnRseSBkaXNwbGF5ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhZ2UgPSAnaG9tZSc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwYWdlcyB0byBzaG93IHRoZSB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wYWdlcyA9IHtcbiAgICAgICAgICAgIGhvbWU6IG5ldyBob21lXzEuSG9tZVBhZ2UodGhpcyksXG4gICAgICAgICAgICBwYW5lbDogbmV3IHBhbmVsXzEuUGFuZWxQYWdlKHRoaXMpLFxuICAgICAgICAgICAgJ2xpc3QtZ3JvdXAnOiBuZXcgbGlzdF9ncm91cF8xLkxpc3RHcm91cFBhZ2UodGhpcyksXG4gICAgICAgICAgICB0YWJsZTogbmV3IHRhYmxlXzEuVGFibGVQYWdlKHRoaXMpLFxuICAgICAgICAgICAgJ3RleHQtZmllbGQnOiBuZXcgdGV4dF9maWVsZF8xLlRleHRGaWVsZFBhZ2UodGhpcyksXG4gICAgICAgICAgICBkYXRlOiBuZXcgZGF0ZV8xLkRhdGVQYWdlKHRoaXMpLFxuICAgICAgICAgICAgc2VsZWN0OiBuZXcgc2VsZWN0XzEuU2VsZWN0UGFnZSh0aGlzKSxcbiAgICAgICAgICAgIGF1dG9jb21wbGV0ZTogbmV3IGF1dG9jb21wbGV0ZV8xLkF1dG9jb21wbGV0ZVBhZ2UodGhpcyksXG4gICAgICAgICAgICAnYnV0dG9uLXNlbGVjdCc6IG5ldyBidXR0b25fc2VsZWN0XzEuQnV0dG9uU2VsZWN0UGFnZSh0aGlzKSxcbiAgICAgICAgICAgIHRhYnM6IG5ldyB0YWJzXzEuVGFic1BhZ2UodGhpcyksXG4gICAgICAgICAgICBzdGFjazogbmV3IHN0YWNrXzEuU3RhY2tQYWdlKHRoaXMpLFxuICAgICAgICAgICAgY2hlY2tib3g6IG5ldyBjaGVja2JveF8xLkNoZWNrYm94UGFnZSh0aGlzKSxcbiAgICAgICAgICAgICdzd2l0Y2gnOiBuZXcgc3dpdGNoXzEuU3dpdGNoUGFnZSh0aGlzKSxcbiAgICAgICAgICAgICdidXN5LWluZGljYXRvcic6IG5ldyBidXN5X2luZGljYXRvcl8xLkJ1c3lJbmRpY2F0b3JQYWdlKHRoaXMpLFxuICAgICAgICAgICAgJ3NlYXJjaC1zdGFjayc6IG5ldyBzZWFyY2hfc3RhY2tfMS5TZWFyY2hTdGFja1BhZ2UodGhpcyksXG4gICAgICAgICAgICBicmVhZGNydW1iczogbmV3IGJyZWFkY3J1bWJzXzEuQnJlYWRDcnVtYnNQYWdlKHRoaXMpLFxuICAgICAgICAgICAgbWVudTogbmV3IG1lbnVfMS5NZW51UGFnZSh0aGlzKSxcbiAgICAgICAgICAgICdidXR0b24tbWVudSc6IG5ldyBidXR0b25fbWVudV8xLkJ1dHRvbk1lbnVQYWdlKHRoaXMpXG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBuYXZpZ2F0aW9uIHZpZXdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmF2aWdhdGlvbiA9IG5ldyBuYXZpZ2F0aW9uXzEuTmF2aWdhdGlvbih0aGlzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHZhbHVlcyB1c2VkIHdpdGhpbiB0aGUgdGVtcGxhdGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiB7XG4gICAgICAgICAgICAgICAgbGF5b3V0OiAnbGF5b3V0J1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogdmlldyBpcyB0aGUgY3VycmVudCBhcHBsaWNhdGlvbiB2aWV3LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IGFwcF8xLk1haW4odGhpcyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjb250ZW50IGRpc3BsYXllZCBhcyB0aGUgbWFpbiBjb250ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb250ZW50ID0gdGhpcy5wYWdlcy5ob21lLnZpZXc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0b2dnbGVEcmF3ZXJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudG9nZ2xlRHJhd2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXNcbiAgICAgICAgICAgICAgICAudmlld1xuICAgICAgICAgICAgICAgIC5maW5kQnlJZChfdGhpcy52YWx1ZXMuaWQubGF5b3V0KVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQudG9nZ2xlRHJhd2VyKCk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogbmF2aWdhdGUgaXMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIGFcbiAgICAgICAgICogbmF2aWdhdGlvbiBsaW5rLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYXZpZ2F0ZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBfYS5uYW1lO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJvdXRlKG5hbWUpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiByb3V0ZSB0aGUgbWFpbiBjb250ZW50IGJhc2VkIG9uIHRoZSBwYXNzZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIEFwcC5wcm90b3R5cGUucm91dGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBjb25zb2xlLmluZm8oJ25hbWUtPiAnLCBuYW1lKTtcbiAgICAgICAgY29uc29sZS5pbmZvKHRoaXMucGFnZXMuaGFzT3duUHJvcGVydHkobmFtZSkpO1xuICAgICAgICB0aGlzLnBhZ2UgPSBuYW1lO1xuICAgICAgICBpZiAodGhpcy5wYWdlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSlcbiAgICAgICAgICAgIHRoaXMuY29udGVudCA9IHRoaXMucGFnZXNbbmFtZV0udmlldztcbiAgICAgICAgdGhpcy52aWV3LmludmFsaWRhdGUoKTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uLmludmFsaWRhdGUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHJ1biB0aGUgYXBwbGljYXRpb24uXG4gICAgICovXG4gICAgQXBwLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByb290ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FwcCcpO1xuICAgICAgICB3aGlsZSAocm9vdC5sYXN0Q2hpbGQpXG4gICAgICAgICAgICByb290LnJlbW92ZUNoaWxkKHJvb3QubGFzdENoaWxkKTtcbiAgICAgICAgcm9vdC5hcHBlbmRDaGlsZCh0aGlzLnZpZXcucmVuZGVyKCkpO1xuICAgICAgICB0aGlzLmxheW91dCA9IHRoaXMudmlldy5maW5kQnlJZCh0aGlzLnZhbHVlcy5pZC5sYXlvdXQpO1xuICAgICAgICB2YXIgcGF0aCA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoLnNwbGl0KCcjJylbMV07XG4gICAgICAgIHBhdGggPSBwYXRoID8gcGF0aC5zcGxpdCgnLycpLmpvaW4oJycpIDogJyc7XG4gICAgICAgIHRoaXMucm91dGUocGF0aCk7XG4gICAgfTtcbiAgICBBcHAubWFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBcHAoKTtcbiAgICB9O1xuICAgIHJldHVybiBBcHA7XG59KCkpO1xuZXhwb3J0cy5BcHAgPSBBcHA7XG52YXIgdyA9IHdpbmRvdztcbncuYXBwID0gQXBwLm1haW4oKTtcbncuYXBwLnJ1bigpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFBhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGFnZShhcHApIHtcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XG4gICAgfVxuICAgIFBhZ2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChpZCwgZm4pIHtcbiAgICAgICAgdGhpc1xuICAgICAgICAgICAgLnZpZXdcbiAgICAgICAgICAgIC5maW5kQnlJZChpZClcbiAgICAgICAgICAgIC5tYXAoZm4pXG4gICAgICAgICAgICAub3JKdXN0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnNvbGUud2FybihpZCArIFwiOiBpcyBtaXNzaW5nXCIpOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBQYWdlO1xufSgpKTtcbmV4cG9ydHMuUGFnZSA9IFBhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QYWdlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvYXV0b2NvbXBsZXRlXCIpO1xudmFyIFBhZ2VfMSA9IHJlcXVpcmUoXCIuLi9QYWdlXCIpO1xudmFyIEF1dG9jb21wbGV0ZVBhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEF1dG9jb21wbGV0ZVBhZ2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXV0b2NvbXBsZXRlUGFnZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiAnc2VhcmNoJyxcbiAgICAgICAgICAgIG5hbWU6ICdzZWFyY2gnLFxuICAgICAgICAgICAgcmVzdWx0czogW1xuICAgICAgICAgICAgICAgIHsgbGFiZWw6ICdBc3VzJywgdmFsdWU6ICdBc3VzJyB9LFxuICAgICAgICAgICAgICAgIHsgbGFiZWw6ICdNU0knLCB2YWx1ZTogJ01TSScgfSxcbiAgICAgICAgICAgICAgICB7IGxhYmVsOiAnR2lnYWJ5dGUnLCB2YWx1ZTogJ0dpZ2FieXRlJyB9LFxuICAgICAgICAgICAgICAgIHsgbGFiZWw6ICdHaWdhcycsIHZhbHVlOiAnR2lnYXMnIH0sXG4gICAgICAgICAgICAgICAgeyBsYWJlbDogJ0FzdXNUZWsnLCB2YWx1ZTogJ0FzdXNUZWsnIH0sXG4gICAgICAgICAgICAgICAgeyBsYWJlbDogJ0FzdXN1Z2EnLCB2YWx1ZTogJ0FzdXN1Z2EnIH0sXG4gICAgICAgICAgICAgICAgeyBsYWJlbDogJ1F1YWxjb21tJywgdmFsdWU6ICdRdWFsY29tbScgfSxcbiAgICAgICAgICAgICAgICB7IGxhYmVsOiAnUXVhbGl0YXRpdmUnLCB2YWx1ZTogJ1F1YWxpdGF0dmUnIH0sXG4gICAgICAgICAgICAgICAgeyBsYWJlbDogJ0FzdW5kZXInLCB2YWx1ZTogJ0FzdW5kZXInIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25TZWFyY2ggPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICAgICAgX3RoaXNcbiAgICAgICAgICAgICAgICAudmlld1xuICAgICAgICAgICAgICAgIC5maW5kQnlJZChfdGhpcy52YWx1ZXMuaWQpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgICAgIHZhciBoaXQgPSBfdGhpcy52YWx1ZXMucmVzdWx0cy5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMudmFsdWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKHZhbHVlKSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzLnVwZGF0ZShoaXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uU2VsZWN0ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgIF90aGlzLnZpZXcuZmluZEJ5SWQoJ3NlbGVjdGVkJylcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGUubGFzdENoaWxkKVxuICAgICAgICAgICAgICAgICAgICBlLnJlbW92ZUNoaWxkKGUubGFzdENoaWxkKTtcbiAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZhbHVlLnZhbHVlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQXV0b2NvbXBsZXRlUGFnZTtcbn0oUGFnZV8xLlBhZ2UpKTtcbmV4cG9ydHMuQXV0b2NvbXBsZXRlUGFnZSA9IEF1dG9jb21wbGV0ZVBhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIEdyaWRfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2xheW91dC9ncmlkL0dyaWRcIik7XG47XG52YXIgYXV0b2NvbXBsZXRlXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb250cm9sL2F1dG9jb21wbGV0ZVwiKTtcbjtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLndpZGdldChHcmlkXzEuR3JpZCwge1xuICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KEdyaWRfMS5Sb3csIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChHcmlkXzEuQ29sdW1uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplJzogNlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiWW91IHNlbGVjdGVkOiBcIiksIF9fX3dtbC5ub2RlKCdiJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaWQnOiBcInNlbGVjdGVkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIihub3RoaW5nKVwiKV0sIF9fX3ZpZXcpLCBfX193bWwudGV4dChcIi5cIildLCBfX192aWV3KSwgX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoYXV0b2NvbXBsZXRlXzEuQXV0b2NvbXBsZXRlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpZCc6IF9fX2NvbnRleHQudmFsdWVzLmlkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IF9fX2NvbnRleHQudmFsdWVzLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc3RyaW5naWZpZXInOiBmdW5jdGlvbiAocikgeyByZXR1cm4gci52YWx1ZTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvblNlYXJjaCc6IF9fX2NvbnRleHQub25TZWFyY2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25TZWxlY3QnOiBfX19jb250ZXh0Lm9uU2VsZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRvY29tcGxldGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBQYWdlXzEgPSByZXF1aXJlKFwiLi4vUGFnZVwiKTtcbnZhciBicmVhZGNydW1ic18xID0gcmVxdWlyZShcIi4vd21sL2JyZWFkY3J1bWJzXCIpO1xudmFyIEJyZWFkQ3J1bWJzUGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQnJlYWRDcnVtYnNQYWdlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJyZWFkQ3J1bWJzUGFnZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgYnJlYWRjcnVtYnNfMS5NYWluKF90aGlzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQnJlYWRDcnVtYnNQYWdlO1xufShQYWdlXzEuUGFnZSkpO1xuZXhwb3J0cy5CcmVhZENydW1ic1BhZ2UgPSBCcmVhZENydW1ic1BhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIEdyaWRfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2xheW91dC9ncmlkL0dyaWRcIik7XG47XG52YXIgQnJlYWRDcnVtYnNfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL25hdi9icmVhZGNydW1icy9CcmVhZENydW1ic1wiKTtcbjtcbnZhciBJdGVtXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9uYXYvYnJlYWRjcnVtYnMvSXRlbVwiKTtcbjtcbnZhciBMaW5rXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9uYXYvbGluay9MaW5rXCIpO1xuO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwud2lkZ2V0KEdyaWRfMS5HcmlkLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoR3JpZF8xLlJvdywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KEdyaWRfMS5Db2x1bW4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChCcmVhZENydW1ic18xLkJyZWFkQ3J1bWJzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoSXRlbV8xLkl0ZW0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChMaW5rXzEuTGluaywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IFwiT25lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQoSXRlbV8xLkl0ZW0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChMaW5rXzEuTGluaywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IFwiVHdvXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQoSXRlbV8xLkl0ZW0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChMaW5rXzEuTGluaywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IFwiVGhyZWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyZWFkY3J1bWJzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYnVzeV9pbmRpY2F0b3JfMSA9IHJlcXVpcmUoXCIuL3dtbC9idXN5LWluZGljYXRvclwiKTtcbnZhciBQYWdlXzEgPSByZXF1aXJlKFwiLi4vUGFnZVwiKTtcbnZhciBCdXN5SW5kaWNhdG9yUGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQnVzeUluZGljYXRvclBhZ2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQnVzeUluZGljYXRvclBhZ2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IGJ1c3lfaW5kaWNhdG9yXzEuTWFpbihfdGhpcyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEJ1c3lJbmRpY2F0b3JQYWdlO1xufShQYWdlXzEuUGFnZSkpO1xuZXhwb3J0cy5CdXN5SW5kaWNhdG9yUGFnZSA9IEJ1c3lJbmRpY2F0b3JQYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBCdXN5SW5kaWNhdG9yXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9hcHAvYnVzeS1pbmRpY2F0b3IvQnVzeUluZGljYXRvclwiKTtcbjtcbnZhciBHcmlkXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9sYXlvdXQvZ3JpZC9HcmlkXCIpO1xuO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwud2lkZ2V0KEdyaWRfMS5HcmlkLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoR3JpZF8xLlJvdywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KEdyaWRfMS5Db2x1bW4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChCdXN5SW5kaWNhdG9yXzEuQnVzeUluZGljYXRvciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idXN5LWluZGljYXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2J1dHRvbi1tZW51XCIpO1xudmFyIFBhZ2VfMSA9IHJlcXVpcmUoXCIuLi9QYWdlXCIpO1xudmFyIEJ1dHRvbk1lbnVQYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCdXR0b25NZW51UGFnZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCdXR0b25NZW51UGFnZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLm9uQ2xpY2sgPSBmdW5jdGlvbiAobXNnKSB7IHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgYWxlcnQobXNnKTtcbiAgICAgICAgfTsgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQnV0dG9uTWVudVBhZ2U7XG59KFBhZ2VfMS5QYWdlKSk7XG5leHBvcnRzLkJ1dHRvbk1lbnVQYWdlID0gQnV0dG9uTWVudVBhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIEdyaWRfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2xheW91dC9ncmlkL0dyaWRcIik7XG47XG52YXIgYnV0dG9uX21lbnVfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL21lbnUvYnV0dG9uLW1lbnVcIik7XG47XG52YXIgbWVudV8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvbWVudVwiKTtcbjtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLndpZGdldChHcmlkXzEuR3JpZCwge1xuICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KEdyaWRfMS5Sb3csIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChHcmlkXzEuQ29sdW1uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplJzogNlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoYnV0dG9uX21lbnVfMS5CdXR0b25NZW51LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQnOiBcIkNsaWNrIE1lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KG1lbnVfMS5NZW51SXRlbSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgnYScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdocmVmJzogXCIjXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbmNsaWNrJzogX19fY29udGV4dC5vbkNsaWNrKFwiWW91IGNsaWNrZWQgb25lXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCJPbmVcIildLCBfX192aWV3KV0sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KG1lbnVfMS5NZW51SXRlbSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgnYScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdocmVmJzogXCIjXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbmNsaWNrJzogX19fY29udGV4dC5vbkNsaWNrKFwiWW91IGNsaWNrZWQgdHdvXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCJUd29cIildLCBfX192aWV3KV0sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KG1lbnVfMS5NZW51SXRlbSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgnYScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdocmVmJzogXCIjXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbmNsaWNrJzogX19fY29udGV4dC5vbkNsaWNrKFwiWW91IGNsaWNrZWQgdGhyZWVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIlRocmVlXCIpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnV0dG9uLW1lbnUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9idXR0b24tc2VsZWN0XCIpO1xudmFyIFBhZ2VfMSA9IHJlcXVpcmUoXCIuLi9QYWdlXCIpO1xudmFyIEJ1dHRvblNlbGVjdFBhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJ1dHRvblNlbGVjdFBhZ2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQnV0dG9uU2VsZWN0UGFnZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIG9wdGlvbnM6IFtcbiAgICAgICAgICAgICAgICB7IHRleHQ6ICdBc3VzJywgdmFsdWU6ICdBc3VzJyB9LFxuICAgICAgICAgICAgICAgIHsgdGV4dDogJ01TSScsIHZhbHVlOiAnTVNJJyB9LFxuICAgICAgICAgICAgICAgIHsgdGV4dDogJ0dpZ2FieXRlJywgdmFsdWU6ICdHaWdhYnl0ZScgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gX2EudmFsdWUsIG5hbWUgPSBfYS5uYW1lO1xuICAgICAgICAgICAgX3RoaXNcbiAgICAgICAgICAgICAgICAudmlld1xuICAgICAgICAgICAgICAgIC5maW5kQnlJZChuYW1lICsgXCItY29udGVudFwiKVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZS5sYXN0Q2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIGUucmVtb3ZlQ2hpbGQoZS5sYXN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKHZhbHVlKSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEJ1dHRvblNlbGVjdFBhZ2U7XG59KFBhZ2VfMS5QYWdlKSk7XG5leHBvcnRzLkJ1dHRvblNlbGVjdFBhZ2UgPSBCdXR0b25TZWxlY3RQYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBHcmlkXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9sYXlvdXQvZ3JpZC9HcmlkXCIpO1xuO1xudmFyIGJ1dHRvbl9zZWxlY3RfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbnRyb2wvYnV0dG9uLXNlbGVjdFwiKTtcbjtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLndpZGdldChHcmlkXzEuR3JpZCwge1xuICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KEdyaWRfMS5Sb3csIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChHcmlkXzEuQ29sdW1uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC5ub2RlKCdwJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIllvdSBzZWxlY3RlZDogXCIpLCBfX193bWwubm9kZSgnYicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogXCJzZWxlY3QtY29udGVudFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCIoTm9uZSlcIildLCBfX192aWV3KSwgX19fd21sLnRleHQoXCIuXCIpXSwgX19fdmlldyksIF9fX3dtbC5ub2RlKCdwJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KGJ1dHRvbl9zZWxlY3RfMS5CdXR0b25TZWxlY3QsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogXCJzZWxlY3RcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBcInNlbGVjdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3ZhcmlhbnQnOiBcIi1wcmltYXJ5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb3B0aW9ucyc6IF9fX2NvbnRleHQudmFsdWVzLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25DaGFuZ2UnOiBfX19jb250ZXh0Lm9uQ2hhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQoR3JpZF8xLlJvdywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KEdyaWRfMS5Db2x1bW4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiWW91IGNhbiBhbHNvIHVzZSBNdWx0aUJ1dHRvblNlbGVjdCBpbnN0ZWFkOiBcIiksIF9fX3dtbC5ub2RlKCdiJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaWQnOiBcIm11bHRpLWNvbnRlbnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiKE5vbmUpXCIpXSwgX19fdmlldyksIF9fX3dtbC50ZXh0KFwiLlwiKV0sIF9fX3ZpZXcpLCBfX193bWwubm9kZSgncCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChidXR0b25fc2VsZWN0XzEuTXVsdGlCdXR0b25TZWxlY3QsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogXCJtdWx0aVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwibXVsdGlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd2YXJpYW50JzogXCItcHJpbWFyeVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29wdGlvbnMnOiBfX19jb250ZXh0LnZhbHVlcy5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2hhbmdlJzogX19fY29udGV4dC5vbkNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnV0dG9uLXNlbGVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2NoZWNrYm94XCIpO1xudmFyIFBhZ2VfMSA9IHJlcXVpcmUoXCIuLi9QYWdlXCIpO1xudmFyIENoZWNrYm94UGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2hlY2tib3hQYWdlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENoZWNrYm94UGFnZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICAgICAgX3RoaXMudmlldy5maW5kQnlJZCgnY29udGVudCcpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChlLmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIGUucmVtb3ZlQ2hpbGQoZS5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZhbHVlID09PSB0cnVlID9cbiAgICAgICAgICAgICAgICAgICAgJ29uJyA6XG4gICAgICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gZmFsc2UgPyAnb2ZmJyA6ICdlcnJvcicpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ2hlY2tib3hQYWdlO1xufShQYWdlXzEuUGFnZSkpO1xuZXhwb3J0cy5DaGVja2JveFBhZ2UgPSBDaGVja2JveFBhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIEdyaWRfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2xheW91dC9ncmlkL0dyaWRcIik7XG47XG52YXIgQ2hlY2tib3hfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbnRyb2wvY2hlY2tib3gvQ2hlY2tib3hcIik7XG47XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC53aWRnZXQoR3JpZF8xLkdyaWQsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChHcmlkXzEuUm93LCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoR3JpZF8xLkNvbHVtbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgncCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCJUaGUgY2hlY2tib3ggaXMgXCIpLCBfX193bWwubm9kZSgnYicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogXCJjb250ZW50XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcInVudG91Y2hlZFwiKV0sIF9fX3ZpZXcpLCBfX193bWwudGV4dChcIi5cIildLCBfX192aWV3KSwgX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoQ2hlY2tib3hfMS5DaGVja2JveCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogXCJjaGVja2JveFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2hhbmdlJzogX19fY29udGV4dC5vbkNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlY2tib3guanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9kYXRlXCIpO1xudmFyIFBhZ2VfMSA9IHJlcXVpcmUoXCIuLi9QYWdlXCIpO1xudmFyIERhdGVQYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEYXRlUGFnZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEYXRlUGFnZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgIF90aGlzXG4gICAgICAgICAgICAgICAgLnZpZXdcbiAgICAgICAgICAgICAgICAuZmluZEJ5SWQoJ3NlbGVjdGVkJylcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGUubGFzdENoaWxkKVxuICAgICAgICAgICAgICAgICAgICBlLnJlbW92ZUNoaWxkKGUubGFzdENoaWxkKTtcbiAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZhbHVlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gRGF0ZVBhZ2U7XG59KFBhZ2VfMS5QYWdlKSk7XG5leHBvcnRzLkRhdGVQYWdlID0gRGF0ZVBhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIEdyaWRfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2xheW91dC9ncmlkL0dyaWRcIik7XG47XG52YXIgRGF0ZV8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29udHJvbC9kYXRlL0RhdGVcIik7XG47XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC53aWRnZXQoR3JpZF8xLkdyaWQsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChHcmlkXzEuUm93LCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoR3JpZF8xLkNvbHVtbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgncCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCJUaGUgZGF0ZSBpcyA6IFwiKSwgX19fd21sLm5vZGUoJ2InLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpZCc6IFwic2VsZWN0ZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiKE5vbmUgc2VsZWN0ZWQpXCIpXSwgX19fdmlldyksIF9fX3dtbC50ZXh0KFwiLlwiKV0sIF9fX3ZpZXcpLCBfX193bWwubm9kZSgncCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChEYXRlXzEuRGF0ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaWQnOiBcImRhdGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBcImRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbkNoYW5nZSc6IF9fX2NvbnRleHQub25DaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBQYWdlXzEgPSByZXF1aXJlKFwiLi4vUGFnZVwiKTtcbnZhciBob21lXzEgPSByZXF1aXJlKFwiLi93bWwvaG9tZVwiKTtcbnZhciBIb21lUGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSG9tZVBhZ2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSG9tZVBhZ2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IGhvbWVfMS5NYWluKF90aGlzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSG9tZVBhZ2U7XG59KFBhZ2VfMS5QYWdlKSk7XG5leHBvcnRzLkhvbWVQYWdlID0gSG9tZVBhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnYicsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCJJbmRleFwiKV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhvbWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBQYWdlXzEgPSByZXF1aXJlKFwiLi4vUGFnZVwiKTtcbnZhciBsaXN0X2dyb3VwXzEgPSByZXF1aXJlKFwiLi93bWwvbGlzdC1ncm91cFwiKTtcbnZhciBMaXN0R3JvdXBQYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMaXN0R3JvdXBQYWdlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpc3RHcm91cFBhZ2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IGxpc3RfZ3JvdXBfMS5NYWluKF90aGlzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTGlzdEdyb3VwUGFnZTtcbn0oUGFnZV8xLlBhZ2UpKTtcbmV4cG9ydHMuTGlzdEdyb3VwUGFnZSA9IExpc3RHcm91cFBhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIEdyaWRfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2xheW91dC9ncmlkL0dyaWRcIik7XG47XG52YXIgbGlzdF9ncm91cF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvbGF5b3V0L2xpc3QtZ3JvdXBcIik7XG47XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC53aWRnZXQoR3JpZF8xLkdyaWQsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChHcmlkXzEuUm93LCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoR3JpZF8xLkNvbHVtbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KGxpc3RfZ3JvdXBfMS5MaXN0R3JvdXAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChsaXN0X2dyb3VwXzEuTGlzdEdyb3VwSXRlbSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgncCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCJUaGlzIGlzIHRoZSBmaXJzdCBpdGVtLlwiKV0sIF9fX3ZpZXcpXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQobGlzdF9ncm91cF8xLkxpc3RHcm91cEl0ZW0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ2InLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiVGhpcyBpcyB0aGUgc2Vjb25kIGl0ZW0uXCIpXSwgX19fdmlldyldLCBfX192aWV3KSwgX19fd21sLndpZGdldChsaXN0X2dyb3VwXzEuTGlzdEdyb3VwSXRlbSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgnaDMnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiV2hvYSFcIildLCBfX192aWV3KSwgX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiVGhpcyBpcyBhIHRoaXJkIGl0ZW0hXCIpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpc3QtZ3JvdXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBQYWdlXzEgPSByZXF1aXJlKFwiLi4vUGFnZVwiKTtcbnZhciBtZW51XzEgPSByZXF1aXJlKFwiLi93bWwvbWVudVwiKTtcbnZhciBNZW51UGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVudVBhZ2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVudVBhZ2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IG1lbnVfMS5NYWluKF90aGlzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWVudVBhZ2U7XG59KFBhZ2VfMS5QYWdlKSk7XG5leHBvcnRzLk1lbnVQYWdlID0gTWVudVBhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIEdyaWRfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2xheW91dC9ncmlkL0dyaWRcIik7XG47XG52YXIgbWVudV8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvbWVudVwiKTtcbjtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLndpZGdldChHcmlkXzEuR3JpZCwge1xuICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KEdyaWRfMS5Sb3csIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChHcmlkXzEuQ29sdW1uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQobWVudV8xLk1lbnUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChtZW51XzEuSGVhZGVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQnOiBcIkhlYWRpbmdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KG1lbnVfMS5NZW51SXRlbSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkaXNhYmxlZCc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IFwiQmFja1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQobWVudV8xLk1lbnVJdGVtLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQnOiBcIlJlZnJlc2hcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KG1lbnVfMS5EaXZpZGVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KG1lbnVfMS5NZW51SXRlbSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgnYScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaHJlZic6IFwiIy9tZW51XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIlF1aXRcIildLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVudS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFBhZ2VfMSA9IHJlcXVpcmUoXCIuLi9QYWdlXCIpO1xudmFyIHBhbmVsXzEgPSByZXF1aXJlKFwiLi93bWwvcGFuZWxcIik7XG52YXIgUGFuZWxQYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQYW5lbFBhZ2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGFuZWxQYWdlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyBwYW5lbF8xLk1haW4oX3RoaXMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBQYW5lbFBhZ2U7XG59KFBhZ2VfMS5QYWdlKSk7XG5leHBvcnRzLlBhbmVsUGFnZSA9IFBhbmVsUGFnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgR3JpZF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvbGF5b3V0L2dyaWQvR3JpZFwiKTtcbjtcbnZhciBQYW5lbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvbGF5b3V0L3BhbmVsL1BhbmVsXCIpO1xuO1xuO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwud2lkZ2V0KEdyaWRfMS5HcmlkLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoR3JpZF8xLlJvdywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KEdyaWRfMS5Db2x1bW4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemUnOiA0XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KFBhbmVsXzEuUGFuZWwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChQYW5lbF8xLkJvZHksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCJCb2R5IG9ubHkuXCIpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KEdyaWRfMS5Db2x1bW4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemUnOiA0XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KFBhbmVsXzEuUGFuZWwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChQYW5lbF8xLkhlYWRlciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIldpdGggSGVhZGVyXCIpXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQoUGFuZWxfMS5Cb2R5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiTG9yZW0gaW1wc3VtIGRpbGl1bSBuZXQgc2V0LlwiKV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KSwgX19fd21sLndpZGdldChHcmlkXzEuQ29sdW1uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplJzogNFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChQYW5lbF8xLlBhbmVsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoUGFuZWxfMS5IZWFkZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCJXaXRoIEZvb3RlclwiKV0sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KFBhbmVsXzEuQm9keSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIkxvcmVtIGltcHN1bSBkaWxpdW0gbmV0IHNldC5cIildLCBfX192aWV3KSwgX19fd21sLndpZGdldChQYW5lbF8xLkZvb3Rlciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIk1laCBmb290LlwiKV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFuZWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9zZWFyY2gtc3RhY2tcIik7XG52YXIgUGFnZV8xID0gcmVxdWlyZShcIi4uL1BhZ2VcIik7XG52YXIgb3B0aW9ucyA9IFtcbiAgICB7IGxhYmVsOiAnQXN1cycsIHZhbHVlOiAnQXN1cycgfSxcbiAgICB7IGxhYmVsOiAnTVNJJywgdmFsdWU6ICdNU0knIH0sXG4gICAgeyBsYWJlbDogJ0dpZ2FieXRlJywgdmFsdWU6ICdHaWdhYnl0ZScgfSxcbiAgICB7IGxhYmVsOiAnR2lnYXMnLCB2YWx1ZTogJ0dpZ2FzJyB9LFxuICAgIHsgbGFiZWw6ICdBc3VzVGVrJywgdmFsdWU6ICdBc3VzVGVrJyB9LFxuICAgIHsgbGFiZWw6ICdBc3VzdWdhJywgdmFsdWU6ICdBc3VzdWdhJyB9LFxuICAgIHsgbGFiZWw6ICdRdWFsY29tbScsIHZhbHVlOiAnUXVhbGNvbW0nIH0sXG4gICAgeyBsYWJlbDogJ1F1YWxpdGF0aXZlJywgdmFsdWU6ICdRdWFsaXRhdHZlJyB9LFxuICAgIHsgbGFiZWw6ICdBc3VuZGVyJywgdmFsdWU6ICdBc3VuZGVyJyB9XG5dO1xudmFyIFNlYXJjaFN0YWNrUGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2VhcmNoU3RhY2tQYWdlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNlYXJjaFN0YWNrUGFnZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiAnc2VhcmNoJyxcbiAgICAgICAgICAgIG5hbWU6ICdzZWFyY2gnLFxuICAgICAgICAgICAgdGV4dDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudmFsdWVzLnNlbGVjdGVkLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5sYWJlbDsgfSkuam9pbignLCcpOyB9LFxuICAgICAgICAgICAgc2VsZWN0ZWQ6IFtdLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vblNlYXJjaCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gX2EudmFsdWU7XG4gICAgICAgICAgICBfdGhpcy52aWV3LmZpbmRCeUlkKF90aGlzLnZhbHVlcy5pZCkubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHMudXBkYXRlKG9wdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnZhbHVlLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCh2YWx1ZS50b0xvd2VyQ2FzZSgpKTsgfSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgIF90aGlzLnZhbHVlcy5zZWxlY3RlZCA9IHZhbHVlO1xuICAgICAgICAgICAgX3RoaXMudmlldy5pbnZhbGlkYXRlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFNlYXJjaFN0YWNrUGFnZTtcbn0oUGFnZV8xLlBhZ2UpKTtcbmV4cG9ydHMuU2VhcmNoU3RhY2tQYWdlID0gU2VhcmNoU3RhY2tQYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBHcmlkXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9sYXlvdXQvZ3JpZC9HcmlkXCIpO1xuO1xudmFyIFNlYXJjaFN0YWNrXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb250cm9sL3NlYXJjaC1zdGFjay9TZWFyY2hTdGFja1wiKTtcbjtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLndpZGdldChHcmlkXzEuR3JpZCwge1xuICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KEdyaWRfMS5Sb3csIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChHcmlkXzEuQ29sdW1uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplJzogNlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiWW91IHNlbGVjdGVkOiBcIiksIF9fX3dtbC5ub2RlKCdiJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaWQnOiBcInRleHRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC5kb21pZnkoX19fY29udGV4dC52YWx1ZXMudGV4dCgpKV0sIF9fX3ZpZXcpLCBfX193bWwudGV4dChcIi5cIildLCBfX192aWV3KSwgX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoU2VhcmNoU3RhY2tfMS5TZWFyY2hTdGFjaywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaWQnOiBfX19jb250ZXh0LnZhbHVlcy5pZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBfX19jb250ZXh0LnZhbHVlcy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3ZhbHVlJzogX19fY29udGV4dC52YWx1ZXMuc2VsZWN0ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGVjb3JhdG9yJzogZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIubGFiZWw7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25DaGFuZ2UnOiBfX19jb250ZXh0Lm9uQ2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uU2VhcmNoJzogX19fY29udGV4dC5vblNlYXJjaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VhcmNoLXN0YWNrLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvc2VsZWN0XCIpO1xudmFyIFBhZ2VfMSA9IHJlcXVpcmUoXCIuLi9QYWdlXCIpO1xudmFyIFNlbGVjdFBhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlbGVjdFBhZ2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2VsZWN0UGFnZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIG9wdGlvbnM6IFtcbiAgICAgICAgICAgICAgICB7IGxhYmVsOiAnQXN1cycsIHZhbHVlOiAnQXN1cycgfSxcbiAgICAgICAgICAgICAgICB7IGxhYmVsOiAnTVNJJywgdmFsdWU6ICdNU0knIH0sXG4gICAgICAgICAgICAgICAgeyBsYWJlbDogJ0dpZ2FieXRlJywgdmFsdWU6ICdHaWdhYnl0ZScgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gX2EudmFsdWU7XG4gICAgICAgICAgICBfdGhpc1xuICAgICAgICAgICAgICAgIC52aWV3XG4gICAgICAgICAgICAgICAgLmZpbmRCeUlkKCdzZWxlY3RlZCcpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChlLmxhc3RDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgZS5yZW1vdmVDaGlsZChlLmxhc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWx1ZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFNlbGVjdFBhZ2U7XG59KFBhZ2VfMS5QYWdlKSk7XG5leHBvcnRzLlNlbGVjdFBhZ2UgPSBTZWxlY3RQYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBHcmlkXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9sYXlvdXQvZ3JpZC9HcmlkXCIpO1xuO1xudmFyIFNlbGVjdF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29udHJvbC9zZWxlY3QvU2VsZWN0XCIpO1xuO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwud2lkZ2V0KEdyaWRfMS5HcmlkLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoR3JpZF8xLlJvdywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KEdyaWRfMS5Db2x1bW4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiWW91IHNlbGVjdGVkOiBcIiksIF9fX3dtbC5ub2RlKCdiJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaWQnOiBcInNlbGVjdGVkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIihOb25lKVwiKV0sIF9fX3ZpZXcpLCBfX193bWwudGV4dChcIi5cIildLCBfX192aWV3KSwgX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoU2VsZWN0XzEuU2VsZWN0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpZCc6IFwic2VsZWN0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogXCJzZWxlY3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvcHRpb25zJzogX19fY29udGV4dC52YWx1ZXMub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbkNoYW5nZSc6IF9fX2NvbnRleHQub25DaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlbGVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL3N0YWNrXCIpO1xudmFyIFBhZ2VfMSA9IHJlcXVpcmUoXCIuLi9QYWdlXCIpO1xudmFyIF9nZXRWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyBsYWJlbDogJ0FzdXMnLCB2YWx1ZTogJ0FzdXMnIH0sXG4gICAgeyBsYWJlbDogJ01TSScsIHZhbHVlOiAnTVNJJyB9LFxuICAgIHsgbGFiZWw6ICdNU0knLCB2YWx1ZTogJ01TSScgfSxcbiAgICB7IGxhYmVsOiAnR2lnYWJ5dGUnLCB2YWx1ZTogJ0dpZ2FieXRlJyB9XG5dOyB9O1xudmFyIF9nZXRUZXh0ID0gZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0ubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBsYWJlbCA9IF9hLmxhYmVsO1xuICAgIHJldHVybiBsYWJlbDtcbn0pLmpvaW4oJywnKTsgfTtcbnZhciBTdGFja1BhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN0YWNrUGFnZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdGFja1BhZ2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICB2YWx1ZXM6IF9nZXRWYWx1ZXMoKSxcbiAgICAgICAgICAgIHRleHQ6IF9nZXRUZXh0KF9nZXRWYWx1ZXMoKSksXG4gICAgICAgICAgICBkZWNvcmF0b3I6IGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLmxhYmVsOyB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgX3RoaXMudmFsdWVzLnZhbHVlcyA9IF9nZXRWYWx1ZXMoKTtcbiAgICAgICAgICAgIF90aGlzLnZhbHVlcy50ZXh0ID0gX2dldFRleHQoX3RoaXMudmFsdWVzLnZhbHVlcyk7XG4gICAgICAgICAgICBfdGhpcy52aWV3LmludmFsaWRhdGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gU3RhY2tQYWdlO1xufShQYWdlXzEuUGFnZSkpO1xuZXhwb3J0cy5TdGFja1BhZ2UgPSBTdGFja1BhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIEdyaWRfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2xheW91dC9ncmlkL0dyaWRcIik7XG47XG52YXIgc3RhY2tfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbnRyb2wvc3RhY2tcIik7XG47XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC53aWRnZXQoR3JpZF8xLkdyaWQsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChHcmlkXzEuUm93LCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoR3JpZF8xLkNvbHVtbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZSc6IDRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC5ub2RlKCdwJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIk1lbWJlcnM6IFwiKSwgX19fd21sLm5vZGUoJ2InLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpZCc6IFwic2VsZWN0ZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC5kb21pZnkoX19fY29udGV4dC52YWx1ZXMudGV4dCldLCBfX192aWV3KSwgX19fd21sLnRleHQoXCIuXCIpXSwgX19fdmlldyksIF9fX3dtbC5ub2RlKCdwJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KHN0YWNrXzEuU3RhY2ssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwic3RhY2tcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd2YWx1ZSc6IF9fX2NvbnRleHQudmFsdWVzLnZhbHVlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkZWNvcmF0b3InOiBfX19jb250ZXh0LnZhbHVlcy5kZWNvcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25DaGFuZ2UnOiBfX19jb250ZXh0Lm9uQ2hhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGFjay5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL3N3aXRjaFwiKTtcbnZhciBQYWdlXzEgPSByZXF1aXJlKFwiLi4vUGFnZVwiKTtcbnZhciBTd2l0Y2hQYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTd2l0Y2hQYWdlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN3aXRjaFBhZ2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZSA9IHRydWU7XG4gICAgICAgIF90aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgIF90aGlzLnZpZXcuZmluZEJ5SWQoJ2NvbnRlbnQnKVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZS5maXJzdENoaWxkKVxuICAgICAgICAgICAgICAgICAgICBlLnJlbW92ZUNoaWxkKGUuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWx1ZSA9PT0gdHJ1ZSA/XG4gICAgICAgICAgICAgICAgICAgICdvbicgOlxuICAgICAgICAgICAgICAgICAgICAodmFsdWUgPT09IGZhbHNlID8gJ29mZicgOiAnZXJyb3InKSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFN3aXRjaFBhZ2U7XG59KFBhZ2VfMS5QYWdlKSk7XG5leHBvcnRzLlN3aXRjaFBhZ2UgPSBTd2l0Y2hQYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBHcmlkXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9sYXlvdXQvZ3JpZC9HcmlkXCIpO1xuO1xudmFyIFN3aXRjaF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29udHJvbC9zd2l0Y2gvU3dpdGNoXCIpO1xuO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwud2lkZ2V0KEdyaWRfMS5HcmlkLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoR3JpZF8xLlJvdywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KEdyaWRfMS5Db2x1bW4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiVGhlIHN3aXRjaCBpcyBcIiksIF9fX3dtbC5ub2RlKCdiJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaWQnOiBcImNvbnRlbnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwidW50b3VjaGVkXCIpXSwgX19fdmlldyksIF9fX3dtbC50ZXh0KFwiLlwiKV0sIF9fX3ZpZXcpLCBfX193bWwubm9kZSgncCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChTd2l0Y2hfMS5Td2l0Y2gsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwic3dpdGNoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25DaGFuZ2UnOiBfX19jb250ZXh0Lm9uQ2hhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zd2l0Y2guanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVzZXJzID0gW1xuICAgIHtcbiAgICAgICAgXCJfaWRcIjogXCI1OWYxMzM0Y2NjMjFmZjcyOGNmN2YzY2VcIixcbiAgICAgICAgXCJpbmRleFwiOiAwLFxuICAgICAgICBcImd1aWRcIjogXCJmZDk0Y2Q1Mi1lN2YxLTQ0YWItYTc0Zi0wNTYwNGVlZTQ2ZGRcIixcbiAgICAgICAgXCJpc0FjdGl2ZVwiOiBmYWxzZSxcbiAgICAgICAgXCJiYWxhbmNlXCI6IFwiJDIsODQ5LjkzXCIsXG4gICAgICAgIFwicGljdHVyZVwiOiBcImh0dHA6Ly9wbGFjZWhvbGQuaXQvMzJ4MzJcIixcbiAgICAgICAgXCJhZ2VcIjogMzQsXG4gICAgICAgIFwiZXllQ29sb3JcIjogXCJncmVlblwiLFxuICAgICAgICBcIm5hbWVcIjogXCJKb2hucyBMZXdpc1wiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIixcbiAgICAgICAgXCJjb21wYW55XCI6IFwiUFJPRkxFWFwiLFxuICAgICAgICBcImVtYWlsXCI6IFwiam9obnNsZXdpc0Bwcm9mbGV4LmNvbVwiLFxuICAgICAgICBcInBob25lXCI6IFwiKzEgKDkyNSkgNDA5LTM0MDBcIixcbiAgICAgICAgXCJhZGRyZXNzXCI6IFwiODc0IEdyb3ZlIFN0cmVldCwgRWRnZXdhdGVyLCBHZW9yZ2lhLCA4MTEyXCIsXG4gICAgICAgIFwiYWJvdXRcIjogXCJFeCBlc3NlIGRvbG9yZSBldCBzaW50IHNpbnQgcHJvaWRlbnQgbm9zdHJ1ZCB1dCBvZmZpY2lhLiBEbyBudWxsYSBtb2xsaXQgZG9sb3JlIHV0IGF1dGUgZXhjZXB0ZXVyIGRlc2VydW50IGxhYm9yaXMgdXQgcHJvaWRlbnQuIFVsbGFtY28gZXN0IGRlc2VydW50IGV4IGNvbW1vZG8gdmVuaWFtIGR1aXMgZWxpdCBleGNlcHRldXIgdmVsaXQgdWxsYW1jbyBkZXNlcnVudCBjdWxwYSBkbyBlc3QuXFxyXFxuXCIsXG4gICAgICAgIFwicmVnaXN0ZXJlZFwiOiBcIjIwMTUtMDItMjJUMTA6MjU6MzIgKzA0OjAwXCIsXG4gICAgICAgIFwibGF0aXR1ZGVcIjogNTYuMjc4ODYyLFxuICAgICAgICBcImxvbmdpdHVkZVwiOiAtNzkuNDU5MTAxLFxuICAgICAgICBcInRhZ3NcIjogW1xuICAgICAgICAgICAgXCJsYWJvcmVcIixcbiAgICAgICAgICAgIFwicHJvaWRlbnRcIixcbiAgICAgICAgICAgIFwiYWxpcXVhXCIsXG4gICAgICAgICAgICBcImFtZXRcIixcbiAgICAgICAgICAgIFwiYW1ldFwiLFxuICAgICAgICAgICAgXCJvZmZpY2lhXCIsXG4gICAgICAgICAgICBcImVuaW1cIlxuICAgICAgICBdLFxuICAgICAgICBcImZyaWVuZHNcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogMCxcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJNYXNvbiBOb2JsZVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogMSxcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJDb2ZmZXkgTWVuZGV6XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiAyLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkRpb25uZSBDb2xlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgXCJncmVldGluZ1wiOiBcIkhlbGxvLCBKb2hucyBMZXdpcyEgWW91IGhhdmUgNSB1bnJlYWQgbWVzc2FnZXMuXCIsXG4gICAgICAgIFwiZmF2b3JpdGVGcnVpdFwiOiBcImJhbmFuYVwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiX2lkXCI6IFwiNTlmMTMzNGMwOWRjMWJjZGM1NzMyNDkxXCIsXG4gICAgICAgIFwiaW5kZXhcIjogMSxcbiAgICAgICAgXCJndWlkXCI6IFwiMzMyNTU5OTUtMDQzMS00MjcxLTk4NzYtMzdlYWJjMTE3YTdiXCIsXG4gICAgICAgIFwiaXNBY3RpdmVcIjogZmFsc2UsXG4gICAgICAgIFwiYmFsYW5jZVwiOiBcIiQyLDE2Ny40MFwiLFxuICAgICAgICBcInBpY3R1cmVcIjogXCJodHRwOi8vcGxhY2Vob2xkLml0LzMyeDMyXCIsXG4gICAgICAgIFwiYWdlXCI6IDIzLFxuICAgICAgICBcImV5ZUNvbG9yXCI6IFwiYmx1ZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJXaWxsaWFtc29uIEdyZWdvcnlcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCIsXG4gICAgICAgIFwiY29tcGFueVwiOiBcIk5FVEFHWVwiLFxuICAgICAgICBcImVtYWlsXCI6IFwid2lsbGlhbXNvbmdyZWdvcnlAbmV0YWd5LmNvbVwiLFxuICAgICAgICBcInBob25lXCI6IFwiKzEgKDkxMCkgNDYyLTM5MThcIixcbiAgICAgICAgXCJhZGRyZXNzXCI6IFwiMTU4IFNlZGd3aWNrIFN0cmVldCwgR2xhc2dvdywgVXRhaCwgNTQ5OFwiLFxuICAgICAgICBcImFib3V0XCI6IFwiRXhjZXB0ZXVyIHNpdCBuaXNpIGV0IHZlbGl0LiBMYWJvcmlzIG1pbmltIGlkIGR1aXMgYWQgcXVpIGN1cGlkYXRhdC4gRXN0IExvcmVtIHF1aXMgZHVpcyBMb3JlbSBsYWJvcmlzIHZlbGl0IGxhYm9yaXMgbm9uIGV4Y2VwdGV1ciBldCB2ZWxpdCB2b2x1cHRhdGUgcXVpLiBEb2xvcmUgcXVpIGFuaW0gZXhlcmNpdGF0aW9uIHZlbmlhbSBpbmNpZGlkdW50IGxhYm9yaXMgbGFib3JlLiBJZCBtaW5pbSBsYWJvcmUgYW1ldCBzdW50IGV4Y2VwdGV1ciB0ZW1wb3IgcHJvaWRlbnQuXFxyXFxuXCIsXG4gICAgICAgIFwicmVnaXN0ZXJlZFwiOiBcIjIwMTYtMDQtMjVUMDQ6MjU6MjQgKzA0OjAwXCIsXG4gICAgICAgIFwibGF0aXR1ZGVcIjogNTQuNDU3ODMzLFxuICAgICAgICBcImxvbmdpdHVkZVwiOiAxMjIuODAzNzY1LFxuICAgICAgICBcInRhZ3NcIjogW1xuICAgICAgICAgICAgXCJ0ZW1wb3JcIixcbiAgICAgICAgICAgIFwiZXhlcmNpdGF0aW9uXCIsXG4gICAgICAgICAgICBcImV0XCIsXG4gICAgICAgICAgICBcImVsaXRcIixcbiAgICAgICAgICAgIFwiZXhcIixcbiAgICAgICAgICAgIFwiY2lsbHVtXCIsXG4gICAgICAgICAgICBcImxhYm9yaXNcIlxuICAgICAgICBdLFxuICAgICAgICBcImZyaWVuZHNcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogMCxcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJOYXZhcnJvIFJlZXZlc1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogMSxcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJTdGFudG9uIFZpbmNlbnRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IDIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiQWxleGlzIEd1em1hblwiXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIFwiZ3JlZXRpbmdcIjogXCJIZWxsbywgV2lsbGlhbXNvbiBHcmVnb3J5ISBZb3UgaGF2ZSAxIHVucmVhZCBtZXNzYWdlcy5cIixcbiAgICAgICAgXCJmYXZvcml0ZUZydWl0XCI6IFwiYXBwbGVcIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIl9pZFwiOiBcIjU5ZjEzMzRjOWQ3OTk3ODliYzQ5NGEzY1wiLFxuICAgICAgICBcImluZGV4XCI6IDIsXG4gICAgICAgIFwiZ3VpZFwiOiBcIjE1OGZmYTVkLTE1ZGEtNGE5Zi1hMWRhLTBhNDhiNzZiODIyNlwiLFxuICAgICAgICBcImlzQWN0aXZlXCI6IGZhbHNlLFxuICAgICAgICBcImJhbGFuY2VcIjogXCIkMSwyODkuMzVcIixcbiAgICAgICAgXCJwaWN0dXJlXCI6IFwiaHR0cDovL3BsYWNlaG9sZC5pdC8zMngzMlwiLFxuICAgICAgICBcImFnZVwiOiAzMyxcbiAgICAgICAgXCJleWVDb2xvclwiOiBcImdyZWVuXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkRhbHRvbiBIb3VzZVwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIixcbiAgICAgICAgXCJjb21wYW55XCI6IFwiRVlFV0FYXCIsXG4gICAgICAgIFwiZW1haWxcIjogXCJkYWx0b25ob3VzZUBleWV3YXguY29tXCIsXG4gICAgICAgIFwicGhvbmVcIjogXCIrMSAoOTU5KSA1NTAtMjI2M1wiLFxuICAgICAgICBcImFkZHJlc3NcIjogXCIxMTYgSG93YXJkIEF2ZW51ZSwgUm9zc21vcmUsIE5ldyBZb3JrLCA2MzAyXCIsXG4gICAgICAgIFwiYWJvdXRcIjogXCJFbGl0IGV1IGlwc3VtIHBhcmlhdHVyIGR1aXMgbW9sbGl0IGV4IHF1aXMuIEFtZXQgbnVsbGEgZXhlcmNpdGF0aW9uIGxhYm9yaXMgbWluaW0gZnVnaWF0IHRlbXBvciBpbiBhbGlxdWEgbmlzaSBub3N0cnVkIGF1dGUuIER1aXMgbWluaW0gZXNzZSBpcnVyZSBpcnVyZSBmdWdpYXQgc2l0IG51bGxhIGV0IHRlbXBvciBuaXNpIGNpbGx1bSBwcm9pZGVudCBpZCBhZGlwaXNpY2luZy4gRXUgZWxpdCBtYWduYSBMb3JlbSBpcnVyZSBsYWJvcmUuIEFsaXF1aXAgaWQgc2ludCB2ZW5pYW0gYWRpcGlzaWNpbmcuIEFtZXQgZWl1c21vZCBtb2xsaXQgcmVwcmVoZW5kZXJpdCByZXByZWhlbmRlcml0IGRvbG9yZS5cXHJcXG5cIixcbiAgICAgICAgXCJyZWdpc3RlcmVkXCI6IFwiMjAxNy0wMi0yOFQwODo1MzowMCArMDQ6MDBcIixcbiAgICAgICAgXCJsYXRpdHVkZVwiOiAtMjUuNjc5Nzc0LFxuICAgICAgICBcImxvbmdpdHVkZVwiOiAyOS4zNzQ3ODEsXG4gICAgICAgIFwidGFnc1wiOiBbXG4gICAgICAgICAgICBcInF1aVwiLFxuICAgICAgICAgICAgXCJjaWxsdW1cIixcbiAgICAgICAgICAgIFwiYW5pbVwiLFxuICAgICAgICAgICAgXCJpcnVyZVwiLFxuICAgICAgICAgICAgXCJub25cIixcbiAgICAgICAgICAgIFwiY29tbW9kb1wiLFxuICAgICAgICAgICAgXCJkZXNlcnVudFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZnJpZW5kc1wiOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiAwLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkNhcm1lbGEgV2lsY294XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiAxLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkVsYmEgR2FyemFcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IDIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiR2Fycmlzb24gQ2h1cmNoXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgXCJncmVldGluZ1wiOiBcIkhlbGxvLCBEYWx0b24gSG91c2UhIFlvdSBoYXZlIDEgdW5yZWFkIG1lc3NhZ2VzLlwiLFxuICAgICAgICBcImZhdm9yaXRlRnJ1aXRcIjogXCJhcHBsZVwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiX2lkXCI6IFwiNTlmMTMzNGNkMTUxOGMzYTQ0ZDY5ZmZmXCIsXG4gICAgICAgIFwiaW5kZXhcIjogMyxcbiAgICAgICAgXCJndWlkXCI6IFwiNTEwOWJjNTAtOWE4ZS00MTg0LWFiYTAtNjc0MGRjMDBiNjA2XCIsXG4gICAgICAgIFwiaXNBY3RpdmVcIjogdHJ1ZSxcbiAgICAgICAgXCJiYWxhbmNlXCI6IFwiJDMsODkxLjgzXCIsXG4gICAgICAgIFwicGljdHVyZVwiOiBcImh0dHA6Ly9wbGFjZWhvbGQuaXQvMzJ4MzJcIixcbiAgICAgICAgXCJhZ2VcIjogMjIsXG4gICAgICAgIFwiZXllQ29sb3JcIjogXCJibHVlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlJheSBXaWxraW5zXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiLFxuICAgICAgICBcImNvbXBhbnlcIjogXCJFWFBPU0FcIixcbiAgICAgICAgXCJlbWFpbFwiOiBcInJheXdpbGtpbnNAZXhwb3NhLmNvbVwiLFxuICAgICAgICBcInBob25lXCI6IFwiKzEgKDgxMikgNDE0LTMyNThcIixcbiAgICAgICAgXCJhZGRyZXNzXCI6IFwiODM3IEJlZGZvcmQgQXZlbnVlLCBIYXJsZWlnaCwgU291dGggQ2Fyb2xpbmEsIDIzMjNcIixcbiAgICAgICAgXCJhYm91dFwiOiBcIkVzdCBhbWV0IHF1aXMgZXUgcHJvaWRlbnQgaXBzdW0gdmVuaWFtIHNpdC4gSXJ1cmUgbGFib3JlIGFkIGNvbnNlY3RldHVyIHVsbGFtY28gc2l0IGlwc3VtIHByb2lkZW50LiBBZCBwYXJpYXR1ciBpcnVyZSBuaXNpIGlydXJlIGNvbW1vZG8gYWxpcXVpcCBuaXNpIGV1IGFuaW0gaXJ1cmUgZG9sb3IgZG9sb3IgdmVuaWFtIHF1aXMuXFxyXFxuXCIsXG4gICAgICAgIFwicmVnaXN0ZXJlZFwiOiBcIjIwMTUtMDktMTdUMDQ6NTI6NDIgKzA0OjAwXCIsXG4gICAgICAgIFwibGF0aXR1ZGVcIjogMzQuMzU0ODAxLFxuICAgICAgICBcImxvbmdpdHVkZVwiOiAtMTY4LjMwMzk1MixcbiAgICAgICAgXCJ0YWdzXCI6IFtcbiAgICAgICAgICAgIFwibmlzaVwiLFxuICAgICAgICAgICAgXCJsYWJvcmlzXCIsXG4gICAgICAgICAgICBcImluY2lkaWR1bnRcIixcbiAgICAgICAgICAgIFwiYW1ldFwiLFxuICAgICAgICAgICAgXCJhdXRlXCIsXG4gICAgICAgICAgICBcInF1aXNcIixcbiAgICAgICAgICAgIFwibW9sbGl0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJmcmllbmRzXCI6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IDAsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiT2xpdmlhIFJ1c3NvXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiAxLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlJpdGEgVHlsZXJcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IDIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiTG9yaWUgV2Fsa2VyXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgXCJncmVldGluZ1wiOiBcIkhlbGxvLCBSYXkgV2lsa2lucyEgWW91IGhhdmUgMSB1bnJlYWQgbWVzc2FnZXMuXCIsXG4gICAgICAgIFwiZmF2b3JpdGVGcnVpdFwiOiBcInN0cmF3YmVycnlcIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIl9pZFwiOiBcIjU5ZjEzMzRjNjkwMWJkYTAwM2U1MmZhNlwiLFxuICAgICAgICBcImluZGV4XCI6IDQsXG4gICAgICAgIFwiZ3VpZFwiOiBcIjBhYjMzNDc3LWIxNTItNGIxMi1hZjM1LWY1YjkyNTRkNWMyYVwiLFxuICAgICAgICBcImlzQWN0aXZlXCI6IHRydWUsXG4gICAgICAgIFwiYmFsYW5jZVwiOiBcIiQzLDczMC43MVwiLFxuICAgICAgICBcInBpY3R1cmVcIjogXCJodHRwOi8vcGxhY2Vob2xkLml0LzMyeDMyXCIsXG4gICAgICAgIFwiYWdlXCI6IDI3LFxuICAgICAgICBcImV5ZUNvbG9yXCI6IFwiYnJvd25cIixcbiAgICAgICAgXCJuYW1lXCI6IFwiTWFkZGVuIEhhdGZpZWxkXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiLFxuICAgICAgICBcImNvbXBhbnlcIjogXCJaT0dBS1wiLFxuICAgICAgICBcImVtYWlsXCI6IFwibWFkZGVuaGF0ZmllbGRAem9nYWsuY29tXCIsXG4gICAgICAgIFwicGhvbmVcIjogXCIrMSAoODMyKSA1NTItMjI5NFwiLFxuICAgICAgICBcImFkZHJlc3NcIjogXCI1MzAgQ2xlcm1vbnQgQXZlbnVlLCBCZXRocGFnZSwgVmlyZ2luIElzbGFuZHMsIDU2MDdcIixcbiAgICAgICAgXCJhYm91dFwiOiBcIkNvbW1vZG8gdGVtcG9yIGFuaW0gdGVtcG9yIGRlc2VydW50IGxhYm9yaXMgcXVpIGV1IHJlcHJlaGVuZGVyaXQgY29uc2VxdWF0LiBOb24gbGFib3J1bSB1bGxhbWNvIHF1aSBwcm9pZGVudC4gRXN0IGN1cGlkYXRhdCBkbyBkb2xvciBleGNlcHRldXIgZXN0IG5vc3RydWQgbGFib3J1bS4gRXUgZXhjZXB0ZXVyIGV4IGNvbW1vZG8gYWxpcXVpcCBhZGlwaXNpY2luZyBleGNlcHRldXIuIEV0IHJlcHJlaGVuZGVyaXQgbGFib3JpcyByZXByZWhlbmRlcml0IGF1dGUgdXQgZXhjZXB0ZXVyIGRlc2VydW50IG5vc3RydWQgdmVsaXQuIFVsbGFtY28gZXN0IHNpdCBmdWdpYXQgaXJ1cmUgYWxpcXVhIGFsaXF1aXAgcHJvaWRlbnQuIFZvbHVwdGF0ZSBhZCBjdWxwYSBkb2xvciBpZCBlbmltIHRlbXBvciBsYWJvcnVtLlxcclxcblwiLFxuICAgICAgICBcInJlZ2lzdGVyZWRcIjogXCIyMDE2LTA0LTEwVDAzOjM3OjE3ICswNDowMFwiLFxuICAgICAgICBcImxhdGl0dWRlXCI6IDgwLjg4ODg3NixcbiAgICAgICAgXCJsb25naXR1ZGVcIjogMTE3Ljg0MzM3LFxuICAgICAgICBcInRhZ3NcIjogW1xuICAgICAgICAgICAgXCJvY2NhZWNhdFwiLFxuICAgICAgICAgICAgXCJuaXNpXCIsXG4gICAgICAgICAgICBcImVzdFwiLFxuICAgICAgICAgICAgXCJhZFwiLFxuICAgICAgICAgICAgXCJub3N0cnVkXCIsXG4gICAgICAgICAgICBcImV1XCIsXG4gICAgICAgICAgICBcImRvbG9yZVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZnJpZW5kc1wiOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiAwLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlZpbmNlbnQgR2F5XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiAxLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlJvc2FyaW8gRm9yYmVzXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiAyLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkJheHRlciBHcmVlblwiXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIFwiZ3JlZXRpbmdcIjogXCJIZWxsbywgTWFkZGVuIEhhdGZpZWxkISBZb3UgaGF2ZSA0IHVucmVhZCBtZXNzYWdlcy5cIixcbiAgICAgICAgXCJmYXZvcml0ZUZydWl0XCI6IFwiYmFuYW5hXCJcbiAgICB9XG5dO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFBhZ2VfMSA9IHJlcXVpcmUoXCIuLi9QYWdlXCIpO1xudmFyIHRhYmxlXzEgPSByZXF1aXJlKFwiLi93bWwvdGFibGVcIik7XG52YXIgZGF0YV8xID0gcmVxdWlyZShcIi4vZGF0YVwiKTtcbnZhciBmaWVsZHMgPSBbXG4gICAgeyBuYW1lOiAnaW5kZXgnLCBoZWFkaW5nOiAnIycgfSxcbiAgICB7IG5hbWU6ICduYW1lJywgaGVhZGluZzogJ05hbWUnIH0sXG4gICAgeyBuYW1lOiAnYmFsYW5jZScsIGhlYWRpbmc6ICdCYWxhbmNlJyB9XG5dO1xudmFyIFRhYmxlUGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFibGVQYWdlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYmxlUGFnZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdGFibGVfMS5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgdXNlcnM6IGRhdGFfMS51c2VycyxcbiAgICAgICAgICAgIGZpZWxkczogZmllbGRzXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRhYmxlUGFnZTtcbn0oUGFnZV8xLlBhZ2UpKTtcbmV4cG9ydHMuVGFibGVQYWdlID0gVGFibGVQYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBHcmlkXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9sYXlvdXQvZ3JpZC9HcmlkXCIpO1xuO1xudmFyIFRhYmxlXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi90YWJsZS90YWJsZS9UYWJsZVwiKTtcbjtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLndpZGdldChHcmlkXzEuR3JpZCwge1xuICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KEdyaWRfMS5Sb3csIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChHcmlkXzEuQ29sdW1uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoVGFibGVfMS5UYWJsZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NlbGVjdGFibGUnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YSc6IF9fX2NvbnRleHQudmFsdWVzLnVzZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZmllbGRzJzogX19fY29udGV4dC52YWx1ZXMuZmllbGRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvdGFic1wiKTtcbnZhciBQYWdlXzEgPSByZXF1aXJlKFwiLi4vUGFnZVwiKTtcbnZhciBUYWJzUGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFic1BhZ2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFic1BhZ2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy50YWIgPSAnRmlyc3QnO1xuICAgICAgICBfdGhpcy5jb250ZW50ID0gJ0ZpcnN0IFRhYic7XG4gICAgICAgIF90aGlzLmNsaWNrZWQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gX2EubmFtZTtcbiAgICAgICAgICAgIF90aGlzLnRhYiA9IG5hbWU7XG4gICAgICAgICAgICBfdGhpcy5jb250ZW50ID0gbmFtZSArIFwiIFRhYlwiO1xuICAgICAgICAgICAgX3RoaXMudmlldy5pbnZhbGlkYXRlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRhYnNQYWdlO1xufShQYWdlXzEuUGFnZSkpO1xuZXhwb3J0cy5UYWJzUGFnZSA9IFRhYnNQYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBHcmlkXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9sYXlvdXQvZ3JpZC9HcmlkXCIpO1xuO1xudmFyIFRhYnNfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbnRyb2wvdGFicy9UYWJzXCIpO1xuO1xudmFyIFRhYl8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29udHJvbC90YWJzL1RhYlwiKTtcbjtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLndpZGdldChHcmlkXzEuR3JpZCwge1xuICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KEdyaWRfMS5Sb3csIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChHcmlkXzEuQ29sdW1uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoVGFic18xLlRhYnMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChUYWJfMS5UYWIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYWN0aXZlJzogKF9fX2NvbnRleHQudGFiID09PSBcIkZpcnN0XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQnOiBcIkZpcnN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwiRmlyc3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbkNsaWNrJzogX19fY29udGV4dC5jbGlja2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQoVGFiXzEuVGFiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IChfX19jb250ZXh0LnRhYiA9PT0gXCJTZWNvbmRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IFwiU2Vjb25kXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwiU2Vjb25kXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25DbGljayc6IF9fX2NvbnRleHQuY2xpY2tlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KFRhYl8xLlRhYiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhY3RpdmUnOiAoX19fY29udGV4dC50YWIgPT09IFwiVGhpcmRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IFwiVGhpcmRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogXCJUaGlyZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2xpY2snOiBfX19jb250ZXh0LmNsaWNrZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KV0sIF9fX3ZpZXcpLCBfX193bWwubm9kZSgncCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogXCJjb250ZW50XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNvbnRlbnQpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFicy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL3RleHQtZmllbGRcIik7XG52YXIgUGFnZV8xID0gcmVxdWlyZShcIi4uL1BhZ2VcIik7XG52YXIgVGV4dEZpZWxkUGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGV4dEZpZWxkUGFnZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUZXh0RmllbGRQYWdlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaWQgPSAndGV4dCc7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgICh2YWx1ZSA9PT0gJ2ludmFsaWQnKSA/XG4gICAgICAgICAgICAgICAgX3RoaXMuZ2V0KF90aGlzLmlkLCBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYy5zZXRFcnJvcignVGhpcyBjb250cm9sIGlzIG5vdyBpbnZhbGlkIScpO1xuICAgICAgICAgICAgICAgIH0pIDpcbiAgICAgICAgICAgICAgICAodmFsdWUgPT09ICd2YWxpZCcpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZ2V0KF90aGlzLmlkLCBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMuc2V0U3VjY2VzcygnVGhpcyBjb250cm9sIGlzIG5vdyB2YWxpZCEnKTtcbiAgICAgICAgICAgICAgICAgICAgfSkgOlxuICAgICAgICAgICAgICAgICAgICAodmFsdWUgPT09ICd3YXJuJykgP1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZ2V0KF90aGlzLmlkLCBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjLnNldFdhcm5pbmcoJ1RoaXMgY29udHJvbCBub3cgaGFzIGEgd2FybmluZyEnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gJ3Jlc2V0JykgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmdldChfdGhpcy5pZCwgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMucmVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnZpZXdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmRCeUlkKCdjb250ZW50JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZS5sYXN0Q2hpbGQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnJlbW92ZUNoaWxkKGUubGFzdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBUZXh0RmllbGRQYWdlO1xufShQYWdlXzEuUGFnZSkpO1xuZXhwb3J0cy5UZXh0RmllbGRQYWdlID0gVGV4dEZpZWxkUGFnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgR3JpZF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvbGF5b3V0L2dyaWQvR3JpZFwiKTtcbjtcbnZhciBUZXh0RmllbGRfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbnRyb2wvdGV4dC1maWVsZC9UZXh0RmllbGRcIik7XG47XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC53aWRnZXQoR3JpZF8xLkdyaWQsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChHcmlkXzEuUm93LCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoR3JpZF8xLkNvbHVtbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgncCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCJUaGUgdmFsdWUgb2YgdGhlIGlucHV0IGlzOlwiKV0sIF9fX3ZpZXcpLCBfX193bWwubm9kZSgncCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogXCJjb250ZW50XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeShcIihOb3RoaW5nKVwiKV0sIF9fX3ZpZXcpLCBfX193bWwubm9kZSgncCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChUZXh0RmllbGRfMS5UZXh0RmllbGQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogXCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25DaGFuZ2UnOiBfX19jb250ZXh0Lm9uQ2hhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQoR3JpZF8xLlJvdywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KEdyaWRfMS5Db2x1bW4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC5ub2RlKCdzdHJvbmcnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiU3VjY2Vzc1wiKV0sIF9fX3ZpZXcpXSwgX19fdmlldyksIF9fX3dtbC5ub2RlKCdwJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KFRleHRGaWVsZF8xLlRleHRGaWVsZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc3VjY2Vzcyc6IFwiVGhpcyB0ZXh0ZmllbGQgaGFzIGEgc3VjY2Vzc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2hhbmdlJzogX19fY29udGV4dC5vbkNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KEdyaWRfMS5Sb3csIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChHcmlkXzEuQ29sdW1uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC5ub2RlKCdwJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgnc3Ryb25nJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIldhcm5pbmdcIildLCBfX192aWV3KV0sIF9fX3ZpZXcpLCBfX193bWwubm9kZSgncCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChUZXh0RmllbGRfMS5UZXh0RmllbGQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3dhcm5pbmcnOiBcIlRoaXMgdGV4dGZpZWxkIGhhcyBhIHdhcm5pbmcuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25DaGFuZ2UnOiBfX19jb250ZXh0Lm9uQ2hhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQoR3JpZF8xLlJvdywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KEdyaWRfMS5Db2x1bW4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC5ub2RlKCdzdHJvbmcnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiRXJyb3JcIildLCBfX192aWV3KV0sIF9fX3ZpZXcpLCBfX193bWwubm9kZSgncCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChUZXh0RmllbGRfMS5UZXh0RmllbGQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2Vycm9yJzogXCJUaGlzIHRleHRmaWVsZCBoYXMgYW4gZXJyb3IuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25DaGFuZ2UnOiBfX19jb250ZXh0Lm9uQ2hhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQoR3JpZF8xLlJvdywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KEdyaWRfMS5Db2x1bW4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiVGhlIG9uZSB1c2VzIHJvd3MgdG8gcmVuZGVyIGEgdGV4dCBhcmVhOlwiKV0sIF9fX3ZpZXcpLCBfX193bWwubm9kZSgncCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChUZXh0RmllbGRfMS5UZXh0RmllbGQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3Jvd3MnOiAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2hhbmdlJzogX19fY29udGV4dC5vbkNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGV4dC1maWVsZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIERyYXdlcl8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvbGF5b3V0L2RyYXdlci9EcmF3ZXJcIik7XG47XG52YXIgQWN0aW9uQmFyXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9hcHAvYWN0aW9uLWJhci9BY3Rpb25CYXJcIik7XG47XG47XG52YXIgSWNvbkJ1dHRvbl8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29udHJvbC9pY29uLWJ1dHRvbi9JY29uQnV0dG9uXCIpO1xuO1xudmFyIGRhc2hfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2FwcC9kYXNoXCIpO1xuO1xudmFyIE1haW5fMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2xheW91dC9tYWluL01haW5cIik7XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC53aWRnZXQoRHJhd2VyXzEuRHJhd2VyLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICdpZCc6IF9fX2NvbnRleHQudmFsdWVzLmlkLmxheW91dFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2RyYXdlcic6IF9fX2NvbnRleHQubmF2aWdhdGlvblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KEFjdGlvbkJhcl8xLkFjdGlvbkJhciwge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KEljb25CdXR0b25fMS5JY29uQnV0dG9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbkNsaWNrJzogX19fY29udGV4dC50b2dnbGVEcmF3ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoZGFzaF8xLkRhc2gsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQoZGFzaF8xLkRhc2gsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQoZGFzaF8xLkRhc2gsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KE1haW5fMS5NYWluLCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC5kb21pZnkoX19fY29udGV4dC5jb250ZW50LnJlbmRlcigpKV0sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG47XG52YXIgbWVudV8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvbmF2L21lbnVcIik7XG52YXIgTmF2aWdhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTmF2aWdhdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOYXZpZ2F0aW9uKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC53aWRnZXQobWVudV8xLk1lbnUsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChtZW51XzEuTGluaywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnZ3JvdXAnOiBcImxpbmtzXCJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhY3RpdmUnOiAoX19fY29udGV4dC5wYWdlID09PSBcImhvbWVcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwiaG9tZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2hyZWYnOiBcIiNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICdvbkNsaWNrJzogX19fY29udGV4dC5uYXZpZ2F0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0JzogXCJIb21lXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KSwgX19fd21sLndpZGdldChtZW51XzEuSGVhZGVyLCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQnOiBcIkxheW91dFwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQobWVudV8xLlN1Yk1lbnUsIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChtZW51XzEuTGluaywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZ3JvdXAnOiBcImxpbmtzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogXCJwYW5lbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdocmVmJzogXCIjL3BhbmVsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2xpY2snOiBfX19jb250ZXh0Lm5hdmlnYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhY3RpdmUnOiAoX19fY29udGV4dC5wYWdlID09PSBcInBhbmVsXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0JzogXCJQYW5lbHNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQobWVudV8xLkxpbmssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2dyb3VwJzogXCJsaW5rc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwibGlzdC1ncm91cFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdocmVmJzogXCIjL2xpc3QtZ3JvdXBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25DbGljayc6IF9fX2NvbnRleHQubmF2aWdhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IChfX19jb250ZXh0LnBhZ2UgPT09IFwibGlzdC1ncm91cFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IFwiTGlzdCBHcm91cFwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KV0sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KG1lbnVfMS5IZWFkZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IFwiVGFibGVcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KG1lbnVfMS5TdWJNZW51LCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQobWVudV8xLkxpbmssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2dyb3VwJzogXCJsaW5rc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwidGFibGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaHJlZic6IFwiIy90YWJsZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbkNsaWNrJzogX19fY29udGV4dC5uYXZpZ2F0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYWN0aXZlJzogKF9fX2NvbnRleHQucGFnZSA9PT0gXCJ0YWJsZVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IFwiVGFibGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyldLCBfX192aWV3KSwgX19fd21sLndpZGdldChtZW51XzEuSGVhZGVyLCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQnOiBcIkNvbnRyb2xcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KG1lbnVfMS5TdWJNZW51LCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQobWVudV8xLkxpbmssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2dyb3VwJzogXCJsaW5rc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwidGV4dC1maWVsZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdocmVmJzogXCIjL3RleHQtZmllbGRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25DbGljayc6IF9fX2NvbnRleHQubmF2aWdhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IChfX19jb250ZXh0LnBhZ2UgPT09IFwidGV4dC1maWVsZFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IFwiVGV4dCBGaWVsZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KSwgX19fd21sLndpZGdldChtZW51XzEuTGluaywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZ3JvdXAnOiBcImxpbmtzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2hyZWYnOiBcIiMvZGF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbkNsaWNrJzogX19fY29udGV4dC5uYXZpZ2F0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYWN0aXZlJzogKF9fX2NvbnRleHQucGFnZSA9PT0gXCJkYXRlXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0JzogXCJEYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KG1lbnVfMS5MaW5rLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdncm91cCc6IFwibGlua3NcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBcInNlbGVjdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdocmVmJzogXCIjL3NlbGVjdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbkNsaWNrJzogX19fY29udGV4dC5uYXZpZ2F0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYWN0aXZlJzogKF9fX2NvbnRleHQucGFnZSA9PT0gXCJzZWxlY3RcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQnOiBcIlNlbGVjdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KSwgX19fd21sLndpZGdldChtZW51XzEuTGluaywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZ3JvdXAnOiBcImxpbmtzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogXCJhdXRvY29tcGxldGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaHJlZic6IFwiIy9hdXRvY29tcGxldGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25DbGljayc6IF9fX2NvbnRleHQubmF2aWdhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IChfX19jb250ZXh0LnBhZ2UgPT09IFwiYXV0b2NvbXBsZXRlXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0JzogXCJBdXRvY29tcGxldGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQobWVudV8xLkxpbmssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2dyb3VwJzogXCJsaW5rc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwiYnV0dG9uLXNlbGVjdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdocmVmJzogXCIjL2J1dHRvbi1zZWxlY3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25DbGljayc6IF9fX2NvbnRleHQubmF2aWdhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IChfX19jb250ZXh0LnBhZ2UgPT09IFwiYnV0dG9uLXNlbGVjdFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IFwiQnV0dG9uIFNlbGVjdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KSwgX19fd21sLndpZGdldChtZW51XzEuTGluaywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZ3JvdXAnOiBcImxpbmtzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogXCJjaGVja2JveFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdocmVmJzogXCIjL2NoZWNrYm94XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2xpY2snOiBfX19jb250ZXh0Lm5hdmlnYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhY3RpdmUnOiAoX19fY29udGV4dC5wYWdlID09PSBcImNoZWNrYm94XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0JzogXCJDaGVja2JveFwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KSwgX19fd21sLndpZGdldChtZW51XzEuTGluaywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZ3JvdXAnOiBcImxpbmtzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogXCJzd2l0Y2hcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaHJlZic6IFwiIy9zd2l0Y2hcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25DbGljayc6IF9fX2NvbnRleHQubmF2aWdhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IChfX19jb250ZXh0LnBhZ2UgPT09IFwic3dpdGNoXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0JzogXCJTd2l0Y2hcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQobWVudV8xLkxpbmssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2dyb3VwJzogXCJsaW5rc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwidGFic1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdocmVmJzogXCIjL3RhYnNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25DbGljayc6IF9fX2NvbnRleHQubmF2aWdhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IChfX19jb250ZXh0LnBhZ2UgPT09IFwidGFic1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IFwiVGFic1wiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KSwgX19fd21sLndpZGdldChtZW51XzEuTGluaywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZ3JvdXAnOiBcImxpbmtzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogXCJzdGFja1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdocmVmJzogXCIjL3N0YWNrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2xpY2snOiBfX19jb250ZXh0Lm5hdmlnYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhY3RpdmUnOiAoX19fY29udGV4dC5wYWdlID09PSBcInN0YWNrXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0JzogXCJTdGFja1wiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KSwgX19fd21sLndpZGdldChtZW51XzEuTGluaywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZ3JvdXAnOiBcImxpbmtzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogXCJzZWFyY2gtc3RhY2tcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaHJlZic6IFwiIy9zZWFyY2gtc3RhY2tcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25DbGljayc6IF9fX2NvbnRleHQubmF2aWdhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IChfX19jb250ZXh0LnBhZ2UgPT09IFwic2VhcmNoLXN0YWNrXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0JzogXCJTZWFyY2ggU3RhY2tcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyldLCBfX192aWV3KSwgX19fd21sLndpZGdldChtZW51XzEuSGVhZGVyLCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQnOiBcIkFwcFwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQobWVudV8xLlN1Yk1lbnUsIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChtZW51XzEuTGluaywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZ3JvdXAnOiBcImxpbmtzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogXCJidXN5LWluZGljYXRvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdocmVmJzogXCIjL2J1c3ktaW5kaWNhdG9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2xpY2snOiBfX19jb250ZXh0Lm5hdmlnYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhY3RpdmUnOiAoX19fY29udGV4dC5wYWdlID09PSBcImJ1c3ktaW5kaWNhdG9yXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0JzogXCJCdXN5IEluZGljYXRvclwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KV0sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KG1lbnVfMS5IZWFkZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IFwiTmF2XCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KSwgX19fd21sLndpZGdldChtZW51XzEuU3ViTWVudSwge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KG1lbnVfMS5MaW5rLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdncm91cCc6IFwibGlua3NcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBcImJyZWFkY3J1bWJzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2hyZWYnOiBcIiMvYnJlYWRjcnVtYnNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25DbGljayc6IF9fX2NvbnRleHQubmF2aWdhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IChfX19jb250ZXh0LnBhZ2UgPT09IFwiYnJlYWRjcnVtYnNcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQnOiBcIkJyZWFkQ3J1bWJzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQobWVudV8xLkhlYWRlciwge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0JzogXCJNZW51XCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KSwgX19fd21sLndpZGdldChtZW51XzEuU3ViTWVudSwge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KG1lbnVfMS5MaW5rLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdncm91cCc6IFwibGlua3NcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBcIm1lbnVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaHJlZic6IFwiIy9tZW51XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2xpY2snOiBfX19jb250ZXh0Lm5hdmlnYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhY3RpdmUnOiAoX19fY29udGV4dC5wYWdlID09PSBcIm1lbnVcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQnOiBcIk1lbnVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQobWVudV8xLkxpbmssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2dyb3VwJzogXCJsaW5rc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwiYnV0dG9uLW1lbnVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaHJlZic6IFwiIy9idXR0b24tbWVudVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbkNsaWNrJzogX19fY29udGV4dC5uYXZpZ2F0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYWN0aXZlJzogKF9fX2NvbnRleHQucGFnZSA9PT0gXCJidXR0b24tbWVudVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IFwiQnV0dG9uIE1lbnVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBOYXZpZ2F0aW9uO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5OYXZpZ2F0aW9uID0gTmF2aWdhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5hdmlnYXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuYW1lcyA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi9uYW1lc1wiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL3V0aWxcIik7XG52YXIgR3JvdXBfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbnRlbnQvR3JvdXBcIik7XG52YXIgYWN0aW9uX2Jhcl8xID0gcmVxdWlyZShcIi4vd21sL2FjdGlvbl9iYXJcIik7XG4vKipcbiAqIEFjdGlvbkJhciBwcm92aWRlcyBhIGJhciBhY3Jvc3MgdGhlIHNjcmVlbiB0aGF0IGNhbiBiZVxuICogdXNlZCBhcyBhIHRvb2xiYXIsIG5hdmlnYXRpb24gbWVudSBvciBzb21ldGhpbmcgc2ltaWxsYXIuXG4gKi9cbnZhciBBY3Rpb25CYXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFjdGlvbkJhciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY3Rpb25CYXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IGFjdGlvbl9iYXJfMS5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiAnY29udGVudCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgIHJvb3Q6IHV0aWwuY29tYmluZShbbmFtZXMuQUNUSU9OX0JBUiwgbmFtZXMuRklYRURfUFVTSEFCTEVdKSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiBuYW1lcy5BQ1RJT05fQkFSX0NPTlRFTlRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQWN0aW9uQmFyO1xufShHcm91cF8xLkdyb3VwKSk7XG5leHBvcnRzLkFjdGlvbkJhciA9IEFjdGlvbkJhcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFjdGlvbkJhci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnZGl2Jywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuY2xhc3Mucm9vdFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC5ub2RlKCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLmNsYXNzLmNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnaWQnOiBfX19jb250ZXh0LnZhbHVlcy5pZC5jb250ZW50XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKV0sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWN0aW9uX2Jhci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHdtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIGJ1c3lfaW5kaWNhdG9yXzEgPSByZXF1aXJlKFwiLi93bWwvYnVzeV9pbmRpY2F0b3JcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL3V0aWxcIik7XG4vKipcbiAqIEJ1c3lJbmRpY2F0b3IgcHJvdmlkZXMgYSAnaGFtYnVyZ2VyJyBtZW51IGJ1dHRvbi5cbiAqL1xudmFyIEJ1c3lJbmRpY2F0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJ1c3lJbmRpY2F0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQnVzeUluZGljYXRvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgYnVzeV9pbmRpY2F0b3JfMS5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgY2xhc3M6IHV0aWxfMS5jb25jYXQoJ2xvYWRpbmcnLCBfdGhpcy5hdHRycy53dyA/IF90aGlzLmF0dHJzLnd3LmNsYXNzIDogJycpXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEJ1c3lJbmRpY2F0b3I7XG59KHdtbC5Db21wb25lbnQpKTtcbmV4cG9ydHMuQnVzeUluZGljYXRvciA9IEJ1c3lJbmRpY2F0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CdXN5SW5kaWNhdG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5jbGFzc1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1c3lfaW5kaWNhdG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmFtZXMgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vbmFtZXNcIik7XG52YXIgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBkYXNoXzEgPSByZXF1aXJlKFwiLi93bWwvZGFzaFwiKTtcbi8qKlxuICogRGFzaCBhcmUgbGl0ZXJhbCBob3Jpem9udGFsIGRhc2hlcy5cbiAqXG4gKiBUaGVzZSBjYW4gYmUgdXNlZCB3aXRoIGFwcC9tZW51L0J1dHRvbiB0byBjcmVhdGUgJ2hhbWJ1cmdlcicgbWVudXMuXG4gKi9cbnZhciBEYXNoID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEYXNoLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERhc2goKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IGRhc2hfMS5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICByb290OiBuYW1lcy5EQVNIXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIERhc2g7XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5EYXNoID0gRGFzaDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURhc2guanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRGFzaF8xID0gcmVxdWlyZShcIi4vRGFzaFwiKTtcbmV4cG9ydHMuRGFzaCA9IERhc2hfMS5EYXNoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ3NwYW4nLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5jbGFzcy5yb290XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGFzaC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogSElEREVOIGluZGljYXRlcyBhbiBlbGVtZW50IHNob3VsZCBiZSBoaWRkZW4gZnJvbSBzaWdodC5cbiAqL1xuZXhwb3J0cy5ISURERU4gPSAnLWhpZGRlbic7XG4vKipcbiAqIERJU0FCTEVEIGluZGljYXRlcyBhbiBlbGVtZW50IHNob3VsZCBhcHBlYXIgdG8gYmUgaW5hY2Nlc2libGVcbiAqL1xuZXhwb3J0cy5ESVNBQkxFRCA9ICctZGlzYWJsZWQnO1xuLyoqXG4gKiBPTiBpbmRpY2F0ZXMgYW4gJ29uJyBzdGF0ZS5cbiAqL1xuZXhwb3J0cy5PTiA9ICctb24nO1xuLyoqXG4gKiBPRkYgaW5kaWNhdGVzIGFuICdvZmYnIHN0YXRlLlxuICovXG5leHBvcnRzLk9GRiA9ICctb2ZmJztcbi8qKlxuICogb3BlbiBpbmRpY2F0ZXMgYW4gb3BlbiBzdGF0ZSBpbiBjb2xsYXBzYWJsZSB3aWRnZXRzXG4gKi9cbmV4cG9ydHMuT1BFTiA9ICctb3Blbic7XG4vKipcbiAqIFBVU0hBQkxFIGlzIHVzZWQgYnkgb3RoZXIgc3R5bGVzIHRvIG1vdmUgYW4gZWxlbWVudCBhcm91bmQuXG4gKi9cbmV4cG9ydHMuUFVTSEFCTEUgPSAnLXB1c2hhYmxlJztcbi8qKlxuICogRklYRURfUFVTSEFCTEUgaXMgbGlrZSBQVVNIQUJMRSBidXQgdXNlZCBmb3IgZml4ZWQgZWxlbWVudHMuXG4gKi9cbmV4cG9ydHMuRklYRURfUFVTSEFCTEUgPSAnLWZpeGVkLXB1c2hhYmxlJztcbi8qKlxuICogTk9fSE9WRVIgaW5kaWNhdGVzIGhvdmVyIGVmZmVjdHMgc2hvdWxkIGJlIGRpc2FibGVkLlxuICovXG5leHBvcnRzLk5PX0hPVkVSID0gJy1uby1ob3Zlcic7XG5leHBvcnRzLlNQQUNFRCA9ICctc3BhY2VkJztcbi8qKlxuICogREVGQVVMVCBzdHlsZSBtb2RpZmllci5cbiAqL1xuZXhwb3J0cy5ERUZBVUxUID0gJy1kZWZhdWx0Jztcbi8qKlxuICogUFJJTUFSWSBzdHlsZSBtb2RpZmllci5cbiAqL1xuZXhwb3J0cy5QUklNQVJZID0gJy1wcmltYXJ5Jztcbi8qKlxuICogU1VDQ0VTUyBzdHlsZSBtb2RpZmllci5cbiAqL1xuZXhwb3J0cy5TVUNDRVNTID0gJy1zdWNjZXNzJztcbi8qKlxuICogSU5GTyBzdHlsZSBtb2RpZmllci5cbiAqL1xuZXhwb3J0cy5JTkZPID0gJy1pbmZvJztcbi8qKlxuICogV0FSTklORyBzdHlsZSBtb2RpZmllci5cbiAqL1xuZXhwb3J0cy5XQVJOSU5HID0gJy13YXJuaW5nJztcbi8qKlxuICogREFOR0VSIHN0eWxlIG1vZGlmaWVyLlxuICovXG5leHBvcnRzLkRBTkdFUiA9ICctZGFuZ2VyJztcbmV4cG9ydHMuTEFSR0UgPSAnLWxhcmdlJztcbmV4cG9ydHMuU01BTEwgPSAnLXNtYWxsJztcbmV4cG9ydHMuRVhUUkFfU01BTEwgPSAnLWV4dHJhLXNtYWxsJztcbmV4cG9ydHMuQUNUSVZFID0gJ2FjdGl2ZSc7IC8vQHRvZG86IHJlZmFjdG9yIHRvIGZsYWcgc3ludGF4XG5leHBvcnRzLkRSQVdFUiA9ICd3dy1kcmF3ZXItbGF5b3V0JztcbmV4cG9ydHMuQVNJREUgPSAnd3ctZHJhd2VyJztcbmV4cG9ydHMuQVNJREVfQ09OVEVOVCA9ICd3dy1kcmF3ZXJfX2NvbnRlbnQnO1xuZXhwb3J0cy5BU0lERV9QVVNIQUJMRSA9ICctZHJhd2VyLXB1c2hhYmxlJztcbmV4cG9ydHMuQVNJREVfUFVTSEFCTEVfRklYRUQgPSAnLWRyYXdlci1wdXNoYWJsZS1maXhlZCc7XG4vKipcbiAqIEFDVElPTl9CQVIgY2xhc3MgbmFtZS4gZm9yIHRoZSBBY3Rpb25CYXIgcm9vdC5cbiAqL1xuZXhwb3J0cy5BQ1RJT05fQkFSID0gJ3d3LWFjdGlvbi1iYXInO1xuLyoqXG4gKiBBQ1RJT05fQkFSX0NPTlRFTlQgY2xhc3MgbmFtZS5cbiAqL1xuZXhwb3J0cy5BQ1RJT05fQkFSX0NPTlRFTlQgPSAnd3ctYWN0aW9uLWJhcl9fY29udGVudCc7XG4vKipcbiAqIElDT05fQlVUVE9OIGNsYXNlc3MgZm9yIEljb25CdXR0b25zLlxuICovXG5leHBvcnRzLklDT05fQlVUVE9OID0gJ3d3LWljb24tYnV0dG9uJztcbi8qKlxuICogQlVUVE9OX01FTlUgY2xhc3MgbmFtZS5cbiAqL1xuZXhwb3J0cy5CVVRUT05fTUVOVSA9ICd3dy1idXR0b24tbWVudSBidG4tZ3JvdXAnO1xuLyoqXG4gKiBCVVRUT05fTUVOVV9CVVRUT04gY2xhc3MgbmFtZS5cbiAqL1xuZXhwb3J0cy5CVVRUT05fTUVOVV9CVVRUT04gPSBleHBvcnRzLkJVVFRPTl9NRU5VICsgXCJfX2J1dHRvblwiO1xuLyoqXG4gKiBCVVRUT05fTUVOVV9NRU5VIGNsYXNzIG5hbWUuXG4gKi9cbmV4cG9ydHMuQlVUVE9OX01FTlVfTUVOVSA9IGV4cG9ydHMuQlVUVE9OX01FTlVfQlVUVE9OICsgXCJfX21lbnVcIjtcbi8qKlxuICogQlVUVE9OX1NFTEVDVFxuICovXG5leHBvcnRzLkJVVFRPTl9TRUxFQ1QgPSAnYnRuLWdyb3VwJztcbmV4cG9ydHMuQlVUVE9OX1NFTEVDVF9PUFRJT04gPSBleHBvcnRzLkJVVFRPTl9TRUxFQ1QgKyBcIl9fb3B0aW9uIGJ0blwiO1xuZXhwb3J0cy5NQUlOX1ZJRVcgPSAnd3ctbWFpbi12aWV3Jztcbi8qKlxuICogTUVOVSBjbGFzcyBuYW1lLlxuICovXG5leHBvcnRzLk1FTlUgPSAnd3ctbWVudSc7XG4vKipcbiAqIE1FTlVfSVRFTSBjbGFzcyBuYW1lLlxuICovXG5leHBvcnRzLk1FTlVfSVRFTSA9IGV4cG9ydHMuTUVOVSArIFwiX19pdGVtXCI7XG4vKipcbiAqIE1FTlVfSEVBREVSIGNsYXNzIG5hbWUuXG4gKi9cbmV4cG9ydHMuTUVOVV9IRUFERVIgPSBleHBvcnRzLk1FTlUgKyBcIl9faGVhZGVyXCI7XG4vKipcbiAqIE1FTlVfRElWSURFUiBjbGFzcyBuYW1lLlxuICovXG5leHBvcnRzLk1FTlVfRElWSURFUiA9IGV4cG9ydHMuTUVOVSArIFwiX19kaXZpZGVyXCI7XG4vKipcbiAqIERBU0ggY2xhc3MgbmFtZS5cbiAqL1xuZXhwb3J0cy5EQVNIID0gJ3d3LWRhc2gnO1xuLyoqXG4gKiBOQVYgY2xhc3MgbmFtZS5cbiAqL1xuZXhwb3J0cy5OQVYgPSAnd3ctbmF2Jztcbi8qKlxuICogTkFWX0xJTksgY2xhc3MgbmFtZS5cbiAqL1xuZXhwb3J0cy5OQVZfTElOSyA9ICd3dy1uYXYtbGluayc7XG4vKipcbiAqIE5BVl9NRU5VIGNsYXNzIG5hbWUuXG4gKi9cbmV4cG9ydHMuTkFWX01FTlUgPSAnd3ctbmF2LW1lbnUnO1xuLyoqXG4gKiBOQVZfTUVOVV9JVEVNIGNsYXNzIG5hbWUuXG4gKi9cbmV4cG9ydHMuTkFWX01FTlVfSVRFTSA9ICd3dy1uYXYtbWVudV9faXRlbSc7XG4vKipcbiAqIE5BVl9NRU5VX0hFQURFUiBjbGFzcyBuYW1lLlxuICovXG5leHBvcnRzLk5BVl9NRU5VX0hFQURFUiA9ICd3dy1uYXYtbWVudV9faGVhZGVyJztcbi8qKlxuICogTkFWX01FTlVfTElOSyBjbGFzcyBuYW1lLlxuICovXG5leHBvcnRzLk5BVl9NRU5VX0xJTksgPSAnd3ctbmF2LW1lbnVfX2xpbmsnO1xuLyoqXG4gKiBOQVZfTUVOVV9TVUJNRU5VIGNsYXNzIG5hbWUuXG4gKi9cbmV4cG9ydHMuTkFWX01FTlVfU1VCTUVOVSA9ICd3dy1uYXYtbWVudV9fc3VibWVudSc7XG5leHBvcnRzLkJVVFRPTiA9ICd3dy1idXR0b24nO1xuZXhwb3J0cy5CVVRUT05fR1JPVVAgPSAnd3ctYnV0dG9uLWdyb3VwJztcbi8vQHRvZG86IHJlZmFjdG9yIHRoaXMgdG8gYmUgaW5saW5lIHdpdGggb3RoZXIgY2xhc3MgbmFtZXNcbmV4cG9ydHMuR1JJRCA9ICdjb250YWluZXItZmx1aWQnO1xuZXhwb3J0cy5HUklEX0NPTFVNTiA9ICd3dy1ncmlkLWNvbHVtbic7XG5leHBvcnRzLkdSSURfUk9XID0gJ3Jvdyc7XG4vKipcbiAqIFBBTkVMIHdyYXBwZXIgY2xhc3MuXG4gKi9cbmV4cG9ydHMuUEFORUwgPSAnd3ctcGFuZWwnO1xuLyoqXG4gKiBQQU5FTF9IRUFERVIgY2xhc3MgbmFtZS5cbiAqL1xuZXhwb3J0cy5QQU5FTF9IRUFERVIgPSAnd3ctcGFuZWxfX2hlYWRlcic7XG4vKipcbiAqIFBBTkVMX0JPRFkgY2xhc3MgbmFtZS5cbiAqL1xuZXhwb3J0cy5QQU5FTF9CT0RZID0gJ3d3LXBhbmVsX19ib2R5Jztcbi8qKlxuICogUEFORUxfRk9PVEVSIGNsYXNzIG5hbWUuXG4gKi9cbmV4cG9ydHMuUEFORUxfRk9PVEVSID0gJ3d3LXBhbmVsX19mb290ZXInO1xuLyoqXG4gKiBIRUFERVIgY2xhc3MgbmFtZS5cbiAqL1xuZXhwb3J0cy5IRUFERVIgPSAnd3ctaGVhZGVyJztcbmV4cG9ydHMuTU9EQUwgPSAnd3ctbW9kYWwnO1xuZXhwb3J0cy5NT0RBTF9ESUFMT0cgPSAnd3ctbW9kYWxfX2RpYWxvZyc7XG5leHBvcnRzLk1PREFMX0NPTlRFTlQgPSAnd3ctbW9kYWxfX2NvbnRlbnQnO1xuZXhwb3J0cy5NT0RBTF9IRUFERVIgPSAnd3ctbW9kYWxfX2hlYWRlcic7XG5leHBvcnRzLk1PREFMX0JPRFkgPSAnd3ctbW9kYWxfX2JvZHknO1xuZXhwb3J0cy5NT0RBTF9GT09URVIgPSAnd3ctbW9hZGxfX2Zvb3Rlcic7XG5leHBvcnRzLkZPUk1fR1JPVVAgPSAnZm9ybS1ncm91cCc7XG5leHBvcnRzLkNPTlRST0xfTEFCRUwgPSAnY29udHJvbC1sYWJlbCc7XG5leHBvcnRzLklOUFVUID0gJ2Zvcm0tY29udHJvbCc7XG5leHBvcnRzLlRFWFRBUkVBID0gJ2Zvcm0tY29udHJvbCc7XG5leHBvcnRzLlNFTEVDVCA9ICdmb3JtLWNvbnRyb2wnO1xuLyoqXG4gKiBUQUJTIGNsYXNzIG5hbWUuXG4gKi9cbmV4cG9ydHMuVEFCUyA9ICd3dy10YWJzJztcbi8qKlxuICogVEFCU19UQUIgY2xhc3MgbmFtZS5cbiAqL1xuZXhwb3J0cy5UQUJTX1RBQiA9ICd3dy10YWJzX190YWInO1xuLyoqXG4gKiBTV0lUQ0ggY2xhc3MgbmFtZS5cbiAqL1xuZXhwb3J0cy5TV0lUQ0ggPSAnd3ctc3dpdGNoJztcbi8qKlxuICogU1dJVENIX1NMSURFUiBjbGFzcyBuYW1lLlxuICovXG5leHBvcnRzLlNXSVRDSF9TTElERVIgPSAnd3ctc3dpdGNoX19zbGlkZXInO1xuLyoqXG4gKiBDSEVDS0JPWCBjbGFzcyBuYW1lLlxuICovXG5leHBvcnRzLkNIRUNLQk9YID0gJ2NoZWNrYm94JztcbmV4cG9ydHMuVEFCTEUgPSAndGFibGUnOyAvL0B0b2RvIHVuLWJvb3RzdHJhcFxuLyoqXG4gKiBCUkVBRF9DUlVNQlMgY2xhc2Vzc1xuICovXG5leHBvcnRzLkJSRUFEX0NSVU1CUyA9ICdicmVhZGNydW1iJzsgLy9AdG9kbyB1bi1ib290c3RyYXBcbi8qKlxuICogQlJFQURfQ1JVTUJTX0lURU0gY2xhc3MgbmFtZS5cbiAqL1xuZXhwb3J0cy5CUkVBRF9DUlVNQlNfSVRFTSA9IGV4cG9ydHMuQlJFQURfQ1JVTUJTICsgXCJfX2l0ZW1cIjtcbmV4cG9ydHMuTElTVCA9ICd3dy1saXN0JztcbmV4cG9ydHMuTElTVF9JVEVNID0gJ3d3LWxpc3RfX2l0ZW0nO1xuLyoqXG4gKiBTRUFSQ0ggY2xhc3MgbmFtZS5cbiAqL1xuZXhwb3J0cy5TRUFSQ0ggPSAnd3ctc2VhcmNoJztcbi8qKlxuICogU0VBUkNIX0lOUFVUIGNsYXNzIG5hbWUuXG4gKi9cbmV4cG9ydHMuU0VBUkNIX0lOUFVUID0gJ3d3LXNlYXJjaF9faW5wdXQnO1xuLyoqXG4gKiBEQVRFIGNsYXNzIG5hbWUuXG4gKi9cbmV4cG9ydHMuREFURSA9ICd3dy1kYXRlJztcbi8qKlxuICogREFURV9EQVkgY2xhc3MgbmFtZS5cbiAqL1xuZXhwb3J0cy5EQVRFX0RBWSA9IGV4cG9ydHMuREFURSArIFwiX19kYXlcIjtcbi8qKlxuICogREFURV9NT05USCBjbGFzcyBuYW1lLlxuICovXG5leHBvcnRzLkRBVEVfTU9OVEggPSBleHBvcnRzLkRBVEUgKyBcIl9tb250aFwiO1xuLyoqXG4gKiBEQVRFX1lFQVIgY2xhc3MgbmFtZS5cbiAqL1xuZXhwb3J0cy5EQVRFX1lFQVIgPSBleHBvcnRzLkRBVEUgKyBcIl9feWVhclwiO1xuLyoqXG4gKiBTVEFDSyBjbGFzcyBuYW1lLlxuICovXG5leHBvcnRzLlNUQUNLID0gJ3d3LXN0YWNrJztcbi8qKlxuICogU1RBQ0tfQ0xPU0UgY2xhc3MgbmFtZS5cbiAqL1xuZXhwb3J0cy5TVEFDS19DTE9TRSA9IGV4cG9ydHMuU1RBQ0sgKyBcIl9fY2xvc2VcIjtcbi8qKlxuICogU1RBQ0tfTUVNQkVSIGNsYXNzIG5hbWUuXG4gKi9cbmV4cG9ydHMuU1RBQ0tfTUVNQkVSID0gZXhwb3J0cy5TVEFDSyArIFwiX19tZW1iZXJcIjtcbi8qKlxuICogU0VBUkNIX1NUQUNLIGNsYXNzIG5hbWUuXG4gKi9cbmV4cG9ydHMuU0VBUkNIX1NUQUNLID0gJ3d3LXNlYXJjaC1zdGFjayc7XG4vKipcbiAqIExJU1RfR1JPVVAgY2xhc3MgbmFtZS5cbiAqL1xuZXhwb3J0cy5MSVNUX0dST1VQID0gJ2xpc3QtZ3JvdXAnO1xuLyoqXG4gKiBMSVNUX0dST1VQX0lURU0gY2xhc3MgbmFtZS5cbiAqL1xuZXhwb3J0cy5MSVNUX0dST1VQX0lURU0gPSAnbGlzdC1ncm91cC1pdGVtJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5hbWVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBjb21iaW5lIHRoZSBtZW1iZXJzIG9mIGFuIGFycmF5IGludG8gb25lIHN0cmluZy5cbiAqL1xuZXhwb3J0cy5jb21iaW5lID0gZnVuY3Rpb24gKHN0ciwgam9pbmVyKSB7XG4gICAgaWYgKGpvaW5lciA9PT0gdm9pZCAwKSB7IGpvaW5lciA9ICcgJzsgfVxuICAgIHJldHVybiBzdHIuZmlsdGVyKGZ1bmN0aW9uIChzKSB7IHJldHVybiAoKHMgIT0gbnVsbCkgfHwgcyAhPSAnJyk7IH0pLmpvaW4oam9pbmVyKTtcbn07XG4vKipcbiAqIGNvbmNhdCBqb2lucyB2YXJpb3VzIHN0cmluZ3MgdG9nZXRoZXIgdG8gZm9ybSBhbiBodG1sIGNsYXNzIGF0dHJpYnV0ZSB2YWx1ZS5cbiAqXG4gKiBSZW1vdmVzIGVtcHR5IHN0cmluZ3MsIG51bGwgYW5kIHVuZGVmaW5lZCB2YWx1ZXMuXG4gKi9cbmV4cG9ydHMuY29uY2F0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdHIgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBzdHJbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5maWx0ZXIoZnVuY3Rpb24gKHMpIHsgcmV0dXJuICgocyAhPSBudWxsKSB8fCBzICE9ICcnKTsgfSkuam9pbignICcpO1xufTtcbi8qKlxuICogbm9vcFxuICovXG5leHBvcnRzLm5vb3AgPSBmdW5jdGlvbiAoKSB7IH07XG4vKipcbiAqIHJlcGxhY2VDb250ZW50XG4gKi9cbmV4cG9ydHMucmVwbGFjZUNvbnRlbnQgPSBmdW5jdGlvbiAociwgbm9kZSkge1xuICAgIHdoaWxlIChub2RlLmxhc3RDaGlsZClcbiAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmxhc3RDaGlsZCk7XG4gICAgbm9kZS5hcHBlbmRDaGlsZChyLnJlbmRlcigpKTtcbn07XG4vKipcbiAqIGRlYm91bmNlIGEgZnVuY3Rpb24gc28gdGhhdCBpdCBpcyBvbmx5IGNhbGxlZCBvbmNlIGFmdGVyXG4gKiBhIHBlcmlvZCBvZiB0aW1lLlxuICovXG5leHBvcnRzLmRlYm91bmNlID0gZnVuY3Rpb24gKGYsIGRlbGF5KSB7XG4gICAgdmFyIHRpbWVyID0gbnVsbDtcbiAgICByZXR1cm4gZGVsYXkgPT09IDAgPyBmIDogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgaWYgKCF0aW1lcikge1xuICAgICAgICAgICAgdGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBmKGEpOyB9LCBkZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgdGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBmKGEpOyB9LCBkZWxheSk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xuLyoqXG4gKiBHcm91cCBpcyBhbiBhYnN0cmFjdCBjbGFzcyBwcm92aWRpbmcgYW4gYXBpIGZvclxuICogd2lkZ2V0cyB3aG9zZSBwcmltYXJ5IHB1cnBvc2UgaXMgZGlzcGxheWluZyBjb250ZW50LlxuICovXG52YXIgR3JvdXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdyb3VwLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdyb3VwKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHNldENvbnRlbnQgY2hhbmdlcyB0aGUgY29udGVudCB2YWx1ZS5cbiAgICAgKi9cbiAgICBHcm91cC5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMudmlldy5pbnZhbGlkYXRlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogcmVtb3ZlQ29udGVudCByZW1vdmVzIGV4aXN0aW5nIGNvbnRlbnQuXG4gICAgICovXG4gICAgR3JvdXAucHJvdG90eXBlLnJlbW92ZUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29udGVudCA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIEdyb3VwO1xufSh3bWxfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuR3JvdXAgPSBHcm91cDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyb3VwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbi8qKlxuICogQ29udHJvbFxuICovXG52YXIgQ29udHJvbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29udHJvbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb250cm9sKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBDb250cm9sO1xufSh3bWxfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuQ29udHJvbCA9IENvbnRyb2w7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db250cm9sLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBEZWZhdWx0RGVsZWdhdGUgZm93YXJkcyBhbGwgZXZlbnRzIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmdcbiAqIGZ1bmN0aW9uIGhhbmRsZXJzLCBzcGVjaWZlZCBvbiB0aGUgYXR0cmlidXRlcyBvZiBhIGNvbnRyb2wuXG4gKi9cbnZhciBEZWZhdWx0RGVsZWdhdGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVmYXVsdERlbGVnYXRlKGF0dHJzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy5vbklucHV0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5hdHRycy5vbklucHV0ID8gX3RoaXMuYXR0cnMub25JbnB1dChlKSA6IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmF0dHJzLm9uQ2hhbmdlID8gX3RoaXMuYXR0cnMub25DaGFuZ2UoZSkgOiBudWxsO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gRGVmYXVsdERlbGVnYXRlO1xufSgpKTtcbmV4cG9ydHMuRGVmYXVsdERlbGVnYXRlID0gRGVmYXVsdERlbGVnYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGVmYXVsdERlbGVnYXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBFdmVudCBpcyB0aGUgcGFyZW50IGNsYXNzIG9mIGFsbCBldmVudHMgZ2VuZXJhdGVkIGJ5IGNvbnRyb2xzLlxuICovXG52YXIgRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXZlbnQobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gRXZlbnQ7XG59KCkpO1xuZXhwb3J0cy5FdmVudCA9IEV2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXZlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBDb250cm9sXzEgPSByZXF1aXJlKFwiLi9Db250cm9sXCIpO1xudmFyIERlZmF1bHREZWxlZ2F0ZV8xID0gcmVxdWlyZShcIi4vRGVmYXVsdERlbGVnYXRlXCIpO1xudmFyIElOUFVUX1NVQ0NFU1MgPSAnaGFzLXN1Y2Nlc3MnO1xudmFyIElOUFVUX0VSUk9SID0gJ2hhcy1lcnJvcic7XG52YXIgSU5QVVRfV0FSTklORyA9ICdoYXMtd2FybmluZyc7XG52YXIgRm9ybUNvbnRyb2wgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZvcm1Db250cm9sLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZvcm1Db250cm9sKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZGVsZWdhdGUgPSBfdGhpcy5hdHRycy53dy5kZWxlZ2F0ZSA/XG4gICAgICAgICAgICBfdGhpcy5hdHRycy53dy5kZWxlZ2F0ZSA6IG5ldyBEZWZhdWx0RGVsZWdhdGVfMS5EZWZhdWx0RGVsZWdhdGUoX3RoaXMuYXR0cnMud3cpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGlzRmlsbGVkXG4gICAgICovXG4gICAgLy8gICBhYnN0cmFjdCBpc0ZpbGxlZCgpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIGNsZWFyXG4gICAgICovXG4gICAgLy8gYWJzdHJhY3QgY2xlYXIoKTogRm9ybUNvbnRyb2w8ViwgQT47XG4gICAgLyoqXG4gICAgICogaXNSZXF1aXJlZCB0ZWxscyBpZiB0aGUgSW5wdXQgd2FzIHJlcXVpcmVkLlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgRm9ybUNvbnRyb2wucHJvdG90eXBlLmlzUmVxdWlyZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5hdHRycy53dy5yZXF1aXJlZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBoYXNDbGFzcyBxdWVyaWVzIHdoZXRoZXIgYSBjbGFzcyBleGlzdHMgb24gdGhlIHJvb3QgZWxlbWVudCBvbiBub3QuXG4gICAgICovXG4gICAgRm9ybUNvbnRyb2wucHJvdG90eXBlLmhhc0NsYXNzID0gZnVuY3Rpb24gKGNscykge1xuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgLnZpZXdcbiAgICAgICAgICAgIC5maW5kQnlJZCh0aGlzLnZhbHVlcy5yb290LmlkKVxuICAgICAgICAgICAgLmNhdGEoZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH0sIChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUuY2xhc3NOYW1lLnNwbGl0KCcgJykuaW5kZXhPZihjbHMpID09PSAtMTtcbiAgICAgICAgfSkpO1xuICAgIH07XG4gICAgRm9ybUNvbnRyb2wucHJvdG90eXBlLmhhc0Vycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNDbGFzcyhJTlBVVF9FUlJPUik7XG4gICAgfTtcbiAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUuaGFzV2FybmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzQ2xhc3MoSU5QVVRfV0FSTklORyk7XG4gICAgfTtcbiAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUuaGFzU3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzQ2xhc3MoSU5QVVRfU1VDQ0VTUyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBzZXRIZWxwVGV4dCBzZXRzIHRoZSBtZXNzYWdlIGZvciB0aGUgbWVzc2FnZSBwb3J0aW9uIG9mXG4gICAgICogdGhpcyBpbnB1dC5cbiAgICAgKi9cbiAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUuc2V0SGVscFRleHQgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICAudmlld1xuICAgICAgICAgICAgLmZpbmRCeUlkKHRoaXMudmFsdWVzLmhlbHAuaWQpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG1zZyk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5yZXBsYWNlQ2hpbGQobm9kZSwgbWVzc2FnZS5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0YShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpczsgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXM7IH0pO1xuICAgIH07XG4gICAgRm9ybUNvbnRyb2wucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICAudmlld1xuICAgICAgICAgICAgLmZpbmRCeUlkKHRoaXMudmFsdWVzLnJvb3QuaWQpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLmNsYXNzTGlzdC5hZGQoc3RhdGUpOyB9KVxuICAgICAgICAgICAgLmNhdGEoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXM7IH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHJlbW92ZVN0YXRlIHJlbW92ZXMgdGhlIHN0YXRlIHZhbGlkYXRpb24gc3RhdGUgZnJvbSB0aGUgaW5wdXQuXG4gICAgICovXG4gICAgRm9ybUNvbnRyb2wucHJvdG90eXBlLnJlbW92ZVN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgLnZpZXdcbiAgICAgICAgICAgIC5maW5kQnlJZCh0aGlzLnZhbHVlcy5yb290LmlkKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaCkge1xuICAgICAgICAgICAgaC5jbGFzc0xpc3QucmVtb3ZlKElOUFVUX1NVQ0NFU1MpO1xuICAgICAgICAgICAgaC5jbGFzc0xpc3QucmVtb3ZlKElOUFVUX0VSUk9SKTtcbiAgICAgICAgICAgIGguY2xhc3NMaXN0LnJlbW92ZShJTlBVVF9XQVJOSU5HKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRhKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzOyB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpczsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBzdGF0ZVxuICAgICAqL1xuICAgIEZvcm1Db250cm9sLnByb3RvdHlwZS5zdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cnMud3cuc3VjY2VzcyA/XG4gICAgICAgICAgICAnaGFzLXN1Y2Nlc3MnIDpcbiAgICAgICAgICAgIHRoaXMuYXR0cnMud3cuZXJyb3IgP1xuICAgICAgICAgICAgICAgICdoYXMtZXJyb3InIDpcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJzLnd3Lndhcm5pbmcgP1xuICAgICAgICAgICAgICAgICAgICAnaGFzLXdhcm5pbmcnIDpcbiAgICAgICAgICAgICAgICAgICAgJyc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBzZXRTdWNjZXNzXG4gICAgICovXG4gICAgRm9ybUNvbnRyb2wucHJvdG90eXBlLnNldFN1Y2Nlc3MgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgLnJlbW92ZVN0YXRlKClcbiAgICAgICAgICAgIC5zZXRIZWxwVGV4dChtZXNzYWdlKVxuICAgICAgICAgICAgLnNldFN0YXRlKElOUFVUX1NVQ0NFU1MpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogc2V0RXJyb3JcbiAgICAgKi9cbiAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUuc2V0RXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgLnJlbW92ZVN0YXRlKClcbiAgICAgICAgICAgIC5zZXRIZWxwVGV4dChtZXNzYWdlKVxuICAgICAgICAgICAgLnNldFN0YXRlKElOUFVUX0VSUk9SKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHNldFdhcm5pbmdcbiAgICAgKi9cbiAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUuc2V0V2FybmluZyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICAucmVtb3ZlU3RhdGUoKVxuICAgICAgICAgICAgLnNldEhlbHBUZXh0KG1lc3NhZ2UpXG4gICAgICAgICAgICAuc2V0U3RhdGUoSU5QVVRfV0FSTklORyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiByZXNldFxuICAgICAqL1xuICAgIEZvcm1Db250cm9sLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICAgIC52aWV3XG4gICAgICAgICAgICAuZmluZEJ5SWQodGhpcy52YWx1ZXMuaGVscC5pZClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIF90aGlzLnJlbW92ZVN0YXRlKCk7XG4gICAgICAgICAgICB3aGlsZSAobS5maXJzdENoaWxkKVxuICAgICAgICAgICAgICAgIG0ucmVtb3ZlQ2hpbGQobS5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIC8vICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0YShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpczsgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXM7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogcmVuZGVyZWQgY2hlY2tzIGlmIHRoZSBpbnB1dCBzaG91bGQgaGF2ZSBhIHZhbGlkYXRpb24gc3RhdGUgc2V0XG4gICAgICovXG4gICAgRm9ybUNvbnRyb2wucHJvdG90eXBlLnJlbmRlcmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmF0dHJzLnd3LCBzdWNjZXNzID0gX2Euc3VjY2VzcywgZXJyb3IgPSBfYS5lcnJvciwgd2FybmluZyA9IF9hLndhcm5pbmc7XG4gICAgICAgIGlmIChzdWNjZXNzKVxuICAgICAgICAgICAgdGhpcy5zZXRTdWNjZXNzKCh0eXBlb2Ygc3VjY2VzcyA9PT0gJ3N0cmluZycpID8gc3VjY2VzcyA6ICcnKTtcbiAgICAgICAgZWxzZSBpZiAoZXJyb3IpXG4gICAgICAgICAgICB0aGlzLnNldEVycm9yKCh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSA/IGVycm9yIDogJycpO1xuICAgICAgICBlbHNlIGlmICh3YXJuaW5nKVxuICAgICAgICAgICAgdGhpcy5zZXRXYXJuaW5nKCh0eXBlb2Ygd2FybmluZyA9PT0gJ3N0cmluZycpID8gd2FybmluZyA6ICcnKTtcbiAgICB9O1xuICAgIHJldHVybiBGb3JtQ29udHJvbDtcbn0oQ29udHJvbF8xLkNvbnRyb2wpKTtcbmV4cG9ydHMuRm9ybUNvbnRyb2wgPSBGb3JtQ29udHJvbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZvcm1Db250cm9sLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmFtZXMgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vbmFtZXNcIik7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvYXV0b2NvbXBsZXRlXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi91dGlsXCIpO1xudmFyIGx1cmNoXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb250cm9sL2x1cmNoXCIpO1xuZXhwb3J0cy5FU0NBUEUgPSAyNztcbmV4cG9ydHMuSU5QVVRfSUQgPSAnaW5wdXQnO1xuLyoqXG4gKiBBdXRvY29tcGxhdGUgcHJvdmlkZXMgYW4gaW5wdXQgd2l0aCBhIGRyb3Bkb3duIG1lbnUgdGhhdCBhbGxvd3NcbiAqIHRoZSB1c2VyIHRvIHNlYXJjaCBhbmQgc2VsZWN0IGZvcm0gYSBsaXN0IG9mIG9wdGlvbnMuXG4gKi9cbnZhciBBdXRvY29tcGxldGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEF1dG9jb21wbGV0ZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBdXRvY29tcGxldGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IHtcbiAgICAgICAgICAgIHBvcHVsYXRlZDogKF90aGlzLmF0dHJzLnd3LnBvcHVsYXRlZCkgP1xuICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LnBvcHVsYXRlZCA6IHZpZXdzLnBvcHVsYXRlZCxcbiAgICAgICAgICAgIGVtcHR5OiAoX3RoaXMuYXR0cnMud3cuZW1wdHkpID9cbiAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5lbXB0eSA6IHZpZXdzLmVtcHR5XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiB7XG4gICAgICAgICAgICAgICAgcm9vdDogJ3Jvb3QnLFxuICAgICAgICAgICAgICAgIGlucHV0OiAnaW5wdXQnLFxuICAgICAgICAgICAgICAgIG1lbnU6ICdtZW51JyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnbWVzYWdlJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgIHJvb3Q6ICcnLFxuICAgICAgICAgICAgICAgIGlucHV0OiAnJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgICAgICBpZDogJ3Jvb3QnLFxuICAgICAgICAgICAgICAgIGNsYXNzOiB1dGlsXzEuY29uY2F0KG5hbWVzLlNFQVJDSCwgX3RoaXMuYXR0cnMud3cuY2xhc3MpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGVscDoge1xuICAgICAgICAgICAgICAgIGlkOiAnaGVscCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZW51OiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdtZW51J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlucHV0OiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdpbnB1dCcsXG4gICAgICAgICAgICAgICAgY2xhc3M6IHV0aWxfMS5jb25jYXQoJ2Zvcm0tY29udHJvbCcsIF90aGlzLmF0dHJzLnd3LmlucHV0Q2xhc3MpLFxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBfdGhpcy5hdHRycy53dy5wbGFjZWhvbGRlciA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LnBsYWNlaG9sZGVyIDogbnVsbCxcbiAgICAgICAgICAgICAgICBvbktleURvd246IF90aGlzLm9uS2V5RG93bixcbiAgICAgICAgICAgICAgICBvbktleVVwOiBfdGhpcy5vbktleVVwLFxuICAgICAgICAgICAgICAgIG9uSW5wdXQ6IF90aGlzLm9uSW5wdXRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWFyY2g6IHtcbiAgICAgICAgICAgICAgICBkZWxheTogX3RoaXMuYXR0cnMud3cuZGVib3VuY2UgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5kZWJvdW5jZSA6IF90aGlzLkRFRkFVTFRfREVCT1VOQ0VfVElNRSxcbiAgICAgICAgICAgICAgICByZXN1bHRzOiBbXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGl0ZW06IHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogX3RoaXMudGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5OiBfdGhpcy5hdHRycy53dy5zdHJpbmdpZmllciA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LnN0cmluZ2lmaWVyIDogX3RoaXMuc3RyaW5naWZ5LFxuICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jbG9zZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZGVsZWdhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vblNlbGVjdChuZXcgbHVyY2hfMS5JdGVtU2VsZWN0ZWRFdmVudChfdGhpcy5hdHRycy53dy5uYW1lLCBfdGhpcy52YWx1ZXMuc2VhcmNoLnJlc3VsdHNbTnVtYmVyKGluZGV4KV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQXV0b2NvbXBsZXRlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBBdXRvY29tcGxldGUucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXNcbiAgICAgICAgICAgIC52aWV3XG4gICAgICAgICAgICAuZmluZEJ5SWQodGhpcy52YWx1ZXMuaWQubWVudSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0uc2hvdygpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBBdXRvY29tcGxldGUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzXG4gICAgICAgICAgICAudmlld1xuICAgICAgICAgICAgLmZpbmRCeUlkKHRoaXMudmFsdWVzLmlkLm1lbnUpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLmhpZGUoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQXV0b2NvbXBsZXRlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAocmVzdWx0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnZhbHVlcy5zZWFyY2gucmVzdWx0cyA9IHJlc3VsdHM7XG4gICAgICAgIHRoaXNcbiAgICAgICAgICAgIC52aWV3XG4gICAgICAgICAgICAuZmluZEJ5SWQodGhpcy52YWx1ZXMuaWQubWVudSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0uc2V0Q29udGVudChuZXcgdmlld3MuUmVzdWx0cyhfdGhpcykpLnNob3coKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIEF1dG9jb21wbGV0ZTtcbn0obHVyY2hfMS5TZWFyY2hDb250cm9sKSk7XG5leHBvcnRzLkF1dG9jb21wbGV0ZSA9IEF1dG9jb21wbGV0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUF1dG9jb21wbGV0ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBBdXRvY29tcGxldGVfMSA9IHJlcXVpcmUoXCIuL0F1dG9jb21wbGV0ZVwiKTtcbmV4cG9ydHMuQXV0b2NvbXBsZXRlID0gQXV0b2NvbXBsZXRlXzEuQXV0b2NvbXBsZXRlO1xudmFyIGx1cmNoXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb250cm9sL2x1cmNoXCIpO1xuZXhwb3J0cy5JdGVtU2VsZWN0ZWRFdmVudCA9IGx1cmNoXzEuSXRlbVNlbGVjdGVkRXZlbnQ7XG5leHBvcnRzLlRlcm1DaGFuZ2VkRXZlbnQgPSBsdXJjaF8xLlRlcm1DaGFuZ2VkRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIE1lbnVfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL21lbnUvTWVudVwiKTtcbjtcbnZhciBNZW51SXRlbV8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvbWVudS9NZW51SXRlbVwiKTtcbjtcbnZhciBGcmFnbWVudF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvbGF5b3V0L2ZyYWdtZW50L0ZyYWdtZW50XCIpO1xuO1xuZXhwb3J0cy5wb3B1bGF0ZWQgPSBmdW5jdGlvbiAob3B0aW9uLCBfaW5kZXgsIF9vcHRpb25zKSB7IHJldHVybiBmdW5jdGlvbiAoX19fY29udGV4dCkgeyByZXR1cm4gZnVuY3Rpb24gKF9fX3ZpZXcpIHsgcmV0dXJuIF9fX3dtbC5kb21pZnkoX19fY29udGV4dC52YWx1ZXMuaXRlbS5zdHJpbmdpZnkob3B0aW9uKSk7IH07IH07IH07XG47XG5leHBvcnRzLmVtcHR5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKF9fX2NvbnRleHQpIHsgcmV0dXJuIGZ1bmN0aW9uIChfX192aWV3KSB7IHJldHVybiBfX193bWwuZG9taWZ5KFwiTm8gcmVzdWx0cyB0byBkaXNwbGF5LlwiKTsgfTsgfTsgfTtcbjtcbnZhciBSZXN1bHRzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZXN1bHRzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlc3VsdHMoY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLndpZGdldChGcmFnbWVudF8xLkZyYWdtZW50LCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC5tYXAoX19fY29udGV4dC52YWx1ZXMuc2VhcmNoLnJlc3VsdHMsIGZ1bmN0aW9uIF9tYXAob3B0aW9uLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19fd21sLndpZGdldChNZW51SXRlbV8xLk1lbnVJdGVtLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogKFwiXCIgKyBpbmRleCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2xpY2snOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfX19jb250ZXh0LnZhbHVlcy5pdGVtLmNsaWNrKGluZGV4KTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeShfX19jb250ZXh0LnZhbHVlcy5pdGVtLnRlbXBsYXRlLnBvcHVsYXRlZChvcHRpb24sIGluZGV4LCBfX19jb250ZXh0LnZhbHVlcy5zZWFyY2gucmVzdWx0cykoX19fY29udGV4dCkoX19fdmlldykpXSwgX19fdmlldyk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gb3RoZXJ3aXNlKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19fd21sLmRvbWlmeShfX19jb250ZXh0LnZhbHVlcy5pdGVtLnRlbXBsYXRlLmVtcHR5KCkoX19fY29udGV4dCkoX19fdmlldykpO1xuICAgICAgICAgICAgICAgIH0pXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJlc3VsdHM7XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLlJlc3VsdHMgPSBSZXN1bHRzO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnZGl2Jywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMucm9vdC5jbGFzc1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC5ub2RlKCdpbnB1dCcsIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLmlucHV0LmNsYXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29ua2V5ZG93bic6IF9fX2NvbnRleHQudmFsdWVzLmlucHV0Lm9uS2V5RG93bixcbiAgICAgICAgICAgICAgICAgICAgICAgICdvbmtleXVwJzogX19fY29udGV4dC52YWx1ZXMuaW5wdXQub25LZXlVcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvbmlucHV0JzogX19fY29udGV4dC52YWx1ZXMuaW5wdXQub25JbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwbGFjZWhvbGRlcic6IF9fX2NvbnRleHQudmFsdWVzLmlucHV0LnBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogX19fY29udGV4dC52YWx1ZXMuaW5wdXQuaWRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KSwgX19fd21sLndpZGdldChNZW51XzEuTWVudSwge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnaWQnOiBfX19jb250ZXh0LnZhbHVlcy5tZW51LmlkXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnaGlkZGVuJzogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0b2NvbXBsZXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29udHJvbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29udHJvbFwiKTtcbi8qKlxuICogQnV0dG9uQ2hhbmdlZEV2ZW50XG4gKi9cbnZhciBCdXR0b25DaGFuZ2VkRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJ1dHRvbkNoYW5nZWRFdmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCdXR0b25DaGFuZ2VkRXZlbnQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEJ1dHRvbkNoYW5nZWRFdmVudDtcbn0oY29udHJvbF8xLkV2ZW50KSk7XG5leHBvcnRzLkJ1dHRvbkNoYW5nZWRFdmVudCA9IEJ1dHRvbkNoYW5nZWRFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJ1dHRvbkNoYW5nZWRFdmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEJ1dHRvbkNoYW5nZWRFdmVudF8xID0gcmVxdWlyZShcIi4vQnV0dG9uQ2hhbmdlZEV2ZW50XCIpO1xudmFyIEJ1dHRvblNlbGVjdEdyb3VwXzEgPSByZXF1aXJlKFwiLi9CdXR0b25TZWxlY3RHcm91cFwiKTtcbnZhciBNYXliZV8xID0gcmVxdWlyZShcImFmcGwvbGliL21vbmFkL01heWJlXCIpO1xuLyoqXG4gKiBCdXR0b25TZWxlY3RcbiAqL1xudmFyIEJ1dHRvblNlbGVjdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQnV0dG9uU2VsZWN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJ1dHRvblNlbGVjdCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBCdXR0b25TZWxlY3QucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE1heWJlXzEuTWF5YmUuZnJvbUFueSh2YWx1ZSk7XG4gICAgfTtcbiAgICBCdXR0b25TZWxlY3QucHJvdG90eXBlLmNsaWNrID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWVzLnNlbGVjdC52YWx1ZSA9IE1heWJlXzEuTWF5YmUuZnJvbUFueSh2YWx1ZSk7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUub25DaGFuZ2UobmV3IEJ1dHRvbkNoYW5nZWRFdmVudF8xLkJ1dHRvbkNoYW5nZWRFdmVudCh0aGlzLmF0dHJzLnd3Lm5hbWUsIHZhbHVlKSk7XG4gICAgICAgIHRoaXMudmlldy5pbnZhbGlkYXRlKCk7XG4gICAgfTtcbiAgICBCdXR0b25TZWxlY3QucHJvdG90eXBlLmlzU2VsZWN0ZWQgPSBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXMuc2VsZWN0LnZhbHVlLmNhdGEoZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH0sIGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgPT09IHY7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEJ1dHRvblNlbGVjdDtcbn0oQnV0dG9uU2VsZWN0R3JvdXBfMS5CdXR0b25TZWxlY3RHcm91cCkpO1xuZXhwb3J0cy5CdXR0b25TZWxlY3QgPSBCdXR0b25TZWxlY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CdXR0b25TZWxlY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuYW1lcyA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi9uYW1lc1wiKTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9idXR0b24tc2VsZWN0XCIpO1xudmFyIGNvbnRyb2xfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbnRyb2xcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL3V0aWxcIik7XG4vKipcbiAqIEJ1dHRvblNlbGVjdEdyb3VwXG4gKi9cbnZhciBCdXR0b25TZWxlY3RHcm91cCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQnV0dG9uU2VsZWN0R3JvdXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQnV0dG9uU2VsZWN0R3JvdXAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdyb290JyxcbiAgICAgICAgICAgICAgICBjbGFzczogbmFtZXMuQlVUVE9OX1NFTEVDVFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhlbHA6IHtcbiAgICAgICAgICAgICAgICBpZDogJ2hlbHAnLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IF90aGlzLmF0dHJzLnd3LnN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgZXJyb3I6IF90aGlzLmF0dHJzLnd3LmVycm9yLFxuICAgICAgICAgICAgICAgIHdhcm5pbmc6IF90aGlzLmF0dHJzLnd3Lndhcm5pbmdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWxlY3Q6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogX3RoaXMuaW5pdGlhbGl6ZShfdGhpcy5hdHRycy53dy52YWx1ZSksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogX3RoaXMuYXR0cnMud3cub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBpc1NlbGVjdGVkOiBmdW5jdGlvbiAodikgeyByZXR1cm4gX3RoaXMuaXNTZWxlY3RlZCh2KTsgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiAodikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY2xpY2sodik7IH07IH0sXG4gICAgICAgICAgICBjYWxjdWxhdGVDbGFzczogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IF9hLmNsYXNzTmFtZSwgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbF8xLmNvbmNhdChuYW1lcy5CVVRUT05fU0VMRUNUX09QVElPTiwgY2xhc3NOYW1lLCAoX3RoaXMuYXR0cnMud3cudmFyaWFudCkgPyBfdGhpcy5hdHRycy53dy52YXJpYW50IDogbmFtZXMuREVGQVVMVCwgX3RoaXMudmFsdWVzLnNlbGVjdC5pc1NlbGVjdGVkKHZhbHVlKSA/IG5hbWVzLkFDVElWRSA6ICcnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEJ1dHRvblNlbGVjdEdyb3VwO1xufShjb250cm9sXzEuRm9ybUNvbnRyb2wpKTtcbmV4cG9ydHMuQnV0dG9uU2VsZWN0R3JvdXAgPSBCdXR0b25TZWxlY3RHcm91cDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJ1dHRvblNlbGVjdEdyb3VwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQnV0dG9uQ2hhbmdlZEV2ZW50XzEgPSByZXF1aXJlKFwiLi9CdXR0b25DaGFuZ2VkRXZlbnRcIik7XG52YXIgQnV0dG9uU2VsZWN0R3JvdXBfMSA9IHJlcXVpcmUoXCIuL0J1dHRvblNlbGVjdEdyb3VwXCIpO1xudmFyIE1heWJlXzEgPSByZXF1aXJlKFwiYWZwbC9saWIvbW9uYWQvTWF5YmVcIik7XG4vKipcbiAqIE11bHRpQnV0dG9uU2VsZWN0XG4gKi9cbnZhciBNdWx0aUJ1dHRvblNlbGVjdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTXVsdGlCdXR0b25TZWxlY3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTXVsdGlCdXR0b25TZWxlY3QoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgTXVsdGlCdXR0b25TZWxlY3QucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gTWF5YmVfMS5NYXliZS5mcm9tQW55KHYpLmNhdGEoZnVuY3Rpb24gKCkgeyByZXR1cm4gTWF5YmVfMS5NYXliZS5mcm9tQXJyYXkoW10pOyB9LCBmdW5jdGlvbiAodikgeyByZXR1cm4gTWF5YmVfMS5NYXliZS5mcm9tQXJyYXkodik7IH0pO1xuICAgIH07XG4gICAgTXVsdGlCdXR0b25TZWxlY3QucHJvdG90eXBlLmNsaWNrID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy52YWx1ZXMuc2VsZWN0LnZhbHVlID0gdGhpc1xuICAgICAgICAgICAgLnZhbHVlc1xuICAgICAgICAgICAgLnNlbGVjdFxuICAgICAgICAgICAgLnZhbHVlXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHBvcyA9IHZhbHVlLmluZGV4T2Yodik7XG4gICAgICAgICAgICBpZiAocG9zID4gLTEpXG4gICAgICAgICAgICAgICAgdmFsdWUuc3BsaWNlKHBvcywgMSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdmFsdWUucHVzaCh2KTtcbiAgICAgICAgICAgIF90aGlzLmRlbGVnYXRlLm9uQ2hhbmdlKG5ldyBCdXR0b25DaGFuZ2VkRXZlbnRfMS5CdXR0b25DaGFuZ2VkRXZlbnQoX3RoaXMuYXR0cnMud3cubmFtZSwgdmFsdWUuc2xpY2UoKSkpO1xuICAgICAgICAgICAgX3RoaXMudmlldy5pbnZhbGlkYXRlKCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAub3JKdXN0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt2XTsgfSk7XG4gICAgfTtcbiAgICBNdWx0aUJ1dHRvblNlbGVjdC5wcm90b3R5cGUuaXNTZWxlY3RlZCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlcy5zZWxlY3QudmFsdWUuY2F0YShmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfSwgZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZS5pbmRleE9mKHYpID4gLTE7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIE11bHRpQnV0dG9uU2VsZWN0O1xufShCdXR0b25TZWxlY3RHcm91cF8xLkJ1dHRvblNlbGVjdEdyb3VwKSk7XG5leHBvcnRzLk11bHRpQnV0dG9uU2VsZWN0ID0gTXVsdGlCdXR0b25TZWxlY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NdWx0aUJ1dHRvblNlbGVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBCdXR0b25TZWxlY3RHcm91cF8xID0gcmVxdWlyZShcIi4vQnV0dG9uU2VsZWN0R3JvdXBcIik7XG5leHBvcnRzLkJ1dHRvblNlbGVjdEdyb3VwID0gQnV0dG9uU2VsZWN0R3JvdXBfMS5CdXR0b25TZWxlY3RHcm91cDtcbnZhciBCdXR0b25TZWxlY3RfMSA9IHJlcXVpcmUoXCIuL0J1dHRvblNlbGVjdFwiKTtcbmV4cG9ydHMuQnV0dG9uU2VsZWN0ID0gQnV0dG9uU2VsZWN0XzEuQnV0dG9uU2VsZWN0O1xudmFyIEJ1dHRvbkNoYW5nZWRFdmVudF8xID0gcmVxdWlyZShcIi4vQnV0dG9uQ2hhbmdlZEV2ZW50XCIpO1xuZXhwb3J0cy5CdXR0b25DaGFuZ2VkRXZlbnQgPSBCdXR0b25DaGFuZ2VkRXZlbnRfMS5CdXR0b25DaGFuZ2VkRXZlbnQ7XG52YXIgTXVsdGlCdXR0b25TZWxlY3RfMSA9IHJlcXVpcmUoXCIuL011bHRpQnV0dG9uU2VsZWN0XCIpO1xuZXhwb3J0cy5NdWx0aUJ1dHRvblNlbGVjdCA9IE11bHRpQnV0dG9uU2VsZWN0XzEuTXVsdGlCdXR0b25TZWxlY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIEJ1dHRvbl8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29udHJvbC9idXR0b24vQnV0dG9uXCIpO1xuO1xuO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnZGl2Jywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMucm9vdC5jbGFzc1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC5tYXAoX19fY29udGV4dC52YWx1ZXMuc2VsZWN0Lm9wdGlvbnMsIGZ1bmN0aW9uIF9tYXAob3B0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfX193bWwud2lkZ2V0KEJ1dHRvbl8xLkJ1dHRvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5jYWxjdWxhdGVDbGFzcyhvcHQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhY3RpdmUnOiBfX19jb250ZXh0LnZhbHVlcy5zZWxlY3QuaXNTZWxlY3RlZChvcHQudmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbkNsaWNrJzogX19fY29udGV4dC52YWx1ZXMuY2xpY2sob3B0LnZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IG9wdC50ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiBvdGhlcndpc2UoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgICAgICAgICAgfSldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idXR0b24tc2VsZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRyA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbnRlbnQvR3JvdXBcIik7XG52YXIgbmFtZXMgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vbmFtZXNcIik7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvYnV0dG9uXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi91dGlsXCIpO1xuLyoqXG4gKiBHcm91cCBtdWx0aXBsZSBidXR0b25zIGludG8gb25lIGVsZW1lbnQuXG4gKi9cbnZhciBHcm91cCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR3JvdXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gR3JvdXAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLkdyb3VwKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgICAgIGNsYXNzOiB1dGlsXzEuY29uY2F0KCdidG4tZ3JvdXAnLCAoX3RoaXMuYXR0cnMud3cpID8gX3RoaXMuYXR0cnMud3cuY2xhc3MgOiAnJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gR3JvdXA7XG59KEcuR3JvdXApKTtcbmV4cG9ydHMuR3JvdXAgPSBHcm91cDtcbjtcbi8qKlxuICogQnV0dG9uIGlzIGFuIGltcHJvdmVtZW50IG92ZXIgSFRNTEJ1dHRpb25FbGVtZW50XG4gKi9cbnZhciBCdXR0b24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJ1dHRvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCdXR0b24oKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLkJ1dHRvbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiB7XG4gICAgICAgICAgICAgICAgYnV0dG9uOiAnYnV0dG9uJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJ1dHRvbjoge1xuICAgICAgICAgICAgICAgIGNsYXNzOiBfdGhpcy5hdHRycy53dyA/XG4gICAgICAgICAgICAgICAgICAgIHV0aWxfMS5jb25jYXQobmFtZXMuQlVUVE9OLCBfdGhpcy5hdHRycy53dy52YXJpYW50IHx8IG5hbWVzLkRFRkFVTFQsIF90aGlzLmF0dHJzLnd3LnN0eWxlLCBfdGhpcy5hdHRycy53dy5hY3RpdmUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXMuQUNUSVZFIDogJycsIF90aGlzLmF0dHJzLnd3LmNsYXNzKSA6XG4gICAgICAgICAgICAgICAgICAgIG5hbWVzLkJVVFRPTixcbiAgICAgICAgICAgICAgICB0eXBlOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cudHlwZSkgPyBfdGhpcy5hdHRycy53dy50eXBlIDogJ2J1dHRvbicsXG4gICAgICAgICAgICAgICAgbmFtZTogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm5hbWUpID8gX3RoaXMuYXR0cnMud3cubmFtZSA6ICcnLFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuZGlzYWJsZWQpID8gX3RoaXMuYXR0cnMud3cuZGlzYWJsZWQgOiBudWxsLFxuICAgICAgICAgICAgICAgIG9uY2xpY2s6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5vbkNsaWNrKSA/IF90aGlzLmF0dHJzLnd3Lm9uQ2xpY2sgOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgICAgICAgICAgICAgdGV4dDogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnRleHQpID8gX3RoaXMuYXR0cnMud3cudGV4dCA6ICcnXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogZGlzYWJsZSB0aGlzIGJ1dHRvbi5cbiAgICAgKi9cbiAgICBCdXR0b24ucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmlldy5maW5kQnlJZCh0aGlzLnZhbHVlcy5pZC5idXR0b24pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChiKSB7IHJldHVybiBiLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBlbmFibGUgdGhpcyBidXR0b24uXG4gICAgICovXG4gICAgQnV0dG9uLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmlldy5maW5kQnlJZCh0aGlzLnZhbHVlcy5pZC5idXR0b24pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChiKSB7IHJldHVybiBiLnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKTsgfSk7XG4gICAgfTtcbiAgICBCdXR0b24ucHJvdG90eXBlLnJlbmRlcmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5hdHRycy53dylcbiAgICAgICAgICAgIGlmICh0aGlzLmF0dHJzLnd3LmRpc2FibGVkKVxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5maW5kQnlJZCh0aGlzLnZhbHVlcy5pZC5idXR0b24pXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGIuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBCdXR0b247XG59KEcuR3JvdXApKTtcbmV4cG9ydHMuQnV0dG9uID0gQnV0dG9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QnV0dG9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgR3JvdXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdyb3VwLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdyb3VwKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5yb290LmNsYXNzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBHcm91cDtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuR3JvdXAgPSBHcm91cDtcbjtcbnZhciBCdXR0b24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJ1dHRvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCdXR0b24oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ2J1dHRvbicsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogX19fY29udGV4dC52YWx1ZXMuYnV0dG9uLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICduYW1lJzogX19fY29udGV4dC52YWx1ZXMuYnV0dG9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICdkaXNhYmxlZCc6IF9fX2NvbnRleHQudmFsdWVzLmJ1dHRvbi5kaXNhYmxlZCxcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuYnV0dG9uLmNsYXNzLFxuICAgICAgICAgICAgICAgICAgICAnb25jbGljayc6IF9fX2NvbnRleHQudmFsdWVzLmJ1dHRvbi5vbmNsaWNrXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2lkJzogXCJidXR0b25cIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIFtfX193bWwuZG9taWZ5KF9fX2NvbnRleHQudmFsdWVzLmJ1dHRvbi50ZXh0KSwgX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBCdXR0b247XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLkJ1dHRvbiA9IEJ1dHRvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1dHRvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5hbWVzID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL25hbWVzXCIpO1xudmFyIHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgY2hlY2tib3hfMSA9IHJlcXVpcmUoXCIuL3dtbC9jaGVja2JveFwiKTtcbnZhciBDaGVja2JveENoYW5nZWRFdmVudF8xID0gcmVxdWlyZShcIi4vQ2hlY2tib3hDaGFuZ2VkRXZlbnRcIik7XG4vKipcbiAqIENoZWNrYm94IGNvbnRyb2wuXG4gKlxuICogVGhpcyBpcyBhbiBhbHRlcm5hdGl2ZSB0byB0aGUgbmF0aXZlIGNoZWNrYm94IHRoYXQgY2FuIGJlIHN0eWxlZC5cbiAqL1xudmFyIENoZWNrYm94ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDaGVja2JveCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDaGVja2JveCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgY2hlY2tib3hfMS5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICByb290OiBuYW1lcy5DSEVDS0JPWCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbnB1dDoge1xuICAgICAgICAgICAgICAgIG5hbWU6IF90aGlzLmF0dHJzLnd3Lm5hbWUsXG4gICAgICAgICAgICAgICAgY2hlY2tlZDogX3RoaXMuYXR0cnMud3cuY2hlY2tlZCB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZXMuaW5wdXQuY2hlY2tlZCA9ICFfdGhpcy52YWx1ZXMuaW5wdXQuY2hlY2tlZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmF0dHJzLnd3Lm9uQ2hhbmdlKVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cub25DaGFuZ2UobmV3IENoZWNrYm94Q2hhbmdlZEV2ZW50XzEuQ2hlY2tib3hDaGFuZ2VkRXZlbnQoX3RoaXMudmFsdWVzLmlucHV0Lm5hbWUsIF90aGlzLnZhbHVlcy5pbnB1dC5jaGVja2VkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDaGVja2JveDtcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLkNoZWNrYm94ID0gQ2hlY2tib3g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DaGVja2JveC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEV2ZW50XzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb250cm9sL0V2ZW50XCIpO1xuLyoqXG4gKiBDaGVja2JveENoYW5nZWRFdmVudCBzaWduYWxzIHRoZSB1c2VyIGhhcyBjaGFuZ2VkIHRoZSBjaGVja2JveCBzdGF0ZS5cbiAqL1xudmFyIENoZWNrYm94Q2hhbmdlZEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDaGVja2JveENoYW5nZWRFdmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDaGVja2JveENoYW5nZWRFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ2hlY2tib3hDaGFuZ2VkRXZlbnQ7XG59KEV2ZW50XzEuRXZlbnQpKTtcbmV4cG9ydHMuQ2hlY2tib3hDaGFuZ2VkRXZlbnQgPSBDaGVja2JveENoYW5nZWRFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNoZWNrYm94Q2hhbmdlZEV2ZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5jbGFzcy5yb290XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ2xhYmVsJywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgnaW5wdXQnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiBcImNoZWNrYm94XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBfX19jb250ZXh0LnZhbHVlcy5pbnB1dC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjaGVja2VkJzogKF9fX2NvbnRleHQudmFsdWVzLmlucHV0LmNoZWNrZWQgfHwgbnVsbCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uY2hhbmdlJzogX19fY29udGV4dC52YWx1ZXMuaW5wdXQub25DaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KSwgX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKV0sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlY2tib3guanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9kYXRlXCIpO1xudmFyIG5hbWVzID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL25hbWVzXCIpO1xudmFyIG1vbWVudCA9IHJlcXVpcmUoXCJtb21lbnRcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL3V0aWxcIik7XG52YXIgY29udHJvbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29udHJvbFwiKTtcbnZhciBEYXRlQ2hhbmdlZEV2ZW50XzEgPSByZXF1aXJlKFwiLi9EYXRlQ2hhbmdlZEV2ZW50XCIpO1xuZXhwb3J0cy5mb3JtYXQgPSB7XG4gICAgWVlZWURETU06ICdZWVlZLU1NLUREJyxcbiAgICBERDogJ0REJyxcbiAgICBNTTogJ01NJyxcbiAgICBZWVlZOiAnWVlZWSdcbn07XG5leHBvcnRzLk1PTlRIUyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXTtcbjtcbnZhciBfaW5wdXRWYWx1ZXMgPSBmdW5jdGlvbiAoaWQsIGtsYXNzLCB2YWx1ZSwgZGF0ZSwgY2IpIHsgcmV0dXJuICh7XG4gICAgaWQ6IGlkLFxuICAgIGNsYXNzOiBrbGFzcyxcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgZGlzYWJsZWQ6IChkYXRlLmF0dHJzLnd3LmRpc2FibGVkID09PSB0cnVlKSA/IHRydWUgOiBudWxsLFxuICAgIHJlYWRPbmx5OiAoZGF0ZS5hdHRycy53dy5yZWFkT25seSA9PT0gdHJ1ZSkgPyB0cnVlIDogbnVsbCxcbiAgICBvbklucHV0OiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gX2EudmFsdWU7XG4gICAgICAgIGNiKHZhbHVlKTtcbiAgICAgICAgZGF0ZS5kYXRlLnZhbHVlID0gZGF0ZS5jYWxjdWxhdGUoKTtcbiAgICAgICAgZGF0ZS5maXJlQ2hhbmdlKCk7XG4gICAgfVxufSk7IH07XG52YXIgX3ByZWZpeCA9IGZ1bmN0aW9uIChzLCBpbmMpIHtcbiAgICBpZiAoaW5jID09PSB2b2lkIDApIHsgaW5jID0gZmFsc2U7IH1cbiAgICB2YXIgbiA9IE51bWJlcihzKTtcbiAgICBpZiAoaW5jKVxuICAgICAgICBuID0gbiArIDE7XG4gICAgaWYgKGlzTmFOKG4pKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgcmV0dXJuIChuIDwgMTApID8gXCIwXCIgKyBuIDogXCJcIiArIG47XG59O1xuLyoqXG4gKiBEYXRlIGlucHV0LlxuICovXG52YXIgRGF0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGF0ZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEYXRlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMuZGVsZWdhdGUgPSBfdGhpcy5hdHRycy53dy5kZWxlZ2F0ZSA/XG4gICAgICAgICAgICBfdGhpcy5hdHRycy53dy5kZWxlZ2F0ZSA6IG5ldyBjb250cm9sXzEuRGVmYXVsdERlbGVnYXRlKF90aGlzLmF0dHJzLnd3KTtcbiAgICAgICAgX3RoaXMuZGF0ZSA9IHtcbiAgICAgICAgICAgIHZhbHVlOiBfdGhpcy5hdHRycy53dy52YWx1ZSA/IG1vbWVudChfdGhpcy5hdHRycy53dy52YWx1ZSwgZXhwb3J0cy5mb3JtYXQuWVlZWURETU0pIDogbnVsbCxcbiAgICAgICAgICAgIHNlcDogJy0nLFxuICAgICAgICAgICAgZm9ybWF0OiBleHBvcnRzLmZvcm1hdC5ZWVlZRERNTVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdyb290JyxcbiAgICAgICAgICAgICAgICBjbGFzczogdXRpbF8xLmNvbmNhdChuYW1lcy5EQVRFLCAnZm9ybS1pbmxpbmUnLCBfdGhpcy5hdHRycy53dy5jbGFzcywgX3RoaXMuc3RhdGUoKSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGF0ZToge1xuICAgICAgICAgICAgICAgIG1vbnRoczogZXhwb3J0cy5NT05USFMubWFwKGZ1bmN0aW9uIChsYWJlbCwgdmFsdWUpIHsgcmV0dXJuICh7IGxhYmVsOiBsYWJlbCwgdmFsdWU6IF9wcmVmaXgodmFsdWUgKyAxKSB9KTsgfSksXG4gICAgICAgICAgICAgICAgcHJlZml4OiBfcHJlZml4XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVsZWdhdGU6IF90aGlzLmRlbGVnYXRlLFxuICAgICAgICAgICAgZGF5OiBfaW5wdXRWYWx1ZXMoJ2RheScsIG5hbWVzLkRBVEVfREFZLCAoX3RoaXMuZGF0ZS52YWx1ZSAmJiBfdGhpcy5kYXRlLnZhbHVlLmlzVmFsaWQoKSkgP1xuICAgICAgICAgICAgICAgIF90aGlzLmRhdGUudmFsdWUuZm9ybWF0KGV4cG9ydHMuZm9ybWF0LkREKSA6ICcnLCBfdGhpcywgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIF90aGlzLnZhbHVlcy5kYXkudmFsdWUgPSBfcHJlZml4KHYpOyB9KSxcbiAgICAgICAgICAgIG1vbnRoOiBfaW5wdXRWYWx1ZXMoJ21vbnRoJywgbmFtZXMuREFURV9NT05USCwgKF90aGlzLmRhdGUudmFsdWUgJiYgX3RoaXMuZGF0ZS52YWx1ZS5pc1ZhbGlkKCkpID9cbiAgICAgICAgICAgICAgICBfdGhpcy5kYXRlLnZhbHVlLmZvcm1hdChleHBvcnRzLmZvcm1hdC5NTSkgOiAnJywgX3RoaXMsIGZ1bmN0aW9uICh2KSB7IHJldHVybiBfdGhpcy52YWx1ZXMubW9udGgudmFsdWUgPSB2OyB9KSxcbiAgICAgICAgICAgIHllYXI6IF9pbnB1dFZhbHVlcygneWVhcicsIG5hbWVzLkRBVEVfWUVBUiwgKF90aGlzLmRhdGUudmFsdWUgJiYgX3RoaXMuZGF0ZS52YWx1ZS5pc1ZhbGlkKCkpID9cbiAgICAgICAgICAgICAgICBfdGhpcy5kYXRlLnZhbHVlLmZvcm1hdChleHBvcnRzLmZvcm1hdC5ZWVlZKSA6ICcnLCBfdGhpcywgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIF90aGlzLnZhbHVlcy55ZWFyLnZhbHVlID0gdjsgfSksXG4gICAgICAgICAgICBuYW1lOiBfdGhpcy5hdHRycy53dy5uYW1lLFxuICAgICAgICAgICAgaGVscDoge1xuICAgICAgICAgICAgICAgIGlkOiAnaGVscCcsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogX3RoaXMuYXR0cnMud3cuc3VjY2VzcyxcbiAgICAgICAgICAgICAgICBlcnJvcjogX3RoaXMuYXR0cnMud3cuZXJyb3IsXG4gICAgICAgICAgICAgICAgd2FybmluZzogX3RoaXMuYXR0cnMud3cud2FybmluZ1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZSB0aGUgZGF0ZSBiYXNlZCBvbiB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgaW5wdXRzLlxuICAgICAqL1xuICAgIERhdGUucHJvdG90eXBlLmNhbGN1bGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGUgPSBbXG4gICAgICAgICAgICB0aGlzLnZhbHVlcy55ZWFyLnZhbHVlLFxuICAgICAgICAgICAgdGhpcy52YWx1ZXMubW9udGgudmFsdWUsXG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5kYXkudmFsdWVcbiAgICAgICAgXS5maWx0ZXIoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQ7IH0pO1xuICAgICAgICByZXR1cm4gKGRhdGUubGVuZ3RoICE9IDMpID8gbnVsbCA6IG1vbWVudChkYXRlLmpvaW4odGhpcy5kYXRlLnNlcCksIG1vbWVudC5JU09fODYwMSk7XG4gICAgfTtcbiAgICA7XG4gICAgLyoqXG4gICAgICogZmlyZUNoYW5nZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgRGF0ZS5wcm90b3R5cGUuZmlyZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0ZS52YWx1ZSAmJiB0aGlzLmRhdGUudmFsdWUuaXNWYWxpZCgpKVxuICAgICAgICAgICAgdGhpcy52YWx1ZXMuZGVsZWdhdGUub25DaGFuZ2UobmV3IERhdGVDaGFuZ2VkRXZlbnRfMS5EYXRlQ2hhbmdlZEV2ZW50KHRoaXMudmFsdWVzLm5hbWUsIHRoaXMuZGF0ZS52YWx1ZS5mb3JtYXQodGhpcy5kYXRlLmZvcm1hdCkpKTtcbiAgICB9O1xuICAgIHJldHVybiBEYXRlO1xufShjb250cm9sXzEuRm9ybUNvbnRyb2wpKTtcbmV4cG9ydHMuRGF0ZSA9IERhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EYXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRXZlbnRfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbnRyb2wvRXZlbnRcIik7XG4vKipcbiAqIERhdGVDaGFuZ2VkRXZlbnQgaXMgZ2VuZXJhdGVkIHdoZW4gdGhlIGRhdGUgaGFzXG4gKiBiZWVuIGNoYW5nZWQgdG8gYSB2YWxpZCBkYXRlLlxuICovXG52YXIgRGF0ZUNoYW5nZWRFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGF0ZUNoYW5nZWRFdmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEYXRlQ2hhbmdlZEV2ZW50KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBEYXRlQ2hhbmdlZEV2ZW50O1xufShFdmVudF8xLkV2ZW50KSk7XG5leHBvcnRzLkRhdGVDaGFuZ2VkRXZlbnQgPSBEYXRlQ2hhbmdlZEV2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGF0ZUNoYW5nZWRFdmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIHdtbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29udHJvbC93bWxcIik7XG47XG52YXIgc2VsZWN0XzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb250cm9sL3NlbGVjdFwiKTtcbjtcbnZhciB0ZXh0X2ZpZWxkXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb250cm9sL3RleHQtZmllbGRcIik7XG47XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5yb290LmNsYXNzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChzZWxlY3RfMS5TZWxlY3QsIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogX19fY29udGV4dC52YWx1ZXMubW9udGguaWRcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogX19fY29udGV4dC52YWx1ZXMubW9udGguaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb25DaGFuZ2UnOiBfX19jb250ZXh0LnZhbHVlcy5tb250aC5vbklucHV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Rpc2FibGVkJzogX19fY29udGV4dC52YWx1ZXMubW9udGguZGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAncmVhZE9ubHknOiBfX19jb250ZXh0LnZhbHVlcy5tb250aC5yZWFkT25seSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLm1vbnRoLmNsYXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29wdGlvbnMnOiBfX19jb250ZXh0LnZhbHVlcy5kYXRlLm1vbnRoc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC5ub2RlKCdvcHRpb24nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NlbGVjdGVkJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndmFsdWUnOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkaXNhYmxlZCc6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIk1vbnRoXCIpXSwgX19fdmlldyldLCBfX192aWV3KSwgX19fd21sLndpZGdldCh0ZXh0X2ZpZWxkXzEuVGV4dEZpZWxkLCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdpZCc6IF9fX2NvbnRleHQudmFsdWVzLmRheS5pZFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBfX19jb250ZXh0LnZhbHVlcy5kYXkuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb25DaGFuZ2UnOiBfX19jb250ZXh0LnZhbHVlcy5kYXkub25JbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICd2YWx1ZSc6IF9fX2NvbnRleHQudmFsdWVzLmRheS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkaXNhYmxlZCc6IF9fX2NvbnRleHQudmFsdWVzLmRheS5kaXNhYmxlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZWFkT25seSc6IF9fX2NvbnRleHQudmFsdWVzLmRheS5yZWFkT25seSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLmRheS5jbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwbGFjZWhvbGRlcic6IFwiRERcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KHRleHRfZmllbGRfMS5UZXh0RmllbGQsIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogX19fY29udGV4dC52YWx1ZXMueWVhci5pZFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBfX19jb250ZXh0LnZhbHVlcy55ZWFyLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2hhbmdlJzogX19fY29udGV4dC52YWx1ZXMueWVhci5vbklucHV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3ZhbHVlJzogX19fY29udGV4dC52YWx1ZXMueWVhci52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkaXNhYmxlZCc6IF9fX2NvbnRleHQudmFsdWVzLnllYXIuZGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAncmVhZE9ubHknOiBfX19jb250ZXh0LnZhbHVlcy55ZWFyLnJlYWRPbmx5LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMueWVhci5jbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwbGFjZWhvbGRlcic6IFwiWVlZWVwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyksIF9fX3dtbC5kb21pZnkod21sXzEubWVzc2FnZShfX19jb250ZXh0LnZhbHVlcy5oZWxwLmlkLCBfX19jb250ZXh0LnZhbHVlcy5oZWxwKShfX192aWV3KSldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmFtZXMgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vbmFtZXNcIik7XG52YXIgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vdXRpbFwiKTtcbnZhciBpY29uX2J1dHRvbl8xID0gcmVxdWlyZShcIi4vd21sL2ljb24tYnV0dG9uXCIpO1xuLyoqXG4gKiBJY29uQnV0dG9uIHByb3ZpZGVzIGEgJ2hhbWJ1cmdlcicgbWVudSBidXR0b24uXG4gKi9cbnZhciBJY29uQnV0dG9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJY29uQnV0dG9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEljb25CdXR0b24oKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IGljb25fYnV0dG9uXzEuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgcm9vdDogbmFtZXMuSUNPTl9CVVRUT05cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBidXR0b246IHtcbiAgICAgICAgICAgICAgICBjbGFzczogdXRpbF8xLmNvbmNhdChuYW1lcy5JQ09OX0JVVFRPTiwgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmNsYXNzKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LmNsYXNzIDogJycpLFxuICAgICAgICAgICAgICAgIG9uQ2xpY2s6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5vbkNsaWNrKSA/IF90aGlzLmF0dHJzLnd3Lm9uQ2xpY2sgOiBmdW5jdGlvbiAoKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSWNvbkJ1dHRvbjtcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLkljb25CdXR0b24gPSBJY29uQnV0dG9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SWNvbkJ1dHRvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnYnV0dG9uJywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuYnV0dG9uLmNsYXNzLFxuICAgICAgICAgICAgICAgICAgICAnb25jbGljayc6IF9fX2NvbnRleHQudmFsdWVzLmJ1dHRvbi5vbkNsaWNrXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWljb24tYnV0dG9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEV2ZW50XzEgPSByZXF1aXJlKFwiLi9FdmVudFwiKTtcbmV4cG9ydHMuRXZlbnQgPSBFdmVudF8xLkV2ZW50O1xudmFyIERlZmF1bHREZWxlZ2F0ZV8xID0gcmVxdWlyZShcIi4vRGVmYXVsdERlbGVnYXRlXCIpO1xuZXhwb3J0cy5EZWZhdWx0RGVsZWdhdGUgPSBEZWZhdWx0RGVsZWdhdGVfMS5EZWZhdWx0RGVsZWdhdGU7XG52YXIgQ29udHJvbF8xID0gcmVxdWlyZShcIi4vQ29udHJvbFwiKTtcbmV4cG9ydHMuQ29udHJvbCA9IENvbnRyb2xfMS5Db250cm9sO1xudmFyIEZvcm1Db250cm9sXzEgPSByZXF1aXJlKFwiLi9Gb3JtQ29udHJvbFwiKTtcbmV4cG9ydHMuRm9ybUNvbnRyb2wgPSBGb3JtQ29udHJvbF8xLkZvcm1Db250cm9sO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb250cm9sXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb250cm9sXCIpO1xudmFyIEl0ZW1TZWxlY3RlZEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJdGVtU2VsZWN0ZWRFdmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJdGVtU2VsZWN0ZWRFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSXRlbVNlbGVjdGVkRXZlbnQ7XG59KGNvbnRyb2xfMS5FdmVudCkpO1xuZXhwb3J0cy5JdGVtU2VsZWN0ZWRFdmVudCA9IEl0ZW1TZWxlY3RlZEV2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SXRlbVNlbGVjdGVkRXZlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vdXRpbFwiKTtcbnZhciBUZXJtQ2hhbmdlZEV2ZW50XzEgPSByZXF1aXJlKFwiLi9UZXJtQ2hhbmdlZEV2ZW50XCIpO1xudmFyIFNlYXJjaERlZmF1bHREZWxlZ2F0ZV8xID0gcmVxdWlyZShcIi4vU2VhcmNoRGVmYXVsdERlbGVnYXRlXCIpO1xudmFyIGNvbnRyb2xfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbnRyb2xcIik7XG5leHBvcnRzLkVTQ0FQRSA9IDI3O1xuZXhwb3J0cy5ERUZBVUxUX0RFQk9VTkNFX1RJTUUgPSA1MDA7XG5leHBvcnRzLklOUFVUX0lEID0gJ2lucHV0Jztcbi8qKlxuICogU2VhcmNoQ29udHJvbFxuICovXG52YXIgU2VhcmNoQ29udHJvbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2VhcmNoQ29udHJvbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTZWFyY2hDb250cm9sKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuREVGQVVMVF9ERUJPVU5DRV9USU1FID0gZXhwb3J0cy5ERUZBVUxUX0RFQk9VTkNFX1RJTUU7XG4gICAgICAgIF90aGlzLmRlbGVnYXRlID0gX3RoaXMuYXR0cnMud3cuZGVsZWdhdGUgP1xuICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuZGVsZWdhdGUgOiBuZXcgU2VhcmNoRGVmYXVsdERlbGVnYXRlXzEuU2VhcmNoRGVmYXVsdERlbGVnYXRlKF90aGlzLmF0dHJzLnd3KTtcbiAgICAgICAgX3RoaXMucmVzdWx0cyA9IFtdO1xuICAgICAgICBfdGhpcy5vbktleURvd24gPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gKGUua2V5Q29kZSAhPT0gZXhwb3J0cy5FU0NBUEUpID8gX3RoaXMuZXhlY3V0ZShudWxsKSA6IG51bGw7IH07XG4gICAgICAgIF90aGlzLm9uS2V5VXAgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gZXhwb3J0cy5FU0NBUEUpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuYmx1cigpO1xuICAgICAgICAgICAgICAgIF90aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uSW5wdXQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgLy9Gb3IgY29tcGF0YWJpbGl0eSByZWFzb25zXG4gICAgICAgICAgICBlLnRhcmdldC5vbmtleWRvd24gPSBudWxsO1xuICAgICAgICAgICAgX3RoaXMub25LZXlEb3duKGUpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5leGVjdXRlID0gdXRpbF8xLmRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzXG4gICAgICAgICAgICAgICAgLnZpZXdcbiAgICAgICAgICAgICAgICAuZmluZEJ5SWQoX3RoaXMudmFsdWVzLmlucHV0LmlkKVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gX2EudmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmRlbGVnYXRlLm9uU2VhcmNoKG5ldyBUZXJtQ2hhbmdlZEV2ZW50XzEuVGVybUNoYW5nZWRFdmVudChfdGhpcy5hdHRycy53dy5uYW1lLCB2YWx1ZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIF90aGlzLmF0dHJzLnd3LmRlYm91bmNlIHx8IF90aGlzLkRFRkFVTFRfREVCT1VOQ0VfVElNRSk7XG4gICAgICAgIF90aGlzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBTdHJpbmcodik7IH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU2VhcmNoQ29udHJvbC5wcm90b3R5cGUucmVuZGVyZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcyk7XG4gICAgfTtcbiAgICBTZWFyY2hDb250cm9sLnByb3RvdHlwZS5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXNcbiAgICAgICAgICAgIC52aWV3XG4gICAgICAgICAgICAuZmluZEJ5SWQodGhpcy52YWx1ZXMuaWQucm9vdClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgICAgICAgIGlmICghcm9vdC5jb250YWlucyhlLnRhcmdldCkpXG4gICAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyhyb290KSlcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIF90aGlzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gU2VhcmNoQ29udHJvbDtcbn0oY29udHJvbF8xLkZvcm1Db250cm9sKSk7XG5leHBvcnRzLlNlYXJjaENvbnRyb2wgPSBTZWFyY2hDb250cm9sO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2VhcmNoQ29udHJvbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbnRyb2xfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbnRyb2xcIik7XG4vKipcbiAqIFNlYXJjaERlZmF1bHREZWxlZ2F0ZSBmb3dhcmRzIGFsbCBldmVudHMgdG8gdGhlaXIgY29ycmVzcG9uZGluZ1xuICogZnVuY3Rpb24gaGFuZGxlcnMsIHNwZWNpZmVkIG9uIHRoZSBhdHRyaWJ1dGVzIG9mIGEgY29udHJvbC5cbiAqL1xudmFyIFNlYXJjaERlZmF1bHREZWxlZ2F0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2VhcmNoRGVmYXVsdERlbGVnYXRlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNlYXJjaERlZmF1bHREZWxlZ2F0ZShhdHRycykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBhdHRycykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgX3RoaXMub25TZWFyY2ggPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmF0dHJzLm9uU2VhcmNoKVxuICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLm9uU2VhcmNoKGUpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vblNlbGVjdCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuYXR0cnMub25TZWxlY3QpXG4gICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMub25TZWxlY3QoZSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFNlYXJjaERlZmF1bHREZWxlZ2F0ZTtcbn0oY29udHJvbF8xLkRlZmF1bHREZWxlZ2F0ZSkpO1xuZXhwb3J0cy5TZWFyY2hEZWZhdWx0RGVsZWdhdGUgPSBTZWFyY2hEZWZhdWx0RGVsZWdhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZWFyY2hEZWZhdWx0RGVsZWdhdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb250cm9sXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb250cm9sXCIpO1xuLyoqXG4gKiBUZXJtQ2hhbmdlZEV2ZW50IHNpZ25hbHMgdGhlIHNlYXJjaCB0ZXJtIGhhcyBjaGFuZ2VkLlxuICovXG52YXIgVGVybUNoYW5nZWRFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGVybUNoYW5nZWRFdmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUZXJtQ2hhbmdlZEV2ZW50KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBUZXJtQ2hhbmdlZEV2ZW50O1xufShjb250cm9sXzEuRXZlbnQpKTtcbmV4cG9ydHMuVGVybUNoYW5nZWRFdmVudCA9IFRlcm1DaGFuZ2VkRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UZXJtQ2hhbmdlZEV2ZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFNlYXJjaENvbnRyb2xfMSA9IHJlcXVpcmUoXCIuL1NlYXJjaENvbnRyb2xcIik7XG5leHBvcnRzLlNlYXJjaENvbnRyb2wgPSBTZWFyY2hDb250cm9sXzEuU2VhcmNoQ29udHJvbDtcbnZhciBTZWFyY2hEZWZhdWx0RGVsZWdhdGVfMSA9IHJlcXVpcmUoXCIuL1NlYXJjaERlZmF1bHREZWxlZ2F0ZVwiKTtcbmV4cG9ydHMuU2VhcmNoRGVmYXVsdERlbGVnYXRlID0gU2VhcmNoRGVmYXVsdERlbGVnYXRlXzEuU2VhcmNoRGVmYXVsdERlbGVnYXRlO1xudmFyIEl0ZW1TZWxlY3RlZEV2ZW50XzEgPSByZXF1aXJlKFwiLi9JdGVtU2VsZWN0ZWRFdmVudFwiKTtcbmV4cG9ydHMuSXRlbVNlbGVjdGVkRXZlbnQgPSBJdGVtU2VsZWN0ZWRFdmVudF8xLkl0ZW1TZWxlY3RlZEV2ZW50O1xudmFyIFRlcm1DaGFuZ2VkRXZlbnRfMSA9IHJlcXVpcmUoXCIuL1Rlcm1DaGFuZ2VkRXZlbnRcIik7XG5leHBvcnRzLlRlcm1DaGFuZ2VkRXZlbnQgPSBUZXJtQ2hhbmdlZEV2ZW50XzEuVGVybUNoYW5nZWRFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmFtZXMgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vbmFtZXNcIik7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvc2VhcmNoLXN0YWNrXCIpO1xudmFyIGNvbnRyb2xfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbnRyb2xcIik7XG4vKipcbiAqIFNlYXJjaFN0YWNrXG4gKi9cbnZhciBTZWFyY2hTdGFjayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2VhcmNoU3RhY2ssIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2VhcmNoU3RhY2soKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBpZDoge1xuICAgICAgICAgICAgICAgIHJvb3Q6ICdyb290JyxcbiAgICAgICAgICAgICAgICBpbnB1dDogJ2J1dHRvbicsXG4gICAgICAgICAgICAgICAgc2VhcmNoOiAnc2VhcmNoJyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnbWVzc2FnZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdyb290JyxcbiAgICAgICAgICAgICAgICBjbGFzczogbmFtZXMuU0VBUkNIX1NUQUNLXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGVscDoge1xuICAgICAgICAgICAgICAgIGlkOiAnaGVscCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWFyY2g6IHtcbiAgICAgICAgICAgICAgICBpZDogJ3NlYXJjaCcsXG4gICAgICAgICAgICAgICAgbmFtZTogX3RoaXMuYXR0cnMud3cubmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogJycsXG4gICAgICAgICAgICAgICAgb25TZWFyY2g6IGZ1bmN0aW9uIChldnQpIHsgaWYgKF90aGlzLmF0dHJzLnd3Lm9uU2VhcmNoKVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5vblNlYXJjaChldnQpOyB9LFxuICAgICAgICAgICAgICAgIG9uU2VsZWN0OiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gX2EudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RhY2s6IHtcbiAgICAgICAgICAgICAgICBpZDogJ3N0YWNrJyxcbiAgICAgICAgICAgICAgICBuYW1lOiBfdGhpcy5hdHRycy53dy5uYW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBfdGhpcy5hdHRycy53dy52YWx1ZSxcbiAgICAgICAgICAgICAgICBkZWNvcmF0b3I6IF90aGlzLmF0dHJzLnd3LmRlY29yYXRvciA/IF90aGlzLmF0dHJzLnd3LmRlY29yYXRvciA6IGZ1bmN0aW9uICh2KSB7IHJldHVybiBTdHJpbmcodik7IH0sXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIChldnQpIHsgcmV0dXJuIF90aGlzLmRlbGVnYXRlLm9uQ2hhbmdlKGV2dCk7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB1cGRhdGUgdGhlIGxpc3Qgb2YgYXZhaWxhYmxlIG9wdGlvbnMgZGlzcGxheWVkIHRvIHRoZSB1c2VyLlxuICAgICAqL1xuICAgIFNlYXJjaFN0YWNrLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobGlzdCkge1xuICAgICAgICB0aGlzXG4gICAgICAgICAgICAudmlld1xuICAgICAgICAgICAgLmZpbmRCeUlkKHRoaXMudmFsdWVzLnNlYXJjaC5pZClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudXBkYXRlKGxpc3QpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBwdXNoIGEgdmFsdWUgb250byB0aGUgc3RhY2suXG4gICAgICovXG4gICAgU2VhcmNoU3RhY2sucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodikge1xuICAgICAgICB0aGlzXG4gICAgICAgICAgICAudmlld1xuICAgICAgICAgICAgLmZpbmRCeUlkKHRoaXMudmFsdWVzLnN0YWNrLmlkKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gcy5wdXNoKHYpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gU2VhcmNoU3RhY2s7XG59KGNvbnRyb2xfMS5Gb3JtQ29udHJvbCkpO1xuZXhwb3J0cy5TZWFyY2hTdGFjayA9IFNlYXJjaFN0YWNrO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2VhcmNoU3RhY2suanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBhdXRvY29tcGxldGVfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbnRyb2wvYXV0b2NvbXBsZXRlXCIpO1xuO1xudmFyIHN0YWNrXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb250cm9sL3N0YWNrXCIpO1xuO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnZGl2Jywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMucm9vdC5jbGFzc1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoc3RhY2tfMS5TdGFjaywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnaWQnOiBfX19jb250ZXh0LnZhbHVlcy5zdGFjay5pZFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBfX19jb250ZXh0LnZhbHVlcy5zdGFjay5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3ZhbHVlJzogX19fY29udGV4dC52YWx1ZXMuc3RhY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGVjb3JhdG9yJzogX19fY29udGV4dC52YWx1ZXMuc3RhY2suZGVjb3JhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2hhbmdlJzogX19fY29udGV4dC52YWx1ZXMuc3RhY2sub25DaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KSwgX19fd21sLndpZGdldChhdXRvY29tcGxldGVfMS5BdXRvY29tcGxldGUsIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogX19fY29udGV4dC52YWx1ZXMuc2VhcmNoLmlkXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IF9fX2NvbnRleHQudmFsdWVzLnNlYXJjaC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3ZhbHVlJzogX19fY29udGV4dC52YWx1ZXMuc2VhcmNoLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N0cmluZ2lmaWVyJzogX19fY29udGV4dC52YWx1ZXMuc3RhY2suZGVjb3JhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29uU2VhcmNoJzogX19fY29udGV4dC52YWx1ZXMuc2VhcmNoLm9uU2VhcmNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29uU2VsZWN0JzogX19fY29udGV4dC52YWx1ZXMuc2VhcmNoLm9uU2VsZWN0XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWFyY2gtc3RhY2suanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9zZWxlY3RcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL3V0aWxcIik7XG52YXIgY29udHJvbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29udHJvbFwiKTtcbnZhciBTZWxlY3RDaGFuZ2VkRXZlbnRfMSA9IHJlcXVpcmUoXCIuL1NlbGVjdENoYW5nZWRFdmVudFwiKTtcbi8qKlxuICogU2VsZWN0IHByb3ZpZGVzIGEgZHJvcGRvd24gbGlzdCBmb3Igc2VsZWN0aW5nIGl0ZW1zLlxuICpcbiAqIE5vdGU6IEN1cnJlbnRseSB0aGlzIHJlbGllcyBvbiB0aGUgbmF0aXZlIHNlbGVjdCBidXQgdGhpc1xuICogaXMgbGlrZWx5IHRvIGNoYW5nZSBpbiB0aGUgZnV0dXJlLiBVc2UgdGhlIG5hdGl2ZSA8c2VsZWN0PlxuICogZGlyZWN0bHkgaWYgeW91IG11c3QgaGF2ZSB0aGF0LlxuICovXG52YXIgU2VsZWN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTZWxlY3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2VsZWN0KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgICAgIGlkOiAncm9vdCcsXG4gICAgICAgICAgICAgICAgY2xhc3M6IHV0aWxfMS5jb25jYXQoJ2Zvcm0tZ3JvdXAnLCBfdGhpcy5hdHRycy53dy5jbGFzcywgX3RoaXMuc3RhdGUoKSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgICAgIGlkOiBfdGhpcy5hdHRycy53dy5uYW1lLFxuICAgICAgICAgICAgICAgIHRleHQ6IF90aGlzLmF0dHJzLnd3LmxhYmVsIHx8ICcnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VsZWN0OiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdzZWxlY3QnLFxuICAgICAgICAgICAgICAgIG5hbWU6IF90aGlzLmF0dHJzLnd3Lm5hbWUsXG4gICAgICAgICAgICAgICAgY2xhc3M6ICdmb3JtLWNvbnRyb2wnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBfdGhpcy5hdHRycy53dy52YWx1ZSB8fCAnJyxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogKF90aGlzLmF0dHJzLnd3LmRpc2FibGVkID09PSB0cnVlKSA/IHRydWUgOiBudWxsLFxuICAgICAgICAgICAgICAgIHJlYWRPbmx5OiAoX3RoaXMuYXR0cnMud3cucmVhZE9ubHkgPT09IHRydWUpID8gdHJ1ZSA6IG51bGwsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogX3RoaXMuYXR0cnMud3cub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogX3RoaXMuYXR0cnMud3cucGxhY2Vob2xkZXIgfHwgJ1NlbGVjdCBvbmUuJyxcbiAgICAgICAgICAgICAgICBvcHRWYWx1ZTogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvID09PSAnc3RyaW5nJyA/IG8gOiBvLnZhbHVlOyB9LFxuICAgICAgICAgICAgICAgIG9wdExhYmVsOiBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG8gPT09ICdzdHJpbmcnID8gbyA6IG8ubGFiZWw7IH0sXG4gICAgICAgICAgICAgICAgaXNTZWxlY3RlZDogZnVuY3Rpb24gKHMpIHsgcmV0dXJuIF90aGlzLnZhbHVlcy5zZWxlY3QudmFsdWUgPT09IHM7IH0sXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kZWxlZ2F0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKG5ldyBTZWxlY3RDaGFuZ2VkRXZlbnRfMS5TZWxlY3RDaGFuZ2VkRXZlbnQoX3RoaXMuYXR0cnMud3cubmFtZSwgdGFyZ2V0LnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhlbHA6IHtcbiAgICAgICAgICAgICAgICBpZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IF90aGlzLmF0dHJzLnd3LnN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgZXJyb3I6IF90aGlzLmF0dHJzLnd3LmVycm9yLFxuICAgICAgICAgICAgICAgIHdhcm5pbmc6IF90aGlzLmF0dHJzLnd3Lndhcm5pbmdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gU2VsZWN0O1xufShjb250cm9sXzEuRm9ybUNvbnRyb2wpKTtcbmV4cG9ydHMuU2VsZWN0ID0gU2VsZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2VsZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29udHJvbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29udHJvbFwiKTtcbnZhciBTZWxlY3RDaGFuZ2VkRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlbGVjdENoYW5nZWRFdmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTZWxlY3RDaGFuZ2VkRXZlbnQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFNlbGVjdENoYW5nZWRFdmVudDtcbn0oY29udHJvbF8xLkV2ZW50KSk7XG5leHBvcnRzLlNlbGVjdENoYW5nZWRFdmVudCA9IFNlbGVjdENoYW5nZWRFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNlbGVjdENoYW5nZWRFdmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBTZWxlY3RfMSA9IHJlcXVpcmUoXCIuL1NlbGVjdFwiKTtcbmV4cG9ydHMuU2VsZWN0ID0gU2VsZWN0XzEuU2VsZWN0O1xudmFyIFNlbGVjdENoYW5nZWRFdmVudF8xID0gcmVxdWlyZShcIi4vU2VsZWN0Q2hhbmdlZEV2ZW50XCIpO1xuZXhwb3J0cy5TZWxlY3RDaGFuZ2VkRXZlbnQgPSBTZWxlY3RDaGFuZ2VkRXZlbnRfMS5TZWxlY3RDaGFuZ2VkRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xuO1xudmFyIHdtbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29udHJvbC93bWxcIik7XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5yb290LmNsYXNzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeSh3bWxfMS5sYWJlbChfX19jb250ZXh0LnZhbHVlcy5sYWJlbC5pZCwgX19fY29udGV4dC52YWx1ZXMubGFiZWwudGV4dCkoX19fdmlldykpLCBfX193bWwubm9kZSgnc2VsZWN0Jywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IF9fX2NvbnRleHQudmFsdWVzLnNlbGVjdC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29uY2hhbmdlJzogX19fY29udGV4dC52YWx1ZXMuc2VsZWN0Lm9uQ2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3ZhbHVlJzogX19fY29udGV4dC52YWx1ZXMuc2VsZWN0LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Rpc2FibGVkJzogX19fY29udGV4dC52YWx1ZXMuc2VsZWN0LmRpc2FibGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JlYWRvbmx5JzogX19fY29udGV4dC52YWx1ZXMuc2VsZWN0LnJlYWRPbmx5LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuc2VsZWN0LmNsYXNzXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogX19fY29udGV4dC52YWx1ZXMuc2VsZWN0LmlkXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ29wdGlvbicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndmFsdWUnOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkaXNhYmVsZCc6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwuZG9taWZ5KF9fX2NvbnRleHQudmFsdWVzLnNlbGVjdC5wbGFjZWhvbGRlcildLCBfX192aWV3KSwgX19fd21sLm1hcChfX19jb250ZXh0LnZhbHVlcy5zZWxlY3Qub3B0aW9ucywgZnVuY3Rpb24gX21hcChvcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnb3B0aW9uJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3ZhbHVlJzogX19fY29udGV4dC52YWx1ZXMuc2VsZWN0Lm9wdFZhbHVlKG9wdCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzZWxlY3RlZCc6IF9fX2NvbnRleHQudmFsdWVzLnNlbGVjdC5pc1NlbGVjdGVkKF9fX2NvbnRleHQudmFsdWVzLnNlbGVjdC5vcHRWYWx1ZShvcHQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC5kb21pZnkoX19fY29udGV4dC52YWx1ZXMuc2VsZWN0Lm9wdExhYmVsKG9wdCkpXSwgX19fdmlldyk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIG90aGVyd2lzZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pXSwgX19fdmlldyksIF9fX3dtbC5kb21pZnkod21sXzEubWVzc2FnZShfX19jb250ZXh0LnZhbHVlcy5oZWxwLmlkLCBfX19jb250ZXh0LnZhbHVlcy5oZWxwKShfX192aWV3KSldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWxlY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB3bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBuYW1lcyA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi9uYW1lc1wiKTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9zdGFja1wiKTtcbnZhciBTdGFja0NoYW5nZWRFdmVudF8xID0gcmVxdWlyZShcIi4vU3RhY2tDaGFuZ2VkRXZlbnRcIik7XG4vKipcbiAqIFN0YWNrIGRpc3BsYXlzIGEgbGlzdCBvZiBpdGVtcyB0aGF0IGNhbiBiZSBtb2RpZmllZFxuICogYnkgcmVsZWFzaW5nIG9uZSBvciBtb3JlIGF0IGEgdGltZS5cbiAqL1xudmFyIFN0YWNrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdGFjaywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdGFjaygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gX3RoaXMuYXR0cnMud3cudGVtcGxhdGUgP1xuICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cudGVtcGxhdGUgOiB2aWV3cy5jb250ZW50O1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBpZDoge1xuICAgICAgICAgICAgICAgIHJvb3Q6ICdyb290JyxcbiAgICAgICAgICAgICAgICBhOiAnbGluaydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgIHJvb3Q6IG5hbWVzLlNUQUNLLFxuICAgICAgICAgICAgICAgIGNsb3NlOiBuYW1lcy5TVEFDS19DTE9TRSxcbiAgICAgICAgICAgICAgICBtZW1iZXI6IG5hbWVzLlNUQUNLX01FTUJFUlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGl0ZW06IHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogX3RoaXMudGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uIChpbmRleCkgeyByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZXMudmFsdWUuc3BsaWNlKE51bWJlcihpbmRleCksIDEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5maXJlKCk7XG4gICAgICAgICAgICAgICAgfTsgfSxcbiAgICAgICAgICAgICAgICBkZWNvcmF0b3I6IF90aGlzLmF0dHJzLnd3LmRlY29yYXRvciA/IF90aGlzLmF0dHJzLnd3LmRlY29yYXRvciA6IGZ1bmN0aW9uIChtKSB7IHJldHVybiBTdHJpbmcobSk7IH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWx1ZTogX3RoaXMuYXR0cnMud3cudmFsdWUgPyBfdGhpcy5hdHRycy53dy52YWx1ZSA6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogcHVzaCBhIG5ldyBtZW1iZXIgb250byB0aGUgc3RhY2suXG4gICAgICovXG4gICAgU3RhY2sucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAobSkge1xuICAgICAgICB0aGlzLnZhbHVlcy52YWx1ZS5wdXNoKG0pO1xuICAgICAgICB0aGlzLmZpcmUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBTdGFjay5wcm90b3R5cGUuZmlyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuYXR0cnMud3cub25DaGFuZ2UpXG4gICAgICAgICAgICB0aGlzLmF0dHJzLnd3Lm9uQ2hhbmdlKG5ldyBTdGFja0NoYW5nZWRFdmVudF8xLlN0YWNrQ2hhbmdlZEV2ZW50KHRoaXMuYXR0cnMud3cubmFtZSwgdGhpcy52YWx1ZXMudmFsdWUuc2xpY2UoKSkpO1xuICAgICAgICB0aGlzLnZpZXcuaW52YWxpZGF0ZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFN0YWNrO1xufSh3bWwuQ29tcG9uZW50KSk7XG5leHBvcnRzLlN0YWNrID0gU3RhY2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdGFjay5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbnRyb2xfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbnRyb2xcIik7XG4vKipcbiAqIFN0YWNrQ2hhbmdlZEV2ZW50IGlzIGdlbmVyYXRlZCB3aGVuIHRoZSB1c2VyIHJlbW92ZXMgYW4gaXRlbSBmcm9tIHRoZSBzdGFjay5cbiAqL1xudmFyIFN0YWNrQ2hhbmdlZEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdGFja0NoYW5nZWRFdmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdGFja0NoYW5nZWRFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gU3RhY2tDaGFuZ2VkRXZlbnQ7XG59KGNvbnRyb2xfMS5FdmVudCkpO1xuZXhwb3J0cy5TdGFja0NoYW5nZWRFdmVudCA9IFN0YWNrQ2hhbmdlZEV2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RhY2tDaGFuZ2VkRXZlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgU3RhY2tfMSA9IHJlcXVpcmUoXCIuL1N0YWNrXCIpO1xuZXhwb3J0cy5TdGFjayA9IFN0YWNrXzEuU3RhY2s7XG52YXIgU3RhY2tDaGFuZ2VkRXZlbnRfMSA9IHJlcXVpcmUoXCIuL1N0YWNrQ2hhbmdlZEV2ZW50XCIpO1xuZXhwb3J0cy5TdGFja0NoYW5nZWRFdmVudCA9IFN0YWNrQ2hhbmdlZEV2ZW50XzEuU3RhY2tDaGFuZ2VkRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xuO1xuZXhwb3J0cy5jb250ZW50ID0gZnVuY3Rpb24gKG0pIHsgcmV0dXJuIGZ1bmN0aW9uIChfX19jb250ZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoX19fdmlldykgeyByZXR1cm4gX19fd21sLm5vZGUoJ3NwYW4nLCB7XG4gICAgaHRtbDoge1xuICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5jbGFzcy5tZW1iZXJcbiAgICB9LFxuICAgIHdtbDoge31cbn0sIFtfX193bWwuZG9taWZ5KF9fX2NvbnRleHQudmFsdWVzLml0ZW0uZGVjb3JhdG9yKG0pKV0sIF9fX3ZpZXcpOyB9OyB9OyB9O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgndWwnLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5jbGFzcy5yb290XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLm1hcChfX19jb250ZXh0LnZhbHVlcy52YWx1ZSwgZnVuY3Rpb24gX21hcChtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ2xpJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwuZG9taWZ5KF9fX2NvbnRleHQudmFsdWVzLml0ZW0udGVtcGxhdGUobSwgaW5kZXgsIF9fX2NvbnRleHQudmFsdWVzLnZhbHVlKShfX19jb250ZXh0KShfX192aWV3KSksIF9fX3dtbC5ub2RlKCdidXR0b24nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5jbGFzcy5jbG9zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uY2xpY2snOiBfX19jb250ZXh0LnZhbHVlcy5pdGVtLmNsb3NlKGluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiXFx1MDBEN1wiKV0sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gb3RoZXJ3aXNlKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICAgICAgICAgIH0pXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhY2suanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuYW1lcyA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi9uYW1lc1wiKTtcbnZhciB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIHN3aXRjaF8xID0gcmVxdWlyZShcIi4vd21sL3N3aXRjaFwiKTtcbnZhciBTd2l0Y2hDaGFuZ2VkRXZlbnRfMSA9IHJlcXVpcmUoXCIuL1N3aXRjaENoYW5nZWRFdmVudFwiKTtcbi8qKlxuICogU3dpdGNoIGFsbG93cyB0aGUgdXNlciB0byBzZWxlY3QgYmV0d2VlbiBvbmUgb3IgdHdvIHZhbHVlcy5cbiAqL1xudmFyIFN3aXRjaCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3dpdGNoLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN3aXRjaCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgc3dpdGNoXzEuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgbGFiZWw6IG5hbWVzLlNXSVRDSCxcbiAgICAgICAgICAgICAgICBzbGlkZXI6IG5hbWVzLlNXSVRDSF9TTElERVJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbnB1dDoge1xuICAgICAgICAgICAgICAgIG5hbWU6IF90aGlzLmF0dHJzLnd3Lm5hbWUsXG4gICAgICAgICAgICAgICAgb246IF90aGlzLmF0dHJzLnd3Lm9uIHx8IGZhbHNlLFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiBfdGhpcy5hdHRycy53dy5kaXNhYmxlZCA/IHRydWUgOiBudWxsLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnZhbHVlcy5pbnB1dC5vbiA9ICFfdGhpcy52YWx1ZXMuaW5wdXQub247XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hdHRycy53dy5vbkNoYW5nZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3Lm9uQ2hhbmdlKG5ldyBTd2l0Y2hDaGFuZ2VkRXZlbnRfMS5Td2l0Y2hDaGFuZ2VkRXZlbnQoX3RoaXMudmFsdWVzLmlucHV0Lm5hbWUsIF90aGlzLnZhbHVlcy5pbnB1dC5vbikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gU3dpdGNoO1xufSh3bWxfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuU3dpdGNoID0gU3dpdGNoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3dpdGNoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29udHJvbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29udHJvbFwiKTtcbi8qKlxuICogU3dpdGNoQ2hhbmdlZEV2ZW50IHNpZ25hbHMgdGhlIHVzZXIgaGFzIGNoYW5nZWQgdGhlIHN3aXRjaC5cbiAqL1xudmFyIFN3aXRjaENoYW5nZWRFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3dpdGNoQ2hhbmdlZEV2ZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN3aXRjaENoYW5nZWRFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gU3dpdGNoQ2hhbmdlZEV2ZW50O1xufShjb250cm9sXzEuRXZlbnQpKTtcbmV4cG9ydHMuU3dpdGNoQ2hhbmdlZEV2ZW50ID0gU3dpdGNoQ2hhbmdlZEV2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3dpdGNoQ2hhbmdlZEV2ZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCdsYWJlbCcsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLmNsYXNzLmxhYmVsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ2lucHV0Jywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAndHlwZSc6IFwiY2hlY2tib3hcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogX19fY29udGV4dC52YWx1ZXMuaW5wdXQubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjaGVja2VkJzogKF9fX2NvbnRleHQudmFsdWVzLmlucHV0Lm9uIHx8IG51bGwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Rpc2FibGVkJzogX19fY29udGV4dC52YWx1ZXMuaW5wdXQuZGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb25jaGFuZ2UnOiBfX19jb250ZXh0LnZhbHVlcy5pbnB1dC5vbkNoYW5nZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpLCBfX193bWwubm9kZSgnZGl2Jywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5jbGFzcy5zbGlkZXJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN3aXRjaC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5hbWVzID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL25hbWVzXCIpO1xudmFyIHZpZXcgPSByZXF1aXJlKFwiLi93bWwvdGFic1wiKTtcbnZhciBhZnBsID0gcmVxdWlyZShcImFmcGxcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL3V0aWxcIik7XG52YXIgVGFiQ2xpY2tlZEV2ZW50XzEgPSByZXF1aXJlKFwiLi9UYWJDbGlja2VkRXZlbnRcIik7XG52YXIgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBfdW5rbm93biA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHJldHVybiBjb25zb2xlLndhcm4oXCJNaXNzaW5nIGVsZW1lbnQgd2l0aCBpZCBcIiArIGlkICsgXCIuXCIpO1xufTtcbi8qKlxuICogVGFiIHByb3ZpZGVzIGEgc2luZ2xlIHRhYiBpdGVtLlxuICpcbiAqIFdoZW4gYSB0YWIgaXMgY2xpY2tlZCwgaXQgYXR0ZW1wdHMgdG8gcmVtb3ZlIHRoZSBhY3RpdmUgY2xhc3MgZnJvbVxuICogaXQncyBzaWJsaW5ncyBhbmQgYXBwbHkgaXQgdG8gaXRzZWxmLiBUaGVyZWZvcmUgdGhlIHNpYmxpbmcgb2YgYVxuICogdGFiIHNob3VsZCBhbHdheXMgYmUgYSBUYWIuXG4gKi9cbnZhciBUYWIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhYiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXcuVGFiKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICByb290OiAncm9vdCcsXG4gICAgICAgICAgICAgICAgYTogJ2xpbmsnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICBsaTogdXRpbF8xLmNvbmNhdChuYW1lcy5UQUJTX1RBQiwgX3RoaXMuYXR0cnMud3cuYWN0aXZlID8gbmFtZXMuQUNUSVZFIDogJycpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGFiOiB7XG4gICAgICAgICAgICAgICAgdGV4dDogX3RoaXMuYXR0cnMud3cudGV4dFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5jbGlja2VkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIF90aGlzXG4gICAgICAgICAgICAgICAgLnZpZXdcbiAgICAgICAgICAgICAgICAuZmluZEJ5SWQoX3RoaXMudmFsdWVzLmlkLnJvb3QpXG4gICAgICAgICAgICAgICAgLmNoYWluKGZ1bmN0aW9uIChyb290KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IHJvb3QucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICB2YXIgdXMgPSBwYXJlbnQuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgdXNbaV0uY2xhc3NMaXN0LnJlbW92ZShuYW1lcy5BQ1RJVkUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpc1xuICAgICAgICAgICAgICAgICAgICAudmlld1xuICAgICAgICAgICAgICAgICAgICAuZmluZEJ5SWQoX3RoaXMudmFsdWVzLmlkLnJvb3QpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5jbGFzc0xpc3QuYWRkKG5hbWVzLkFDVElWRSk7IH0pXG4gICAgICAgICAgICAgICAgICAgIC5vckp1c3QoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3Vua25vd24oX3RoaXMudmFsdWVzLmlkLnJvb3QpOyB9KVxuICAgICAgICAgICAgICAgICAgICAuY2hhaW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gYWZwbC5NYXliZS5mcm9tQW55KF90aGlzLmF0dHJzLnd3Lm9uQ2xpY2spOyB9KVxuICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmKG5ldyBUYWJDbGlja2VkRXZlbnRfMS5UYWJDbGlja2VkRXZlbnQoX3RoaXMuYXR0cnMud3cubmFtZSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogY2xpY2sgdGhpcyBUYWJcbiAgICAgKi9cbiAgICBUYWIucHJvdG90eXBlLmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzXG4gICAgICAgICAgICAudmlld1xuICAgICAgICAgICAgLmZpbmRCeUlkKHRoaXMudmFsdWVzLmlkLmEpXG4gICAgICAgICAgICAuY2F0YShmdW5jdGlvbiAoKSB7IHJldHVybiBfdW5rbm93bihfdGhpcy52YWx1ZXMuaWQuYSk7IH0sIGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLmNsaWNrKCk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFRhYjtcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLlRhYiA9IFRhYjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRhYi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogVGFiQ2xpY2tlZEV2ZW50IGlzIGZpcmVkIHdoZW4gYSB1c2VyIGNsaWNrcyBvbiBhIHRhYi5cbiAqXG4gKiBJdCBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdGFiIHRoYXQgd2FzIGNsaWNrZWQuXG4gKi9cbnZhciBUYWJDbGlja2VkRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGFiQ2xpY2tlZEV2ZW50KG5hbWUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIFRhYkNsaWNrZWRFdmVudDtcbn0oKSk7XG5leHBvcnRzLlRhYkNsaWNrZWRFdmVudCA9IFRhYkNsaWNrZWRFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRhYkNsaWNrZWRFdmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5hbWVzID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL25hbWVzXCIpO1xudmFyIHZpZXcgPSByZXF1aXJlKFwiLi93bWwvdGFic1wiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vdXRpbFwiKTtcbnZhciB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xuLyoqXG4gKiBUYWJzIGFjdHMgYXMgYSBwYXJlbnQgY29udGFpbmVyIGZvciBhIGdyb3VwIG9mIFRhYi5cbiAqXG4gKiBVc2UgaXQgdG8gY3JlYXRlIGEgdGFiYmVkIG5hdmlnYXRpb24gb3IgdmlldyBmb3IgbWFpbiBsYXlvdXQsXG4gKiBzdWIgdmlld3Mgb3IgZm9ybXMgZXRjLlxuICovXG52YXIgVGFicyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFicywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJzKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3LlRhYnMoX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgY2xhc3M6IHV0aWxfMS5jb25jYXQobmFtZXMuVEFCUywgJ25hdiBuYXYtdGFicycsIF90aGlzLmF0dHJzLnd3ID8gX3RoaXMuYXR0cnMud3cuY2xhc3MgOiAnJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVGFicztcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLlRhYnMgPSBUYWJzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGFicy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xuO1xudmFyIFRhYiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFiLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnbGknLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5jbGFzcy5saVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICdpZCc6IF9fX2NvbnRleHQudmFsdWVzLmlkLnJvb3RcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ2EnLCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdocmVmJzogXCIjXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb25jbGljayc6IF9fX2NvbnRleHQuY2xpY2tlZFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdpZCc6IF9fX2NvbnRleHQudmFsdWVzLmlkLmFcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIFsoX19fY29udGV4dC52YWx1ZXMudGFiLnRleHQpID8gX19fd21sLmRvbWlmeShfX19jb250ZXh0LnZhbHVlcy50YWIudGV4dCkgOiBfX193bWwuZG9taWZ5KF9fX2NvbnRleHQuY2hpbGRyZW4pXSwgX19fdmlldyldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVGFiO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5UYWIgPSBUYWI7XG47XG52YXIgVGFicyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFicywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJzKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCd1bCcsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwuZG9taWZ5KF9fX2NvbnRleHQuY2hpbGRyZW4pXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRhYnM7XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLlRhYnMgPSBUYWJzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFicy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbnRyb2xfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbnRyb2xcIik7XG4vKipcbiAqIFRleHRDaGFuZ2VkRXZlbnRcbiAqL1xudmFyIFRleHRDaGFuZ2VkRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRleHRDaGFuZ2VkRXZlbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGV4dENoYW5nZWRFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVGV4dENoYW5nZWRFdmVudDtcbn0oY29udHJvbF8xLkV2ZW50KSk7XG5leHBvcnRzLlRleHRDaGFuZ2VkRXZlbnQgPSBUZXh0Q2hhbmdlZEV2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dENoYW5nZWRFdmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL3RleHQtZmllbGRcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL3V0aWxcIik7XG52YXIgY29udHJvbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29udHJvbFwiKTtcbnZhciBUZXh0Q2hhbmdlZEV2ZW50XzEgPSByZXF1aXJlKFwiLi9UZXh0Q2hhbmdlZEV2ZW50XCIpO1xuLyoqXG4gKiBUZXh0RmllbGRcbiAqL1xudmFyIFRleHRGaWVsZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGV4dEZpZWxkLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRleHRGaWVsZCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgICAgICBpZDogJ3Jvb3QnLFxuICAgICAgICAgICAgICAgIGNsYXNzOiB1dGlsXzEuY29uY2F0KCdmb3JtLWdyb3VwJywgX3RoaXMuYXR0cnMud3cuY2xhc3MsIF90aGlzLnN0YXRlKCkpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhlbHA6IHtcbiAgICAgICAgICAgICAgICBpZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IF90aGlzLmF0dHJzLnd3LnN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgZXJyb3I6IF90aGlzLmF0dHJzLnd3LmVycm9yLFxuICAgICAgICAgICAgICAgIHdhcm5pbmc6IF90aGlzLmF0dHJzLnd3Lndhcm5pbmdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgICAgIGlkOiBfdGhpcy5hdHRycy53dy5uYW1lLFxuICAgICAgICAgICAgICAgIHRleHQ6IF90aGlzLmF0dHJzLnd3LmxhYmVsIHx8ICcnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5wdXQ6IHtcbiAgICAgICAgICAgICAgICBpZDogJ2lucHV0JyxcbiAgICAgICAgICAgICAgICBjbGFzczogJ2Zvcm0tY29udHJvbCcsXG4gICAgICAgICAgICAgICAgbmFtZTogX3RoaXMuYXR0cnMud3cubmFtZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBfdGhpcy5hdHRycy53dy50eXBlIHx8ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogX3RoaXMuYXR0cnMud3cucGxhY2Vob2xkZXIgfHwgJycsXG4gICAgICAgICAgICAgICAgdmFsdWU6IF90aGlzLmF0dHJzLnd3LnZhbHVlIHx8ICcnLFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiAoX3RoaXMuYXR0cnMud3cuZGlzYWJsZWQgPT09IHRydWUpID8gdHJ1ZSA6IG51bGwsXG4gICAgICAgICAgICAgICAgcmVhZE9ubHk6IChfdGhpcy5hdHRycy53dy5yZWFkT25seSA9PT0gdHJ1ZSkgPyB0cnVlIDogbnVsbCxcbiAgICAgICAgICAgICAgICByb3dzOiBfdGhpcy5hdHRycy53dy5yb3dzIHx8IDEsXG4gICAgICAgICAgICAgICAgb25JbnB1dDogZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLmRlbGVnYXRlLm9uQ2hhbmdlKG5ldyBUZXh0Q2hhbmdlZEV2ZW50XzEuVGV4dENoYW5nZWRFdmVudChfdGhpcy5hdHRycy53dy5uYW1lLCBlLnRhcmdldC52YWx1ZSkpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRleHRGaWVsZDtcbn0oY29udHJvbF8xLkZvcm1Db250cm9sKSk7XG5leHBvcnRzLlRleHRGaWVsZCA9IFRleHRGaWVsZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHRGaWVsZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBUZXh0RmllbGRfMSA9IHJlcXVpcmUoXCIuL1RleHRGaWVsZFwiKTtcbmV4cG9ydHMuVGV4dEZpZWxkID0gVGV4dEZpZWxkXzEuVGV4dEZpZWxkO1xudmFyIFRleHRDaGFuZ2VkRXZlbnRfMSA9IHJlcXVpcmUoXCIuL1RleHRDaGFuZ2VkRXZlbnRcIik7XG5leHBvcnRzLlRleHRDaGFuZ2VkRXZlbnQgPSBUZXh0Q2hhbmdlZEV2ZW50XzEuVGV4dENoYW5nZWRFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG47XG52YXIgd21sXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb250cm9sL3dtbFwiKTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwuZG9taWZ5KHdtbF8xLmxhYmVsKF9fX2NvbnRleHQudmFsdWVzLmxhYmVsLmlkLCBfX19jb250ZXh0LnZhbHVlcy5sYWJlbC50ZXh0KShfX192aWV3KSksICgoX19fY29udGV4dC52YWx1ZXMuaW5wdXQucm93cyA9PT0gMSkpID8gX19fd21sLm5vZGUoJ2lucHV0Jywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IF9fX2NvbnRleHQudmFsdWVzLmlucHV0Lm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHlwZSc6IF9fX2NvbnRleHQudmFsdWVzLmlucHV0LnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAncGxhY2Vob2xkZXInOiBfX19jb250ZXh0LnZhbHVlcy5pbnB1dC5wbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICdvbmlucHV0JzogX19fY29udGV4dC52YWx1ZXMuaW5wdXQub25JbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICd2YWx1ZSc6IF9fX2NvbnRleHQudmFsdWVzLmlucHV0LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Rpc2FibGVkJzogX19fY29udGV4dC52YWx1ZXMuaW5wdXQuZGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAncmVhZG9ubHknOiBfX19jb250ZXh0LnZhbHVlcy5pbnB1dC5yZWFkT25seSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLmlucHV0LmNsYXNzXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogXCJpbnB1dFwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldykgOiBfX193bWwubm9kZSgndGV4dGFyZWEnLCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogX19fY29udGV4dC52YWx1ZXMuaW5wdXQubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwbGFjZWhvbGRlcic6IF9fX2NvbnRleHQudmFsdWVzLmlucHV0LnBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29uaW5wdXQnOiBfX19jb250ZXh0LnZhbHVlcy5pbnB1dC5vbklucHV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Rpc2FibGVkJzogX19fY29udGV4dC52YWx1ZXMuaW5wdXQuZGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAncmVhZG9ubHknOiBfX19jb250ZXh0LnZhbHVlcy5pbnB1dC5yZWFkT25seSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyb3dzJzogX19fY29udGV4dC52YWx1ZXMuaW5wdXQucm93cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLmlucHV0LmNsYXNzXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogXCJpbnB1dFwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeShfX19jb250ZXh0LnZhbHVlcy5pbnB1dC52YWx1ZSldLCBfX192aWV3KSwgX19fd21sLmRvbWlmeSh3bWxfMS5tZXNzYWdlKF9fX2NvbnRleHQudmFsdWVzLmhlbHAuaWQsIF9fX2NvbnRleHQudmFsdWVzLmhlbHApKF9fX3ZpZXcpKV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRleHQtZmllbGQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG5leHBvcnRzLmxhYmVsID0gZnVuY3Rpb24gKGlkLCB0ZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoX19fdmlldykgeyByZXR1cm4gX19fd21sLm5vZGUoJ2xhYmVsJywge1xuICAgIGh0bWw6IHtcbiAgICAgICAgJ2Zvcic6IGlkLFxuICAgICAgICAnY2xhc3MnOiBcImNvbnRyb2wtbGFiZWxcIlxuICAgIH0sXG4gICAgd21sOiB7fVxufSwgW19fX3dtbC5kb21pZnkodGV4dCldLCBfX192aWV3KTsgfTsgfTtcbjtcbmV4cG9ydHMubWVzc2FnZSA9IGZ1bmN0aW9uIChpZCwgbSkgeyByZXR1cm4gZnVuY3Rpb24gKF9fX3ZpZXcpIHsgcmV0dXJuIF9fX3dtbC5ib3goX19fd21sLmRvbWlmeShjb25zb2xlLmVycm9yKG0pKSwgKG0uc3VjY2VzcykgPyBfX193bWwubm9kZSgnc3BhbicsIHtcbiAgICBodG1sOiB7XG4gICAgICAgICdjbGFzcyc6IFwiaGVscC10ZXh0XCJcbiAgICB9LFxuICAgIHdtbDoge1xuICAgICAgICAnaWQnOiBpZFxuICAgIH1cbn0sIFtfX193bWwuZG9taWZ5KG0uc3VjY2VzcyldLCBfX192aWV3KSA6IChtLmVycm9yKSA/IF9fX3dtbC5ub2RlKCdzcGFuJywge1xuICAgIGh0bWw6IHtcbiAgICAgICAgJ2NsYXNzJzogXCJoZWxwLXRleHRcIlxuICAgIH0sXG4gICAgd21sOiB7XG4gICAgICAgICdpZCc6IGlkXG4gICAgfVxufSwgW19fX3dtbC5kb21pZnkobS5lcnJvcildLCBfX192aWV3KSA6IChtLndhcm5pbmcpID8gX19fd21sLm5vZGUoJ3NwYW4nLCB7XG4gICAgaHRtbDoge1xuICAgICAgICAnY2xhc3MnOiBcImhlbHAtdGV4dFwiXG4gICAgfSxcbiAgICB3bWw6IHtcbiAgICAgICAgJ2lkJzogaWRcbiAgICB9XG59LCBbX19fd21sLmRvbWlmeShtLndhcm5pbmcpXSwgX19fdmlldykgOiBfX193bWwubm9kZSgnc3BhbicsIHtcbiAgICBodG1sOiB7XG4gICAgICAgICdjbGFzcyc6IFwiaGVscC10ZXh0XCJcbiAgICB9LFxuICAgIHdtbDoge1xuICAgICAgICAnaWQnOiBpZFxuICAgIH1cbn0sIFtdLCBfX192aWV3KSk7IH07IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5hbWVzID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL25hbWVzXCIpO1xudmFyIEdyb3VwXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb250ZW50L0dyb3VwXCIpO1xudmFyIGFzaWRlXzEgPSByZXF1aXJlKFwiLi93bWwvYXNpZGVcIik7XG4vKipcbiAqIEFzaWRlIHByb3ZpZGVzIGEgd2lkZ2V0IGZvciBkaXNwbGF5aW5nIG5hdmlnYXRpb24gYW5kIG90aGVyIHNpZGViYXIgY29udGVudC5cbiAqXG4gKiBJdCdzIGFwaSBhbGxvd3MgZm9yIHRvZ2dsaW5nIGJldHdlZW4gaGlkZGVuIGFuZCBzaG93biBzdGF0ZXMgYXMgd2VsbCBhcyBxdWVyeWluZyB0aGVcbiAqIGN1cnJlbnQgc3RhdGUuXG4gKlxuICogVGhpcyB3aWRnZXQncyBzdHlsZSBpbnRlbnRpb25hbGx5IGdpdmVzIGl0IGEgaGlnaCB6LWluZGV4IHNvIHRoYXQgaXQgYXBwZWFycyBpbi1mcm9udFxuICogb2Ygb3RoZXIgY29udGVudC4gQWRqdXN0IHRoZSByZXNwZWN0aXZlIHN0eWxlIHZhcmlhYmxlcyB0byBjaGFuZ2UuXG4gKi9cbnZhciBBc2lkZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXNpZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXNpZGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAvKipcbiAgICAgICAgICogdmFsdWVzIGlzIGEgaGFzaCBvZiB2YWx1ZXMgdXNlZCBpbiB0aGUgdGVtcGxhdGVcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiB7XG4gICAgICAgICAgICAgICAgcm9vdDogJ2FzaWRlJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgIHJvb3Q6IG5hbWVzLkFTSURFLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IG5hbWVzLkFTSURFX0NPTlRFTlRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICd3dzpjb250ZW50J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5jb250ZW50KSA/IF90aGlzLmF0dHJzLnd3LmNvbnRlbnQgOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgYXNpZGVfMS5NYWluKF90aGlzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBc2lkZS5wcm90b3R5cGUuX2dldERyYXdlckRPTSA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuZmluZEJ5SWQodGhpcy52YWx1ZXMuaWQucm9vdCkuY2F0YShmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LCBmKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHZpc2libGUgcXVlcmllcyB3aGV0aGVyIHRoZSBEcmF3ZXIgaXMgdmlzaWJsZSBvciBub3QuXG4gICAgICovXG4gICAgQXNpZGUucHJvdG90eXBlLnZpc2libGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5fZ2V0RHJhd2VyRE9NKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLmNsYXNzTGlzdC5jb250YWlucyhuYW1lcy5ISURERU4pOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGhpZGUgdGhlIGRyYXdlci5cbiAgICAgKi9cbiAgICBBc2lkZS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZSgpKVxuICAgICAgICAgICAgdGhpcy5fZ2V0RHJhd2VyRE9NKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLmNsYXNzTGlzdC5hZGQobmFtZXMuSElEREVOKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBzaG93RHJhd2VyIHNob3dzIHRoZSBkcmF3ZXJcbiAgICAgKi9cbiAgICBBc2lkZS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpc2libGUoKSlcbiAgICAgICAgICAgIHRoaXMuX2dldERyYXdlckRPTShmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5jbGFzc0xpc3QucmVtb3ZlKG5hbWVzLkhJRERFTik7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogdG9nZ2xlIHRoZSB2aXNpYmlsaXR5IG9mIHRoaXMgRHJhd2VyXG4gICAgICovXG4gICAgQXNpZGUucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZ2V0RHJhd2VyRE9NKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLmNsYXNzTGlzdC50b2dnbGUobmFtZXMuSElEREVOKTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQXNpZGU7XG59KEdyb3VwXzEuR3JvdXApKTtcbmV4cG9ydHMuQXNpZGUgPSBBc2lkZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFzaWRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5jbGFzcy5yb290XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2lkJzogX19fY29udGV4dC52YWx1ZXMuaWQucm9vdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgnZGl2Jywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5jbGFzcy5jb250ZW50XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbKF9fX2NvbnRleHQudmFsdWVzLmNvbnRlbnQpID8gX19fd21sLmRvbWlmeShfX19jb250ZXh0LnZhbHVlcy5jb250ZW50LnJlbmRlcigpKSA6IF9fX3dtbC5kb21pZnkoX19fY29udGV4dC5jaGlsZHJlbildLCBfX192aWV3KV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzaWRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgR3JvdXBfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbnRlbnQvR3JvdXBcIik7XG52YXIgbmFtZXMgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vbmFtZXNcIik7XG52YXIgZHJhd2VyXzEgPSByZXF1aXJlKFwiLi93bWwvZHJhd2VyXCIpO1xuO1xuLyoqXG4gKiBEcmF3ZXIgcHJvdmlkZXMgYSAyIGNvbHVtbiBhcHBsaWNhdGlvbiBsYXlvdXQgd2l0aCB0aGUgZmlyc3QgdHlwaWNhbGx5IHVzZWQgYXMgbmF2YWlnYXRpb25cbiAqIGFuZCB0aGUgc2Vjb25kIG1haW4gYXBwbGljYXRpb24gY29udGVudC5cbiAqXG4gKiBgYGB3bWxcbiAqXG4gKiAgPERyYXdlclxuICogICB3bWw6aWQ9XCJsYXlvdXRcIlxuICogICBjb250ZW50PXt7dGhpcy5nZXRDb250ZW50KCl9fSAvPlxuICpcbiAqIGBgYFxuICovXG52YXIgRHJhd2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEcmF3ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRHJhd2VyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyBkcmF3ZXJfMS5NYWluKF90aGlzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHZhbHVlcyBpcyBhIGhhc2ggb2YgdmFsdWVzIHVzZWQgaW4gdGhlIHRlbXBsYXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICByb290OiAnY29udGVudCcsXG4gICAgICAgICAgICAgICAgZHJhd2VyOiAnZHJhd2VyJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgcm9vdDogbmFtZXMuRFJBV0VSLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgRFJBV0VSOiAnd3c6ZHJhd2VyJyxcbiAgICAgICAgICAgICAgICBDT05URU5UOiAnd3c6Y29udGVudCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhc2lkZToge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5kcmF3ZXIpID8gX3RoaXMuYXR0cnMud3cuZHJhd2VyIDogbnVsbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5jb250ZW50KSA/IF90aGlzLmF0dHJzLnd3LmNvbnRlbnQgOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRHJhd2VyLnByb3RvdHlwZS5fZ2V0QXNpZGUgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LmZpbmRCeUlkKHRoaXMudmFsdWVzLmlkLmRyYXdlcikuY2F0YShmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LCBmKTtcbiAgICB9O1xuICAgIERyYXdlci5wcm90b3R5cGUuX2NvbWJpbmUgPSBmdW5jdGlvbiAoY2xhc3Nlcykge1xuICAgICAgICByZXR1cm4gY2xhc3Nlcy5qb2luKCcgJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBkcmF3ZXJWaXNpYmxlIHF1ZXJpZXMgd2hldGhlciB0aGUgQXNpZGUgaXMgdmlzaWJsZSBvciBub3QuXG4gICAgICovXG4gICAgRHJhd2VyLnByb3RvdHlwZS5kcmF3ZXJWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QXNpZGUoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEudmlzaWJsZSgpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGhpZGVEcmF3ZXIgaGlkZXMgdGhlIGRyYXdlci5cbiAgICAgKi9cbiAgICBEcmF3ZXIucHJvdG90eXBlLmhpZGVEcmF3ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRBc2lkZShmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS5oaWRlKCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogc2hvd0RyYXdlciBzaG93cyB0aGUgZHJhd2VyXG4gICAgICovXG4gICAgRHJhd2VyLnByb3RvdHlwZS5zaG93RHJhd2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QXNpZGUoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEuc2hvdygpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHRvZ2dsZSB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgQXNpZGUuXG4gICAgICovXG4gICAgRHJhd2VyLnByb3RvdHlwZS50b2dnbGVEcmF3ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRBc2lkZShmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS50b2dnbGUoKTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gRHJhd2VyO1xufShHcm91cF8xLkdyb3VwKSk7XG5leHBvcnRzLkRyYXdlciA9IERyYXdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURyYXdlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIEFzaWRlXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9sYXlvdXQvYXNpZGUvQXNpZGVcIik7XG47XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5jbGFzcy5yb290XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2lkJzogX19fY29udGV4dC52YWx1ZXMuaWQucm9vdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KEFzaWRlXzEuQXNpZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogX19fY29udGV4dC52YWx1ZXMuaWQuZHJhd2VyXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnY29udGVudCc6IF9fX2NvbnRleHQudmFsdWVzLmFzaWRlLmNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KSwgKF9fX2NvbnRleHQuY29udGVudCkgPyBfX193bWwuZG9taWZ5KF9fX2NvbnRleHQuY29udGVudCkgOiAoX19fY29udGV4dC52YWx1ZXMuY29udGVudCkgPyBfX193bWwuZG9taWZ5KF9fX2NvbnRleHQudmFsdWVzLmNvbnRlbnQucmVuZGVyKCkpIDogX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRyYXdlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL3ZpZXdzXCIpO1xudmFyIHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgRnJhZ21lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZyYWdtZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZyYWdtZW50KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKG51bGwpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEZyYWdtZW50LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGZyYWcuYXBwZW5kQ2hpbGQoYyk7IH0pO1xuICAgICAgICByZXR1cm4gZnJhZztcbiAgICB9O1xuICAgIHJldHVybiBGcmFnbWVudDtcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLkZyYWdtZW50ID0gRnJhZ21lbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GcmFnbWVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnZnJhZ21lbnQnLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpZXdzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmFtZXMgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vbmFtZXNcIik7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvZ3JpZFwiKTtcbnZhciB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi91dGlsXCIpO1xuO1xuLyoqXG4gKiBHcmlkXG4gKi9cbnZhciBHcmlkID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHcmlkLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdyaWQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLkdyaWQoX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgIHJvb3Q6IHV0aWxfMS5jb25jYXQobmFtZXMuR1JJRCwgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmNsYXNzKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LmNsYXNzIDogJycpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEdyaWQ7XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5HcmlkID0gR3JpZDtcbnZhciBSb3cgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJvdywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSb3coKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLlJvdyhfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgcm9vdDogdXRpbF8xLmNvbmNhdChuYW1lcy5HUklEX1JPVywgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmNsYXNzKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LmNsYXNzIDogJycpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJvdztcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLlJvdyA9IFJvdztcbnZhciBDb2x1bW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbHVtbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb2x1bW4oKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLkNvbHVtbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgcm9vdDogX3RoaXMuYXR0cnMud3cgPyB1dGlsXzEuY29uY2F0KF90aGlzLmF0dHJzLnd3LnNpemUgP1xuICAgICAgICAgICAgICAgICAgICBcImNvbC1tZC1cIiArIF90aGlzLmF0dHJzLnd3LnNpemUgOiAnY29sLW1kLTEyJywgX3RoaXMuYXR0cnMud3cuY2xhc3MpIDogJ2NvbC1tZC0xMidcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ29sdW1uO1xufSh3bWxfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuQ29sdW1uID0gQ29sdW1uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3JpZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIEdyaWQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdyaWQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gR3JpZChjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnc2VjdGlvbicsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLmNsYXNzLnJvb3RcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwuZG9taWZ5KF9fX2NvbnRleHQuY2hpbGRyZW4pXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEdyaWQ7XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLkdyaWQgPSBHcmlkO1xuO1xudmFyIFJvdyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUm93LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJvdyhjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnZGl2Jywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuY2xhc3Mucm9vdFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC5kb21pZnkoX19fY29udGV4dC5jaGlsZHJlbildLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUm93O1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5Sb3cgPSBSb3c7XG47XG52YXIgQ29sdW1uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb2x1bW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29sdW1uKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5jbGFzcy5yb290XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDb2x1bW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLkNvbHVtbiA9IENvbHVtbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyaWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB3bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9saXN0LWdyb3VwXCIpO1xudmFyIG5hbWVzID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL25hbWVzXCIpO1xuLyoqXG4gKiBMaXN0R3JvdXAgaXMgdXNlZCB0byBjcmVhdGUgYSB2ZXJ0aWNhbCBsaXN0IG9mIGNvbnRlbnQuXG4gKlxuICogQ2hpbGRyZW4gbXVzdCBiZSBMaXN0R3JvdXBJdGVtcy5cbiAqL1xudmFyIExpc3RHcm91cCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGlzdEdyb3VwLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpc3RHcm91cCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgICAgICBjbGFzczogbmFtZXMuTElTVF9HUk9VUFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBMaXN0R3JvdXA7XG59KHdtbC5Db21wb25lbnQpKTtcbmV4cG9ydHMuTGlzdEdyb3VwID0gTGlzdEdyb3VwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGlzdEdyb3VwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvbGlzdC1ncm91cC1pdGVtXCIpO1xudmFyIHdtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIG5hbWVzID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL25hbWVzXCIpO1xuLyoqXG4gKiBMaXN0R3JvdXBJdGVtXG4gKi9cbnZhciBMaXN0R3JvdXBJdGVtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMaXN0R3JvdXBJdGVtLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpc3RHcm91cEl0ZW0oKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgY2xhc3M6IG5hbWVzLkxJU1RfR1JPVVBfSVRFTVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBMaXN0R3JvdXBJdGVtO1xufSh3bWwuQ29tcG9uZW50KSk7XG5leHBvcnRzLkxpc3RHcm91cEl0ZW0gPSBMaXN0R3JvdXBJdGVtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGlzdEdyb3VwSXRlbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBMaXN0R3JvdXBfMSA9IHJlcXVpcmUoXCIuL0xpc3RHcm91cFwiKTtcbmV4cG9ydHMuTGlzdEdyb3VwID0gTGlzdEdyb3VwXzEuTGlzdEdyb3VwO1xudmFyIExpc3RHcm91cEl0ZW1fMSA9IHJlcXVpcmUoXCIuL0xpc3RHcm91cEl0ZW1cIik7XG5leHBvcnRzLkxpc3RHcm91cEl0ZW0gPSBMaXN0R3JvdXBJdGVtXzEuTGlzdEdyb3VwSXRlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCdsaScsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwuZG9taWZ5KF9fX2NvbnRleHQuY2hpbGRyZW4pXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGlzdC1ncm91cC1pdGVtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCd1bCcsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwuZG9taWZ5KF9fX2NvbnRleHQuY2hpbGRyZW4pXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGlzdC1ncm91cC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL21haW5cIik7XG52YXIgbmFtZXMgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vbmFtZXNcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL3V0aWxcIik7XG52YXIgR3JvdXBfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbnRlbnQvR3JvdXBcIik7XG4vKipcbiAqIE1haW4gcHJvdmlkZXMgYSBjb250YWluZXIgZm9yIHRoZSBtYWluIGNvbnRlbnQgb2YgYW4gYXBwbGljYXRpb24uXG4gKi9cbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgIHJvb3Q6IHV0aWxfMS5jb25jYXQobmFtZXMuTUFJTl9WSUVXLCBuYW1lcy5QVVNIQUJMRSwgX3RoaXMuYXR0cnMud3cgPyBfdGhpcy5hdHRycy53dy5jbGFzcyA6ICcnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShHcm91cF8xLkdyb3VwKSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWFpbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnZGl2Jywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuY2xhc3Mucm9vdFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC5kb21pZnkoX19fY29udGV4dC5jaGlsZHJlbildLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWluLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmFtZXMgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vbmFtZXNcIik7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvcGFuZWxcIik7XG52YXIgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vdXRpbFwiKTtcbnZhciBQYW5lbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGFuZWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGFuZWwoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLlBhbmVsKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICByb290OiB1dGlsXzEuY29uY2F0KG5hbWVzLlBBTkVMLCBfdGhpcy5hdHRycy53dyA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LnN0eWxlIDogbmFtZXMuREVGQVVMVCwgX3RoaXMuYXR0cnMud3cgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5jbGFzcyA6ICcnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBQYW5lbDtcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLlBhbmVsID0gUGFuZWw7XG52YXIgSGVhZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhIZWFkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSGVhZGVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5IZWFkZXIoX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgIHJvb3Q6IHV0aWxfMS5jb25jYXQobmFtZXMuUEFORUxfSEVBREVSLCBfdGhpcy5hdHRycy53dyA/IF90aGlzLmF0dHJzLnd3LmNsYXNzIDogJycpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEhlYWRlcjtcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLkhlYWRlciA9IEhlYWRlcjtcbnZhciBCb2R5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCb2R5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJvZHkoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLkJvZHkoX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgIHJvb3Q6IHV0aWxfMS5jb25jYXQobmFtZXMuUEFORUxfQk9EWSwgX3RoaXMuYXR0cnMud3cgPyBfdGhpcy5hdHRycy53dy5jbGFzcyA6ICcnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBCb2R5O1xufSh3bWxfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuQm9keSA9IEJvZHk7XG52YXIgRm9vdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGb290ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRm9vdGVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5Gb290ZXIoX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgIHJvb3Q6IHV0aWxfMS5jb25jYXQobmFtZXMuUEFORUxfRk9PVEVSLCBfdGhpcy5hdHRycy53dyA/IF90aGlzLmF0dHJzLnd3LmNsYXNzIDogJycpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEZvb3Rlcjtcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLkZvb3RlciA9IEZvb3Rlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBhbmVsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgUGFuZWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBhbmVsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBhbmVsKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5jbGFzcy5yb290XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBQYW5lbDtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuUGFuZWwgPSBQYW5lbDtcbjtcbnZhciBIZWFkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEhlYWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIZWFkZXIoY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLmNsYXNzLnJvb3RcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwuZG9taWZ5KF9fX2NvbnRleHQuY2hpbGRyZW4pXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEhlYWRlcjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuSGVhZGVyID0gSGVhZGVyO1xuO1xudmFyIEJvZHkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJvZHksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQm9keShjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnZGl2Jywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuY2xhc3Mucm9vdFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC5kb21pZnkoX19fY29udGV4dC5jaGlsZHJlbildLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQm9keTtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuQm9keSA9IEJvZHk7XG47XG52YXIgRm9vdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGb290ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRm9vdGVyKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5jbGFzcy5yb290XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBGb290ZXI7XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLkZvb3RlciA9IEZvb3Rlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhbmVsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmFtZXMgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vbmFtZXNcIik7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvZGl2aWRlclwiKTtcbnZhciB3bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbi8qKlxuICogRGl2aWRlclxuICovXG52YXIgRGl2aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGl2aWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEaXZpZGVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICByb290OiBuYW1lcy5NRU5VX0RJVklERVJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gRGl2aWRlcjtcbn0od21sLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5EaXZpZGVyID0gRGl2aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURpdmlkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuYW1lcyA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi9uYW1lc1wiKTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9oZWFkZXJcIik7XG52YXIgd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL3V0aWxcIik7XG4vKipcbiAqIEhlYWRlclxuICovXG52YXIgSGVhZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhIZWFkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSGVhZGVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICByb290OiB1dGlsXzEuY29uY2F0KG5hbWVzLk1FTlVfSEVBREVSLCBfdGhpcy5hdHRycy53dyA/IF90aGlzLmF0dHJzLnd3LmNsYXNzIDogJycpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGV4dDogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnRleHQpID9cbiAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy50ZXh0IDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBIZWFkZXI7XG59KHdtbC5Db21wb25lbnQpKTtcbmV4cG9ydHMuSGVhZGVyID0gSGVhZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SGVhZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgbmFtZXMgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vbmFtZXNcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL3V0aWxcIik7XG52YXIgbWVudV8xID0gcmVxdWlyZShcIi4vd21sL21lbnVcIik7XG4vKipcbiAqIE1lbnVcbiAqL1xudmFyIE1lbnUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lbnUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVudSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgbWVudV8xLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBpZDoge1xuICAgICAgICAgICAgICAgIHJvb3Q6ICdyb290JyxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6ICdtZW51J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgcm9vdDogdXRpbF8xLmNvbmNhdChuYW1lcy5NRU5VLCAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuY2xhc3MpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuY2xhc3MgOiAnJywgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmhpZGRlbikgP1xuICAgICAgICAgICAgICAgICAgICBuYW1lcy5ISURERU4gOiAnJylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250ZW50OiBfdGhpcy5jaGlsZHJlbixcbiAgICAgICAgICAgIGNsaWNrOiB7XG4gICAgICAgICAgICAgICAgaGlkZU9uQ2xpY2s6IChfdGhpcy5hdHRycy53dyAmJiAoX3RoaXMuYXR0cnMud3cuaGlkZU9uQ2xpY2sgIT0gbnVsbCkpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuaGlkZU9uQ2xpY2sgOiB0cnVlLFxuICAgICAgICAgICAgICAgIGhpZGVPbkV4dGVybmFsQ2xpY2s6IChfdGhpcy5hdHRycy53dyAmJiAoX3RoaXMuYXR0cnMud3cuaGlkZU9uRXh0ZXJuYWxDbGljayAhPSBudWxsKSkgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5oaWRlT25FeHRlcm5hbENsaWNrIDogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGlzSGlkZGVuXG4gICAgICovXG4gICAgTWVudS5wcm90b3R5cGUuaXNIaWRkZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuZmluZEJ5SWQodGhpcy52YWx1ZXMuaWQucm9vdClcbiAgICAgICAgICAgIC5jYXRhKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9LCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5jbGFzc0xpc3QuY29udGFpbnMobmFtZXMuSElEREVOKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBoaWRlIHRoZSBtZW51LlxuICAgICAqL1xuICAgIE1lbnUucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmlldy5maW5kQnlJZCh0aGlzLnZhbHVlcy5pZC5yb290KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUuY2xhc3NMaXN0LmFkZChuYW1lcy5ISURERU4pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBzaG93IHRoaXMgbWVudS5cbiAgICAgKi9cbiAgICBNZW51LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnZpZXcuZmluZEJ5SWQodGhpcy52YWx1ZXMuaWQucm9vdClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlLmNsYXNzTGlzdC5yZW1vdmUobmFtZXMuSElEREVOKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogdG9nZ2xlIHRoaXMgbWVudSdzIHZpc2liaWxpdHlcbiAgICAgKi9cbiAgICBNZW51LnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmlldy5maW5kQnlJZCh0aGlzLnZhbHVlcy5pZC5yb290KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUuY2xhc3NMaXN0LnRvZ2dsZShuYW1lcy5ISURERU4pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBzZXRDb250ZW50IG9mIHRoaXMgbWVudS5cbiAgICAgKi9cbiAgICBNZW51LnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24gKHZpZXcpIHtcbiAgICAgICAgdGhpcy52YWx1ZXMuY29udGVudCA9IFt2aWV3LnJlbmRlcigpXTtcbiAgICAgICAgdGhpcy52aWV3LmludmFsaWRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBNZW51LnByb3RvdHlwZS5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXNcbiAgICAgICAgICAgIC52aWV3XG4gICAgICAgICAgICAuZmluZEJ5SWQodGhpcy52YWx1ZXMuaWQucm9vdClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgICAgICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyhyb290KSlcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIF90aGlzKTtcbiAgICAgICAgICAgIGlmICgoIXJvb3QuY29udGFpbnMoZS50YXJnZXQpKSAmJiBfdGhpcy52YWx1ZXMuY2xpY2suaGlkZU9uRXh0ZXJuYWxDbGljaylcbiAgICAgICAgICAgICAgICBfdGhpcy5oaWRlKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWVudS5wcm90b3R5cGUucmVuZGVyZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gTWVudTtcbn0od21sLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5NZW51ID0gTWVudTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1lbnUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuYW1lcyA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi9uYW1lc1wiKTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9tZW51LWl0ZW1cIik7XG52YXIgd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL3V0aWxcIik7XG52YXIgTWVudUl0ZW1DbGlja2VkRXZlbnRfMSA9IHJlcXVpcmUoXCIuL01lbnVJdGVtQ2xpY2tlZEV2ZW50XCIpO1xuLyoqXG4gKiBNZW51SXRlbVxuICovXG52YXIgTWVudUl0ZW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lbnVJdGVtLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lbnVJdGVtKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICByb290OiAncm9vdCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgIHJvb3Q6IHV0aWxfMS5jb25jYXQobmFtZXMuTUVOVV9JVEVNLCAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuZGlzYWJsZWQpID9cbiAgICAgICAgICAgICAgICAgICAgbmFtZXMuRElTQUJMRUQgOiBudWxsKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRleHQ6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy50ZXh0KSA/XG4gICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cudGV4dCA6IG51bGwsXG4gICAgICAgICAgICBjbGlja2VkOiBmdW5jdGlvbiAoKSB7IHJldHVybiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cub25DbGljaykgP1xuICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3Lm9uQ2xpY2sobmV3IE1lbnVJdGVtQ2xpY2tlZEV2ZW50XzEuTWVudUl0ZW1DbGlja2VkRXZlbnQoX3RoaXMuYXR0cnMud3cubmFtZSkpIDogZnVuY3Rpb24gKCkgeyB9OyB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1lbnVJdGVtO1xufSh3bWwuQ29tcG9uZW50KSk7XG5leHBvcnRzLk1lbnVJdGVtID0gTWVudUl0ZW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NZW51SXRlbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogTWVudUl0ZW1DbGlja2VkRXZlbnQgaW5kaWNhdGVzIGEgbWVudSBpdGVtIGhhcyBiZWVuIGNsaWNrZWQuXG4gKi9cbnZhciBNZW51SXRlbUNsaWNrZWRFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZW51SXRlbUNsaWNrZWRFdmVudChuYW1lKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgfVxuICAgIHJldHVybiBNZW51SXRlbUNsaWNrZWRFdmVudDtcbn0oKSk7XG5leHBvcnRzLk1lbnVJdGVtQ2xpY2tlZEV2ZW50ID0gTWVudUl0ZW1DbGlja2VkRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NZW51SXRlbUNsaWNrZWRFdmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHdtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIG5hbWVzID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL25hbWVzXCIpO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2J1dHRvbi1tZW51XCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi91dGlsXCIpO1xuLyoqXG4gKiBCdXR0b25NZW51XG4gKi9cbnZhciBCdXR0b25NZW51ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCdXR0b25NZW51LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJ1dHRvbk1lbnUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy5fYnV0dG9uVGVtcGxhdGUgPSBfdGhpcy5hdHRycy53dy5idXR0b25UZW1wbGF0ZSA/XG4gICAgICAgICAgICBfdGhpcy5hdHRycy53dy5idXR0b25UZW1wbGF0ZSA6IHZpZXdzLmJ1dHRvbjtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICByb290OiAncm9vdCcsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiAnbWVudSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgY2xhc3M6IHV0aWxfMS5jb25jYXQobmFtZXMuQlVUVE9OX01FTlUsIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5jbGFzcykgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5jbGFzcyA6ICcnKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJ1dHRvbjoge1xuICAgICAgICAgICAgICAgIHRleHQ6IF90aGlzLmF0dHJzLnd3LnRleHQgPyBfdGhpcy5hdHRycy53dy50ZXh0IDogJycsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IF90aGlzLl9idXR0b25UZW1wbGF0ZSxcbiAgICAgICAgICAgICAgICBjbGFzczogbmFtZXMuQlVUVE9OX01FTlVfQlVUVE9OLFxuICAgICAgICAgICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uICgpIHsgX3RoaXMudmlldy5maW5kQnlJZChfdGhpcy52YWx1ZXMubWVudS5pZCkubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLnRvZ2dsZSgpOyB9KTsgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lbnU6IHtcbiAgICAgICAgICAgICAgICBpZDogJ21lbnUnLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IF90aGlzLmF0dHJzLnd3LmNvbnRlbnQgPyBfdGhpcy5hdHRycy53dy5jb250ZW50IDogX3RoaXMuY2hpbGRyZW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBoaWRlIHRoZSBtZW51LlxuICAgICAqL1xuICAgIEJ1dHRvbk1lbnUucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmlldy5maW5kQnlJZCh0aGlzLnZhbHVlcy5tZW51LmlkKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5oaWRlKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHNob3cgdGhlIG1lbnUuXG4gICAgICovXG4gICAgQnV0dG9uTWVudS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy52aWV3LmZpbmRCeUlkKHRoaXMudmFsdWVzLm1lbnUuaWQpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLnNob3coKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogdG9nZ2xlIHRoZSBtZW51LlxuICAgICAqL1xuICAgIEJ1dHRvbk1lbnUucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy52aWV3LmZpbmRCeUlkKHRoaXMudmFsdWVzLm1lbnUuaWQpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLnRvZ2dsZSgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBzZXRDb250ZW50IG9mIHRoaXMgbWVudS5cbiAgICAgKi9cbiAgICBCdXR0b25NZW51LnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24gKHZpZXcpIHtcbiAgICAgICAgdGhpcy52YWx1ZXMubWVudS5jb250ZW50ID0gW3ZpZXcucmVuZGVyKCldO1xuICAgICAgICB0aGlzLnZpZXcuaW52YWxpZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBCdXR0b25NZW51O1xufSh3bWwuQ29tcG9uZW50KSk7XG5leHBvcnRzLkJ1dHRvbk1lbnUgPSBCdXR0b25NZW51O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QnV0dG9uTWVudS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBCdXR0b25NZW51XzEgPSByZXF1aXJlKFwiLi9CdXR0b25NZW51XCIpO1xuZXhwb3J0cy5CdXR0b25NZW51ID0gQnV0dG9uTWVudV8xLkJ1dHRvbk1lbnU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIE1lbnVfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL21lbnUvTWVudVwiKTtcbjtcbmV4cG9ydHMuYnV0dG9uID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKF9fX2NvbnRleHQpIHsgcmV0dXJuIGZ1bmN0aW9uIChfX192aWV3KSB7IHJldHVybiBfX193bWwubm9kZSgnYnV0dG9uJywge1xuICAgIGh0bWw6IHtcbiAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuYnV0dG9uLmNsYXNzLFxuICAgICAgICAndHlwZSc6IFwiYnV0dG9uXCIsXG4gICAgICAgICdvbmNsaWNrJzogX19fY29udGV4dC52YWx1ZXMuYnV0dG9uLm9uQ2xpY2tcbiAgICB9LFxuICAgIHdtbDoge31cbn0sIFtfX193bWwuZG9taWZ5KF9fX2NvbnRleHQudmFsdWVzLmJ1dHRvbi50ZXh0KV0sIF9fX3ZpZXcpOyB9OyB9OyB9O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnZGl2Jywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMucm9vdC5jbGFzc1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC5kb21pZnkoX19fY29udGV4dC52YWx1ZXMuYnV0dG9uLnRlbXBsYXRlKCkoX19fY29udGV4dCkoX19fdmlldykpLCBfX193bWwud2lkZ2V0KE1lbnVfMS5NZW51LCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdpZCc6IF9fX2NvbnRleHQudmFsdWVzLm1lbnUuaWRcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdoaWRkZW4nOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeShfX19jb250ZXh0LnZhbHVlcy5tZW51LmNvbnRlbnQpXSwgX19fdmlldyldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idXR0b24tbWVudS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBEaXZpZGVyXzEgPSByZXF1aXJlKFwiLi9EaXZpZGVyXCIpO1xuZXhwb3J0cy5EaXZpZGVyID0gRGl2aWRlcl8xLkRpdmlkZXI7XG52YXIgSGVhZGVyXzEgPSByZXF1aXJlKFwiLi9IZWFkZXJcIik7XG5leHBvcnRzLkhlYWRlciA9IEhlYWRlcl8xLkhlYWRlcjtcbnZhciBNZW51SXRlbV8xID0gcmVxdWlyZShcIi4vTWVudUl0ZW1cIik7XG5leHBvcnRzLk1lbnVJdGVtID0gTWVudUl0ZW1fMS5NZW51SXRlbTtcbnZhciBNZW51SXRlbUNsaWNrZWRFdmVudF8xID0gcmVxdWlyZShcIi4vTWVudUl0ZW1DbGlja2VkRXZlbnRcIik7XG5leHBvcnRzLk1lbnVJdGVtQ2xpY2tlZEV2ZW50ID0gTWVudUl0ZW1DbGlja2VkRXZlbnRfMS5NZW51SXRlbUNsaWNrZWRFdmVudDtcbnZhciBNZW51XzEgPSByZXF1aXJlKFwiLi9NZW51XCIpO1xuZXhwb3J0cy5NZW51ID0gTWVudV8xLk1lbnU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnbGknLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5jbGFzcy5yb290XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGl2aWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnbGknLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5jbGFzcy5yb290XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbKF9fX2NvbnRleHQudmFsdWVzLnRleHQpID8gX19fd21sLmRvbWlmeShfX19jb250ZXh0LnZhbHVlcy50ZXh0KSA6IF9fX3dtbC5kb21pZnkoX19fY29udGV4dC5jaGlsZHJlbildLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWFkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ2xpJywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuY2xhc3Mucm9vdCxcbiAgICAgICAgICAgICAgICAgICAgJ29uY2xpY2snOiBfX19jb250ZXh0LnZhbHVlcy5jbGlja2VkXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbKF9fX2NvbnRleHQudmFsdWVzLnRleHQpID8gX19fd21sLmRvbWlmeShfX19jb250ZXh0LnZhbHVlcy50ZXh0KSA6IF9fX3dtbC5kb21pZnkoX19fY29udGV4dC5jaGlsZHJlbildLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZW51LWl0ZW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ3VsJywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuY2xhc3Mucm9vdFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC5kb21pZnkoX19fY29udGV4dC52YWx1ZXMuY29udGVudCldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZW51LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmFtZXMgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vbmFtZXNcIik7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvYnJlYWRjcnVtYnNcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL3V0aWxcIik7XG52YXIgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbjtcbi8qKlxuICogQnJlYWRDcnVtYlxuICovXG52YXIgQnJlYWRDcnVtYnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJyZWFkQ3J1bWJzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJyZWFkQ3J1bWJzKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5CcmVhZENydW1icyhfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgcm9vdDogdXRpbF8xLmNvbmNhdChuYW1lcy5CUkVBRF9DUlVNQlMsIF90aGlzLmF0dHJzLnd3ID8gX3RoaXMuYXR0cnMud3cuY2xhc3MgOiAnJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQnJlYWRDcnVtYnM7XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5CcmVhZENydW1icyA9IEJyZWFkQ3J1bWJzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QnJlYWRDcnVtYnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuYW1lcyA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi9uYW1lc1wiKTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9icmVhZGNydW1ic1wiKTtcbnZhciB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xuLyoqXG4gKiBJdGVtIGZvciBicmVhZGNydW1iIGxpc3RzLlxuICovXG52YXIgSXRlbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSXRlbSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJdGVtKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5JdGVtKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICByb290OiBuYW1lcy5CUkVBRF9DUlVNQlNfSVRFTVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBJdGVtO1xufSh3bWxfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuSXRlbSA9IEl0ZW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JdGVtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG47XG52YXIgQnJlYWRDcnVtYnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJyZWFkQ3J1bWJzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJyZWFkQ3J1bWJzKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCdvbCcsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLmNsYXNzLnJvb3RcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwuZG9taWZ5KF9fX2NvbnRleHQuY2hpbGRyZW4pXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEJyZWFkQ3J1bWJzO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5CcmVhZENydW1icyA9IEJyZWFkQ3J1bWJzO1xuO1xudmFyIEl0ZW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEl0ZW0sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSXRlbShjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnbGknLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5jbGFzcy5yb290XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBJdGVtO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5JdGVtID0gSXRlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyZWFkY3J1bWJzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgbmFtZXMgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vbmFtZXNcIik7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvbGlua1wiKTtcbnZhciBMaW5rQ2xpY2tlZEV2ZW50XzEgPSByZXF1aXJlKFwiLi9MaW5rQ2xpY2tlZEV2ZW50XCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi91dGlsXCIpO1xuLyoqXG4gKiBMaW5rIGdlbmVyYXRlcyBhbiA8YT4gZWxlbWVudC5cbiAqL1xudmFyIExpbmsgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpbmssIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGluaygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBuYW1lIGFzc2lnbmVkIHRvIHRoaXMgTGluay5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLm5hbWUgPSAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cubmFtZSkgP1xuICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cubmFtZSA6ICcnO1xuICAgICAgICAvKipcbiAgICAgICAgICogdGl0bGUgYXNzaWduZWQgdG8gdGhpcyBMaW5rLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMudGl0bGUgPSAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cudGl0bGUpID9cbiAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LnRpdGxlIDogJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBocmVmIGFzc2lnbmVkIHRvIHRoaXMgbGlua1xuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuaHJlZiA9IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5ocmVmKSA/XG4gICAgICAgICAgICBfdGhpcy5hdHRycy53dy5ocmVmIDogJyc7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiB7XG4gICAgICAgICAgICAgICAgcm9vdDogJ3Jvb3QnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICByb290OiB1dGlsXzEuY29uY2F0KG5hbWVzLk5BVl9MSU5LLCBfdGhpcy5hdHRycy53dyA/IF90aGlzLmF0dHJzLnd3LmNsYXNzIDogJycsIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5hY3RpdmUpID9cbiAgICAgICAgICAgICAgICAgICAgbmFtZXMuQUNUSVZFIDogJycpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICAgIHRpdGxlOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cudGl0bGUpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cudGl0bGUgOiBudWxsLFxuICAgICAgICAgICAgICAgIG5hbWU6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5uYW1lKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3Lm5hbWUgOiBudWxsLFxuICAgICAgICAgICAgICAgIGhyZWY6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5ocmVmKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LmhyZWYgOiAnIycsXG4gICAgICAgICAgICAgICAgYWN0aXZlOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuYWN0aXZlKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LmFjdGl2ZSA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHRleHQ6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy50ZXh0KSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LnRleHQgOiAnJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5jbGlja2VkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5hdHRycy53dykge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLmF0dHJzLnd3LCBuYW1lXzEgPSBfYS5uYW1lLCBocmVmID0gX2EuaHJlZiwgb25DbGljayA9IF9hLm9uQ2xpY2s7XG4gICAgICAgICAgICAgICAgaWYgKCFocmVmKVxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgaWYgKG9uQ2xpY2spXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2sobmV3IExpbmtDbGlja2VkRXZlbnRfMS5MaW5rQ2xpY2tlZEV2ZW50KG5hbWVfMSwgaHJlZikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAgKiBhY3RpdmF0ZSB0aGlzIG5hdiBsaXN0IEl0ZW0uXG4gICAgICAqL1xuICAgIExpbmsucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnZpZXcuZmluZEJ5SWQodGhpcy52YWx1ZXMuaWQucm9vdClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHcpIHtcbiAgICAgICAgICAgIHcuY2xhc3NMaXN0LnJlbW92ZShuYW1lcy5BQ1RJVkUpO1xuICAgICAgICAgICAgdy5jbGFzc0xpc3QuYWRkKG5hbWVzLkFDVElWRSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogaW5hY3RpdmF0ZSB0aGlzIG5hdiBsaXN0IGl0ZW0uXG4gICAgICovXG4gICAgTGluay5wcm90b3R5cGUuaW5hY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy52aWV3LmZpbmRCeUlkKHRoaXMudmFsdWVzLmlkLnJvb3QpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LmNsYXNzTGlzdC5yZW1vdmUobmFtZXMuQUNUSVZFKTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gTGluaztcbn0od21sLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5MaW5rID0gTGluaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxpbmsuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIExpbmtDbGlja2VkRXZlbnQgaW5kaWNhdGVzIGEgbGluayBoYXMgYmVlbiBjbGlja2VkLlxuICovXG52YXIgTGlua0NsaWNrZWRFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMaW5rQ2xpY2tlZEV2ZW50KG5hbWUsIGhyZWYpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5ocmVmID0gaHJlZjtcbiAgICB9XG4gICAgcmV0dXJuIExpbmtDbGlja2VkRXZlbnQ7XG59KCkpO1xuZXhwb3J0cy5MaW5rQ2xpY2tlZEV2ZW50ID0gTGlua0NsaWNrZWRFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxpbmtDbGlja2VkRXZlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTGlua18xID0gcmVxdWlyZShcIi4vTGlua1wiKTtcbmV4cG9ydHMuTGluayA9IExpbmtfMS5MaW5rO1xudmFyIExpbmtDbGlja2VkRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0xpbmtDbGlja2VkRXZlbnRcIik7XG5leHBvcnRzLkxpbmtDbGlja2VkRXZlbnQgPSBMaW5rQ2xpY2tlZEV2ZW50XzEuTGlua0NsaWNrZWRFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCdhJywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuY2xhc3Mucm9vdCxcbiAgICAgICAgICAgICAgICAgICAgJ2hyZWYnOiBfX19jb250ZXh0LnZhbHVlcy5hLmhyZWYsXG4gICAgICAgICAgICAgICAgICAgICd0aXRsZSc6IF9fX2NvbnRleHQudmFsdWVzLmEudGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICdvbmNsaWNrJzogX19fY29udGV4dC5jbGlja2VkXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbKF9fX2NvbnRleHQudmFsdWVzLmEudGV4dCkgPyBfX193bWwuZG9taWZ5KF9fX2NvbnRleHQudmFsdWVzLmEudGV4dCkgOiBfX193bWwuZG9taWZ5KF9fX2NvbnRleHQuY2hpbGRyZW4pXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGluay5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5hbWVzID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL25hbWVzXCIpO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2hlYWRlclwiKTtcbnZhciB3bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vdXRpbFwiKTtcbi8qKlxuICogSGVhZGVyIGNhbiBiZSB1c2VkIHRvIGRpc3BsYXkgbm9uLWNsaWNrYWJsZSBoZWFkaW5nIHRleHQgaW4gYSBuYXYgbGlzdC5cbiAqL1xudmFyIEhlYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSGVhZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhlYWRlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGl0ZW06IHtcbiAgICAgICAgICAgICAgICBjbGFzczogJydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzcGFuOiB7XG4gICAgICAgICAgICAgICAgY2xhc3M6IHV0aWxfMS5jb25jYXQobmFtZXMuTkFWX01FTlVfSEVBREVSLCBfdGhpcy5hdHRycy53dyA/IF90aGlzLmF0dHJzLnd3LmNsYXNzIDogJycpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGV4dDogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnRleHQpID9cbiAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy50ZXh0IDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBIZWFkZXI7XG59KHdtbC5Db21wb25lbnQpKTtcbmV4cG9ydHMuSGVhZGVyID0gSGVhZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SGVhZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmFtZXMgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vbmFtZXNcIik7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvaXRlbVwiKTtcbnZhciB3bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vdXRpbFwiKTtcbi8qKlxuICogSXRlbSB3cmFwcyBjb250ZW50IGluIGEgbmF2aWdhdGlvbiBsaXN0LlxuICpcbiAqIEl0ZW1zIHNob3VsZCBub3QgaGF2ZSBhbnkgc2libGluZ3MgdGhhdCBhcmUgbm90IG90aGVyIEl0ZW1zLlxuICovXG52YXIgSXRlbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSXRlbSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJdGVtKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICByb290OiAncm9vdCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgIHJvb3Q6IHV0aWxfMS5jb25jYXQobmFtZXMuTkFWX01FTlVfSVRFTSwgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmFjdGl2ZSkgPyBuYW1lcy5BQ1RJVkUgOiBudWxsKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRleHQ6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy50ZXh0KSA/XG4gICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cudGV4dCA6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBhY3RpdmF0ZSB0aGlzIG5hdiBsaXN0IEl0ZW0uXG4gICAgICovXG4gICAgSXRlbS5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmlldy5maW5kQnlJZCh0aGlzLnZhbHVlcy5pZC5yb290KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodykge1xuICAgICAgICAgICAgdy5jbGFzc0xpc3QucmVtb3ZlKG5hbWVzLkFDVElWRSk7XG4gICAgICAgICAgICB3LmNsYXNzTGlzdC5hZGQobmFtZXMuQUNUSVZFKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBpbmFjdGl2YXRlIHRoaXMgbmF2IGxpc3QgaXRlbS5cbiAgICAgKi9cbiAgICBJdGVtLnByb3RvdHlwZS5pbmFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnZpZXcuZmluZEJ5SWQodGhpcy52YWx1ZXMuaWQucm9vdClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcuY2xhc3NMaXN0LnJlbW92ZShuYW1lcy5BQ1RJVkUpOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBJdGVtO1xufSh3bWwuQ29tcG9uZW50KSk7XG5leHBvcnRzLkl0ZW0gPSBJdGVtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SXRlbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogSXRlbUNsaWNrZWRFdmVudCBpcyBmaXJlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiBhbiBpdGVtIGluXG4gKiBhIG5hdiBsaXN0LlxuICovXG52YXIgSXRlbUNsaWNrZWRFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJdGVtQ2xpY2tlZEV2ZW50KG5hbWUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIEl0ZW1DbGlja2VkRXZlbnQ7XG59KCkpO1xuZXhwb3J0cy5JdGVtQ2xpY2tlZEV2ZW50ID0gSXRlbUNsaWNrZWRFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUl0ZW1DbGlja2VkRXZlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBsaW5rID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvbmF2L2xpbmtcIik7XG52YXIgbmFtZXMgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vbmFtZXNcIik7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvbGlua1wiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vdXRpbFwiKTtcbi8qKlxuICogTGluayBwcm92aWRlcyBhIGxpbmsgZW50cnkgaW50byBhIG5hdiBtZW51LlxuICovXG52YXIgTGluayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGluaywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMaW5rKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6IHsgcm9vdDogJycgfSxcbiAgICAgICAgICAgIGNsYXNzOiB7IHJvb3Q6ICcnIH0sXG4gICAgICAgICAgICBpdGVtOiB7XG4gICAgICAgICAgICAgICAgY2xhc3M6IHV0aWxfMS5jb25jYXQobmFtZXMuTkFWX01FTlVfSVRFTSwgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmFjdGl2ZSkgPyBuYW1lcy5BQ1RJVkUgOiAnJylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgICAgY2xhc3M6IHV0aWxfMS5jb25jYXQoKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmFjdGl2ZSkgP1xuICAgICAgICAgICAgICAgICAgICBuYW1lcy5BQ1RJVkUgOiAnJyksXG4gICAgICAgICAgICAgICAgdGl0bGU6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy50aXRsZSkgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy50aXRsZSA6ICcnLFxuICAgICAgICAgICAgICAgIG5hbWU6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5uYW1lKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3Lm5hbWUgOiAnJyxcbiAgICAgICAgICAgICAgICBocmVmOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuaHJlZikgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5ocmVmIDogJyMnLFxuICAgICAgICAgICAgICAgIGFjdGl2ZTogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmFjdGl2ZSkgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5hY3RpdmUgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0ZXh0OiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cudGV4dCkgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy50ZXh0IDogJycsXG4gICAgICAgICAgICAgICAgb25DbGljazogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm9uQ2xpY2spID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cub25DbGljayA6IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTGluaztcbn0obGluay5MaW5rKSk7XG5leHBvcnRzLkxpbmsgPSBMaW5rO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGluay5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5hbWVzID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL25hbWVzXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vdXRpbFwiKTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9tZW51XCIpO1xudmFyIHdtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xuLyoqXG4gKiBNZW51IG9mIG5hdmlnYXRpb24gbGlua3MuXG4gKi9cbnZhciBNZW51ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZW51LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lbnUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgIHJvb3Q6IHV0aWwuY29uY2F0KG5hbWVzLk5BVl9NRU5VLCBfdGhpcy5hdHRycy53dyA/IF90aGlzLmF0dHJzLnd3LmNsYXNzIDogJycpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1lbnU7XG59KHdtbC5Db21wb25lbnQpKTtcbmV4cG9ydHMuTWVudSA9IE1lbnU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NZW51LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvc3ViLW1lbnVcIik7XG52YXIgTWVudV8xID0gcmVxdWlyZShcIi4vTWVudVwiKTtcbi8qKlxuICogU3ViTWVudSBpcyB1c2VkIGZvciBuZXN0ZWQgbWVudXMuXG4gKi9cbnZhciBTdWJNZW51ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJNZW51LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1Yk1lbnUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBTdWJNZW51O1xufShNZW51XzEuTWVudSkpO1xuZXhwb3J0cy5TdWJNZW51ID0gU3ViTWVudTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1Yk1lbnUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgSXRlbV8xID0gcmVxdWlyZShcIi4vSXRlbVwiKTtcbmV4cG9ydHMuSXRlbSA9IEl0ZW1fMS5JdGVtO1xudmFyIEl0ZW1DbGlja2VkRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0l0ZW1DbGlja2VkRXZlbnRcIik7XG5leHBvcnRzLkl0ZW1DbGlja2VkRXZlbnQgPSBJdGVtQ2xpY2tlZEV2ZW50XzEuSXRlbUNsaWNrZWRFdmVudDtcbnZhciBNZW51XzEgPSByZXF1aXJlKFwiLi9NZW51XCIpO1xuZXhwb3J0cy5NZW51ID0gTWVudV8xLk1lbnU7XG52YXIgU3ViTWVudV8xID0gcmVxdWlyZShcIi4vU3ViTWVudVwiKTtcbmV4cG9ydHMuU3ViTWVudSA9IFN1Yk1lbnVfMS5TdWJNZW51O1xudmFyIEhlYWRlcl8xID0gcmVxdWlyZShcIi4vSGVhZGVyXCIpO1xuZXhwb3J0cy5IZWFkZXIgPSBIZWFkZXJfMS5IZWFkZXI7XG52YXIgTGlua18xID0gcmVxdWlyZShcIi4vTGlua1wiKTtcbmV4cG9ydHMuTGluayA9IExpbmtfMS5MaW5rO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBJdGVtXzEgPSByZXF1aXJlKFwiLi4vSXRlbVwiKTtcbjtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLndpZGdldChJdGVtXzEuSXRlbSwge1xuICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuaXRlbS5jbGFzc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgnc3BhbicsIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuc3Bhbi5jbGFzc1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgWyhfX19jb250ZXh0LnZhbHVlcy50ZXh0KSA/IF9fX3dtbC5kb21pZnkoX19fY29udGV4dC52YWx1ZXMudGV4dCkgOiBfX193bWwuZG9taWZ5KF9fX2NvbnRleHQuY2hpbGRyZW4pXSwgX19fdmlldyldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWFkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ2xpJywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuY2xhc3Mucm9vdFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgWyhfX19jb250ZXh0LnZhbHVlcy50ZXh0KSA/IF9fX3dtbC5kb21pZnkoX19fY29udGV4dC52YWx1ZXMudGV4dCkgOiBfX193bWwuZG9taWZ5KF9fX2NvbnRleHQuY2hpbGRyZW4pXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXRlbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIGxpbmtfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL25hdi9saW5rXCIpO1xuO1xuO1xudmFyIEl0ZW1fMSA9IHJlcXVpcmUoXCIuLi9JdGVtXCIpO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwud2lkZ2V0KEl0ZW1fMS5JdGVtLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5pdGVtLmNsYXNzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQobGlua18xLkxpbmssIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5hLmNsYXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBfX19jb250ZXh0LnZhbHVlcy5hLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGl0bGUnOiBfX19jb250ZXh0LnZhbHVlcy5hLnRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2hyZWYnOiBfX19jb250ZXh0LnZhbHVlcy5hLmhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IF9fX2NvbnRleHQudmFsdWVzLmEudGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhY3RpdmUnOiBfX19jb250ZXh0LnZhbHVlcy5hLmFjdGl2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvbkNsaWNrJzogX19fY29udGV4dC52YWx1ZXMuYS5vbkNsaWNrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKV0sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGluay5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgndWwnLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5jbGFzcy5yb290XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lbnUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbjtcbnZhciBJdGVtXzEgPSByZXF1aXJlKFwiLi4vSXRlbVwiKTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLndpZGdldChJdGVtXzEuSXRlbSwge1xuICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgndWwnLCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLmNsYXNzLnJvb3RcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtfX193bWwuZG9taWZ5KF9fX2NvbnRleHQuY2hpbGRyZW4pXSwgX19fdmlldyldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWItbWVudS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQ2VsbENsaWNrZWRFdmVudCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgd2hpdGVzcGFjZSBvZiBhIGNlbGwgaXMgY2xpY2tlZC5cbiAqL1xudmFyIENlbGxDbGlja2VkRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2VsbENsaWNrZWRFdmVudCh2YWx1ZSwgbmFtZSwgaW5kZXgsIHJvdykge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5yb3cgPSByb3c7XG4gICAgfVxuICAgIHJldHVybiBDZWxsQ2xpY2tlZEV2ZW50O1xufSgpKTtcbmV4cG9ydHMuQ2VsbENsaWNrZWRFdmVudCA9IENlbGxDbGlja2VkRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DZWxsQ2xpY2tlZEV2ZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBIZWFkaW5nQ2xpY2tlZCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb25cbiAqIG9uZSBvZiB0aGUgY29sdW1uIGhlYWRpbmdzLlxuICovXG52YXIgSGVhZGluZ0NsaWNrZWRFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIZWFkaW5nQ2xpY2tlZEV2ZW50KG5hbWUsIGZpZWxkKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbiAgICB9XG4gICAgcmV0dXJuIEhlYWRpbmdDbGlja2VkRXZlbnQ7XG59KCkpO1xuZXhwb3J0cy5IZWFkaW5nQ2xpY2tlZEV2ZW50ID0gSGVhZGluZ0NsaWNrZWRFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUhlYWRpbmdDbGlja2VkRXZlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFJvd0NsaWNrZWRFdmVudCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gd2hpdGVzcGFjZSBpblxuICogdGhlIHJvdyBvZiBhIHRhYmxlLlxuICovXG52YXIgUm93Q2xpY2tlZEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJvd0NsaWNrZWRFdmVudCh2YWx1ZSwgaW5kZXgsIGRhdGEpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIHJldHVybiBSb3dDbGlja2VkRXZlbnQ7XG59KCkpO1xuZXhwb3J0cy5Sb3dDbGlja2VkRXZlbnQgPSBSb3dDbGlja2VkRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Sb3dDbGlja2VkRXZlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBSb3dDbGlja2VkRXZlbnRfMSA9IHJlcXVpcmUoXCIuL1Jvd0NsaWNrZWRFdmVudFwiKTtcbi8qKlxuICogUm93U2VsZWN0ZWRFdmVudCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgY2hlY2tib3ggKGlmIGRpc3BsYXllZCkgaXMgY2xpY2tlZFxuICogb24gZm9yIGEgcm93LlxuICovXG52YXIgUm93U2VsZWN0ZWRFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUm93U2VsZWN0ZWRFdmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSb3dTZWxlY3RlZEV2ZW50KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBSb3dTZWxlY3RlZEV2ZW50O1xufShSb3dDbGlja2VkRXZlbnRfMS5Sb3dDbGlja2VkRXZlbnQpKTtcbmV4cG9ydHMuUm93U2VsZWN0ZWRFdmVudCA9IFJvd1NlbGVjdGVkRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Sb3dTZWxlY3RlZEV2ZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmFtZXMgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vbmFtZXNcIik7XG52YXIgdmlldyA9IHJlcXVpcmUoXCIuL3dtbC90YWJsZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vdXRpbFwiKTtcbnZhciB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIHByb3BlcnR5X3NlZWtfMSA9IHJlcXVpcmUoXCJwcm9wZXJ0eS1zZWVrXCIpO1xudmFyIEFTQ19BUlJPVyA9ICdcXHUyMWU3JztcbnZhciBERVNDX0FSUk9XID0gJ1xcdTIxZTknO1xuZXhwb3J0cy5kYXRlU29ydCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIG5hID0gbmV3IERhdGUoYSkuZ2V0VGltZSgpO1xuICAgIHZhciBuYiA9IG5ldyBEYXRlKGIpLmdldFRpbWUoKTtcbiAgICByZXR1cm4gbmEgPiBuYiA/IC0xIDogbmEgPCBuYiA/IDEgOiAwO1xufTtcbmV4cG9ydHMuc3RyaW5nU29ydCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGxhID0gU3RyaW5nKGEpLnJlcGxhY2UoL1xccysvLCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgbGIgPSBTdHJpbmcoYikucmVwbGFjZSgvXFxzKy8sICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiAobGEgPiBsYikgPyAtMSA6IChsYSA8IGxiKSA/IDEgOiAwO1xufTtcbmV4cG9ydHMubmF0dXJhbFNvcnQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIGlmIChhID09PSB2b2lkIDApIHsgYSA9ICcnOyB9XG4gICAgaWYgKGIgPT09IHZvaWQgMCkgeyBiID0gJyc7IH1cbiAgICAvL1NvdXJjZTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80MzQwMjI3L3NvcnQtbWl4ZWQtYWxwaGEtbnVtZXJpYy1hcnJheVxuICAgIHZhciByZUEgPSAvW15hLXpBLVpdL2c7XG4gICAgdmFyIHJlTiA9IC9bXjAtOV0vZztcbiAgICB2YXIgQUludCA9IHBhcnNlSW50KGEsIDEwKTtcbiAgICB2YXIgQkludCA9IHBhcnNlSW50KGIsIDEwKTtcbiAgICBpZiAoaXNOYU4oQUludCkgJiYgaXNOYU4oQkludCkpIHtcbiAgICAgICAgdmFyIGFBID0gYS5yZXBsYWNlKHJlQSwgJycpO1xuICAgICAgICB2YXIgYkEgPSBiLnJlcGxhY2UocmVBLCAnJyk7XG4gICAgICAgIGlmIChhQSA9PT0gYkEpIHtcbiAgICAgICAgICAgIHZhciBhTiA9IHBhcnNlSW50KGEucmVwbGFjZShyZU4sICcnKSwgMTApO1xuICAgICAgICAgICAgdmFyIGJOID0gcGFyc2VJbnQoYi5yZXBsYWNlKHJlTiwgJycpLCAxMCk7XG4gICAgICAgICAgICByZXR1cm4gYU4gPT09IGJOID8gMCA6IGFOID4gYk4gPyAtMSA6IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYUEgPiBiQSA/IC0xIDogMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc05hTihBSW50KSkge1xuICAgICAgICByZXR1cm4gLTE7IC8vdG8gbWFrZSBhbHBoYW51bWVyaWMgc29ydCBmaXJzdCByZXR1cm4gLTEgaGVyZVxuICAgIH1cbiAgICBlbHNlIGlmIChpc05hTihCSW50KSkge1xuICAgICAgICByZXR1cm4gMTsgLy90byBtYWtlIGFscGhhbnVtZXJpYyBzb3J0IGZpcnN0IHJldHVybiAxIGhlcmVcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBBSW50ID4gQkludCA/IC0xIDogMTtcbiAgICB9XG59O1xuZXhwb3J0cy5udW1iZXJTb3J0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgbmEgPSBwYXJzZUZsb2F0KGEpO1xuICAgIHZhciBuYiA9IHBhcnNlRmxvYXQoYik7XG4gICAgbmEgPSAoaXNOYU4oYSkpID8gLUluZmluaXR5IDogYTtcbiAgICBuYiA9IChpc05hTihiKSkgPyAtSW5maW5pdHkgOiBiO1xuICAgIHJldHVybiAobmEgPiBuYikgPyAtMSA6IChuYSA8IG5iKSA/IDEgOiAwO1xufTtcbnZhciBEZWZhdWx0VGFibGVNb2RlbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWZhdWx0VGFibGVNb2RlbCh0YWJsZSkge1xuICAgICAgICB0aGlzLnRhYmxlID0gdGFibGU7XG4gICAgfVxuICAgIERlZmF1bHRUYWJsZU1vZGVsLnByb3RvdHlwZS5hbGxTZWxlY3RlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBEZWZhdWx0VGFibGVNb2RlbC5wcm90b3R5cGUuY2VsbENsaWNrZWQgPSBmdW5jdGlvbiAoX2UpIHsgfTtcbiAgICBEZWZhdWx0VGFibGVNb2RlbC5wcm90b3R5cGUuaGVhZGluZ0NsaWNrZWQgPSBmdW5jdGlvbiAoX2UpIHsgfTtcbiAgICBEZWZhdWx0VGFibGVNb2RlbC5wcm90b3R5cGUucm93Q2xpY2tlZCA9IGZ1bmN0aW9uIChfZSkgeyB9O1xuICAgIERlZmF1bHRUYWJsZU1vZGVsLnByb3RvdHlwZS5yb3dTZWxlY3RlZCA9IGZ1bmN0aW9uIChfZSkgeyB9O1xuICAgIHJldHVybiBEZWZhdWx0VGFibGVNb2RlbDtcbn0oKSk7XG5leHBvcnRzLkRlZmF1bHRUYWJsZU1vZGVsID0gRGVmYXVsdFRhYmxlTW9kZWw7XG52YXIgU29ydFRhYmxlTW9kZWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNvcnRUYWJsZU1vZGVsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNvcnRUYWJsZU1vZGVsKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFNvcnRUYWJsZU1vZGVsLnByb3RvdHlwZS5oZWFkaW5nQ2xpY2tlZCA9IGZ1bmN0aW9uIChlKSB7IHRoaXMudGFibGUuc29ydChlLm5hbWUpOyB9O1xuICAgIHJldHVybiBTb3J0VGFibGVNb2RlbDtcbn0oRGVmYXVsdFRhYmxlTW9kZWwpKTtcbmV4cG9ydHMuU29ydFRhYmxlTW9kZWwgPSBTb3J0VGFibGVNb2RlbDtcbi8qKlxuICogVGFibGUgcHJvdmlkZXMgYSBzbWFydGVyIGh0bWwgdGFibGUuXG4gKi9cbnZhciBUYWJsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vcmlnaW5hbERhdGEgPSBfdGhpcy5hdHRycy53dy5kYXRhO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXcuVGFibGUoX3RoaXMpO1xuICAgICAgICBfdGhpcy5tb2RlbCA9IF90aGlzLmF0dHJzLnd3Lm1vZGVsID9cbiAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3Lm1vZGVsIDpcbiAgICAgICAgICAgIG5ldyBTb3J0VGFibGVNb2RlbChfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiB7XG4gICAgICAgICAgICAgICAgcm9vdDogJ3Jvb3QnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgcm9vdDogdXRpbF8xLmNvbmNhdChuYW1lcy5UQUJMRSwgX3RoaXMuYXR0cnMud3cuY2xhc3MpLFxuICAgICAgICAgICAgICAgIHJvdzogX3RoaXMuYXR0cnMud3cucm93Q2xhc3MgfHwgJycsXG4gICAgICAgICAgICAgICAgY2VsbDogX3RoaXMuYXR0cnMud3cuY2VsbENsYXNzIHx8ICcnLFxuICAgICAgICAgICAgICAgIGhlYWRpbmc6IF90aGlzLmF0dHJzLnd3LmhlYWRpbmdDbGFzcyB8fCAnJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyYWdtZW50OiB7XG4gICAgICAgICAgICAgICAgZW1wdHk6IF90aGlzLmF0dHJzLnd3LmVtcHR5XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIHNlbGVjdGFibGU6IF90aGlzLmF0dHJzLnd3LnNlbGVjdGFibGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzb3J0ZWRPbjogJycsXG4gICAgICAgICAgICBkYXRhOiBfdGhpcy5vcmlnaW5hbERhdGEuc2xpY2UoKSxcbiAgICAgICAgICAgIGZpZWxkczogX3RoaXMuYXR0cnMud3cuZmllbGRzLFxuICAgICAgICAgICAgYXJyb3c6ICcnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVGFibGUucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgZmllbGRzID0gdGhpcy5hdHRycy53dyA/IHRoaXMuYXR0cnMud3cuZmllbGRzID8gdGhpcy5hdHRycy53dy5maWVsZHMgOiBbXSA6IFtdO1xuICAgICAgICB2YXIgZmllbGQgPSBmaWVsZHMucmVkdWNlKGZ1bmN0aW9uIChwLCBjKSB7IHJldHVybiBwID8gcCA6IChjLm5hbWUgPT09IG5hbWUgPyBjIDogbnVsbCk7IH0pO1xuICAgICAgICB2YXIgc29ydE9uO1xuICAgICAgICB2YXIgc3RyYXRlZ3k7XG4gICAgICAgIGlmICghZmllbGQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUYWJsZSNzb3J0OiB1bmtub3duIGZpZWxkICdcIiArIG5hbWUgKyBcIidcIik7XG4gICAgICAgIHNvcnRPbiA9IGZpZWxkLnNvcnRBcyB8fCBuYW1lO1xuICAgICAgICBzdHJhdGVneSA9IGZpZWxkLnN0cmF0ZWd5IHx8IGV4cG9ydHMuc3RyaW5nU29ydDtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVzLnNvcnRlZE9uID09PSBuYW1lKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5kYXRhID0gdGhpcy52YWx1ZXMuZGF0YS5yZXZlcnNlKCk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5hcnJvdyA9ICh0aGlzLnZhbHVlcy5hcnJvdyA9PT0gQVNDX0FSUk9XKSA/IERFU0NfQVJST1cgOiBBU0NfQVJST1c7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5hcnJvdyA9IERFU0NfQVJST1c7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5kYXRhID0gdGhpc1xuICAgICAgICAgICAgICAgIC5vcmlnaW5hbERhdGFcbiAgICAgICAgICAgICAgICAuc2xpY2UoKVxuICAgICAgICAgICAgICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBzdHJhdGVneShwcm9wZXJ0eV9zZWVrXzEuZ2V0KHNvcnRPbiwgYSksIHByb3BlcnR5X3NlZWtfMS5nZXQoc29ydE9uLCBiKSk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWVzLnNvcnRlZE9uID0gbmFtZTtcbiAgICAgICAgdGhpcy52aWV3LmludmFsaWRhdGUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHVwZGF0ZSB0aGUgZGF0YSB0aGUgdGFibGUgZGlzcGxheXNcbiAgICAgKi9cbiAgICBUYWJsZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5vcmlnaW5hbERhdGEgPSBkYXRhLnNsaWNlKCk7XG4gICAgICAgIHRoaXMudmFsdWVzLmRhdGEgPSBkYXRhLnNsaWNlKCk7XG4gICAgICAgICh0aGlzLnZhbHVlcy5zb3J0ZWRPbiA9PT0gJycpID8gdGhpcy52aWV3LmludmFsaWRhdGUoKSA6IHRoaXMuc29ydCh0aGlzLnZhbHVlcy5zb3J0ZWRPbik7XG4gICAgfTtcbiAgICByZXR1cm4gVGFibGU7XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5UYWJsZSA9IFRhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbjtcbnZhciBuYW1lcyA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi9uYW1lc1wiKTtcbjtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vdXRpbFwiKTtcbjtcbnZhciBDZWxsQ2xpY2tlZEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vQ2VsbENsaWNrZWRFdmVudFwiKTtcbjtcbnZhciBSb3dDbGlja2VkRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9Sb3dDbGlja2VkRXZlbnRcIik7XG47XG52YXIgUm93U2VsZWN0ZWRFdmVudF8xID0gcmVxdWlyZShcIi4uL1Jvd1NlbGVjdGVkRXZlbnRcIik7XG47XG52YXIgSGVhZGluZ0NsaWNrZWRFdmVudF8xID0gcmVxdWlyZShcIi4uL0hlYWRpbmdDbGlja2VkRXZlbnRcIik7XG47XG52YXIgcHJvcGVydHlfc2Vla18xID0gcmVxdWlyZShcInByb3BlcnR5LXNlZWtcIik7XG47XG52YXIgRnJhZ21lbnRfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2xheW91dC9mcmFnbWVudC9GcmFnbWVudFwiKTtcbjtcbmV4cG9ydHMuYWxsU2VsZWN0ZWRDaGVja2JveCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChfX19jb250ZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoX19fdmlldykgeyByZXR1cm4gX19fd21sLm5vZGUoJ3RoJywge1xuICAgIGh0bWw6IHt9LFxuICAgIHdtbDoge31cbn0sIFtfX193bWwubm9kZSgnaW5wdXQnLCB7XG4gICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICd0eXBlJzogXCJjaGVja2JveFwiLFxuICAgICAgICAgICAgJ29uY2xpY2snOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfX19jb250ZXh0Lm1vZGVsLmFsbFNlbGVjdGVkKCk7IH1cbiAgICAgICAgfSxcbiAgICAgICAgd21sOiB7fVxuICAgIH0sIFtdLCBfX192aWV3KV0sIF9fX3ZpZXcpOyB9OyB9OyB9O1xuO1xuZXhwb3J0cy5oZWFkaW5ncyA9IGZ1bmN0aW9uIChmaWVsZHMpIHsgcmV0dXJuIGZ1bmN0aW9uIChfX19jb250ZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoX19fdmlldykgeyByZXR1cm4gX19fd21sLm1hcChmaWVsZHMsIGZ1bmN0aW9uIF9tYXAoZmllbGQpIHtcbiAgICByZXR1cm4gKGZpZWxkLnNvcnRBcykgPyBfX193bWwubm9kZSgndGgnLCB7XG4gICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICdjbGFzcyc6IHV0aWxfMS5jb25jYXQoX19fY29udGV4dC52YWx1ZXMuY2xhc3MuaGVhZGluZywgKChfX19jb250ZXh0LnZhbHVlcy5zb3J0ZWRPbiA9PT0gZmllbGQubmFtZSkpID8gbmFtZXMuQUNUSVZFIDogXCJcIiksXG4gICAgICAgICAgICAnb25jbGljayc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fX2NvbnRleHQubW9kZWwuaGVhZGluZ0NsaWNrZWQobmV3IEhlYWRpbmdDbGlja2VkRXZlbnRfMS5IZWFkaW5nQ2xpY2tlZEV2ZW50KGZpZWxkLm5hbWUsIGZpZWxkKSk7IH1cbiAgICAgICAgfSxcbiAgICAgICAgd21sOiB7fVxuICAgIH0sIFtfX193bWwuZG9taWZ5KGZpZWxkLmhlYWRpbmcpLCAoKF9fX2NvbnRleHQudmFsdWVzLnNvcnRlZE9uID09PSBmaWVsZC5uYW1lKSkgPyBfX193bWwuZG9taWZ5KF9fX2NvbnRleHQudmFsdWVzLmFycm93KSA6IF9fX3dtbC5kb21pZnkoXCJcIildLCBfX192aWV3KSA6IF9fX3dtbC5ub2RlKCd0aCcsIHtcbiAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgJ2NsYXNzJzogdXRpbF8xLmNvbmNhdChfX19jb250ZXh0LnZhbHVlcy5jbGFzcy5oZWFkaW5nLCAoKF9fX2NvbnRleHQudmFsdWVzLnNvcnRlZE9uID09PSBmaWVsZC5uYW1lKSkgPyBuYW1lcy5BQ1RJVkUgOiBcIlwiKSxcbiAgICAgICAgICAgICdvbmNsaWNrJzogZnVuY3Rpb24gKCkgeyByZXR1cm4gX19fY29udGV4dC5tb2RlbC5oZWFkaW5nQ2xpY2tlZChuZXcgSGVhZGluZ0NsaWNrZWRFdmVudF8xLkhlYWRpbmdDbGlja2VkRXZlbnQoZmllbGQubmFtZSwgZmllbGQpKTsgfVxuICAgICAgICB9LFxuICAgICAgICB3bWw6IHt9XG4gICAgfSwgW19fX3dtbC5kb21pZnkoZmllbGQuaGVhZGluZyksIF9fX3dtbC5kb21pZnkoKChfX19jb250ZXh0LnZhbHVlcy5zb3J0ZWRPbiA9PT0gZmllbGQubmFtZSkpID8gX19fY29udGV4dC52YWx1ZXMuYXJyb3cgOiBcIlwiKV0sIF9fX3ZpZXcpO1xufSwgZnVuY3Rpb24gb3RoZXJ3aXNlKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG59KTsgfTsgfTsgfTtcbjtcbmV4cG9ydHMudGhlYWQgPSBmdW5jdGlvbiAoZmllbGRzKSB7IHJldHVybiBmdW5jdGlvbiAoX19fY29udGV4dCkgeyByZXR1cm4gZnVuY3Rpb24gKF9fX3ZpZXcpIHsgcmV0dXJuIF9fX3dtbC5ub2RlKCd0cicsIHtcbiAgICBodG1sOiB7fSxcbiAgICB3bWw6IHt9XG59LCBbKF9fX2NvbnRleHQudmFsdWVzLm9wdGlvbnMuc2VsZWN0YWJsZSkgPyBfX193bWwuYm94KF9fX3dtbC5kb21pZnkoZXhwb3J0cy5hbGxTZWxlY3RlZENoZWNrYm94KCkoX19fY29udGV4dCkoX19fdmlldykpLCBfX193bWwuZG9taWZ5KGV4cG9ydHMuaGVhZGluZ3MoZmllbGRzKShfX19jb250ZXh0KShfX192aWV3KSkpIDogX19fd21sLmRvbWlmeShleHBvcnRzLmhlYWRpbmdzKGZpZWxkcykoX19fY29udGV4dCkoX19fdmlldykpXSwgX19fdmlldyk7IH07IH07IH07XG47XG5leHBvcnRzLnJvd1NlbGVjdENoZWNrYm94ID0gZnVuY3Rpb24gKHJvdywgaW5kZXgsIGRhdGEpIHsgcmV0dXJuIGZ1bmN0aW9uIChfX19jb250ZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoX19fdmlldykgeyByZXR1cm4gKF9fX2NvbnRleHQudmFsdWVzLm9wdGlvbnMuc2VsZWN0YWJsZSkgPyBfX193bWwubm9kZSgndGQnLCB7XG4gICAgaHRtbDoge30sXG4gICAgd21sOiB7fVxufSwgW19fX3dtbC5ub2RlKCdpbnB1dCcsIHtcbiAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgJ3R5cGUnOiBcImNoZWNrYm94XCIsXG4gICAgICAgICAgICAnb25jbGljayc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fX2NvbnRleHQubW9kZWwucm93U2VsZWN0ZWQobmV3IFJvd1NlbGVjdGVkRXZlbnRfMS5Sb3dTZWxlY3RlZEV2ZW50KHJvdywgaW5kZXgsIGRhdGEpKTsgfVxuICAgICAgICB9LFxuICAgICAgICB3bWw6IHt9XG4gICAgfSwgW10sIF9fX3ZpZXcpXSwgX19fdmlldykgOiBfX193bWwuZG9taWZ5KG51bGwpOyB9OyB9OyB9O1xuO1xuZXhwb3J0cy5yb3dzID0gZnVuY3Rpb24gKHJvdywgaW5kZXgsIGZpZWxkcykgeyByZXR1cm4gZnVuY3Rpb24gKF9fX2NvbnRleHQpIHsgcmV0dXJuIGZ1bmN0aW9uIChfX192aWV3KSB7IHJldHVybiBfX193bWwubWFwKGZpZWxkcywgZnVuY3Rpb24gX21hcChmaWVsZCkge1xuICAgIHJldHVybiBfX193bWwubm9kZSgndGQnLCB7XG4gICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLmNsYXNzLmNlbGwsXG4gICAgICAgICAgICAnb25jbGljayc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fX2NvbnRleHQubW9kZWwuY2VsbENsaWNrZWQobmV3IENlbGxDbGlja2VkRXZlbnRfMS5DZWxsQ2xpY2tlZEV2ZW50KHByb3BlcnR5X3NlZWtfMS5nZXQoZmllbGQubmFtZSwgcm93KSwgZmllbGQubmFtZSwgaW5kZXgsIHJvdykpOyB9XG4gICAgICAgIH0sXG4gICAgICAgIHdtbDoge31cbiAgICB9LCBbKGZpZWxkLmZyYWdtZW50KSA/IF9fX3dtbC5kb21pZnkoZmllbGQuZnJhZ21lbnQocHJvcGVydHlfc2Vla18xLmdldChmaWVsZC5uYW1lLCByb3cpLCBmaWVsZC5uYW1lLCByb3cpKF9fX3ZpZXcpKSA6IF9fX3dtbC5kb21pZnkocHJvcGVydHlfc2Vla18xLmdldChmaWVsZC5uYW1lLCByb3cpKV0sIF9fX3ZpZXcpO1xufSwgZnVuY3Rpb24gb3RoZXJ3aXNlKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG59KTsgfTsgfTsgfTtcbjtcbmV4cG9ydHMudGJvZHkgPSBmdW5jdGlvbiAoZGF0YSwgZmllbGRzKSB7IHJldHVybiBmdW5jdGlvbiAoX19fY29udGV4dCkgeyByZXR1cm4gZnVuY3Rpb24gKF9fX3ZpZXcpIHsgcmV0dXJuIF9fX3dtbC5tYXAoZGF0YSwgZnVuY3Rpb24gX21hcChyb3csIGluZGV4KSB7XG4gICAgcmV0dXJuIF9fX3dtbC5ub2RlKCd0cicsIHtcbiAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuY2xhc3Mucm93LFxuICAgICAgICAgICAgJ29uY2xpY2snOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfX19jb250ZXh0Lm1vZGVsLnJvd0NsaWNrZWQobmV3IFJvd0NsaWNrZWRFdmVudF8xLlJvd0NsaWNrZWRFdmVudChyb3csIGluZGV4LCBkYXRhKSk7IH1cbiAgICAgICAgfSxcbiAgICAgICAgd21sOiB7fVxuICAgIH0sIFsoX19fY29udGV4dC52YWx1ZXMub3B0aW9ucy5zZWxlY3RhYmxlKSA/IF9fX3dtbC5ib3goX19fd21sLmRvbWlmeShleHBvcnRzLnJvd1NlbGVjdENoZWNrYm94KHJvdywgaW5kZXgsIGRhdGEpKF9fX2NvbnRleHQpKF9fX3ZpZXcpKSwgX19fd21sLmRvbWlmeShleHBvcnRzLnJvd3Mocm93LCBpbmRleCwgZmllbGRzKShfX19jb250ZXh0KShfX192aWV3KSkpIDogX19fd21sLmRvbWlmeShleHBvcnRzLnJvd3Mocm93LCBpbmRleCwgZmllbGRzKShfX19jb250ZXh0KShfX192aWV3KSldLCBfX192aWV3KTtcbn0sIGZ1bmN0aW9uIG90aGVyd2lzZSgpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xufSk7IH07IH07IH07XG47XG5leHBvcnRzLnRhYmxlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKF9fX2NvbnRleHQpIHsgcmV0dXJuIGZ1bmN0aW9uIChfX192aWV3KSB7IHJldHVybiBfX193bWwubm9kZSgndGFibGUnLCB7XG4gICAgaHRtbDoge1xuICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5jbGFzcy5yb290XG4gICAgfSxcbiAgICB3bWw6IHtcbiAgICAgICAgJ2lkJzogX19fY29udGV4dC52YWx1ZXMuaWQucm9vdFxuICAgIH1cbn0sIFtfX193bWwubm9kZSgndGhlYWQnLCB7XG4gICAgICAgIGh0bWw6IHt9LFxuICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICdpZCc6IFwiaGVhZFwiXG4gICAgICAgIH1cbiAgICB9LCBbX19fd21sLmRvbWlmeShleHBvcnRzLnRoZWFkKF9fX2NvbnRleHQudmFsdWVzLmZpZWxkcykoX19fY29udGV4dCkoX19fdmlldykpXSwgX19fdmlldyksIF9fX3dtbC5ub2RlKCd0Ym9keScsIHtcbiAgICAgICAgaHRtbDoge30sXG4gICAgICAgIHdtbDoge1xuICAgICAgICAgICAgJ2lkJzogXCJib2R5XCJcbiAgICAgICAgfVxuICAgIH0sIFtfX193bWwuZG9taWZ5KGV4cG9ydHMudGJvZHkoX19fY29udGV4dC52YWx1ZXMuZGF0YSwgX19fY29udGV4dC52YWx1ZXMuZmllbGRzKShfX19jb250ZXh0KShfX192aWV3KSldLCBfX192aWV3KV0sIF9fX3ZpZXcpOyB9OyB9OyB9O1xuO1xudmFyIFRhYmxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZShjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwud2lkZ2V0KEZyYWdtZW50XzEuRnJhZ21lbnQsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbKChfX19jb250ZXh0LnZhbHVlcy5kYXRhLmxlbmd0aCA9PT0gMCkpID8gKF9fX2NvbnRleHQudmFsdWVzLmZyYWdtZW50LmVtcHR5KSA/IF9fX3dtbC5kb21pZnkoX19fY29udGV4dC52YWx1ZXMuZnJhZ21lbnQuZW1wdHkucmVuZGVyKCkpIDogX19fd21sLmRvbWlmeShleHBvcnRzLnRhYmxlKCkoX19fY29udGV4dCkoX19fdmlldykpIDogX19fd21sLmRvbWlmeShleHBvcnRzLnRhYmxlKCkoX19fY29udGV4dCkoX19fdmlldykpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRhYmxlO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5UYWJsZSA9IFRhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIFR5cGVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIFdNTCBBU1QuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbjtcbi8qKlxuICogTW9kdWxlIGlzIHdoYXQgYSB3bWwgZmlsZSBjb21waWxlcyB0by5cbiAqXG4gKiBBIG1vZHVsZSBjb250YWlucyBhIGxpc3Qgb2YgaW1wb3J0cyBhbmQgZXhwb3J0ZWQgc3ltYm9scy5cbiAqIEFsbCBkZWNsYXJhdGlvbnMgaW4gd21sIGFyZSBleHBvcnRlZC4gVGhlcmUgaXMgbm8gc3VjaCB0aGluZ1xuICogYXMgcHJpdmF0ZSBoZXJlLlxuICovXG52YXIgTW9kdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1vZHVsZShpbXBvcnRzLCBleHBvcnRzLCBtYWluLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLmltcG9ydHMgPSBpbXBvcnRzO1xuICAgICAgICB0aGlzLmV4cG9ydHMgPSBleHBvcnRzO1xuICAgICAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICdtb2R1bGUnO1xuICAgIH1cbiAgICByZXR1cm4gTW9kdWxlO1xufSgpKTtcbmV4cG9ydHMuTW9kdWxlID0gTW9kdWxlO1xuLyoqXG4gKiBJbXBvcnRTdGF0ZW1lbnRcbiAqL1xudmFyIEltcG9ydFN0YXRlbWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbXBvcnRTdGF0ZW1lbnQobWVtYmVyLCBtb2R1bGUsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMubWVtYmVyID0gbWVtYmVyO1xuICAgICAgICB0aGlzLm1vZHVsZSA9IG1vZHVsZTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAnaW1wb3J0LXN0YXRlbWVudCc7XG4gICAgfVxuICAgIHJldHVybiBJbXBvcnRTdGF0ZW1lbnQ7XG59KCkpO1xuZXhwb3J0cy5JbXBvcnRTdGF0ZW1lbnQgPSBJbXBvcnRTdGF0ZW1lbnQ7XG4vKipcbiAqIEFsaWFzZWRNZW1iZXJcbiAqIEBwcm9wZXJ0eSB7SWRlbnRpZmllcn0gYWxpYXMgLSBUaGUgaWRlbnRpZmllciBpbnRyb2R1Y2VkIHRvIHNjb3BlLlxuICogQHByb3BlcnR5IHtJZGVudGlmaWVyfSBtZW1iZXIgLSBUaGUgaWRlbnRpZmllciB0aGF0IGlzIGFsaWFzZWQuXG4gKi9cbnZhciBBbGlhc2VkTWVtYmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFsaWFzZWRNZW1iZXIobWVtYmVyLCBhbGlhcywgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5tZW1iZXIgPSBtZW1iZXI7XG4gICAgICAgIHRoaXMuYWxpYXMgPSBhbGlhcztcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAnYWxpYXNlZC1tZW1iZXInO1xuICAgIH1cbiAgICByZXR1cm4gQWxpYXNlZE1lbWJlcjtcbn0oKSk7XG5leHBvcnRzLkFsaWFzZWRNZW1iZXIgPSBBbGlhc2VkTWVtYmVyO1xuLyoqXG4gKiBBZ2dyZWdhdGVNZW1iZXJcbiAqL1xudmFyIEFnZ3JlZ2F0ZU1lbWJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBZ2dyZWdhdGVNZW1iZXIoaWQsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAncXVhbGlmaWVkLW1lbWJlcic7XG4gICAgfVxuICAgIHJldHVybiBBZ2dyZWdhdGVNZW1iZXI7XG59KCkpO1xuZXhwb3J0cy5BZ2dyZWdhdGVNZW1iZXIgPSBBZ2dyZWdhdGVNZW1iZXI7XG4vKipcbiAqIENvbXBvc2l0ZU1lbWJlclxuICogQHByb3BlcnR5IHsuLi5JZGVudGlmaWVyfEFsaWFzZWRfTWVtYmVyfSBtZW1iZXJzXG4gKi9cbnZhciBDb21wb3NpdGVNZW1iZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29tcG9zaXRlTWVtYmVyKG1lbWJlcnMsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMubWVtYmVycyA9IG1lbWJlcnM7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2NvbXBvc2l0ZS1tZW1iZXInO1xuICAgIH1cbiAgICByZXR1cm4gQ29tcG9zaXRlTWVtYmVyO1xufSgpKTtcbmV4cG9ydHMuQ29tcG9zaXRlTWVtYmVyID0gQ29tcG9zaXRlTWVtYmVyO1xudmFyIFR5cGVkTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUeXBlZE1haW4oaWQsIHR5cGVDbGFzc2VzLCBjb250ZXh0LCBwYXJhbWV0ZXJzLCB0YWcsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy50eXBlQ2xhc3NlcyA9IHR5cGVDbGFzc2VzO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAndHlwZWQtbWFpbic7XG4gICAgfVxuICAgIHJldHVybiBUeXBlZE1haW47XG59KCkpO1xuZXhwb3J0cy5UeXBlZE1haW4gPSBUeXBlZE1haW47XG52YXIgVW50eXBlZE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVW50eXBlZE1haW4odGFnLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAndW50eXBlZC1tYWluJztcbiAgICB9XG4gICAgcmV0dXJuIFVudHlwZWRNYWluO1xufSgpKTtcbmV4cG9ydHMuVW50eXBlZE1haW4gPSBVbnR5cGVkTWFpbjtcbnZhciBFeHBvcnRTdGF0ZW1lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXhwb3J0U3RhdGVtZW50KG1lbWJlcnMsIG1vZHVsZSwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5tZW1iZXJzID0gbWVtYmVycztcbiAgICAgICAgdGhpcy5tb2R1bGUgPSBtb2R1bGU7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2V4cG9ydC1zdGF0ZW1lbnQnO1xuICAgIH1cbiAgICByZXR1cm4gRXhwb3J0U3RhdGVtZW50O1xufSgpKTtcbmV4cG9ydHMuRXhwb3J0U3RhdGVtZW50ID0gRXhwb3J0U3RhdGVtZW50O1xuLyoqXG4gKiBWaWV3U3RhdGVtZW50XG4gKi9cbnZhciBWaWV3U3RhdGVtZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZpZXdTdGF0ZW1lbnQoaWQsIHR5cGVDbGFzc2VzLCBjb250ZXh0LCBwYXJhbWV0ZXJzLCB0YWcsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy50eXBlQ2xhc3NlcyA9IHR5cGVDbGFzc2VzO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAndmlldy1zdGF0ZW1lbnQnO1xuICAgIH1cbiAgICByZXR1cm4gVmlld1N0YXRlbWVudDtcbn0oKSk7XG5leHBvcnRzLlZpZXdTdGF0ZW1lbnQgPSBWaWV3U3RhdGVtZW50O1xudmFyIEZ1blN0YXRlbWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGdW5TdGF0ZW1lbnQoaWQsIHR5cGVDbGFzc2VzLCBjb250ZXh0LCBwYXJhbWV0ZXJzLCBib2R5LCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMudHlwZUNsYXNzZXMgPSB0eXBlQ2xhc3NlcztcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcbiAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAnZnVuLXN0YXRlbWVudCc7XG4gICAgfVxuICAgIHJldHVybiBGdW5TdGF0ZW1lbnQ7XG59KCkpO1xuZXhwb3J0cy5GdW5TdGF0ZW1lbnQgPSBGdW5TdGF0ZW1lbnQ7XG4vKipcbiAqIFR5cGVDbGFzc1xuICovXG52YXIgVHlwZUNsYXNzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFR5cGVDbGFzcyhpZCwgY29uc3RyYWludCwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmNvbnN0cmFpbnQgPSBjb25zdHJhaW50O1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICd0eXBlLWNsYXNzJztcbiAgICB9XG4gICAgcmV0dXJuIFR5cGVDbGFzcztcbn0oKSk7XG5leHBvcnRzLlR5cGVDbGFzcyA9IFR5cGVDbGFzcztcbnZhciBUeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFR5cGUoaWQsIHR5cGVDbGFzc2VzLCBsaXN0LCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMudHlwZUNsYXNzZXMgPSB0eXBlQ2xhc3NlcztcbiAgICAgICAgdGhpcy5saXN0ID0gbGlzdDtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAndHlwZSc7XG4gICAgfVxuICAgIHJldHVybiBUeXBlO1xufSgpKTtcbmV4cG9ydHMuVHlwZSA9IFR5cGU7XG52YXIgVHlwZWRQYXJhbWV0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHlwZWRQYXJhbWV0ZXIoaWQsIGhpbnQsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5oaW50ID0gaGludDtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAndHlwZWQtcGFyYW1ldGVyJztcbiAgICB9XG4gICAgcmV0dXJuIFR5cGVkUGFyYW1ldGVyO1xufSgpKTtcbmV4cG9ydHMuVHlwZWRQYXJhbWV0ZXIgPSBUeXBlZFBhcmFtZXRlcjtcbnZhciBVbnR5cGVkUGFyYW1ldGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVudHlwZWRQYXJhbWV0ZXIoaWQsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAndW50eXBlZC1wYXJhbWV0ZXInO1xuICAgIH1cbiAgICByZXR1cm4gVW50eXBlZFBhcmFtZXRlcjtcbn0oKSk7XG5leHBvcnRzLlVudHlwZWRQYXJhbWV0ZXIgPSBVbnR5cGVkUGFyYW1ldGVyO1xudmFyIE5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9kZShvcGVuLCBhdHRyaWJ1dGVzLCBjaGlsZHJlbiwgY2xvc2UpIHtcbiAgICAgICAgdGhpcy5vcGVuID0gb3BlbjtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLmNsb3NlID0gY2xvc2U7XG4gICAgICAgIHRoaXMudHlwZSA9ICdub2RlJztcbiAgICB9XG4gICAgcmV0dXJuIE5vZGU7XG59KCkpO1xuZXhwb3J0cy5Ob2RlID0gTm9kZTtcbnZhciBXaWRnZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gV2lkZ2V0KG9wZW4sIGF0dHJpYnV0ZXMsIGNoaWxkcmVuLCBjbG9zZSkge1xuICAgICAgICB0aGlzLm9wZW4gPSBvcGVuO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMuY2xvc2UgPSBjbG9zZTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3dpZGdldCc7XG4gICAgfVxuICAgIHJldHVybiBXaWRnZXQ7XG59KCkpO1xuZXhwb3J0cy5XaWRnZXQgPSBXaWRnZXQ7XG52YXIgQXR0cmlidXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEF0dHJpYnV0ZShuYW1lc3BhY2UsIG5hbWUsIHZhbHVlLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICdhdHRyaWJ1dGUnO1xuICAgIH1cbiAgICByZXR1cm4gQXR0cmlidXRlO1xufSgpKTtcbmV4cG9ydHMuQXR0cmlidXRlID0gQXR0cmlidXRlO1xudmFyIEludGVycG9sYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW50ZXJwb2xhdGlvbihleHByZXNzaW9uLCBmaWx0ZXJzLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICB0aGlzLmZpbHRlcnMgPSBmaWx0ZXJzO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICdpbnRlcnBvbGF0aW9uJztcbiAgICB9XG4gICAgcmV0dXJuIEludGVycG9sYXRpb247XG59KCkpO1xuZXhwb3J0cy5JbnRlcnBvbGF0aW9uID0gSW50ZXJwb2xhdGlvbjtcbnZhciBGb3JTdGF0ZW1lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRm9yU3RhdGVtZW50KHZhcmlhYmxlLCBpbmRleCwgYWxsLCBsaXN0LCBib2R5LCBvdGhlcndpc2UsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGUgPSB2YXJpYWJsZTtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLmFsbCA9IGFsbDtcbiAgICAgICAgdGhpcy5saXN0ID0gbGlzdDtcbiAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgdGhpcy5vdGhlcndpc2UgPSBvdGhlcndpc2U7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2Zvci1zdGF0ZW1lbnQnO1xuICAgIH1cbiAgICByZXR1cm4gRm9yU3RhdGVtZW50O1xufSgpKTtcbmV4cG9ydHMuRm9yU3RhdGVtZW50ID0gRm9yU3RhdGVtZW50O1xudmFyIElmU3RhdGVtZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElmU3RhdGVtZW50KGNvbmRpdGlvbiwgdGhlbiwgZWxzZUNsYXVzZSwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XG4gICAgICAgIHRoaXMudGhlbiA9IHRoZW47XG4gICAgICAgIHRoaXMuZWxzZUNsYXVzZSA9IGVsc2VDbGF1c2U7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2lmLXN0YXRlbWVudCc7XG4gICAgfVxuICAgIHJldHVybiBJZlN0YXRlbWVudDtcbn0oKSk7XG5leHBvcnRzLklmU3RhdGVtZW50ID0gSWZTdGF0ZW1lbnQ7XG52YXIgRWxzZUNsYXVzZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbHNlQ2xhdXNlKGNoaWxkcmVuLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2Vsc2UtY2xhdXNlJztcbiAgICB9XG4gICAgcmV0dXJuIEVsc2VDbGF1c2U7XG59KCkpO1xuZXhwb3J0cy5FbHNlQ2xhdXNlID0gRWxzZUNsYXVzZTtcbnZhciBFbHNlSWZDbGF1c2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRWxzZUlmQ2xhdXNlKGNvbmRpdGlvbiwgdGhlbiwgZWxzZUNsYXVzZSwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XG4gICAgICAgIHRoaXMudGhlbiA9IHRoZW47XG4gICAgICAgIHRoaXMuZWxzZUNsYXVzZSA9IGVsc2VDbGF1c2U7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2Vsc2UtaWYtY2xhdXNlJztcbiAgICB9XG4gICAgcmV0dXJuIEVsc2VJZkNsYXVzZTtcbn0oKSk7XG5leHBvcnRzLkVsc2VJZkNsYXVzZSA9IEVsc2VJZkNsYXVzZTtcbnZhciBDaGFyYWN0ZXJzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENoYXJhY3RlcnModmFsdWUsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAnY2hhcmFjdGVycyc7XG4gICAgfVxuICAgIHJldHVybiBDaGFyYWN0ZXJzO1xufSgpKTtcbmV4cG9ydHMuQ2hhcmFjdGVycyA9IENoYXJhY3RlcnM7XG52YXIgSWZUaGVuRXhwcmVzc2lvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJZlRoZW5FeHByZXNzaW9uKGNvbmRpdGlvbiwgaWZ0cnVlLCBpZmZhbHNlLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICAgICAgdGhpcy5pZnRydWUgPSBpZnRydWU7XG4gICAgICAgIHRoaXMuaWZmYWxzZSA9IGlmZmFsc2U7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2lmLXRoZW4tZXhwcmVzc2lvbic7XG4gICAgfVxuICAgIHJldHVybiBJZlRoZW5FeHByZXNzaW9uO1xufSgpKTtcbmV4cG9ydHMuSWZUaGVuRXhwcmVzc2lvbiA9IElmVGhlbkV4cHJlc3Npb247XG52YXIgQmluYXJ5RXhwcmVzc2lvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCaW5hcnlFeHByZXNzaW9uKGxlZnQsIG9wZXJhdG9yLCByaWdodCwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2JpbmFyeS1leHByZXNzaW9uJztcbiAgICB9XG4gICAgcmV0dXJuIEJpbmFyeUV4cHJlc3Npb247XG59KCkpO1xuZXhwb3J0cy5CaW5hcnlFeHByZXNzaW9uID0gQmluYXJ5RXhwcmVzc2lvbjtcbnZhciBVbmFyeUV4cHJlc3Npb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVW5hcnlFeHByZXNzaW9uKG9wZXJhdG9yLCBleHByZXNzaW9uKSB7XG4gICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ3VuYXJ5LWV4cHJlc3Npb24nO1xuICAgIH1cbiAgICByZXR1cm4gVW5hcnlFeHByZXNzaW9uO1xufSgpKTtcbmV4cG9ydHMuVW5hcnlFeHByZXNzaW9uID0gVW5hcnlFeHByZXNzaW9uO1xudmFyIFZpZXdDb25zdHJ1Y3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVmlld0NvbnN0cnVjdGlvbihjb25zLCBjb250ZXh0LCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLmNvbnMgPSBjb25zO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICd2aWV3LWNvbnN0cnVjdGlvbic7XG4gICAgfVxuICAgIHJldHVybiBWaWV3Q29uc3RydWN0aW9uO1xufSgpKTtcbmV4cG9ydHMuVmlld0NvbnN0cnVjdGlvbiA9IFZpZXdDb25zdHJ1Y3Rpb247XG52YXIgRnVuQXBwbGljYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRnVuQXBwbGljYXRpb24odGFyZ2V0LCB0eXBlQXJncywgY29udGV4dCwgYXJncywgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMudHlwZUFyZ3MgPSB0eXBlQXJncztcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAnZnVuLWFwcGxpY2F0aW9uJztcbiAgICB9XG4gICAgcmV0dXJuIEZ1bkFwcGxpY2F0aW9uO1xufSgpKTtcbmV4cG9ydHMuRnVuQXBwbGljYXRpb24gPSBGdW5BcHBsaWNhdGlvbjtcbnZhciBDb25zdHJ1Y3RFeHByZXNzaW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbnN0cnVjdEV4cHJlc3Npb24oY29ucywgYXJncywgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5jb25zID0gY29ucztcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAnY29uc3RydWN0LWV4cHJlc3Npb24nO1xuICAgIH1cbiAgICByZXR1cm4gQ29uc3RydWN0RXhwcmVzc2lvbjtcbn0oKSk7XG5leHBvcnRzLkNvbnN0cnVjdEV4cHJlc3Npb24gPSBDb25zdHJ1Y3RFeHByZXNzaW9uO1xudmFyIENhbGxFeHByZXNzaW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhbGxFeHByZXNzaW9uKHRhcmdldCwgdHlwZUFyZ3MsIGFyZ3MsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLnR5cGVBcmdzID0gdHlwZUFyZ3M7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2NhbGwtZXhwcmVzc2lvbic7XG4gICAgfVxuICAgIHJldHVybiBDYWxsRXhwcmVzc2lvbjtcbn0oKSk7XG5leHBvcnRzLkNhbGxFeHByZXNzaW9uID0gQ2FsbEV4cHJlc3Npb247XG4vKipcbiAqIE1lbWJlckV4cHJlc3Npb25cbiAqL1xudmFyIE1lbWJlckV4cHJlc3Npb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVtYmVyRXhwcmVzc2lvbih0YXJnZXQsIG1lbWJlciwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMubWVtYmVyID0gbWVtYmVyO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgfVxuICAgIHJldHVybiBNZW1iZXJFeHByZXNzaW9uO1xufSgpKTtcbmV4cG9ydHMuTWVtYmVyRXhwcmVzc2lvbiA9IE1lbWJlckV4cHJlc3Npb247XG52YXIgUmVhZEV4cHJlc3Npb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVhZEV4cHJlc3Npb24odGFyZ2V0LCBwYXRoLCBoaW50LCBkZWZhdWx0cywgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMuaGludCA9IGhpbnQ7XG4gICAgICAgIHRoaXMuZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAncmVhZC1leHByZXNzaW9uJztcbiAgICB9XG4gICAgcmV0dXJuIFJlYWRFeHByZXNzaW9uO1xufSgpKTtcbmV4cG9ydHMuUmVhZEV4cHJlc3Npb24gPSBSZWFkRXhwcmVzc2lvbjtcbnZhciBGdW5jdGlvbkV4cHJlc3Npb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRnVuY3Rpb25FeHByZXNzaW9uKHBhcmFtZXRlcnMsIGJvZHksIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMucGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG4gICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2Z1bmN0aW9uLWV4cHJlc3Npb24nO1xuICAgIH1cbiAgICByZXR1cm4gRnVuY3Rpb25FeHByZXNzaW9uO1xufSgpKTtcbmV4cG9ydHMuRnVuY3Rpb25FeHByZXNzaW9uID0gRnVuY3Rpb25FeHByZXNzaW9uO1xudmFyIExpc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGlzdChtZW1iZXJzLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLm1lbWJlcnMgPSBtZW1iZXJzO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICdsaXN0JztcbiAgICB9XG4gICAgcmV0dXJuIExpc3Q7XG59KCkpO1xuZXhwb3J0cy5MaXN0ID0gTGlzdDtcbnZhciBSZWNvcmQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVjb3JkKHByb3BlcnRpZXMsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ3JlY29yZCc7XG4gICAgfVxuICAgIHJldHVybiBSZWNvcmQ7XG59KCkpO1xuZXhwb3J0cy5SZWNvcmQgPSBSZWNvcmQ7XG52YXIgUHJvcGVydHkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHJvcGVydHkoa2V5LCB2YWx1ZSwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAncHJvcGVydHknO1xuICAgIH1cbiAgICByZXR1cm4gUHJvcGVydHk7XG59KCkpO1xuZXhwb3J0cy5Qcm9wZXJ0eSA9IFByb3BlcnR5O1xudmFyIFN0cmluZ0xpdGVyYWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RyaW5nTGl0ZXJhbCh2YWx1ZSwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICdzdHJpbmcnO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nTGl0ZXJhbDtcbn0oKSk7XG5leHBvcnRzLlN0cmluZ0xpdGVyYWwgPSBTdHJpbmdMaXRlcmFsO1xudmFyIE51bWJlckxpdGVyYWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTnVtYmVyTGl0ZXJhbCh2YWx1ZSwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICdudW1iZXItbGl0ZXJhbCc7XG4gICAgfVxuICAgIHJldHVybiBOdW1iZXJMaXRlcmFsO1xufSgpKTtcbmV4cG9ydHMuTnVtYmVyTGl0ZXJhbCA9IE51bWJlckxpdGVyYWw7XG52YXIgQm9vbGVhbkxpdGVyYWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQm9vbGVhbkxpdGVyYWwodmFsdWUsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAnYm9vbGVhbi1saXRlcmFsJztcbiAgICB9XG4gICAgcmV0dXJuIEJvb2xlYW5MaXRlcmFsO1xufSgpKTtcbmV4cG9ydHMuQm9vbGVhbkxpdGVyYWwgPSBCb29sZWFuTGl0ZXJhbDtcbnZhciBDb250ZXh0UHJvcGVydHkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29udGV4dFByb3BlcnR5KG1lbWJlciwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5tZW1iZXIgPSBtZW1iZXI7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2NvbnRleHQtcHJvcGVydHknO1xuICAgIH1cbiAgICByZXR1cm4gQ29udGV4dFByb3BlcnR5O1xufSgpKTtcbmV4cG9ydHMuQ29udGV4dFByb3BlcnR5ID0gQ29udGV4dFByb3BlcnR5O1xudmFyIENvbnRleHRWYXJpYWJsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb250ZXh0VmFyaWFibGUobG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAnY29udGV4dC12YXJpYWJsZSc7XG4gICAgfVxuICAgIHJldHVybiBDb250ZXh0VmFyaWFibGU7XG59KCkpO1xuZXhwb3J0cy5Db250ZXh0VmFyaWFibGUgPSBDb250ZXh0VmFyaWFibGU7XG52YXIgVW5xdWFsaWZpZWRDb25zdHJ1Y3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVbnF1YWxpZmllZENvbnN0cnVjdG9yKGlkLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ3VucXVhbGlmaWVkLWNvbnN0cnVjdG9yJztcbiAgICB9XG4gICAgcmV0dXJuIFVucXVhbGlmaWVkQ29uc3RydWN0b3I7XG59KCkpO1xuZXhwb3J0cy5VbnF1YWxpZmllZENvbnN0cnVjdG9yID0gVW5xdWFsaWZpZWRDb25zdHJ1Y3RvcjtcbnZhciBRdWFsaWZpZWRDb25zdHJ1Y3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBRdWFsaWZpZWRDb25zdHJ1Y3RvcihxdWFsaWZpZXIsIG1lbWJlciwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5xdWFsaWZpZXIgPSBxdWFsaWZpZXI7XG4gICAgICAgIHRoaXMubWVtYmVyID0gbWVtYmVyO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICdxdWFsaWZpZWQtY29uc3RydWN0b3InO1xuICAgIH1cbiAgICByZXR1cm4gUXVhbGlmaWVkQ29uc3RydWN0b3I7XG59KCkpO1xuZXhwb3J0cy5RdWFsaWZpZWRDb25zdHJ1Y3RvciA9IFF1YWxpZmllZENvbnN0cnVjdG9yO1xudmFyIFVucXVhbGlmaWVkSWRlbnRpZmllciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVbnF1YWxpZmllZElkZW50aWZpZXIoaWQsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAndW5xdWFsaWZpZWQtaWRlbnRpZmllcic7XG4gICAgfVxuICAgIHJldHVybiBVbnF1YWxpZmllZElkZW50aWZpZXI7XG59KCkpO1xuZXhwb3J0cy5VbnF1YWxpZmllZElkZW50aWZpZXIgPSBVbnF1YWxpZmllZElkZW50aWZpZXI7XG4vKipcbiAqIFF1YWxpZmllZElkZW50aWZpZXJcbiAqL1xudmFyIFF1YWxpZmllZElkZW50aWZpZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUXVhbGlmaWVkSWRlbnRpZmllcihxdWFsaWZpZXIsIG1lbWJlciwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5xdWFsaWZpZXIgPSBxdWFsaWZpZXI7XG4gICAgICAgIHRoaXMubWVtYmVyID0gbWVtYmVyO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICdxdWFsaWZpZWQtaWRlbnRpZmllcic7XG4gICAgfVxuICAgIHJldHVybiBRdWFsaWZpZWRJZGVudGlmaWVyO1xufSgpKTtcbmV4cG9ydHMuUXVhbGlmaWVkSWRlbnRpZmllciA9IFF1YWxpZmllZElkZW50aWZpZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BU1QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPSdQYXJzZXIuZC50cycgLz5cbnZhciBQYXJzZXIgPSByZXF1aXJlKFwiLi9QYXJzZXJcIik7XG52YXIgbm9kZXMgPSByZXF1aXJlKFwiLi9BU1RcIik7XG52YXIgYWZwbCA9IHJlcXVpcmUoXCJhZnBsXCIpO1xudmFyIGpzZm10ID0gcmVxdWlyZShcImpzLWJlYXV0aWZ5XCIpO1xudmFyIFR5cGVTY3JpcHQgPSByZXF1aXJlKFwiLi9UeXBlU2NyaXB0XCIpO1xudmFyIGFmcGxfMSA9IHJlcXVpcmUoXCJhZnBsXCIpO1xudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgIGRlYnVnOiBmYWxzZSxcbiAgICBtYWluOiAnTWFpbicsXG4gICAgbW9kdWxlOiAnQHF1ZW5rL3dtbCcsXG59O1xuLyoqXG4gKiBwYXJzZSBhIHN0cmluZyBhcyBXTUwgcmV0dXJuaW5nIGVpdGhlciBhbiBlcnJvciBvciBhbiBBU1QuXG4gKi9cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoc3RyLCBhc3QpIHtcbiAgICBpZiAoYXN0ID09PSB2b2lkIDApIHsgYXN0ID0gbm9kZXM7IH1cbiAgICBQYXJzZXIucGFyc2VyLnl5ID0geyBhc3Q6IGFzdCB9O1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhZnBsXzEuRWl0aGVyLnJpZ2h0KFBhcnNlci5wYXJzZXIucGFyc2Uoc3RyKSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBhZnBsXzEuRWl0aGVyLmxlZnQoZSk7XG4gICAgfVxufTtcbi8qKlxuICogcHJldHR5IHVwIHRoZSBvdXRwdXQuXG4gKi9cbmV4cG9ydHMucHJldHR5ID0gZnVuY3Rpb24gKGRvaXQpIHsgcmV0dXJuIGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIGRvaXQgPyBqc2ZtdChzLCB7fSkgOiBzO1xufTsgfTtcbi8qKlxuICogY29tcGlsZSBhIHN0cmluZyBvZiBXTUwgdHVybmluZyBpdCBpbnRvIHR5cGVzY3JpcHQgY29kZS5cbiAqL1xuZXhwb3J0cy5jb21waWxlID0gZnVuY3Rpb24gKHNyYywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIG9wdHMgPSBhZnBsLnV0aWwubWVyZ2UoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIHJldHVybiBleHBvcnRzLnBhcnNlKHNyYylcbiAgICAgICAgLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gVHlwZVNjcmlwdC5jb2RlKG0sIG9wdHMpOyB9KVxuICAgICAgICAubWFwKGV4cG9ydHMucHJldHR5KG9wdGlvbnMucHJldHR5KSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29tcGlsZXIuanMubWFwIiwiXG4vKiBwYXJzZXIgZ2VuZXJhdGVkIGJ5IGppc29uIDAuNi4xLTIwMyAqL1xuXG4vKlxuICogUmV0dXJucyBhIFBhcnNlciBvYmplY3Qgb2YgdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmU6XG4gKlxuICogIFBhcnNlcjoge1xuICogICAgeXk6IHt9ICAgICBUaGUgc28tY2FsbGVkIFwic2hhcmVkIHN0YXRlXCIgb3IgcmF0aGVyIHRoZSAqc291cmNlKiBvZiBpdDtcbiAqICAgICAgICAgICAgICAgdGhlIHJlYWwgXCJzaGFyZWQgc3RhdGVcIiBgeXlgIHBhc3NlZCBhcm91bmQgdG9cbiAqICAgICAgICAgICAgICAgdGhlIHJ1bGUgYWN0aW9ucywgZXRjLiBpcyBhIGRlcml2YXRpdmUvY29weSBvZiB0aGlzIG9uZSxcbiAqICAgICAgICAgICAgICAgbm90IGEgZGlyZWN0IHJlZmVyZW5jZSFcbiAqICB9XG4gKlxuICogIFBhcnNlci5wcm90b3R5cGU6IHtcbiAqICAgIHl5OiB7fSxcbiAqICAgIEVPRjogMSxcbiAqICAgIFRFUlJPUjogMixcbiAqXG4gKiAgICB0cmFjZTogZnVuY3Rpb24oZXJyb3JNZXNzYWdlLCAuLi4pLFxuICpcbiAqICAgIEppc29uUGFyc2VyRXJyb3I6IGZ1bmN0aW9uKG1zZywgaGFzaCksXG4gKlxuICogICAgcXVvdGVOYW1lOiBmdW5jdGlvbihuYW1lKSxcbiAqICAgICAgICAgICAgICAgSGVscGVyIGZ1bmN0aW9uIHdoaWNoIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHVzZXIgY29kZSBsYXRlciBvbjogcHV0IHN1aXRhYmxlXG4gKiAgICAgICAgICAgICAgIHF1b3RlcyBhcm91bmQgbGl0ZXJhbCBJRHMgaW4gYSBkZXNjcmlwdGlvbiBzdHJpbmcuXG4gKlxuICogICAgb3JpZ2luYWxRdW90ZU5hbWU6IGZ1bmN0aW9uKG5hbWUpLFxuICogICAgICAgICAgICAgICBUaGUgYmFzaWMgcXVvdGVOYW1lIGhhbmRsZXIgcHJvdmlkZWQgYnkgSklTT04uXG4gKiAgICAgICAgICAgICAgIGBjbGVhbnVwQWZ0ZXJQYXJzZSgpYCB3aWxsIGNsZWFuIHVwIGFuZCByZXNldCBgcXVvdGVOYW1lKClgIHRvIHJlZmVyZW5jZSB0aGlzIGZ1bmN0aW9uXG4gKiAgICAgICAgICAgICAgIGF0IHRoZSBlbmQgb2YgdGhlIGBwYXJzZSgpYC5cbiAqXG4gKiAgICBkZXNjcmliZVN5bWJvbDogZnVuY3Rpb24oc3ltYm9sKSxcbiAqICAgICAgICAgICAgICAgUmV0dXJuIGEgbW9yZS1vci1sZXNzIGh1bWFuLXJlYWRhYmxlIGRlc2NyaXB0aW9uIG9mIHRoZSBnaXZlbiBzeW1ib2wsIHdoZW5cbiAqICAgICAgICAgICAgICAgYXZhaWxhYmxlLCBvciB0aGUgc3ltYm9sIGl0c2VsZiwgc2VydmluZyBhcyBpdHMgb3duICdkZXNjcmlwdGlvbicgZm9yIGxhY2tcbiAqICAgICAgICAgICAgICAgb2Ygc29tZXRoaW5nIGJldHRlciB0byBzZXJ2ZSB1cC5cbiAqXG4gKiAgICAgICAgICAgICAgIFJldHVybiBOVUxMIHdoZW4gdGhlIHN5bWJvbCBpcyB1bmtub3duIHRvIHRoZSBwYXJzZXIuXG4gKlxuICogICAgc3ltYm9sc186IHthc3NvY2lhdGl2ZSBsaXN0OiBuYW1lID09PiBudW1iZXJ9LFxuICogICAgdGVybWluYWxzXzoge2Fzc29jaWF0aXZlIGxpc3Q6IG51bWJlciA9PT4gbmFtZX0sXG4gKiAgICBub250ZXJtaW5hbHM6IHthc3NvY2lhdGl2ZSBsaXN0OiBydWxlLW5hbWUgPT0+IHthc3NvY2lhdGl2ZSBsaXN0OiBudW1iZXIgPT0+IHJ1bGUtYWx0fX0sXG4gKiAgICB0ZXJtaW5hbF9kZXNjcmlwdGlvbnNfOiAoaWYgdGhlcmUgYXJlIGFueSkge2Fzc29jaWF0aXZlIGxpc3Q6IG51bWJlciA9PT4gZGVzY3JpcHRpb259LFxuICogICAgcHJvZHVjdGlvbnNfOiBbLi4uXSxcbiAqXG4gKiAgICBwZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBwYXJzZXJfX3BlcmZvcm1BY3Rpb24oeXl0ZXh0LCB5eWxlbmcsIHl5bGluZW5vLCB5eWxvYywgeXlzdGF0ZSwgeXlzcCwgeXl2c3RhY2ssIHl5bHN0YWNrLCB5eXN0YWNrLCB5eXNzdGFjayksXG4gKlxuICogICAgICAgICAgICAgICBUaGUgZnVuY3Rpb24gcGFyYW1ldGVycyBhbmQgYHRoaXNgIGhhdmUgdGhlIGZvbGxvd2luZyB2YWx1ZS9tZWFuaW5nOlxuICogICAgICAgICAgICAgICAtIGB0aGlzYCAgICA6IHJlZmVyZW5jZSB0byB0aGUgYHl5dmFsYCBpbnRlcm5hbCBvYmplY3QsIHdoaWNoIGhhcyBtZW1iZXJzIChgJGAgYW5kIGBfJGApXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gc3RvcmUvcmVmZXJlbmNlIHRoZSBydWxlIHZhbHVlIGAkJGAgYW5kIGxvY2F0aW9uIGluZm8gYEAkYC5cbiAqXG4gKiAgICAgICAgICAgICAgICAgT25lIGltcG9ydGFudCB0aGluZyB0byBub3RlIGFib3V0IGB0aGlzYCBhLmsuYS4gYHl5dmFsYDogZXZlcnkgKnJlZHVjZSogYWN0aW9uIGdldHNcbiAqICAgICAgICAgICAgICAgICB0byBzZWUgdGhlIHNhbWUgb2JqZWN0IHZpYSB0aGUgYHRoaXNgIHJlZmVyZW5jZSwgaS5lLiBpZiB5b3Ugd2lzaCB0byBjYXJyeSBjdXN0b21cbiAqICAgICAgICAgICAgICAgICBkYXRhIGZyb20gb25lIHJlZHVjZSBhY3Rpb24gdGhyb3VnaCB0byB0aGUgbmV4dCB3aXRoaW4gYSBzaW5nbGUgcGFyc2UgcnVuLCB0aGVuIHlvdVxuICogICAgICAgICAgICAgICAgIG1heSBnZXQgbmFzdHkgYW5kIHVzZSBgeXl2YWxgIGEuay5hLiBgdGhpc2AgZm9yIHN0b3JpbmcgeW91IG93biBzZW1pLXBlcm1hbmVudCBkYXRhLlxuICpcbiAqICAgICAgICAgICAgICAgICBgdGhpcy55eWAgaXMgYSBkaXJlY3QgcmVmZXJlbmNlIHRvIHRoZSBgeXlgIHNoYXJlZCBzdGF0ZSBvYmplY3QuXG4gKlxuICogICAgICAgICAgICAgICAgIGAlcGFyc2UtcGFyYW1gLXNwZWNpZmllZCBhZGRpdGlvbmFsIGBwYXJzZSgpYCBhcmd1bWVudHMgaGF2ZSBiZWVuIGFkZGVkIHRvIHRoaXMgYHl5YFxuICogICAgICAgICAgICAgICAgIG9iamVjdCBhdCBgcGFyc2UoKWAgc3RhcnQgYW5kIGFyZSB0aGVyZWZvcmUgYXZhaWxhYmxlIHRvIHRoZSBhY3Rpb24gY29kZSB2aWEgdGhlXG4gKiAgICAgICAgICAgICAgICAgc2FtZSBuYW1lZCBgeXkueHh4eGAgYXR0cmlidXRlcyAod2hlcmUgYHh4eHhgIHJlcHJlc2VudHMgYSBpZGVudGlmaWVyIG5hbWUgZnJvbVxuICogICAgICAgICAgICAgICAgIHRoZSAlcGFyc2UtcGFyYW1gIGxpc3QuXG4gKlxuICogICAgICAgICAgICAgICAtIGB5eXRleHRgICA6IHJlZmVyZW5jZSB0byB0aGUgbGV4ZXIgdmFsdWUgd2hpY2ggYmVsb25ncyB0byB0aGUgbGFzdCBsZXhlciB0b2tlbiB1c2VkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gbWF0Y2ggdGhpcyBydWxlLiBUaGlzIGlzICpub3QqIHRoZSBsb29rLWFoZWFkIHRva2VuLCBidXQgdGhlIGxhc3QgdG9rZW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0J3MgYWN0dWFsbHkgcGFydCBvZiB0aGlzIHJ1bGUuXG4gKlxuICogICAgICAgICAgICAgICAgIEZvcm11bGF0ZWQgYW5vdGhlciB3YXksIGB5eXRleHRgIGlzIHRoZSB2YWx1ZSBvZiB0aGUgdG9rZW4gaW1tZWRpYXRlbHkgcHJlY2VlZGluZ1xuICogICAgICAgICAgICAgICAgIHRoZSBjdXJyZW50IGxvb2stYWhlYWQgdG9rZW4uXG4gKiAgICAgICAgICAgICAgICAgQ2F2ZWF0cyBhcHBseSBmb3IgcnVsZXMgd2hpY2ggZG9uJ3QgcmVxdWlyZSBsb29rLWFoZWFkLCBzdWNoIGFzIGVwc2lsb24gcnVsZXMuXG4gKlxuICogICAgICAgICAgICAgICAtIGB5eWxlbmdgICA6IGRpdHRvIGFzIGB5eXRleHRgLCBvbmx5IG5vdyBmb3IgdGhlIGxleGVyLnl5bGVuZyB2YWx1ZS5cbiAqXG4gKiAgICAgICAgICAgICAgIC0gYHl5bGluZW5vYDogZGl0dG8gYXMgYHl5dGV4dGAsIG9ubHkgbm93IGZvciB0aGUgbGV4ZXIueXlsaW5lbm8gdmFsdWUuXG4gKlxuICogICAgICAgICAgICAgICAtIGB5eWxvY2AgICA6IGRpdHRvIGFzIGB5eXRleHRgLCBvbmx5IG5vdyBmb3IgdGhlIGxleGVyLnl5bGxvYyBsZXhlciB0b2tlbiBsb2NhdGlvbiBpbmZvLlxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdBUk5JTkc6IHNpbmNlIGppc29uIDAuNC4xOC0xODYgdGhpcyBlbnRyeSBtYXkgYmUgTlVMTC9VTkRFRklORUQgaW5zdGVhZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgYW4gZW1wdHkgb2JqZWN0IHdoZW4gbm8gc3VpdGFibGUgbG9jYXRpb24gaW5mbyBjYW4gYmUgcHJvdmlkZWQuXG4gKlxuICogICAgICAgICAgICAgICAtIGB5eXN0YXRlYCA6IHRoZSBjdXJyZW50IHBhcnNlciBzdGF0ZSBudW1iZXIsIHVzZWQgaW50ZXJuYWxseSBmb3IgZGlzcGF0Y2hpbmcgYW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRpbmcgdGhlIGFjdGlvbiBjb2RlIGNodW5rIG1hdGNoaW5nIHRoZSBydWxlIGN1cnJlbnRseSBiZWluZyByZWR1Y2VkLlxuICpcbiAqICAgICAgICAgICAgICAgLSBgeXlzcGAgICAgOiB0aGUgY3VycmVudCBzdGF0ZSBzdGFjayBwb3NpdGlvbiAoYS5rLmEuICdzdGFjayBwb2ludGVyJylcbiAqXG4gKiAgICAgICAgICAgICAgICAgVGhpcyBvbmUgY29tZXMgaW4gaGFuZHkgd2hlbiB5b3UgYXJlIGdvaW5nIHRvIGRvIGFkdmFuY2VkIHRoaW5ncyB0byB0aGUgcGFyc2VyXG4gKiAgICAgICAgICAgICAgICAgc3RhY2tzLCBhbGwgb2Ygd2hpY2ggYXJlIGFjY2Vzc2libGUgZnJvbSB5b3VyIGFjdGlvbiBjb2RlIChzZWUgdGhlIG5leHQgZW50cmllcyBiZWxvdykuXG4gKlxuICogICAgICAgICAgICAgICAgIEFsc28gbm90ZSB0aGF0IHlvdSBjYW4gYWNjZXNzIHRoaXMgYW5kIG90aGVyIHN0YWNrIGluZGV4IHZhbHVlcyB1c2luZyB0aGUgbmV3IGRvdWJsZS1oYXNoXG4gKiAgICAgICAgICAgICAgICAgc3ludGF4LCBpLmUuIGAjIyQgPT09ICMjMCA9PT0geXlzcGAsIHdoaWxlIGAjIzFgIGlzIHRoZSBzdGFjayBpbmRleCBmb3IgYWxsIHRoaW5nc1xuICogICAgICAgICAgICAgICAgIHJlbGF0ZWQgdG8gdGhlIGZpcnN0IHJ1bGUgdGVybSwganVzdCBsaWtlIHlvdSBoYXZlIGAkMWAsIGBAMWAgYW5kIGAjMWAuXG4gKiAgICAgICAgICAgICAgICAgVGhpcyBpcyBtYWRlIGF2YWlsYWJsZSB0byB3cml0ZSB2ZXJ5IGFkdmFuY2VkIGdyYW1tYXIgYWN0aW9uIHJ1bGVzLCBlLmcuIHdoZW4geW91IHdhbnRcbiAqICAgICAgICAgICAgICAgICB0byBpbnZlc3RpZ2F0ZSB0aGUgcGFyc2Ugc3RhdGUgc3RhY2sgaW4geW91ciBhY3Rpb24gY29kZSwgd2hpY2ggd291bGQsIGZvciBleGFtcGxlLFxuICogICAgICAgICAgICAgICAgIGJlIHJlbGV2YW50IHdoZW4geW91IHdpc2ggdG8gaW1wbGVtZW50IGVycm9yIGRpYWdub3N0aWNzIGFuZCByZXBvcnRpbmcgc2NoZW1lcyBzaW1pbGFyXG4gKiAgICAgICAgICAgICAgICAgdG8gdGhlIHdvcmsgZGVzY3JpYmVkIGhlcmU6XG4gKlxuICogICAgICAgICAgICAgICAgICsgUG90dGllciwgRi4sIDIwMTYuIFJlYWNoYWJpbGl0eSBhbmQgZXJyb3IgZGlhZ25vc2lzIGluIExSKDEpIGF1dG9tYXRhLlxuICogICAgICAgICAgICAgICAgICAgSW4gSm91cm7DqWVzIEZyYW5jb3Bob25lcyBkZXMgTGFuZ3VhZ2VzIEFwcGxpY2F0aWZzLlxuICpcbiAqICAgICAgICAgICAgICAgICArIEplZmZlcnksIEMuTC4sIDIwMDMuIEdlbmVyYXRpbmcgTFIgc3ludGF4IGVycm9yIG1lc3NhZ2VzIGZyb20gZXhhbXBsZXMuXG4gKiAgICAgICAgICAgICAgICAgICBBQ00gVHJhbnNhY3Rpb25zIG9uIFByb2dyYW1taW5nIExhbmd1YWdlcyBhbmQgU3lzdGVtcyAoVE9QTEFTKSwgMjUoNSksIHBwLjYzMeKAkzY0MC5cbiAqXG4gKiAgICAgICAgICAgICAgIC0gYHl5cnVsZWxlbmd0aGA6IHRoZSBjdXJyZW50IHJ1bGUncyB0ZXJtIGNvdW50LCBpLmUuIHRoZSBudW1iZXIgb2YgZW50cmllcyBvY2N1cGllZCBvbiB0aGUgc3RhY2suXG4gKlxuICogICAgICAgICAgICAgICAgIFRoaXMgb25lIGNvbWVzIGluIGhhbmR5IHdoZW4geW91IGFyZSBnb2luZyB0byBkbyBhZHZhbmNlZCB0aGluZ3MgdG8gdGhlIHBhcnNlclxuICogICAgICAgICAgICAgICAgIHN0YWNrcywgYWxsIG9mIHdoaWNoIGFyZSBhY2Nlc3NpYmxlIGZyb20geW91ciBhY3Rpb24gY29kZSAoc2VlIHRoZSBuZXh0IGVudHJpZXMgYmVsb3cpLlxuICpcbiAqICAgICAgICAgICAgICAgLSBgeXl2c3RhY2tgOiByZWZlcmVuY2UgdG8gdGhlIHBhcnNlciB2YWx1ZSBzdGFjay4gQWxzbyBhY2Nlc3NlZCB2aWEgdGhlIGAkMWAgZXRjLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdHMuXG4gKlxuICogICAgICAgICAgICAgICAtIGB5eWxzdGFja2A6IHJlZmVyZW5jZSB0byB0aGUgcGFyc2VyIHRva2VuIGxvY2F0aW9uIHN0YWNrLiBBbHNvIGFjY2Vzc2VkIHZpYVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBgQDFgIGV0Yy4gY29uc3RydWN0cy5cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV0FSTklORzogc2luY2Ugamlzb24gMC40LjE4LTE4NiB0aGlzIGFycmF5IE1BWSBjb250YWluIHNsb3RzIHdoaWNoIGFyZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIFVOREVGSU5FRCByYXRoZXIgdGhhbiBhbiBlbXB0eSAobG9jYXRpb24pIG9iamVjdCwgd2hlbiB0aGUgbGV4ZXIvcGFyc2VyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uIGNvZGUgZGlkIG5vdCBwcm92aWRlIGEgc3VpdGFibGUgbG9jYXRpb24gaW5mbyBvYmplY3Qgd2hlbiBzdWNoIGFcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbG90IHdhcyBmaWxsZWQhXG4gKlxuICogICAgICAgICAgICAgICAtIGB5eXN0YWNrYCA6IHJlZmVyZW5jZSB0byB0aGUgcGFyc2VyIHRva2VuIGlkIHN0YWNrLiBBbHNvIGFjY2Vzc2VkIHZpYSB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgIzFgIGV0Yy4gY29uc3RydWN0cy5cbiAqXG4gKiAgICAgICAgICAgICAgICAgTm90ZTogdGhpcyBpcyBhIGJpdCBvZiBhICoqd2hpdGUgbGllKiogYXMgd2UgY2FuIHN0YXRpY2FsbHkgZGVjb2RlIGFueSBgI25gIHJlZmVyZW5jZSB0b1xuICogICAgICAgICAgICAgICAgIGl0cyBudW1lcmljIHRva2VuIGlkIHZhbHVlLCBoZW5jZSB0aGF0IGNvZGUgd291bGRuJ3QgbmVlZCB0aGUgYHl5c3RhY2tgIGJ1dCAqeW91KiBtaWdodFxuICogICAgICAgICAgICAgICAgIHdhbnQgYWNjZXNzIHRoaXMgYXJyYXkgZm9yIHlvdXIgb3duIHB1cnBvc2VzLCBzdWNoIGFzIGVycm9yIGFuYWx5c2lzIGFzIG1lbnRpb25lZCBhYm92ZSFcbiAqXG4gKiAgICAgICAgICAgICAgICAgTm90ZSB0aGF0IHRoaXMgc3RhY2sgc3RvcmVzIHRoZSBjdXJyZW50IHN0YWNrIG9mICp0b2tlbnMqLCB0aGF0IGlzIHRoZSBzZXF1ZW5jZSBvZlxuICogICAgICAgICAgICAgICAgIGFscmVhZHkgcGFyc2VkPXJlZHVjZWQgKm5vbnRlcm1pbmFscyogKHRva2VucyByZXByZXNlbnRpbmcgcnVsZXMpIGFuZCAqdGVybWluYWxzKlxuICogICAgICAgICAgICAgICAgIChsZXhlciB0b2tlbnMgKnNoaWZ0ZWQqIG9udG8gdGhlIHN0YWNrIHVudGlsIHRoZSBydWxlIHRoZXkgYmVsb25nIHRvIGlzIGZvdW5kIGFuZFxuICogICAgICAgICAgICAgICAgICpyZWR1Y2VkKi5cbiAqXG4gKiAgICAgICAgICAgICAgIC0gYHl5c3N0YWNrYDogcmVmZXJlbmNlIHRvIHRoZSBwYXJzZXIgc3RhdGUgc3RhY2suIFRoaXMgb25lIGNhcnJpZXMgdGhlIGludGVybmFsIHBhcnNlclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICpzdGF0ZXMqIHN1Y2ggYXMgdGhlIG9uZSBpbiBgeXlzdGF0ZWAsIHdoaWNoIGFyZSB1c2VkIHRvIHJlcHJlc2VudFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBwYXJzZXIgc3RhdGUgbWFjaGluZSBpbiB0aGUgKnBhcnNlIHRhYmxlKi4gKlZlcnkqICppbnRlcm5hbCogc3R1ZmYsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hhdCBjYW4gSSBzYXk/IElmIHlvdSBhY2Nlc3MgdGhpcyBvbmUsIHlvdSdyZSBjbGVhcmx5IGRvaW5nIHdpY2tlZCB0aGluZ3NcbiAqXG4gKiAgICAgICAgICAgICAgIC0gYC4uLmAgICAgIDogdGhlIGV4dHJhIGFyZ3VtZW50cyB5b3Ugc3BlY2lmaWVkIGluIHRoZSBgJXBhcnNlLXBhcmFtYCBzdGF0ZW1lbnQgaW4geW91clxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYW1tYXIgZGVmaW5pdGlvbiBmaWxlLlxuICpcbiAqICAgIHRhYmxlOiBbLi4uXSxcbiAqICAgICAgICAgICAgICAgU3RhdGUgdHJhbnNpdGlvbiB0YWJsZVxuICogICAgICAgICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogICAgICAgICAgICAgICBpbmRleCBsZXZlbHMgYXJlOlxuICogICAgICAgICAgICAgICAtIGBzdGF0ZWAgIC0tPiBoYXNoIHRhYmxlXG4gKiAgICAgICAgICAgICAgIC0gYHN5bWJvbGAgLS0+IGFjdGlvbiAobnVtYmVyIG9yIGFycmF5KVxuICpcbiAqICAgICAgICAgICAgICAgICBJZiB0aGUgYGFjdGlvbmAgaXMgYW4gYXJyYXksIHRoZXNlIGFyZSB0aGUgZWxlbWVudHMnIG1lYW5pbmc6XG4gKiAgICAgICAgICAgICAgICAgLSBpbmRleCBbMF06IDEgPSBzaGlmdCwgMiA9IHJlZHVjZSwgMyA9IGFjY2VwdFxuICogICAgICAgICAgICAgICAgIC0gaW5kZXggWzFdOiBHT1RPIGBzdGF0ZWBcbiAqXG4gKiAgICAgICAgICAgICAgICAgSWYgdGhlIGBhY3Rpb25gIGlzIGEgbnVtYmVyLCBpdCBpcyB0aGUgR09UTyBgc3RhdGVgXG4gKlxuICogICAgZGVmYXVsdEFjdGlvbnM6IHsuLi59LFxuICpcbiAqICAgIHBhcnNlRXJyb3I6IGZ1bmN0aW9uKHN0ciwgaGFzaCwgRXhjZXB0aW9uQ2xhc3MpLFxuICogICAgeXlFcnJvcjogZnVuY3Rpb24oc3RyLCAuLi4pLFxuICogICAgeXlSZWNvdmVyaW5nOiBmdW5jdGlvbigpLFxuICogICAgeXlFcnJPazogZnVuY3Rpb24oKSxcbiAqICAgIHl5Q2xlYXJJbjogZnVuY3Rpb24oKSxcbiAqXG4gKiAgICBjb25zdHJ1Y3RQYXJzZUVycm9ySW5mbzogZnVuY3Rpb24oZXJyb3JfbWVzc2FnZSwgZXhjZXB0aW9uX29iamVjdCwgZXhwZWN0ZWRfdG9rZW5fc2V0LCBpc19yZWNvdmVyYWJsZSksXG4gKiAgICAgICAgICAgICAgIEhlbHBlciBmdW5jdGlvbiAqKndoaWNoIHdpbGwgYmUgc2V0IHVwIGR1cmluZyB0aGUgZmlyc3QgaW52b2NhdGlvbiBvZiB0aGUgYHBhcnNlKClgIG1ldGhvZCoqLlxuICogICAgICAgICAgICAgICBQcm9kdWNlcyBhIG5ldyBlcnJvckluZm8gJ2hhc2ggb2JqZWN0JyB3aGljaCBjYW4gYmUgcGFzc2VkIGludG8gYHBhcnNlRXJyb3IoKWAuXG4gKiAgICAgICAgICAgICAgIFNlZSBpdCdzIHVzZSBpbiB0aGlzIHBhcnNlciBrZXJuZWwgaW4gbWFueSBwbGFjZXM7IGV4YW1wbGUgdXNhZ2U6XG4gKlxuICogICAgICAgICAgICAgICAgICAgdmFyIGluZm9PYmogPSBwYXJzZXIuY29uc3RydWN0UGFyc2VFcnJvckluZm8oJ2ZhaWwhJywgbnVsbCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5jb2xsZWN0X2V4cGVjdGVkX3Rva2VuX3NldChzdGF0ZSksIHRydWUpO1xuICogICAgICAgICAgICAgICAgICAgdmFyIHJldFZhbCA9IHBhcnNlci5wYXJzZUVycm9yKGluZm9PYmouZXJyU3RyLCBpbmZvT2JqLCBwYXJzZXIuSmlzb25QYXJzZXJFcnJvcik7XG4gKlxuICogICAgb3JpZ2luYWxQYXJzZUVycm9yOiBmdW5jdGlvbihzdHIsIGhhc2gsIEV4Y2VwdGlvbkNsYXNzKSxcbiAqICAgICAgICAgICAgICAgVGhlIGJhc2ljIGBwYXJzZUVycm9yYCBoYW5kbGVyIHByb3ZpZGVkIGJ5IEpJU09OLlxuICogICAgICAgICAgICAgICBgY2xlYW51cEFmdGVyUGFyc2UoKWAgd2lsbCBjbGVhbiB1cCBhbmQgcmVzZXQgYHBhcnNlRXJyb3IoKWAgdG8gcmVmZXJlbmNlIHRoaXMgZnVuY3Rpb25cbiAqICAgICAgICAgICAgICAgYXQgdGhlIGVuZCBvZiB0aGUgYHBhcnNlKClgLlxuICpcbiAqICAgIG9wdGlvbnM6IHsgLi4uIHBhcnNlciAlb3B0aW9ucyAuLi4gfSxcbiAqXG4gKiAgICBwYXJzZTogZnVuY3Rpb24oaW5wdXRbLCBhcmdzLi4uXSksXG4gKiAgICAgICAgICAgICAgIFBhcnNlIHRoZSBnaXZlbiBgaW5wdXRgIGFuZCByZXR1cm4gdGhlIHBhcnNlZCB2YWx1ZSAob3IgYHRydWVgIHdoZW4gbm9uZSB3YXMgcHJvdmlkZWQgYnlcbiAqICAgICAgICAgICAgICAgdGhlIHJvb3QgYWN0aW9uLCBpbiB3aGljaCBjYXNlIHRoZSBwYXJzZXIgaXMgYWN0aW5nIGFzIGEgKm1hdGNoZXIqKS5cbiAqICAgICAgICAgICAgICAgWW91IE1BWSB1c2UgdGhlIGFkZGl0aW9uYWwgYGFyZ3MuLi5gIHBhcmFtZXRlcnMgYXMgcGVyIGAlcGFyc2UtcGFyYW1gIHNwZWMgb2YgdGhpcyBncmFtbWFyOlxuICogICAgICAgICAgICAgICB0aGVzZSBleHRyYSBgYXJncy4uLmAgYXJlIGFkZGVkIHZlcmJhdGltIHRvIHRoZSBgeXlgIG9iamVjdCByZWZlcmVuY2UgYXMgbWVtYmVyIHZhcmlhYmxlcy5cbiAqXG4gKiAgICAgICAgICAgICAgIFdBUk5JTkc6XG4gKiAgICAgICAgICAgICAgIFBhcnNlcidzIGFkZGl0aW9uYWwgYGFyZ3MuLi5gIHBhcmFtZXRlcnMgKHZpYSBgJXBhcnNlLXBhcmFtYCkgTUFZIGNvbmZsaWN0IHdpdGhcbiAqICAgICAgICAgICAgICAgYW55IGF0dHJpYnV0ZXMgYWxyZWFkeSBhZGRlZCB0byBgeXlgIGJ5IHRoZSBqaXNvbiBydW4tdGltZTtcbiAqICAgICAgICAgICAgICAgd2hlbiBzdWNoIGEgY29sbGlzaW9uIGlzIGRldGVjdGVkIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gdG8gcHJldmVudCB0aGUgZ2VuZXJhdGVkIHJ1bi10aW1lXG4gKiAgICAgICAgICAgICAgIGZyb20gc2lsZW50bHkgYWNjZXB0aW5nIHRoaXMgY29uZnVzaW5nIGFuZCBwb3RlbnRpYWxseSBoYXphcmRvdXMgc2l0dWF0aW9uIVxuICpcbiAqICAgICAgICAgICAgICAgVGhlIGxleGVyIE1BWSBhZGQgaXRzIG93biBzZXQgb2YgYWRkaXRpb25hbCBwYXJhbWV0ZXJzICh2aWEgdGhlIGAlcGFyc2UtcGFyYW1gIGxpbmUgaW5cbiAqICAgICAgICAgICAgICAgdGhlIGxleGVyIHNlY3Rpb24gb2YgdGhlIGdyYW1tYXIgc3BlYyk6IHRoZXNlIHdpbGwgYmUgaW5zZXJ0ZWQgaW4gdGhlIGB5eWAgc2hhcmVkIHN0YXRlXG4gKiAgICAgICAgICAgICAgIG9iamVjdCBhbmQgYW55IGNvbGxpc2lvbiB3aXRoIHRob3NlIHdpbGwgYmUgcmVwb3J0ZWQgYnkgdGhlIGxleGVyIHZpYSBhIHRocm93biBleGNlcHRpb24uXG4gKlxuICogICAgY2xlYW51cEFmdGVyUGFyc2U6IGZ1bmN0aW9uKHJlc3VsdFZhbHVlLCBpbnZva2VfcG9zdF9tZXRob2RzLCBkb19ub3RfbnVrZV9lcnJvcmluZm9zKSxcbiAqICAgICAgICAgICAgICAgSGVscGVyIGZ1bmN0aW9uICoqd2hpY2ggd2lsbCBiZSBzZXQgdXAgZHVyaW5nIHRoZSBmaXJzdCBpbnZvY2F0aW9uIG9mIHRoZSBgcGFyc2UoKWAgbWV0aG9kKiouXG4gKiAgICAgICAgICAgICAgIFRoaXMgaGVscGVyIEFQSSBpcyBpbnZva2VkIGF0IHRoZSBlbmQgb2YgdGhlIGBwYXJzZSgpYCBjYWxsLCB1bmxlc3MgYW4gZXhjZXB0aW9uIHdhcyB0aHJvd25cbiAqICAgICAgICAgICAgICAgYW5kIGAlb3B0aW9ucyBuby10cnktY2F0Y2hgIGhhcyBiZWVuIGRlZmluZWQgZm9yIHRoaXMgZ3JhbW1hcjogaW4gdGhhdCBjYXNlIHRoaXMgaGVscGVyIE1BWVxuICogICAgICAgICAgICAgICBiZSBpbnZva2VkIGJ5IGNhbGxpbmcgdXNlciBjb2RlIHRvIGVuc3VyZSB0aGUgYHBvc3RfcGFyc2VgIGNhbGxiYWNrcyBhcmUgaW52b2tlZCBhbmRcbiAqICAgICAgICAgICAgICAgdGhlIGludGVybmFsIHBhcnNlciBnZXRzIHByb3Blcmx5IGdhcmJhZ2UgY29sbGVjdGVkIHVuZGVyIHRoZXNlIHBhcnRpY3VsYXIgY2lyY3Vtc3RhbmNlcy5cbiAqXG4gKiAgICB5eU1lcmdlTG9jYXRpb25JbmZvOiBmdW5jdGlvbihmaXJzdF9pbmRleCwgbGFzdF9pbmRleCwgZmlyc3RfeXlsbG9jLCBsYXN0X3l5bGxvYywgZG9udF9sb29rX2JhY2spLFxuICogICAgICAgICAgICAgICBIZWxwZXIgZnVuY3Rpb24gKip3aGljaCB3aWxsIGJlIHNldCB1cCBkdXJpbmcgdGhlIGZpcnN0IGludm9jYXRpb24gb2YgdGhlIGBwYXJzZSgpYCBtZXRob2QqKi5cbiAqICAgICAgICAgICAgICAgVGhpcyBoZWxwZXIgQVBJIGNhbiBiZSBpbnZva2VkIHRvIGNhbGN1bGF0ZSBhIHNwYW5uaW5nIGB5eWxsb2NgIGxvY2F0aW9uIGluZm8gb2JqZWN0LlxuICpcbiAqICAgICAgICAgICAgICAgTm90ZTogJWVwc2lsb24gcnVsZXMgTUFZIHNwZWNpZnkgbm8gYGZpcnN0X2luZGV4YCBhbmQgYGZpcnN0X3l5bGxvY2AsIGluIHdoaWNoIGNhc2VcbiAqICAgICAgICAgICAgICAgdGhpcyBmdW5jdGlvbiB3aWxsIGF0dGVtcHQgdG8gb2J0YWluIGEgc3VpdGFibGUgbG9jYXRpb24gbWFya2VyIGJ5IGluc3BlY3RpbmcgdGhlIGxvY2F0aW9uIHN0YWNrXG4gKiAgICAgICAgICAgICAgIGJhY2t3YXJkcy5cbiAqXG4gKiAgICAgICAgICAgICAgIEZvciBtb3JlIGluZm8gc2VlIHRoZSBkb2N1bWVudGF0aW9uIGNvbW1lbnQgZnVydGhlciBiZWxvdywgaW1tZWRpYXRlbHkgYWJvdmUgdGhpcyBmdW5jdGlvbidzXG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uLlxuICpcbiAqICAgIGxleGVyOiB7XG4gKiAgICAgICAgeXk6IHsuLi59LCAgICAgICAgICAgQSByZWZlcmVuY2UgdG8gdGhlIHNvLWNhbGxlZCBcInNoYXJlZCBzdGF0ZVwiIGB5eWAgb25jZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkIHZpYSBhIGNhbGwgdG8gdGhlIGAuc2V0SW5wdXQoaW5wdXQsIHl5KWAgbGV4ZXIgQVBJLlxuICogICAgICAgIEVPRjogMSxcbiAqICAgICAgICBFUlJPUjogMixcbiAqICAgICAgICBKaXNvbkxleGVyRXJyb3I6IGZ1bmN0aW9uKG1zZywgaGFzaCksXG4gKiAgICAgICAgcGFyc2VFcnJvcjogZnVuY3Rpb24oc3RyLCBoYXNoLCBFeGNlcHRpb25DbGFzcyksXG4gKiAgICAgICAgc2V0SW5wdXQ6IGZ1bmN0aW9uKGlucHV0LCBbeXldKSxcbiAqICAgICAgICBpbnB1dDogZnVuY3Rpb24oKSxcbiAqICAgICAgICB1bnB1dDogZnVuY3Rpb24oc3RyKSxcbiAqICAgICAgICBtb3JlOiBmdW5jdGlvbigpLFxuICogICAgICAgIHJlamVjdDogZnVuY3Rpb24oKSxcbiAqICAgICAgICBsZXNzOiBmdW5jdGlvbihuKSxcbiAqICAgICAgICBwYXN0SW5wdXQ6IGZ1bmN0aW9uKG4pLFxuICogICAgICAgIHVwY29taW5nSW5wdXQ6IGZ1bmN0aW9uKG4pLFxuICogICAgICAgIHNob3dQb3NpdGlvbjogZnVuY3Rpb24oKSxcbiAqICAgICAgICB0ZXN0X21hdGNoOiBmdW5jdGlvbihyZWdleF9tYXRjaF9hcnJheSwgcnVsZV9pbmRleCwgLi4uKSxcbiAqICAgICAgICBuZXh0OiBmdW5jdGlvbiguLi4pLFxuICogICAgICAgIGxleDogZnVuY3Rpb24oLi4uKSxcbiAqICAgICAgICBiZWdpbjogZnVuY3Rpb24oY29uZGl0aW9uKSxcbiAqICAgICAgICBwdXNoU3RhdGU6IGZ1bmN0aW9uKGNvbmRpdGlvbiksXG4gKiAgICAgICAgcG9wU3RhdGU6IGZ1bmN0aW9uKCksXG4gKiAgICAgICAgdG9wU3RhdGU6IGZ1bmN0aW9uKCksXG4gKiAgICAgICAgX2N1cnJlbnRSdWxlczogZnVuY3Rpb24oKSxcbiAqICAgICAgICBzdGF0ZVN0YWNrU2l6ZTogZnVuY3Rpb24oKSxcbiAqICAgICAgICBjbGVhbnVwQWZ0ZXJMZXg6IGZ1bmN0aW9uKClcbiAqXG4gKiAgICAgICAgb3B0aW9uczogeyAuLi4gbGV4ZXIgJW9wdGlvbnMgLi4uIH0sXG4gKlxuICogICAgICAgIHBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uKHl5LCB5eV8sICRhdm9pZGluZ19uYW1lX2NvbGxpc2lvbnMsIFlZX1NUQVJULCAuLi4pLFxuICogICAgICAgIHJ1bGVzOiBbLi4uXSxcbiAqICAgICAgICBjb25kaXRpb25zOiB7YXNzb2NpYXRpdmUgbGlzdDogbmFtZSA9PT4gc2V0fSxcbiAqICAgIH1cbiAqICB9XG4gKlxuICpcbiAqICB0b2tlbiBsb2NhdGlvbiBpbmZvIChAJCwgXyQsIGV0Yy4pOiB7XG4gKiAgICBmaXJzdF9saW5lOiBuLFxuICogICAgbGFzdF9saW5lOiBuLFxuICogICAgZmlyc3RfY29sdW1uOiBuLFxuICogICAgbGFzdF9jb2x1bW46IG4sXG4gKiAgICByYW5nZTogW3N0YXJ0X251bWJlciwgZW5kX251bWJlcl1cbiAqICAgICAgICAgICAgICAgKHdoZXJlIHRoZSBudW1iZXJzIGFyZSBpbmRleGVzIGludG8gdGhlIGlucHV0IHN0cmluZywgemVyby1iYXNlZClcbiAqICB9XG4gKlxuICogLS0tXG4gKlxuICogVGhlIGBwYXJzZUVycm9yYCBmdW5jdGlvbiByZWNlaXZlcyBhICdoYXNoJyBvYmplY3Qgd2l0aCB0aGVzZSBtZW1iZXJzIGZvciBsZXhlciBhbmRcbiAqIHBhcnNlciBlcnJvcnM6XG4gKlxuICogIHtcbiAqICAgIHRleHQ6ICAgICAgICAobWF0Y2hlZCB0ZXh0KVxuICogICAgdG9rZW46ICAgICAgICh0aGUgcHJvZHVjZWQgdGVybWluYWwgdG9rZW4sIGlmIGFueSlcbiAqICAgIHRva2VuX2lkOiAgICAodGhlIHByb2R1Y2VkIHRlcm1pbmFsIHRva2VuIG51bWVyaWMgSUQsIGlmIGFueSlcbiAqICAgIGxpbmU6ICAgICAgICAoeXlsaW5lbm8pXG4gKiAgICBsb2M6ICAgICAgICAgKHl5bGxvYylcbiAqICB9XG4gKlxuICogcGFyc2VyIChncmFtbWFyKSBlcnJvcnMgd2lsbCBhbHNvIHByb3ZpZGUgdGhlc2UgYWRkaXRpb25hbCBtZW1iZXJzOlxuICpcbiAqICB7XG4gKiAgICBleHBlY3RlZDogICAgKGFycmF5IGRlc2NyaWJpbmcgdGhlIHNldCBvZiBleHBlY3RlZCB0b2tlbnM7XG4gKiAgICAgICAgICAgICAgICAgIG1heSBiZSBVTkRFRklORUQgd2hlbiB3ZSBjYW5ub3QgZWFzaWx5IHByb2R1Y2Ugc3VjaCBhIHNldClcbiAqICAgIHN0YXRlOiAgICAgICAoaW50ZWdlciAob3IgYXJyYXkgd2hlbiB0aGUgdGFibGUgaW5jbHVkZXMgZ3JhbW1hciBjb2xsaXNpb25zKTtcbiAqICAgICAgICAgICAgICAgICAgcmVwcmVzZW50cyB0aGUgY3VycmVudCBpbnRlcm5hbCBzdGF0ZSBvZiB0aGUgcGFyc2VyIGtlcm5lbC5cbiAqICAgICAgICAgICAgICAgICAgY2FuLCBmb3IgZXhhbXBsZSwgYmUgdXNlZCB0byBwYXNzIHRvIHRoZSBgY29sbGVjdF9leHBlY3RlZF90b2tlbl9zZXQoKWBcbiAqICAgICAgICAgICAgICAgICAgQVBJIHRvIG9idGFpbiB0aGUgZXhwZWN0ZWQgdG9rZW4gc2V0KVxuICogICAgYWN0aW9uOiAgICAgIChpbnRlZ2VyOyByZXByZXNlbnRzIHRoZSBjdXJyZW50IGludGVybmFsIGFjdGlvbiB3aGljaCB3aWxsIGJlIGV4ZWN1dGVkKVxuICogICAgbmV3X3N0YXRlOiAgIChpbnRlZ2VyOyByZXByZXNlbnRzIHRoZSBuZXh0L3BsYW5uZWQgaW50ZXJuYWwgc3RhdGUsIG9uY2UgdGhlIGN1cnJlbnRcbiAqICAgICAgICAgICAgICAgICAgYWN0aW9uIGhhcyBleGVjdXRlZClcbiAqICAgIHJlY292ZXJhYmxlOiAoYm9vbGVhbjogVFJVRSB3aGVuIHRoZSBwYXJzZXIgTUFZIGhhdmUgYW4gZXJyb3IgcmVjb3ZlcnkgcnVsZVxuICogICAgICAgICAgICAgICAgICBhdmFpbGFibGUgZm9yIHRoaXMgcGFydGljdWxhciBlcnJvcilcbiAqICAgIHN0YXRlX3N0YWNrOiAoYXJyYXk6IHRoZSBjdXJyZW50IHBhcnNlciBMQUxSL0xSIGludGVybmFsIHN0YXRlIHN0YWNrOyB0aGlzIGNhbiBiZSB1c2VkLFxuICogICAgICAgICAgICAgICAgICBmb3IgaW5zdGFuY2UsIGZvciBhZHZhbmNlZCBlcnJvciBhbmFseXNpcyBhbmQgcmVwb3J0aW5nKVxuICogICAgdmFsdWVfc3RhY2s6IChhcnJheTogdGhlIGN1cnJlbnQgcGFyc2VyIExBTFIvTFIgaW50ZXJuYWwgYCQkYCB2YWx1ZSBzdGFjazsgdGhpcyBjYW4gYmUgdXNlZCxcbiAqICAgICAgICAgICAgICAgICAgZm9yIGluc3RhbmNlLCBmb3IgYWR2YW5jZWQgZXJyb3IgYW5hbHlzaXMgYW5kIHJlcG9ydGluZylcbiAqICAgIGxvY2F0aW9uX3N0YWNrOiAoYXJyYXk6IHRoZSBjdXJyZW50IHBhcnNlciBMQUxSL0xSIGludGVybmFsIGxvY2F0aW9uIHN0YWNrOyB0aGlzIGNhbiBiZSB1c2VkLFxuICogICAgICAgICAgICAgICAgICBmb3IgaW5zdGFuY2UsIGZvciBhZHZhbmNlZCBlcnJvciBhbmFseXNpcyBhbmQgcmVwb3J0aW5nKVxuICogICAgeXk6ICAgICAgICAgIChvYmplY3Q6IHRoZSBjdXJyZW50IHBhcnNlciBpbnRlcm5hbCBcInNoYXJlZCBzdGF0ZVwiIGB5eWBcbiAqICAgICAgICAgICAgICAgICAgYXMgaXMgYWxzbyBhdmFpbGFibGUgaW4gdGhlIHJ1bGUgYWN0aW9uczsgdGhpcyBjYW4gYmUgdXNlZCxcbiAqICAgICAgICAgICAgICAgICAgZm9yIGluc3RhbmNlLCBmb3IgYWR2YW5jZWQgZXJyb3IgYW5hbHlzaXMgYW5kIHJlcG9ydGluZylcbiAqICAgIGxleGVyOiAgICAgICAocmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGxleGVyIGluc3RhbmNlIHVzZWQgYnkgdGhlIHBhcnNlcilcbiAqICAgIHBhcnNlcjogICAgICAocmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IHBhcnNlciBpbnN0YW5jZSlcbiAqICB9XG4gKlxuICogd2hpbGUgYHRoaXNgIHdpbGwgcmVmZXJlbmNlIHRoZSBjdXJyZW50IHBhcnNlciBpbnN0YW5jZS5cbiAqXG4gKiBXaGVuIGBwYXJzZUVycm9yYCBpcyBpbnZva2VkIGJ5IHRoZSBsZXhlciwgYHRoaXNgIHdpbGwgc3RpbGwgcmVmZXJlbmNlIHRoZSByZWxhdGVkICpwYXJzZXIqXG4gKiBpbnN0YW5jZSwgd2hpbGUgdGhlc2UgYWRkaXRpb25hbCBgaGFzaGAgZmllbGRzIHdpbGwgYWxzbyBiZSBwcm92aWRlZDpcbiAqXG4gKiAge1xuICogICAgbGV4ZXI6ICAgICAgIChyZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgbGV4ZXIgaW5zdGFuY2Ugd2hpY2ggcmVwb3J0ZWQgdGhlIGVycm9yKVxuICogIH1cbiAqXG4gKiBXaGVuIGBwYXJzZUVycm9yYCBpcyBpbnZva2VkIGJ5IHRoZSBwYXJzZXIgZHVlIHRvIGEgKipKYXZhU2NyaXB0IGV4Y2VwdGlvbioqIGJlaW5nIGZpcmVkXG4gKiBmcm9tIGVpdGhlciB0aGUgcGFyc2VyIG9yIGxleGVyLCBgdGhpc2Agd2lsbCBzdGlsbCByZWZlcmVuY2UgdGhlIHJlbGF0ZWQgKnBhcnNlcipcbiAqIGluc3RhbmNlLCB3aGlsZSB0aGVzZSBhZGRpdGlvbmFsIGBoYXNoYCBmaWVsZHMgd2lsbCBhbHNvIGJlIHByb3ZpZGVkOlxuICpcbiAqICB7XG4gKiAgICBleGNlcHRpb246ICAgKHJlZmVyZW5jZSB0byB0aGUgZXhjZXB0aW9uIHRocm93bilcbiAqICB9XG4gKlxuICogUGxlYXNlIGRvIG5vdGUgdGhhdCBpbiB0aGUgbGF0dGVyIHNpdHVhdGlvbiwgdGhlIGBleHBlY3RlZGAgZmllbGQgd2lsbCBiZSBvbWl0dGVkIGFzXG4gKiB0aGlzIHR5cGUgb2YgZmFpbHVyZSBpcyBhc3N1bWVkIG5vdCB0byBiZSBkdWUgdG8gKnBhcnNlIGVycm9ycyogYnV0IHJhdGhlciBkdWUgdG8gdXNlclxuICogYWN0aW9uIGNvZGUgaW4gZWl0aGVyIHBhcnNlciBvciBsZXhlciBmYWlsaW5nIHVuZXhwZWN0ZWRseS5cbiAqXG4gKiAtLS1cbiAqXG4gKiBZb3UgY2FuIHNwZWNpZnkgcGFyc2VyIG9wdGlvbnMgYnkgc2V0dGluZyAvIG1vZGlmeWluZyB0aGUgYC55eWAgb2JqZWN0IG9mIHlvdXIgUGFyc2VyIGluc3RhbmNlLlxuICogVGhlc2Ugb3B0aW9ucyBhcmUgYXZhaWxhYmxlOlxuICpcbiAqICMjIyBvcHRpb25zIHdoaWNoIGFyZSBnbG9iYWwgZm9yIGFsbCBwYXJzZXIgaW5zdGFuY2VzXG4gKlxuICogIFBhcnNlci5wcmVfcGFyc2U6IGZ1bmN0aW9uKHl5KVxuICogICAgICAgICAgICAgICAgIG9wdGlvbmFsOiB5b3UgY2FuIHNwZWNpZnkgYSBwcmVfcGFyc2UoKSBmdW5jdGlvbiBpbiB0aGUgY2h1bmsgZm9sbG93aW5nXG4gKiAgICAgICAgICAgICAgICAgdGhlIGdyYW1tYXIsIGkuZS4gYWZ0ZXIgdGhlIGxhc3QgYCUlYC5cbiAqICBQYXJzZXIucG9zdF9wYXJzZTogZnVuY3Rpb24oeXksIHJldHZhbCwgcGFyc2VJbmZvKSB7IHJldHVybiByZXR2YWw7IH1cbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogeW91IGNhbiBzcGVjaWZ5IGEgcG9zdF9wYXJzZSgpIGZ1bmN0aW9uIGluIHRoZSBjaHVuayBmb2xsb3dpbmdcbiAqICAgICAgICAgICAgICAgICB0aGUgZ3JhbW1hciwgaS5lLiBhZnRlciB0aGUgbGFzdCBgJSVgLiBXaGVuIGl0IGRvZXMgbm90IHJldHVybiBhbnkgdmFsdWUsXG4gKiAgICAgICAgICAgICAgICAgdGhlIHBhcnNlciB3aWxsIHJldHVybiB0aGUgb3JpZ2luYWwgYHJldHZhbGAuXG4gKlxuICogIyMjIG9wdGlvbnMgd2hpY2ggY2FuIGJlIHNldCB1cCBwZXIgcGFyc2VyIGluc3RhbmNlXG4gKlxuICogIHl5OiB7XG4gKiAgICAgIHByZV9wYXJzZTogIGZ1bmN0aW9uKHl5KVxuICogICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBpcyBpbnZva2VkIGJlZm9yZSB0aGUgcGFyc2UgY3ljbGUgc3RhcnRzIChhbmQgYmVmb3JlIHRoZSBmaXJzdFxuICogICAgICAgICAgICAgICAgIGludm9jYXRpb24gb2YgYGxleCgpYCkgYnV0IGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBpbnZvY2F0aW9uIG9mXG4gKiAgICAgICAgICAgICAgICAgYHBhcnNlci5wcmVfcGFyc2UoKWApLlxuICogICAgICBwb3N0X3BhcnNlOiBmdW5jdGlvbih5eSwgcmV0dmFsLCBwYXJzZUluZm8pIHsgcmV0dXJuIHJldHZhbDsgfVxuICogICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBpcyBpbnZva2VkIHdoZW4gdGhlIHBhcnNlIHRlcm1pbmF0ZXMgZHVlIHRvIHN1Y2Nlc3MgKCdhY2NlcHQnKVxuICogICAgICAgICAgICAgICAgIG9yIGZhaWx1cmUgKGV2ZW4gd2hlbiBleGNlcHRpb25zIGFyZSB0aHJvd24pLlxuICogICAgICAgICAgICAgICAgIGByZXR2YWxgIGNvbnRhaW5zIHRoZSByZXR1cm4gdmFsdWUgdG8gYmUgcHJvZHVjZWQgYnkgYFBhcnNlci5wYXJzZSgpYDtcbiAqICAgICAgICAgICAgICAgICB0aGlzIGZ1bmN0aW9uIGNhbiBvdmVycmlkZSB0aGUgcmV0dXJuIHZhbHVlIGJ5IHJldHVybmluZyBhbm90aGVyLlxuICogICAgICAgICAgICAgICAgIFdoZW4gaXQgZG9lcyBub3QgcmV0dXJuIGFueSB2YWx1ZSwgdGhlIHBhcnNlciB3aWxsIHJldHVybiB0aGUgb3JpZ2luYWxcbiAqICAgICAgICAgICAgICAgICBgcmV0dmFsYC5cbiAqICAgICAgICAgICAgICAgICBUaGlzIGZ1bmN0aW9uIGlzIGludm9rZWQgaW1tZWRpYXRlbHkgYmVmb3JlIGBwYXJzZXIucG9zdF9wYXJzZSgpYC5cbiAqXG4gKiAgICAgIHBhcnNlRXJyb3I6IGZ1bmN0aW9uKHN0ciwgaGFzaCwgRXhjZXB0aW9uQ2xhc3MpXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IG92ZXJyaWRlcyB0aGUgZGVmYXVsdCBgcGFyc2VFcnJvcmAgZnVuY3Rpb24uXG4gKiAgICAgIHF1b3RlTmFtZTogZnVuY3Rpb24obmFtZSksXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IG92ZXJyaWRlcyB0aGUgZGVmYXVsdCBgcXVvdGVOYW1lYCBmdW5jdGlvbi5cbiAqICB9XG4gKlxuICogIHBhcnNlci5sZXhlci5vcHRpb25zOiB7XG4gKiAgICAgIHByZV9sZXg6ICBmdW5jdGlvbigpXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IGlzIGludm9rZWQgYmVmb3JlIHRoZSBsZXhlciBpcyBpbnZva2VkIHRvIHByb2R1Y2UgYW5vdGhlciB0b2tlbi5cbiAqICAgICAgICAgICAgICAgICBgdGhpc2AgcmVmZXJzIHRvIHRoZSBMZXhlciBvYmplY3QuXG4gKiAgICAgIHBvc3RfbGV4OiBmdW5jdGlvbih0b2tlbikgeyByZXR1cm4gdG9rZW47IH1cbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogaXMgaW52b2tlZCB3aGVuIHRoZSBsZXhlciBoYXMgcHJvZHVjZWQgYSB0b2tlbiBgdG9rZW5gO1xuICogICAgICAgICAgICAgICAgIHRoaXMgZnVuY3Rpb24gY2FuIG92ZXJyaWRlIHRoZSByZXR1cm5lZCB0b2tlbiB2YWx1ZSBieSByZXR1cm5pbmcgYW5vdGhlci5cbiAqICAgICAgICAgICAgICAgICBXaGVuIGl0IGRvZXMgbm90IHJldHVybiBhbnkgKHRydXRoeSkgdmFsdWUsIHRoZSBsZXhlciB3aWxsIHJldHVyblxuICogICAgICAgICAgICAgICAgIHRoZSBvcmlnaW5hbCBgdG9rZW5gLlxuICogICAgICAgICAgICAgICAgIGB0aGlzYCByZWZlcnMgdG8gdGhlIExleGVyIG9iamVjdC5cbiAqXG4gKiAgICAgIHJhbmdlczogYm9vbGVhblxuICogICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBgdHJ1ZWAgPT0+IHRva2VuIGxvY2F0aW9uIGluZm8gd2lsbCBpbmNsdWRlIGEgLnJhbmdlW10gbWVtYmVyLlxuICogICAgICBmbGV4OiBib29sZWFuXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IGB0cnVlYCA9PT4gZmxleC1saWtlIGxleGluZyBiZWhhdmlvdXIgd2hlcmUgdGhlIHJ1bGVzIGFyZSB0ZXN0ZWRcbiAqICAgICAgICAgICAgICAgICBleGhhdXN0aXZlbHkgdG8gZmluZCB0aGUgbG9uZ2VzdCBtYXRjaC5cbiAqICAgICAgYmFja3RyYWNrX2xleGVyOiBib29sZWFuXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IGB0cnVlYCA9PT4gbGV4ZXIgcmVnZXhlcyBhcmUgdGVzdGVkIGluIG9yZGVyIGFuZCBmb3IgaW52b2tlZDtcbiAqICAgICAgICAgICAgICAgICB0aGUgbGV4ZXIgdGVybWluYXRlcyB0aGUgc2NhbiB3aGVuIGEgdG9rZW4gaXMgcmV0dXJuZWQgYnkgdGhlIGFjdGlvbiBjb2RlLlxuICogICAgICB4cmVnZXhwOiBib29sZWFuXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IGB0cnVlYCA9PT4gbGV4ZXIgcnVsZSByZWdleGVzIGFyZSBcImV4dGVuZGVkIHJlZ2V4IGZvcm1hdFwiIHJlcXVpcmluZyB0aGVcbiAqICAgICAgICAgICAgICAgICBgWFJlZ0V4cGAgbGlicmFyeS4gV2hlbiB0aGlzIGAlb3B0aW9uYCBoYXMgbm90IGJlZW4gc3BlY2lmaWVkIGF0IGNvbXBpbGUgdGltZSwgYWxsIGxleGVyXG4gKiAgICAgICAgICAgICAgICAgcnVsZSByZWdleGVzIGhhdmUgYmVlbiB3cml0dGVuIGFzIHN0YW5kYXJkIEphdmFTY3JpcHQgUmVnRXhwIGV4cHJlc3Npb25zLlxuICogIH1cbiAqL1xuXG4gICAgICAgIFxuICAgIFxuICAgICAgICAgICAgdmFyIFBhcnNlciA9IChmdW5jdGlvbiAoKSB7XG5cbi8vIFNlZSBhbHNvOlxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzgyMTA3L3doYXRzLWEtZ29vZC13YXktdG8tZXh0ZW5kLWVycm9yLWluLWphdmFzY3JpcHQvIzM1ODgxNTA4XG4vLyBidXQgd2Uga2VlcCB0aGUgcHJvdG90eXBlLmNvbnN0cnVjdG9yIGFuZCBwcm90b3R5cGUubmFtZSBhc3NpZ25tZW50IGxpbmVzIHRvbyBmb3IgY29tcGF0aWJpbGl0eVxuLy8gd2l0aCB1c2VybGFuZCBjb2RlIHdoaWNoIG1pZ2h0IGFjY2VzcyB0aGUgZGVyaXZlZCBjbGFzcyBpbiBhICdjbGFzc2ljJyB3YXkuXG5mdW5jdGlvbiBKaXNvblBhcnNlckVycm9yKG1zZywgaGFzaCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbmFtZScsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6ICdKaXNvblBhcnNlckVycm9yJ1xuICAgIH0pO1xuXG4gICAgaWYgKG1zZyA9PSBudWxsKSBtc2cgPSAnPz8/JztcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbWVzc2FnZScsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogbXNnXG4gICAgfSk7XG5cbiAgICB0aGlzLmhhc2ggPSBoYXNoO1xuXG4gICAgdmFyIHN0YWNrdHJhY2U7XG4gICAgaWYgKGhhc2ggJiYgaGFzaC5leGNlcHRpb24gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB2YXIgZXgyID0gaGFzaC5leGNlcHRpb247XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGV4Mi5tZXNzYWdlIHx8IG1zZztcbiAgICAgICAgc3RhY2t0cmFjZSA9IGV4Mi5zdGFjaztcbiAgICB9XG4gICAgaWYgKCFzdGFja3RyYWNlKSB7XG4gICAgICAgIGlmIChFcnJvci5oYXNPd25Qcm9wZXJ0eSgnY2FwdHVyZVN0YWNrVHJhY2UnKSkgeyAgICAgICAgLy8gVjgvQ2hyb21lIGVuZ2luZVxuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFja3RyYWNlID0gKG5ldyBFcnJvcihtc2cpKS5zdGFjaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhY2t0cmFjZSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3N0YWNrJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogc3RhY2t0cmFjZVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmlmICh0eXBlb2YgT2JqZWN0LnNldFByb3RvdHlwZU9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKEppc29uUGFyc2VyRXJyb3IucHJvdG90eXBlLCBFcnJvci5wcm90b3R5cGUpO1xufSBlbHNlIHtcbiAgICBKaXNvblBhcnNlckVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbn1cbkppc29uUGFyc2VyRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSmlzb25QYXJzZXJFcnJvcjtcbkppc29uUGFyc2VyRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnSmlzb25QYXJzZXJFcnJvcic7XG5cblxuXG4gICAgICAgIC8vIGhlbHBlcjogcmVjb25zdHJ1Y3QgdGhlIHByb2R1Y3Rpb25zW10gdGFibGVcbiAgICAgICAgZnVuY3Rpb24gYnAocykge1xuICAgICAgICAgICAgdmFyIHJ2ID0gW107XG4gICAgICAgICAgICB2YXIgcCA9IHMucG9wO1xuICAgICAgICAgICAgdmFyIHIgPSBzLnJ1bGU7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHAubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcnYucHVzaChbXG4gICAgICAgICAgICAgICAgICAgIHBbaV0sXG4gICAgICAgICAgICAgICAgICAgIHJbaV1cbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgfVxuICAgIFxuXG5cbiAgICAgICAgLy8gaGVscGVyOiByZWNvbnN0cnVjdCB0aGUgZGVmYXVsdEFjdGlvbnNbXSB0YWJsZVxuICAgICAgICBmdW5jdGlvbiBiZGEocykge1xuICAgICAgICAgICAgdmFyIHJ2ID0ge307XG4gICAgICAgICAgICB2YXIgZCA9IHMuaWR4O1xuICAgICAgICAgICAgdmFyIGcgPSBzLmdvdG87XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGogPSBkW2ldO1xuICAgICAgICAgICAgICAgIHJ2W2pdID0gZ1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgfVxuICAgIFxuXG5cbiAgICAgICAgLy8gaGVscGVyOiByZWNvbnN0cnVjdCB0aGUgJ2dvdG8nIHRhYmxlXG4gICAgICAgIGZ1bmN0aW9uIGJ0KHMpIHtcbiAgICAgICAgICAgIHZhciBydiA9IFtdO1xuICAgICAgICAgICAgdmFyIGQgPSBzLmxlbjtcbiAgICAgICAgICAgIHZhciB5ID0gcy5zeW1ib2w7XG4gICAgICAgICAgICB2YXIgdCA9IHMudHlwZTtcbiAgICAgICAgICAgIHZhciBhID0gcy5zdGF0ZTtcbiAgICAgICAgICAgIHZhciBtID0gcy5tb2RlO1xuICAgICAgICAgICAgdmFyIGcgPSBzLmdvdG87XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSBkW2ldO1xuICAgICAgICAgICAgICAgIHZhciBxID0ge307XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHogPSB5LnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodC5zaGlmdCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHFbel0gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5zaGlmdCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGcuc2hpZnQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHFbel0gPSBhLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHlwZSA9PT0gMTogYWNjZXB0XG4gICAgICAgICAgICAgICAgICAgICAgICBxW3pdID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDNcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcnYucHVzaChxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgfVxuICAgIFxuXG5cbiAgICAgICAgLy8gaGVscGVyOiBydW5sZW5ndGggZW5jb2Rpbmcgd2l0aCBpbmNyZW1lbnQgc3RlcDogY29kZSwgbGVuZ3RoOiBzdGVwIChkZWZhdWx0IHN0ZXAgPSAwKVxuICAgICAgICAvLyBgdGhpc2AgcmVmZXJlbmNlcyBhbiBhcnJheVxuICAgICAgICBmdW5jdGlvbiBzKGMsIGwsIGEpIHtcbiAgICAgICAgICAgIGEgPSBhIHx8IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaChjKTtcbiAgICAgICAgICAgICAgICBjICs9IGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoZWxwZXI6IGR1cGxpY2F0ZSBzZXF1ZW5jZSBmcm9tICpyZWxhdGl2ZSogb2Zmc2V0IGFuZCBsZW5ndGguXG4gICAgICAgIC8vIGB0aGlzYCByZWZlcmVuY2VzIGFuIGFycmF5XG4gICAgICAgIGZ1bmN0aW9uIGMoaSwgbCkge1xuICAgICAgICAgICAgaSA9IHRoaXMubGVuZ3RoIC0gaTtcbiAgICAgICAgICAgIGZvciAobCArPSBpOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoKHRoaXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGVscGVyOiB1bnBhY2sgYW4gYXJyYXkgdXNpbmcgaGVscGVycyBhbmQgZGF0YSwgYWxsIHBhc3NlZCBpbiBhbiBhcnJheSBhcmd1bWVudCAnYScuXG4gICAgICAgIGZ1bmN0aW9uIHUoYSkge1xuICAgICAgICAgICAgdmFyIHJ2ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBhW2ldO1xuICAgICAgICAgICAgICAgIC8vIElzIHRoaXMgZW50cnkgYSBoZWxwZXIgZnVuY3Rpb24/XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBseShydiwgYVtpXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcnYucHVzaChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgIH1cbiAgICBcblxudmFyIHBhcnNlciA9IHtcbiAgICAvLyBDb2RlIEdlbmVyYXRvciBJbmZvcm1hdGlvbiBSZXBvcnRcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vIE9wdGlvbnM6XG4gICAgLy9cbiAgICAvLyAgIGRlZmF1bHQgYWN0aW9uIG1vZGU6IC4uLi4uLi4uLi4uLi4gY2xhc3NpYyxtZXJnZVxuICAgIC8vICAgbm8gdHJ5Li5jYXRjaDogLi4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgbm8gZGVmYXVsdCByZXNvbHZlIG9uIGNvbmZsaWN0OiAgICBmYWxzZVxuICAgIC8vICAgb24tZGVtYW5kIGxvb2stYWhlYWQ6IC4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgZXJyb3IgcmVjb3ZlcnkgdG9rZW4gc2tpcCBtYXhpbXVtOiAzXG4gICAgLy8gICB5eWVycm9yIGluIHBhcnNlIGFjdGlvbnMgaXM6IC4uLi4uIE5PVCByZWNvdmVyYWJsZSxcbiAgICAvLyAgIHl5ZXJyb3IgaW4gbGV4ZXIgYWN0aW9ucyBhbmQgb3RoZXIgbm9uLWZhdGFsIGxleGVyIGFyZTpcbiAgICAvLyAgIC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4gTk9UIHJlY292ZXJhYmxlLFxuICAgIC8vICAgZGVidWcgZ3JhbW1hci9vdXRwdXQ6IC4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgaGFzIHBhcnRpYWwgTFIgY29uZmxpY3QgdXBncmFkZTogICB0cnVlXG4gICAgLy8gICBydWRpbWVudGFyeSB0b2tlbi1zdGFjayBzdXBwb3J0OiAgIGZhbHNlXG4gICAgLy8gICBwYXJzZXIgdGFibGUgY29tcHJlc3Npb24gbW9kZTogLi4uIDJcbiAgICAvLyAgIGV4cG9ydCBkZWJ1ZyB0YWJsZXM6IC4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIGV4cG9ydCAqYWxsKiB0YWJsZXM6IC4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIG1vZHVsZSB0eXBlOiAuLi4uLi4uLi4uLi4uLi4uLi4uLi4gY29tbW9uanNcbiAgICAvLyAgIHBhcnNlciBlbmdpbmUgdHlwZTogLi4uLi4uLi4uLi4uLi4gbGFsclxuICAgIC8vICAgb3V0cHV0IG1haW4oKSBpbiB0aGUgbW9kdWxlOiAuLi4uLiB0cnVlXG4gICAgLy8gICBoYXMgdXNlci1zcGVjaWZpZWQgbWFpbigpOiAuLi4uLi4uIGZhbHNlXG4gICAgLy8gICBoYXMgdXNlci1zcGVjaWZpZWQgcmVxdWlyZSgpL2ltcG9ydCBtb2R1bGVzIGZvciBtYWluKCk6IFxuICAgIC8vICAgLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgbnVtYmVyIG9mIGV4cGVjdGVkIGNvbmZsaWN0czogLi4uLiAwXG4gICAgLy9cbiAgICAvL1xuICAgIC8vIFBhcnNlciBBbmFseXNpcyBmbGFnczpcbiAgICAvL1xuICAgIC8vICAgbm8gc2lnbmlmaWNhbnQgYWN0aW9ucyAocGFyc2VyIGlzIGEgbGFuZ3VhZ2UgbWF0Y2hlciBvbmx5KTpcbiAgICAvLyAgIC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIHVzZXMgeXlsZW5nOiAuLi4uLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIHVzZXMgeXlsaW5lbm86IC4uLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIHVzZXMgeXl0ZXh0OiAuLi4uLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIHVzZXMgeXlsbG9jOiAuLi4uLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIHVzZXMgUGFyc2VFcnJvciBBUEk6IC4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIHVzZXMgWVlFUlJPUjogLi4uLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIHVzZXMgWVlSRUNPVkVSSU5HOiAuLi4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIHVzZXMgWVlFUlJPSzogLi4uLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIHVzZXMgWVlDTEVBUklOOiAuLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIHRyYWNrcyBydWxlIHZhbHVlczogLi4uLi4uLi4uLi4uLi4gdHJ1ZVxuICAgIC8vICAgYXNzaWducyBydWxlIHZhbHVlczogLi4uLi4uLi4uLi4uLiB0cnVlXG4gICAgLy8gICB1c2VzIGxvY2F0aW9uIHRyYWNraW5nOiAuLi4uLi4uLi4uIHRydWVcbiAgICAvLyAgIGFzc2lnbnMgbG9jYXRpb246IC4uLi4uLi4uLi4uLi4uLi4gdHJ1ZVxuICAgIC8vICAgdXNlcyB5eXN0YWNrOiAuLi4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgdXNlcyB5eXNzdGFjazogLi4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgdXNlcyB5eXNwOiAuLi4uLi4uLi4uLi4uLi4uLi4uLi4uLiB0cnVlXG4gICAgLy8gICB1c2VzIHl5cnVsZWxlbmd0aDogLi4uLi4uLi4uLi4uLi4uIGZhbHNlXG4gICAgLy8gICB1c2VzIHl5TWVyZ2VMb2NhdGlvbkluZm8gQVBJOiAuLi4uIHRydWVcbiAgICAvLyAgIGhhcyBlcnJvciByZWNvdmVyeTogLi4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIGhhcyBlcnJvciByZXBvcnRpbmc6IC4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvL1xuICAgIC8vIC0tLS0tLS0tLSBFTkQgT0YgUkVQT1JUIC0tLS0tLS0tLS0tXG5cbnRyYWNlOiBmdW5jdGlvbiBub19vcF90cmFjZSgpIHt9LFxuSmlzb25QYXJzZXJFcnJvcjogSmlzb25QYXJzZXJFcnJvcixcbnl5OiB7fSxcbm9wdGlvbnM6IHtcbiAgdHlwZTogXCJsYWxyXCIsXG4gIGhhc1BhcnRpYWxMclVwZ3JhZGVPbkNvbmZsaWN0OiB0cnVlLFxuICBlcnJvclJlY292ZXJ5VG9rZW5EaXNjYXJkQ291bnQ6IDMsXG4gIGVibmY6IHRydWVcbn0sXG5zeW1ib2xzXzoge1xuICBcIiFcIjogMTYsXG4gIFwiIT1cIjogNjAsXG4gIFwiJGFjY2VwdFwiOiAwLFxuICBcIiRlbmRcIjogMSxcbiAgXCIlfVwiOiAzMCxcbiAgXCImJlwiOiA2MSxcbiAgXCIoXCI6IDcsXG4gIFwiKVwiOiA4LFxuICBcIipcIjogMyxcbiAgXCIrXCI6IDIxLFxuICBcIixcIjogNixcbiAgXCItXCI6IDIzLFxuICBcIi5cIjogMTcsXG4gIFwiL1wiOiAyMixcbiAgXCIvPlwiOiAzOCxcbiAgXCI6XCI6IDEyLFxuICBcIjtcIjogMjAsXG4gIFwiPFwiOiAxMyxcbiAgXCI8L1wiOiAzNyxcbiAgXCI8PVwiOiA1OCxcbiAgXCI9XCI6IDksXG4gIFwiPT1cIjogNTksXG4gIFwiPT5cIjogNTAsXG4gIFwiPlwiOiAxNCxcbiAgXCI+PVwiOiA1NyxcbiAgXCI/XCI6IDE4LFxuICBcIkBcIjogMTksXG4gIFwiQVNcIjogMjcsXG4gIFwiQ0hBUkFDVEVSU1wiOiA0NyxcbiAgXCJDT05TVFJVQ1RPUlwiOiA1NixcbiAgXCJFTFNFXCI6IDQ0LFxuICBcIkVOREZPUlwiOiA0MyxcbiAgXCJFTkRGVU5cIjogMzYsXG4gIFwiRU5ESUZcIjogNDYsXG4gIFwiRU5ETUFJTlwiOiAzMSxcbiAgXCJFTkRWSUVXXCI6IDM0LFxuICBcIkVPRlwiOiAxLFxuICBcIkVYUE9SVFwiOiAzMixcbiAgXCJGQUxTRVwiOiA1NCxcbiAgXCJGT1JcIjogNDEsXG4gIFwiRlJPTVwiOiAyNixcbiAgXCJGVU5cIjogMzUsXG4gIFwiSURFTlRJRklFUlwiOiA1NSxcbiAgXCJJRlwiOiA0NSxcbiAgXCJJTVBPUlRcIjogMjUsXG4gIFwiSU5cIjogNDIsXG4gIFwiSU5TVEFOQ0VPRlwiOiA2MyxcbiAgXCJNQUlOXCI6IDI5LFxuICBcIk5VTUJFUl9MSVRFUkFMXCI6IDUyLFxuICBcIlNUUklOR19MSVRFUkFMXCI6IDUxLFxuICBcIlRIRU5cIjogNDgsXG4gIFwiVFJVRVwiOiA1MyxcbiAgXCJWSUVXXCI6IDMzLFxuICBcIltcIjogMTAsXG4gIFwiXFxcXFxcXFxcIjogNDksXG4gIFwiXVwiOiAxMSxcbiAgXCJeXCI6IDI0LFxuICBcImFnZ3JlZ2F0ZV9tZW1iZXJcIjogNjksXG4gIFwiYWxpYXNlZF9tZW1iZXJcIjogNjgsXG4gIFwiYXJndW1lbnRfbGlzdFwiOiAxMDUsXG4gIFwiYXJndW1lbnRzXCI6IDEwNCxcbiAgXCJhdHRyaWJ1dGVcIjogOTQsXG4gIFwiYXR0cmlidXRlX3ZhbHVlXCI6IDk1LFxuICBcImF0dHJpYnV0ZV92YWx1ZV9ncm91cFwiOiAxNTUsXG4gIFwiYXR0cmlidXRlc1wiOiA5MyxcbiAgXCJiaW5hcnlfZXhwcmVzc2lvblwiOiAxMDgsXG4gIFwiYmluYXJ5X29wZXJhdG9yXCI6IDEzOCxcbiAgXCJiaW5hcnlfb3BlcmF0b3JfZ3JvdXBcIjogMTYxLFxuICBcImJvb2xlYW5fbGl0ZXJhbFwiOiAxMjksXG4gIFwiY2FsbF9leHByZXNzaW9uXCI6IDExNyxcbiAgXCJjaGFyYWN0ZXJzXCI6IDEwMyxcbiAgXCJjaGlsZFwiOiA4OSxcbiAgXCJjaGlsZF9ncm91cFwiOiAxNTAsXG4gIFwiY2hpbGRyZW5cIjogODgsXG4gIFwiY29tcG9zaXRlX21lbWJlclwiOiA3MCxcbiAgXCJjb25zXCI6IDEzMixcbiAgXCJjb25zdHJ1Y3RfZXhwcmVzc2lvblwiOiAxMTYsXG4gIFwiY29udGV4dF9wcm9wZXJ0eVwiOiAxMzAsXG4gIFwiY29udGV4dF90eXBlXCI6IDgwLFxuICBcImNvbnRleHRfdmFyaWFibGVcIjogMTMxLFxuICBcImNvbnRyb2xcIjogOTksXG4gIFwiY29udHJvbF9ncm91cFwiOiAxNTYsXG4gIFwiZWxzZV9jbGF1c2VcIjogMTAyLFxuICBcImVuZF9tYWluXCI6IDc0LFxuICBcImVycm9yXCI6IDIsXG4gIFwiZXhwb3J0XCI6IDc2LFxuICBcImV4cG9ydF9zdGF0ZW1lbnRcIjogNzcsXG4gIFwiZXhwb3J0c1wiOiA3NSxcbiAgXCJleHByZXNzaW9uXCI6IDEwNixcbiAgXCJmaWx0ZXJcIjogOTgsXG4gIFwiZmlsdGVyc1wiOiA5NyxcbiAgXCJmb3Jfc3RhdGVtZW50XCI6IDEwMCxcbiAgXCJmdW5fYXBwbGljYXRpb25cIjogMTEyLFxuICBcImZ1bl9zdGF0ZW1lbnRcIjogNzksXG4gIFwiZnVuX3RhcmdldFwiOiAxMTMsXG4gIFwiZnVuY3Rpb25fZXhwcmVzc2lvblwiOiAxMjEsXG4gIFwiaWRlbnRpZmllclwiOiAxMzUsXG4gIFwiaWZfZXhwcmVzc2lvblwiOiAxMDcsXG4gIFwiaWZfc3RhdGVtZW50XCI6IDEwMSxcbiAgXCJpbXBvcnRfbWVtYmVyXCI6IDY3LFxuICBcImltcG9ydF9zdGF0ZW1lbnRcIjogNjYsXG4gIFwiaW1wb3J0X3N0YXRlbWVudF9vcHRpb25cIjogMTM5LFxuICBcImltcG9ydHNcIjogNjUsXG4gIFwiaW50ZXJwb2xhdGlvblwiOiA5NixcbiAgXCJsaXN0XCI6IDEyNixcbiAgXCJsaXRlcmFsXCI6IDEyMixcbiAgXCJsaXRlcmFsX2dyb3VwXCI6IDE1OSxcbiAgXCJtYWluXCI6IDczLFxuICBcIm1haW5fb3B0aW9uXCI6IDE0MyxcbiAgXCJtYWluX29wdGlvbjJcIjogMTQ0LFxuICBcIm1haW5fb3B0aW9uM1wiOiAxNDUsXG4gIFwibWFpbl9vcHRpb240XCI6IDE0NixcbiAgXCJtZW1iZXJcIjogNzIsXG4gIFwibWVtYmVyX2V4cHJlc3Npb25cIjogMTE4LFxuICBcIm1lbWJlcl9ncm91cFwiOiAxNDIsXG4gIFwibWVtYmVyX2xpc3RcIjogNzEsXG4gIFwibWVtYmVyX2xpc3RfZ3JvdXBcIjogMTQwLFxuICBcIm1lbWJlcl9saXN0X2dyb3VwMlwiOiAxNDEsXG4gIFwibW9kdWxlXCI6IDY0LFxuICBcIm5vZGVcIjogOTEsXG4gIFwibm9kZV9vcHRpb25cIjogMTUxLFxuICBcIm5vZGVfb3B0aW9uMlwiOiAxNTIsXG4gIFwibnVtYmVyX2xpdGVyYWxcIjogMTI4LFxuICBcInBhcmFtZXRlclwiOiA4NyxcbiAgXCJwYXJhbWV0ZXJfbGlzdFwiOiA4NixcbiAgXCJwYXJhbWV0ZXJzXCI6IDg1LFxuICBcInByb3BlcnRpZXNcIjogMTI0LFxuICBcInByb3BlcnR5XCI6IDEyNSxcbiAgXCJwcm9wZXJ0eV9ncm91cFwiOiAxNjAsXG4gIFwicXVhbGlmaWVkX2NvbnN0cnVjdG9yXCI6IDEzMyxcbiAgXCJxdWFsaWZpZWRfaWRlbnRpZmllclwiOiAxMzYsXG4gIFwicmVhZF9leHByZXNzaW9uXCI6IDExOSxcbiAgXCJyZWFkYWJsZV9leHByZXNzaW9uXCI6IDEyMCxcbiAgXCJyZWFkYWJsZV9leHByZXNzaW9uX2dyb3VwXCI6IDE1OCxcbiAgXCJyZWNvcmRcIjogMTIzLFxuICBcInNpbXBsZV9leHByZXNzaW9uXCI6IDExMCxcbiAgXCJzaW1wbGVfZXhwcmVzc2lvbl9ncm91cFwiOiAxNTcsXG4gIFwic3RyaW5nX2xpdGVyYWxcIjogMTI3LFxuICBcInRhZ1wiOiA5MCxcbiAgXCJ0eXBlXCI6IDg0LFxuICBcInR5cGVfYXJnX2xpc3RcIjogMTE1LFxuICBcInR5cGVfYXJndW1lbnRzXCI6IDExNCxcbiAgXCJ0eXBlX2NsYXNzXCI6IDgzLFxuICBcInR5cGVfY2xhc3NfbGlzdFwiOiA4MixcbiAgXCJ0eXBlX2NsYXNzZXNcIjogODEsXG4gIFwidHlwZV9vcHRpb25cIjogMTQ5LFxuICBcInVuYXJ5X2V4cHJlc3Npb25cIjogMTA5LFxuICBcInVucXVhbGlmaWVkX2NvbnN0cnVjdG9yXCI6IDEzNCxcbiAgXCJ1bnF1YWxpZmllZF9pZGVudGlmaWVyXCI6IDEzNyxcbiAgXCJ2aWV3X2NvbnN0cnVjdGlvblwiOiAxMTEsXG4gIFwidmlld19zdGF0ZW1lbnRcIjogNzgsXG4gIFwidmlld19zdGF0ZW1lbnRfb3B0aW9uXCI6IDE0NyxcbiAgXCJ2aWV3X3N0YXRlbWVudF9vcHRpb24yXCI6IDE0OCxcbiAgXCJ3aWRnZXRcIjogOTIsXG4gIFwid2lkZ2V0X29wdGlvblwiOiAxNTMsXG4gIFwid2lkZ2V0X29wdGlvbjJcIjogMTU0LFxuICBcIntcIjogNCxcbiAgXCJ7JVwiOiAyOCxcbiAgXCJ7e1wiOiAzOSxcbiAgXCJ8XCI6IDE1LFxuICBcInx8XCI6IDYyLFxuICBcIn1cIjogNSxcbiAgXCJ9fVwiOiA0MFxufSxcbnRlcm1pbmFsc186IHtcbiAgMTogXCJFT0ZcIixcbiAgMjogXCJlcnJvclwiLFxuICAzOiBcIipcIixcbiAgNDogXCJ7XCIsXG4gIDU6IFwifVwiLFxuICA2OiBcIixcIixcbiAgNzogXCIoXCIsXG4gIDg6IFwiKVwiLFxuICA5OiBcIj1cIixcbiAgMTA6IFwiW1wiLFxuICAxMTogXCJdXCIsXG4gIDEyOiBcIjpcIixcbiAgMTM6IFwiPFwiLFxuICAxNDogXCI+XCIsXG4gIDE1OiBcInxcIixcbiAgMTY6IFwiIVwiLFxuICAxNzogXCIuXCIsXG4gIDE4OiBcIj9cIixcbiAgMTk6IFwiQFwiLFxuICAyMDogXCI7XCIsXG4gIDIxOiBcIitcIixcbiAgMjI6IFwiL1wiLFxuICAyMzogXCItXCIsXG4gIDI0OiBcIl5cIixcbiAgMjU6IFwiSU1QT1JUXCIsXG4gIDI2OiBcIkZST01cIixcbiAgMjc6IFwiQVNcIixcbiAgMjg6IFwieyVcIixcbiAgMjk6IFwiTUFJTlwiLFxuICAzMDogXCIlfVwiLFxuICAzMTogXCJFTkRNQUlOXCIsXG4gIDMyOiBcIkVYUE9SVFwiLFxuICAzMzogXCJWSUVXXCIsXG4gIDM0OiBcIkVORFZJRVdcIixcbiAgMzU6IFwiRlVOXCIsXG4gIDM2OiBcIkVOREZVTlwiLFxuICAzNzogXCI8L1wiLFxuICAzODogXCIvPlwiLFxuICAzOTogXCJ7e1wiLFxuICA0MDogXCJ9fVwiLFxuICA0MTogXCJGT1JcIixcbiAgNDI6IFwiSU5cIixcbiAgNDM6IFwiRU5ERk9SXCIsXG4gIDQ0OiBcIkVMU0VcIixcbiAgNDU6IFwiSUZcIixcbiAgNDY6IFwiRU5ESUZcIixcbiAgNDc6IFwiQ0hBUkFDVEVSU1wiLFxuICA0ODogXCJUSEVOXCIsXG4gIDQ5OiBcIlxcXFxcXFxcXCIsXG4gIDUwOiBcIj0+XCIsXG4gIDUxOiBcIlNUUklOR19MSVRFUkFMXCIsXG4gIDUyOiBcIk5VTUJFUl9MSVRFUkFMXCIsXG4gIDUzOiBcIlRSVUVcIixcbiAgNTQ6IFwiRkFMU0VcIixcbiAgNTU6IFwiSURFTlRJRklFUlwiLFxuICA1NjogXCJDT05TVFJVQ1RPUlwiLFxuICA1NzogXCI+PVwiLFxuICA1ODogXCI8PVwiLFxuICA1OTogXCI9PVwiLFxuICA2MDogXCIhPVwiLFxuICA2MTogXCImJlwiLFxuICA2MjogXCJ8fFwiLFxuICA2MzogXCJJTlNUQU5DRU9GXCJcbn0sXG5URVJST1I6IDIsXG5FT0Y6IDEsXG5cbi8vIGludGVybmFsczogZGVmaW5lZCBoZXJlIHNvIHRoZSBvYmplY3QgKnN0cnVjdHVyZSogZG9lc24ndCBnZXQgbW9kaWZpZWQgYnkgcGFyc2UoKSBldCBhbCxcbi8vIHRodXMgaGVscGluZyBKSVQgY29tcGlsZXJzIGxpa2UgQ2hyb21lIFY4Llxub3JpZ2luYWxRdW90ZU5hbWU6IG51bGwsXG5vcmlnaW5hbFBhcnNlRXJyb3I6IG51bGwsXG5jbGVhbnVwQWZ0ZXJQYXJzZTogbnVsbCxcbmNvbnN0cnVjdFBhcnNlRXJyb3JJbmZvOiBudWxsLFxueXlNZXJnZUxvY2F0aW9uSW5mbzogbnVsbCxcblxuX19yZWVudHJhbnRfY2FsbF9kZXB0aDogMCwgLy8gSU5URVJOQUwgVVNFIE9OTFlcbl9fZXJyb3JfaW5mb3M6IFtdLCAvLyBJTlRFUk5BTCBVU0UgT05MWTogdGhlIHNldCBvZiBwYXJzZUVycm9ySW5mbyBvYmplY3RzIGNyZWF0ZWQgc2luY2UgdGhlIGxhc3QgY2xlYW51cFxuX19lcnJvcl9yZWNvdmVyeV9pbmZvczogW10sIC8vIElOVEVSTkFMIFVTRSBPTkxZOiB0aGUgc2V0IG9mIHBhcnNlRXJyb3JJbmZvIG9iamVjdHMgY3JlYXRlZCBzaW5jZSB0aGUgbGFzdCBjbGVhbnVwXG5cbi8vIEFQSXMgd2hpY2ggd2lsbCBiZSBzZXQgdXAgZGVwZW5kaW5nIG9uIHVzZXIgYWN0aW9uIGNvZGUgYW5hbHlzaXM6XG4vL3l5UmVjb3ZlcmluZzogMCxcbi8veXlFcnJPazogMCxcbi8veXlDbGVhckluOiAwLFxuXG4vLyBIZWxwZXIgQVBJc1xuLy8gLS0tLS0tLS0tLS1cblxuLy8gSGVscGVyIGZ1bmN0aW9uIHdoaWNoIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHVzZXIgY29kZSBsYXRlciBvbjogcHV0IHN1aXRhYmxlIHF1b3RlcyBhcm91bmRcbi8vIGxpdGVyYWwgSURzIGluIGEgZGVzY3JpcHRpb24gc3RyaW5nLlxucXVvdGVOYW1lOiBmdW5jdGlvbiBwYXJzZXJfcXVvdGVOYW1lKGlkX3N0cikge1xuICAgIHJldHVybiAnXCInICsgaWRfc3RyICsgJ1wiJztcbn0sXG5cbi8vIFJldHVybiB0aGUgbmFtZSBvZiB0aGUgZ2l2ZW4gc3ltYm9sICh0ZXJtaW5hbCBvciBub24tdGVybWluYWwpIGFzIGEgc3RyaW5nLCB3aGVuIGF2YWlsYWJsZS5cbi8vXG4vLyBSZXR1cm4gTlVMTCB3aGVuIHRoZSBzeW1ib2wgaXMgdW5rbm93biB0byB0aGUgcGFyc2VyLlxuZ2V0U3ltYm9sTmFtZTogZnVuY3Rpb24gcGFyc2VyX2dldFN5bWJvbE5hbWUoc3ltYm9sKSB7XG4gICAgaWYgKHRoaXMudGVybWluYWxzX1tzeW1ib2xdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRlcm1pbmFsc19bc3ltYm9sXTtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UuLi4gdGhpcyBtaWdodCByZWZlciB0byBhIFJVTEUgdG9rZW4gaS5lLiBhIG5vbi10ZXJtaW5hbDogc2VlIGlmIHdlIGNhbiBkaWcgdGhhdCBvbmUgdXAuXG4gICAgLy9cbiAgICAvLyBBbiBleGFtcGxlIG9mIHRoaXMgbWF5IGJlIHdoZXJlIGEgcnVsZSdzIGFjdGlvbiBjb2RlIGNvbnRhaW5zIGEgY2FsbCBsaWtlIHRoaXM6XG4gICAgLy9cbiAgICAvLyAgICAgIHBhcnNlci5nZXRTeW1ib2xOYW1lKCMkKVxuICAgIC8vXG4gICAgLy8gdG8gb2J0YWluIGEgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgY3VycmVudCBncmFtbWFyIHJ1bGUuXG4gICAgdmFyIHMgPSB0aGlzLnN5bWJvbHNfO1xuICAgIGZvciAodmFyIGtleSBpbiBzKSB7XG4gICAgICAgIGlmIChzW2tleV0gPT09IHN5bWJvbCkge1xuICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn0sXG5cbi8vIFJldHVybiBhIG1vcmUtb3ItbGVzcyBodW1hbi1yZWFkYWJsZSBkZXNjcmlwdGlvbiBvZiB0aGUgZ2l2ZW4gc3ltYm9sLCB3aGVuIGF2YWlsYWJsZSxcbi8vIG9yIHRoZSBzeW1ib2wgaXRzZWxmLCBzZXJ2aW5nIGFzIGl0cyBvd24gJ2Rlc2NyaXB0aW9uJyBmb3IgbGFjayBvZiBzb21ldGhpbmcgYmV0dGVyIHRvIHNlcnZlIHVwLlxuLy9cbi8vIFJldHVybiBOVUxMIHdoZW4gdGhlIHN5bWJvbCBpcyB1bmtub3duIHRvIHRoZSBwYXJzZXIuXG5kZXNjcmliZVN5bWJvbDogZnVuY3Rpb24gcGFyc2VyX2Rlc2NyaWJlU3ltYm9sKHN5bWJvbCkge1xuICAgIGlmIChzeW1ib2wgIT09IHRoaXMuRU9GICYmIHRoaXMudGVybWluYWxfZGVzY3JpcHRpb25zXyAmJiB0aGlzLnRlcm1pbmFsX2Rlc2NyaXB0aW9uc19bc3ltYm9sXSkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXJtaW5hbF9kZXNjcmlwdGlvbnNfW3N5bWJvbF07XG4gICAgfSBlbHNlIGlmIChzeW1ib2wgPT09IHRoaXMuRU9GKSB7XG4gICAgICAgIHJldHVybiAnZW5kIG9mIGlucHV0JztcbiAgICB9XG4gICAgdmFyIGlkID0gdGhpcy5nZXRTeW1ib2xOYW1lKHN5bWJvbCk7XG4gICAgaWYgKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1b3RlTmFtZShpZCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufSxcblxuLy8gUHJvZHVjZSBhIChtb3JlIG9yIGxlc3MpIGh1bWFuLXJlYWRhYmxlIGxpc3Qgb2YgZXhwZWN0ZWQgdG9rZW5zIGF0IHRoZSBwb2ludCBvZiBmYWlsdXJlLlxuLy9cbi8vIFRoZSBwcm9kdWNlZCBsaXN0IG1heSBjb250YWluIHRva2VuIG9yIHRva2VuIHNldCBkZXNjcmlwdGlvbnMgaW5zdGVhZCBvZiB0aGUgdG9rZW5zXG4vLyB0aGVtc2VsdmVzIHRvIGhlbHAgdHVybmluZyB0aGlzIG91dHB1dCBpbnRvIHNvbWV0aGluZyB0aGF0IGVhc2llciB0byByZWFkIGJ5IGh1bWFuc1xuLy8gdW5sZXNzIGBkb19ub3RfZGVzY3JpYmVgIHBhcmFtZXRlciBpcyBzZXQsIGluIHdoaWNoIGNhc2UgYSBsaXN0IG9mIHRoZSByYXcsICpudW1lcmljKixcbi8vIGV4cGVjdGVkIHRlcm1pbmFscyBhbmQgbm9udGVybWluYWxzIGlzIHByb2R1Y2VkLlxuLy9cbi8vIFRoZSByZXR1cm5lZCBsaXN0IChhcnJheSkgd2lsbCBub3QgY29udGFpbiBhbnkgZHVwbGljYXRlIGVudHJpZXMuXG5jb2xsZWN0X2V4cGVjdGVkX3Rva2VuX3NldDogZnVuY3Rpb24gcGFyc2VyX2NvbGxlY3RfZXhwZWN0ZWRfdG9rZW5fc2V0KHN0YXRlLCBkb19ub3RfZGVzY3JpYmUpIHtcbiAgICB2YXIgVEVSUk9SID0gdGhpcy5URVJST1I7XG4gICAgdmFyIHRva2Vuc2V0ID0gW107XG4gICAgdmFyIGNoZWNrID0ge307XG4gICAgLy8gSGFzIHRoaXMgKGVycm9yPykgc3RhdGUgYmVlbiBvdXRmaXR0ZWQgd2l0aCBhIGN1c3RvbSBleHBlY3RhdGlvbnMgZGVzY3JpcHRpb24gdGV4dCBmb3IgaHVtYW4gY29uc3VtcHRpb24/XG4gICAgLy8gSWYgc28sIHVzZSB0aGF0IG9uZSBpbnN0ZWFkIG9mIHRoZSBsZXNzIHBhbGF0YWJsZSB0b2tlbiBzZXQuXG4gICAgaWYgKCFkb19ub3RfZGVzY3JpYmUgJiYgdGhpcy5zdGF0ZV9kZXNjcmlwdGlvbnNfICYmIHRoaXMuc3RhdGVfZGVzY3JpcHRpb25zX1tzdGF0ZV0pIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLnN0YXRlX2Rlc2NyaXB0aW9uc19bc3RhdGVdXTtcbiAgICB9XG4gICAgZm9yICh2YXIgcCBpbiB0aGlzLnRhYmxlW3N0YXRlXSkge1xuICAgICAgICBwID0gK3A7XG4gICAgICAgIGlmIChwICE9PSBURVJST1IpIHtcbiAgICAgICAgICAgIHZhciBkID0gZG9fbm90X2Rlc2NyaWJlID8gcCA6IHRoaXMuZGVzY3JpYmVTeW1ib2wocCk7XG4gICAgICAgICAgICBpZiAoZCAmJiAhY2hlY2tbZF0pIHtcbiAgICAgICAgICAgICAgICB0b2tlbnNldC5wdXNoKGQpO1xuICAgICAgICAgICAgICAgIGNoZWNrW2RdID0gdHJ1ZTsgLy8gTWFyayB0aGlzIHRva2VuIGRlc2NyaXB0aW9uIGFzIGFscmVhZHkgbWVudGlvbmVkIHRvIHByZXZlbnQgb3V0cHV0dGluZyBkdXBsaWNhdGUgZW50cmllcy5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG9rZW5zZXQ7XG59LFxucHJvZHVjdGlvbnNfOiBicCh7XG4gIHBvcDogdShbXG4gIHMsXG4gIFs2NCwgN10sXG4gIDY1LFxuICA2NSxcbiAgNjYsXG4gIHMsXG4gIFs2NywgM10sXG4gIHMsXG4gIFs2OCwgNCwgMV0sXG4gIDcxLFxuICA3MixcbiAgNzMsXG4gIDczLFxuICA3NCxcbiAgNzUsXG4gIDc1LFxuICBzLFxuICBbNzYsIDNdLFxuICA3NyxcbiAgNzgsXG4gIHMsXG4gIFs3OSwgMTZdLFxuICA4MCxcbiAgODEsXG4gIDgyLFxuICA4MixcbiAgcyxcbiAgWzgzLCA0XSxcbiAgcyxcbiAgWzg0LCAzXSxcbiAgODUsXG4gIDg1LFxuICA4NixcbiAgODYsXG4gIDg3LFxuICA4NyxcbiAgODgsXG4gIDg4LFxuICA4OSxcbiAgOTAsXG4gIDkwLFxuICBzLFxuICBbOTEsIDRdLFxuICBzLFxuICBbOTIsIDRdLFxuICA5MyxcbiAgOTMsXG4gIHMsXG4gIFs5NCwgNF0sXG4gIDk1LFxuICA5NixcbiAgOTYsXG4gIDk3LFxuICBzLFxuICBbOTcsIDQsIDFdLFxuICBzLFxuICBbMTAwLCA1XSxcbiAgMTAxLFxuICAxMDIsXG4gIDEwMixcbiAgMTAzLFxuICAxMDQsXG4gIDEwNCxcbiAgMTA1LFxuICAxMDUsXG4gIHMsXG4gIFsxMDYsIDddLFxuICAxMDcsXG4gIHMsXG4gIFsxMDgsIDRdLFxuICAxMDksXG4gIHMsXG4gIFsxMDksIDQsIDFdLFxuICBzLFxuICBbMTEyLCAzXSxcbiAgcyxcbiAgWzExMywgM10sXG4gIDExNCxcbiAgMTE1LFxuICAxMTUsXG4gIDExNixcbiAgcyxcbiAgWzExNywgOF0sXG4gIHMsXG4gIFsxMTgsIDEwXSxcbiAgcyxcbiAgWzExOSwgMTBdLFxuICAxMjAsXG4gIDEyMCxcbiAgMTIxLFxuICAxMjEsXG4gIDEyMixcbiAgMTIzLFxuICAxMjMsXG4gIDEyNCxcbiAgMTI0LFxuICAxMjUsXG4gIDEyNixcbiAgcyxcbiAgWzEyNiwgNCwgMV0sXG4gIHMsXG4gIFsxMjksIDQsIDFdLFxuICAxMzIsXG4gIDEzMyxcbiAgMTMzLFxuICAxMzQsXG4gIDEzNSxcbiAgMTM1LFxuICAxMzYsXG4gIHMsXG4gIFsxMzYsIDQsIDFdLFxuICAxMzksXG4gIDE0MCxcbiAgMTQwLFxuICAxNDEsXG4gIDE0MSxcbiAgMTQyLFxuICAxNDIsXG4gIDE0MyxcbiAgMTQzLFxuICAxNDQsXG4gIDE0NCxcbiAgMTQ1LFxuICAxNDUsXG4gIDE0NixcbiAgMTQ2LFxuICAxNDcsXG4gIDE0NyxcbiAgMTQ4LFxuICAxNDgsXG4gIDE0OSxcbiAgMTQ5LFxuICBzLFxuICBbMTUwLCA1XSxcbiAgMTUxLFxuICAxNTEsXG4gIDE1MixcbiAgMTUyLFxuICAxNTMsXG4gIDE1MyxcbiAgMTU0LFxuICAxNTQsXG4gIDE1NSxcbiAgMTU1LFxuICAxNTYsXG4gIDE1NixcbiAgcyxcbiAgWzE1NywgMTBdLFxuICBzLFxuICBbMTU4LCA0XSxcbiAgcyxcbiAgWzE1OSwgNV0sXG4gIDE2MCxcbiAgMTYwLFxuICBzLFxuICBbMTYxLCAxNF1cbl0pLFxuICBydWxlOiB1KFtcbiAgNCxcbiAgMyxcbiAgMyxcbiAgMixcbiAgMyxcbiAgMixcbiAgMixcbiAgMSxcbiAgMixcbiAgNSxcbiAgcyxcbiAgWzEsIDNdLFxuICBzLFxuICBbMywgM10sXG4gIDEsXG4gIDMsXG4gIDEsXG4gIDExLFxuICBjLFxuICBbNCwgM10sXG4gIDIsXG4gIHMsXG4gIFsxLCAzXSxcbiAgNixcbiAgMTMsXG4gIDExLFxuICAxMCxcbiAgMTAsXG4gIDksXG4gIDEwLFxuICA5LFxuICA5LFxuICA4LFxuICA5LFxuICA4LFxuICA4LFxuICA3LFxuICA4LFxuICA3LFxuICA3LFxuICA2LFxuICBjLFxuICBbMzEsIDVdLFxuICBjLFxuICBbNCwgM10sXG4gIDIsXG4gIDQsXG4gIGMsXG4gIFs1MywgM10sXG4gIGMsXG4gIFs0NiwgM10sXG4gIDEsXG4gIGMsXG4gIFs0MCwgNV0sXG4gIDgsXG4gIDcsXG4gIDQsXG4gIDMsXG4gIGMsXG4gIFs0LCA0XSxcbiAgYyxcbiAgWzY4LCAzXSxcbiAgYyxcbiAgWzE5LCA0XSxcbiAgMyxcbiAgNCxcbiAgMSxcbiAgYyxcbiAgWzgwLCAzXSxcbiAgMTAsXG4gIDEyLFxuICAxNCxcbiAgMTQsXG4gIDE2LFxuICAxOCxcbiAgNixcbiAgNyxcbiAgNyxcbiAgMSxcbiAgYyxcbiAgWzQyLCA0XSxcbiAgcyxcbiAgWzEsIDZdLFxuICAzLFxuICA2LFxuICAzLFxuICA1LFxuICA1LFxuICA3LFxuICAyLFxuICA0LFxuICAxLFxuICA0LFxuICA2LFxuICA1LFxuICA1LFxuICA0LFxuICBjLFxuICBbMTExLCA0XSxcbiAgYyxcbiAgWzc1LCAzXSxcbiAgYyxcbiAgWzEyNywgNF0sXG4gIDMsXG4gIDIsXG4gIDUsXG4gIGMsXG4gIFsxMzYsIDNdLFxuICBzLFxuICBbMywgNl0sXG4gIDUsXG4gIDMsXG4gIDYsXG4gIDgsXG4gIDYsXG4gIDgsXG4gIGMsXG4gIFs0LCA0XSxcbiAgMTAsXG4gIDgsXG4gIGMsXG4gIFs3NiwgM10sXG4gIGMsXG4gIFsxNTQsIDNdLFxuICBjLFxuICBbMTA2LCA0XSxcbiAgYyxcbiAgWzUsIDNdLFxuICBzLFxuICBbMSwgM10sXG4gIGMsXG4gIFsxMTAsIDRdLFxuICBjLFxuICBbOTksIDRdLFxuICBjLFxuICBbNSwgNV0sXG4gIDAsXG4gIHMsXG4gIFsxLCA3XSxcbiAgMCxcbiAgYyxcbiAgWzEwLCAzXSxcbiAgYyxcbiAgWzQsIDEwXSxcbiAgYyxcbiAgWzE5LCAxM10sXG4gIHMsXG4gIFsxLCAzOV1cbl0pXG59KSxcbnBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uIHBhcnNlcl9fUGVyZm9ybUFjdGlvbih5eWxvYywgeXlzdGF0ZSAvKiBhY3Rpb25bMV0gKi8sIHl5c3AsIHl5dnN0YWNrLCB5eWxzdGFjaykge1xuXG4gICAgICAgICAgLyogdGhpcyA9PSB5eXZhbCAqL1xuXG4gICAgICAgICAgLy8gdGhlIEpTIGVuZ2luZSBpdHNlbGYgY2FuIGdvIGFuZCByZW1vdmUgdGhlc2Ugc3RhdGVtZW50cyB3aGVuIGB5eWAgdHVybnMgb3V0IHRvIGJlIHVudXNlZCBpbiBhbnkgYWN0aW9uIGNvZGUhXG4gICAgICAgICAgdmFyIHl5ID0gdGhpcy55eTtcbiAgICAgICAgICB2YXIgeXlwYXJzZXIgPSB5eS5wYXJzZXI7XG4gICAgICAgICAgdmFyIHl5bGV4ZXIgPSB5eS5sZXhlcjtcblxuICAgICAgICAgIFxuXG4gICAgICAgICAgc3dpdGNoICh5eXN0YXRlKSB7XG5jYXNlIDA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICAkYWNjZXB0IDogbW9kdWxlICRlbmQgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLC0sLSxMVCxMQSwtLC0pOlxuICAgIHRoaXMuJCA9IHl5dnN0YWNrW3l5c3AgLSAxXTtcbiAgICB0aGlzLl8kID0geXlsc3RhY2tbeXlzcCAtIDFdO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSwtLC0sTFQsTEEsLSwtKVxuICAgIGJyZWFrO1xuXG5jYXNlIDE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtb2R1bGUgOiBpbXBvcnRzIGV4cG9ydHMgbWFpbiBFT0YgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDMsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID1cbiAgICBuZXcgeXkuYXN0Lk1vZHVsZSh5eXZzdGFja1t5eXNwIC0gM10sIHl5dnN0YWNrW3l5c3AgLSAyXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTsgXG4gICAgcmV0dXJuIHRoaXMuJDtcbiAgICBicmVhaztcblxuY2FzZSAyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbW9kdWxlIDogaW1wb3J0cyBleHBvcnRzIEVPRiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPVxuICAgIG5ldyB5eS5hc3QuTW9kdWxlKHl5dnN0YWNrW3l5c3AgLSAyXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCBudWxsLCB0aGlzLl8kKTsgXG4gICAgcmV0dXJuIHRoaXMuJDtcbiAgICBicmVhaztcblxuY2FzZSAzOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbW9kdWxlIDogaW1wb3J0cyBtYWluIEVPRiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPVxuICAgIG5ldyB5eS5hc3QuTW9kdWxlKHl5dnN0YWNrW3l5c3AgLSAyXSwgW10sIHl5dnN0YWNrW3l5c3AgLSAxXSwgdGhpcy5fJCk7IFxuICAgIHJldHVybiB0aGlzLiQ7XG4gICAgYnJlYWs7XG5cbmNhc2UgNDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1vZHVsZSA6IGltcG9ydHMgRU9GICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAxLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9XG4gICAgbmV3IHl5LmFzdC5Nb2R1bGUoeXl2c3RhY2tbeXlzcCAtIDFdLCBbXSwgbnVsbCwgdGhpcy5fJCk7IFxuICAgIHJldHVybiB0aGlzLiQ7XG4gICAgYnJlYWs7XG5cbmNhc2UgNTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1vZHVsZSA6IGV4cG9ydHMgbWFpbiBFT0YgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDIsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID1cbiAgICBuZXcgeXkuYXN0Lk1vZHVsZShbXSwgeXl2c3RhY2tbeXlzcCAtIDJdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpOyBcbiAgICByZXR1cm4gdGhpcy4kO1xuICAgIGJyZWFrO1xuXG5jYXNlIDY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtb2R1bGUgOiBleHBvcnRzIEVPRiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPVxuICAgIG5ldyB5eS5hc3QuTW9kdWxlKFtdLCB5eXZzdGFja1t5eXNwIC0gMV0sIG51bGwsIHRoaXMuXyQpOyBcbiAgICByZXR1cm4gdGhpcy4kO1xuICAgIGJyZWFrO1xuXG5jYXNlIDc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtb2R1bGUgOiBtYWluIEVPRiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPVxuICAgIG5ldyB5eS5hc3QuTW9kdWxlKFtdLCBbXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTsgXG4gICAgcmV0dXJuIHRoaXMuJDtcbiAgICBicmVhaztcblxuY2FzZSA4OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgaW1wb3J0cyA6IGltcG9ydF9zdGF0ZW1lbnQgKi9cbmNhc2UgODU6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmaWx0ZXJzIDogZmlsdGVyICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLC0sLSk6XG4gICAgdGhpcy5fJCA9IHl5bHN0YWNrW3l5c3BdO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLC0sLSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSAgW3l5dnN0YWNrW3l5c3BdXTtcbiAgICBicmVhaztcblxuY2FzZSA5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgaW1wb3J0cyA6IGltcG9ydHMgaW1wb3J0X3N0YXRlbWVudCAqL1xuY2FzZSAyNDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGV4cG9ydHMgOiBleHBvcnRzIGV4cG9ydCAqL1xuY2FzZSA2NDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNoaWxkcmVuIDogY2hpbGRyZW4gY2hpbGQgKi9cbmNhc2UgNzc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBhdHRyaWJ1dGVzIDogYXR0cmlidXRlcyBhdHRyaWJ1dGUgKi9cbmNhc2UgODY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmaWx0ZXJzIDogZmlsdGVycyBmaWx0ZXIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsLSwtKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsLSwtKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IHl5dnN0YWNrW3l5c3AgLSAxXS5jb25jYXQoeXl2c3RhY2tbeXlzcF0pO1xuICAgIGJyZWFrO1xuXG5jYXNlIDEwOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgaW1wb3J0X3N0YXRlbWVudCA6IElNUE9SVCBpbXBvcnRfbWVtYmVyIEZST00gc3RyaW5nX2xpdGVyYWwgaW1wb3J0X3N0YXRlbWVudF9vcHRpb24gKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDQsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5JbXBvcnRTdGF0ZW1lbnQoeXl2c3RhY2tbeXlzcCAtIDNdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDExOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgaW1wb3J0X21lbWJlciA6IGFnZ3JlZ2F0ZV9tZW1iZXIgKi9cbmNhc2UgMTI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBpbXBvcnRfbWVtYmVyIDogYWxpYXNlZF9tZW1iZXIgKi9cbmNhc2UgMTM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBpbXBvcnRfbWVtYmVyIDogY29tcG9zaXRlX21lbWJlciAqL1xuY2FzZSAxOTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1lbWJlciA6IG1lbWJlcl9ncm91cCAqL1xuY2FzZSAyNTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGV4cG9ydCA6IGV4cG9ydF9zdGF0ZW1lbnQgKi9cbmNhc2UgMjY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBleHBvcnQgOiB2aWV3X3N0YXRlbWVudCAqL1xuY2FzZSAxNjI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBsaXRlcmFsIDogbGl0ZXJhbF9ncm91cCAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsLSwtLExULExBLC0sLSk6XG4gICAgdGhpcy4kID0geXl2c3RhY2tbeXlzcF07XG4gICAgdGhpcy5fJCA9IHl5bHN0YWNrW3l5c3BdO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSwtLC0sTFQsTEEsLSwtKVxuICAgIGJyZWFrO1xuXG5jYXNlIDE0OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYWxpYXNlZF9tZW1iZXIgOiBtZW1iZXIgQVMgbWVtYmVyICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAyLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuQWxpYXNlZE1lbWJlcih5eXZzdGFja1t5eXNwIC0gMl0sIHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxNTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGFnZ3JlZ2F0ZV9tZW1iZXIgOiBcIipcIiBBUyBtZW1iZXIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDIsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5BZ2dyZWdhdGVNZW1iZXIoeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDE2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY29tcG9zaXRlX21lbWJlciA6IFwie1wiIG1lbWJlcl9saXN0IFwifVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAyLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuQ29tcG9zaXRlTWVtYmVyKHl5dnN0YWNrW3l5c3AgLSAxXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtZW1iZXJfbGlzdCA6IG1lbWJlcl9saXN0X2dyb3VwICovXG5jYXNlIDIzOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZXhwb3J0cyA6IGV4cG9ydCAqL1xuY2FzZSA0ODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHR5cGVfY2xhc3NfbGlzdCA6IHR5cGVfY2xhc3MgKi9cbmNhc2UgNTk6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBwYXJhbWV0ZXJfbGlzdCA6IHBhcmFtZXRlciAqL1xuY2FzZSA2MzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNoaWxkcmVuIDogY2hpbGQgKi9cbmNhc2UgNzY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBhdHRyaWJ1dGVzIDogYXR0cmlidXRlICovXG5jYXNlIDEwMTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGFyZ3VtZW50X2xpc3QgOiBleHByZXNzaW9uICovXG5jYXNlIDEyNzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHR5cGVfYXJnX2xpc3QgOiB0eXBlICovXG5jYXNlIDE2NTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHByb3BlcnRpZXMgOiBwcm9wZXJ0eSAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSwtLC0pOlxuICAgIHRoaXMuXyQgPSB5eWxzdGFja1t5eXNwXTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSwtLC0pXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gW3l5dnN0YWNrW3l5c3BdXTtcbiAgICBicmVhaztcblxuY2FzZSAxODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1lbWJlcl9saXN0IDogbWVtYmVyX2xpc3QgXCIsXCIgbWVtYmVyX2xpc3RfZ3JvdXAyICovXG5jYXNlIDQ5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgdHlwZV9jbGFzc19saXN0IDogdHlwZV9jbGFzc19saXN0IFwiLFwiIHR5cGVfY2xhc3MgKi9cbmNhc2UgNjA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBwYXJhbWV0ZXJfbGlzdCA6IHBhcmFtZXRlcl9saXN0IFwiLFwiIHBhcmFtZXRlciAqL1xuY2FzZSAxMDI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBhcmd1bWVudF9saXN0IDogYXJndW1lbnRfbGlzdCBcIixcIiBleHByZXNzaW9uICovXG5jYXNlIDEyODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHR5cGVfYXJnX2xpc3QgOiB0eXBlX2FyZ19saXN0IFwiLFwiIHR5cGUgKi9cbmNhc2UgMTY2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcHJvcGVydGllcyA6IHByb3BlcnRpZXMgXCIsXCIgcHJvcGVydHkgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsLSwtKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsLSwtKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IHl5dnN0YWNrW3l5c3AgLSAyXS5jb25jYXQoeXl2c3RhY2tbeXlzcF0pO1xuICAgIGJyZWFrO1xuXG5jYXNlIDIwOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWFpbiA6IFwieyVcIiBNQUlOIG1haW5fb3B0aW9uIG1haW5fb3B0aW9uMiBcIihcIiB0eXBlIFwiKVwiIG1haW5fb3B0aW9uMyBcIiV9XCIgdGFnIG1haW5fb3B0aW9uNCAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMTAsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5UeXBlZE1haW4oeXl2c3RhY2tbeXlzcCAtIDhdLCB5eXZzdGFja1t5eXNwIC0gN118fFtdLCB5eXZzdGFja1t5eXNwIC0gNV0sIHl5dnN0YWNrW3l5c3AgLSAzXXx8W10sIHl5dnN0YWNrW3l5c3AgLSAxXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMjE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtYWluIDogdGFnICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eWxzdGFja1t5eXNwXTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuVW50eXBlZE1haW4oeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDIyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZW5kX21haW4gOiBcInslXCIgRU5ETUFJTiBcIiV9XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLC0sLSxMVCxMQSwtLC0pOlxuICAgIHRoaXMuJCA9IHl5dnN0YWNrW3l5c3AgLSAyXTtcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLC0sLSxMVCxMQSwtLC0pXG4gICAgYnJlYWs7XG5cbmNhc2UgMjc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBleHBvcnQgOiBmdW5fc3RhdGVtZW50ICovXG5jYXNlIDY1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY2hpbGQgOiBjaGlsZF9ncm91cCAqL1xuY2FzZSA2NjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHRhZyA6IG5vZGUgKi9cbmNhc2UgNjc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB0YWcgOiB3aWRnZXQgKi9cbmNhc2UgODI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBhdHRyaWJ1dGVfdmFsdWUgOiBhdHRyaWJ1dGVfdmFsdWVfZ3JvdXAgKi9cbmNhc2UgODg6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjb250cm9sIDogY29udHJvbF9ncm91cCAqL1xuY2FzZSAxMDM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBleHByZXNzaW9uIDogaWZfZXhwcmVzc2lvbiAqL1xuY2FzZSAxMDQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBleHByZXNzaW9uIDogYmluYXJ5X2V4cHJlc3Npb24gKi9cbmNhc2UgMTA2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZXhwcmVzc2lvbiA6IHNpbXBsZV9leHByZXNzaW9uICovXG5jYXNlIDEwNzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGV4cHJlc3Npb24gOiByZWFkX2V4cHJlc3Npb24gKi9cbmNhc2UgMTA4OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZXhwcmVzc2lvbiA6IGZ1bmN0aW9uX2V4cHJlc3Npb24gKi9cbmNhc2UgMTE3OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgc2ltcGxlX2V4cHJlc3Npb24gOiBzaW1wbGVfZXhwcmVzc2lvbl9ncm91cCAqL1xuY2FzZSAxMjM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5fdGFyZ2V0IDogaWRlbnRpZmllciAqL1xuY2FzZSAxMjQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5fdGFyZ2V0IDogY29udGV4dF9wcm9wZXJ0eSAqL1xuY2FzZSAxNTg6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICByZWFkYWJsZV9leHByZXNzaW9uIDogcmVhZGFibGVfZXhwcmVzc2lvbl9ncm91cCAqL1xuY2FzZSAxNzY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjb25zIDogcXVhbGlmaWVkX2NvbnN0cnVjdG9yICovXG5jYXNlIDE3NzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNvbnMgOiB1bnF1YWxpZmllZF9jb25zdHJ1Y3RvciAqL1xuY2FzZSAxODE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBpZGVudGlmaWVyIDogcXVhbGlmaWVkX2lkZW50aWZpZXIgKi9cbmNhc2UgMTgyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgaWRlbnRpZmllciA6IHVucXVhbGlmaWVkX2lkZW50aWZpZXIgKi9cbmNhc2UgMTg2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYmluYXJ5X29wZXJhdG9yIDogYmluYXJ5X29wZXJhdG9yX2dyb3VwICovXG5jYXNlIDE4ODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGltcG9ydF9zdGF0ZW1lbnRfb3B0aW9uIDogXCI7XCIgKi9cbmNhc2UgMTg5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWVtYmVyX2xpc3RfZ3JvdXAgOiBtZW1iZXIgKi9cbmNhc2UgMTkwOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWVtYmVyX2xpc3RfZ3JvdXAgOiBhbGlhc2VkX21lbWJlciAqL1xuY2FzZSAxOTE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtZW1iZXJfbGlzdF9ncm91cDIgOiBtZW1iZXIgKi9cbmNhc2UgMTkyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWVtYmVyX2xpc3RfZ3JvdXAyIDogYWxpYXNlZF9tZW1iZXIgKi9cbmNhc2UgMTkzOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWVtYmVyX2dyb3VwIDogdW5xdWFsaWZpZWRfaWRlbnRpZmllciAqL1xuY2FzZSAxOTQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtZW1iZXJfZ3JvdXAgOiB1bnF1YWxpZmllZF9jb25zdHJ1Y3RvciAqL1xuY2FzZSAxOTY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtYWluX29wdGlvbiA6IHVucXVhbGlmaWVkX2NvbnN0cnVjdG9yICovXG5jYXNlIDE5ODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1haW5fb3B0aW9uMiA6IHR5cGVfY2xhc3NlcyAqL1xuY2FzZSAyMDA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtYWluX29wdGlvbjMgOiBwYXJhbWV0ZXJzICovXG5jYXNlIDIwMjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1haW5fb3B0aW9uNCA6IGVuZF9tYWluICovXG5jYXNlIDIwNDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHZpZXdfc3RhdGVtZW50X29wdGlvbiA6IHR5cGVfY2xhc3NlcyAqL1xuY2FzZSAyMDY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB2aWV3X3N0YXRlbWVudF9vcHRpb24yIDogcGFyYW1ldGVycyAqL1xuY2FzZSAyMDg6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB0eXBlX29wdGlvbiA6IHR5cGVfY2xhc3NlcyAqL1xuY2FzZSAyMDk6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjaGlsZF9ncm91cCA6IHRhZyAqL1xuY2FzZSAyMTA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjaGlsZF9ncm91cCA6IGludGVycG9sYXRpb24gKi9cbmNhc2UgMjExOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY2hpbGRfZ3JvdXAgOiBjb250cm9sICovXG5jYXNlIDIxMjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNoaWxkX2dyb3VwIDogY2hhcmFjdGVycyAqL1xuY2FzZSAyMTM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjaGlsZF9ncm91cCA6IGlkZW50aWZpZXIgKi9cbmNhc2UgMjE1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbm9kZV9vcHRpb24gOiBjaGlsZHJlbiAqL1xuY2FzZSAyMTc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBub2RlX29wdGlvbjIgOiBjaGlsZHJlbiAqL1xuY2FzZSAyMTk6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB3aWRnZXRfb3B0aW9uIDogY2hpbGRyZW4gKi9cbmNhc2UgMjIxOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgd2lkZ2V0X29wdGlvbjIgOiBjaGlsZHJlbiAqL1xuY2FzZSAyMjI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBhdHRyaWJ1dGVfdmFsdWVfZ3JvdXAgOiBpbnRlcnBvbGF0aW9uICovXG5jYXNlIDIyMzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGF0dHJpYnV0ZV92YWx1ZV9ncm91cCA6IGxpdGVyYWwgKi9cbmNhc2UgMjI0OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY29udHJvbF9ncm91cCA6IGZvcl9zdGF0ZW1lbnQgKi9cbmNhc2UgMjI1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY29udHJvbF9ncm91cCA6IGlmX3N0YXRlbWVudCAqL1xuY2FzZSAyMjY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBzaW1wbGVfZXhwcmVzc2lvbl9ncm91cCA6IHZpZXdfY29uc3RydWN0aW9uICovXG5jYXNlIDIyNzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHNpbXBsZV9leHByZXNzaW9uX2dyb3VwIDogZnVuX2FwcGxpY2F0aW9uICovXG5jYXNlIDIyODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHNpbXBsZV9leHByZXNzaW9uX2dyb3VwIDogY29uc3RydWN0X2V4cHJlc3Npb24gKi9cbmNhc2UgMjI5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgc2ltcGxlX2V4cHJlc3Npb25fZ3JvdXAgOiBjYWxsX2V4cHJlc3Npb24gKi9cbmNhc2UgMjMwOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgc2ltcGxlX2V4cHJlc3Npb25fZ3JvdXAgOiBtZW1iZXJfZXhwcmVzc2lvbiAqL1xuY2FzZSAyMzE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBzaW1wbGVfZXhwcmVzc2lvbl9ncm91cCA6IGxpdGVyYWwgKi9cbmNhc2UgMjMyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgc2ltcGxlX2V4cHJlc3Npb25fZ3JvdXAgOiBjb250ZXh0X3Byb3BlcnR5ICovXG5jYXNlIDIzMzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHNpbXBsZV9leHByZXNzaW9uX2dyb3VwIDogY29ucyAqL1xuY2FzZSAyMzQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBzaW1wbGVfZXhwcmVzc2lvbl9ncm91cCA6IGlkZW50aWZpZXIgKi9cbmNhc2UgMjM1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgc2ltcGxlX2V4cHJlc3Npb25fZ3JvdXAgOiBjb250ZXh0X3ZhcmlhYmxlICovXG5jYXNlIDIzNjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHJlYWRhYmxlX2V4cHJlc3Npb25fZ3JvdXAgOiBzdHJpbmdfbGl0ZXJhbCAqL1xuY2FzZSAyMzc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICByZWFkYWJsZV9leHByZXNzaW9uX2dyb3VwIDogbWVtYmVyX2V4cHJlc3Npb24gKi9cbmNhc2UgMjM4OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcmVhZGFibGVfZXhwcmVzc2lvbl9ncm91cCA6IGNvbnRleHRfcHJvcGVydHkgKi9cbmNhc2UgMjM5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcmVhZGFibGVfZXhwcmVzc2lvbl9ncm91cCA6IGNhbGxfZXhwcmVzc2lvbiAqL1xuY2FzZSAyNDA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBsaXRlcmFsX2dyb3VwIDogcmVjb3JkICovXG5jYXNlIDI0MTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGxpdGVyYWxfZ3JvdXAgOiBsaXN0ICovXG5jYXNlIDI0MjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGxpdGVyYWxfZ3JvdXAgOiBzdHJpbmdfbGl0ZXJhbCAqL1xuY2FzZSAyNDM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBsaXRlcmFsX2dyb3VwIDogbnVtYmVyX2xpdGVyYWwgKi9cbmNhc2UgMjQ0OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbGl0ZXJhbF9ncm91cCA6IGJvb2xlYW5fbGl0ZXJhbCAqL1xuY2FzZSAyNDU6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBwcm9wZXJ0eV9ncm91cCA6IHVucXVhbGlmaWVkX2lkZW50aWZpZXIgKi9cbmNhc2UgMjQ2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcHJvcGVydHlfZ3JvdXAgOiBzdHJpbmdfbGl0ZXJhbCAqL1xuY2FzZSAyNDc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBiaW5hcnlfb3BlcmF0b3JfZ3JvdXAgOiBcIj5cIiAqL1xuY2FzZSAyNDg6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBiaW5hcnlfb3BlcmF0b3JfZ3JvdXAgOiBcIj49XCIgKi9cbmNhc2UgMjQ5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYmluYXJ5X29wZXJhdG9yX2dyb3VwIDogXCI8XCIgKi9cbmNhc2UgMjUwOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYmluYXJ5X29wZXJhdG9yX2dyb3VwIDogXCI8PVwiICovXG5jYXNlIDI1MTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGJpbmFyeV9vcGVyYXRvcl9ncm91cCA6IFwiPT1cIiAqL1xuY2FzZSAyNTI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBiaW5hcnlfb3BlcmF0b3JfZ3JvdXAgOiBcIiE9XCIgKi9cbmNhc2UgMjUzOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYmluYXJ5X29wZXJhdG9yX2dyb3VwIDogXCIrXCIgKi9cbmNhc2UgMjU0OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYmluYXJ5X29wZXJhdG9yX2dyb3VwIDogXCIvXCIgKi9cbmNhc2UgMjU1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYmluYXJ5X29wZXJhdG9yX2dyb3VwIDogXCItXCIgKi9cbmNhc2UgMjU2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYmluYXJ5X29wZXJhdG9yX2dyb3VwIDogXCI9XCIgKi9cbmNhc2UgMjU3OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYmluYXJ5X29wZXJhdG9yX2dyb3VwIDogXCImJlwiICovXG5jYXNlIDI1ODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGJpbmFyeV9vcGVyYXRvcl9ncm91cCA6IFwifHxcIiAqL1xuY2FzZSAyNTk6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBiaW5hcnlfb3BlcmF0b3JfZ3JvdXAgOiBcIl5cIiAqL1xuY2FzZSAyNjA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBiaW5hcnlfb3BlcmF0b3JfZ3JvdXAgOiBJTlNUQU5DRU9GICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLC0sLSk6XG4gICAgdGhpcy5fJCA9IHl5bHN0YWNrW3l5c3BdO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLC0sLSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSB5eXZzdGFja1t5eXNwXTtcbiAgICBicmVhaztcblxuY2FzZSAyODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGV4cG9ydF9zdGF0ZW1lbnQgOiBcInslXCIgRVhQT1JUIGNvbXBvc2l0ZV9tZW1iZXIgRlJPTSBzdHJpbmdfbGl0ZXJhbCBcIiV9XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDUsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5FeHBvcnRTdGF0ZW1lbnQoeXl2c3RhY2tbeXlzcCAtIDNdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDI5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgdmlld19zdGF0ZW1lbnQgOiBcInslXCIgVklFVyB1bnF1YWxpZmllZF9jb25zdHJ1Y3RvciB2aWV3X3N0YXRlbWVudF9vcHRpb24gXCIoXCIgdHlwZSBcIilcIiB2aWV3X3N0YXRlbWVudF9vcHRpb24yIFwiJX1cIiB0YWcgXCJ7JVwiIEVORFZJRVcgXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAxMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LlZpZXdTdGF0ZW1lbnQoeXl2c3RhY2tbeXlzcCAtIDEwXSwgeXl2c3RhY2tbeXlzcCAtIDldfHxbXSwgeXl2c3RhY2tbeXlzcCAtIDddLCB5eXZzdGFja1t5eXNwIC0gNV18fFtdLCB5eXZzdGFja1t5eXNwIC0gM10sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDMwOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZnVuX3N0YXRlbWVudCA6IFwieyVcIiBGVU4gdW5xdWFsaWZpZWRfaWRlbnRpZmllciB0eXBlX2NsYXNzZXMgY29udGV4dF90eXBlIHBhcmFtZXRlcnMgXCIlfVwiIGNoaWxkcmVuIFwieyVcIiBFTkRGVU4gXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAxMCwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZ1blN0YXRlbWVudCh5eXZzdGFja1t5eXNwIC0gOF0sIHl5dnN0YWNrW3l5c3AgLSA3XSwgeXl2c3RhY2tbeXlzcCAtIDZdLCB5eXZzdGFja1t5eXNwIC0gNV0sIHl5dnN0YWNrW3l5c3AgLSAzXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMzE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5fc3RhdGVtZW50IDogXCJ7JVwiIEZVTiB1bnF1YWxpZmllZF9pZGVudGlmaWVyIHR5cGVfY2xhc3NlcyBjb250ZXh0X3R5cGUgXCIlfVwiIGNoaWxkcmVuIFwieyVcIiBFTkRGVU4gXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA5LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRnVuU3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSA3XSwgeXl2c3RhY2tbeXlzcCAtIDZdLCB5eXZzdGFja1t5eXNwIC0gNV0sIFtdLCB5eXZzdGFja1t5eXNwIC0gM10sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDMyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZnVuX3N0YXRlbWVudCA6IFwieyVcIiBGVU4gdW5xdWFsaWZpZWRfaWRlbnRpZmllciB0eXBlX2NsYXNzZXMgcGFyYW1ldGVycyBcIiV9XCIgY2hpbGRyZW4gXCJ7JVwiIEVOREZVTiBcIiV9XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDksIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5GdW5TdGF0ZW1lbnQoeXl2c3RhY2tbeXlzcCAtIDddLCB5eXZzdGFja1t5eXNwIC0gNl0sIG51bGwsIHl5dnN0YWNrW3l5c3AgLSA1XSwgeXl2c3RhY2tbeXlzcCAtIDNdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAzMzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZ1bl9zdGF0ZW1lbnQgOiBcInslXCIgRlVOIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgdHlwZV9jbGFzc2VzIFwiJX1cIiBjaGlsZHJlbiBcInslXCIgRU5ERlVOIFwiJX1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gOCwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZ1blN0YXRlbWVudCh5eXZzdGFja1t5eXNwIC0gNl0sIHl5dnN0YWNrW3l5c3AgLSA1XSwgbnVsbCwgW10sIHl5dnN0YWNrW3l5c3AgLSAzXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMzQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5fc3RhdGVtZW50IDogXCJ7JVwiIEZVTiB1bnF1YWxpZmllZF9pZGVudGlmaWVyIGNvbnRleHRfdHlwZSBwYXJhbWV0ZXJzIFwiJX1cIiBjaGlsZHJlbiBcInslXCIgRU5ERlVOIFwiJX1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gOSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZ1blN0YXRlbWVudCh5eXZzdGFja1t5eXNwIC0gN10sIFtdLCB5eXZzdGFja1t5eXNwIC0gNl0sIHl5dnN0YWNrW3l5c3AgLSA1XSwgeXl2c3RhY2tbeXlzcCAtIDNdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAzNTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZ1bl9zdGF0ZW1lbnQgOiBcInslXCIgRlVOIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgY29udGV4dF90eXBlIFwiJX1cIiBjaGlsZHJlbiBcInslXCIgRU5ERlVOIFwiJX1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gOCwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZ1blN0YXRlbWVudCh5eXZzdGFja1t5eXNwIC0gNl0sIFtdLCB5eXZzdGFja1t5eXNwIC0gNV0sIFtdLCB5eXZzdGFja1t5eXNwIC0gM10sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDM2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZnVuX3N0YXRlbWVudCA6IFwieyVcIiBGVU4gdW5xdWFsaWZpZWRfaWRlbnRpZmllciBwYXJhbWV0ZXJzIFwiJX1cIiBjaGlsZHJlbiBcInslXCIgRU5ERlVOIFwiJX1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gOCwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZ1blN0YXRlbWVudCh5eXZzdGFja1t5eXNwIC0gNl0sW10sbnVsbCx5eXZzdGFja1t5eXNwIC0gNV0seXl2c3RhY2tbeXlzcCAtIDNdLHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDM3OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZnVuX3N0YXRlbWVudCA6IFwieyVcIiBGVU4gdW5xdWFsaWZpZWRfaWRlbnRpZmllciBcIiV9XCIgY2hpbGRyZW4gXCJ7JVwiIEVOREZVTiBcIiV9XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDcsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5GdW5TdGF0ZW1lbnQoeXl2c3RhY2tbeXlzcCAtIDVdLFtdLG51bGwsW10seXl2c3RhY2tbeXlzcCAtIDNdLHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDM4OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZnVuX3N0YXRlbWVudCA6IFwieyVcIiBGVU4gdW5xdWFsaWZpZWRfaWRlbnRpZmllciB0eXBlX2NsYXNzZXMgY29udGV4dF90eXBlIHBhcmFtZXRlcnMgXCI9XCIgY2hpbGQgXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA4LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRnVuU3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSA2XSwgeXl2c3RhY2tbeXlzcCAtIDVdLCB5eXZzdGFja1t5eXNwIC0gNF0sIHl5dnN0YWNrW3l5c3AgLSAzXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAzOTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZ1bl9zdGF0ZW1lbnQgOiBcInslXCIgRlVOIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgdHlwZV9jbGFzc2VzIGNvbnRleHRfdHlwZSBcIj1cIiBjaGlsZCBcIiV9XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDcsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5GdW5TdGF0ZW1lbnQoeXl2c3RhY2tbeXlzcCAtIDVdLCB5eXZzdGFja1t5eXNwIC0gNF0sIHl5dnN0YWNrW3l5c3AgLSAzXSwgW10sIHl5dnN0YWNrW3l5c3AgLSAxXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgNDA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5fc3RhdGVtZW50IDogXCJ7JVwiIEZVTiB1bnF1YWxpZmllZF9pZGVudGlmaWVyIHR5cGVfY2xhc3NlcyBwYXJhbWV0ZXJzIFwiPVwiIGNoaWxkIFwiJX1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gNywgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZ1blN0YXRlbWVudCh5eXZzdGFja1t5eXNwIC0gNV0sIHl5dnN0YWNrW3l5c3AgLSA0XSwgbnVsbCwgeXl2c3RhY2tbeXlzcCAtIDNdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDQxOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZnVuX3N0YXRlbWVudCA6IFwieyVcIiBGVU4gdW5xdWFsaWZpZWRfaWRlbnRpZmllciB0eXBlX2NsYXNzZXMgXCI9XCIgY2hpbGQgXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA2LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRnVuU3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSA0XSwgeXl2c3RhY2tbeXlzcCAtIDNdLCBudWxsLCBbXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA0MjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZ1bl9zdGF0ZW1lbnQgOiBcInslXCIgRlVOIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgY29udGV4dF90eXBlIHBhcmFtZXRlcnMgXCI9XCIgY2hpbGQgXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA3LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRnVuU3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSA1XSwgW10sIHl5dnN0YWNrW3l5c3AgLSA0XSwgeXl2c3RhY2tbeXlzcCAtIDNdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDQzOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZnVuX3N0YXRlbWVudCA6IFwieyVcIiBGVU4gdW5xdWFsaWZpZWRfaWRlbnRpZmllciBjb250ZXh0X3R5cGUgXCI9XCIgY2hpbGQgXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA2LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRnVuU3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSA0XSwgW10sIHl5dnN0YWNrW3l5c3AgLSAzXSwgW10sIHl5dnN0YWNrW3l5c3AgLSAxXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgNDQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5fc3RhdGVtZW50IDogXCJ7JVwiIEZVTiB1bnF1YWxpZmllZF9pZGVudGlmaWVyIHBhcmFtZXRlcnMgXCI9XCIgY2hpbGQgXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA2LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRnVuU3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSA0XSxbXSxudWxsLHl5dnN0YWNrW3l5c3AgLSAzXSx5eXZzdGFja1t5eXNwIC0gMV0sdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgNDU6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5fc3RhdGVtZW50IDogXCJ7JVwiIEZVTiB1bnF1YWxpZmllZF9pZGVudGlmaWVyIFwiPVwiIGNoaWxkIFwiJX1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gNSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZ1blN0YXRlbWVudCh5eXZzdGFja1t5eXNwIC0gM10sW10sbnVsbCxbXSx5eXZzdGFja1t5eXNwIC0gMV0sdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgNDY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjb250ZXh0X3R5cGUgOiBcIihcIiB0eXBlIFwiKVwiICovXG5jYXNlIDQ3OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgdHlwZV9jbGFzc2VzIDogXCJbXCIgdHlwZV9jbGFzc19saXN0IFwiXVwiICovXG5jYXNlIDU4OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcGFyYW1ldGVycyA6IFwiKFwiIHBhcmFtZXRlcl9saXN0IFwiKVwiICovXG5jYXNlIDEwMDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGFyZ3VtZW50cyA6IFwiKFwiIGFyZ3VtZW50X2xpc3QgXCIpXCIgKi9cbmNhc2UgMTA5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZXhwcmVzc2lvbiA6IFwiKFwiIGV4cHJlc3Npb24gXCIpXCIgKi9cbmNhc2UgMTI1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZnVuX3RhcmdldCA6IFwiKFwiIGV4cHJlc3Npb24gXCIpXCIgKi9cbmNhc2UgMTI2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgdHlwZV9hcmd1bWVudHMgOiBcIltcIiB0eXBlX2FyZ19saXN0IFwiXVwiICovXG5jYXNlIDE1OTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHJlYWRhYmxlX2V4cHJlc3Npb24gOiBcIihcIiBleHByZXNzaW9uIFwiKVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLC0sLSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDIsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLC0sLSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSB5eXZzdGFja1t5eXNwIC0gMV07XG4gICAgYnJlYWs7XG5cbmNhc2UgNTA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB0eXBlX2NsYXNzIDogdW5xdWFsaWZpZWRfaWRlbnRpZmllciAqL1xuY2FzZSA1MjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHR5cGVfY2xhc3MgOiB1bnF1YWxpZmllZF9jb25zdHJ1Y3RvciAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlsc3RhY2tbeXlzcF07XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LlR5cGVDbGFzcyh5eXZzdGFja1t5eXNwXSwgbnVsbCwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgNTE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB0eXBlX2NsYXNzIDogdW5xdWFsaWZpZWRfaWRlbnRpZmllciBcIjpcIiB0eXBlICovXG5jYXNlIDUzOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgdHlwZV9jbGFzcyA6IHVucXVhbGlmaWVkX2NvbnN0cnVjdG9yIFwiOlwiIHR5cGUgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDIsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5UeXBlQ2xhc3MoeXl2c3RhY2tbeXlzcCAtIDJdLCB5eXZzdGFja1t5eXNwXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgNTQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB0eXBlIDogY29ucyB0eXBlX29wdGlvbiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LlR5cGUoeXl2c3RhY2tbeXlzcCAtIDFdLCB5eXZzdGFja1t5eXNwXXx8W10sIGZhbHNlLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA1NTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHR5cGUgOiBjb25zIHR5cGVfY2xhc3NlcyBcIltcIiBcIl1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMywgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LlR5cGUoeXl2c3RhY2tbeXlzcCAtIDNdLCB5eXZzdGFja1t5eXNwIC0gMl0sIHRydWUsIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDU2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgdHlwZSA6IGNvbnMgXCJbXCIgXCJdXCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDIsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5UeXBlKHl5dnN0YWNrW3l5c3AgLSAyXSwgW10sIHRydWUsIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDU3OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcGFyYW1ldGVycyA6IFwiKFwiIFwiKVwiICovXG5jYXNlIDk5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYXJndW1lbnRzIDogXCIoXCIgXCIpXCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsLSwtKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsLSwtKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IFtdO1xuICAgIGJyZWFrO1xuXG5jYXNlIDYxOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcGFyYW1ldGVyIDogdW5xdWFsaWZpZWRfaWRlbnRpZmllciBcIjpcIiB0eXBlICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAyLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuVHlwZWRQYXJhbWV0ZXIoeXl2c3RhY2tbeXlzcCAtIDJdLCB5eXZzdGFja1t5eXNwXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgNjI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBwYXJhbWV0ZXIgOiB1bnF1YWxpZmllZF9pZGVudGlmaWVyICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eWxzdGFja1t5eXNwXTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuVW50eXBlZFBhcmFtZXRlcih5eXZzdGFja1t5eXNwXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgNjg6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBub2RlIDogXCI8XCIgaWRlbnRpZmllciBhdHRyaWJ1dGVzIFwiPlwiIG5vZGVfb3B0aW9uIFwiPC9cIiBpZGVudGlmaWVyIFwiPlwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA3LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuTm9kZSh5eXZzdGFja1t5eXNwIC0gNl0sIHl5dnN0YWNrW3l5c3AgLSA1XSwgeXl2c3RhY2tbeXlzcCAtIDNdfHxbXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA2OTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG5vZGUgOiBcIjxcIiBpZGVudGlmaWVyIFwiPlwiIG5vZGVfb3B0aW9uMiBcIjwvXCIgaWRlbnRpZmllciBcIj5cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gNiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0Lk5vZGUoeXl2c3RhY2tbeXlzcCAtIDVdLCBbXSwgeXl2c3RhY2tbeXlzcCAtIDNdfHxbXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA3MDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG5vZGUgOiBcIjxcIiBpZGVudGlmaWVyIGF0dHJpYnV0ZXMgXCIvPlwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAzLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuTm9kZSh5eXZzdGFja1t5eXNwIC0gMl0sIHl5dnN0YWNrW3l5c3AgLSAxXSwgW10sIHl5dnN0YWNrW3l5c3AgLSAyXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgNzE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBub2RlIDogXCI8XCIgaWRlbnRpZmllciBcIi8+XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDIsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5Ob2RlKHl5dnN0YWNrW3l5c3AgLSAxXSwgW10sIFtdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDcyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgd2lkZ2V0IDogXCI8XCIgY29ucyBhdHRyaWJ1dGVzIFwiPlwiIHdpZGdldF9vcHRpb24gXCI8L1wiIGNvbnMgXCI+XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDcsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5XaWRnZXQoeXl2c3RhY2tbeXlzcCAtIDZdLCB5eXZzdGFja1t5eXNwIC0gNV0sIHl5dnN0YWNrW3l5c3AgLSAzXXx8W10sIHl5dnN0YWNrW3l5c3AgLSAxXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgNzM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB3aWRnZXQgOiBcIjxcIiBjb25zIFwiPlwiIHdpZGdldF9vcHRpb24yIFwiPC9cIiBjb25zIFwiPlwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA2LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuV2lkZ2V0KHl5dnN0YWNrW3l5c3AgLSA1XSwgW10sIHl5dnN0YWNrW3l5c3AgLSAzXXx8W10sIHl5dnN0YWNrW3l5c3AgLSAxXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgNzQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB3aWRnZXQgOiBcIjxcIiBjb25zIGF0dHJpYnV0ZXMgXCIvPlwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAzLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuV2lkZ2V0KHl5dnN0YWNrW3l5c3AgLSAyXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCBbXSwgeXl2c3RhY2tbeXlzcCAtIDJdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA3NTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHdpZGdldCA6IFwiPFwiIGNvbnMgXCIvPlwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAyLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuV2lkZ2V0KHl5dnN0YWNrW3l5c3AgLSAxXSwgW10sIFtdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDc4OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYXR0cmlidXRlIDogdW5xdWFsaWZpZWRfaWRlbnRpZmllciBcIjpcIiB1bnF1YWxpZmllZF9pZGVudGlmaWVyIFwiPVwiIGF0dHJpYnV0ZV92YWx1ZSAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gNCwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkF0dHJpYnV0ZSh5eXZzdGFja1t5eXNwIC0gNF0sIHl5dnN0YWNrW3l5c3AgLSAyXSwgeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDc5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYXR0cmlidXRlIDogdW5xdWFsaWZpZWRfaWRlbnRpZmllciBcIj1cIiBhdHRyaWJ1dGVfdmFsdWUgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDIsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID1cbiAgICBuZXcgeXkuYXN0LkF0dHJpYnV0ZShuZXcgeXkuYXN0LlVucXVhbGlmaWVkSWRlbnRpZmllcignaHRtbCcsIHRoaXMuXyQpLFxuICAgIHl5dnN0YWNrW3l5c3AgLSAyXSwgeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDgwOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYXR0cmlidXRlIDogdW5xdWFsaWZpZWRfaWRlbnRpZmllciBcIjpcIiB1bnF1YWxpZmllZF9pZGVudGlmaWVyICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAyLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuQXR0cmlidXRlKHl5dnN0YWNrW3l5c3AgLSAyXSwgeXl2c3RhY2tbeXlzcF0sIG5ldyB5eS5hc3QuQm9vbGVhbkxpdGVyYWwodHJ1ZSwgdGhpcy5fJCksIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDgxOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYXR0cmlidXRlIDogdW5xdWFsaWZpZWRfaWRlbnRpZmllciAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlsc3RhY2tbeXlzcF07XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkF0dHJpYnV0ZShcbiAgICBuZXcgeXkuYXN0LlVucXVhbGlmaWVkSWRlbnRpZmllcignaHRtbCcsIHRoaXMuXyQpLFxuICAgIHl5dnN0YWNrW3l5c3BdLCBuZXcgeXkuYXN0LkJvb2xlYW5MaXRlcmFsKHRydWUsIHRoaXMuXyQpLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA4MzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGludGVycG9sYXRpb24gOiBcInt7XCIgZXhwcmVzc2lvbiBcIn19XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDIsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5JbnRlcnBvbGF0aW9uKHl5dnN0YWNrW3l5c3AgLSAxXSwgW10sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDg0OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgaW50ZXJwb2xhdGlvbiA6IFwie3tcIiBleHByZXNzaW9uIGZpbHRlcnMgXCJ9fVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAzLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuSW50ZXJwb2xhdGlvbih5eXZzdGFja1t5eXNwIC0gMl0sIHl5dnN0YWNrW3l5c3AgLSAxXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgODc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmaWx0ZXIgOiBcInxcIiBleHByZXNzaW9uICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLC0sLSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDEsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLC0sLSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSB5eXZzdGFja1t5eXNwXVxuICAgIGJyZWFrO1xuXG5jYXNlIDg5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZm9yX3N0YXRlbWVudCA6IFwieyVcIiBGT1IgcGFyYW1ldGVyIElOIGV4cHJlc3Npb24gXCIlfVwiIGNoaWxkcmVuIFwieyVcIiBFTkRGT1IgXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA5LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRm9yU3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSA3XSwgbnVsbCwgbnVsbCwgeXl2c3RhY2tbeXlzcCAtIDVdLCB5eXZzdGFja1t5eXNwIC0gM10sIFtdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA5MDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZvcl9zdGF0ZW1lbnQgOiBcInslXCIgRk9SIHBhcmFtZXRlciBcIixcIiBwYXJhbWV0ZXIgSU4gZXhwcmVzc2lvbiBcIiV9XCIgY2hpbGRyZW4gXCJ7JVwiIEVOREZPUiBcIiV9XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDExLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRm9yU3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSA5XSwgeXl2c3RhY2tbeXlzcCAtIDddLCBudWxsLCB5eXZzdGFja1t5eXNwIC0gNV0sIHl5dnN0YWNrW3l5c3AgLSAzXSwgW10sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDkxOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZm9yX3N0YXRlbWVudCA6IFwieyVcIiBGT1IgcGFyYW1ldGVyIFwiLFwiIHBhcmFtZXRlciBcIixcIiBwYXJhbWV0ZXIgSU4gZXhwcmVzc2lvbiBcIiV9XCIgY2hpbGRyZW4gXCJ7JVwiIEVOREZPUiBcIiV9XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDEzLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRm9yU3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSAxMV0sIHl5dnN0YWNrW3l5c3AgLSA5XSwgeXl2c3RhY2tbeXlzcCAtIDddLCB5eXZzdGFja1t5eXNwIC0gNV0sIHl5dnN0YWNrW3l5c3AgLSAzXSwgW10sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDkyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZm9yX3N0YXRlbWVudCA6IFwieyVcIiBGT1IgcGFyYW1ldGVyIElOIGV4cHJlc3Npb24gXCIlfVwiIGNoaWxkcmVuIFwieyVcIiBFTFNFIFwiJX1cIiBjaGlsZHJlbiBcInslXCIgRU5ERk9SIFwiJX1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMTMsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5Gb3JTdGF0ZW1lbnQoeXl2c3RhY2tbeXlzcCAtIDExXSwgbnVsbCwgbnVsbCwgeXl2c3RhY2tbeXlzcCAtIDldLCB5eXZzdGFja1t5eXNwIC0gN10sIHl5dnN0YWNrW3l5c3AgLSAzXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgOTM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmb3Jfc3RhdGVtZW50IDogXCJ7JVwiIEZPUiBwYXJhbWV0ZXIgXCIsXCIgcGFyYW1ldGVyIElOIGV4cHJlc3Npb24gXCIlfVwiIGNoaWxkcmVuIFwieyVcIiBFTFNFIFwiJX1cIiBjaGlsZHJlbiBcInslXCIgRU5ERk9SIFwiJX1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMTUsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5Gb3JTdGF0ZW1lbnQoeXl2c3RhY2tbeXlzcCAtIDEzXSwgeXl2c3RhY2tbeXlzcCAtIDExXSwgbnVsbCwgeXl2c3RhY2tbeXlzcCAtIDldLCB5eXZzdGFja1t5eXNwIC0gN10sIHl5dnN0YWNrW3l5c3AgLSAzXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgOTQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmb3Jfc3RhdGVtZW50IDogXCJ7JVwiIEZPUiBwYXJhbWV0ZXIgXCIsXCIgcGFyYW1ldGVyIFwiLFwiIHBhcmFtZXRlciBJTiBleHByZXNzaW9uIFwiJX1cIiBjaGlsZHJlbiBcInslXCIgRUxTRSBcIiV9XCIgY2hpbGRyZW4gXCJ7JVwiIEVOREZPUiBcIiV9XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDE3LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRm9yU3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSAxNV0sIHl5dnN0YWNrW3l5c3AgLSAxM10sIG51bGwsIHl5dnN0YWNrW3l5c3AgLSAxMV0sIHl5dnN0YWNrW3l5c3AgLSA5XSwgeXl2c3RhY2tbeXlzcCAtIDNdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA5NTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGlmX3N0YXRlbWVudCA6IFwieyVcIiBJRiBleHByZXNzaW9uIFwiJX1cIiBjaGlsZHJlbiBlbHNlX2NsYXVzZSAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gNSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LklmU3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSAzXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB5eXZzdGFja1t5eXNwXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgOTY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBlbHNlX2NsYXVzZSA6IFwieyVcIiBFTFNFIFwiJX1cIiBjaGlsZHJlbiBcInslXCIgRU5ESUYgXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA2LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRWxzZUNsYXVzZSh5eXZzdGFja1t5eXNwIC0gM10sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDk3OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZWxzZV9jbGF1c2UgOiBcInslXCIgRUxTRSBJRiBleHByZXNzaW9uIFwiJX1cIiBjaGlsZHJlbiBlbHNlX2NsYXVzZSAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gNiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkVsc2VJZkNsYXVzZSh5eXZzdGFja1t5eXNwIC0gM10sIHl5dnN0YWNrW3l5c3AgLSAxXSwgeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDk4OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY2hhcmFjdGVycyA6IENIQVJBQ1RFUlMgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5bHN0YWNrW3l5c3BdO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5DaGFyYWN0ZXJzKHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxMDU6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBleHByZXNzaW9uIDogdW5hcnlfZXhwcmVzc2lvbiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSwtLC0pOlxuICAgIHRoaXMuXyQgPSB5eWxzdGFja1t5eXNwXTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSwtLC0pXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID15eXZzdGFja1t5eXNwXTtcbiAgICBicmVhaztcblxuY2FzZSAxMTA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBpZl9leHByZXNzaW9uIDogSUYgZXhwcmVzc2lvbiBUSEVOIGV4cHJlc3Npb24gRUxTRSBleHByZXNzaW9uICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA1LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuSWZUaGVuRXhwcmVzc2lvbih5eXZzdGFja1t5eXNwIC0gNF0sIHl5dnN0YWNrW3l5c3AgLSAyXSwgeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDExMTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGJpbmFyeV9leHByZXNzaW9uIDogc2ltcGxlX2V4cHJlc3Npb24gYmluYXJ5X29wZXJhdG9yIHNpbXBsZV9leHByZXNzaW9uICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAyLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuQmluYXJ5RXhwcmVzc2lvbih5eXZzdGFja1t5eXNwIC0gMl0sIHl5dnN0YWNrW3l5c3AgLSAxXSwgeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDExMjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGJpbmFyeV9leHByZXNzaW9uIDogc2ltcGxlX2V4cHJlc3Npb24gYmluYXJ5X29wZXJhdG9yIFwiKFwiIGV4cHJlc3Npb24gXCIpXCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDQsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5CaW5hcnlFeHByZXNzaW9uKHl5dnN0YWNrW3l5c3AgLSA0XSwgeXl2c3RhY2tbeXlzcCAtIDNdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDExMzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGJpbmFyeV9leHByZXNzaW9uIDogXCIoXCIgZXhwcmVzc2lvbiBcIilcIiBiaW5hcnlfb3BlcmF0b3Igc2ltcGxlX2V4cHJlc3Npb24gKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDQsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5CaW5hcnlFeHByZXNzaW9uKHl5dnN0YWNrW3l5c3AgLSAzXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB5eXZzdGFja1t5eXNwXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTE0OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYmluYXJ5X2V4cHJlc3Npb24gOiBcIihcIiBleHByZXNzaW9uIFwiKVwiIGJpbmFyeV9vcGVyYXRvciBcIihcIiBleHByZXNzaW9uIFwiKVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA2LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuQmluYXJ5RXhwcmVzc2lvbih5eXZzdGFja1t5eXNwIC0gNV0sIHl5dnN0YWNrW3l5c3AgLSAzXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxMTU6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB1bmFyeV9leHByZXNzaW9uIDogXCIhXCIgc2ltcGxlX2V4cHJlc3Npb24gKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDEsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5VbmFyeUV4cHJlc3Npb24oeXl2c3RhY2tbeXlzcCAtIDFdLCB5eXZzdGFja1t5eXNwXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTE2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgdW5hcnlfZXhwcmVzc2lvbiA6IFwiIVwiIFwiKFwiIGV4cHJlc3Npb24gXCIpXCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDMsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5VbmFyeUV4cHJlc3Npb24oeXl2c3RhY2tbeXlzcCAtIDNdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDExODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHZpZXdfY29uc3RydWN0aW9uIDogXCI8XCIgY29ucyBhcmd1bWVudHMgXCI+XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDMsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5WaWV3Q29uc3RydWN0aW9uKHl5dnN0YWNrW3l5c3AgLSAyXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxMTk6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5fYXBwbGljYXRpb24gOiBcIjxcIiBmdW5fdGFyZ2V0IHR5cGVfYXJndW1lbnRzIGFyZ3VtZW50cyBhcmd1bWVudHMgXCI+XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDUsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5GdW5BcHBsaWNhdGlvbih5eXZzdGFja1t5eXNwIC0gNF0sIHl5dnN0YWNrW3l5c3AgLSAzXSwgeXl2c3RhY2tbeXlzcCAtIDJdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDEyMDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZ1bl9hcHBsaWNhdGlvbiA6IFwiPFwiIGZ1bl90YXJnZXQgdHlwZV9hcmd1bWVudHMgYXJndW1lbnRzIFwiPlwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA0LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRnVuQXBwbGljYXRpb24oeXl2c3RhY2tbeXlzcCAtIDNdLCB5eXZzdGFja1t5eXNwIC0gMl0sIFtdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDEyMTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZ1bl9hcHBsaWNhdGlvbiA6IFwiPFwiIGZ1bl90YXJnZXQgYXJndW1lbnRzIGFyZ3VtZW50cyBcIj5cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gNCwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZ1bkFwcGxpY2F0aW9uKHl5dnN0YWNrW3l5c3AgLSAzXSwgW10sIHl5dnN0YWNrW3l5c3AgLSAyXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxMjI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5fYXBwbGljYXRpb24gOiBcIjxcIiBmdW5fdGFyZ2V0IGFyZ3VtZW50cyBcIj5cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMywgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZ1bkFwcGxpY2F0aW9uKHl5dnN0YWNrW3l5c3AgLSAyXSwgW10sIFtdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDEyOTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNvbnN0cnVjdF9leHByZXNzaW9uIDogY29ucyBhcmd1bWVudHMgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDEsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5Db25zdHJ1Y3RFeHByZXNzaW9uKHl5dnN0YWNrW3l5c3AgLSAxXSwgeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDEzMDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNhbGxfZXhwcmVzc2lvbiA6IGlkZW50aWZpZXIgdHlwZV9hcmd1bWVudHMgYXJndW1lbnRzICovXG5jYXNlIDEzMjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNhbGxfZXhwcmVzc2lvbiA6IGNvbnRleHRfcHJvcGVydHkgdHlwZV9hcmd1bWVudHMgYXJndW1lbnRzICovXG5jYXNlIDEzNDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNhbGxfZXhwcmVzc2lvbiA6IG1lbWJlcl9leHByZXNzaW9uIHR5cGVfYXJndW1lbnRzIGFyZ3VtZW50cyAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkNhbGxFeHByZXNzaW9uKHl5dnN0YWNrW3l5c3AgLSAyXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB5eXZzdGFja1t5eXNwXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTMxOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY2FsbF9leHByZXNzaW9uIDogaWRlbnRpZmllciBhcmd1bWVudHMgKi9cbmNhc2UgMTMzOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY2FsbF9leHByZXNzaW9uIDogY29udGV4dF9wcm9wZXJ0eSBhcmd1bWVudHMgKi9cbmNhc2UgMTM1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY2FsbF9leHByZXNzaW9uIDogbWVtYmVyX2V4cHJlc3Npb24gYXJndW1lbnRzICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAxLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuQ2FsbEV4cHJlc3Npb24oeXl2c3RhY2tbeXlzcCAtIDFdLCBbXSwgeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDEzNjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNhbGxfZXhwcmVzc2lvbiA6IFwiKFwiIGV4cHJlc3Npb24gXCIpXCIgdHlwZV9hcmd1bWVudHMgYXJndW1lbnRzICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA0LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuQ2FsbEV4cHJlc3Npb24oeXl2c3RhY2tbeXlzcCAtIDNdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxMzc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjYWxsX2V4cHJlc3Npb24gOiBcIihcIiBleHByZXNzaW9uIFwiKVwiIGFyZ3VtZW50cyAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMywgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkNhbGxFeHByZXNzaW9uKHl5dnN0YWNrW3l5c3AgLSAyXSwgW10sIHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxMzg6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtZW1iZXJfZXhwcmVzc2lvbiA6IHF1YWxpZmllZF9pZGVudGlmaWVyIFwiLlwiIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgKi9cbmNhc2UgMTM5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWVtYmVyX2V4cHJlc3Npb24gOiBxdWFsaWZpZWRfY29uc3RydWN0b3IgXCIuXCIgdW5xdWFsaWZpZWRfaWRlbnRpZmllciAqL1xuY2FzZSAxNDA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtZW1iZXJfZXhwcmVzc2lvbiA6IGNvbnRleHRfdmFyaWFibGUgXCIuXCIgdW5xdWFsaWZpZWRfaWRlbnRpZmllciAqL1xuY2FzZSAxNDE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtZW1iZXJfZXhwcmVzc2lvbiA6IGNvbnRleHRfcHJvcGVydHkgXCIuXCIgdW5xdWFsaWZpZWRfaWRlbnRpZmllciAqL1xuY2FzZSAxNDI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtZW1iZXJfZXhwcmVzc2lvbiA6IGxpc3QgXCIuXCIgdW5xdWFsaWZpZWRfaWRlbnRpZmllciAqL1xuY2FzZSAxNDM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtZW1iZXJfZXhwcmVzc2lvbiA6IHJlY29yZCBcIi5cIiB1bnF1YWxpZmllZF9pZGVudGlmaWVyICovXG5jYXNlIDE0NDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1lbWJlcl9leHByZXNzaW9uIDogc3RyaW5nX2xpdGVyYWwgXCIuXCIgdW5xdWFsaWZpZWRfaWRlbnRpZmllciAqL1xuY2FzZSAxNDU6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtZW1iZXJfZXhwcmVzc2lvbiA6IGNhbGxfZXhwcmVzc2lvbiBcIi5cIiB1bnF1YWxpZmllZF9pZGVudGlmaWVyICovXG5jYXNlIDE0NzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1lbWJlcl9leHByZXNzaW9uIDogbWVtYmVyX2V4cHJlc3Npb24gXCIuXCIgdW5xdWFsaWZpZWRfaWRlbnRpZmllciAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0Lk1lbWJlckV4cHJlc3Npb24oeXl2c3RhY2tbeXlzcCAtIDJdLCB5eXZzdGFja1t5eXNwXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTQ2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWVtYmVyX2V4cHJlc3Npb24gOiBcIihcIiBleHByZXNzaW9uIFwiKVwiIFwiLlwiIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDQsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5NZW1iZXJFeHByZXNzaW9uKHl5dnN0YWNrW3l5c3AgLSAzXSwgeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDE0ODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHJlYWRfZXhwcmVzc2lvbiA6IGlkZW50aWZpZXIgXCJbXCIgcmVhZGFibGVfZXhwcmVzc2lvbiBBUyB0eXBlIFwiXVwiICovXG5jYXNlIDE1MDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHJlYWRfZXhwcmVzc2lvbiA6IGNvbnRleHRfdmFyaWFibGUgXCJbXCIgcmVhZGFibGVfZXhwcmVzc2lvbiBBUyB0eXBlIFwiXVwiICovXG5jYXNlIDE1MjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHJlYWRfZXhwcmVzc2lvbiA6IGNvbnRleHRfcHJvcGVydHkgXCJbXCIgcmVhZGFibGVfZXhwcmVzc2lvbiBBUyB0eXBlIFwiXVwiICovXG5jYXNlIDE1NDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHJlYWRfZXhwcmVzc2lvbiA6IG1lbWJlcl9leHByZXNzaW9uIFwiW1wiIHJlYWRhYmxlX2V4cHJlc3Npb24gQVMgdHlwZSBcIl1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gNSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LlJlYWRFeHByZXNzaW9uKHl5dnN0YWNrW3l5c3AgLSA1XSwgeXl2c3RhY2tbeXlzcCAtIDNdLCB5eXZzdGFja1t5eXNwIC0gMV0sIG51bGwsIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDE0OTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHJlYWRfZXhwcmVzc2lvbiA6IGlkZW50aWZpZXIgXCJbXCIgcmVhZGFibGVfZXhwcmVzc2lvbiBBUyB0eXBlIFwiP1wiIGV4cHJlc3Npb24gXCJdXCIgKi9cbmNhc2UgMTUxOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcmVhZF9leHByZXNzaW9uIDogY29udGV4dF92YXJpYWJsZSBcIltcIiByZWFkYWJsZV9leHByZXNzaW9uIEFTIHR5cGUgXCI/XCIgZXhwcmVzc2lvbiBcIl1cIiAqL1xuY2FzZSAxNTM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICByZWFkX2V4cHJlc3Npb24gOiBjb250ZXh0X3Byb3BlcnR5IFwiW1wiIHJlYWRhYmxlX2V4cHJlc3Npb24gQVMgdHlwZSBcIj9cIiBleHByZXNzaW9uIFwiXVwiICovXG5jYXNlIDE1NTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHJlYWRfZXhwcmVzc2lvbiA6IG1lbWJlcl9leHByZXNzaW9uIFwiW1wiIHJlYWRhYmxlX2V4cHJlc3Npb24gQVMgdHlwZSBcIj9cIiBleHByZXNzaW9uIFwiXVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA3LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuUmVhZEV4cHJlc3Npb24oeXl2c3RhY2tbeXlzcCAtIDddLCB5eXZzdGFja1t5eXNwIC0gNV0sIHl5dnN0YWNrW3l5c3AgLSAzXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxNTY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICByZWFkX2V4cHJlc3Npb24gOiBcIihcIiBleHByZXNzaW9uIFwiKVwiIFwiW1wiIGV4cHJlc3Npb24gQVMgdHlwZSBcIj9cIiBleHByZXNzaW9uIFwiXVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA5LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuUmVhZEV4cHJlc3Npb24oeXl2c3RhY2tbeXlzcCAtIDldLCB5eXZzdGFja1t5eXNwIC0gN10sIHl5dnN0YWNrW3l5c3AgLSA1XSwgeXl2c3RhY2tbeXlzcCAtIDNdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxNTc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICByZWFkX2V4cHJlc3Npb24gOiBcIihcIiBleHByZXNzaW9uIFwiKVwiIFwiW1wiIGV4cHJlc3Npb24gQVMgdHlwZSBcIl1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gNywgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LlJlYWRFeHByZXNzaW9uKHl5dnN0YWNrW3l5c3AgLSA3XSwgeXl2c3RhY2tbeXlzcCAtIDVdLCB5eXZzdGFja1t5eXNwIC0gM10sIG51bGwsIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDE2MDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZ1bmN0aW9uX2V4cHJlc3Npb24gOiBcIlxcXFxcIiBwYXJhbWV0ZXJfbGlzdCBcIj0+XCIgZXhwcmVzc2lvbiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMywgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZ1bmN0aW9uRXhwcmVzc2lvbih5eXZzdGFja1t5eXNwIC0gMl0sIHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxNjE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5jdGlvbl9leHByZXNzaW9uIDogXCI9PlwiIGV4cHJlc3Npb24gKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDEsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5GdW5jdGlvbkV4cHJlc3Npb24oW10sIHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxNjM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICByZWNvcmQgOiBcIntcIiBcIn1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LlJlY29yZChbXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTY0OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcmVjb3JkIDogXCJ7XCIgcHJvcGVydGllcyBcIn1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LlJlY29yZCh5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDE2NzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHByb3BlcnR5IDogcHJvcGVydHlfZ3JvdXAgXCI6XCIgZXhwcmVzc2lvbiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LlByb3BlcnR5KHl5dnN0YWNrW3l5c3AgLSAyXSwgeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDE2ODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGxpc3QgOiBcIltcIiBcIl1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0Lkxpc3QoW10sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDE2OTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGxpc3QgOiBcIltcIiBhcmd1bWVudF9saXN0IFwiXVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAyLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuTGlzdCh5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDE3MDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHN0cmluZ19saXRlcmFsIDogU1RSSU5HX0xJVEVSQUwgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5bHN0YWNrW3l5c3BdO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5TdHJpbmdMaXRlcmFsKHl5dnN0YWNrW3l5c3BdLnNsaWNlKDEsIHl5dnN0YWNrW3l5c3BdLmxlbmd0aCAtIDEsIHRoaXMuXyQpKTtcbiAgICBicmVhaztcblxuY2FzZSAxNzE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBudW1iZXJfbGl0ZXJhbCA6IE5VTUJFUl9MSVRFUkFMICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eWxzdGFja1t5eXNwXTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuTnVtYmVyTGl0ZXJhbCh5eXZzdGFja1t5eXNwXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTcyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYm9vbGVhbl9saXRlcmFsIDogVFJVRSAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlsc3RhY2tbeXlzcF07XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkJvb2xlYW5MaXRlcmFsKHRydWUsIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDE3MzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGJvb2xlYW5fbGl0ZXJhbCA6IEZBTFNFICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eWxzdGFja1t5eXNwXTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuQm9vbGVhbkxpdGVyYWwoZmFsc2UsIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDE3NDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNvbnRleHRfcHJvcGVydHkgOiBcIkBcIiB1bnF1YWxpZmllZF9pZGVudGlmaWVyICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAxLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuQ29udGV4dFByb3BlcnR5KHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKVxuICAgIGJyZWFrO1xuXG5jYXNlIDE3NTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNvbnRleHRfdmFyaWFibGUgOiBcIkBcIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlsc3RhY2tbeXlzcF07XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkNvbnRleHRWYXJpYWJsZSh0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxNzg6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBxdWFsaWZpZWRfY29uc3RydWN0b3IgOiBJREVOVElGSUVSIFwiLlwiIENPTlNUUlVDVE9SICovXG5jYXNlIDE3OTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHF1YWxpZmllZF9jb25zdHJ1Y3RvciA6IENPTlNUUlVDVE9SIFwiLlwiIENPTlNUUlVDVE9SICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAyLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuUXVhbGlmaWVkQ29uc3RydWN0b3IoeXl2c3RhY2tbeXlzcCAtIDJdLCB5eXZzdGFja1t5eXNwXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTgwOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgdW5xdWFsaWZpZWRfY29uc3RydWN0b3IgOiBDT05TVFJVQ1RPUiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlsc3RhY2tbeXlzcF07XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LlVucXVhbGlmaWVkQ29uc3RydWN0b3IoeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDE4MzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHF1YWxpZmllZF9pZGVudGlmaWVyIDogSURFTlRJRklFUiBcIi5cIiBJREVOVElGSUVSICovXG5jYXNlIDE4NDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHF1YWxpZmllZF9pZGVudGlmaWVyIDogQ09OU1RSVUNUT1IgXCIuXCIgSURFTlRJRklFUiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LlF1YWxpZmllZElkZW50aWZpZXIoeXl2c3RhY2tbeXlzcCAtIDJdLCB5eXZzdGFja1t5eXNwXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTg1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgdW5xdWFsaWZpZWRfaWRlbnRpZmllciA6IElERU5USUZJRVIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5bHN0YWNrW3l5c3BdO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5VbnF1YWxpZmllZElkZW50aWZpZXIoeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDE4NzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGltcG9ydF9zdGF0ZW1lbnRfb3B0aW9uIDogJWVwc2lsb24gKi9cbmNhc2UgMTk1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWFpbl9vcHRpb24gOiAlZXBzaWxvbiAqL1xuY2FzZSAxOTc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtYWluX29wdGlvbjIgOiAlZXBzaWxvbiAqL1xuY2FzZSAxOTk6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtYWluX29wdGlvbjMgOiAlZXBzaWxvbiAqL1xuY2FzZSAyMDE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtYWluX29wdGlvbjQgOiAlZXBzaWxvbiAqL1xuY2FzZSAyMDM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB2aWV3X3N0YXRlbWVudF9vcHRpb24gOiAlZXBzaWxvbiAqL1xuY2FzZSAyMDU6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB2aWV3X3N0YXRlbWVudF9vcHRpb24yIDogJWVwc2lsb24gKi9cbmNhc2UgMjA3OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgdHlwZV9vcHRpb24gOiAlZXBzaWxvbiAqL1xuY2FzZSAyMTQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBub2RlX29wdGlvbiA6ICVlcHNpbG9uICovXG5jYXNlIDIxNjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG5vZGVfb3B0aW9uMiA6ICVlcHNpbG9uICovXG5jYXNlIDIxODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHdpZGdldF9vcHRpb24gOiAlZXBzaWxvbiAqL1xuY2FzZSAyMjA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB3aWRnZXRfb3B0aW9uMiA6ICVlcHNpbG9uICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLC0sLSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8obnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgdHJ1ZSk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsLSwtKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IHVuZGVmaW5lZDtcbiAgICBicmVhaztcblxufVxufSxcbnRhYmxlOiBidCh7XG4gIGxlbjogdShbXG4gIDE1LFxuICAxLFxuICAxNCxcbiAgMTEsXG4gIDEsXG4gIDAsXG4gIDAsXG4gIDQsXG4gIDAsXG4gIDEyLFxuICBzLFxuICBbMCwgNV0sXG4gIDgsXG4gIGMsXG4gIFsxMywgNF0sXG4gIGMsXG4gIFszLCAzXSxcbiAgMCxcbiAgNSxcbiAgcyxcbiAgWzIsIDNdLFxuICBjLFxuICBbOCwgNF0sXG4gIDEsXG4gIDEsXG4gIDksXG4gIHMsXG4gIFswLCA1XSxcbiAgNixcbiAgNixcbiAgcyxcbiAgWzAsIDRdLFxuICAyOSxcbiAgMjksXG4gIGMsXG4gIFsyMCwgNF0sXG4gIDQsXG4gIDAsXG4gIDEsXG4gIDQsXG4gIDcsXG4gIDIsXG4gIDYsXG4gIDYsXG4gIDIsXG4gIDAsXG4gIDMsXG4gIDAsXG4gIDUsXG4gIDIzLFxuICBjLFxuICBbNDQsIDNdLFxuICBjLFxuICBbNSwgM10sXG4gIDIsXG4gIDIsXG4gIGMsXG4gIFs1NSwgM10sXG4gIDYsXG4gIGMsXG4gIFs1MSwgM10sXG4gIDUsXG4gIDQsXG4gIDIsXG4gIDIxLFxuICAyMCxcbiAgMTAsXG4gIGMsXG4gIFs0NiwgNV0sXG4gIDgsXG4gIGMsXG4gIFsyOCwgM10sXG4gIDEsXG4gIDIxLFxuICBzLFxuICBbMCwgN10sXG4gIDQzLFxuICBzLFxuICBbMCwgNF0sXG4gIDEwLFxuICAxLFxuICAyLFxuICAyLFxuICAxNyxcbiAgMjMsXG4gIGMsXG4gIFsyMSwgN10sXG4gIGMsXG4gIFs2NCwgNF0sXG4gIDMsXG4gIDEsXG4gIDYsXG4gIGMsXG4gIFs0OCwgNF0sXG4gIGMsXG4gIFszLCAzXSxcbiAgNSxcbiAgMjEsXG4gIDIwLFxuICAyMCxcbiAgMSxcbiAgMSxcbiAgMCxcbiAgMixcbiAgOSxcbiAgYyxcbiAgWzY2LCAzXSxcbiAgYyxcbiAgWzExNSwgNF0sXG4gIDMsXG4gIGMsXG4gIFszOCwgM10sXG4gIDUsXG4gIGMsXG4gIFsxMDcsIDNdLFxuICAwLFxuICAwLFxuICAyNixcbiAgYyxcbiAgWzYxLCAzXSxcbiAgNDMsXG4gIDMzLFxuICAwLFxuICAyOCxcbiAgMjYsXG4gIDI5LFxuICAyOSxcbiAgNCxcbiAgYyxcbiAgWzcwLCA0XSxcbiAgMjUsXG4gIDAsXG4gIDI2LFxuICAyNyxcbiAgMjgsXG4gIDI3LFxuICBzLFxuICBbMjUsIDNdLFxuICAxMixcbiAgMCxcbiAgNDUsXG4gIDgsXG4gIHMsXG4gIFswLCA1XSxcbiAgMSxcbiAgMSxcbiAgMyxcbiAgNDMsXG4gIGMsXG4gIFs0MiwgNF0sXG4gIGMsXG4gIFsxMiwgNV0sXG4gIDIxLFxuICA1LFxuICBjLFxuICBbNzEsIDNdLFxuICA1LFxuICBjLFxuICBbMTc2LCAzXSxcbiAgMSxcbiAgYyxcbiAgWzg2LCAzXSxcbiAgYyxcbiAgWzg1LCA0XSxcbiAgYyxcbiAgWzQsIDRdLFxuICAyMCxcbiAgMSxcbiAgMyxcbiAgYyxcbiAgWzg0LCA1XSxcbiAgNyxcbiAgNyxcbiAgNixcbiAgMSxcbiAgMSxcbiAgNSxcbiAgMSxcbiAgYyxcbiAgWzEwLCAzXSxcbiAgYyxcbiAgWzgyLCAzXSxcbiAgcyxcbiAgWzAsIDE0XSxcbiAgYyxcbiAgWzU0LCAzXSxcbiAgNDMsXG4gIDE1LFxuICAxNSxcbiAgMTQsXG4gIDExLFxuICAyNCxcbiAgMixcbiAgMCxcbiAgNDUsXG4gIDIwLFxuICAyLFxuICAyNCxcbiAgYyxcbiAgWzIwOSwgM10sXG4gIGMsXG4gIFs0LCA0XSxcbiAgMixcbiAgMCxcbiAgYyxcbiAgWzQsIDVdLFxuICBzLFxuICBbMiwgNF0sXG4gIGMsXG4gIFs5OCwgM10sXG4gIDQzLFxuICBjLFxuICBbMTMsIDRdLFxuICBjLFxuICBbMywgM10sXG4gIGMsXG4gIFsyNjIsIDNdLFxuICAyLFxuICAxLFxuICAxNyxcbiAgNSxcbiAgMSxcbiAgYyxcbiAgWzExNywgNF0sXG4gIDQsXG4gIGMsXG4gIFs5NiwgOF0sXG4gIGMsXG4gIFs0LCA0XSxcbiAgYyxcbiAgWzE4MiwgM10sXG4gIGMsXG4gIFsyOSwgNF0sXG4gIGMsXG4gIFsyOTQsIDRdLFxuICBjLFxuICBbNDYsIDNdLFxuICAzMSxcbiAgNDMsXG4gIDEsXG4gIDcsXG4gIDEsXG4gIDIsXG4gIGMsXG4gIFsyNTEsIDNdLFxuICBjLFxuICBbMzAxLCA0XSxcbiAgcyxcbiAgWzEsIDNdLFxuICBjLFxuICBbNDcsIDNdLFxuICBjLFxuICBbNywgNF0sXG4gIGMsXG4gIFszNCwgN10sXG4gIGMsXG4gIFsyNzQsIDVdLFxuICBjLFxuICBbMTAsIDNdLFxuICAyLFxuICAzLFxuICBjLFxuICBbMTIyLCAzXSxcbiAgMCxcbiAgNixcbiAgNDMsXG4gIDQzLFxuICAzLFxuICAyMSxcbiAgYyxcbiAgWzYyLCA1XSxcbiAgMSxcbiAgYyxcbiAgWzc0LCA4XSxcbiAgYyxcbiAgWzMsIDNdLFxuICBjLFxuICBbMzg3LCA1XSxcbiAgMzMsXG4gIDQ1LFxuICBjLFxuICBbMzUwLCA0XSxcbiAgMTUsXG4gIDYsXG4gIDAsXG4gIDYsXG4gIGMsXG4gIFszNTUsIDNdLFxuICBjLFxuICBbMzkzLCA0XSxcbiAgYyxcbiAgWzQ5LCAzXSxcbiAgYyxcbiAgWzU4LCA2XSxcbiAgMjEsXG4gIDAsXG4gIDQsXG4gIDQsXG4gIGMsXG4gIFszOCwgNV0sXG4gIGMsXG4gIFsxNywgM10sXG4gIDE1LFxuICAwLFxuICA0MyxcbiAgMSxcbiAgMjIsXG4gIGMsXG4gIFsxNjMsIDVdLFxuICA2LFxuICBjLFxuICBbNDQ0LCA2XSxcbiAgMjEsXG4gIDQzLFxuICBjLFxuICBbNzAsIDNdLFxuICA0LFxuICBjLFxuICBbNjcsIDZdLFxuICBjLFxuICBbNTMsIDNdLFxuICA0MyxcbiAgYyxcbiAgWzEwMSwgM10sXG4gIGMsXG4gIFs0LCA0XSxcbiAgYyxcbiAgWzM1OCwgM10sXG4gIGMsXG4gIFsxOTYsIDNdLFxuICBjLFxuICBbMjMsIDNdLFxuICAxNSxcbiAgYyxcbiAgWzE0MCwgNF0sXG4gIDEsXG4gIDQsXG4gIDIxLFxuICA0MyxcbiAgMjEsXG4gIDQzLFxuICAxLFxuICAxLFxuICBjLFxuICBbMTQxLCA2XSxcbiAgMSxcbiAgYyxcbiAgWzIwMSwgM10sXG4gIDIwLFxuICBjLFxuICBbMTU4LCA1XSxcbiAgMjEsXG4gIDQsXG4gIDIxLFxuICBjLFxuICBbMTQzLCAzXSxcbiAgYyxcbiAgWzQ0LCAzXSxcbiAgYyxcbiAgWzMyMCwgM10sXG4gIDMsXG4gIGMsXG4gIFsxNCwgM10sXG4gIGMsXG4gIFsyMCwgM10sXG4gIGMsXG4gIFs0MTUsIDRdLFxuICBjLFxuICBbMTEsIDNdLFxuICAxLFxuICAyMCxcbiAgYyxcbiAgWzEyOCwgNF1cbl0pLFxuICBzeW1ib2w6IHUoW1xuICAxMyxcbiAgMjUsXG4gIDI4LFxuICA2NCxcbiAgNjUsXG4gIDY2LFxuICA3MyxcbiAgcyxcbiAgWzc1LCA1LCAxXSxcbiAgOTAsXG4gIDkxLFxuICA5MixcbiAgMSxcbiAgMSxcbiAgYyxcbiAgWzE3LCAzXSxcbiAgYyxcbiAgWzE1LCAxMV0sXG4gIDEzLFxuICAyOCxcbiAgNzMsXG4gIGMsXG4gIFsxMSwgOF0sXG4gIDI5LFxuICAzMixcbiAgMzMsXG4gIDM1LFxuICAzLFxuICA0LFxuICA1NSxcbiAgNTYsXG4gIHMsXG4gIFs2NywgNCwgMV0sXG4gIDcyLFxuICAxMzQsXG4gIDEzNyxcbiAgMTQyLFxuICA1NSxcbiAgNTYsXG4gIHMsXG4gIFsxMzIsIDYsIDFdLFxuICBjLFxuICBbMzYsIDEyXSxcbiAgMSxcbiAgNyxcbiAgMTAsXG4gIDU2LFxuICAxMzQsXG4gIDE0MyxcbiAgNCxcbiAgNzAsXG4gIDU2LFxuICAxMzQsXG4gIDU1LFxuICAxMzcsXG4gIDI2LFxuICAyNyxcbiAgMjcsXG4gIDU1LFxuICA1NixcbiAgNjgsXG4gIDcxLFxuICBjLFxuICBbNDMsIDNdLFxuICAxNDAsXG4gIDE0MixcbiAgMTQsXG4gIDM4LFxuICA1NSxcbiAgOTMsXG4gIDk0LFxuICAxMzcsXG4gIGMsXG4gIFs2LCA2XSxcbiAgcyxcbiAgWzUsIDcsIDFdLFxuICAxMyxcbiAgMTQsXG4gIDE1LFxuICAxNyxcbiAgcyxcbiAgWzIxLCA0LCAxXSxcbiAgMjcsXG4gIDMwLFxuICAzOCxcbiAgNDAsXG4gIDQ0LFxuICA0OCxcbiAgNTUsXG4gIHMsXG4gIFs1NywgNywgMV0sXG4gIGMsXG4gIFsyOSwgMjldLFxuICBjLFxuICBbOTQsIDNdLFxuICA4MSxcbiAgMTQ0LFxuICAyNixcbiAgYyxcbiAgWzUsIDNdLFxuICAxNDcsXG4gIDcsXG4gIDksXG4gIDEwLFxuICAzMCxcbiAgODAsXG4gIDgxLFxuICA4NSxcbiAgNTEsXG4gIDEyNyxcbiAgNTUsXG4gIDU2LFxuICBjLFxuICBbMTM5LCA2XSxcbiAgYyxcbiAgWzYsIDRdLFxuICA1LFxuICA2LFxuICA1LFxuICA2LFxuICAyNyxcbiAgYyxcbiAgWzEwMCwgM10sXG4gIDk0LFxuICAxMzcsXG4gIDEzLFxuICAyOCxcbiAgMzcsXG4gIDM5LFxuICA0NyxcbiAgNTUsXG4gIDU2LFxuICBzLFxuICBbODgsIDUsIDFdLFxuICA5NixcbiAgOTksXG4gIDEwMCxcbiAgMTAxLFxuICAxMDMsXG4gIGMsXG4gIFsxNjcsIDNdLFxuICAxNTAsXG4gIDE1MixcbiAgMTU2LFxuICA5LFxuICAxMixcbiAgYyxcbiAgWzMwLCAzXSxcbiAgYyxcbiAgWzMzLCAyNl0sXG4gIDE1NCxcbiAgMTU2LFxuICA1NSxcbiAgNTYsXG4gIDU1LFxuICA1NixcbiAgNyxcbiAgNTUsXG4gIDU2LFxuICA4MixcbiAgODMsXG4gIDEzNCxcbiAgMTM3LFxuICA1MSxcbiAgMTI3LFxuICA3LFxuICA3LFxuICA5LFxuICAzMCxcbiAgODAsXG4gIDg1LFxuICBjLFxuICBbNSwgM10sXG4gIDg1LFxuICA5LFxuICAzMCxcbiAgMTMsXG4gIDI4LFxuICBjLFxuICBbNDcsIDE4XSxcbiAgMTU2LFxuICBjLFxuICBbMjEsIDZdLFxuICBjLFxuICBbMjAsIDE0XSxcbiAgOCxcbiAgNTUsXG4gIDU2LFxuICA4NCxcbiAgODYsXG4gIDg3LFxuICBjLFxuICBbMjgxLCAzXSxcbiAgYyxcbiAgWzI3OSwgM10sXG4gIDIwLFxuICAyNSxcbiAgMjgsXG4gIDEzOSxcbiAgYyxcbiAgWzI1OCwgM10sXG4gIGMsXG4gIFsxNTUsIDNdLFxuICAxNDEsXG4gIDE0MixcbiAgYyxcbiAgWzExMywgMjFdLFxuICAxNTEsXG4gIDE1NixcbiAgMzcsXG4gIGMsXG4gIFsyNCwgN10sXG4gIGMsXG4gIFs2OSwgMTRdLFxuICBzLFxuICBbNCwgNiwgM10sXG4gIDQ1LFxuICBzLFxuICBbNDksIDgsIDFdLFxuICBzLFxuICBbMTA2LCA3LCAxXSxcbiAgcyxcbiAgWzExNiwgNCwgMV0sXG4gIDEyMSxcbiAgMTIyLFxuICAxMjMsXG4gIHMsXG4gIFsxMjYsIDEyLCAxXSxcbiAgMTU3LFxuICAxNTksXG4gIDEzLFxuICAxNCxcbiAgMTcsXG4gIDI4LFxuICAzMCxcbiAgYyxcbiAgWzY3LCA1XSxcbiAgMTcsXG4gIDQxLFxuICA0NSxcbiAgNTUsXG4gIDEzNyxcbiAgNCxcbiAgMTAsXG4gIDM5LFxuICBjLFxuICBbNTIsIDRdLFxuICA5NSxcbiAgOTYsXG4gIGMsXG4gIFs0MCwgNl0sXG4gIDE1NSxcbiAgMTU5LFxuICBjLFxuICBbMTIwLCAyMV0sXG4gIDE1MyxcbiAgYyxcbiAgWzEyMCwgMjNdLFxuICBjLFxuICBbMTg4LCAzXSxcbiAgYyxcbiAgWzg4LCAzXSxcbiAgNixcbiAgMTEsXG4gIDYsXG4gIDExLFxuICAxMixcbiAgYyxcbiAgWzMsIDNdLFxuICAzMCxcbiAgYyxcbiAgWzE1LCA2XSxcbiAgYyxcbiAgWzI1NywgNDddLFxuICBjLFxuICBbMzAwLCA0NV0sXG4gIDg2LFxuICA4NyxcbiAgYyxcbiAgWzM5NCwgM10sXG4gIGMsXG4gIFs0NiwgMzldLFxuICBjLFxuICBbMjAsIDIwXSxcbiAgMzAsXG4gIDgsXG4gIDYsXG4gIDgsXG4gIDYsXG4gIDgsXG4gIDEwLFxuICAxMSxcbiAgMTgsXG4gIDQyLFxuICA1MCxcbiAgODEsXG4gIDE0OSxcbiAgNixcbiAgOCxcbiAgMTIsXG4gIDQyLFxuICA1MCxcbiAgYyxcbiAgWzUsIDNdLFxuICAxNyxcbiAgYyxcbiAgWzE4LCA0XSxcbiAgMTQsXG4gIDE3LFxuICBjLFxuICBbMjAsIDNdLFxuICBjLFxuICBbNTI3LCAzXSxcbiAgYyxcbiAgWzIzMywgMjRdLFxuICBjLFxuICBbNywgM10sXG4gIDE1LFxuICA0MCxcbiAgOTcsXG4gIDk4LFxuICA1LFxuICA2LFxuICA4LFxuICA5LFxuICBjLFxuICBbNjIxLCA0XSxcbiAgYyxcbiAgWzYyMCwgNl0sXG4gIGMsXG4gIFs2MTksIDNdLFxuICBjLFxuICBbNjE4LCA3XSxcbiAgMTM4LFxuICAxNjEsXG4gIGMsXG4gIFszODgsIDQzXSxcbiAgYyxcbiAgWzQzLCA0N10sXG4gIDE5LFxuICBjLFxuICBbMzksIDZdLFxuICBjLFxuICBbMzUsIDZdLFxuICBjLFxuICBbMzMsIDE2XSxcbiAgYyxcbiAgWzc2OCwgMTBdLFxuICBjLFxuICBbMTQ3LCAxNl0sXG4gIDEwNCxcbiAgMTE0LFxuICBjLFxuICBbMTczLCA0XSxcbiAgYyxcbiAgWzc5NSwgMTJdLFxuICBjLFxuICBbMjgsIDEwXSxcbiAgYyxcbiAgWzgyMiwgMTddLFxuICBjLFxuICBbNTUsIDE0XSxcbiAgYyxcbiAgWzI5LCAyN10sXG4gIGMsXG4gIFszODcsIDRdLFxuICBjLFxuICBbMTkyLCA0M10sXG4gIGMsXG4gIFszMDQsIDhdLFxuICBjLFxuICBbMTMwLCAyMl0sXG4gIGMsXG4gIFsxODMsIDIxXSxcbiAgYyxcbiAgWzEyNywgMjddLFxuICBjLFxuICBbMjA5LCAxOV0sXG4gIGMsXG4gIFsxMDAzLCA4XSxcbiAgYyxcbiAgWzEwNjIsIDE4XSxcbiAgYyxcbiAgWzU1LCAxNF0sXG4gIGMsXG4gIFsyNSwgNzFdLFxuICA3LFxuICAxOSxcbiAgNTUsXG4gIDU2LFxuICAxMTMsXG4gIDEzMCxcbiAgYyxcbiAgWzIyMiwgNl0sXG4gIGMsXG4gIFsyNjMsIDNdLFxuICAxMSxcbiAgYyxcbiAgWzI2NCwgMTJdLFxuICBzLFxuICBbMTA1LCA4LCAxXSxcbiAgYyxcbiAgWzI2NSwgMjJdLFxuICA1MSxcbiAgNTUsXG4gIDEyNCxcbiAgMTI1LFxuICAxMjcsXG4gIDEzNyxcbiAgMTYwLFxuICBzLFxuICBbNTUsIDNdLFxuICBjLFxuICBbMzIxLCA0NV0sXG4gIDksXG4gIGMsXG4gIFsxMTUxLCAzXSxcbiAgYyxcbiAgWzY2MCwgMjRdLFxuICBjLFxuICBbMzYsIDNdLFxuICA4LFxuICAxNyxcbiAgNTUsXG4gIDU2LFxuICBjLFxuICBbMTE0OSwgM10sXG4gIGMsXG4gIFs4OTAsIDZdLFxuICBjLFxuICBbNiwgNl0sXG4gIDgsXG4gIGMsXG4gIFs4NTAsIDQzXSxcbiAgYyxcbiAgWzg0NSwgNjJdLFxuICBjLFxuICBbNjIsIDY4XSxcbiAgYyxcbiAgWzIxLCAxNV0sXG4gIDM2LFxuICBjLFxuICBbMTE3MywgM10sXG4gIDg3LFxuICAxMzcsXG4gIGMsXG4gIFs5MzEsIDddLFxuICAxMSxcbiAgYyxcbiAgWzEzNzAsIDZdLFxuICBjLFxuICBbMjE1LCA2XSxcbiAgNTYsXG4gIGMsXG4gIFsxMzg3LCAzXSxcbiAgYyxcbiAgWzM2LCAzXSxcbiAgMTQsXG4gIDE1LFxuICA0MCxcbiAgOTgsXG4gIGMsXG4gIFs4MzIsIDc2XSxcbiAgOCxcbiAgNDgsXG4gIGMsXG4gIFs3MTgsIDQ1XSxcbiAgNyxcbiAgYyxcbiAgWzE1NCwgM10sXG4gIDE1LFxuICAxNyxcbiAgYyxcbiAgWzUzMCwgNV0sXG4gIGMsXG4gIFs4MDksIDZdLFxuICBjLFxuICBbMTUsIDE4XSxcbiAgYyxcbiAgWzE0LCA5XSxcbiAgOCxcbiAgYyxcbiAgWzI3LCA4XSxcbiAgYyxcbiAgWzk4LCAzXSxcbiAgMTksXG4gIDUxLFxuICBjLFxuICBbMTk4LCAzXSxcbiAgMTE1LFxuICAxMTcsXG4gIDExOCxcbiAgMTIwLFxuICBjLFxuICBbODIsIDNdLFxuICBjLFxuICBbODAsIDhdLFxuICAxNTgsXG4gIDcsXG4gIDEwNCxcbiAgNCxcbiAgYyxcbiAgWzUwLCAzXSxcbiAgYyxcbiAgWzU3OSwgNDFdLFxuICBjLFxuICBbNzEsIDddLFxuICBjLFxuICBbNjksIDhdLFxuICAxMzMsXG4gIGMsXG4gIFs2NywgNF0sXG4gIGMsXG4gIFsxNDc0LCAzXSxcbiAgYyxcbiAgWzkzLCAyM10sXG4gIDU1LFxuICAxMzcsXG4gIGMsXG4gIFs5NSwgNF0sXG4gIGMsXG4gIFsyOCwgMjZdLFxuICA2LFxuICA1MCxcbiAgNTUsXG4gIDEzNyxcbiAgNTUsXG4gIDEzNyxcbiAgYyxcbiAgWzQsIDhdLFxuICA3LFxuICAxMDQsXG4gIDcsXG4gIDEwLFxuICAxMDQsXG4gIDExNCxcbiAgYyxcbiAgWzI2NywgNDNdLFxuICA1NSxcbiAgMTM3LFxuICA2LFxuICAxMSxcbiAgNSxcbiAgNixcbiAgMTIsXG4gIDYsXG4gIDQyLFxuICAzMCxcbiAgYyxcbiAgWzE2MDMsIDE3XSxcbiAgYyxcbiAgWzY2NSwgNV0sXG4gIDE0LFxuICA3LFxuICAzMCxcbiAgODUsXG4gIDE0NSxcbiAgYyxcbiAgWzQsIDNdLFxuICAxNDgsXG4gIGMsXG4gIFs1NDksIDg2XSxcbiAgYyxcbiAgWzI0LCAyNF0sXG4gIGMsXG4gIFszLCAzXSxcbiAgMzAsXG4gIDExLFxuICAxNCxcbiAgYyxcbiAgWzQ2NywgNDddLFxuICBjLFxuICBbMTI2MSwgMjVdLFxuICBjLFxuICBbMTQ5NCwgNDVdLFxuICBjLFxuICBbMTk5NCwgNF0sXG4gIDExNSxcbiAgYyxcbiAgWzEzLCAzXSxcbiAgMjcsXG4gIDYsXG4gIDExLFxuICBjLFxuICBbNTQsIDQzXSxcbiAgMTcsXG4gIDI3LFxuICA3LFxuICAxMCxcbiAgMTcsXG4gIDI3LFxuICAxMDQsXG4gIDExNCxcbiAgYyxcbiAgWzYsIDZdLFxuICAxNyxcbiAgMjcsXG4gIHMsXG4gIFsxNywgM10sXG4gIGMsXG4gIFszOTQsIDRdLFxuICA2LFxuICA4LFxuICBjLFxuICBbMTAsIDNdLFxuICAyNyxcbiAgMjcsXG4gIGMsXG4gIFs3MywgNDNdLFxuICAxNCxcbiAgYyxcbiAgWzQ1MSwgM10sXG4gIDE0LFxuICAxMDQsXG4gIDgsXG4gIGMsXG4gIFs1MCwgNDNdLFxuICA1MSxcbiAgNTUsXG4gIGMsXG4gIFsxMTY5LCA0XSxcbiAgYyxcbiAgWzE3MjAsIDg2XSxcbiAgYyxcbiAgWzk2NSwgM10sXG4gIGMsXG4gIFs1MDUsIDIxXSxcbiAgMTQsXG4gIDMwLFxuICBjLFxuICBbNDY3LCAyNV0sXG4gIGMsXG4gIFs0NDMsIDRdLFxuICBjLFxuICBbNCwgNF0sXG4gIDMwLFxuICBjLFxuICBbMTk2LCA1XSxcbiAgYyxcbiAgWzk0OSwgMjldLFxuICBjLFxuICBbMTM3LCAxNV0sXG4gIDg0LFxuICBjLFxuICBbMTM4LCA3XSxcbiAgcyxcbiAgWzExNSwgNSwgMV0sXG4gIGMsXG4gIFs2ODIsIDE5XSxcbiAgNyxcbiAgMTA0LFxuICA0NCxcbiAgYyxcbiAgWzkzOSwgMTVdLFxuICBjLFxuICBbMTMyOCwgMTNdLFxuICBjLFxuICBbMTMsIDEyXSxcbiAgYyxcbiAgWzIyNDMsIDddLFxuICAxNCxcbiAgMTA0LFxuICAxNCxcbiAgMzAsXG4gIDYsXG4gIDQyLFxuICBjLFxuICBbMTcwLCAxNF0sXG4gIDEwMixcbiAgYyxcbiAgWzY3OSwgN10sXG4gIGMsXG4gIFsxNSwgM10sXG4gIGMsXG4gIFs0LCA0XSxcbiAgYyxcbiAgWzE3MSwgNV0sXG4gIDMwLFxuICBjLFxuICBbODgsIDE1XSxcbiAgYyxcbiAgWzI5MCwgNDNdLFxuICAyNyxcbiAgNixcbiAgYyxcbiAgWzI3MDgsIDNdLFxuICBjLFxuICBbNjMyLCAzXSxcbiAgYyxcbiAgWzYzMCwgNV0sXG4gIGMsXG4gIFs2MjYsIDddLFxuICA4MSxcbiAgMTA0LFxuICAxNDksXG4gIGMsXG4gIFs2NiwgNDNdLFxuICAxMSxcbiAgMTgsXG4gIGMsXG4gIFs1NjUsIDZdLFxuICAxMSxcbiAgMTgsXG4gIDExLFxuICAxOCxcbiAgMTEsXG4gIDE4LFxuICAxNCxcbiAgYyxcbiAgWzM2OCwgMjFdLFxuICBjLFxuICBbNDM1LCA0Nl0sXG4gIDQxLFxuICA0NCxcbiAgNDUsXG4gIDEsXG4gIDI4LFxuICA3NCxcbiAgMTQ2LFxuICAyOCxcbiAgMzAsXG4gIGMsXG4gIFsyNzYsIDddLFxuICBjLFxuICBbMjI2MCwgOTBdLFxuICBjLFxuICBbNDMsIDgyXSxcbiAgYyxcbiAgWzU5OSwgMjFdLFxuICA0MixcbiAgMzAsXG4gIDQ1LFxuICAzMSxcbiAgMzQsXG4gIGMsXG4gIFs0MjAsIDE1XSxcbiAgYyxcbiAgWzMwMSwgM10sXG4gIHMsXG4gIFsxMSwgM10sXG4gIDQxLFxuICA0MyxcbiAgNDQsXG4gIGMsXG4gIFsxMDkzLCA3XSxcbiAgYyxcbiAgWzMwNiwgNThdLFxuICBjLFxuICBbNjQsIDY0XSxcbiAgMzAsXG4gIDMwLFxuICBjLFxuICBbNDUsIDQ1XSxcbiAgYyxcbiAgWzEzMTMsIDQyXSxcbiAgMTEsXG4gIGMsXG4gIFsxNTQsIDIxXSxcbiAgYyxcbiAgWzI0MywgMjVdLFxuICA0MSxcbiAgNDUsXG4gIDQ2LFxuICBjLFxuICBbMTQ0NiwgNDFdLFxuICBjLFxuICBbMTM1LCAzN10sXG4gIGMsXG4gIFs4MTEsIDddLFxuICA0MSxcbiAgNDMsXG4gIGMsXG4gIFsxMTIsIDIzXSxcbiAgYyxcbiAgWzEzNywgM10sXG4gIGMsXG4gIFs3MSwgMjJdLFxuICAzMCxcbiAgYyxcbiAgWzUxLCAyNF0sXG4gIGMsXG4gIFs0NywgMjFdLFxuICBjLFxuICBbNDUsIDNdLFxuICAzMFxuXSksXG4gIHR5cGU6IHUoW1xuICBzLFxuICBbMiwgM10sXG4gIHMsXG4gIFswLCAxMl0sXG4gIDEsXG4gIHMsXG4gIFsyLCA0XSxcbiAgcyxcbiAgWzAsIDEwXSxcbiAgYyxcbiAgWzEzLCAxMV0sXG4gIHMsXG4gIFsyLCA5XSxcbiAgYyxcbiAgWzE3LCAxMF0sXG4gIGMsXG4gIFszNiwgMjJdLFxuICBjLFxuICBbNywgM10sXG4gIDAsXG4gIDIsXG4gIGMsXG4gIFs0LCA0XSxcbiAgYyxcbiAgWzQ1LCAxMV0sXG4gIGMsXG4gIFsxMCwgNl0sXG4gIGMsXG4gIFs2LCA5XSxcbiAgcyxcbiAgWzIsIDU4XSxcbiAgYyxcbiAgWzY5LCA3XSxcbiAgYyxcbiAgWzkxLCA3XSxcbiAgYyxcbiAgWzEwMSwgNF0sXG4gIGMsXG4gIFsxMzksIDEwXSxcbiAgYyxcbiAgWzM2LCAxM10sXG4gIGMsXG4gIFsyMDAsIDE0XSxcbiAgYyxcbiAgWzE5NSwgMTRdLFxuICBjLFxuICBbMzMsIDMyXSxcbiAgYyxcbiAgWzExLCA1XSxcbiAgYyxcbiAgWzEwMCwgN10sXG4gIGMsXG4gIFs1LCA0XSxcbiAgYyxcbiAgWzI1MCwgMTZdLFxuICBjLFxuICBbNDYsIDEzXSxcbiAgYyxcbiAgWzIwLCAxN10sXG4gIGMsXG4gIFsyNjgsIDEzXSxcbiAgYyxcbiAgWzI5MywgMTFdLFxuICBjLFxuICBbMTQ2LCAzMF0sXG4gIGMsXG4gIFsyMiwgMjBdLFxuICBjLFxuICBbNTMsIDIzXSxcbiAgYyxcbiAgWzQzLCAyNl0sXG4gIGMsXG4gIFsxMDMsIDE4XSxcbiAgYyxcbiAgWzEyMCwgNDddLFxuICBjLFxuICBbODMsIDE1XSxcbiAgYyxcbiAgWzIxMCwgOF0sXG4gIGMsXG4gIFsyNTcsIDQ2XSxcbiAgYyxcbiAgWzQzLCA0Ml0sXG4gIGMsXG4gIFsyNSwgMjNdLFxuICBjLFxuICBbODksIDI3XSxcbiAgYyxcbiAgWzI1NCwgMjVdLFxuICBjLFxuICBbNjAwLCAzMV0sXG4gIGMsXG4gIFsxMjIsIDIxXSxcbiAgYyxcbiAgWzUyLCAyNl0sXG4gIGMsXG4gIFszODgsIDU5XSxcbiAgYyxcbiAgWzQzLCA0MF0sXG4gIGMsXG4gIFs3NiwgMzddLFxuICBjLFxuICBbMjI1LCA0Ml0sXG4gIGMsXG4gIFs1NSwgNTNdLFxuICBjLFxuICBbNzQzLCA0XSxcbiAgYyxcbiAgWzIzNSwgNjBdLFxuICBjLFxuICBbMTI4LCAzNl0sXG4gIGMsXG4gIFsxMDAwLCA1NV0sXG4gIHMsXG4gIFsyLCAxMDZdLFxuICBjLFxuICBbMjIwLCAyNF0sXG4gIHMsXG4gIFswLCAyOV0sXG4gIGMsXG4gIFszMiwgOF0sXG4gIGMsXG4gIFs1NTYsIDYwXSxcbiAgYyxcbiAgWzc4MiwgMjNdLFxuICBjLFxuICBbOTA1LCAxMV0sXG4gIGMsXG4gIFsxNDAwLCAyMV0sXG4gIGMsXG4gIFs4MDQsIDQ3XSxcbiAgYyxcbiAgWzg0NSwgNDhdLFxuICBjLFxuICBbNjIsIDc2XSxcbiAgYyxcbiAgWzY0MiwgMTddLFxuICBjLFxuICBbMjE1LCAxNF0sXG4gIGMsXG4gIFsxMTE4LCAxNV0sXG4gIGMsXG4gIFs4MzIsIDg1XSxcbiAgYyxcbiAgWzcxOCwgNDFdLFxuICBjLFxuICBbMTUsIDI5XSxcbiAgYyxcbiAgWzc2MiwgMjBdLFxuICBjLFxuICBbNzksIDE4XSxcbiAgYyxcbiAgWzU3OSwgNDldLFxuICBjLFxuICBbMzYsIDE3XSxcbiAgYyxcbiAgWzE0NzQsIDE5XSxcbiAgYyxcbiAgWzI2LCAxMF0sXG4gIGMsXG4gIFsyOCwgMzJdLFxuICBjLFxuICBbMTkxMiwgOF0sXG4gIGMsXG4gIFsxNiwgN10sXG4gIGMsXG4gIFs2NjQsIDQ2XSxcbiAgYyxcbiAgWzQ1LCAyNl0sXG4gIGMsXG4gIFsxOTc5LCAxMF0sXG4gIGMsXG4gIFs4NCwgMTBdLFxuICBjLFxuICBbNTQ5LCA4MV0sXG4gIGMsXG4gIFsxNzk4LCAzNF0sXG4gIGMsXG4gIFsxMTg1LCA2NV0sXG4gIGMsXG4gIFsxNDUxLCA1MF0sXG4gIGMsXG4gIFs4MiwgMjNdLFxuICBjLFxuICBbMTI4LCAzNF0sXG4gIGMsXG4gIFs3MzUsIDhdLFxuICBjLFxuICBbMTQxMiwgMzFdLFxuICBjLFxuICBbNzMsIDMwXSxcbiAgYyxcbiAgWzMsIDZdLFxuICBjLFxuICBbNTAsIDQ1XSxcbiAgYyxcbiAgWzE0ODUsIDYxXSxcbiAgYyxcbiAgWzU0MywgMzBdLFxuICBjLFxuICBbNTA1LCAyOF0sXG4gIGMsXG4gIFs0NDMsIDY0XSxcbiAgYyxcbiAgWzgyMiwgNDRdLFxuICBjLFxuICBbNzc3LCAxMl0sXG4gIGMsXG4gIFszNTEsIDExXSxcbiAgYyxcbiAgWzI1NywgMTNdLFxuICBjLFxuICBbMTMsIDEyXSxcbiAgYyxcbiAgWzMzMiwgOV0sXG4gIGMsXG4gIFsxMzUxLCAyNF0sXG4gIGMsXG4gIFs0LCA4XSxcbiAgYyxcbiAgWzIwNTMsIDc4XSxcbiAgYyxcbiAgWzQ4LCA4XSxcbiAgYyxcbiAgWzU3MSwgNTVdLFxuICBjLFxuICBbMTUyNSwgMzBdLFxuICBjLFxuICBbNDM1LCA0NV0sXG4gIGMsXG4gIFs3LCA5XSxcbiAgYyxcbiAgWzIyNjAsIDk5XSxcbiAgYyxcbiAgWzQzLCA4MV0sXG4gIGMsXG4gIFszNTYsIDMzXSxcbiAgYyxcbiAgWzE5NzUsIDMzXSxcbiAgYyxcbiAgWzExNSwgNjNdLFxuICBjLFxuICBbNTE1LCA2MV0sXG4gIGMsXG4gIFs0NSwgMzZdLFxuICBjLFxuICBbMTMxMywgNDNdLFxuICBjLFxuICBbMTExLCAyNV0sXG4gIGMsXG4gIFs5MTcsIDM4XSxcbiAgYyxcbiAgWzI5OTEsIDQzXSxcbiAgYyxcbiAgWzg4LCA1Ml0sXG4gIGMsXG4gIFsyOTc1LCAzMl0sXG4gIGMsXG4gIFsyMzIsIDM4XVxuXSksXG4gIHN0YXRlOiB1KFtcbiAgMSxcbiAgMixcbiAgNSxcbiAgNCxcbiAgMyxcbiAgNixcbiAgMTAsXG4gIDExLFxuICAxMixcbiAgOCxcbiAgMTMsXG4gIDE0LFxuICAxOSxcbiAgMTcsXG4gIDE2LFxuICBjLFxuICBbMTAsIDddLFxuICAyMCxcbiAgMjIsXG4gIGMsXG4gIFs4LCA2XSxcbiAgMjgsXG4gIDMwLFxuICAyOSxcbiAgMzEsXG4gIDMzLFxuICAzNyxcbiAgMzYsXG4gIDM1LFxuICA0MSxcbiAgNDQsXG4gIDQ1LFxuICA0MCxcbiAgNDIsXG4gIDQzLFxuICA0OCxcbiAgYyxcbiAgWzIyLCA3XSxcbiAgNTMsXG4gIDUyLFxuICA1NCxcbiAgNTUsXG4gIDU2LFxuICA2MyxcbiAgNjAsXG4gIDYyLFxuICAzNyxcbiAgMzYsXG4gIDYxLFxuICAzNSxcbiAgNjQsXG4gIDY3LFxuICA2OCxcbiAgNjksXG4gIDY3LFxuICA2OCxcbiAgNzYsXG4gIDc1LFxuICA4MCxcbiAgNzksXG4gIDgyLFxuICA4MSxcbiAgODMsXG4gIDg3LFxuICA4OSxcbiAgYyxcbiAgWzQ0LCAzXSxcbiAgOTAsXG4gIGMsXG4gIFs0LCAzXSxcbiAgOTUsXG4gIDY4LFxuICA5NyxcbiAgOTgsXG4gIDEwMCxcbiAgMTMsXG4gIDE0LFxuICAxMDEsXG4gIDEwMixcbiAgMTA4LFxuICAxMDksXG4gIDEwMyxcbiAgMTA0LFxuICA0MixcbiAgNDMsXG4gIDk5LFxuICA5NixcbiAgMTA2LFxuICA5NSxcbiAgNjgsXG4gIDExOCxcbiAgYyxcbiAgWzE4LCAxM10sXG4gIDExNyxcbiAgMTA2LFxuICAxMjQsXG4gIDEyNSxcbiAgMTI3LFxuICAxMjYsXG4gIDEyOCxcbiAgMTMwLFxuICAxMzEsXG4gIDEzNCxcbiAgMTQwLFxuICBjLFxuICBbMjQsIDEzXSxcbiAgMTA2LFxuICAxNDEsXG4gIGMsXG4gIFsxNCwgMTNdLFxuICAxNDIsXG4gIDE0NCxcbiAgMTQ2LFxuICAxNDUsXG4gIDQ0LFxuICA0NSxcbiAgMTQ3LFxuICAxNTAsXG4gIDE1NCxcbiAgMTUzLFxuICAzNyxcbiAgMzYsXG4gIDE1MixcbiAgMzUsXG4gIDE1NixcbiAgYyxcbiAgWzQzLCAxM10sXG4gIDE1NSxcbiAgMTA2LFxuICAxNTgsXG4gIGMsXG4gIFs0NCwgMTNdLFxuICBzLFxuICBbMTU5LCA1LCAxXSxcbiAgcyxcbiAgWzE3NiwgNCwgMV0sXG4gIDE3MyxcbiAgMTY0LFxuICAxNjUsXG4gIDE4MCxcbiAgMTg2LFxuICAxODUsXG4gIDE4NyxcbiAgMTkyLFxuICAxOTMsXG4gIDE3MixcbiAgMTcxLFxuICAxODEsXG4gIDE4NCxcbiAgNDUsXG4gIDE3MCxcbiAgMTgyLFxuICA0MyxcbiAgMTY5LFxuICAxODksXG4gIDIwMSxcbiAgMjAyLFxuICBzLFxuICBbMjA0LCA1LCAxXSxcbiAgMTkyLFxuICAxOTMsXG4gIDIwMyxcbiAgMTg5LFxuICAyMTAsXG4gIGMsXG4gIFs2OSwgMTNdLFxuICAyMDksXG4gIGMsXG4gIFs2OSwgMTVdLFxuICAyMTIsXG4gIGMsXG4gIFsxMTEsIDNdLFxuICAyMTksXG4gIGMsXG4gIFs0LCAzXSxcbiAgMjIwLFxuICAyMjUsXG4gIGMsXG4gIFsxNTEsIDE0XSxcbiAgMjI2LFxuICBjLFxuICBbMTQsIDEzXSxcbiAgMjI5LFxuICBjLFxuICBbMjksIDE0XSxcbiAgMjMwLFxuICBjLFxuICBbMTQsIDEzXSxcbiAgMTQ0LFxuICAxNDYsXG4gIDE0NyxcbiAgMjMxLFxuICBjLFxuICBbMzIsIDE0XSxcbiAgMjMyLFxuICBjLFxuICBbMTQsIDEzXSxcbiAgYyxcbiAgWzExMywgMTRdLFxuICAyMzksXG4gIDIzOCxcbiAgYyxcbiAgWzE2LCAxNF0sXG4gIDI0NSxcbiAgNDIsXG4gIDQzLFxuICAyNDcsXG4gIDI0OCxcbiAgMjUwLFxuICAyNTEsXG4gIDI2NixcbiAgYyxcbiAgWzIwNSwgMjddLFxuICAyNjcsXG4gIGMsXG4gIFsyOCwgMjddLFxuICAyNjgsXG4gIGMsXG4gIFsyNCwgNF0sXG4gIDI3MCxcbiAgYyxcbiAgWzIyLCA2XSxcbiAgMjcxLFxuICAyNzMsXG4gIGMsXG4gIFsyMiwgM10sXG4gIDI3MixcbiAgYyxcbiAgWzIyLCA0XSxcbiAgMjc2LFxuICAyNzUsXG4gIDI4MyxcbiAgMjgyLFxuICAyODcsXG4gIDI4NixcbiAgMjg4LFxuICAxNDYsXG4gIDE0NyxcbiAgMjg5LFxuICBjLFxuICBbNTksIDI3XSxcbiAgMjkxLFxuICAyOTMsXG4gIDI5OSxcbiAgMzAxLFxuICAyOTgsXG4gIDQ0LFxuICA0NSxcbiAgMzAwLFxuICA0MixcbiAgNDMsXG4gIDMwNSxcbiAgMzA2LFxuICBjLFxuICBbMzksIDI3XSxcbiAgMzA4LFxuICAzMDksXG4gIDMxMixcbiAgMzExLFxuICAzMTAsXG4gIDMxMyxcbiAgMTQ3LFxuICAzMTQsXG4gIGMsXG4gIFszNSwgMjddLFxuICBjLFxuICBbMjEwLCAxNF0sXG4gIDMxNyxcbiAgNDQsXG4gIDQ1LFxuICAzMTksXG4gIDEyNyxcbiAgMTI2LFxuICAzMjAsXG4gIGMsXG4gIFszNDEsIDNdLFxuICAzMjEsXG4gIGMsXG4gIFs0LCAzXSxcbiAgMzI1LFxuICBjLFxuICBbMjgzLCAxNF0sXG4gIDMyNixcbiAgYyxcbiAgWzE0LCAxM10sXG4gIDMyNyxcbiAgYyxcbiAgWzI5LCAxNF0sXG4gIDMyOCxcbiAgYyxcbiAgWzMxMiwgMjddLFxuICAzMzEsXG4gIGMsXG4gIFs0MywgMTRdLFxuICAzMzIsXG4gIGMsXG4gIFs0MywgMjddLFxuICBjLFxuICBbMTQsIDE0XSxcbiAgMzM4LFxuICAxNDcsXG4gIGMsXG4gIFs2MzQsIDRdLFxuICAzNDEsXG4gIGMsXG4gIFsxMzksIDNdLFxuICAzNDIsXG4gIDQyLFxuICA0MyxcbiAgMzQ1LFxuICAzNDYsXG4gIGMsXG4gIFsxOTksIDI3XSxcbiAgMzQ3LFxuICBjLFxuICBbMzMyLCAyMV0sXG4gIDM1MSxcbiAgYyxcbiAgWzUwLCAyN10sXG4gIDI4NyxcbiAgMjg2LFxuICAyODMsXG4gIDI4MixcbiAgMjc2LFxuICAyNzUsXG4gIDM1NyxcbiAgMzU0LFxuICAzNjEsXG4gIDM1OSxcbiAgMzUzLFxuICAzNjQsXG4gIDM2MyxcbiAgMzU4LFxuICAzNjAsXG4gIDM2MixcbiAgMTQ1LFxuICAxODQsXG4gIDQ1LFxuICAzNjUsXG4gIDE4MixcbiAgNDMsXG4gIDM1NSxcbiAgMzY2LFxuICAzNjgsXG4gIGMsXG4gIFszMzcsIDI4XSxcbiAgMzYxLFxuICAzNTksXG4gIDM2OSxcbiAgYyxcbiAgWzQ1LCA1XSxcbiAgMzcwLFxuICBjLFxuICBbNDMsIDRdLFxuICAzNzIsXG4gIGMsXG4gIFs2MSwgNF0sXG4gIDM3MyxcbiAgYyxcbiAgWzYxLCAxMl0sXG4gIDM3NCxcbiAgMzc1LFxuICBjLFxuICBbMTksIDRdLFxuICAzNzYsXG4gIGMsXG4gIFsxOSwgMTJdLFxuICAzNzcsXG4gIDM3OCxcbiAgcyxcbiAgWzM4MCwgNywgMV0sXG4gIDM4OCxcbiAgMzg3LFxuICAzODksXG4gIGMsXG4gIFs4OSwgMjddLFxuICAyOTMsXG4gIDM5OCxcbiAgYyxcbiAgWzc1NywgOV0sXG4gIDM5OSxcbiAgNDQsXG4gIDQ1LFxuICA0MDIsXG4gIDQwMSxcbiAgNDA0LFxuICA0MDMsXG4gIDQwNSxcbiAgYyxcbiAgWzMwOSwgMTRdLFxuICA0MDYsXG4gIGMsXG4gIFszMDksIDQxXSxcbiAgYyxcbiAgWzE0LCAxNF0sXG4gIDQxOSxcbiAgYyxcbiAgWzExNywgMjddLFxuICA0MjQsXG4gIDQyMyxcbiAgNDIwLFxuICAyNTEsXG4gIDQyNSxcbiAgYyxcbiAgWzMyLCAyN10sXG4gIDM1NyxcbiAgMzU0LFxuICBjLFxuICBbMzc4LCAzXSxcbiAgNDMwLFxuICBjLFxuICBbMzI0LCAzM10sXG4gIDQzNSxcbiAgYyxcbiAgWzM0LCAyN10sXG4gIDQzNyxcbiAgNDM4LFxuICA0NDEsXG4gIGMsXG4gIFszMCwgMjddLFxuICA0NDIsXG4gIGMsXG4gIFs2NzEsIDNdLFxuICA0NDMsXG4gIGMsXG4gIFszMiwgMjddLFxuICA0NDQsXG4gIGMsXG4gIFsyOCwgMjddLFxuICA0NDUsXG4gIDE0NyxcbiAgNDQ2LFxuICBjLFxuICBbMjkwLCAxNF0sXG4gIGMsXG4gIFsyNDgsIDE0XSxcbiAgNDU5LFxuICBjLFxuICBbNTI5LCAyMV0sXG4gIDM1NyxcbiAgNDYxLFxuICBjLFxuICBbODIsIDZdLFxuICAzNTQsXG4gIGMsXG4gIFs4MywgMTNdLFxuICA0NjIsXG4gIGMsXG4gIFs4MywgN10sXG4gIDQ2MyxcbiAgNDY0LFxuICA0MjQsXG4gIDQyMyxcbiAgNDY2LFxuICBjLFxuICBbMjQzLCAzXSxcbiAgNDY3LFxuICBjLFxuICBbNCwgM10sXG4gIDQ2OSxcbiAgYyxcbiAgWzQsIDNdLFxuICA0NzAsXG4gIGMsXG4gIFs0LCAzXSxcbiAgNDcxLFxuICBjLFxuICBbNCwgM10sXG4gIDQ3MixcbiAgYyxcbiAgWzkxLCA4XSxcbiAgNDc4LFxuICBjLFxuICBbOTIsIDZdLFxuICA0ODAsXG4gIDEzLFxuICAxNCxcbiAgNDgxLFxuICAxMyxcbiAgMTQsXG4gIDQyNCxcbiAgNDIzLFxuICA0ODYsXG4gIGMsXG4gIFsxNTksIDI3XSxcbiAgMjM5LFxuICAyOTEsXG4gIDIzOCxcbiAgNDg4LFxuICBjLFxuICBbMzc5LCAyOV0sXG4gIDQ5OCxcbiAgYyxcbiAgWzE5MCwgMTRdLFxuICA0OTksXG4gIGMsXG4gIFs0NSwgMjddLFxuICA1MDAsXG4gIDE0NyxcbiAgNTAzLFxuICA1MDIsXG4gIDUwOCxcbiAgYyxcbiAgWzEzNiwgM10sXG4gIDUwOSxcbiAgYyxcbiAgWzM2LCAyN10sXG4gIDUxMCxcbiAgYyxcbiAgWzI4LCAyN10sXG4gIDUxMSxcbiAgYyxcbiAgWzI4LCAyN10sXG4gIDUxMixcbiAgYyxcbiAgWzEwNTIsIDQxXSxcbiAgNDI0LFxuICA0MjMsXG4gIDUyOCxcbiAgYyxcbiAgWzE3OSwgMTRdLFxuICA1MjksXG4gIGMsXG4gIFs1OSwgMjddLFxuICA1MzAsXG4gIGMsXG4gIFs0MywgMTRdLFxuICA1MzEsXG4gIGMsXG4gIFs0MywgMjddLFxuICA1MzQsXG4gIGMsXG4gIFsxMzAsIDQxXSxcbiAgYyxcbiAgWzE0LCAxNF0sXG4gIDU0MixcbiAgYyxcbiAgWzk5LCAxNF0sXG4gIDU0NSxcbiAgYyxcbiAgWzE1LCAxNF0sXG4gIDU0NyxcbiAgYyxcbiAgWzU0MSwgMjhdLFxuICBjLFxuICBbMTQsIDIyXSxcbiAgNTUzLFxuICBjLFxuICBbMTUsIDZdLFxuICA1NTUsXG4gIGMsXG4gIFs1OCwgMjhdLFxuICA1NjMsXG4gIGMsXG4gIFsyOSwgMjhdXG5dKSxcbiAgbW9kZTogdShbXG4gIHMsXG4gIFsxLCAyNl0sXG4gIDIsXG4gIDIsXG4gIGMsXG4gIFsxNywgMTddLFxuICBzLFxuICBbMiwgOF0sXG4gIGMsXG4gIFsxMSwgMTFdLFxuICBzLFxuICBbMiwgMThdLFxuICBjLFxuICBbMjksIDE5XSxcbiAgMSxcbiAgYyxcbiAgWzc1LCAzXSxcbiAgYyxcbiAgWzc4LCAxM10sXG4gIGMsXG4gIFs5MiwgOF0sXG4gIGMsXG4gIFs3LCA4XSxcbiAgYyxcbiAgWzE2LCA3XSxcbiAgYyxcbiAgWzExNCwgMTZdLFxuICBjLFxuICBbMTUyLCAyNF0sXG4gIGMsXG4gIFs0NywgNl0sXG4gIGMsXG4gIFs0NiwgOF0sXG4gIGMsXG4gIFs1NCwgMjBdLFxuICBjLFxuICBbMTM1LCAxMF0sXG4gIGMsXG4gIFsyMywgMTRdLFxuICBjLFxuICBbNTEsIDE2XSxcbiAgYyxcbiAgWzc3LCA5XSxcbiAgcyxcbiAgWzEsIDU1XSxcbiAgYyxcbiAgWzEwNCwgOV0sXG4gIGMsXG4gIFs3LCA2XSxcbiAgYyxcbiAgWzYsIDEzXSxcbiAgYyxcbiAgWzEwNCwgMTRdLFxuICBjLFxuICBbMjYxLCAxMF0sXG4gIGMsXG4gIFsxNTEsIDE4XSxcbiAgYyxcbiAgWzI0NiwgNDFdLFxuICBjLFxuICBbMzcyLCAyOV0sXG4gIGMsXG4gIFszNzcsIDIxXSxcbiAgYyxcbiAgWzI3LCA1MF0sXG4gIGMsXG4gIFsxMjIsIDE4XSxcbiAgYyxcbiAgWzQ3MiwgMjddLFxuICBzLFxuICBbMiwgMzFdLFxuICBjLFxuICBbMzMsIDMzXSxcbiAgYyxcbiAgWzM2LCAyMV0sXG4gIGMsXG4gIFsyMzEsIDMwXSxcbiAgYyxcbiAgWzI1LCA2Ml0sXG4gIGMsXG4gIFszNzAsIDQ0XSxcbiAgYyxcbiAgWzQ1LCA0XSxcbiAgYyxcbiAgWzU0MSwgNjBdLFxuICBjLFxuICBbNTYwLCAyNl0sXG4gIGMsXG4gIFs2MiwgNTldLFxuICBjLFxuICBbNzMxLCAxMl0sXG4gIGMsXG4gIFsxMywgMTddLFxuICBjLFxuICBbMjQ5LCAxNl0sXG4gIHMsXG4gIFsxLCA5Nl0sXG4gIGMsXG4gIFs3MjUsIDVdLFxuICBjLFxuICBbMjcwLCA2Ml0sXG4gIGMsXG4gIFszNTUsIDVdLFxuICBjLFxuICBbMTAyMywgN10sXG4gIGMsXG4gIFsxNzksIDQ4XSxcbiAgYyxcbiAgWzQxNywgOF0sXG4gIGMsXG4gIFsxMzUsIDYzXSxcbiAgYyxcbiAgWzQ4MywgODJdLFxuICBjLFxuICBbNDA4LCA5XSxcbiAgYyxcbiAgWzQ0LCA2MF0sXG4gIGMsXG4gIFs0NjcsIDE2XSxcbiAgYyxcbiAgWzc5LCAyM10sXG4gIGMsXG4gIFsyNTEsIDMzXSxcbiAgYyxcbiAgWzcwNywgODNdLFxuICBjLFxuICBbMjI0LCA0MF0sXG4gIHMsXG4gIFsxLCAxNDNdXG5dKSxcbiAgZ290bzogdShbXG4gIDE1LFxuICA5LFxuICA3LFxuICAxOCxcbiAgYyxcbiAgWzQsIDNdLFxuICAyMSxcbiAgMTUsXG4gIDcsXG4gIHMsXG4gIFsyMywgNSwgMV0sXG4gIDMyLFxuICAzNCxcbiAgMzgsXG4gIDM5LFxuICA0NixcbiAgNDcsXG4gIDQ5LFxuICAxNSxcbiAgNyxcbiAgNTAsXG4gIDUxLFxuICAxOTUsXG4gIDE5NSxcbiAgMzksXG4gIDM0LFxuICAzOSxcbiAgMzgsXG4gIDU3LFxuICA1OCxcbiAgNTksXG4gIDM4LFxuICAzOSxcbiAgNjUsXG4gIDY2LFxuICAzOCxcbiAgNzAsXG4gIDcxLFxuICAzOCxcbiAgcyxcbiAgWzE4NSwgMTBdLFxuICA3MixcbiAgcyxcbiAgWzE4NSwgMThdLFxuICBzLFxuICBbMTgwLCAxMF0sXG4gIDczLFxuICBzLFxuICBbMTgwLCAxOF0sXG4gIDc0LFxuICAxOTcsXG4gIDc3LFxuICA3OCxcbiAgMjAzLFxuICA3NyxcbiAgODYsXG4gIDg1LFxuICA3NyxcbiAgODQsXG4gIDg4LFxuICAzOCxcbiAgMzksXG4gIDM4LFxuICAzOSxcbiAgOTEsXG4gIDkyLFxuICAxODksXG4gIDE4OSxcbiAgNTksXG4gIDkzLFxuICA5NCxcbiAgMzgsXG4gIDE1LFxuICAxMTIsXG4gIDIxNixcbiAgMTA1LFxuICAxMDcsXG4gIDExMCxcbiAgMTExLFxuICAxMTQsXG4gIDExMyxcbiAgcyxcbiAgWzgxLCAzXSxcbiAgMTE1LFxuICAxMTYsXG4gIGMsXG4gIFsxNSwgM10sXG4gIDIyMCxcbiAgYyxcbiAgWzE1LCA0XSxcbiAgcyxcbiAgWzExOSwgNSwgMV0sXG4gIDM4LFxuICAzOSxcbiAgODgsXG4gIDEyOSxcbiAgODYsXG4gIDEzMyxcbiAgMTMyLFxuICAxMzcsXG4gIDEzNixcbiAgMTM1LFxuICAxMzksXG4gIDEzOCxcbiAgMTUsXG4gIDExMixcbiAgYyxcbiAgWzIzLCA0XSxcbiAgYyxcbiAgWzYsIDZdLFxuICAxNDMsXG4gIDE0OCxcbiAgMTQ5LFxuICAxODcsXG4gIDE4NyxcbiAgMTUxLFxuICAxODcsXG4gIDE4NyxcbiAgMzgsXG4gIDM5LFxuICAxNSxcbiAgMTEyLFxuICAyMTQsXG4gIGMsXG4gIFsxNywgNF0sXG4gIDE1NyxcbiAgMTUsXG4gIDExMixcbiAgMjE3LFxuICBjLFxuICBbOCwgNF0sXG4gIDE5MSxcbiAgMTY2LFxuICAxOTAsXG4gIDE4OCxcbiAgMTY4LFxuICAxODMsXG4gIDE2NyxcbiAgMTc0LFxuICAxNzUsXG4gIDg4LFxuICAxOTQsXG4gIDE5NSxcbiAgMTk2LFxuICA0NixcbiAgNDcsXG4gIDE4NSxcbiAgMTg1LFxuICAxOTcsXG4gIHMsXG4gIFsxODUsIDddLFxuICAxOTgsXG4gIDE5OSxcbiAgMjAwLFxuICAzOCxcbiAgMTkxLFxuICAxOTAsXG4gIDEwNSxcbiAgYyxcbiAgWzIzLCA0XSxcbiAgMTUsXG4gIDExMixcbiAgMjE4LFxuICBjLFxuICBbNDMsIDRdLFxuICAyMTEsXG4gIDE1LFxuICAxMTIsXG4gIDIyMSxcbiAgYyxcbiAgWzgsIDRdLFxuICAyMTMsXG4gIDE0OSxcbiAgMjE1LFxuICAyMTQsXG4gIDUwLFxuICA1MCxcbiAgMjE2LFxuICA1MixcbiAgNTIsXG4gIDIxNyxcbiAgMjE4LFxuICAyMTMsXG4gIDE0OSxcbiAgMTM3LFxuICAyMjIsXG4gIDIyMSxcbiAgMjI0LFxuICAyMjMsXG4gIGMsXG4gIFsxMDYsIDEyXSxcbiAgMjI4LFxuICAyMjcsXG4gIGMsXG4gIFsxMjAsIDEzXSxcbiAgYyxcbiAgWzE1OCwgM10sXG4gIGMsXG4gIFsxNCwgMTBdLFxuICAxNSxcbiAgMjMzLFxuICBjLFxuICBbNiwgNF0sXG4gIDIzNCxcbiAgMjM1LFxuICAyMzcsXG4gIDIzNixcbiAgMjA3LFxuICAyMDcsXG4gIDI0MCxcbiAgcyxcbiAgWzIwNywgNF0sXG4gIDYyLFxuICA2MixcbiAgMjQxLFxuICA2MixcbiAgNjIsXG4gIHMsXG4gIFsxODUsIDNdLFxuICAyNDIsXG4gIHMsXG4gIFsxODAsIDVdLFxuICAyNDMsXG4gIHMsXG4gIFsxODAsIDNdLFxuICAxOTEsXG4gIDE5MSxcbiAgNTksXG4gIDI0NCxcbiAgMTUsXG4gIDExMixcbiAgMjE1LFxuICBjLFxuICBbNDAsIDRdLFxuICAxMTAsXG4gIDExMSxcbiAgMjQ5LFxuICAyNDYsXG4gIHMsXG4gIFsxMDYsIDNdLFxuICAyNjEsXG4gIDEwNixcbiAgMjU0LFxuICAyNTIsXG4gIDEwNixcbiAgMjU4LFxuICAyNTksXG4gIDI2MCxcbiAgMjY0LFxuICBzLFxuICBbMTA2LCA1XSxcbiAgMjUzLFxuICAyNTUsXG4gIDI1NixcbiAgMjU3LFxuICAyNjIsXG4gIDI2MyxcbiAgMjY1LFxuICBjLFxuICBbMTgzLCAxNV0sXG4gIGMsXG4gIFsxNSwgMTZdLFxuICAyNjksXG4gIDE5MCxcbiAgMTg4LFxuICAxODMsXG4gIGMsXG4gIFsxMSwgNl0sXG4gIDIzNCxcbiAgMjM0LFxuICAyNzcsXG4gIDIzNCxcbiAgMjM0LFxuICAyNzQsXG4gIHMsXG4gIFsyMzQsIDIwXSxcbiAgcyxcbiAgWzIzNSwgNF0sXG4gIDI3OCxcbiAgcyxcbiAgWzIzNSwgNF0sXG4gIDI3OSxcbiAgcyxcbiAgWzIzNSwgMTZdLFxuICAyMzIsXG4gIDIzMixcbiAgMjc3LFxuICAyMzIsXG4gIDIzMixcbiAgMjgwLFxuICBzLFxuICBbMjMyLCA0XSxcbiAgMjgxLFxuICBzLFxuICBbMjMyLCAxNl0sXG4gIDIzMCxcbiAgMjMwLFxuICAyNzcsXG4gIDIzMCxcbiAgMjMwLFxuICAyODQsXG4gIHMsXG4gIFsyMzAsIDRdLFxuICAyODUsXG4gIHMsXG4gIFsyMzAsIDE2XSxcbiAgMzgsXG4gIGMsXG4gIFsxMzMsIDE1XSxcbiAgcyxcbiAgWzIyOSwgOF0sXG4gIDI5MCxcbiAgcyxcbiAgWzIyOSwgMTZdLFxuICAyMzMsXG4gIDIzMyxcbiAgMjc3LFxuICBzLFxuICBbMjMzLCAyMl0sXG4gIHMsXG4gIFsxODEsIDEwXSxcbiAgMjkyLFxuICBzLFxuICBbMTgxLCAxNl0sXG4gIHMsXG4gIFsxNzUsIDE5XSxcbiAgMzgsXG4gIHMsXG4gIFsxNzUsIDddLFxuICBzLFxuICBbMTc2LCAxMF0sXG4gIDI5NCxcbiAgcyxcbiAgWzE3NiwgMTZdLFxuICBzLFxuICBbMjQxLCA4XSxcbiAgMjk1LFxuICBzLFxuICBbMjQxLCAxNl0sXG4gIHMsXG4gIFsyNDAsIDhdLFxuICAyOTYsXG4gIHMsXG4gIFsyNDAsIDE2XSxcbiAgcyxcbiAgWzI0MiwgOF0sXG4gIDI5NyxcbiAgcyxcbiAgWzI0MiwgMTZdLFxuICAzMDIsXG4gIDMwMyxcbiAgYyxcbiAgWzM1OCwgNV0sXG4gIDMwNCxcbiAgYyxcbiAgWzIyNiwgMTJdLFxuICAzMDcsXG4gIDg4LFxuICAzOCxcbiAgMTE5LFxuICAxMjEsXG4gIGMsXG4gIFsyNDcsIDE2XSxcbiAgMzE1LFxuICBzLFxuICBbODAsIDNdLFxuICAzMTYsXG4gIDE1LFxuICAxMTIsXG4gIDIxOSxcbiAgYyxcbiAgWzU1NCwgNl0sXG4gIDMxOCxcbiAgMjQyLFxuICAzOCxcbiAgMzksXG4gIDIxMyxcbiAgMTQ5LFxuICAyMTMsXG4gIDE0OSxcbiAgMzIyLFxuICAzMjQsXG4gIDMyMyxcbiAgYyxcbiAgWzUyMSwgMTNdLFxuICBjLFxuICBbNiwgMTJdLFxuICAzMjksXG4gIGMsXG4gIFs2LCA0XSxcbiAgMzMwLFxuICBjLFxuICBbMTksIDEzXSxcbiAgMzMzLFxuICBjLFxuICBbNiwgNF0sXG4gIDMzNCxcbiAgMTUsXG4gIDMzNSxcbiAgYyxcbiAgWzcsIDRdLFxuICAzMzYsXG4gIDMzNyxcbiAgYyxcbiAgWzY1MCwgM10sXG4gIDIwOCxcbiAgMjA4LFxuICAzMzksXG4gIHMsXG4gIFsyMDgsIDRdLFxuICAzNDAsXG4gIGMsXG4gIFs3OCwgNF0sXG4gIDEyMCxcbiAgMTIyLFxuICAxMTAsXG4gIDExMSxcbiAgMzQzLFxuICAyNDksXG4gIDM0NCxcbiAgYyxcbiAgWzUwMCwgMTZdLFxuICAzNDgsXG4gIGMsXG4gIFs1MDAsIDldLFxuICAzNDksXG4gIDM1MCxcbiAgYyxcbiAgWzI4LCAxNV0sXG4gIGMsXG4gIFs0MzgsIDRdLFxuICAzNTIsXG4gIGMsXG4gIFs0MzUsIDhdLFxuICBjLFxuICBbNDc4LCA0XSxcbiAgMzUyLFxuICBjLFxuICBbNDc1LCA4XSxcbiAgYyxcbiAgWzU0MywgNF0sXG4gIDM1MixcbiAgYyxcbiAgWzUyOSwgMTFdLFxuICBjLFxuICBbNTI1LCA3XSxcbiAgMTkxLFxuICAzNTYsXG4gIDE5MCxcbiAgMTgzLFxuICA4OCxcbiAgNDYsXG4gIDQ3LFxuICAyNzcsXG4gIDE5MSxcbiAgMTY2LFxuICAzNjcsXG4gIGMsXG4gIFsxMDEsIDE0XSxcbiAgYyxcbiAgWzI0LCA1XSxcbiAgMzcxLFxuICAzOCxcbiAgYyxcbiAgWzMyLCA3XSxcbiAgMzgsXG4gIDI3NyxcbiAgYyxcbiAgWzksIDldLFxuICAyMzcsXG4gIDM3OSxcbiAgcyxcbiAgWzM4LCA2XSxcbiAgMjc3LFxuICAyNzcsXG4gIDM1MixcbiAgYyxcbiAgWzEyNSwgMTVdLFxuICAzOCxcbiAgMzkxLFxuICAzOTAsXG4gIDM5MixcbiAgMzkzLFxuICAzOTQsXG4gIDM5NixcbiAgMzk1LFxuICAzOTcsXG4gIGMsXG4gIFs4NDYsIDddLFxuICAyMTMsXG4gIDE0OSxcbiAgNDAwLFxuICAxMzcsXG4gIDE5OSxcbiAgMTM3LFxuICAyMDUsXG4gIGMsXG4gIFsyNDAsIDEzXSxcbiAgNDA3LFxuICBjLFxuICBbNiwgNF0sXG4gIDQwOCxcbiAgMTUsXG4gIDQwOSxcbiAgYyxcbiAgWzcsIDRdLFxuICA0MTAsXG4gIDQxMSxcbiAgMTk5LFxuICAyMDAsXG4gIDE1LFxuICA0MTIsXG4gIGMsXG4gIFsxMCwgNF0sXG4gIDQxMyxcbiAgNDE0LFxuICAxOTksXG4gIDIwMCxcbiAgNDE1LFxuICAxOTksXG4gIDIwMCxcbiAgNDE2LFxuICA0MTcsXG4gIDQxOCxcbiAgYyxcbiAgWzgzLCAxNV0sXG4gIDEwOSxcbiAgMTA5LFxuICAyNzcsXG4gIDEwOSxcbiAgMjYxLFxuICA0MjEsXG4gIDEwOSxcbiAgMjU0LFxuICAyNTIsXG4gIDEwOSxcbiAgNDIyLFxuICBjLFxuICBbNzkzLCA0XSxcbiAgcyxcbiAgWzEwOSwgNV0sXG4gIGMsXG4gIFs3OTMsIDIyXSxcbiAgNDI2LFxuICAyMTMsXG4gIDE0OSxcbiAgNDI3LFxuICA0MjksXG4gIDQyOCxcbiAgYyxcbiAgWzIxLCAxNV0sXG4gIDI5NyxcbiAgMjM2LFxuICAyNzcsXG4gIDM1MixcbiAgMjg1LFxuICAyMzcsXG4gIDI3NyxcbiAgMzUyLFxuICAyODEsXG4gIDIzOCxcbiAgMjkwLFxuICAyMzksXG4gIDI3OSxcbiAgMjk1LFxuICAyOTYsXG4gIDI3NyxcbiAgMzUyLFxuICAzOTEsXG4gIDQzMSxcbiAgNDMyLFxuICAyOTQsXG4gIDczLFxuICA0MzMsXG4gIDQzNCxcbiAgYyxcbiAgWzM5LCAxNV0sXG4gIDQzNixcbiAgMjc3LFxuICAyNzcsXG4gIDQzOSxcbiAgNDQwLFxuICBjLFxuICBbMjAsIDE1XSxcbiAgODgsXG4gIGMsXG4gIFs0OTUsIDE2XSxcbiAgYyxcbiAgWzIzNywgMTZdLFxuICBjLFxuICBbMjA5LCA2XSxcbiAgNDQ3LFxuICA0NDgsXG4gIDQ0OSxcbiAgMTUsXG4gIDQ1MCxcbiAgYyxcbiAgWzksIDRdLFxuICA0NTEsXG4gIDQ1MixcbiAgMTk5LFxuICAyMDAsXG4gIDQ1MyxcbiAgMTk5LFxuICAyMDAsXG4gIDQ1NCxcbiAgNDU1LFxuICAxOTksXG4gIDIwMCxcbiAgNDU2LFxuICA0NTcsXG4gIDQ1OCxcbiAgMTkxLFxuICA0NjAsXG4gIGMsXG4gIFs0MjAsIDldLFxuICBjLFxuICBbNTYsIDE2XSxcbiAgMjc3LFxuICA0NjUsXG4gIDExNixcbiAgMTE2LFxuICAyNzcsXG4gIDExNixcbiAgMzUyLFxuICAxMTYsXG4gIDExNixcbiAgNDIyLFxuICBzLFxuICBbMTE2LCA1XSxcbiAgYyxcbiAgWzU2NCwgNF0sXG4gIDQ2OCxcbiAgYyxcbiAgWzUsIDRdLFxuICAyMTMsXG4gIDE0OSxcbiAgMjc3LFxuICA0NzMsXG4gIDQ3NCxcbiAgNDc1LFxuICA0NzcsXG4gIDQ3NixcbiAgMTUsXG4gIDQ3OSxcbiAgYyxcbiAgWzI5NywgNV0sXG4gIDE1LFxuICA0ODIsXG4gIDE5OSxcbiAgMjAwLFxuICA0ODMsXG4gIDQ4NCxcbiAgNDg1LFxuICAxMTIsXG4gIDExMixcbiAgMjc3LFxuICAxMTIsXG4gIDM1MixcbiAgMTEyLFxuICAxMTIsXG4gIDQyMixcbiAgcyxcbiAgWzExMiwgNV0sXG4gIGMsXG4gIFs3NSwgMTVdLFxuICA0ODcsXG4gIDIwNyxcbiAgMjc3LFxuICAyMzMsXG4gIDI0MCxcbiAgMjA3LFxuICBzLFxuICBbMjMzLCAxNF0sXG4gIGMsXG4gIFszNSwgMTVdLFxuICA0ODksXG4gIDQ5MCxcbiAgMjc3LFxuICAzNTIsXG4gIDQyMixcbiAgMTU5LFxuICBzLFxuICBbNDkxLCA3LCAxXSxcbiAgYyxcbiAgWzE3OCwgNl0sXG4gIGMsXG4gIFsxNDQsIDE2XSxcbiAgMTk5LFxuICA1MDEsXG4gIDIwMCxcbiAgMjAxLFxuICBzLFxuICBbNTA0LCA0LCAxXSxcbiAgMjEzLFxuICAxNDksXG4gIGMsXG4gIFsxMTMxLCAzMV0sXG4gIGMsXG4gIFsxNSwgMjldLFxuICAxNSxcbiAgNTEzLFxuICBjLFxuICBbOTIsIDRdLFxuICBzLFxuICBbNTE0LCA2LCAxXSxcbiAgMTE0LFxuICAxMTQsXG4gIDI3NyxcbiAgMTE0LFxuICAzNTIsXG4gIDExNCxcbiAgMTE0LFxuICA0MjIsXG4gIHMsXG4gIFsxMTQsIDVdLFxuICA1MjEsXG4gIDUyMCxcbiAgcyxcbiAgWzUyMiwgNCwgMV0sXG4gIDE5OSxcbiAgNTI2LFxuICA1MjcsXG4gIDIwMCxcbiAgYyxcbiAgWzEyNywgMjFdLFxuICBjLFxuICBbMjEsIDIxXSxcbiAgNTMyLFxuICA1MzMsXG4gIGMsXG4gIFsxNywgMTVdLFxuICA1MzUsXG4gIDUzNixcbiAgMTUsXG4gIDUzNyxcbiAgYyxcbiAgWzQwLCA0XSxcbiAgNTM4LFxuICAxNSxcbiAgNTM5LFxuICBjLFxuICBbNywgNF0sXG4gIDU0MCxcbiAgNTQxLFxuICBjLFxuICBbNTUsIDZdLFxuICAxOTksXG4gIDU0MyxcbiAgNTQ0LFxuICBjLFxuICBbODYsIDddLFxuICAxOTksXG4gIDIwMCxcbiAgNTQ2LFxuICBjLFxuICBbNjA5LCA3XSxcbiAgNTQ4LFxuICBjLFxuICBbNiwgNF0sXG4gIDU0OSxcbiAgNTUwLFxuICAxNSxcbiAgNTUxLFxuICBjLFxuICBbOCwgNF0sXG4gIDU1MixcbiAgYyxcbiAgWzMzMywgNl0sXG4gIDE5OSxcbiAgNTU0LFxuICBjLFxuICBbMzksIDhdLFxuICA1NTYsXG4gIDU1NyxcbiAgMjAwLFxuICA1NTgsXG4gIDE1LFxuICA1NTksXG4gIGMsXG4gIFsxMSwgNF0sXG4gIDU2MCxcbiAgNTYxLFxuICAxOTksXG4gIDU2MixcbiAgYyxcbiAgWzIyLCA3XSxcbiAgNTY0LFxuICAxNSxcbiAgNTY1LFxuICBjLFxuICBbMjksIDVdLFxuICA1NjYsXG4gIDIwMCxcbiAgNTY3XG5dKVxufSksXG5kZWZhdWx0QWN0aW9uczogYmRhKHtcbiAgaWR4OiB1KFtcbiAgNSxcbiAgNixcbiAgOCxcbiAgcyxcbiAgWzEwLCA1LCAxXSxcbiAgMTgsXG4gIDE5LFxuICAyMSxcbiAgMjIsXG4gIDIzLFxuICAyOSxcbiAgMzAsXG4gIDMxLFxuICBzLFxuICBbMzUsIDUsIDFdLFxuICBzLFxuICBbNDIsIDQsIDFdLFxuICA0OSxcbiAgNTAsXG4gIDUxLFxuICA1MyxcbiAgNjEsXG4gIDYzLFxuICA2NixcbiAgNjcsXG4gIDcxLFxuICA3NCxcbiAgNzYsXG4gIDgwLFxuICBzLFxuICBbODgsIDQsIDFdLFxuICA5NCxcbiAgOTUsXG4gIHMsXG4gIFs5OCwgNywgMV0sXG4gIHMsXG4gIFsxMDYsIDQsIDFdLFxuICAxMTYsXG4gIHMsXG4gIFsxMTksIDQsIDFdLFxuICAxMjUsXG4gIDE0MyxcbiAgMTQ2LFxuICAxNTAsXG4gIDE1MSxcbiAgMTUyLFxuICAxNTQsXG4gIDE1OCxcbiAgMTYwLFxuICAxNjEsXG4gIDE2MixcbiAgMTY0LFxuICAxNjUsXG4gIDE2OSxcbiAgMTc2LFxuICAxNzcsXG4gIDE3OCxcbiAgMTgwLFxuICAxODksXG4gIHMsXG4gIFsxOTIsIDUsIDFdLFxuICBzLFxuICBbMjAyLCA3LCAxXSxcbiAgMjE0LFxuICAyMTgsXG4gIDIzNCxcbiAgMjM1LFxuICAyMzYsXG4gIDIzOCxcbiAgMjQ2LFxuICAyNDgsXG4gIHMsXG4gIFsyNTEsIDE1LCAxXSxcbiAgMjY4LFxuICAyNzYsXG4gIDI4MyxcbiAgcyxcbiAgWzI4NywgNCwgMl0sXG4gIDMwMCxcbiAgMzAxLFxuICAzMDQsXG4gIDMwNixcbiAgMzA3LFxuICAzMDksXG4gIDMxMSxcbiAgMzEyLFxuICAzMTksXG4gIDMyMCxcbiAgMzIxLFxuICAzMzAsXG4gIHMsXG4gIFszMzQsIDQsIDJdLFxuICAzNDEsXG4gIHMsXG4gIFszNDMsIDUsIDFdLFxuICAzNTUsXG4gIDM1NyxcbiAgMzY2LFxuICAzNjcsXG4gIDM3MixcbiAgMzc0LFxuICAzNzUsXG4gIDM3NyxcbiAgMzc4LFxuICBzLFxuICBbMzgwLCA2LCAxXSxcbiAgMzkwLFxuICAzOTIsXG4gIHMsXG4gIFszOTgsIDQsIDJdLFxuICA0MDgsXG4gIDQxMCxcbiAgNDEzLFxuICA0MTYsXG4gIDQxNyxcbiAgNDE4LFxuICA0MjQsXG4gIDQyOCxcbiAgNDMxLFxuICA0MzUsXG4gIDQzNixcbiAgcyxcbiAgWzQzOSwgNSwgMV0sXG4gIDQ0NyxcbiAgNDUxLFxuICA0NTQsXG4gIDQ1NixcbiAgNDU3LFxuICA0NTksXG4gIDQ2MyxcbiAgNDY0LFxuICA0NjcsXG4gIDQ3MyxcbiAgNDc0LFxuICA0NzgsXG4gIDQ4MyxcbiAgNDg0LFxuICA0ODUsXG4gIDQ4OCxcbiAgcyxcbiAgWzQ4OSwgNSwgMl0sXG4gIDUwMixcbiAgNTAzLFxuICA1MDYsXG4gIHMsXG4gIFs1MjEsIDUsIDFdLFxuICA1MzIsXG4gIDUzMyxcbiAgNTM1LFxuICA1NDEsXG4gIDU0OSxcbiAgNTUyLFxuICA1NTMsXG4gIDU1OCxcbiAgNTYwLFxuICA1NjQsXG4gIDU2N1xuXSksXG4gIGdvdG86IHUoW1xuICA4LFxuICAyMyxcbiAgMjEsXG4gIDI1LFxuICAyNixcbiAgMjcsXG4gIDY2LFxuICA2NyxcbiAgNCxcbiAgOSxcbiAgNixcbiAgMjQsXG4gIDcsXG4gIDExLFxuICAxMixcbiAgMTMsXG4gIDE5LFxuICAxOTMsXG4gIDE5NCxcbiAgMTg1LFxuICAxODAsXG4gIDE4MSxcbiAgMTgyLFxuICAxNzYsXG4gIDE3NyxcbiAgMixcbiAgMyxcbiAgNSxcbiAgMTk2LFxuICAxNyxcbiAgMTkwLFxuICA3MSxcbiAgNzYsXG4gIDc1LFxuICAxLFxuICAxOTgsXG4gIDIwNCxcbiAgMTcwLFxuICAxNSxcbiAgMTQsXG4gIDE2LFxuICA3MCxcbiAgNzcsXG4gIDYzLFxuICA2NSxcbiAgcyxcbiAgWzIwOSwgNSwgMV0sXG4gIDg4LFxuICA5OCxcbiAgMjI0LFxuICAyMjUsXG4gIDc0LFxuICAxODMsXG4gIDE3OCxcbiAgMTg0LFxuICAxNzksXG4gIDQ4LFxuICA1NyxcbiAgNTksXG4gIDEwLFxuICAxODgsXG4gIDE4LFxuICAxOTIsXG4gIDY0LFxuICAxMDMsXG4gIDEwNCxcbiAgMTA1LFxuICAxMDcsXG4gIDEwOCxcbiAgMTE3LFxuICAyMjYsXG4gIDIyNyxcbiAgMjI4LFxuICAyMzEsXG4gIDE2MixcbiAgMjQzLFxuICAyNDQsXG4gIDE3MSxcbiAgMTcyLFxuICAxNzMsXG4gIDc5LFxuICA4MixcbiAgMjIyLFxuICAyMjMsXG4gIDI0MCxcbiAgMjQxLFxuICAyNDIsXG4gIDQ3LFxuICAyOCxcbiAgNDUsXG4gIDQ2LFxuICA1OCxcbiAgNTQsXG4gIDgzLFxuICA4NSxcbiAgMTg2LFxuICBzLFxuICBbMjQ3LCAxNCwgMV0sXG4gIDExNSxcbiAgMTMxLFxuICAxMzMsXG4gIDEzNSxcbiAgMTYxLFxuICAxMjksXG4gIDE3NCxcbiAgMTIzLFxuICAxMjQsXG4gIDE2OCxcbiAgMTAxLFxuICAxNjMsXG4gIDE2NSxcbiAgMjQ1LFxuICAyNDYsXG4gIDQ5LFxuICA1MSxcbiAgNTMsXG4gIDQxLFxuICA0MyxcbiAgNDQsXG4gIDYwLFxuICA1NixcbiAgNjEsXG4gIDY5LFxuICA4NCxcbiAgODYsXG4gIDg3LFxuICAxMTEsXG4gIDE1OCxcbiAgMTI3LFxuICAxMzAsXG4gIDk5LFxuICAxNDAsXG4gIDE0MSxcbiAgMTMyLFxuICAxNDcsXG4gIDEzNCxcbiAgMTQ1LFxuICAxMzgsXG4gIDEzOSxcbiAgMTQyLFxuICAxNDMsXG4gIDE0NCxcbiAgMTY5LFxuICAxNjQsXG4gIDc4LFxuICA3MyxcbiAgMjAwLFxuICAyMDYsXG4gIDM5LFxuICA0MCxcbiAgNDIsXG4gIDM3LFxuICA1NSxcbiAgNjgsXG4gIDEzNyxcbiAgMTI2LFxuICAxMDAsXG4gIDE2MCxcbiAgMTE4LFxuICAxMjIsXG4gIDEyNSxcbiAgMTAyLFxuICAxNjYsXG4gIDE2NyxcbiAgNzIsXG4gIDM4LFxuICAzMyxcbiAgMzUsXG4gIDM2LFxuICAxMTMsXG4gIDE0NixcbiAgMTM2LFxuICAxMjgsXG4gIDEyMCxcbiAgMTIxLFxuICA5NSxcbiAgMzEsXG4gIDMyLFxuICAzNCxcbiAgMTEwLFxuICBzLFxuICBbMTQ4LCA0LCAyXSxcbiAgMTE5LFxuICAyMCxcbiAgMjAyLFxuICAzMCxcbiAgMTU3LFxuICBzLFxuICBbMTQ5LCA0LCAyXSxcbiAgMjIsXG4gIDI5LFxuICA4OSxcbiAgMTU2LFxuICA5MCxcbiAgOTYsXG4gIDk3LFxuICA5MixcbiAgOTEsXG4gIDkzLFxuICA5NFxuXSlcbn0pLFxucGFyc2VFcnJvcjogZnVuY3Rpb24gcGFyc2VFcnJvcihzdHIsIGhhc2gsIEV4Y2VwdGlvbkNsYXNzKSB7XG4gICAgaWYgKGhhc2gucmVjb3ZlcmFibGUgJiYgdHlwZW9mIHRoaXMudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy50cmFjZShzdHIpO1xuICAgICAgICBoYXNoLmRlc3Ryb3koKTsgLy8gZGVzdHJveS4uLiB3ZWxsLCAqYWxtb3N0KiFcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIUV4Y2VwdGlvbkNsYXNzKSB7XG4gICAgICAgICAgICBFeGNlcHRpb25DbGFzcyA9IHRoaXMuSmlzb25QYXJzZXJFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uQ2xhc3Moc3RyLCBoYXNoKTtcbiAgICB9XG59LFxucGFyc2U6IGZ1bmN0aW9uIHBhcnNlKGlucHV0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBzdGFjayA9IG5ldyBBcnJheSgxMjgpOyAgICAgICAgIC8vIHRva2VuIHN0YWNrOiBzdG9yZXMgdG9rZW4gd2hpY2ggbGVhZHMgdG8gc3RhdGUgYXQgdGhlIHNhbWUgaW5kZXggKGNvbHVtbiBzdG9yYWdlKVxuICAgIHZhciBzc3RhY2sgPSBuZXcgQXJyYXkoMTI4KTsgICAgICAgIC8vIHN0YXRlIHN0YWNrOiBzdG9yZXMgc3RhdGVzIChjb2x1bW4gc3RvcmFnZSlcblxuICAgIHZhciB2c3RhY2sgPSBuZXcgQXJyYXkoMTI4KTsgICAgICAgIC8vIHNlbWFudGljIHZhbHVlIHN0YWNrXG4gICAgdmFyIGxzdGFjayA9IG5ldyBBcnJheSgxMjgpOyAgICAgICAgLy8gbG9jYXRpb24gc3RhY2tcbiAgICB2YXIgdGFibGUgPSB0aGlzLnRhYmxlO1xuICAgIHZhciBzcCA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vICdzdGFjayBwb2ludGVyJzogaW5kZXggaW50byB0aGUgc3RhY2tzXG4gICAgdmFyIHl5bG9jO1xuXG4gICAgdmFyIHl5bGluZW5vO1xuXG5cbiAgICB2YXIgc3ltYm9sID0gMDtcblxuXG5cbiAgICB2YXIgVEVSUk9SID0gdGhpcy5URVJST1I7XG4gICAgdmFyIEVPRiA9IHRoaXMuRU9GO1xuICAgIHZhciBFUlJPUl9SRUNPVkVSWV9UT0tFTl9ESVNDQVJEX0NPVU5UID0gKHRoaXMub3B0aW9ucy5lcnJvclJlY292ZXJ5VG9rZW5EaXNjYXJkQ291bnQgfCAwKSB8fCAzO1xuICAgIHZhciBOT19BQ1RJT04gPSBbMCwgNTY4IC8qID09PSB0YWJsZS5sZW5ndGggOjogZW5zdXJlcyB0aGF0IGFueW9uZSB1c2luZyB0aGlzIG5ldyBzdGF0ZSB3aWxsIGZhaWwgZHJhbWF0aWNhbGx5ISAqL107XG5cbiAgICB2YXIgbGV4ZXI7XG4gICAgaWYgKHRoaXMuX19sZXhlcl9fKSB7XG4gICAgICAgIGxleGVyID0gdGhpcy5fX2xleGVyX187XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV4ZXIgPSB0aGlzLl9fbGV4ZXJfXyA9IE9iamVjdC5jcmVhdGUodGhpcy5sZXhlcik7XG4gICAgfVxuXG4gICAgdmFyIHNoYXJlZFN0YXRlX3l5ID0ge1xuICAgICAgICBwYXJzZUVycm9yOiB1bmRlZmluZWQsXG4gICAgICAgIHF1b3RlTmFtZTogdW5kZWZpbmVkLFxuICAgICAgICBsZXhlcjogdW5kZWZpbmVkLFxuICAgICAgICBwYXJzZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgcHJlX3BhcnNlOiB1bmRlZmluZWQsXG4gICAgICAgIHBvc3RfcGFyc2U6IHVuZGVmaW5lZCxcbiAgICAgICAgcHJlX2xleDogdW5kZWZpbmVkLFxuICAgICAgICBwb3N0X2xleDogdW5kZWZpbmVkICAgICAgLy8gV0FSTklORzogbXVzdCBiZSB3cml0dGVuIHRoaXMgd2F5IGZvciB0aGUgY29kZSBleHBhbmRlcnMgdG8gd29yayBjb3JyZWN0bHkgaW4gYm90aCBFUzUgYW5kIEVTNiBtb2RlcyFcbiAgICB9O1xuXG4gICAgdmFyIEFTU0VSVDtcbiAgICBpZiAodHlwZW9mIGFzc2VydCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBBU1NFUlQgPSBmdW5jdGlvbiBKaXNvbkFzc2VydChjb25kLCBtc2cpIHtcbiAgICAgICAgICAgIGlmICghY29uZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzZXJ0aW9uIGZhaWxlZDogJyArIChtc2cgfHwgJyoqKicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBBU1NFUlQgPSBhc3NlcnQ7XG4gICAgfVxuXG4gICAgdGhpcy55eUdldFNoYXJlZFN0YXRlID0gZnVuY3Rpb24geXlHZXRTaGFyZWRTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHNoYXJlZFN0YXRlX3l5O1xuICAgIH07XG5cblxuICAgIC8vIHNoYWxsb3cgY2xvbmUgb2JqZWN0cywgc3RyYWlnaHQgY29weSBvZiBzaW1wbGUgYHNyY2AgdmFsdWVzXG4gICAgLy8gZS5nLiBgbGV4ZXIueXl0ZXh0YCBNQVkgYmUgYSBjb21wbGV4IHZhbHVlIG9iamVjdCxcbiAgICAvLyByYXRoZXIgdGhhbiBhIHNpbXBsZSBzdHJpbmcvdmFsdWUuXG4gICAgZnVuY3Rpb24gc2hhbGxvd19jb3B5KHNyYykge1xuICAgICAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHZhciBkc3QgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gc3JjKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzcmMsIGspKSB7XG4gICAgICAgICAgICAgICAgICAgIGRzdFtrXSA9IHNyY1trXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZHN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcmM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNoYWxsb3dfY29weV9ub2Nsb2JiZXIoZHN0LCBzcmMpIHtcbiAgICAgICAgZm9yICh2YXIgayBpbiBzcmMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZHN0W2tdID09PSAndW5kZWZpbmVkJyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3JjLCBrKSkge1xuICAgICAgICAgICAgICAgIGRzdFtrXSA9IHNyY1trXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb3B5X3l5bGxvYyhsb2MpIHtcbiAgICAgICAgdmFyIHJ2ID0gc2hhbGxvd19jb3B5KGxvYyk7XG4gICAgICAgIGlmIChydiAmJiBydi5yYW5nZSkge1xuICAgICAgICAgICAgcnYucmFuZ2UgPSBydi5yYW5nZS5zbGljZSgwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnY7XG4gICAgfVxuXG4gICAgLy8gY29weSBzdGF0ZVxuICAgIHNoYWxsb3dfY29weV9ub2Nsb2JiZXIoc2hhcmVkU3RhdGVfeXksIHRoaXMueXkpO1xuXG4gICAgc2hhcmVkU3RhdGVfeXkubGV4ZXIgPSBsZXhlcjtcbiAgICBzaGFyZWRTdGF0ZV95eS5wYXJzZXIgPSB0aGlzO1xuXG5cblxuXG5cblxuICAgIC8vIERvZXMgdGhlIHNoYXJlZCBzdGF0ZSBvdmVycmlkZSB0aGUgZGVmYXVsdCBgcGFyc2VFcnJvcmAgdGhhdCBhbHJlYWR5IGNvbWVzIHdpdGggdGhpcyBpbnN0YW5jZT9cbiAgICBpZiAodHlwZW9mIHNoYXJlZFN0YXRlX3l5LnBhcnNlRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5wYXJzZUVycm9yID0gZnVuY3Rpb24gcGFyc2VFcnJvckFsdChzdHIsIGhhc2gsIEV4Y2VwdGlvbkNsYXNzKSB7XG4gICAgICAgICAgICBpZiAoIUV4Y2VwdGlvbkNsYXNzKSB7XG4gICAgICAgICAgICAgICAgRXhjZXB0aW9uQ2xhc3MgPSB0aGlzLkppc29uUGFyc2VyRXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2hhcmVkU3RhdGVfeXkucGFyc2VFcnJvci5jYWxsKHRoaXMsIHN0ciwgaGFzaCwgRXhjZXB0aW9uQ2xhc3MpO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFyc2VFcnJvciA9IHRoaXMub3JpZ2luYWxQYXJzZUVycm9yO1xuICAgIH1cblxuICAgIC8vIERvZXMgdGhlIHNoYXJlZCBzdGF0ZSBvdmVycmlkZSB0aGUgZGVmYXVsdCBgcXVvdGVOYW1lYCB0aGF0IGFscmVhZHkgY29tZXMgd2l0aCB0aGlzIGluc3RhbmNlP1xuICAgIGlmICh0eXBlb2Ygc2hhcmVkU3RhdGVfeXkucXVvdGVOYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucXVvdGVOYW1lID0gZnVuY3Rpb24gcXVvdGVOYW1lQWx0KGlkX3N0cikge1xuICAgICAgICAgICAgcmV0dXJuIHNoYXJlZFN0YXRlX3l5LnF1b3RlTmFtZS5jYWxsKHRoaXMsIGlkX3N0cik7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5xdW90ZU5hbWUgPSB0aGlzLm9yaWdpbmFsUXVvdGVOYW1lO1xuICAgIH1cblxuICAgIC8vIHNldCB1cCB0aGUgY2xlYW51cCBmdW5jdGlvbjsgbWFrZSBpdCBhbiBBUEkgc28gdGhhdCBleHRlcm5hbCBjb2RlIGNhbiByZS11c2UgdGhpcyBvbmUgaW4gY2FzZSBvZlxuICAgIC8vIGNhbGFtaXRpZXMgb3Igd2hlbiB0aGUgYCVvcHRpb25zIG5vLXRyeS1jYXRjaGAgb3B0aW9uIGhhcyBiZWVuIHNwZWNpZmllZCBmb3IgdGhlIGdyYW1tYXIsIGluIHdoaWNoXG4gICAgLy8gY2FzZSB0aGlzIHBhcnNlKCkgQVBJIG1ldGhvZCBkb2Vzbid0IGNvbWUgd2l0aCBhIGBmaW5hbGx5IHsgLi4uIH1gIGJsb2NrIGFueSBtb3JlIVxuICAgIC8vXG4gICAgLy8gTk9URTogYXMgdGhpcyBBUEkgdXNlcyBwYXJzZSgpIGFzIGEgY2xvc3VyZSwgaXQgTVVTVCBiZSBzZXQgYWdhaW4gb24gZXZlcnkgcGFyc2UoKSBpbnZvY2F0aW9uLFxuICAgIC8vICAgICAgIG9yIGVsc2UgeW91ciBgc2hhcmVkU3RhdGVgLCBldGMuIHJlZmVyZW5jZXMgd2lsbCBiZSAqd3JvbmcqIVxuICAgIHRoaXMuY2xlYW51cEFmdGVyUGFyc2UgPSBmdW5jdGlvbiBwYXJzZXJfY2xlYW51cEFmdGVyUGFyc2UocmVzdWx0VmFsdWUsIGludm9rZV9wb3N0X21ldGhvZHMsIGRvX25vdF9udWtlX2Vycm9yaW5mb3MpIHtcbiAgICAgICAgdmFyIHJ2O1xuXG4gICAgICAgIGlmIChpbnZva2VfcG9zdF9tZXRob2RzKSB7XG4gICAgICAgICAgICB2YXIgaGFzaDtcblxuICAgICAgICAgICAgaWYgKHNoYXJlZFN0YXRlX3l5LnBvc3RfcGFyc2UgfHwgdGhpcy5wb3N0X3BhcnNlKSB7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGFuIGVycm9yIGhhc2ggaW5mbyBpbnN0YW5jZTogd2UgcmUtdXNlIHRoaXMgQVBJIGluIGEgKipub24tZXJyb3Igc2l0dWF0aW9uKipcbiAgICAgICAgICAgICAgICAvLyBhcyB0aGlzIG9uZSBkZWxpdmVycyBhbGwgcGFyc2VyIGludGVybmFscyByZWFkeSBmb3IgYWNjZXNzIGJ5IHVzZXJsYW5kIGNvZGUuXG4gICAgICAgICAgICAgICAgaGFzaCA9IHRoaXMuY29uc3RydWN0UGFyc2VFcnJvckluZm8obnVsbCAvKiBubyBlcnJvciEgKi8sIG51bGwgLyogbm8gZXhjZXB0aW9uISAqLywgbnVsbCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2hhcmVkU3RhdGVfeXkucG9zdF9wYXJzZSkge1xuICAgICAgICAgICAgICAgIHJ2ID0gc2hhcmVkU3RhdGVfeXkucG9zdF9wYXJzZS5jYWxsKHRoaXMsIHNoYXJlZFN0YXRlX3l5LCByZXN1bHRWYWx1ZSwgaGFzaCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBydiAhPT0gJ3VuZGVmaW5lZCcpIHJlc3VsdFZhbHVlID0gcnY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wb3N0X3BhcnNlKSB7XG4gICAgICAgICAgICAgICAgcnYgPSB0aGlzLnBvc3RfcGFyc2UuY2FsbCh0aGlzLCBzaGFyZWRTdGF0ZV95eSwgcmVzdWx0VmFsdWUsIGhhc2gpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcnYgIT09ICd1bmRlZmluZWQnKSByZXN1bHRWYWx1ZSA9IHJ2O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjbGVhbnVwOlxuICAgICAgICAgICAgaWYgKGhhc2ggJiYgaGFzaC5kZXN0cm95KSB7XG4gICAgICAgICAgICAgICAgaGFzaC5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fX3JlZW50cmFudF9jYWxsX2RlcHRoID4gMSkgcmV0dXJuIHJlc3VsdFZhbHVlOyAgICAgICAgLy8gZG8gbm90ICh5ZXQpIGtpbGwgdGhlIHNoYXJlZFN0YXRlIHdoZW4gdGhpcyBpcyBhIHJlZW50cmFudCBydW4uXG5cbiAgICAgICAgLy8gY2xlYW4gdXAgdGhlIGxpbmdlcmluZyBsZXhlciBzdHJ1Y3R1cmVzIGFzIHdlbGw6XG4gICAgICAgIGlmIChsZXhlci5jbGVhbnVwQWZ0ZXJMZXgpIHtcbiAgICAgICAgICAgIGxleGVyLmNsZWFudXBBZnRlckxleChkb19ub3RfbnVrZV9lcnJvcmluZm9zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHByZXZlbnQgbGluZ2VyaW5nIGNpcmN1bGFyIHJlZmVyZW5jZXMgZnJvbSBjYXVzaW5nIG1lbW9yeSBsZWFrczpcbiAgICAgICAgaWYgKHNoYXJlZFN0YXRlX3l5KSB7XG4gICAgICAgICAgICBzaGFyZWRTdGF0ZV95eS5sZXhlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHNoYXJlZFN0YXRlX3l5LnBhcnNlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChsZXhlci55eSA9PT0gc2hhcmVkU3RhdGVfeXkpIHtcbiAgICAgICAgICAgICAgICBsZXhlci55eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzaGFyZWRTdGF0ZV95eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5wYXJzZUVycm9yID0gdGhpcy5vcmlnaW5hbFBhcnNlRXJyb3I7XG4gICAgICAgIHRoaXMucXVvdGVOYW1lID0gdGhpcy5vcmlnaW5hbFF1b3RlTmFtZTtcblxuICAgICAgICAvLyBudWtlIHRoZSB2c3RhY2tbXSBhcnJheSBhdCBsZWFzdCBhcyB0aGF0IG9uZSB3aWxsIHN0aWxsIHJlZmVyZW5jZSBvYnNvbGV0ZWQgdXNlciB2YWx1ZXMuXG4gICAgICAgIC8vIFRvIGJlIHNhZmUsIHdlIG51a2UgdGhlIG90aGVyIGludGVybmFsIHN0YWNrIGNvbHVtbnMgYXMgd2VsbC4uLlxuICAgICAgICBzdGFjay5sZW5ndGggPSAwOyAgICAgICAgICAgICAgIC8vIGZhc3Rlc3Qgd2F5IHRvIG51a2UgYW4gYXJyYXkgd2l0aG91dCBvdmVybHkgYm90aGVyaW5nIHRoZSBHQ1xuICAgICAgICBzc3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgbHN0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgIHZzdGFjay5sZW5ndGggPSAwO1xuICAgICAgICBzcCA9IDA7XG5cbiAgICAgICAgLy8gbnVrZSB0aGUgZXJyb3IgaGFzaCBpbmZvIGluc3RhbmNlcyBjcmVhdGVkIGR1cmluZyB0aGlzIHJ1bi5cbiAgICAgICAgLy8gVXNlcmxhbmQgY29kZSBtdXN0IENPUFkgYW55IGRhdGEvcmVmZXJlbmNlc1xuICAgICAgICAvLyBpbiB0aGUgZXJyb3IgaGFzaCBpbnN0YW5jZShzKSBpdCBpcyBtb3JlIHBlcm1hbmVudGx5IGludGVyZXN0ZWQgaW4uXG4gICAgICAgIGlmICghZG9fbm90X251a2VfZXJyb3JpbmZvcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX19lcnJvcl9pbmZvcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuX19lcnJvcl9pbmZvc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoZWwgJiYgdHlwZW9mIGVsLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX19lcnJvcl9pbmZvcy5sZW5ndGggPSAwO1xuXG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRWYWx1ZTtcbiAgICB9O1xuXG4gICAgLy8gbWVyZ2UgeXlsbG9jIGluZm8gaW50byBhIG5ldyB5eWxsb2MgaW5zdGFuY2UuXG4gICAgLy9cbiAgICAvLyBgZmlyc3RfaW5kZXhgIGFuZCBgbGFzdF9pbmRleGAgTUFZIGJlIFVOREVGSU5FRC9OVUxMIG9yIHRoZXNlIGFyZSBpbmRleGVzIGludG8gdGhlIGBsc3RhY2tbXWAgbG9jYXRpb24gc3RhY2sgYXJyYXkuXG4gICAgLy9cbiAgICAvLyBgZmlyc3RfeXlsbG9jYCBhbmQgYGxhc3RfeXlsbG9jYCBNQVkgYmUgVU5ERUZJTkVEL05VTEwgb3IgZXhwbGljaXQgKGN1c3RvbSBvciByZWd1bGFyKSBgeXlsbG9jYCBpbnN0YW5jZXMsIGluIHdoaWNoXG4gICAgLy8gY2FzZSB0aGVzZSBvdmVycmlkZSB0aGUgY29ycmVzcG9uZGluZyBmaXJzdC9sYXN0IGluZGV4ZXMuXG4gICAgLy9cbiAgICAvLyBgZG9udF9sb29rX2JhY2tgIGlzIGFuIG9wdGlvbmFsIGZsYWcgKGRlZmF1bHQ6IEZBTFNFKSwgd2hpY2ggaW5zdHJ1Y3RzIHRoaXMgbWVyZ2Ugb3BlcmF0aW9uIE5PVCB0byBzZWFyY2hcbiAgICAvLyB0aHJvdWdoIHRoZSBwYXJzZSBsb2NhdGlvbiBzdGFjayBmb3IgYSBsb2NhdGlvbiwgd2hpY2ggd291bGQgb3RoZXJ3aXNlIGJlIHVzZWQgdG8gY29uc3RydWN0IHRoZSBuZXcgKGVwc2lsb24hKVxuICAgIC8vIHl5bGxvYyBpbmZvLlxuICAgIC8vXG4gICAgLy8gTm90ZTogZXBzaWxvbiBydWxlJ3MgeXlsbG9jIHNpdHVhdGlvbiBpcyBkZXRlY3RlZCBieSBwYXNzaW5nIGJvdGggYGZpcnN0X2luZGV4YCBhbmQgYGZpcnN0X3l5bGxvY2AgYXMgVU5ERUZJTkVEL05VTEwuXG4gICAgdGhpcy55eU1lcmdlTG9jYXRpb25JbmZvID0gZnVuY3Rpb24gcGFyc2VyX3l5TWVyZ2VMb2NhdGlvbkluZm8oZmlyc3RfaW5kZXgsIGxhc3RfaW5kZXgsIGZpcnN0X3l5bGxvYywgbGFzdF95eWxsb2MsIGRvbnRfbG9va19iYWNrKSB7XG4gICAgICAgIHZhciBpMSA9IGZpcnN0X2luZGV4IHwgMCxcbiAgICAgICAgICAgIGkyID0gbGFzdF9pbmRleCB8IDA7XG4gICAgICAgIHZhciBsMSA9IGZpcnN0X3l5bGxvYyxcbiAgICAgICAgICAgIGwyID0gbGFzdF95eWxsb2M7XG4gICAgICAgIHZhciBydjtcblxuICAgICAgICAvLyBydWxlczpcbiAgICAgICAgLy8gLSBmaXJzdC9sYXN0IHl5bGxvYyBlbnRyaWVzIG92ZXJyaWRlIGZpcnN0L2xhc3QgaW5kZXhlc1xuXG4gICAgICAgIGlmICghbDEpIHtcbiAgICAgICAgICAgIGlmIChmaXJzdF9pbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGkxOyBpIDw9IGkyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbDEgPSBsc3RhY2tbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChsMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWwyKSB7XG4gICAgICAgICAgICBpZiAobGFzdF9pbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGkyOyBpID49IGkxOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgbDIgPSBsc3RhY2tbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChsMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyAtIGRldGVjdCBpZiBhbiBlcHNpbG9uIHJ1bGUgaXMgYmVpbmcgcHJvY2Vzc2VkIGFuZCBhY3QgYWNjb3JkaW5nbHk6XG4gICAgICAgIGlmICghbDEgJiYgZmlyc3RfaW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gZXBzaWxvbiBydWxlIHNwYW4gbWVyZ2VyLiBXaXRoIG9wdGlvbmFsIGxvb2stYWhlYWQgaW4gbDIuXG4gICAgICAgICAgICBpZiAoIWRvbnRfbG9va19iYWNrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IChpMSB8fCBzcCkgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBsMSA9IGxzdGFja1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGwxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWwyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gd2Ugc3RpbGwgZG9uJ3QgaGF2ZSBhbnkgdmFsaWQgeXlsbG9jIGluZm8sIHdlJ3JlIGxvb2tpbmcgYXQgYW4gZXBzaWxvbiBydWxlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdpdGhvdXQgbG9vay1haGVhZCBhbmQgbm8gcHJlY2VkaW5nIHRlcm1zIGFuZC9vciBgZG9udF9sb29rX2JhY2tgIHNldDpcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhIGRvIG5vdGhpbmcgYnV0IHJldHVybiBOVUxML1VOREVGSU5FRDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBzaGFsbG93LWNvcHkgTDI6IGFmdGVyIGFsbCwgd2UgTUFZIGJlIGxvb2tpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gYXQgdW5jb252ZW50aW9uYWwgeXlsbG9jIGluZm8gb2JqZWN0cy4uLlxuICAgICAgICAgICAgICAgICAgICBydiA9IHNoYWxsb3dfY29weShsMik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChydi5yYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hhbGxvdyBjb3B5IHRoZSB5eWxsb2MgcmFuZ2VzIGluZm8gdG8gcHJldmVudCB1cyBmcm9tIG1vZGlmeWluZyB0aGUgb3JpZ2luYWwgYXJndW1lbnRzJyBlbnRyaWVzOlxuICAgICAgICAgICAgICAgICAgICAgICAgcnYucmFuZ2UgPSBydi5yYW5nZS5zbGljZSgwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzaGFsbG93LWNvcHkgTDEsIHRoZW4gYWRqdXN0IGZpcnN0IGNvbC9yb3cgMSBjb2x1bW4gcGFzdCB0aGUgZW5kLlxuICAgICAgICAgICAgICAgIHJ2ID0gc2hhbGxvd19jb3B5KGwxKTtcbiAgICAgICAgICAgICAgICBydi5maXJzdF9saW5lID0gcnYubGFzdF9saW5lO1xuICAgICAgICAgICAgICAgIHJ2LmZpcnN0X2NvbHVtbiA9IHJ2Lmxhc3RfY29sdW1uO1xuICAgICAgICAgICAgICAgIGlmIChydi5yYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzaGFsbG93IGNvcHkgdGhlIHl5bGxvYyByYW5nZXMgaW5mbyB0byBwcmV2ZW50IHVzIGZyb20gbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbCBhcmd1bWVudHMnIGVudHJpZXM6XG4gICAgICAgICAgICAgICAgICAgIHJ2LnJhbmdlID0gcnYucmFuZ2Uuc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgICAgIHJ2LnJhbmdlWzBdID0gcnYucmFuZ2VbMV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGwyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNoYWxsb3ctbWl4aW4gTDIsIHRoZW4gYWRqdXN0IGxhc3QgY29sL3JvdyBhY2NvcmRpbmdseS5cbiAgICAgICAgICAgICAgICAgICAgc2hhbGxvd19jb3B5X25vY2xvYmJlcihydiwgbDIpO1xuICAgICAgICAgICAgICAgICAgICBydi5sYXN0X2xpbmUgPSBsMi5sYXN0X2xpbmU7XG4gICAgICAgICAgICAgICAgICAgIHJ2Lmxhc3RfY29sdW1uID0gbDIubGFzdF9jb2x1bW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChydi5yYW5nZSAmJiBsMi5yYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnYucmFuZ2VbMV0gPSBsMi5yYW5nZVsxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWwxKSB7XG4gICAgICAgICAgICBsMSA9IGwyO1xuICAgICAgICAgICAgbDIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbDEpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzaGFsbG93LWNvcHkgTDF8TDIsIGJlZm9yZSB3ZSB0cnkgdG8gYWRqdXN0IHRoZSB5eWxsb2MgdmFsdWVzOiBhZnRlciBhbGwsIHdlIE1BWSBiZSBsb29raW5nXG4gICAgICAgIC8vIGF0IHVuY29udmVudGlvbmFsIHl5bGxvYyBpbmZvIG9iamVjdHMuLi5cbiAgICAgICAgcnYgPSBzaGFsbG93X2NvcHkobDEpO1xuXG4gICAgICAgIC8vIGZpcnN0X2xpbmU6IC4uLixcbiAgICAgICAgLy8gZmlyc3RfY29sdW1uOiAuLi4sXG4gICAgICAgIC8vIGxhc3RfbGluZTogLi4uLFxuICAgICAgICAvLyBsYXN0X2NvbHVtbjogLi4uLFxuICAgICAgICBpZiAocnYucmFuZ2UpIHtcbiAgICAgICAgICAgIC8vIHNoYWxsb3cgY29weSB0aGUgeXlsbG9jIHJhbmdlcyBpbmZvIHRvIHByZXZlbnQgdXMgZnJvbSBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsIGFyZ3VtZW50cycgZW50cmllczpcbiAgICAgICAgICAgIHJ2LnJhbmdlID0gcnYucmFuZ2Uuc2xpY2UoMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobDIpIHtcbiAgICAgICAgICAgIHNoYWxsb3dfY29weV9ub2Nsb2JiZXIocnYsIGwyKTtcbiAgICAgICAgICAgIHJ2Lmxhc3RfbGluZSA9IGwyLmxhc3RfbGluZTtcbiAgICAgICAgICAgIHJ2Lmxhc3RfY29sdW1uID0gbDIubGFzdF9jb2x1bW47XG4gICAgICAgICAgICBpZiAocnYucmFuZ2UgJiYgbDIucmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBydi5yYW5nZVsxXSA9IGwyLnJhbmdlWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgIH07XG5cbiAgICAvLyBOT1RFOiBhcyB0aGlzIEFQSSB1c2VzIHBhcnNlKCkgYXMgYSBjbG9zdXJlLCBpdCBNVVNUIGJlIHNldCBhZ2FpbiBvbiBldmVyeSBwYXJzZSgpIGludm9jYXRpb24sXG4gICAgLy8gICAgICAgb3IgZWxzZSB5b3VyIGBsZXhlcmAsIGBzaGFyZWRTdGF0ZWAsIGV0Yy4gcmVmZXJlbmNlcyB3aWxsIGJlICp3cm9uZyohXG4gICAgdGhpcy5jb25zdHJ1Y3RQYXJzZUVycm9ySW5mbyA9IGZ1bmN0aW9uIHBhcnNlcl9jb25zdHJ1Y3RQYXJzZUVycm9ySW5mbyhtc2csIGV4LCBleHBlY3RlZCwgcmVjb3ZlcmFibGUpIHtcbiAgICAgICAgdmFyIHBlaSA9IHtcbiAgICAgICAgICAgIGVyclN0cjogbXNnLFxuICAgICAgICAgICAgZXhjZXB0aW9uOiBleCxcbiAgICAgICAgICAgIHRleHQ6IGxleGVyLm1hdGNoLFxuICAgICAgICAgICAgdmFsdWU6IGxleGVyLnl5dGV4dCxcbiAgICAgICAgICAgIHRva2VuOiB0aGlzLmRlc2NyaWJlU3ltYm9sKHN5bWJvbCkgfHwgc3ltYm9sLFxuICAgICAgICAgICAgdG9rZW5faWQ6IHN5bWJvbCxcbiAgICAgICAgICAgIGxpbmU6IGxleGVyLnl5bGluZW5vLFxuICAgICAgICAgICAgbG9jOiBjb3B5X3l5bGxvYyhsZXhlci55eWxsb2MpLFxuICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgICAgICAgcmVjb3ZlcmFibGU6IHJlY292ZXJhYmxlLFxuICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgICBuZXdfc3RhdGU6IG5ld1N0YXRlLFxuICAgICAgICAgICAgc3ltYm9sX3N0YWNrOiBzdGFjayxcbiAgICAgICAgICAgIHN0YXRlX3N0YWNrOiBzc3RhY2ssXG4gICAgICAgICAgICB2YWx1ZV9zdGFjazogdnN0YWNrLFxuICAgICAgICAgICAgbG9jYXRpb25fc3RhY2s6IGxzdGFjayxcbiAgICAgICAgICAgIHN0YWNrX3BvaW50ZXI6IHNwLFxuICAgICAgICAgICAgeXk6IHNoYXJlZFN0YXRlX3l5LFxuICAgICAgICAgICAgbGV4ZXI6IGxleGVyLFxuICAgICAgICAgICAgcGFyc2VyOiB0aGlzLFxuXG4gICAgICAgICAgICAvLyBhbmQgbWFrZSBzdXJlIHRoZSBlcnJvciBpbmZvIGRvZXNuJ3Qgc3RheSBkdWUgdG8gcG90ZW50aWFsXG4gICAgICAgICAgICAvLyByZWYgY3ljbGUgdmlhIHVzZXJsYW5kIGNvZGUgbWFuaXB1bGF0aW9ucy5cbiAgICAgICAgICAgIC8vIFRoZXNlIHdvdWxkIG90aGVyd2lzZSBhbGwgYmUgbWVtb3J5IGxlYWsgb3Bwb3J0dW5pdGllcyFcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgb25seSBhcnJheSBhbmQgb2JqZWN0IHJlZmVyZW5jZXMgYXJlIG51a2VkIGFzIHRob3NlXG4gICAgICAgICAgICAvLyBjb25zdGl0dXRlIHRoZSBzZXQgb2YgZWxlbWVudHMgd2hpY2ggY2FuIHByb2R1Y2UgYSBjeWNsaWMgcmVmLlxuICAgICAgICAgICAgLy8gVGhlIHJlc3Qgb2YgdGhlIG1lbWJlcnMgaXMga2VwdCBpbnRhY3QgYXMgdGhleSBhcmUgaGFybWxlc3MuXG4gICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cnVjdFBhcnNlRXJyb3JJbmZvKCkge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBjeWNsaWMgcmVmZXJlbmNlcyBhZGRlZCB0byBlcnJvciBpbmZvOlxuICAgICAgICAgICAgICAgIC8vIGluZm8ueXkgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIGluZm8ubGV4ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIGluZm8udmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIGluZm8udmFsdWVfc3RhY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIC4uLlxuICAgICAgICAgICAgICAgIHZhciByZWMgPSAhIXRoaXMucmVjb3ZlcmFibGU7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiB0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3ZlcmFibGUgPSByZWM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIHRyYWNrIHRoaXMgaW5zdGFuY2Ugc28gd2UgY2FuIGBkZXN0cm95KClgIGl0IG9uY2Ugd2UgZGVlbSBpdCBzdXBlcmZsdW91cyBhbmQgcmVhZHkgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbiFcbiAgICAgICAgdGhpcy5fX2Vycm9yX2luZm9zLnB1c2gocGVpKTtcbiAgICAgICAgcmV0dXJuIHBlaTtcbiAgICB9O1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4gICAgZnVuY3Rpb24gZ2V0Tm9uVGVybWluYWxGcm9tQ29kZShzeW1ib2wpIHtcbiAgICAgICAgdmFyIHRva2VuTmFtZSA9IHNlbGYuZ2V0U3ltYm9sTmFtZShzeW1ib2wpO1xuICAgICAgICBpZiAoIXRva2VuTmFtZSkge1xuICAgICAgICAgICAgdG9rZW5OYW1lID0gc3ltYm9sO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbk5hbWU7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBsZXgoKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IGxleGVyLmxleCgpO1xuICAgICAgICAvLyBpZiB0b2tlbiBpc24ndCBpdHMgbnVtZXJpYyB2YWx1ZSwgY29udmVydFxuICAgICAgICBpZiAodHlwZW9mIHRva2VuICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdG9rZW4gPSBzZWxmLnN5bWJvbHNfW3Rva2VuXSB8fCB0b2tlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0b2tlbiB8fCBFT0Y7XG4gICAgfVxuXG5cbiAgICB2YXIgc3RhdGUsIGFjdGlvbiwgciwgdDtcbiAgICB2YXIgeXl2YWwgPSB7XG4gICAgICAgICQ6IHRydWUsXG4gICAgICAgIF8kOiB1bmRlZmluZWQsXG4gICAgICAgIHl5OiBzaGFyZWRTdGF0ZV95eVxuICAgIH07XG4gICAgdmFyIHA7XG4gICAgdmFyIHl5cnVsZWxlbjtcbiAgICB2YXIgdGhpc19wcm9kdWN0aW9uO1xuICAgIHZhciBuZXdTdGF0ZTtcbiAgICB2YXIgcmV0dmFsID0gZmFsc2U7XG5cblxuICAgIHRyeSB7XG4gICAgICAgIHRoaXMuX19yZWVudHJhbnRfY2FsbF9kZXB0aCsrO1xuXG4gICAgICAgIGxleGVyLnNldElucHV0KGlucHV0LCBzaGFyZWRTdGF0ZV95eSk7XG5cbiAgICAgICAgeXlsb2MgPSBsZXhlci55eWxsb2M7XG4gICAgICAgIGxzdGFja1tzcF0gPSB5eWxvYztcbiAgICAgICAgdnN0YWNrW3NwXSA9IG51bGw7XG4gICAgICAgIHNzdGFja1tzcF0gPSAwO1xuICAgICAgICBzdGFja1tzcF0gPSAwO1xuICAgICAgICArK3NwO1xuXG5cblxuXG5cbiAgICAgICAgaWYgKHRoaXMucHJlX3BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLnByZV9wYXJzZS5jYWxsKHRoaXMsIHNoYXJlZFN0YXRlX3l5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hhcmVkU3RhdGVfeXkucHJlX3BhcnNlKSB7XG4gICAgICAgICAgICBzaGFyZWRTdGF0ZV95eS5wcmVfcGFyc2UuY2FsbCh0aGlzLCBzaGFyZWRTdGF0ZV95eSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdTdGF0ZSA9IHNzdGFja1tzcCAtIDFdO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAvLyByZXRyaWV2ZSBzdGF0ZSBudW1iZXIgZnJvbSB0b3Agb2Ygc3RhY2tcbiAgICAgICAgICAgIHN0YXRlID0gbmV3U3RhdGU7ICAgICAgICAgICAgICAgLy8gc3N0YWNrW3NwIC0gMV07XG5cbiAgICAgICAgICAgIC8vIHVzZSBkZWZhdWx0IGFjdGlvbnMgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICBpZiAodGhpcy5kZWZhdWx0QWN0aW9uc1tzdGF0ZV0pIHtcbiAgICAgICAgICAgICAgICBhY3Rpb24gPSAyO1xuICAgICAgICAgICAgICAgIG5ld1N0YXRlID0gdGhpcy5kZWZhdWx0QWN0aW9uc1tzdGF0ZV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBzaW5nbGUgYD09YCBjb25kaXRpb24gYmVsb3cgY292ZXJzIGJvdGggdGhlc2UgYD09PWAgY29tcGFyaXNvbnMgaW4gYSBzaW5nbGVcbiAgICAgICAgICAgICAgICAvLyBvcGVyYXRpb246XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAgICAgaWYgKHN5bWJvbCA9PT0gbnVsbCB8fCB0eXBlb2Ygc3ltYm9sID09PSAndW5kZWZpbmVkJykgLi4uXG4gICAgICAgICAgICAgICAgaWYgKCFzeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHJlYWQgYWN0aW9uIGZvciBjdXJyZW50IHN0YXRlIGFuZCBmaXJzdCBpbnB1dFxuICAgICAgICAgICAgICAgIHQgPSAodGFibGVbc3RhdGVdICYmIHRhYmxlW3N0YXRlXVtzeW1ib2xdKSB8fCBOT19BQ1RJT047XG4gICAgICAgICAgICAgICAgbmV3U3RhdGUgPSB0WzFdO1xuICAgICAgICAgICAgICAgIGFjdGlvbiA9IHRbMF07XG5cblxuXG5cblxuXG5cblxuXG5cblxuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBwYXJzZSBlcnJvclxuICAgICAgICAgICAgICAgIGlmICghYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJTdHI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJTeW1ib2xEZXNjciA9ICh0aGlzLmRlc2NyaWJlU3ltYm9sKHN5bWJvbCkgfHwgc3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4cGVjdGVkID0gdGhpcy5jb2xsZWN0X2V4cGVjdGVkX3Rva2VuX3NldChzdGF0ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVwb3J0IGVycm9yXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGV4ZXIueXlsaW5lbm8gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJTdHIgPSAnUGFyc2UgZXJyb3Igb24gbGluZSAnICsgKGxleGVyLnl5bGluZW5vICsgMSkgKyAnOiAnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyU3RyID0gJ1BhcnNlIGVycm9yOiAnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGV4ZXIuc2hvd1Bvc2l0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJTdHIgKz0gJ1xcbicgKyBsZXhlci5zaG93UG9zaXRpb24oNzkgLSAxMCwgMTApICsgJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cGVjdGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyU3RyICs9ICdFeHBlY3RpbmcgJyArIGV4cGVjdGVkLmpvaW4oJywgJykgKyAnLCBnb3QgdW5leHBlY3RlZCAnICsgZXJyU3ltYm9sRGVzY3I7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJTdHIgKz0gJ1VuZXhwZWN0ZWQgJyArIGVyclN5bWJvbERlc2NyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGNhbm5vdCByZWNvdmVyIGZyb20gdGhlIGVycm9yIVxuICAgICAgICAgICAgICAgICAgICBwID0gdGhpcy5jb25zdHJ1Y3RQYXJzZUVycm9ySW5mbyhlcnJTdHIsIG51bGwsIGV4cGVjdGVkLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IHRoaXMucGFyc2VFcnJvcihwLmVyclN0ciwgcCwgdGhpcy5KaXNvblBhcnNlckVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIH1cblxuXG5cblxuXG5cblxuXG5cblxuICAgICAgICAgICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIGNhdGNoIG1pc2MuIHBhcnNlIGZhaWx1cmVzOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHNob3VsZG4ndCBoYXBwZW4sIHVubGVzcyByZXNvbHZlIGRlZmF1bHRzIGFyZSBvZmZcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHRoaXMuY29uc3RydWN0UGFyc2VFcnJvckluZm8oJ1BhcnNlIEVycm9yOiBtdWx0aXBsZSBhY3Rpb25zIHBvc3NpYmxlIGF0IHN0YXRlOiAnICsgc3RhdGUgKyAnLCB0b2tlbjogJyArIHN5bWJvbCwgbnVsbCwgbnVsbCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSB0aGlzLnBhcnNlRXJyb3IocC5lcnJTdHIsIHAsIHRoaXMuSmlzb25QYXJzZXJFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBbm90aGVyIGNhc2Ugb2YgYmV0dGVyIHNhZmUgdGhhbiBzb3JyeTogaW4gY2FzZSBzdGF0ZSB0cmFuc2l0aW9ucyBjb21lIG91dCBvZiBhbm90aGVyIGVycm9yIHJlY292ZXJ5IHByb2Nlc3NcbiAgICAgICAgICAgICAgICAvLyBvciBhIGJ1Z2d5IExVVCAoTG9va1VwIFRhYmxlKTpcbiAgICAgICAgICAgICAgICBwID0gdGhpcy5jb25zdHJ1Y3RQYXJzZUVycm9ySW5mbygnUGFyc2luZyBoYWx0ZWQuIE5vIHZpYWJsZSBlcnJvciByZWNvdmVyeSBhcHByb2FjaCBhdmFpbGFibGUgZHVlIHRvIGludGVybmFsIHN5c3RlbSBmYWlsdXJlLicsIG51bGwsIG51bGwsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICByZXR2YWwgPSB0aGlzLnBhcnNlRXJyb3IocC5lcnJTdHIsIHAsIHRoaXMuSmlzb25QYXJzZXJFcnJvcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIC8vIHNoaWZ0OlxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHN0YWNrW3NwXSA9IHN5bWJvbDtcbiAgICAgICAgICAgICAgICB2c3RhY2tbc3BdID0gbGV4ZXIueXl0ZXh0O1xuICAgICAgICAgICAgICAgIGxzdGFja1tzcF0gPSBjb3B5X3l5bGxvYyhsZXhlci55eWxsb2MpO1xuICAgICAgICAgICAgICAgIHNzdGFja1tzcF0gPSBuZXdTdGF0ZTsgLy8gcHVzaCBzdGF0ZVxuXG4gICAgICAgICAgICAgICAgKytzcDtcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSAwO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUGljayB1cCB0aGUgbGV4ZXIgZGV0YWlscyBmb3IgdGhlIGN1cnJlbnQgc3ltYm9sIGFzIHRoYXQgb25lIGlzIG5vdCAnbG9vay1haGVhZCcgYW55IG1vcmU6XG5cblxuXG4gICAgICAgICAgICAgICAgICAgIHl5bG9jID0gbGV4ZXIueXlsbG9jO1xuXG5cblxuXG5cblxuICAgICAgICAgICAgICAgIFxuXG5cblxuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vIHJlZHVjZTpcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICB0aGlzX3Byb2R1Y3Rpb24gPSB0aGlzLnByb2R1Y3Rpb25zX1tuZXdTdGF0ZSAtIDFdOyAgLy8gYHRoaXMucHJvZHVjdGlvbnNfW11gIGlzIHplcm8tYmFzZWQgaW5kZXhlZCB3aGlsZSBzdGF0ZXMgc3RhcnQgZnJvbSAxIHVwd2FyZHMuLi5cbiAgICAgICAgICAgICAgICB5eXJ1bGVsZW4gPSB0aGlzX3Byb2R1Y3Rpb25bMV07XG5cblxuXG5cblxuXG5cblxuXG5cbiAgICAgICAgICAgICAgICByID0gdGhpcy5wZXJmb3JtQWN0aW9uLmNhbGwoeXl2YWwsIHl5bG9jLCBuZXdTdGF0ZSwgc3AgLSAxLCB2c3RhY2ssIGxzdGFjayk7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IHI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHBvcCBvZmYgc3RhY2tcbiAgICAgICAgICAgICAgICBzcCAtPSB5eXJ1bGVsZW47XG5cbiAgICAgICAgICAgICAgICAvLyBkb24ndCBvdmVyd3JpdGUgdGhlIGBzeW1ib2xgIHZhcmlhYmxlOiB1c2UgYSBsb2NhbCB2YXIgdG8gc3BlZWQgdGhpbmdzIHVwOlxuICAgICAgICAgICAgICAgIHZhciBudHN5bWJvbCA9IHRoaXNfcHJvZHVjdGlvblswXTsgICAgLy8gcHVzaCBub250ZXJtaW5hbCAocmVkdWNlKVxuICAgICAgICAgICAgICAgIHN0YWNrW3NwXSA9IG50c3ltYm9sO1xuICAgICAgICAgICAgICAgIHZzdGFja1tzcF0gPSB5eXZhbC4kO1xuICAgICAgICAgICAgICAgIGxzdGFja1tzcF0gPSB5eXZhbC5fJDtcbiAgICAgICAgICAgICAgICAvLyBnb3RvIG5ldyBzdGF0ZSA9IHRhYmxlW1NUQVRFXVtOT05URVJNSU5BTF1cbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHRhYmxlW3NzdGFja1tzcCAtIDFdXVtudHN5bWJvbF07XG4gICAgICAgICAgICAgICAgc3N0YWNrW3NwXSA9IG5ld1N0YXRlO1xuICAgICAgICAgICAgICAgICsrc3A7XG5cblxuXG5cblxuXG5cblxuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vIGFjY2VwdDpcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR2YWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIFJldHVybiB0aGUgYCRhY2NlcHRgIHJ1bGUncyBgJCRgIHJlc3VsdCwgaWYgYXZhaWxhYmxlLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gQWxzbyBub3RlIHRoYXQgSklTT04gYWx3YXlzIGFkZHMgdGhpcyB0b3AtbW9zdCBgJGFjY2VwdGAgcnVsZSAod2l0aCBpbXBsaWNpdCxcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0LCBhY3Rpb24pOlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gICAgICRhY2NlcHQ6IDxzdGFydFN5bWJvbD4gJGVuZFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgJXsgJCQgPSAkMTsgQCQgPSBAMTsgJX1cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIHdoaWNoLCBjb21iaW5lZCB3aXRoIHRoZSBwYXJzZSBrZXJuZWwncyBgJGFjY2VwdGAgc3RhdGUgYmVoYXZpb3VyIGNvZGVkIGJlbG93LFxuICAgICAgICAgICAgICAgIC8vIHdpbGwgcHJvZHVjZSB0aGUgYCQkYCB2YWx1ZSBvdXRwdXQgb2YgdGhlIDxzdGFydFN5bWJvbD4gcnVsZSBhcyB0aGUgcGFyc2UgcmVzdWx0LFxuICAgICAgICAgICAgICAgIC8vIElGRiB0aGF0IHJlc3VsdCBpcyAqbm90KiBgdW5kZWZpbmVkYC4gKFNlZSBhbHNvIHRoZSBwYXJzZXIga2VybmVsIGNvZGUuKVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gSW4gY29kZTpcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgJXtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICBAJCA9IEAxOyAgICAgICAgICAgIC8vIGlmIGxvY2F0aW9uIHRyYWNraW5nIHN1cHBvcnQgaXMgaW5jbHVkZWRcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mICQxICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQxO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7ICAgICAgICAgICAvLyB0aGUgZGVmYXVsdCBwYXJzZSByZXN1bHQgaWYgdGhlIHJ1bGUgYWN0aW9ucyBkb24ndCBwcm9kdWNlIGFueXRoaW5nXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAlfVxuICAgICAgICAgICAgICAgIHNwLS07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2c3RhY2tbc3BdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSB2c3RhY2tbc3BdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBicmVhayBvdXQgb2YgbG9vcDogd2UgYWNjZXB0IG9yIGZhaWwgd2l0aCBlcnJvclxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAvLyByZXBvcnQgZXhjZXB0aW9ucyB0aHJvdWdoIHRoZSBwYXJzZUVycm9yIGNhbGxiYWNrIHRvbywgYnV0IGtlZXAgdGhlIGV4Y2VwdGlvbiBpbnRhY3RcbiAgICAgICAgLy8gaWYgaXQgaXMgYSBrbm93biBwYXJzZXIgb3IgbGV4ZXIgZXJyb3Igd2hpY2ggaGFzIGJlZW4gdGhyb3duIGJ5IHBhcnNlRXJyb3IoKSBhbHJlYWR5OlxuICAgICAgICBpZiAoZXggaW5zdGFuY2VvZiB0aGlzLkppc29uUGFyc2VyRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGV4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxleGVyICYmIHR5cGVvZiBsZXhlci5KaXNvbkxleGVyRXJyb3IgPT09ICdmdW5jdGlvbicgJiYgZXggaW5zdGFuY2VvZiBsZXhlci5KaXNvbkxleGVyRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGV4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcCA9IHRoaXMuY29uc3RydWN0UGFyc2VFcnJvckluZm8oJ1BhcnNpbmcgYWJvcnRlZCBkdWUgdG8gZXhjZXB0aW9uLicsIGV4LCBudWxsLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR2YWwgPSB0aGlzLnBhcnNlRXJyb3IocC5lcnJTdHIsIHAsIHRoaXMuSmlzb25QYXJzZXJFcnJvcik7XG4gICAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgICByZXR2YWwgPSB0aGlzLmNsZWFudXBBZnRlclBhcnNlKHJldHZhbCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX19yZWVudHJhbnRfY2FsbF9kZXB0aC0tO1xuICAgIH0gICAvLyAvZmluYWxseVxuXG4gICAgcmV0dXJuIHJldHZhbDtcbn1cbn07XG5wYXJzZXIub3JpZ2luYWxQYXJzZUVycm9yID0gcGFyc2VyLnBhcnNlRXJyb3I7XG5wYXJzZXIub3JpZ2luYWxRdW90ZU5hbWUgPSBwYXJzZXIucXVvdGVOYW1lO1xuXG5cbi8qIGxleGVyIGdlbmVyYXRlZCBieSBqaXNvbi1sZXggMC42LjEtMjAzICovXG5cbi8qXG4gKiBSZXR1cm5zIGEgTGV4ZXIgb2JqZWN0IG9mIHRoZSBmb2xsb3dpbmcgc3RydWN0dXJlOlxuICpcbiAqICBMZXhlcjoge1xuICogICAgeXk6IHt9ICAgICBUaGUgc28tY2FsbGVkIFwic2hhcmVkIHN0YXRlXCIgb3IgcmF0aGVyIHRoZSAqc291cmNlKiBvZiBpdDtcbiAqICAgICAgICAgICAgICAgdGhlIHJlYWwgXCJzaGFyZWQgc3RhdGVcIiBgeXlgIHBhc3NlZCBhcm91bmQgdG9cbiAqICAgICAgICAgICAgICAgdGhlIHJ1bGUgYWN0aW9ucywgZXRjLiBpcyBhIGRpcmVjdCByZWZlcmVuY2UhXG4gKlxuICogICAgICAgICAgICAgICBUaGlzIFwic2hhcmVkIGNvbnRleHRcIiBvYmplY3Qgd2FzIHBhc3NlZCB0byB0aGUgbGV4ZXIgYnkgd2F5IG9mIFxuICogICAgICAgICAgICAgICB0aGUgYGxleGVyLnNldElucHV0KHN0ciwgeXkpYCBBUEkgYmVmb3JlIHlvdSBtYXkgdXNlIGl0LlxuICpcbiAqICAgICAgICAgICAgICAgVGhpcyBcInNoYXJlZCBjb250ZXh0XCIgb2JqZWN0IGlzIHBhc3NlZCB0byB0aGUgbGV4ZXIgYWN0aW9uIGNvZGUgaW4gYHBlcmZvcm1BY3Rpb24oKWBcbiAqICAgICAgICAgICAgICAgc28gdXNlcmxhbmQgY29kZSBpbiB0aGUgbGV4ZXIgYWN0aW9ucyBtYXkgY29tbXVuaWNhdGUgd2l0aCB0aGUgb3V0c2lkZSB3b3JsZCBcbiAqICAgICAgICAgICAgICAgYW5kL29yIG90aGVyIGxleGVyIHJ1bGVzJyBhY3Rpb25zIGluIG1vcmUgb3IgbGVzcyBjb21wbGV4IHdheXMuXG4gKlxuICogIH1cbiAqXG4gKiAgTGV4ZXIucHJvdG90eXBlOiB7XG4gKiAgICBFT0Y6IDEsXG4gKiAgICBFUlJPUjogMixcbiAqXG4gKiAgICB5eTogICAgICAgIFRoZSBvdmVyYWxsIFwic2hhcmVkIGNvbnRleHRcIiBvYmplY3QgcmVmZXJlbmNlLlxuICpcbiAqICAgIEppc29uTGV4ZXJFcnJvcjogZnVuY3Rpb24obXNnLCBoYXNoKSxcbiAqXG4gKiAgICBwZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBsZXhlcl9fcGVyZm9ybUFjdGlvbih5eSwgeXlydWxlbnVtYmVyLCBZWV9TVEFSVCksXG4gKlxuICogICAgICAgICAgICAgICBUaGUgZnVuY3Rpb24gcGFyYW1ldGVycyBhbmQgYHRoaXNgIGhhdmUgdGhlIGZvbGxvd2luZyB2YWx1ZS9tZWFuaW5nOlxuICogICAgICAgICAgICAgICAtIGB0aGlzYCAgICA6IHJlZmVyZW5jZSB0byB0aGUgYGxleGVyYCBpbnN0YW5jZS4gXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgeXlfYCBpcyBhbiBhbGlhcyBmb3IgYHRoaXNgIGxleGVyIGluc3RhbmNlIHJlZmVyZW5jZSB1c2VkIGludGVybmFsbHkuXG4gKlxuICogICAgICAgICAgICAgICAtIGB5eWAgICAgICA6IGEgcmVmZXJlbmNlIHRvIHRoZSBgeXlgIFwic2hhcmVkIHN0YXRlXCIgb2JqZWN0IHdoaWNoIHdhcyBwYXNzZWQgdG8gdGhlIGxleGVyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnkgd2F5IG9mIHRoZSBgbGV4ZXIuc2V0SW5wdXQoc3RyLCB5eSlgIEFQSSBiZWZvcmUuXG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5vdGU6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGV4dHJhIGFyZ3VtZW50cyB5b3Ugc3BlY2lmaWVkIGluIHRoZSBgJXBhcnNlLXBhcmFtYCBzdGF0ZW1lbnQgaW4geW91clxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICoqcGFyc2VyKiogZ3JhbW1hciBkZWZpbml0aW9uIGZpbGUgYXJlIHBhc3NlZCB0byB0aGUgbGV4ZXIgdmlhIHRoaXMgb2JqZWN0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlIGFzIG1lbWJlciB2YXJpYWJsZXMuXG4gKlxuICogICAgICAgICAgICAgICAtIGB5eXJ1bGVudW1iZXJgICAgOiBpbmRleCBvZiB0aGUgbWF0Y2hlZCBsZXhlciBydWxlIChyZWdleCksIHVzZWQgaW50ZXJuYWxseS5cbiAqXG4gKiAgICAgICAgICAgICAgIC0gYFlZX1NUQVJUYDogdGhlIGN1cnJlbnQgbGV4ZXIgXCJzdGFydCBjb25kaXRpb25cIiBzdGF0ZS5cbiAqXG4gKiAgICBwYXJzZUVycm9yOiBmdW5jdGlvbihzdHIsIGhhc2gsIEV4Y2VwdGlvbkNsYXNzKSxcbiAqXG4gKiAgICBjb25zdHJ1Y3RMZXhFcnJvckluZm86IGZ1bmN0aW9uKGVycm9yX21lc3NhZ2UsIGlzX3JlY292ZXJhYmxlKSxcbiAqICAgICAgICAgICAgICAgSGVscGVyIGZ1bmN0aW9uLlxuICogICAgICAgICAgICAgICBQcm9kdWNlcyBhIG5ldyBlcnJvckluZm8gJ2hhc2ggb2JqZWN0JyB3aGljaCBjYW4gYmUgcGFzc2VkIGludG8gYHBhcnNlRXJyb3IoKWAuXG4gKiAgICAgICAgICAgICAgIFNlZSBpdCdzIHVzZSBpbiB0aGlzIGxleGVyIGtlcm5lbCBpbiBtYW55IHBsYWNlczsgZXhhbXBsZSB1c2FnZTpcbiAqXG4gKiAgICAgICAgICAgICAgICAgICB2YXIgaW5mb09iaiA9IGxleGVyLmNvbnN0cnVjdFBhcnNlRXJyb3JJbmZvKCdmYWlsIScsIHRydWUpO1xuICogICAgICAgICAgICAgICAgICAgdmFyIHJldFZhbCA9IGxleGVyLnBhcnNlRXJyb3IoaW5mb09iai5lcnJTdHIsIGluZm9PYmosIGxleGVyLkppc29uTGV4ZXJFcnJvcik7XG4gKlxuICogICAgb3B0aW9uczogeyAuLi4gbGV4ZXIgJW9wdGlvbnMgLi4uIH0sXG4gKlxuICogICAgbGV4OiBmdW5jdGlvbigpLFxuICogICAgICAgICAgICAgICBQcm9kdWNlIG9uZSB0b2tlbiBvZiBsZXhlZCBpbnB1dCwgd2hpY2ggd2FzIHBhc3NlZCBpbiBlYXJsaWVyIHZpYSB0aGUgYGxleGVyLnNldElucHV0KClgIEFQSS5cbiAqICAgICAgICAgICAgICAgWW91IE1BWSB1c2UgdGhlIGFkZGl0aW9uYWwgYGFyZ3MuLi5gIHBhcmFtZXRlcnMgYXMgcGVyIGAlcGFyc2UtcGFyYW1gIHNwZWMgb2YgdGhlICoqbGV4ZXIqKiBncmFtbWFyOlxuICogICAgICAgICAgICAgICB0aGVzZSBleHRyYSBgYXJncy4uLmAgYXJlIGFkZGVkIHZlcmJhdGltIHRvIHRoZSBgeXlgIG9iamVjdCByZWZlcmVuY2UgYXMgbWVtYmVyIHZhcmlhYmxlcy5cbiAqXG4gKiAgICAgICAgICAgICAgIFdBUk5JTkc6XG4gKiAgICAgICAgICAgICAgIExleGVyJ3MgYWRkaXRpb25hbCBgYXJncy4uLmAgcGFyYW1ldGVycyAodmlhIGxleGVyJ3MgYCVwYXJzZS1wYXJhbWApIE1BWSBjb25mbGljdCB3aXRoXG4gKiAgICAgICAgICAgICAgIGFueSBhdHRyaWJ1dGVzIGFscmVhZHkgYWRkZWQgdG8gYHl5YCBieSB0aGUgKipwYXJzZXIqKiBvciB0aGUgamlzb24gcnVuLXRpbWU7IFxuICogICAgICAgICAgICAgICB3aGVuIHN1Y2ggYSBjb2xsaXNpb24gaXMgZGV0ZWN0ZWQgYW4gZXhjZXB0aW9uIGlzIHRocm93biB0byBwcmV2ZW50IHRoZSBnZW5lcmF0ZWQgcnVuLXRpbWUgXG4gKiAgICAgICAgICAgICAgIGZyb20gc2lsZW50bHkgYWNjZXB0aW5nIHRoaXMgY29uZnVzaW5nIGFuZCBwb3RlbnRpYWxseSBoYXphcmRvdXMgc2l0dWF0aW9uISBcbiAqXG4gKiAgICBjbGVhbnVwQWZ0ZXJMZXg6IGZ1bmN0aW9uKGRvX25vdF9udWtlX2Vycm9yaW5mb3MpLFxuICogICAgICAgICAgICAgICBIZWxwZXIgZnVuY3Rpb24uXG4gKlxuICogICAgICAgICAgICAgICBUaGlzIGhlbHBlciBBUEkgaXMgaW52b2tlZCB3aGVuIHRoZSAqKnBhcnNlIHByb2Nlc3MqKiBoYXMgY29tcGxldGVkOiBpdCBpcyB0aGUgcmVzcG9uc2liaWxpdHlcbiAqICAgICAgICAgICAgICAgb2YgdGhlICoqcGFyc2VyKiogKG9yIHRoZSBjYWxsaW5nIHVzZXJsYW5kIGNvZGUpIHRvIGludm9rZSB0aGlzIG1ldGhvZCBvbmNlIGNsZWFudXAgaXMgZGVzaXJlZC4gXG4gKlxuICogICAgICAgICAgICAgICBUaGlzIGhlbHBlciBtYXkgYmUgaW52b2tlZCBieSB1c2VyIGNvZGUgdG8gZW5zdXJlIHRoZSBpbnRlcm5hbCBsZXhlciBnZXRzIHByb3Blcmx5IGdhcmJhZ2UgY29sbGVjdGVkLlxuICpcbiAqICAgIHNldElucHV0OiBmdW5jdGlvbihpbnB1dCwgW3l5XSksXG4gKlxuICpcbiAqICAgIGlucHV0OiBmdW5jdGlvbigpLFxuICpcbiAqXG4gKiAgICB1bnB1dDogZnVuY3Rpb24oc3RyKSxcbiAqXG4gKlxuICogICAgbW9yZTogZnVuY3Rpb24oKSxcbiAqXG4gKlxuICogICAgcmVqZWN0OiBmdW5jdGlvbigpLFxuICpcbiAqXG4gKiAgICBsZXNzOiBmdW5jdGlvbihuKSxcbiAqXG4gKlxuICogICAgcGFzdElucHV0OiBmdW5jdGlvbihuKSxcbiAqXG4gKlxuICogICAgdXBjb21pbmdJbnB1dDogZnVuY3Rpb24obiksXG4gKlxuICpcbiAqICAgIHNob3dQb3NpdGlvbjogZnVuY3Rpb24oKSxcbiAqXG4gKlxuICogICAgdGVzdF9tYXRjaDogZnVuY3Rpb24ocmVnZXhfbWF0Y2hfYXJyYXksIHJ1bGVfaW5kZXgpLFxuICpcbiAqXG4gKiAgICBuZXh0OiBmdW5jdGlvbigpLFxuICpcbiAqXG4gKiAgICBiZWdpbjogZnVuY3Rpb24oY29uZGl0aW9uKSxcbiAqXG4gKlxuICogICAgcHVzaFN0YXRlOiBmdW5jdGlvbihjb25kaXRpb24pLFxuICpcbiAqXG4gKiAgICBwb3BTdGF0ZTogZnVuY3Rpb24oKSxcbiAqXG4gKlxuICogICAgdG9wU3RhdGU6IGZ1bmN0aW9uKCksXG4gKlxuICpcbiAqICAgIF9jdXJyZW50UnVsZXM6IGZ1bmN0aW9uKCksXG4gKlxuICpcbiAqICAgIHN0YXRlU3RhY2tTaXplOiBmdW5jdGlvbigpLFxuICpcbiAqXG4gKiAgICBwZXJmb3JtQWN0aW9uOiBmdW5jdGlvbih5eSwgeXlfLCB5eXJ1bGVudW1iZXIsIFlZX1NUQVJUKSxcbiAqXG4gKlxuICogICAgcnVsZXM6IFsuLi5dLFxuICpcbiAqXG4gKiAgICBjb25kaXRpb25zOiB7YXNzb2NpYXRpdmUgbGlzdDogbmFtZSA9PT4gc2V0fSxcbiAqICB9XG4gKlxuICpcbiAqICB0b2tlbiBsb2NhdGlvbiBpbmZvIChgeXlsbG9jYCk6IHtcbiAqICAgIGZpcnN0X2xpbmU6IG4sXG4gKiAgICBsYXN0X2xpbmU6IG4sXG4gKiAgICBmaXJzdF9jb2x1bW46IG4sXG4gKiAgICBsYXN0X2NvbHVtbjogbixcbiAqICAgIHJhbmdlOiBbc3RhcnRfbnVtYmVyLCBlbmRfbnVtYmVyXVxuICogICAgICAgICAgICAgICAod2hlcmUgdGhlIG51bWJlcnMgYXJlIGluZGV4ZXMgaW50byB0aGUgaW5wdXQgc3RyaW5nLCB6ZXJvLWJhc2VkKVxuICogIH1cbiAqXG4gKiAtLS1cbiAqXG4gKiBUaGUgYHBhcnNlRXJyb3JgIGZ1bmN0aW9uIHJlY2VpdmVzIGEgJ2hhc2gnIG9iamVjdCB3aXRoIHRoZXNlIG1lbWJlcnMgZm9yIGxleGVyIGVycm9yczpcbiAqXG4gKiAge1xuICogICAgdGV4dDogICAgICAgIChtYXRjaGVkIHRleHQpXG4gKiAgICB0b2tlbjogICAgICAgKHRoZSBwcm9kdWNlZCB0ZXJtaW5hbCB0b2tlbiwgaWYgYW55KVxuICogICAgdG9rZW5faWQ6ICAgICh0aGUgcHJvZHVjZWQgdGVybWluYWwgdG9rZW4gbnVtZXJpYyBJRCwgaWYgYW55KVxuICogICAgbGluZTogICAgICAgICh5eWxpbmVubylcbiAqICAgIGxvYzogICAgICAgICAoeXlsbG9jKVxuICogICAgcmVjb3ZlcmFibGU6IChib29sZWFuOiBUUlVFIHdoZW4gdGhlIHBhcnNlciBNQVkgaGF2ZSBhbiBlcnJvciByZWNvdmVyeSBydWxlXG4gKiAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZSBmb3IgdGhpcyBwYXJ0aWN1bGFyIGVycm9yKVxuICogICAgeXk6ICAgICAgICAgIChvYmplY3Q6IHRoZSBjdXJyZW50IHBhcnNlciBpbnRlcm5hbCBcInNoYXJlZCBzdGF0ZVwiIGB5eWBcbiAqICAgICAgICAgICAgICAgICAgYXMgaXMgYWxzbyBhdmFpbGFibGUgaW4gdGhlIHJ1bGUgYWN0aW9uczsgdGhpcyBjYW4gYmUgdXNlZCxcbiAqICAgICAgICAgICAgICAgICAgZm9yIGluc3RhbmNlLCBmb3IgYWR2YW5jZWQgZXJyb3IgYW5hbHlzaXMgYW5kIHJlcG9ydGluZylcbiAqICAgIGxleGVyOiAgICAgICAocmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGxleGVyIGluc3RhbmNlIHVzZWQgYnkgdGhlIHBhcnNlcilcbiAqICB9XG4gKlxuICogd2hpbGUgYHRoaXNgIHdpbGwgcmVmZXJlbmNlIHRoZSBjdXJyZW50IGxleGVyIGluc3RhbmNlLlxuICpcbiAqIFdoZW4gYHBhcnNlRXJyb3JgIGlzIGludm9rZWQgYnkgdGhlIGxleGVyLCB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiB3aWxsXG4gKiBhdHRlbXB0IHRvIGludm9rZSBgeXkucGFyc2VyLnBhcnNlRXJyb3IoKWA7IHdoZW4gdGhpcyBjYWxsYmFjayBpcyBub3QgcHJvdmlkZWRcbiAqIGl0IHdpbGwgdHJ5IHRvIGludm9rZSBgeXkucGFyc2VFcnJvcigpYCBpbnN0ZWFkLiBXaGVuIHRoYXQgY2FsbGJhY2sgaXMgYWxzbyBub3RcbiAqIHByb3ZpZGVkLCBhIGBKaXNvbkxleGVyRXJyb3JgIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93biBjb250YWluaW5nIHRoZSBlcnJvclxuICogbWVzc2FnZSBhbmQgYGhhc2hgLCBhcyBjb25zdHJ1Y3RlZCBieSB0aGUgYGNvbnN0cnVjdExleEVycm9ySW5mbygpYCBBUEkuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBsZXhlcidzIGBKaXNvbkxleGVyRXJyb3JgIGVycm9yIGNsYXNzIGlzIHBhc3NlZCB2aWEgdGhlXG4gKiBgRXhjZXB0aW9uQ2xhc3NgIGFyZ3VtZW50LCB3aGljaCBpcyBpbnZva2VkIHRvIGNvbnN0cnVjdCB0aGUgZXhjZXB0aW9uXG4gKiBpbnN0YW5jZSB0byBiZSB0aHJvd24sIHNvIHRlY2huaWNhbGx5IGBwYXJzZUVycm9yYCB3aWxsIHRocm93IHRoZSBvYmplY3RcbiAqIHByb2R1Y2VkIGJ5IHRoZSBgbmV3IEV4Y2VwdGlvbkNsYXNzKHN0ciwgaGFzaClgIEphdmFTY3JpcHQgZXhwcmVzc2lvbi5cbiAqXG4gKiAtLS1cbiAqXG4gKiBZb3UgY2FuIHNwZWNpZnkgbGV4ZXIgb3B0aW9ucyBieSBzZXR0aW5nIC8gbW9kaWZ5aW5nIHRoZSBgLm9wdGlvbnNgIG9iamVjdCBvZiB5b3VyIExleGVyIGluc3RhbmNlLlxuICogVGhlc2Ugb3B0aW9ucyBhcmUgYXZhaWxhYmxlOlxuICpcbiAqIChPcHRpb25zIGFyZSBwZXJtYW5lbnQuKVxuICogIFxuICogIHl5OiB7XG4gKiAgICAgIHBhcnNlRXJyb3I6IGZ1bmN0aW9uKHN0ciwgaGFzaCwgRXhjZXB0aW9uQ2xhc3MpXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IG92ZXJyaWRlcyB0aGUgZGVmYXVsdCBgcGFyc2VFcnJvcmAgZnVuY3Rpb24uXG4gKiAgfVxuICpcbiAqICBsZXhlci5vcHRpb25zOiB7XG4gKiAgICAgIHByZV9sZXg6ICBmdW5jdGlvbigpXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IGlzIGludm9rZWQgYmVmb3JlIHRoZSBsZXhlciBpcyBpbnZva2VkIHRvIHByb2R1Y2UgYW5vdGhlciB0b2tlbi5cbiAqICAgICAgICAgICAgICAgICBgdGhpc2AgcmVmZXJzIHRvIHRoZSBMZXhlciBvYmplY3QuXG4gKiAgICAgIHBvc3RfbGV4OiBmdW5jdGlvbih0b2tlbikgeyByZXR1cm4gdG9rZW47IH1cbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogaXMgaW52b2tlZCB3aGVuIHRoZSBsZXhlciBoYXMgcHJvZHVjZWQgYSB0b2tlbiBgdG9rZW5gO1xuICogICAgICAgICAgICAgICAgIHRoaXMgZnVuY3Rpb24gY2FuIG92ZXJyaWRlIHRoZSByZXR1cm5lZCB0b2tlbiB2YWx1ZSBieSByZXR1cm5pbmcgYW5vdGhlci5cbiAqICAgICAgICAgICAgICAgICBXaGVuIGl0IGRvZXMgbm90IHJldHVybiBhbnkgKHRydXRoeSkgdmFsdWUsIHRoZSBsZXhlciB3aWxsIHJldHVyblxuICogICAgICAgICAgICAgICAgIHRoZSBvcmlnaW5hbCBgdG9rZW5gLlxuICogICAgICAgICAgICAgICAgIGB0aGlzYCByZWZlcnMgdG8gdGhlIExleGVyIG9iamVjdC5cbiAqXG4gKiBXQVJOSU5HOiB0aGUgbmV4dCBzZXQgb2Ygb3B0aW9ucyBhcmUgbm90IG1lYW50IHRvIGJlIGNoYW5nZWQuIFRoZXkgZWNobyB0aGUgYWJpbGl0aWVzIG9mXG4gKiB0aGUgbGV4ZXIgYXMgcGVyIHdoZW4gaXQgd2FzIGNvbXBpbGVkIVxuICpcbiAqICAgICAgcmFuZ2VzOiBib29sZWFuXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IGB0cnVlYCA9PT4gdG9rZW4gbG9jYXRpb24gaW5mbyB3aWxsIGluY2x1ZGUgYSAucmFuZ2VbXSBtZW1iZXIuXG4gKiAgICAgIGZsZXg6IGJvb2xlYW5cbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogYHRydWVgID09PiBmbGV4LWxpa2UgbGV4aW5nIGJlaGF2aW91ciB3aGVyZSB0aGUgcnVsZXMgYXJlIHRlc3RlZFxuICogICAgICAgICAgICAgICAgIGV4aGF1c3RpdmVseSB0byBmaW5kIHRoZSBsb25nZXN0IG1hdGNoLlxuICogICAgICBiYWNrdHJhY2tfbGV4ZXI6IGJvb2xlYW5cbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogYHRydWVgID09PiBsZXhlciByZWdleGVzIGFyZSB0ZXN0ZWQgaW4gb3JkZXIgYW5kIGZvciBpbnZva2VkO1xuICogICAgICAgICAgICAgICAgIHRoZSBsZXhlciB0ZXJtaW5hdGVzIHRoZSBzY2FuIHdoZW4gYSB0b2tlbiBpcyByZXR1cm5lZCBieSB0aGUgYWN0aW9uIGNvZGUuXG4gKiAgICAgIHhyZWdleHA6IGJvb2xlYW5cbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogYHRydWVgID09PiBsZXhlciBydWxlIHJlZ2V4ZXMgYXJlIFwiZXh0ZW5kZWQgcmVnZXggZm9ybWF0XCIgcmVxdWlyaW5nIHRoZVxuICogICAgICAgICAgICAgICAgIGBYUmVnRXhwYCBsaWJyYXJ5LiBXaGVuIHRoaXMgJW9wdGlvbiBoYXMgbm90IGJlZW4gc3BlY2lmaWVkIGF0IGNvbXBpbGUgdGltZSwgYWxsIGxleGVyXG4gKiAgICAgICAgICAgICAgICAgcnVsZSByZWdleGVzIGhhdmUgYmVlbiB3cml0dGVuIGFzIHN0YW5kYXJkIEphdmFTY3JpcHQgUmVnRXhwIGV4cHJlc3Npb25zLlxuICogIH1cbiAqL1xuXG5cbnZhciBsZXhlciA9IGZ1bmN0aW9uKCkge1xuICAvKipcbiAgICogU2VlIGFsc286XG4gICAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTM4MjEwNy93aGF0cy1hLWdvb2Qtd2F5LXRvLWV4dGVuZC1lcnJvci1pbi1qYXZhc2NyaXB0LyMzNTg4MTUwOFxuICAgKiBidXQgd2Uga2VlcCB0aGUgcHJvdG90eXBlLmNvbnN0cnVjdG9yIGFuZCBwcm90b3R5cGUubmFtZSBhc3NpZ25tZW50IGxpbmVzIHRvbyBmb3IgY29tcGF0aWJpbGl0eVxuICAgKiB3aXRoIHVzZXJsYW5kIGNvZGUgd2hpY2ggbWlnaHQgYWNjZXNzIHRoZSBkZXJpdmVkIGNsYXNzIGluIGEgJ2NsYXNzaWMnIHdheS5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKiBAY29uc3RydWN0b3JcbiAgICogQG5vY29sbGFwc2VcbiAgICovXG4gIGZ1bmN0aW9uIEppc29uTGV4ZXJFcnJvcihtc2csIGhhc2gpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ25hbWUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiAnSmlzb25MZXhlckVycm9yJ1xuICAgIH0pO1xuXG4gICAgaWYgKG1zZyA9PSBudWxsKVxuICAgICAgbXNnID0gJz8/Pyc7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ21lc3NhZ2UnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG1zZ1xuICAgIH0pO1xuXG4gICAgdGhpcy5oYXNoID0gaGFzaDtcbiAgICB2YXIgc3RhY2t0cmFjZTtcblxuICAgIGlmIChoYXNoICYmIGhhc2guZXhjZXB0aW9uIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHZhciBleDIgPSBoYXNoLmV4Y2VwdGlvbjtcbiAgICAgIHRoaXMubWVzc2FnZSA9IGV4Mi5tZXNzYWdlIHx8IG1zZztcbiAgICAgIHN0YWNrdHJhY2UgPSBleDIuc3RhY2s7XG4gICAgfVxuXG4gICAgaWYgKCFzdGFja3RyYWNlKSB7XG4gICAgICBpZiAoRXJyb3IuaGFzT3duUHJvcGVydHkoJ2NhcHR1cmVTdGFja1RyYWNlJykpIHtcbiAgICAgICAgLy8gVjhcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFja3RyYWNlID0gbmV3IEVycm9yKG1zZykuc3RhY2s7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0YWNrdHJhY2UpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RhY2snLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBzdGFja3RyYWNlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIE9iamVjdC5zZXRQcm90b3R5cGVPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihKaXNvbkxleGVyRXJyb3IucHJvdG90eXBlLCBFcnJvci5wcm90b3R5cGUpO1xuICB9IGVsc2Uge1xuICAgIEppc29uTGV4ZXJFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4gIH1cblxuICBKaXNvbkxleGVyRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSmlzb25MZXhlckVycm9yO1xuICBKaXNvbkxleGVyRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnSmlzb25MZXhlckVycm9yJztcblxuICB2YXIgbGV4ZXIgPSB7XG4gICAgXG4vLyBDb2RlIEdlbmVyYXRvciBJbmZvcm1hdGlvbiBSZXBvcnRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy9cbi8vIE9wdGlvbnM6XG4vL1xuLy8gICBiYWNrdHJhY2tpbmc6IC4uLi4uLi4uLi4uLi4uLi4uLi4uIGZhbHNlXG4vLyAgIGxvY2F0aW9uLnJhbmdlczogLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2Vcbi8vICAgbG9jYXRpb24gbGluZStjb2x1bW4gdHJhY2tpbmc6IC4uLiB0cnVlXG4vL1xuLy9cbi8vIEZvcndhcmRlZCBQYXJzZXIgQW5hbHlzaXMgZmxhZ3M6XG4vL1xuLy8gICB1c2VzIHl5bGVuZzogLi4uLi4uLi4uLi4uLi4uLi4uLi4uIGZhbHNlXG4vLyAgIHVzZXMgeXlsaW5lbm86IC4uLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2Vcbi8vICAgdXNlcyB5eXRleHQ6IC4uLi4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuLy8gICB1c2VzIHl5bGxvYzogLi4uLi4uLi4uLi4uLi4uLi4uLi4uIGZhbHNlXG4vLyAgIHVzZXMgbGV4ZXIgdmFsdWVzOiAuLi4uLi4uLi4uLi4uLi4gdHJ1ZSAvIHRydWVcbi8vICAgbG9jYXRpb24gdHJhY2tpbmc6IC4uLi4uLi4uLi4uLi4uLiB0cnVlXG4vLyAgIGxvY2F0aW9uIGFzc2lnbm1lbnQ6IC4uLi4uLi4uLi4uLi4gdHJ1ZVxuLy9cbi8vXG4vLyBMZXhlciBBbmFseXNpcyBmbGFnczpcbi8vXG4vLyAgIHVzZXMgeXlsZW5nOiAuLi4uLi4uLi4uLi4uLi4uLi4uLi4gPz8/XG4vLyAgIHVzZXMgeXlsaW5lbm86IC4uLi4uLi4uLi4uLi4uLi4uLi4gPz8/XG4vLyAgIHVzZXMgeXl0ZXh0OiAuLi4uLi4uLi4uLi4uLi4uLi4uLi4gPz8/XG4vLyAgIHVzZXMgeXlsbG9jOiAuLi4uLi4uLi4uLi4uLi4uLi4uLi4gPz8/XG4vLyAgIHVzZXMgUGFyc2VFcnJvciBBUEk6IC4uLi4uLi4uLi4uLi4gPz8/XG4vLyAgIHVzZXMgeXllcnJvcjogLi4uLi4uLi4uLi4uLi4uLi4uLi4gPz8/XG4vLyAgIHVzZXMgbG9jYXRpb24gdHJhY2tpbmcgJiBlZGl0aW5nOiAgPz8/XG4vLyAgIHVzZXMgbW9yZSgpIEFQSTogLi4uLi4uLi4uLi4uLi4uLi4gPz8/XG4vLyAgIHVzZXMgdW5wdXQoKSBBUEk6IC4uLi4uLi4uLi4uLi4uLi4gPz8/XG4vLyAgIHVzZXMgcmVqZWN0KCkgQVBJOiAuLi4uLi4uLi4uLi4uLi4gPz8/XG4vLyAgIHVzZXMgbGVzcygpIEFQSTogLi4uLi4uLi4uLi4uLi4uLi4gPz8/XG4vLyAgIHVzZXMgZGlzcGxheSBBUElzIHBhc3RJbnB1dCgpLCB1cGNvbWluZ0lucHV0KCksIHNob3dQb3NpdGlvbigpOlxuLy8gICAgICAgIC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uID8/P1xuLy8gICB1c2VzIGRlc2NyaWJlWVlMTE9DKCkgQVBJOiAuLi4uLi4uID8/P1xuLy9cbi8vIC0tLS0tLS0tLSBFTkQgT0YgUkVQT1JUIC0tLS0tLS0tLS0tXG5cbkVPRjogMSxcbiAgICBFUlJPUjogMixcblxuICAgIC8vIEppc29uTGV4ZXJFcnJvcjogSmlzb25MZXhlckVycm9yLCAgICAgICAgLy8vIDwtLSBpbmplY3RlZCBieSB0aGUgY29kZSBnZW5lcmF0b3JcblxuICAgIC8vIG9wdGlvbnM6IHt9LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vIDwtLSBpbmplY3RlZCBieSB0aGUgY29kZSBnZW5lcmF0b3JcblxuICAgIC8vIHl5OiAuLi4sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vIDwtLSBpbmplY3RlZCBieSBzZXRJbnB1dCgpXG5cbiAgICBfX2N1cnJlbnRSdWxlU2V0X186IG51bGwsICAgICAgICAgICAgICAgICAgIC8vLyBJTlRFUk5BTCBVU0UgT05MWTogaW50ZXJuYWwgcnVsZSBzZXQgY2FjaGUgZm9yIHRoZSBjdXJyZW50IGxleGVyIHN0YXRlICBcblxuICAgIF9fZXJyb3JfaW5mb3M6IFtdLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vIElOVEVSTkFMIFVTRSBPTkxZOiB0aGUgc2V0IG9mIGxleEVycm9ySW5mbyBvYmplY3RzIGNyZWF0ZWQgc2luY2UgdGhlIGxhc3QgY2xlYW51cCAgXG4gICAgX19kZWNvbXByZXNzZWQ6IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAvLy8gSU5URVJOQUwgVVNFIE9OTFk6IG1hcmsgd2hldGhlciB0aGUgbGV4ZXIgaW5zdGFuY2UgaGFzIGJlZW4gJ3VuZm9sZGVkJyBjb21wbGV0ZWx5IGFuZCBpcyBub3cgcmVhZHkgZm9yIHVzZSAgXG4gICAgZG9uZTogZmFsc2UsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8gSU5URVJOQUwgVVNFIE9OTFkgIFxuICAgIF9iYWNrdHJhY2s6IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vIElOVEVSTkFMIFVTRSBPTkxZICBcbiAgICBfaW5wdXQ6ICcnLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLyBJTlRFUk5BTCBVU0UgT05MWSAgXG4gICAgX21vcmU6IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8gSU5URVJOQUwgVVNFIE9OTFkgIFxuICAgIF9zaWduYWxlZF9lcnJvcl90b2tlbjogZmFsc2UsICAgICAgICAgICAgICAgLy8vIElOVEVSTkFMIFVTRSBPTkxZICBcbiAgICBjb25kaXRpb25TdGFjazogW10sICAgICAgICAgICAgICAgICAgICAgICAgIC8vLyBJTlRFUk5BTCBVU0UgT05MWTsgbWFuYWdlZCB2aWEgYHB1c2hTdGF0ZSgpYCwgYHBvcFN0YXRlKClgLCBgdG9wU3RhdGUoKWAgYW5kIGBzdGF0ZVN0YWNrU2l6ZSgpYCAgXG4gICAgbWF0Y2g6ICcnLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8gUkVBRC1PTkxZIEVYVEVSTkFMIEFDQ0VTUyAtIEFEVkFOQ0VEIFVTRSBPTkxZOiB0cmFja3MgaW5wdXQgd2hpY2ggaGFzIGJlZW4gbWF0Y2hlZCBzbyBmYXIgZm9yIHRoZSBsZXhlciB0b2tlbiB1bmRlciBjb25zdHJ1Y3Rpb24uIGBtYXRjaGAgaXMgaWRlbnRpY2FsIHRvIGB5eXRleHRgIGV4Y2VwdCB0aGF0IHRoaXMgb25lIHN0aWxsIGNvbnRhaW5zIHRoZSBtYXRjaGVkIGlucHV0IHN0cmluZyBhZnRlciBgbGV4ZXIucGVyZm9ybUFjdGlvbigpYCBoYXMgYmVlbiBpbnZva2VkLCB3aGVyZSB1c2VybGFuZCBjb2RlIE1BWSBoYXZlIGNoYW5nZWQvcmVwbGFjZWQgdGhlIGB5eXRleHRgIHZhbHVlIGVudGlyZWx5ISAgXG4gICAgbWF0Y2hlZDogJycsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8gUkVBRC1PTkxZIEVYVEVSTkFMIEFDQ0VTUyAtIEFEVkFOQ0VEIFVTRSBPTkxZOiB0cmFja3MgZW50aXJlIGlucHV0IHdoaWNoIGhhcyBiZWVuIG1hdGNoZWQgc28gZmFyICBcbiAgICBtYXRjaGVzOiBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLyBSRUFELU9OTFkgRVhURVJOQUwgQUNDRVNTIC0gQURWQU5DRUQgVVNFIE9OTFk6IHRyYWNrcyBSRSBtYXRjaCByZXN1bHQgZm9yIGxhc3QgKHN1Y2Nlc3NmdWwpIG1hdGNoIGF0dGVtcHQgIFxuICAgIHl5dGV4dDogJycsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vIEFEVkFOQ0VEIFVTRSBPTkxZOiB0cmFja3MgaW5wdXQgd2hpY2ggaGFzIGJlZW4gbWF0Y2hlZCBzbyBmYXIgZm9yIHRoZSBsZXhlciB0b2tlbiB1bmRlciBjb25zdHJ1Y3Rpb247IHRoaXMgdmFsdWUgaXMgdHJhbnNmZXJyZWQgdG8gdGhlIHBhcnNlciBhcyB0aGUgJ3Rva2VuIHZhbHVlJyB3aGVuIHRoZSBwYXJzZXIgY29uc3VtZXMgdGhlIGxleGVyIHRva2VuIHByb2R1Y2VkIHRocm91Z2ggYSBjYWxsIHRvIHRoZSBgbGV4KClgIEFQSS4gIFxuICAgIG9mZnNldDogMCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vIFJFQUQtT05MWSBFWFRFUk5BTCBBQ0NFU1MgLSBBRFZBTkNFRCBVU0UgT05MWTogdHJhY2tzIHRoZSAnY3Vyc29yIHBvc2l0aW9uJyBpbiB0aGUgaW5wdXQgc3RyaW5nLCBpLmUuIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBtYXRjaGVkIHNvIGZhciAgXG4gICAgeXlsZW5nOiAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8gUkVBRC1PTkxZIEVYVEVSTkFMIEFDQ0VTUyAtIEFEVkFOQ0VEIFVTRSBPTkxZOiBsZW5ndGggb2YgbWF0Y2hlZCBpbnB1dCBmb3IgdGhlIHRva2VuIHVuZGVyIGNvbnN0cnVjdGlvbiAoYHl5dGV4dGApICBcbiAgICB5eWxpbmVubzogMCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLyBSRUFELU9OTFkgRVhURVJOQUwgQUNDRVNTIC0gQURWQU5DRUQgVVNFIE9OTFk6ICdsaW5lIG51bWJlcicgYXQgd2hpY2ggdGhlIHRva2VuIHVuZGVyIGNvbnN0cnVjdGlvbiBpcyBsb2NhdGVkICBcbiAgICB5eWxsb2M6IG51bGwsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLyBSRUFELU9OTFkgRVhURVJOQUwgQUNDRVNTIC0gQURWQU5DRUQgVVNFIE9OTFk6IHRyYWNrcyBsb2NhdGlvbiBpbmZvIChsaW5lcyArIGNvbHVtbnMpIGZvciB0aGUgdG9rZW4gdW5kZXIgY29uc3RydWN0aW9uICBcblxuICAgIC8qKlxuICAgICAqIElOVEVSTkFMIFVTRTogY29uc3RydWN0IGEgc3VpdGFibGUgZXJyb3IgaW5mbyBoYXNoIG9iamVjdCBpbnN0YW5jZSBmb3IgYHBhcnNlRXJyb3JgLlxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgY29uc3RydWN0TGV4RXJyb3JJbmZvOiBmdW5jdGlvbiBsZXhlcl9jb25zdHJ1Y3RMZXhFcnJvckluZm8obXNnLCByZWNvdmVyYWJsZSkge1xuICAgICAgLyoqIEBjb25zdHJ1Y3RvciAqL1xuICAgICAgdmFyIHBlaSA9IHtcbiAgICAgICAgZXJyU3RyOiBtc2csXG4gICAgICAgIHJlY292ZXJhYmxlOiAhIXJlY292ZXJhYmxlLFxuICAgICAgICB0ZXh0OiB0aGlzLm1hdGNoLCAgICAgICAgICAgLy8gVGhpcyBvbmUgTUFZIGJlIGVtcHR5OyB1c2VybGFuZCBjb2RlIHNob3VsZCB1c2UgdGhlIGB1cGNvbWluZ0lucHV0YCBBUEkgdG8gb2J0YWluIG1vcmUgdGV4dCB3aGljaCBmb2xsb3dzIHRoZSAnbGV4ZXIgY3Vyc29yIHBvc2l0aW9uJy4uLiAgXG4gICAgICAgIHRva2VuOiBudWxsLFxuICAgICAgICBsaW5lOiB0aGlzLnl5bGluZW5vLFxuICAgICAgICBsb2M6IHRoaXMueXlsbG9jLFxuICAgICAgICB5eTogdGhpcy55eSxcbiAgICAgICAgbGV4ZXI6IHRoaXMsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFuZCBtYWtlIHN1cmUgdGhlIGVycm9yIGluZm8gZG9lc24ndCBzdGF5IGR1ZSB0byBwb3RlbnRpYWxcbiAgICAgICAgICogcmVmIGN5Y2xlIHZpYSB1c2VybGFuZCBjb2RlIG1hbmlwdWxhdGlvbnMuXG4gICAgICAgICAqIFRoZXNlIHdvdWxkIG90aGVyd2lzZSBhbGwgYmUgbWVtb3J5IGxlYWsgb3Bwb3J0dW5pdGllcyFcbiAgICAgICAgICogXG4gICAgICAgICAqIE5vdGUgdGhhdCBvbmx5IGFycmF5IGFuZCBvYmplY3QgcmVmZXJlbmNlcyBhcmUgbnVrZWQgYXMgdGhvc2VcbiAgICAgICAgICogY29uc3RpdHV0ZSB0aGUgc2V0IG9mIGVsZW1lbnRzIHdoaWNoIGNhbiBwcm9kdWNlIGEgY3ljbGljIHJlZi5cbiAgICAgICAgICogVGhlIHJlc3Qgb2YgdGhlIG1lbWJlcnMgaXMga2VwdCBpbnRhY3QgYXMgdGhleSBhcmUgaGFybWxlc3MuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEB0aGlzIHtMZXhFcnJvckluZm99XG4gICAgICAgICAqL1xuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cnVjdExleEVycm9ySW5mbygpIHtcbiAgICAgICAgICAvLyByZW1vdmUgY3ljbGljIHJlZmVyZW5jZXMgYWRkZWQgdG8gZXJyb3IgaW5mbzpcbiAgICAgICAgICAvLyBpbmZvLnl5ID0gbnVsbDtcbiAgICAgICAgICAvLyBpbmZvLmxleGVyID0gbnVsbDtcbiAgICAgICAgICAvLyAuLi5cbiAgICAgICAgICB2YXIgcmVjID0gISF0aGlzLnJlY292ZXJhYmxlO1xuXG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KGtleSkgJiYgdHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgdGhpc1trZXldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMucmVjb3ZlcmFibGUgPSByZWM7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIHRyYWNrIHRoaXMgaW5zdGFuY2Ugc28gd2UgY2FuIGBkZXN0cm95KClgIGl0IG9uY2Ugd2UgZGVlbSBpdCBzdXBlcmZsdW91cyBhbmQgcmVhZHkgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbiFcbiAgICAgIHRoaXMuX19lcnJvcl9pbmZvcy5wdXNoKHBlaSk7XG5cbiAgICAgIHJldHVybiBwZWk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGhhbmRsZXIgd2hpY2ggaXMgaW52b2tlZCB3aGVuIGEgbGV4ZXIgZXJyb3Igb2NjdXJzLlxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgcGFyc2VFcnJvcjogZnVuY3Rpb24gbGV4ZXJfcGFyc2VFcnJvcihzdHIsIGhhc2gsIEV4Y2VwdGlvbkNsYXNzKSB7XG4gICAgICBpZiAoIUV4Y2VwdGlvbkNsYXNzKSB7XG4gICAgICAgIEV4Y2VwdGlvbkNsYXNzID0gdGhpcy5KaXNvbkxleGVyRXJyb3I7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnl5KSB7XG4gICAgICAgIGlmICh0aGlzLnl5LnBhcnNlciAmJiB0eXBlb2YgdGhpcy55eS5wYXJzZXIucGFyc2VFcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiB0aGlzLnl5LnBhcnNlci5wYXJzZUVycm9yLmNhbGwodGhpcywgc3RyLCBoYXNoLCBFeGNlcHRpb25DbGFzcykgfHwgdGhpcy5FUlJPUjtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy55eS5wYXJzZUVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMueXkucGFyc2VFcnJvci5jYWxsKHRoaXMsIHN0ciwgaGFzaCwgRXhjZXB0aW9uQ2xhc3MpIHx8IHRoaXMuRVJST1I7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbkNsYXNzKHN0ciwgaGFzaCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIG1ldGhvZCB3aGljaCBpbXBsZW1lbnRzIGB5eWVycm9yKHN0ciwgLi4uYXJncylgIGZ1bmN0aW9uYWxpdHkgZm9yIHVzZSBpbnNpZGUgbGV4ZXIgYWN0aW9ucy5cbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIHl5ZXJyb3I6IGZ1bmN0aW9uIHl5RXJyb3Ioc3RyIC8qLCAuLi5hcmdzICovKSB7XG4gICAgICB2YXIgbGluZW5vX21zZyA9ICcnO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnRyYWNrUG9zaXRpb24pIHtcbiAgICAgICAgbGluZW5vX21zZyA9ICcgb24gbGluZSAnICsgKHRoaXMueXlsaW5lbm8gKyAxKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHAgPSB0aGlzLmNvbnN0cnVjdExleEVycm9ySW5mbyhcbiAgICAgICAgJ0xleGljYWwgZXJyb3InICsgbGluZW5vX21zZyArICc6ICcgKyBzdHIsXG4gICAgICAgIHRoaXMub3B0aW9ucy5sZXhlckVycm9yc0FyZVJlY292ZXJhYmxlXG4gICAgICApO1xuXG4gICAgICAvLyBBZGQgYW55IGV4dHJhIGFyZ3MgdG8gdGhlIGhhc2ggdW5kZXIgdGhlIG5hbWUgYGV4dHJhX2Vycm9yX2F0dHJpYnV0ZXNgOlxuICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgcC5leHRyYV9lcnJvcl9hdHRyaWJ1dGVzID0gYXJncztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VFcnJvcihwLmVyclN0ciwgcCwgdGhpcy5KaXNvbkxleGVyRXJyb3IpIHx8IHRoaXMuRVJST1I7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGZpbmFsIGNsZWFudXAgZnVuY3Rpb24gZm9yIHdoZW4gd2UgaGF2ZSBjb21wbGV0ZWQgbGV4aW5nIHRoZSBpbnB1dDtcbiAgICAgKiBtYWtlIGl0IGFuIEFQSSBzbyB0aGF0IGV4dGVybmFsIGNvZGUgY2FuIHVzZSB0aGlzIG9uZSBvbmNlIHVzZXJsYW5kXG4gICAgICogY29kZSBoYXMgZGVjaWRlZCBpdCdzIHRpbWUgdG8gZGVzdHJveSBhbnkgbGluZ2VyaW5nIGxleGVyIGVycm9yXG4gICAgICogaGFzaCBvYmplY3QgaW5zdGFuY2VzIGFuZCB0aGUgbGlrZTogdGhpcyBmdW5jdGlvbiBoZWxwcyB0byBjbGVhblxuICAgICAqIHVwIHRoZXNlIGNvbnN0cnVjdHMsIHdoaWNoICptYXkqIGNhcnJ5IGN5Y2xpYyByZWZlcmVuY2VzIHdoaWNoIHdvdWxkXG4gICAgICogb3RoZXJ3aXNlIHByZXZlbnQgdGhlIGluc3RhbmNlcyBmcm9tIGJlaW5nIHByb3Blcmx5IGFuZCB0aW1lbHlcbiAgICAgKiBnYXJiYWdlLWNvbGxlY3RlZCwgaS5lLiB0aGlzIGZ1bmN0aW9uIGhlbHBzIHByZXZlbnQgbWVtb3J5IGxlYWtzIVxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgY2xlYW51cEFmdGVyTGV4OiBmdW5jdGlvbiBsZXhlcl9jbGVhbnVwQWZ0ZXJMZXgoZG9fbm90X251a2VfZXJyb3JpbmZvcykge1xuICAgICAgLy8gcHJldmVudCBsaW5nZXJpbmcgY2lyY3VsYXIgcmVmZXJlbmNlcyBmcm9tIGNhdXNpbmcgbWVtb3J5IGxlYWtzOlxuICAgICAgdGhpcy5zZXRJbnB1dCgnJywge30pO1xuXG4gICAgICAvLyBudWtlIHRoZSBlcnJvciBoYXNoIGluZm8gaW5zdGFuY2VzIGNyZWF0ZWQgZHVyaW5nIHRoaXMgcnVuLlxuICAgICAgLy8gVXNlcmxhbmQgY29kZSBtdXN0IENPUFkgYW55IGRhdGEvcmVmZXJlbmNlc1xuICAgICAgLy8gaW4gdGhlIGVycm9yIGhhc2ggaW5zdGFuY2UocykgaXQgaXMgbW9yZSBwZXJtYW5lbnRseSBpbnRlcmVzdGVkIGluLlxuICAgICAgaWYgKCFkb19ub3RfbnVrZV9lcnJvcmluZm9zKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9fZXJyb3JfaW5mb3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB2YXIgZWwgPSB0aGlzLl9fZXJyb3JfaW5mb3NbaV07XG5cbiAgICAgICAgICBpZiAoZWwgJiYgdHlwZW9mIGVsLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGVsLmRlc3Ryb3koKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9fZXJyb3JfaW5mb3MubGVuZ3RoID0gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNsZWFyIHRoZSBsZXhlciB0b2tlbiBjb250ZXh0OyBpbnRlbmRlZCBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIGNsZWFyOiBmdW5jdGlvbiBsZXhlcl9jbGVhcigpIHtcbiAgICAgIHRoaXMueXl0ZXh0ID0gJyc7XG4gICAgICB0aGlzLnl5bGVuZyA9IDA7XG4gICAgICB0aGlzLm1hdGNoID0gJyc7XG5cbiAgICAgIC8vIC0gRE8gTk9UIHJlc2V0IGB0aGlzLm1hdGNoZWRgXG4gICAgICB0aGlzLm1hdGNoZXMgPSBmYWxzZTtcblxuICAgICAgdGhpcy5fbW9yZSA9IGZhbHNlO1xuICAgICAgdGhpcy5fYmFja3RyYWNrID0gZmFsc2U7XG4gICAgICB2YXIgY29sID0gKHRoaXMueXlsbG9jID8gdGhpcy55eWxsb2MubGFzdF9jb2x1bW4gOiAwKTtcblxuICAgICAgdGhpcy55eWxsb2MgPSB7XG4gICAgICAgIGZpcnN0X2xpbmU6IHRoaXMueXlsaW5lbm8gKyAxLFxuICAgICAgICBmaXJzdF9jb2x1bW46IGNvbCxcbiAgICAgICAgbGFzdF9saW5lOiB0aGlzLnl5bGluZW5vICsgMSxcbiAgICAgICAgbGFzdF9jb2x1bW46IGNvbCxcbiAgICAgICAgcmFuZ2U6IFt0aGlzLm9mZnNldCwgdGhpcy5vZmZzZXRdXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXNldHMgdGhlIGxleGVyLCBzZXRzIG5ldyBpbnB1dFxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgc2V0SW5wdXQ6IGZ1bmN0aW9uIGxleGVyX3NldElucHV0KGlucHV0LCB5eSkge1xuICAgICAgdGhpcy55eSA9IHl5IHx8IHRoaXMueXkgfHwge307XG5cbiAgICAgIC8vIGFsc28gY2hlY2sgaWYgd2UndmUgZnVsbHkgaW5pdGlhbGl6ZWQgdGhlIGxleGVyIGluc3RhbmNlLFxuICAgICAgLy8gaW5jbHVkaW5nIGV4cGFuc2lvbiB3b3JrIHRvIGJlIGRvbmUgdG8gZ28gZnJvbSBhIGxvYWRlZFxuICAgICAgLy8gbGV4ZXIgdG8gYSB1c2FibGUgbGV4ZXI6XG4gICAgICBpZiAoIXRoaXMuX19kZWNvbXByZXNzZWQpIHtcbiAgICAgICAgLy8gc3RlcCAxOiBkZWNvbXByZXNzIHRoZSByZWdleCBsaXN0OlxuICAgICAgICB2YXIgcnVsZXMgPSB0aGlzLnJ1bGVzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBydWxlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHZhciBydWxlX3JlID0gcnVsZXNbaV07XG5cbiAgICAgICAgICAvLyBjb21wcmVzc2lvbjogaXMgdGhlIFJFIGFuIHhyZWYgdG8gYW5vdGhlciBSRSBzbG90IGluIHRoZSBydWxlc1tdIHRhYmxlP1xuICAgICAgICAgIGlmICh0eXBlb2YgcnVsZV9yZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJ1bGVzW2ldID0gcnVsZXNbcnVsZV9yZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3RlcCAyOiB1bmZvbGQgdGhlIGNvbmRpdGlvbnNbXSBzZXQgdG8gbWFrZSB0aGVzZSByZWFkeSBmb3IgdXNlOlxuICAgICAgICB2YXIgY29uZGl0aW9ucyA9IHRoaXMuY29uZGl0aW9ucztcblxuICAgICAgICBmb3IgKHZhciBrIGluIGNvbmRpdGlvbnMpIHtcbiAgICAgICAgICB2YXIgc3BlYyA9IGNvbmRpdGlvbnNba107XG4gICAgICAgICAgdmFyIHJ1bGVfaWRzID0gc3BlYy5ydWxlcztcbiAgICAgICAgICB2YXIgbGVuID0gcnVsZV9pZHMubGVuZ3RoO1xuICAgICAgICAgIHZhciBydWxlX3JlZ2V4ZXMgPSBuZXcgQXJyYXkobGVuICsgMSk7ICAgICAgICAgICAgIC8vIHNsb3QgMCBpcyB1bnVzZWQ7IHdlIHVzZSBhIDEtYmFzZWQgaW5kZXggYXBwcm9hY2ggaGVyZSB0byBrZWVwIHRoZSBob3R0ZXN0IGNvZGUgaW4gYGxleGVyX25leHQoKWAgZmFzdCBhbmQgc2ltcGxlISBcbiAgICAgICAgICB2YXIgcnVsZV9uZXdfaWRzID0gbmV3IEFycmF5KGxlbiArIDEpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGlkeCA9IHJ1bGVfaWRzW2ldO1xuICAgICAgICAgICAgdmFyIHJ1bGVfcmUgPSBydWxlc1tpZHhdO1xuICAgICAgICAgICAgcnVsZV9yZWdleGVzW2kgKyAxXSA9IHJ1bGVfcmU7XG4gICAgICAgICAgICBydWxlX25ld19pZHNbaSArIDFdID0gaWR4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNwZWMucnVsZXMgPSBydWxlX25ld19pZHM7XG4gICAgICAgICAgc3BlYy5fX3J1bGVfcmVnZXhlcyA9IHJ1bGVfcmVnZXhlcztcbiAgICAgICAgICBzcGVjLl9fcnVsZV9jb3VudCA9IGxlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19kZWNvbXByZXNzZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pbnB1dCA9IGlucHV0IHx8ICcnO1xuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgdGhpcy5fc2lnbmFsZWRfZXJyb3JfdG9rZW4gPSBmYWxzZTtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy55eWxpbmVubyA9IDA7XG4gICAgICB0aGlzLm1hdGNoZWQgPSAnJztcbiAgICAgIHRoaXMuY29uZGl0aW9uU3RhY2sgPSBbJ0lOSVRJQUwnXTtcbiAgICAgIHRoaXMuX19jdXJyZW50UnVsZVNldF9fID0gbnVsbDtcblxuICAgICAgdGhpcy55eWxsb2MgPSB7XG4gICAgICAgIGZpcnN0X2xpbmU6IDEsXG4gICAgICAgIGZpcnN0X2NvbHVtbjogMCxcbiAgICAgICAgbGFzdF9saW5lOiAxLFxuICAgICAgICBsYXN0X2NvbHVtbjogMCxcbiAgICAgICAgcmFuZ2U6IFswLCAwXVxuICAgICAgfTtcblxuICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGVkaXQgdGhlIHJlbWFpbmluZyBpbnB1dCB2aWEgdXNlci1zcGVjaWZpZWQgY2FsbGJhY2suXG4gICAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBmb3J3YXJkLWFkanVzdCB0aGUgaW5wdXQtdG8tcGFyc2UsIFxuICAgICAqIGUuZy4gaW5zZXJ0aW5nIG1hY3JvIGV4cGFuc2lvbnMgYW5kIGFsaWtlIGluIHRoZVxuICAgICAqIGlucHV0IHdoaWNoIGhhcyB5ZXQgdG8gYmUgbGV4ZWQuXG4gICAgICogVGhlIGJlaGF2aW91ciBvZiB0aGlzIEFQSSBjb250cmFzdHMgdGhlIGB1bnB1dCgpYCBldCBhbFxuICAgICAqIEFQSXMgYXMgdGhvc2UgYWN0IG9uIHRoZSAqY29uc3VtZWQqIGlucHV0LCB3aGlsZSB0aGlzXG4gICAgICogb25lIGFsbG93cyBvbmUgdG8gbWFuaXB1bGF0ZSB0aGUgZnV0dXJlLCB3aXRob3V0IGltcGFjdGluZ1xuICAgICAqIHRoZSBjdXJyZW50IGB5eWxvY2AgY3Vyc29yIGxvY2F0aW9uIG9yIGFueSBoaXN0b3J5LiBcbiAgICAgKiBcbiAgICAgKiBVc2UgdGhpcyBBUEkgdG8gaGVscCBpbXBsZW1lbnQgQy1wcmVwcm9jZXNzb3ItbGlrZVxuICAgICAqIGAjaW5jbHVkZWAgc3RhdGVtZW50cywgZXRjLlxuICAgICAqIFxuICAgICAqIFRoZSBwcm92aWRlZCBjYWxsYmFjayBtdXN0IGJlIHN5bmNocm9ub3VzIGFuZCBpc1xuICAgICAqIGV4cGVjdGVkIHRvIHJldHVybiB0aGUgZWRpdGVkIGlucHV0IChzdHJpbmcpLlxuICAgICAqXG4gICAgICogVGhlIGBjcHNBcmdgIGFyZ3VtZW50IHZhbHVlIGlzIHBhc3NlZCB0byB0aGUgY2FsbGJhY2tcbiAgICAgKiBhcy1pcy5cbiAgICAgKlxuICAgICAqIGBjYWxsYmFja2AgaW50ZXJmYWNlOiBcbiAgICAgKiBgZnVuY3Rpb24gY2FsbGJhY2soaW5wdXQsIGNwc0FyZylgXG4gICAgICogXG4gICAgICogLSBgaW5wdXRgIHdpbGwgY2FycnkgdGhlIHJlbWFpbmluZy1pbnB1dC10by1sZXggc3RyaW5nXG4gICAgICogICBmcm9tIHRoZSBsZXhlci5cbiAgICAgKiAtIGBjcHNBcmdgIGlzIGBjcHNBcmdgIHBhc3NlZCBpbnRvIHRoaXMgQVBJLlxuICAgICAqIFxuICAgICAqIFRoZSBgdGhpc2AgcmVmZXJlbmNlIGZvciB0aGUgY2FsbGJhY2sgd2lsbCBiZSBzZXQgdG9cbiAgICAgKiByZWZlcmVuY2UgdGhpcyBsZXhlciBpbnN0YW5jZSBzbyB0aGF0IHVzZXJsYW5kIGNvZGVcbiAgICAgKiBpbiB0aGUgY2FsbGJhY2sgY2FuIGVhc2lseSBhbmQgcXVpY2tseSBhY2Nlc3MgYW55IGxleGVyXG4gICAgICogQVBJLiBcbiAgICAgKlxuICAgICAqIFdoZW4gdGhlIGNhbGxiYWNrIHJldHVybnMgYSBub24tc3RyaW5nLXR5cGUgZmFsc2V5IHZhbHVlLFxuICAgICAqIHdlIGFzc3VtZSB0aGUgY2FsbGJhY2sgZGlkIG5vdCBlZGl0IHRoZSBpbnB1dCBhbmQgd2VcbiAgICAgKiB3aWxsIHVzaW5nIHRoZSBpbnB1dCBhcy1pcy5cbiAgICAgKlxuICAgICAqIFdoZW4gdGhlIGNhbGxiYWNrIHJldHVybnMgYSBub24tc3RyaW5nLXR5cGUgdmFsdWUsIGl0XG4gICAgICogaXMgY29udmVydGVkIHRvIGEgc3RyaW5nIGZvciBsZXhpbmcgdmlhIHRoZSBgXCJcIiArIHJldHZhbGBcbiAgICAgKiBvcGVyYXRpb24uIChTZWUgYWxzbyB3aHk6IGh0dHA6Ly8yYWxpdHkuY29tLzIwMTIvMDMvY29udmVydGluZy10by1zdHJpbmcuaHRtbCBcbiAgICAgKiAtLSB0aGF0IHdheSBhbnkgcmV0dXJuZWQgb2JqZWN0J3MgYHRvVmFsdWUoKWAgYW5kIGB0b1N0cmluZygpYFxuICAgICAqIG1ldGhvZHMgd2lsbCBiZSBpbnZva2VkIGluIGEgcHJvcGVyL2Rlc2lyYWJsZSBvcmRlci4pXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBlZGl0UmVtYWluaW5nSW5wdXQ6IGZ1bmN0aW9uIGxleGVyX2VkaXRSZW1haW5pbmdJbnB1dChjYWxsYmFjaywgY3BzQXJnKSB7XG4gICAgICB2YXIgcnYgPSBjYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMuX2lucHV0LCBjcHNBcmcpO1xuXG4gICAgICBpZiAodHlwZW9mIHJ2ICE9PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAocnYpIHtcbiAgICAgICAgICB0aGlzLl9pbnB1dCA9ICcnICsgcnY7XG4gICAgICAgIH0gXG4gICAgICAgIC8vIGVsc2U6IGtlZXAgYHRoaXMuX2lucHV0YCBhcyBpcy4gIFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faW5wdXQgPSBydjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNvbnN1bWVzIGFuZCByZXR1cm5zIG9uZSBjaGFyIGZyb20gdGhlIGlucHV0XG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBpbnB1dDogZnVuY3Rpb24gbGV4ZXJfaW5wdXQoKSB7XG4gICAgICBpZiAoIXRoaXMuX2lucHV0KSB7XG4gICAgICAgIC8vdGhpcy5kb25lID0gdHJ1ZTsgICAgLS0gZG9uJ3Qgc2V0IGBkb25lYCBhcyB3ZSB3YW50IHRoZSBsZXgoKS9uZXh0KCkgQVBJIHRvIGJlIGFibGUgdG8gcHJvZHVjZSBvbmUgY3VzdG9tIEVPRiB0b2tlbiBtYXRjaCBhZnRlciB0aGlzIGFueWhvdy4gKGxleGVyIGNhbiBtYXRjaCBzcGVjaWFsIDw8RU9GPj4gdG9rZW5zIGFuZCBwZXJmb3JtIHVzZXIgYWN0aW9uIGNvZGUgZm9yIGEgPDxFT0Y+PiBtYXRjaCwgYnV0IG9ubHkgZG9lcyBzbyAqb25jZSopXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2ggPSB0aGlzLl9pbnB1dFswXTtcbiAgICAgIHRoaXMueXl0ZXh0ICs9IGNoO1xuICAgICAgdGhpcy55eWxlbmcrKztcbiAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICB0aGlzLm1hdGNoICs9IGNoO1xuICAgICAgdGhpcy5tYXRjaGVkICs9IGNoO1xuXG4gICAgICAvLyBDb3VudCB0aGUgbGluZW51bWJlciB1cCB3aGVuIHdlIGhpdCB0aGUgTEYgKG9yIGEgc3RhbmQtYWxvbmUgQ1IpLlxuICAgICAgLy8gT24gQ1JMRiwgdGhlIGxpbmVudW1iZXIgaXMgaW5jcmVtZW50ZWQgd2hlbiB5b3UgZmV0Y2ggdGhlIENSIG9yIHRoZSBDUkxGIGNvbWJvXG4gICAgICAvLyBhbmQgd2UgYWR2YW5jZSBpbW1lZGlhdGVseSBwYXN0IHRoZSBMRiBhcyB3ZWxsLCByZXR1cm5pbmcgYm90aCB0b2dldGhlciBhcyBpZlxuICAgICAgLy8gaXQgd2FzIGFsbCBhIHNpbmdsZSAnY2hhcmFjdGVyJyBvbmx5LlxuICAgICAgdmFyIHNsaWNlX2xlbiA9IDE7XG5cbiAgICAgIHZhciBsaW5lcyA9IGZhbHNlO1xuXG4gICAgICBpZiAoY2ggPT09ICdcXG4nKSB7XG4gICAgICAgIGxpbmVzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcXHInKSB7XG4gICAgICAgIGxpbmVzID0gdHJ1ZTtcbiAgICAgICAgdmFyIGNoMiA9IHRoaXMuX2lucHV0WzFdO1xuXG4gICAgICAgIGlmIChjaDIgPT09ICdcXG4nKSB7XG4gICAgICAgICAgc2xpY2VfbGVuKys7XG4gICAgICAgICAgY2ggKz0gY2gyO1xuICAgICAgICAgIHRoaXMueXl0ZXh0ICs9IGNoMjtcbiAgICAgICAgICB0aGlzLnl5bGVuZysrO1xuICAgICAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICAgICAgdGhpcy5tYXRjaCArPSBjaDI7XG4gICAgICAgICAgdGhpcy5tYXRjaGVkICs9IGNoMjtcbiAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZVsxXSsrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChsaW5lcykge1xuICAgICAgICB0aGlzLnl5bGluZW5vKys7XG4gICAgICAgIHRoaXMueXlsbG9jLmxhc3RfbGluZSsrO1xuICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbiA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbisrO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnl5bGxvYy5yYW5nZVsxXSsrO1xuICAgICAgdGhpcy5faW5wdXQgPSB0aGlzLl9pbnB1dC5zbGljZShzbGljZV9sZW4pO1xuICAgICAgcmV0dXJuIGNoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB1bnNoaWZ0cyBvbmUgY2hhciAob3IgYW4gZW50aXJlIHN0cmluZykgaW50byB0aGUgaW5wdXRcbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIHVucHV0OiBmdW5jdGlvbiBsZXhlcl91bnB1dChjaCkge1xuICAgICAgdmFyIGxlbiA9IGNoLmxlbmd0aDtcbiAgICAgIHZhciBsaW5lcyA9IGNoLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvZyk7XG4gICAgICB0aGlzLl9pbnB1dCA9IGNoICsgdGhpcy5faW5wdXQ7XG4gICAgICB0aGlzLnl5dGV4dCA9IHRoaXMueXl0ZXh0LnN1YnN0cigwLCB0aGlzLnl5dGV4dC5sZW5ndGggLSBsZW4pO1xuICAgICAgdGhpcy55eWxlbmcgPSB0aGlzLnl5dGV4dC5sZW5ndGg7XG4gICAgICB0aGlzLm9mZnNldCAtPSBsZW47XG4gICAgICB0aGlzLm1hdGNoID0gdGhpcy5tYXRjaC5zdWJzdHIoMCwgdGhpcy5tYXRjaC5sZW5ndGggLSBsZW4pO1xuICAgICAgdGhpcy5tYXRjaGVkID0gdGhpcy5tYXRjaGVkLnN1YnN0cigwLCB0aGlzLm1hdGNoZWQubGVuZ3RoIC0gbGVuKTtcblxuICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhpcy55eWxpbmVubyAtPSBsaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2xpbmUgPSB0aGlzLnl5bGluZW5vICsgMTtcbiAgICAgICAgdmFyIHByZSA9IHRoaXMubWF0Y2g7XG4gICAgICAgIHZhciBwcmVfbGluZXMgPSBwcmUuc3BsaXQoLyg/Olxcclxcbj98XFxuKS9nKTtcblxuICAgICAgICBpZiAocHJlX2xpbmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHByZSA9IHRoaXMubWF0Y2hlZDtcbiAgICAgICAgICBwcmVfbGluZXMgPSBwcmUuc3BsaXQoLyg/Olxcclxcbj98XFxuKS9nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uID0gcHJlX2xpbmVzW3ByZV9saW5lcy5sZW5ndGggLSAxXS5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbiAtPSBsZW47XG4gICAgICB9XG5cbiAgICAgIHRoaXMueXlsbG9jLnJhbmdlWzFdID0gdGhpcy55eWxsb2MucmFuZ2VbMF0gKyB0aGlzLnl5bGVuZztcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhY2hlIG1hdGNoZWQgdGV4dCBhbmQgYXBwZW5kIGl0IG9uIG5leHQgYWN0aW9uXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBtb3JlOiBmdW5jdGlvbiBsZXhlcl9tb3JlKCkge1xuICAgICAgdGhpcy5fbW9yZSA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc2lnbmFsIHRoZSBsZXhlciB0aGF0IHRoaXMgcnVsZSBmYWlscyB0byBtYXRjaCB0aGUgaW5wdXQsIHNvIHRoZVxuICAgICAqIG5leHQgbWF0Y2hpbmcgcnVsZSAocmVnZXgpIHNob3VsZCBiZSB0ZXN0ZWQgaW5zdGVhZC5cbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIHJlamVjdDogZnVuY3Rpb24gbGV4ZXJfcmVqZWN0KCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIpIHtcbiAgICAgICAgdGhpcy5fYmFja3RyYWNrID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHdoZW4gdGhlIGBwYXJzZUVycm9yKClgIGNhbGwgcmV0dXJucywgd2UgTVVTVCBlbnN1cmUgdGhhdCB0aGUgZXJyb3IgaXMgcmVnaXN0ZXJlZC5cbiAgICAgICAgLy8gV2UgYWNjb21wbGlzaCB0aGlzIGJ5IHNpZ25hbGluZyBhbiAnZXJyb3InIHRva2VuIHRvIGJlIHByb2R1Y2VkIGZvciB0aGUgY3VycmVudFxuICAgICAgICAvLyBgLmxleCgpYCBydW4uXG4gICAgICAgIHZhciBsaW5lbm9fbXNnID0gJyc7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmFja1Bvc2l0aW9uKSB7XG4gICAgICAgICAgbGluZW5vX21zZyA9ICcgb24gbGluZSAnICsgKHRoaXMueXlsaW5lbm8gKyAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb3Nfc3RyID0gJyc7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnNob3dQb3NpdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHBvc19zdHIgPSB0aGlzLnNob3dQb3NpdGlvbigpO1xuXG4gICAgICAgICAgaWYgKHBvc19zdHIgJiYgcG9zX3N0clswXSAhPT0gJ1xcbicpIHtcbiAgICAgICAgICAgIHBvc19zdHIgPSAnXFxuJyArIHBvc19zdHI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHAgPSB0aGlzLmNvbnN0cnVjdExleEVycm9ySW5mbyhcbiAgICAgICAgICAnTGV4aWNhbCBlcnJvcicgKyBsaW5lbm9fbXNnICsgJzogWW91IGNhbiBvbmx5IGludm9rZSByZWplY3QoKSBpbiB0aGUgbGV4ZXIgd2hlbiB0aGUgbGV4ZXIgaXMgb2YgdGhlIGJhY2t0cmFja2luZyBwZXJzdWFzaW9uIChvcHRpb25zLmJhY2t0cmFja19sZXhlciA9IHRydWUpLicgKyBwb3Nfc3RyLFxuICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5fc2lnbmFsZWRfZXJyb3JfdG9rZW4gPSB0aGlzLnBhcnNlRXJyb3IocC5lcnJTdHIsIHAsIHRoaXMuSmlzb25MZXhlckVycm9yKSB8fCB0aGlzLkVSUk9SO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0YWluIGZpcnN0IG4gY2hhcmFjdGVycyBvZiB0aGUgbWF0Y2hcbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIGxlc3M6IGZ1bmN0aW9uIGxleGVyX2xlc3Mobikge1xuICAgICAgcmV0dXJuIHRoaXMudW5wdXQodGhpcy5tYXRjaC5zbGljZShuKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiAocGFydCBvZiB0aGUpIGFscmVhZHkgbWF0Y2hlZCBpbnB1dCwgaS5lLiBmb3IgZXJyb3JcbiAgICAgKiBtZXNzYWdlcy5cbiAgICAgKiBcbiAgICAgKiBMaW1pdCB0aGUgcmV0dXJuZWQgc3RyaW5nIGxlbmd0aCB0byBgbWF4U2l6ZWAgKGRlZmF1bHQ6IDIwKS5cbiAgICAgKiBcbiAgICAgKiBMaW1pdCB0aGUgcmV0dXJuZWQgc3RyaW5nIHRvIHRoZSBgbWF4TGluZXNgIG51bWJlciBvZiBsaW5lcyBvZlxuICAgICAqIGlucHV0IChkZWZhdWx0OiAxKS5cbiAgICAgKiBcbiAgICAgKiBOZWdhdGl2ZSBsaW1pdCB2YWx1ZXMgZXF1YWwgKnVubGltaXRlZCouXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBwYXN0SW5wdXQ6IGZ1bmN0aW9uIGxleGVyX3Bhc3RJbnB1dChtYXhTaXplLCBtYXhMaW5lcykge1xuICAgICAgdmFyIHBhc3QgPSB0aGlzLm1hdGNoZWQuc3Vic3RyaW5nKDAsIHRoaXMubWF0Y2hlZC5sZW5ndGggLSB0aGlzLm1hdGNoLmxlbmd0aCk7XG5cbiAgICAgIGlmIChtYXhTaXplIDwgMClcbiAgICAgICAgbWF4U2l6ZSA9IHBhc3QubGVuZ3RoO1xuICAgICAgZWxzZSBpZiAoIW1heFNpemUpXG4gICAgICAgIG1heFNpemUgPSAyMDtcblxuICAgICAgaWYgKG1heExpbmVzIDwgMClcbiAgICAgICAgbWF4TGluZXMgPSBwYXN0Lmxlbmd0aDsgICAgICAgICAgLy8gY2FuJ3QgZXZlciBoYXZlIG1vcmUgaW5wdXQgbGluZXMgdGhhbiB0aGlzISBcbiAgICAgIGVsc2UgaWYgKCFtYXhMaW5lcylcbiAgICAgICAgbWF4TGluZXMgPSAxO1xuXG4gICAgICAvLyBgc3Vic3RyYCBhbnRpY2lwYXRpb246IHRyZWF0IFxcclxcbiBhcyBhIHNpbmdsZSBjaGFyYWN0ZXIgYW5kIHRha2UgYSBsaXR0bGVcbiAgICAgIC8vIG1vcmUgdGhhbiBuZWNlc3Nhcnkgc28gdGhhdCB3ZSBjYW4gc3RpbGwgcHJvcGVybHkgY2hlY2sgYWdhaW5zdCBtYXhTaXplXG4gICAgICAvLyBhZnRlciB3ZSd2ZSB0cmFuc2Zvcm1lZCBhbmQgbGltaXRlZCB0aGUgbmV3TGluZXMgaW4gaGVyZTpcbiAgICAgIHBhc3QgPSBwYXN0LnN1YnN0cigtbWF4U2l6ZSAqIDIgLSAyKTtcblxuICAgICAgLy8gbm93IHRoYXQgd2UgaGF2ZSBhIHNpZ25pZmljYW50bHkgcmVkdWNlZCBzdHJpbmcgdG8gcHJvY2VzcywgdHJhbnNmb3JtIHRoZSBuZXdsaW5lc1xuICAgICAgLy8gYW5kIGNob3AgdGhlbSwgdGhlbiBsaW1pdCB0aGVtOlxuICAgICAgdmFyIGEgPSBwYXN0LnJlcGxhY2UoL1xcclxcbnxcXHIvZywgJ1xcbicpLnNwbGl0KCdcXG4nKTtcblxuICAgICAgYSA9IGEuc2xpY2UoLW1heExpbmVzKTtcbiAgICAgIHBhc3QgPSBhLmpvaW4oJ1xcbicpO1xuXG4gICAgICAvLyBXaGVuLCBhZnRlciBsaW1pdGluZyB0byBtYXhMaW5lcywgd2Ugc3RpbGwgaGF2ZSB0b28gbXVjaCB0byByZXR1cm4sXG4gICAgICAvLyBkbyBhZGQgYW4gZWxsaXBzaXMgcHJlZml4Li4uXG4gICAgICBpZiAocGFzdC5sZW5ndGggPiBtYXhTaXplKSB7XG4gICAgICAgIHBhc3QgPSAnLi4uJyArIHBhc3Quc3Vic3RyKC1tYXhTaXplKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiAocGFydCBvZiB0aGUpIHVwY29taW5nIGlucHV0LCBpLmUuIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgICAgKiBcbiAgICAgKiBMaW1pdCB0aGUgcmV0dXJuZWQgc3RyaW5nIGxlbmd0aCB0byBgbWF4U2l6ZWAgKGRlZmF1bHQ6IDIwKS5cbiAgICAgKiBcbiAgICAgKiBMaW1pdCB0aGUgcmV0dXJuZWQgc3RyaW5nIHRvIHRoZSBgbWF4TGluZXNgIG51bWJlciBvZiBsaW5lcyBvZiBpbnB1dCAoZGVmYXVsdDogMSkuXG4gICAgICogXG4gICAgICogTmVnYXRpdmUgbGltaXQgdmFsdWVzIGVxdWFsICp1bmxpbWl0ZWQqLlxuICAgICAqXG4gICAgICogPiAjIyMgTk9URSAjIyNcbiAgICAgKiA+XG4gICAgICogPiAqXCJ1cGNvbWluZyBpbnB1dFwiKiBpcyBkZWZpbmVkIGFzIHRoZSB3aG9sZSBvZiB0aGUgYm90aFxuICAgICAqID4gdGhlICpjdXJyZW50bHkgbGV4ZWQqIGlucHV0LCB0b2dldGhlciB3aXRoIGFueSByZW1haW5pbmcgaW5wdXRcbiAgICAgKiA+IGZvbGxvd2luZyB0aGF0LiAqXCJjdXJyZW50bHkgbGV4ZWRcIiogaW5wdXQgaXMgdGhlIGlucHV0IFxuICAgICAqID4gYWxyZWFkeSByZWNvZ25pemVkIGJ5IHRoZSBsZXhlciBidXQgbm90IHlldCByZXR1cm5lZCB3aXRoXG4gICAgICogPiB0aGUgbGV4ZXIgdG9rZW4uIFRoaXMgaGFwcGVucyB3aGVuIHlvdSBhcmUgaW52b2tpbmcgdGhpcyBBUElcbiAgICAgKiA+IGZyb20gaW5zaWRlIGFueSBsZXhlciBydWxlIGFjdGlvbiBjb2RlIGJsb2NrLiBcbiAgICAgKiA+XG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICB1cGNvbWluZ0lucHV0OiBmdW5jdGlvbiBsZXhlcl91cGNvbWluZ0lucHV0KG1heFNpemUsIG1heExpbmVzKSB7XG4gICAgICB2YXIgbmV4dCA9IHRoaXMubWF0Y2g7XG5cbiAgICAgIGlmIChtYXhTaXplIDwgMClcbiAgICAgICAgbWF4U2l6ZSA9IG5leHQubGVuZ3RoICsgdGhpcy5faW5wdXQubGVuZ3RoO1xuICAgICAgZWxzZSBpZiAoIW1heFNpemUpXG4gICAgICAgIG1heFNpemUgPSAyMDtcblxuICAgICAgaWYgKG1heExpbmVzIDwgMClcbiAgICAgICAgbWF4TGluZXMgPSBtYXhTaXplOyAgICAgICAgICAvLyBjYW4ndCBldmVyIGhhdmUgbW9yZSBpbnB1dCBsaW5lcyB0aGFuIHRoaXMhIFxuICAgICAgZWxzZSBpZiAoIW1heExpbmVzKVxuICAgICAgICBtYXhMaW5lcyA9IDE7XG5cbiAgICAgIC8vIGBzdWJzdHJpbmdgIGFudGljaXBhdGlvbjogdHJlYXQgXFxyXFxuIGFzIGEgc2luZ2xlIGNoYXJhY3RlciBhbmQgdGFrZSBhIGxpdHRsZVxuICAgICAgLy8gbW9yZSB0aGFuIG5lY2Vzc2FyeSBzbyB0aGF0IHdlIGNhbiBzdGlsbCBwcm9wZXJseSBjaGVjayBhZ2FpbnN0IG1heFNpemVcbiAgICAgIC8vIGFmdGVyIHdlJ3ZlIHRyYW5zZm9ybWVkIGFuZCBsaW1pdGVkIHRoZSBuZXdMaW5lcyBpbiBoZXJlOlxuICAgICAgaWYgKG5leHQubGVuZ3RoIDwgbWF4U2l6ZSAqIDIgKyAyKSB7XG4gICAgICAgIG5leHQgKz0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKDAsIG1heFNpemUgKiAyICsgMik7ICAgLy8gc3Vic3RyaW5nIGlzIGZhc3RlciBvbiBDaHJvbWUvVjggXG4gICAgICB9XG5cbiAgICAgIC8vIG5vdyB0aGF0IHdlIGhhdmUgYSBzaWduaWZpY2FudGx5IHJlZHVjZWQgc3RyaW5nIHRvIHByb2Nlc3MsIHRyYW5zZm9ybSB0aGUgbmV3bGluZXNcbiAgICAgIC8vIGFuZCBjaG9wIHRoZW0sIHRoZW4gbGltaXQgdGhlbTpcbiAgICAgIHZhciBhID0gbmV4dC5yZXBsYWNlKC9cXHJcXG58XFxyL2csICdcXG4nKS5zcGxpdCgnXFxuJyk7XG5cbiAgICAgIGEgPSBhLnNsaWNlKDAsIG1heExpbmVzKTtcbiAgICAgIG5leHQgPSBhLmpvaW4oJ1xcbicpO1xuXG4gICAgICAvLyBXaGVuLCBhZnRlciBsaW1pdGluZyB0byBtYXhMaW5lcywgd2Ugc3RpbGwgaGF2ZSB0b28gbXVjaCB0byByZXR1cm4sXG4gICAgICAvLyBkbyBhZGQgYW4gZWxsaXBzaXMgcG9zdGZpeC4uLlxuICAgICAgaWYgKG5leHQubGVuZ3RoID4gbWF4U2l6ZSkge1xuICAgICAgICBuZXh0ID0gbmV4dC5zdWJzdHJpbmcoMCwgbWF4U2l6ZSkgKyAnLi4uJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiBhIHN0cmluZyB3aGljaCBkaXNwbGF5cyB0aGUgY2hhcmFjdGVyIHBvc2l0aW9uIHdoZXJlIHRoZVxuICAgICAqIGxleGluZyBlcnJvciBvY2N1cnJlZCwgaS5lLiBmb3IgZXJyb3IgbWVzc2FnZXNcbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIHNob3dQb3NpdGlvbjogZnVuY3Rpb24gbGV4ZXJfc2hvd1Bvc2l0aW9uKG1heFByZWZpeCwgbWF4UG9zdGZpeCkge1xuICAgICAgdmFyIHByZSA9IHRoaXMucGFzdElucHV0KG1heFByZWZpeCkucmVwbGFjZSgvXFxzL2csICcgJyk7XG4gICAgICB2YXIgYyA9IG5ldyBBcnJheShwcmUubGVuZ3RoICsgMSkuam9pbignLScpO1xuICAgICAgcmV0dXJuIHByZSArIHRoaXMudXBjb21pbmdJbnB1dChtYXhQb3N0Zml4KS5yZXBsYWNlKC9cXHMvZywgJyAnKSArICdcXG4nICsgYyArICdeJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIGEgc3RyaW5nIHdoaWNoIGRpc3BsYXlzIHRoZSBsaW5lcyAmIGNvbHVtbnMgb2YgaW5wdXQgd2hpY2ggYXJlIHJlZmVyZW5jZWQgXG4gICAgICogYnkgdGhlIGdpdmVuIGxvY2F0aW9uIGluZm8gcmFuZ2UsIHBsdXMgYSBmZXcgbGluZXMgb2YgY29udGV4dC5cbiAgICAgKiBcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHByZXR0eS1wcmludHMgdGhlIGluZGljYXRlZCBzZWN0aW9uIG9mIHRoZSBpbnB1dCwgd2l0aCBsaW5lIG51bWJlcnMgXG4gICAgICogYW5kIGV2ZXJ5dGhpbmchXG4gICAgICogXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyB2ZXJ5IHVzZWZ1bCB0byBwcm92aWRlIGhpZ2hseSByZWFkYWJsZSBlcnJvciByZXBvcnRzLCB3aGlsZVxuICAgICAqIHRoZSBsb2NhdGlvbiByYW5nZSBtYXkgYmUgc3BlY2lmaWVkIGluIHZhcmlvdXMgZmxleGlibGUgd2F5czpcbiAgICAgKiBcbiAgICAgKiAtIGBsb2NgIGlzIHRoZSBsb2NhdGlvbiBpbmZvIG9iamVjdCB3aGljaCByZWZlcmVuY2VzIHRoZSBhcmVhIHdoaWNoIHNob3VsZCBiZVxuICAgICAqICAgZGlzcGxheWVkIGFuZCAnbWFya2VkIHVwJzogdGhlc2UgbGluZXMgJiBjb2x1bW5zIG9mIHRleHQgYXJlIG1hcmtlZCB1cCBieSBgXmBcbiAgICAgKiAgIGNoYXJhY3RlcnMgYmVsb3cgZWFjaCBjaGFyYWN0ZXIgaW4gdGhlIGVudGlyZSBpbnB1dCByYW5nZS5cbiAgICAgKiBcbiAgICAgKiAtIGBjb250ZXh0X2xvY2AgaXMgdGhlICpvcHRpb25hbCogbG9jYXRpb24gaW5mbyBvYmplY3Qgd2hpY2ggaW5zdHJ1Y3RzIHRoaXNcbiAgICAgKiAgIHByZXR0eS1wcmludGVyIGhvdyBtdWNoICpsZWFkaW5nKiBjb250ZXh0IHNob3VsZCBiZSBkaXNwbGF5ZWQgYWxvbmdzaWRlXG4gICAgICogICB0aGUgYXJlYSByZWZlcmVuY2VkIGJ5IGBsb2NgLiBUaGlzIGNhbiBoZWxwIHByb3ZpZGUgY29udGV4dCBmb3IgdGhlIGRpc3BsYXllZFxuICAgICAqICAgZXJyb3IsIGV0Yy5cbiAgICAgKiBcbiAgICAgKiAgIFdoZW4gdGhpcyBsb2NhdGlvbiBpbmZvIGlzIG5vdCBwcm92aWRlZCwgYSBkZWZhdWx0IGNvbnRleHQgb2YgMyBsaW5lcyBpc1xuICAgICAqICAgdXNlZC5cbiAgICAgKiBcbiAgICAgKiAtIGBjb250ZXh0X2xvYzJgIGlzIGFub3RoZXIgKm9wdGlvbmFsKiBsb2NhdGlvbiBpbmZvIG9iamVjdCwgd2hpY2ggc2VydmVzXG4gICAgICogICBhIHNpbWlsYXIgcHVycG9zZSB0byBgY29udGV4dF9sb2NgOiBpdCBzcGVjaWZpZXMgdGhlIGFtb3VudCBvZiAqdHJhaWxpbmcqXG4gICAgICogICBjb250ZXh0IGxpbmVzIHRvIGRpc3BsYXkgaW4gdGhlIHByZXR0eS1wcmludCBvdXRwdXQuXG4gICAgICogXG4gICAgICogICBXaGVuIHRoaXMgbG9jYXRpb24gaW5mbyBpcyBub3QgcHJvdmlkZWQsIGEgZGVmYXVsdCBjb250ZXh0IG9mIDEgbGluZSBvbmx5IGlzXG4gICAgICogICB1c2VkLlxuICAgICAqIFxuICAgICAqIFNwZWNpYWwgTm90ZXM6XG4gICAgICogXG4gICAgICogLSB3aGVuIHRoZSBgbG9jYC1pbmRpY2F0ZWQgcmFuZ2UgaXMgdmVyeSBsYXJnZSAoYWJvdXQgNSBsaW5lcyBvciBtb3JlKSwgdGhlblxuICAgICAqICAgb25seSB0aGUgZmlyc3QgYW5kIGxhc3QgZmV3IGxpbmVzIG9mIHRoaXMgYmxvY2sgYXJlIHByaW50ZWQgd2hpbGUgYVxuICAgICAqICAgYC4uLmNvbnRpbnVlZC4uLmAgbWVzc2FnZSB3aWxsIGJlIHByaW50ZWQgYmV0d2VlbiB0aGVtLlxuICAgICAqIFxuICAgICAqICAgVGhpcyBzZXJ2ZXMgdGhlIHB1cnBvc2Ugb2Ygbm90IHByaW50aW5nIGEgaHVnZSBhbW91bnQgb2YgdGV4dCB3aGVuIHRoZSBgbG9jYFxuICAgICAqICAgcmFuZ2UgaGFwcGVucyB0byBiZSBodWdlOiB0aGlzIHdheSBhIG1hbmFnZWFibGUgJiByZWFkYWJsZSBvdXRwdXQgcmVzdWx0c1xuICAgICAqICAgZm9yIGFyYml0cmFyeSBsYXJnZSByYW5nZXMuXG4gICAgICogXG4gICAgICogLSB0aGlzIGZ1bmN0aW9uIGNhbiBkaXNwbGF5IGxpbmVzIG9mIGlucHV0IHdoaWNoIHdoYXZlIG5vdCB5ZXQgYmVlbiBsZXhlZC5cbiAgICAgKiAgIGBwcmV0dHlQcmludFJhbmdlKClgIGNhbiBhY2Nlc3MgdGhlIGVudGlyZSBpbnB1dCFcbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIHByZXR0eVByaW50UmFuZ2U6IGZ1bmN0aW9uIGxleGVyX3ByZXR0eVByaW50UmFuZ2UobG9jLCBjb250ZXh0X2xvYywgY29udGV4dF9sb2MyKSB7XG4gICAgICB2YXIgZXJyb3Jfc2l6ZSA9IGxvYy5sYXN0X2xpbmUgLSBsb2MuZmlyc3RfbGluZTtcbiAgICAgIGNvbnN0IENPTlRFWFQgPSAzO1xuICAgICAgY29uc3QgQ09OVEVYVF9UQUlMID0gMTtcbiAgICAgIGNvbnN0IE1JTklNVU1fVklTSUJMRV9OT05FTVBUWV9MSU5FX0NPVU5UID0gMjtcbiAgICAgIHZhciBpbnB1dCA9IHRoaXMubWF0Y2hlZCArIHRoaXMuX2lucHV0O1xuICAgICAgdmFyIGxpbmVzID0gaW5wdXQuc3BsaXQoJ1xcbicpO1xuXG4gICAgICAvL3ZhciBzaG93X2NvbnRleHQgPSAoZXJyb3Jfc2l6ZSA8IDUgfHwgY29udGV4dF9sb2MpO1xuICAgICAgdmFyIGwwID0gTWF0aC5tYXgoMSwgKGNvbnRleHRfbG9jID8gY29udGV4dF9sb2MuZmlyc3RfbGluZSA6IGxvYy5maXJzdF9saW5lIC0gQ09OVEVYVCkpO1xuXG4gICAgICB2YXIgbDEgPSBNYXRoLm1heCgxLCAoY29udGV4dF9sb2MyID8gY29udGV4dF9sb2MyLmxhc3RfbGluZSA6IGxvYy5sYXN0X2xpbmUgKyBDT05URVhUX1RBSUwpKTtcbiAgICAgIHZhciBsaW5lbm9fZGlzcGxheV93aWR0aCA9IDEgKyBNYXRoLmxvZzEwKGwxIHwgMSkgfCAwO1xuICAgICAgdmFyIHdzX3ByZWZpeCA9IG5ldyBBcnJheShsaW5lbm9fZGlzcGxheV93aWR0aCkuam9pbignICcpO1xuICAgICAgdmFyIG5vbmVtcHR5X2xpbmVfaW5kZXhlcyA9IFtdO1xuXG4gICAgICB2YXIgcnYgPSBsaW5lcy5zbGljZShsMCAtIDEsIGwxICsgMSkubWFwKGZ1bmN0aW9uIGluamVjdExpbmVOdW1iZXIobGluZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGxubyA9IGluZGV4ICsgbDA7XG4gICAgICAgIHZhciBsbm9fcGZ4ID0gKHdzX3ByZWZpeCArIGxubykuc3Vic3RyKC1saW5lbm9fZGlzcGxheV93aWR0aCk7XG4gICAgICAgIHZhciBydiA9IGxub19wZnggKyAnOiAnICsgbGluZTtcbiAgICAgICAgdmFyIGVycnBmeCA9IG5ldyBBcnJheShsaW5lbm9fZGlzcGxheV93aWR0aCArIDEpLmpvaW4oJ14nKTtcblxuICAgICAgICBpZiAobG5vID09PSBsb2MuZmlyc3RfbGluZSkge1xuICAgICAgICAgIHZhciBvZmZzZXQgPSBsb2MuZmlyc3RfY29sdW1uICsgMjtcblxuICAgICAgICAgIHZhciBsZW4gPSBNYXRoLm1heChcbiAgICAgICAgICAgIDIsXG4gICAgICAgICAgICAoKGxubyA9PT0gbG9jLmxhc3RfbGluZSA/IGxvYy5sYXN0X2NvbHVtbiA6IGxpbmUubGVuZ3RoKSkgLSBsb2MuZmlyc3RfY29sdW1uICsgMVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICB2YXIgbGVhZCA9IG5ldyBBcnJheShvZmZzZXQpLmpvaW4oJy4nKTtcbiAgICAgICAgICB2YXIgbWFyayA9IG5ldyBBcnJheShsZW4pLmpvaW4oJ14nKTtcbiAgICAgICAgICBydiArPSAnXFxuJyArIGVycnBmeCArIGxlYWQgKyBtYXJrO1xuXG4gICAgICAgICAgaWYgKGxpbmUudHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG5vbmVtcHR5X2xpbmVfaW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobG5vID09PSBsb2MubGFzdF9saW5lKSB7XG4gICAgICAgICAgdmFyIG9mZnNldCA9IDIgKyAxO1xuICAgICAgICAgIHZhciBsZW4gPSBNYXRoLm1heCgyLCBsb2MubGFzdF9jb2x1bW4gKyAxKTtcbiAgICAgICAgICB2YXIgbGVhZCA9IG5ldyBBcnJheShvZmZzZXQpLmpvaW4oJy4nKTtcbiAgICAgICAgICB2YXIgbWFyayA9IG5ldyBBcnJheShsZW4pLmpvaW4oJ14nKTtcbiAgICAgICAgICBydiArPSAnXFxuJyArIGVycnBmeCArIGxlYWQgKyBtYXJrO1xuXG4gICAgICAgICAgaWYgKGxpbmUudHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG5vbmVtcHR5X2xpbmVfaW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobG5vID4gbG9jLmZpcnN0X2xpbmUgJiYgbG5vIDwgbG9jLmxhc3RfbGluZSkge1xuICAgICAgICAgIHZhciBvZmZzZXQgPSAyICsgMTtcbiAgICAgICAgICB2YXIgbGVuID0gTWF0aC5tYXgoMiwgbGluZS5sZW5ndGggKyAxKTtcbiAgICAgICAgICB2YXIgbGVhZCA9IG5ldyBBcnJheShvZmZzZXQpLmpvaW4oJy4nKTtcbiAgICAgICAgICB2YXIgbWFyayA9IG5ldyBBcnJheShsZW4pLmpvaW4oJ14nKTtcbiAgICAgICAgICBydiArPSAnXFxuJyArIGVycnBmeCArIGxlYWQgKyBtYXJrO1xuXG4gICAgICAgICAgaWYgKGxpbmUudHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG5vbmVtcHR5X2xpbmVfaW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBydiA9IHJ2LnJlcGxhY2UoL1xcdC9nLCAnICcpO1xuICAgICAgICByZXR1cm4gcnY7XG4gICAgICB9KTtcblxuICAgICAgLy8gbm93IG1ha2Ugc3VyZSB3ZSBkb24ndCBwcmludCBhbiBvdmVybHkgbGFyZ2UgYW1vdW50IG9mIGVycm9yIGFyZWE6IGxpbWl0IGl0IFxuICAgICAgLy8gdG8gdGhlIHRvcCBhbmQgYm90dG9tIGxpbmUgY291bnQ6XG4gICAgICBpZiAobm9uZW1wdHlfbGluZV9pbmRleGVzLmxlbmd0aCA+IDIgKiBNSU5JTVVNX1ZJU0lCTEVfTk9ORU1QVFlfTElORV9DT1VOVCkge1xuICAgICAgICB2YXIgY2xpcF9zdGFydCA9IG5vbmVtcHR5X2xpbmVfaW5kZXhlc1tNSU5JTVVNX1ZJU0lCTEVfTk9ORU1QVFlfTElORV9DT1VOVCAtIDFdICsgMTtcbiAgICAgICAgdmFyIGNsaXBfZW5kID0gbm9uZW1wdHlfbGluZV9pbmRleGVzW25vbmVtcHR5X2xpbmVfaW5kZXhlcy5sZW5ndGggLSBNSU5JTVVNX1ZJU0lCTEVfTk9ORU1QVFlfTElORV9DT1VOVF0gLSAxO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCdjbGlwIG9mZjogJywge1xuICAgICAgICAgIHN0YXJ0OiBjbGlwX3N0YXJ0LFxuICAgICAgICAgIGVuZDogY2xpcF9lbmQsXG4gICAgICAgICAgbGVuOiBjbGlwX2VuZCAtIGNsaXBfc3RhcnQgKyAxLFxuICAgICAgICAgIGFycjogbm9uZW1wdHlfbGluZV9pbmRleGVzLFxuICAgICAgICAgIHJ2XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBpbnRlcm1lZGlhdGVfbGluZSA9IG5ldyBBcnJheShsaW5lbm9fZGlzcGxheV93aWR0aCArIDEpLmpvaW4oJyAnKSArICcgICguLi5jb250aW51ZWQuLi4pJztcbiAgICAgICAgaW50ZXJtZWRpYXRlX2xpbmUgKz0gJ1xcbicgKyBuZXcgQXJyYXkobGluZW5vX2Rpc3BsYXlfd2lkdGggKyAxKS5qb2luKCctJykgKyAnICAoLS0tLS0tLS0tLS0tLS0tKSc7XG4gICAgICAgIHJ2LnNwbGljZShjbGlwX3N0YXJ0LCBjbGlwX2VuZCAtIGNsaXBfc3RhcnQgKyAxLCBpbnRlcm1lZGlhdGVfbGluZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBydi5qb2luKCdcXG4nKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogaGVscGVyIGZ1bmN0aW9uLCB1c2VkIHRvIHByb2R1Y2UgYSBodW1hbiByZWFkYWJsZSBkZXNjcmlwdGlvbiBhcyBhIHN0cmluZywgZ2l2ZW5cbiAgICAgKiB0aGUgaW5wdXQgYHl5bGxvY2AgbG9jYXRpb24gb2JqZWN0LlxuICAgICAqIFxuICAgICAqIFNldCBgZGlzcGxheV9yYW5nZV90b29gIHRvIFRSVUUgdG8gaW5jbHVkZSB0aGUgc3RyaW5nIGNoYXJhY3RlciBpbmRleCBwb3NpdGlvbihzKVxuICAgICAqIGluIHRoZSBkZXNjcmlwdGlvbiBpZiB0aGUgYHl5bGxvYy5yYW5nZWAgaXMgYXZhaWxhYmxlLlxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgZGVzY3JpYmVZWUxMT0M6IGZ1bmN0aW9uIGxleGVyX2Rlc2NyaWJlX3l5bGxvYyh5eWxsb2MsIGRpc3BsYXlfcmFuZ2VfdG9vKSB7XG4gICAgICB2YXIgbDEgPSB5eWxsb2MuZmlyc3RfbGluZTtcbiAgICAgIHZhciBsMiA9IHl5bGxvYy5sYXN0X2xpbmU7XG4gICAgICB2YXIgYzEgPSB5eWxsb2MuZmlyc3RfY29sdW1uO1xuICAgICAgdmFyIGMyID0geXlsbG9jLmxhc3RfY29sdW1uO1xuICAgICAgdmFyIGRsID0gbDIgLSBsMTtcbiAgICAgIHZhciBkYyA9IGMyIC0gYzE7XG4gICAgICB2YXIgcnY7XG5cbiAgICAgIGlmIChkbCA9PT0gMCkge1xuICAgICAgICBydiA9ICdsaW5lICcgKyBsMSArICcsICc7XG5cbiAgICAgICAgaWYgKGRjIDw9IDEpIHtcbiAgICAgICAgICBydiArPSAnY29sdW1uICcgKyBjMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBydiArPSAnY29sdW1ucyAnICsgYzEgKyAnIC4uICcgKyBjMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnYgPSAnbGluZXMgJyArIGwxICsgJyhjb2x1bW4gJyArIGMxICsgJykgLi4gJyArIGwyICsgJyhjb2x1bW4gJyArIGMyICsgJyknO1xuICAgICAgfVxuXG4gICAgICBpZiAoeXlsbG9jLnJhbmdlICYmIGRpc3BsYXlfcmFuZ2VfdG9vKSB7XG4gICAgICAgIHZhciByMSA9IHl5bGxvYy5yYW5nZVswXTtcbiAgICAgICAgdmFyIHIyID0geXlsbG9jLnJhbmdlWzFdIC0gMTtcblxuICAgICAgICBpZiAocjIgPD0gcjEpIHtcbiAgICAgICAgICBydiArPSAnIHtTdHJpbmcgT2Zmc2V0OiAnICsgcjEgKyAnfSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcnYgKz0gJyB7U3RyaW5nIE9mZnNldCByYW5nZTogJyArIHIxICsgJyAuLiAnICsgcjIgKyAnfSc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJ2O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB0ZXN0IHRoZSBsZXhlZCB0b2tlbjogcmV0dXJuIEZBTFNFIHdoZW4gbm90IGEgbWF0Y2gsIG90aGVyd2lzZSByZXR1cm4gdG9rZW4uXG4gICAgICogXG4gICAgICogYG1hdGNoYCBpcyBzdXBwb3NlZCB0byBiZSBhbiBhcnJheSBjb21pbmcgb3V0IG9mIGEgcmVnZXggbWF0Y2gsIGkuZS4gYG1hdGNoWzBdYFxuICAgICAqIGNvbnRhaW5zIHRoZSBhY3R1YWxseSBtYXRjaGVkIHRleHQgc3RyaW5nLlxuICAgICAqIFxuICAgICAqIEFsc28gbW92ZSB0aGUgaW5wdXQgY3Vyc29yIGZvcndhcmQgYW5kIHVwZGF0ZSB0aGUgbWF0Y2ggY29sbGVjdG9yczpcbiAgICAgKiBcbiAgICAgKiAtIGB5eXRleHRgXG4gICAgICogLSBgeXlsZW5nYFxuICAgICAqIC0gYG1hdGNoYFxuICAgICAqIC0gYG1hdGNoZXNgXG4gICAgICogLSBgeXlsbG9jYFxuICAgICAqIC0gYG9mZnNldGBcbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIHRlc3RfbWF0Y2g6IGZ1bmN0aW9uIGxleGVyX3Rlc3RfbWF0Y2gobWF0Y2gsIGluZGV4ZWRfcnVsZSkge1xuICAgICAgdmFyIHRva2VuLCBsaW5lcywgYmFja3VwLCBtYXRjaF9zdHIsIG1hdGNoX3N0cl9sZW47XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmFja3RyYWNrX2xleGVyKSB7XG4gICAgICAgIC8vIHNhdmUgY29udGV4dFxuICAgICAgICBiYWNrdXAgPSB7XG4gICAgICAgICAgeXlsaW5lbm86IHRoaXMueXlsaW5lbm8sXG5cbiAgICAgICAgICB5eWxsb2M6IHtcbiAgICAgICAgICAgIGZpcnN0X2xpbmU6IHRoaXMueXlsbG9jLmZpcnN0X2xpbmUsXG4gICAgICAgICAgICBsYXN0X2xpbmU6IHRoaXMueXlsbG9jLmxhc3RfbGluZSxcbiAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uLFxuICAgICAgICAgICAgbGFzdF9jb2x1bW46IHRoaXMueXlsbG9jLmxhc3RfY29sdW1uLFxuICAgICAgICAgICAgcmFuZ2U6IHRoaXMueXlsbG9jLnJhbmdlLnNsaWNlKDApXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHl5dGV4dDogdGhpcy55eXRleHQsXG4gICAgICAgICAgbWF0Y2g6IHRoaXMubWF0Y2gsXG4gICAgICAgICAgbWF0Y2hlczogdGhpcy5tYXRjaGVzLFxuICAgICAgICAgIG1hdGNoZWQ6IHRoaXMubWF0Y2hlZCxcbiAgICAgICAgICB5eWxlbmc6IHRoaXMueXlsZW5nLFxuICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgX21vcmU6IHRoaXMuX21vcmUsXG4gICAgICAgICAgX2lucHV0OiB0aGlzLl9pbnB1dCxcblxuICAgICAgICAgIC8vX3NpZ25hbGVkX2Vycm9yX3Rva2VuOiB0aGlzLl9zaWduYWxlZF9lcnJvcl90b2tlbixcbiAgICAgICAgICB5eTogdGhpcy55eSxcblxuICAgICAgICAgIGNvbmRpdGlvblN0YWNrOiB0aGlzLmNvbmRpdGlvblN0YWNrLnNsaWNlKDApLFxuICAgICAgICAgIGRvbmU6IHRoaXMuZG9uZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBtYXRjaF9zdHIgPSBtYXRjaFswXTtcbiAgICAgIG1hdGNoX3N0cl9sZW4gPSBtYXRjaF9zdHIubGVuZ3RoO1xuXG4gICAgICAvLyBpZiAobWF0Y2hfc3RyLmluZGV4T2YoJ1xcbicpICE9PSAtMSB8fCBtYXRjaF9zdHIuaW5kZXhPZignXFxyJykgIT09IC0xKSB7XG4gICAgICBsaW5lcyA9IG1hdGNoX3N0ci5zcGxpdCgvKD86XFxyXFxuP3xcXG4pL2cpO1xuXG4gICAgICBpZiAobGluZXMubGVuZ3RoID4gMSkge1xuICAgICAgICB0aGlzLnl5bGluZW5vICs9IGxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgIHRoaXMueXlsbG9jLmxhc3RfbGluZSA9IHRoaXMueXlsaW5lbm8gKyAxO1xuICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbiA9IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uICs9IG1hdGNoX3N0cl9sZW47XG4gICAgICB9XG5cbiAgICAgIC8vIH1cbiAgICAgIHRoaXMueXl0ZXh0ICs9IG1hdGNoX3N0cjtcblxuICAgICAgdGhpcy5tYXRjaCArPSBtYXRjaF9zdHI7XG4gICAgICB0aGlzLm1hdGNoZWQgKz0gbWF0Y2hfc3RyO1xuICAgICAgdGhpcy5tYXRjaGVzID0gbWF0Y2g7XG4gICAgICB0aGlzLnl5bGVuZyA9IHRoaXMueXl0ZXh0Lmxlbmd0aDtcbiAgICAgIHRoaXMueXlsbG9jLnJhbmdlWzFdICs9IG1hdGNoX3N0cl9sZW47XG5cbiAgICAgIC8vIHByZXZpb3VzIGxleCBydWxlcyBNQVkgaGF2ZSBpbnZva2VkIHRoZSBgbW9yZSgpYCBBUEkgcmF0aGVyIHRoYW4gcHJvZHVjaW5nIGEgdG9rZW46XG4gICAgICAvLyB0aG9zZSBydWxlcyB3aWxsIGFscmVhZHkgaGF2ZSBtb3ZlZCB0aGlzIGBvZmZzZXRgIGZvcndhcmQgbWF0Y2hpbmcgdGhlaXIgbWF0Y2ggbGVuZ3RocyxcbiAgICAgIC8vIGhlbmNlIHdlIG11c3Qgb25seSBhZGQgb3VyIG93biBtYXRjaCBsZW5ndGggbm93OlxuICAgICAgdGhpcy5vZmZzZXQgKz0gbWF0Y2hfc3RyX2xlbjtcblxuICAgICAgdGhpcy5fbW9yZSA9IGZhbHNlO1xuICAgICAgdGhpcy5fYmFja3RyYWNrID0gZmFsc2U7XG4gICAgICB0aGlzLl9pbnB1dCA9IHRoaXMuX2lucHV0LnNsaWNlKG1hdGNoX3N0cl9sZW4pO1xuXG4gICAgICAvLyBjYWxsaW5nIHRoaXMgbWV0aG9kOlxuICAgICAgLy9cbiAgICAgIC8vICAgZnVuY3Rpb24gbGV4ZXJfX3BlcmZvcm1BY3Rpb24oeXksIHl5cnVsZW51bWJlciwgWVlfU1RBUlQpIHsuLi59XG4gICAgICB0b2tlbiA9IHRoaXMucGVyZm9ybUFjdGlvbi5jYWxsKFxuICAgICAgICB0aGlzLFxuICAgICAgICB0aGlzLnl5LFxuICAgICAgICBpbmRleGVkX3J1bGUsXG4gICAgICAgIHRoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxXSAvKiA9IFlZX1NUQVJUICovXG4gICAgICApO1xuXG4gICAgICAvLyBvdGhlcndpc2UsIHdoZW4gdGhlIGFjdGlvbiBjb2RlcyBhcmUgYWxsIHNpbXBsZSByZXR1cm4gdG9rZW4gc3RhdGVtZW50czpcbiAgICAgIC8vdG9rZW4gPSB0aGlzLnNpbXBsZUNhc2VBY3Rpb25DbHVzdGVyc1tpbmRleGVkX3J1bGVdO1xuXG4gICAgICBpZiAodGhpcy5kb25lICYmIHRoaXMuX2lucHV0KSB7XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9iYWNrdHJhY2spIHtcbiAgICAgICAgLy8gcmVjb3ZlciBjb250ZXh0XG4gICAgICAgIGZvciAodmFyIGsgaW4gYmFja3VwKSB7XG4gICAgICAgICAgdGhpc1trXSA9IGJhY2t1cFtrXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19jdXJyZW50UnVsZVNldF9fID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAgLy8gcnVsZSBhY3Rpb24gY2FsbGVkIHJlamVjdCgpIGltcGx5aW5nIHRoZSBuZXh0IHJ1bGUgc2hvdWxkIGJlIHRlc3RlZCBpbnN0ZWFkLiBcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fc2lnbmFsZWRfZXJyb3JfdG9rZW4pIHtcbiAgICAgICAgLy8gcHJvZHVjZSBvbmUgJ2Vycm9yJyB0b2tlbiBhcyBgLnBhcnNlRXJyb3IoKWAgaW4gYHJlamVjdCgpYFxuICAgICAgICAvLyBkaWQgbm90IGd1YXJhbnRlZSBhIGZhaWx1cmUgc2lnbmFsIGJ5IHRocm93aW5nIGFuIGV4Y2VwdGlvbiFcbiAgICAgICAgdG9rZW4gPSB0aGlzLl9zaWduYWxlZF9lcnJvcl90b2tlbjtcblxuICAgICAgICB0aGlzLl9zaWduYWxlZF9lcnJvcl90b2tlbiA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIG5leHQgbWF0Y2ggaW4gaW5wdXRcbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIG5leHQ6IGZ1bmN0aW9uIGxleGVyX25leHQoKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuRU9GO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2lucHV0KSB7XG4gICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciB0b2tlbiwgbWF0Y2gsIHRlbXBNYXRjaCwgaW5kZXg7XG5cbiAgICAgIGlmICghdGhpcy5fbW9yZSkge1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzcGVjID0gdGhpcy5fX2N1cnJlbnRSdWxlU2V0X187XG5cbiAgICAgIGlmICghc3BlYykge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHJ1bGVzZXQgY2FjaGUgYXMgd2UgYXBwYXJlbnRseSBlbmNvdW50ZXJlZCBhIHN0YXRlIGNoYW5nZSBvciBqdXN0IHN0YXJ0ZWQgbGV4aW5nLlxuICAgICAgICAvLyBUaGUgY2FjaGUgaXMgc2V0IHVwIGZvciBmYXN0IGxvb2t1cCAtLSB3ZSBhc3N1bWUgYSBsZXhlciB3aWxsIHN3aXRjaCBzdGF0ZXMgbXVjaCBsZXNzIG9mdGVuIHRoYW4gaXQgd2lsbFxuICAgICAgICAvLyBpbnZva2UgdGhlIGBsZXgoKWAgdG9rZW4tcHJvZHVjaW5nIEFQSSBhbmQgcmVsYXRlZCBBUElzLCBoZW5jZSBjYWNoaW5nIHRoZSBzZXQgZm9yIGRpcmVjdCBhY2Nlc3MgaGVscHNcbiAgICAgICAgLy8gc3BlZWQgdXAgdGhvc2UgYWN0aXZpdGllcyBhIHRpbnkgYml0LlxuICAgICAgICBzcGVjID0gdGhpcy5fX2N1cnJlbnRSdWxlU2V0X18gPSB0aGlzLl9jdXJyZW50UnVsZXMoKTtcblxuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIGEgKnNhbmUqIGNvbmRpdGlvbiBoYXMgYmVlbiBwdXNoZWQgYmVmb3JlOiB0aGlzIG1ha2VzIHRoZSBsZXhlciByb2J1c3QgYWdhaW5zdFxuICAgICAgICAvLyB1c2VyLXByb2dyYW1tZXIgYnVncyBzdWNoIGFzIGh0dHBzOi8vZ2l0aHViLmNvbS96YWFjaC9qaXNvbi1sZXgvaXNzdWVzLzE5XG4gICAgICAgIGlmICghc3BlYyB8fCAhc3BlYy5ydWxlcykge1xuICAgICAgICAgIHZhciBsaW5lbm9fbXNnID0gJyc7XG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRyYWNrUG9zaXRpb24pIHtcbiAgICAgICAgICAgIGxpbmVub19tc2cgPSAnIG9uIGxpbmUgJyArICh0aGlzLnl5bGluZW5vICsgMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHBvc19zdHIgPSAnJztcblxuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5zaG93UG9zaXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHBvc19zdHIgPSB0aGlzLnNob3dQb3NpdGlvbigpO1xuXG4gICAgICAgICAgICBpZiAocG9zX3N0ciAmJiBwb3Nfc3RyWzBdICE9PSAnXFxuJykge1xuICAgICAgICAgICAgICBwb3Nfc3RyID0gJ1xcbicgKyBwb3Nfc3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwID0gdGhpcy5jb25zdHJ1Y3RMZXhFcnJvckluZm8oXG4gICAgICAgICAgICAnSW50ZXJuYWwgbGV4ZXIgZW5naW5lIGVycm9yJyArIGxpbmVub19tc2cgKyAnOiBUaGUgbGV4IGdyYW1tYXIgcHJvZ3JhbW1lciBwdXNoZWQgYSBub24tZXhpc3RpbmcgY29uZGl0aW9uIG5hbWUgXCInICsgdGhpcy50b3BTdGF0ZSgpICsgJ1wiOyB0aGlzIGlzIGEgZmF0YWwgZXJyb3IgYW5kIHNob3VsZCBiZSByZXBvcnRlZCB0byB0aGUgYXBwbGljYXRpb24gcHJvZ3JhbW1lciB0ZWFtIScgKyBwb3Nfc3RyLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gcHJvZHVjZSBvbmUgJ2Vycm9yJyB0b2tlbiB1bnRpbCB0aGlzIHNpdHVhdGlvbiBoYXMgYmVlbiByZXNvbHZlZCwgbW9zdCBwcm9iYWJseSBieSBwYXJzZSB0ZXJtaW5hdGlvbiFcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUVycm9yKHAuZXJyU3RyLCBwLCB0aGlzLkppc29uTGV4ZXJFcnJvcikgfHwgdGhpcy5FUlJPUjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcnVsZV9pZHMgPSBzcGVjLnJ1bGVzO1xuICAgICAgdmFyIHJlZ2V4ZXMgPSBzcGVjLl9fcnVsZV9yZWdleGVzO1xuICAgICAgdmFyIGxlbiA9IHNwZWMuX19ydWxlX2NvdW50O1xuXG4gICAgICAvLyBOb3RlOiB0aGUgYXJyYXlzIGFyZSAxLWJhc2VkLCB3aGlsZSBgbGVuYCBpdHNlbGYgaXMgYSB2YWxpZCBpbmRleCxcbiAgICAgIC8vIGhlbmNlIHRoZSBub24tc3RhbmRhcmQgbGVzcy1vci1lcXVhbCBjaGVjayBpbiB0aGUgbmV4dCBsb29wIGNvbmRpdGlvbiFcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IGxlbjsgaSsrKSB7XG4gICAgICAgIHRlbXBNYXRjaCA9IHRoaXMuX2lucHV0Lm1hdGNoKHJlZ2V4ZXNbaV0pO1xuXG4gICAgICAgIGlmICh0ZW1wTWF0Y2ggJiYgKCFtYXRjaCB8fCB0ZW1wTWF0Y2hbMF0ubGVuZ3RoID4gbWF0Y2hbMF0ubGVuZ3RoKSkge1xuICAgICAgICAgIG1hdGNoID0gdGVtcE1hdGNoO1xuICAgICAgICAgIGluZGV4ID0gaTtcblxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmFja3RyYWNrX2xleGVyKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMudGVzdF9tYXRjaCh0ZW1wTWF0Y2gsIHJ1bGVfaWRzW2ldKTtcblxuICAgICAgICAgICAgaWYgKHRva2VuICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JhY2t0cmFjaykge1xuICAgICAgICAgICAgICBtYXRjaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgY29udGludWU7ICAvLyBydWxlIGFjdGlvbiBjYWxsZWQgcmVqZWN0KCkgaW1wbHlpbmcgYSBydWxlIE1JU21hdGNoLiBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGVsc2U6IHRoaXMgaXMgYSBsZXhlciBydWxlIHdoaWNoIGNvbnN1bWVzIGlucHV0IHdpdGhvdXQgcHJvZHVjaW5nIGEgdG9rZW4gKGUuZy4gd2hpdGVzcGFjZSlcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMub3B0aW9ucy5mbGV4KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHRva2VuID0gdGhpcy50ZXN0X21hdGNoKG1hdGNoLCBydWxlX2lkc1tpbmRleF0pO1xuXG4gICAgICAgIGlmICh0b2tlbiAhPT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbHNlOiB0aGlzIGlzIGEgbGV4ZXIgcnVsZSB3aGljaCBjb25zdW1lcyBpbnB1dCB3aXRob3V0IHByb2R1Y2luZyBhIHRva2VuIChlLmcuIHdoaXRlc3BhY2UpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9pbnB1dCkge1xuICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIHJldHVybiB0aGlzLkVPRjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBsaW5lbm9fbXNnID0gJyc7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmFja1Bvc2l0aW9uKSB7XG4gICAgICAgICAgbGluZW5vX21zZyA9ICcgb24gbGluZSAnICsgKHRoaXMueXlsaW5lbm8gKyAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb3Nfc3RyID0gJyc7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnNob3dQb3NpdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHBvc19zdHIgPSB0aGlzLnNob3dQb3NpdGlvbigpO1xuXG4gICAgICAgICAgaWYgKHBvc19zdHIgJiYgcG9zX3N0clswXSAhPT0gJ1xcbicpIHtcbiAgICAgICAgICAgIHBvc19zdHIgPSAnXFxuJyArIHBvc19zdHI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHAgPSB0aGlzLmNvbnN0cnVjdExleEVycm9ySW5mbyhcbiAgICAgICAgICAnTGV4aWNhbCBlcnJvcicgKyBsaW5lbm9fbXNnICsgJzogVW5yZWNvZ25pemVkIHRleHQuJyArIHBvc19zdHIsXG4gICAgICAgICAgdGhpcy5vcHRpb25zLmxleGVyRXJyb3JzQXJlUmVjb3ZlcmFibGVcbiAgICAgICAgKTtcblxuICAgICAgICB0b2tlbiA9IHRoaXMucGFyc2VFcnJvcihwLmVyclN0ciwgcCwgdGhpcy5KaXNvbkxleGVyRXJyb3IpIHx8IHRoaXMuRVJST1I7XG5cbiAgICAgICAgaWYgKHRva2VuID09PSB0aGlzLkVSUk9SKSB7XG4gICAgICAgICAgLy8gd2UgY2FuIHRyeSB0byByZWNvdmVyIGZyb20gYSBsZXhlciBlcnJvciB0aGF0IGBwYXJzZUVycm9yKClgIGRpZCBub3QgJ3JlY292ZXInIGZvciB1c1xuICAgICAgICAgIC8vIGJ5IG1vdmluZyBmb3J3YXJkIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIgYXQgYSB0aW1lOlxuICAgICAgICAgIGlmICghdGhpcy5tYXRjaC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiBuZXh0IG1hdGNoIHRoYXQgaGFzIGEgdG9rZW5cbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIGxleDogZnVuY3Rpb24gbGV4ZXJfbGV4KCkge1xuICAgICAgdmFyIHI7XG5cbiAgICAgIC8vIGFsbG93IHRoZSBQUkUvUE9TVCBoYW5kbGVycyBzZXQvbW9kaWZ5IHRoZSByZXR1cm4gdG9rZW4gZm9yIG1heGltdW0gZmxleGliaWxpdHkgb2YgdGhlIGdlbmVyYXRlZCBsZXhlcjpcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnByZV9sZXggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgciA9IHRoaXMub3B0aW9ucy5wcmVfbGV4LmNhbGwodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICghcikge1xuICAgICAgICByID0gdGhpcy5uZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnBvc3RfbGV4ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIChhbHNvIGFjY291bnQgZm9yIGEgdXNlcmRlZiBmdW5jdGlvbiB3aGljaCBkb2VzIG5vdCByZXR1cm4gYW55IHZhbHVlOiBrZWVwIHRoZSB0b2tlbiBhcyBpcylcbiAgICAgICAgciA9IHRoaXMub3B0aW9ucy5wb3N0X2xleC5jYWxsKHRoaXMsIHIpIHx8IHI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBiYWNrd2FyZHMgY29tcGF0aWJsZSBhbGlhcyBmb3IgYHB1c2hTdGF0ZSgpYDtcbiAgICAgKiB0aGUgbGF0dGVyIGlzIHN5bW1ldHJpY2FsIHdpdGggYHBvcFN0YXRlKClgIGFuZCB3ZSBhZHZpc2UgdG8gdXNlXG4gICAgICogdGhvc2UgQVBJcyBpbiBhbnkgbW9kZXJuIGxleGVyIGNvZGUsIHJhdGhlciB0aGFuIGBiZWdpbigpYC5cbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIGJlZ2luOiBmdW5jdGlvbiBsZXhlcl9iZWdpbihjb25kaXRpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLnB1c2hTdGF0ZShjb25kaXRpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBhY3RpdmF0ZXMgYSBuZXcgbGV4ZXIgY29uZGl0aW9uIHN0YXRlIChwdXNoZXMgdGhlIG5ldyBsZXhlclxuICAgICAqIGNvbmRpdGlvbiBzdGF0ZSBvbnRvIHRoZSBjb25kaXRpb24gc3RhY2spXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBwdXNoU3RhdGU6IGZ1bmN0aW9uIGxleGVyX3B1c2hTdGF0ZShjb25kaXRpb24pIHtcbiAgICAgIHRoaXMuY29uZGl0aW9uU3RhY2sucHVzaChjb25kaXRpb24pO1xuICAgICAgdGhpcy5fX2N1cnJlbnRSdWxlU2V0X18gPSBudWxsO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHBvcCB0aGUgcHJldmlvdXNseSBhY3RpdmUgbGV4ZXIgY29uZGl0aW9uIHN0YXRlIG9mZiB0aGUgY29uZGl0aW9uXG4gICAgICogc3RhY2tcbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIHBvcFN0YXRlOiBmdW5jdGlvbiBsZXhlcl9wb3BTdGF0ZSgpIHtcbiAgICAgIHZhciBuID0gdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxO1xuXG4gICAgICBpZiAobiA+IDApIHtcbiAgICAgICAgdGhpcy5fX2N1cnJlbnRSdWxlU2V0X18gPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFjay5wb3AoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrWzBdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gdGhlIGN1cnJlbnRseSBhY3RpdmUgbGV4ZXIgY29uZGl0aW9uIHN0YXRlOyB3aGVuIGFuIGluZGV4XG4gICAgICogYXJndW1lbnQgaXMgcHJvdmlkZWQgaXQgcHJvZHVjZXMgdGhlIE4tdGggcHJldmlvdXMgY29uZGl0aW9uIHN0YXRlLFxuICAgICAqIGlmIGF2YWlsYWJsZVxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgdG9wU3RhdGU6IGZ1bmN0aW9uIGxleGVyX3RvcFN0YXRlKG4pIHtcbiAgICAgIG4gPSB0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDEgLSBNYXRoLmFicyhuIHx8IDApO1xuXG4gICAgICBpZiAobiA+PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrW25dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICdJTklUSUFMJztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogKGludGVybmFsKSBkZXRlcm1pbmUgdGhlIGxleGVyIHJ1bGUgc2V0IHdoaWNoIGlzIGFjdGl2ZSBmb3IgdGhlXG4gICAgICogY3VycmVudGx5IGFjdGl2ZSBsZXhlciBjb25kaXRpb24gc3RhdGVcbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIF9jdXJyZW50UnVsZXM6IGZ1bmN0aW9uIGxleGVyX19jdXJyZW50UnVsZXMoKSB7XG4gICAgICBpZiAodGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggJiYgdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvbnNbdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDFdXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvbnNbJ0lOSVRJQUwnXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBudW1iZXIgb2Ygc3RhdGVzIGN1cnJlbnRseSBvbiB0aGUgc3RhY2tcbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIHN0YXRlU3RhY2tTaXplOiBmdW5jdGlvbiBsZXhlcl9zdGF0ZVN0YWNrU2l6ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgb3B0aW9uczoge1xuICAgICAgZmxleDogdHJ1ZSxcbiAgICAgIHRyYWNrUG9zaXRpb246IHRydWUsXG4gICAgICBwYXJzZUFjdGlvbnNVc2VZWU1FUkdFTE9DQVRJT05JTkZPOiB0cnVlXG4gICAgfSxcblxuICAgIEppc29uTGV4ZXJFcnJvcjogSmlzb25MZXhlckVycm9yLFxuXG4gICAgcGVyZm9ybUFjdGlvbjogZnVuY3Rpb24gbGV4ZXJfX3BlcmZvcm1BY3Rpb24oeXksIHl5cnVsZW51bWJlciwgWVlfU1RBUlQpIHtcbiAgICAgIHZhciB5eV8gPSB0aGlzO1xuICAgICAgdmFyIFlZU1RBVEUgPSBZWV9TVEFSVDtcblxuICAgICAgc3dpdGNoICh5eXJ1bGVudW1iZXIpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgLyohIENvbmRpdGlvbnM6OiAqICovXG4gICAgICAgIC8qISBSdWxlOjogICAgICAgXFxzKyAqL1xuICAgICAgICByZXR1cm47XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNTpcbiAgICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAgIC8qISBSdWxlOjogICAgICAgXFx7JSAqL1xuICAgICAgICB0aGlzLmJlZ2luKCdDT05UUk9MJyk7XG5cbiAgICAgICAgcmV0dXJuIDI4O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA2OlxuICAgICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgICAgLyohIFJ1bGU6OiAgICAgICA8IS0tICovXG4gICAgICAgIHRoaXMuYmVnaW4oJ0NPTU1FTlQnKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDc6XG4gICAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgICAvKiEgUnVsZTo6ICAgICAgIDwgKi9cbiAgICAgICAgdGhpcy5iZWdpbignVEFHJyk7XG5cbiAgICAgICAgcmV0dXJuIDEzO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA4OlxuICAgICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgICAgLyohIFJ1bGU6OiAgICAgICBcXHtcXHsgKi9cbiAgICAgICAgdGhpcy5iZWdpbignRVhQUkVTU0lPTicpO1xuXG4gICAgICAgIHJldHVybiAzOTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMTc6XG4gICAgICAgIC8qISBDb25kaXRpb25zOjogVEFHICovXG4gICAgICAgIC8qISBSdWxlOjogICAgICAgXFwvPiAqL1xuICAgICAgICB0aGlzLnBvcFN0YXRlKCk7XG5cbiAgICAgICAgcmV0dXJuIDM4O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAxOTpcbiAgICAgICAgLyohIENvbmRpdGlvbnM6OiBUQUcgKi9cbiAgICAgICAgLyohIFJ1bGU6OiAgICAgICA+ICovXG4gICAgICAgIHRoaXMuYmVnaW4oJ0NISUxEUkVOJyk7XG5cbiAgICAgICAgcmV0dXJuIDE0O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAyMDpcbiAgICAgICAgLyohIENvbmRpdGlvbnM6OiBUQUcgKi9cbiAgICAgICAgLyohIFJ1bGU6OiAgICAgICBcXHtcXHsgKi9cbiAgICAgICAgdGhpcy5iZWdpbignRVhQUkVTU0lPTicpO1xuXG4gICAgICAgIHJldHVybiAzOTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMjM6XG4gICAgICAgIC8qISBDb25kaXRpb25zOjogQ0hJTERSRU4gKi9cbiAgICAgICAgLyohIFJ1bGU6OiAgICAgICBcXHtcXHsgKi9cbiAgICAgICAgdGhpcy5iZWdpbignRVhQUkVTU0lPTicpO1xuXG4gICAgICAgIHJldHVybiAzOTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMjQ6XG4gICAgICAgIC8qISBDb25kaXRpb25zOjogQ0hJTERSRU4gKi9cbiAgICAgICAgLyohIFJ1bGU6OiAgICAgICBcXHslICovXG4gICAgICAgIHRoaXMuYmVnaW4oJ0NPTlRST0wnKTtcblxuICAgICAgICByZXR1cm4gMjg7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDI1OlxuICAgICAgICAvKiEgQ29uZGl0aW9uczo6IENISUxEUkVOICovXG4gICAgICAgIC8qISBSdWxlOjogICAgICAgPCEtLSAqL1xuICAgICAgICB0aGlzLmJlZ2luKCdDT01NRU5UJyk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAyNjpcbiAgICAgICAgLyohIENvbmRpdGlvbnM6OiBDSElMRFJFTiAqL1xuICAgICAgICAvKiEgUnVsZTo6ICAgICAgIDxcXC8gKi9cbiAgICAgICAgdGhpcy5iZWdpbignVEFHJyk7XG5cbiAgICAgICAgcmV0dXJuIDM3O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAyNzpcbiAgICAgICAgLyohIENvbmRpdGlvbnM6OiBDSElMRFJFTiAqL1xuICAgICAgICAvKiEgUnVsZTo6ICAgICAgIDwgKi9cbiAgICAgICAgdGhpcy5iZWdpbignVEFHJyk7XG5cbiAgICAgICAgcmV0dXJuIDEzO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA1NzpcbiAgICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAgIC8qISBSdWxlOjogICAgICAgPSAqL1xuICAgICAgICB0aGlzLnBvcFN0YXRlKCk7XG5cbiAgICAgICAgdGhpcy5iZWdpbignQ09OVFJPTF9DSElMRCcpO1xuICAgICAgICByZXR1cm4gOTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNjA6XG4gICAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgICAvKiEgUnVsZTo6ICAgICAgICVcXH0gKi9cbiAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xuXG4gICAgICAgIHJldHVybiAzMDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNjM6XG4gICAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTF9DSElMRCAqL1xuICAgICAgICAvKiEgUnVsZTo6ICAgICAgIDwgKi9cbiAgICAgICAgdGhpcy5iZWdpbignVEFHJyk7XG5cbiAgICAgICAgcmV0dXJuIDEzO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA2NDpcbiAgICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MX0NISUxEICovXG4gICAgICAgIC8qISBSdWxlOjogICAgICAgXFx7XFx7ICovXG4gICAgICAgIHRoaXMuYmVnaW4oJ0VYUFJFU1NJT04nKTtcblxuICAgICAgICByZXR1cm4gMzk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDY1OlxuICAgICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0xfQ0hJTEQgKi9cbiAgICAgICAgLyohIFJ1bGU6OiAgICAgICAlXFx9ICovXG4gICAgICAgIHRoaXMucG9wU3RhdGUoKTtcblxuICAgICAgICByZXR1cm4gMzA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDgzOlxuICAgICAgICAvKiEgQ29uZGl0aW9uczo6IEVYUFJFU1NJT04gKi9cbiAgICAgICAgLyohIFJ1bGU6OiAgICAgICBcXH1cXH0gKi9cbiAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xuXG4gICAgICAgIHJldHVybiA0MDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgODY6XG4gICAgICAgIC8qISBDb25kaXRpb25zOjogQ09NTUVOVCAqL1xuICAgICAgICAvKiEgUnVsZTo6ICAgICAgICgufFxccnxcXG4pKj8tLT4gKi9cbiAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMTE1OlxuICAgICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgICAgLyohIFJ1bGU6OiAgICAgICAuICovXG4gICAgICAgIGNvbnNvbGUubG9nKCcnLCB5eV8ueXl0ZXh0KTtcblxuICAgICAgICAvKiBgZmxleGAgbGV4aW5nIG1vZGU6IHRoZSBsYXN0IHJlc29ydCBydWxlISAqL1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMuc2ltcGxlQ2FzZUFjdGlvbkNsdXN0ZXJzW3l5cnVsZW51bWJlcl07XG4gICAgICB9XG4gICAgfSxcblxuICAgIHNpbXBsZUNhc2VBY3Rpb25DbHVzdGVyczoge1xuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGltcG9ydCAqL1xuICAgICAgMTogMjUsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBmcm9tICovXG4gICAgICAyOiAyNixcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIHVzaW5nICovXG4gICAgICAzOiAnVVNJTkcnLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgYXMgKi9cbiAgICAgIDQ6IDI3LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAge0NvbnN0cnVjdG9yfSAqL1xuICAgICAgOTogNTYsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICB7SWRlbnRpZmllcn0gKi9cbiAgICAgIDEwOiA1NSxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIFxceyAqL1xuICAgICAgMTE6IDQsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBcXH0gKi9cbiAgICAgIDEyOiA1LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IFRBRyAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICB0cnVlICovXG4gICAgICAxMzogNTMsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogVEFHICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGZhbHNlICovXG4gICAgICAxNDogNTQsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogVEFHICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIHtDb25zdHJ1Y3Rvcn0gKi9cbiAgICAgIDE1OiA1NixcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBUQUcgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAge0lkZW50aWZpZXJ9ICovXG4gICAgICAxNjogNTUsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogVEFHICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIFxcLyAqL1xuICAgICAgMTg6ICdOT1NFJyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBUQUcgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFx7ICovXG4gICAgICAyMTogNCxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBUQUcgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFx9ICovXG4gICAgICAyMjogNSxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDSElMRFJFTiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBcXHsgKi9cbiAgICAgIDI4OiA0LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENISUxEUkVOICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIFxcfSAqL1xuICAgICAgMjk6IDUsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ0hJTERSRU4gKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgW14vPD57JX1dKyAqL1xuICAgICAgMzA6IDQ3LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0wgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgbWFpbiAqL1xuICAgICAgMzE6IDI5LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0wgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgZW5kbWFpbiAqL1xuICAgICAgMzI6IDMxLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0wgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgbWFjcm8gKi9cbiAgICAgIDMzOiAnTUFDUk8nLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0wgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgZW5kbWFjcm8gKi9cbiAgICAgIDM0OiAnRU5ETUFDUk8nLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0wgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgZm9yICovXG4gICAgICAzNTogNDEsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBlbmRmb3IgKi9cbiAgICAgIDM2OiA0MyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGlmICovXG4gICAgICAzNzogNDUsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBlbmRpZiAqL1xuICAgICAgMzg6IDQ2LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0wgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgZWxzZSAqL1xuICAgICAgMzk6IDQ0LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0wgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgZWxzZWlmICovXG4gICAgICA0MDogJ0VMU0VJRicsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBpbiAqL1xuICAgICAgNDE6IDQyLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0wgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgY2FzZSAqL1xuICAgICAgNDI6ICdDQVNFJyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGVuZGNhc2UgKi9cbiAgICAgIDQzOiAnRU5EQ0FTRScsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBleHBvcnQgKi9cbiAgICAgIDQ0OiAzMixcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGZyb20gKi9cbiAgICAgIDQ1OiAyNixcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIHZpZXcgKi9cbiAgICAgIDQ2OiAzMyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIHVzaW5nICovXG4gICAgICA0NzogJ1VTSU5HJyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGVuZHZpZXcgKi9cbiAgICAgIDQ4OiAzNCxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGluc3RhbmNlb2YgKi9cbiAgICAgIDQ5OiA2MyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIHRoaXMgKi9cbiAgICAgIDUwOiAnVEhJUycsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBmdW4gKi9cbiAgICAgIDUxOiAzNSxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGVuZGZ1biAqL1xuICAgICAgNTI6IDM2LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0wgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgYXMgKi9cbiAgICAgIDUzOiAyNyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIDo6ICovXG4gICAgICA1NDogJzo6JyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIEAgKi9cbiAgICAgIDU1OiAxOSxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIFxcKFxcKSAqL1xuICAgICAgNTY6ICcoKScsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICB7Q29uc3RydWN0b3J9ICovXG4gICAgICA1ODogNTYsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICB7SWRlbnRpZmllcn0gKi9cbiAgICAgIDU5OiA1NSxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIFxceyAqL1xuICAgICAgNjE6IDQsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBcXH0gKi9cbiAgICAgIDYyOiA1LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0xfQ0hJTEQgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAge0NvbnN0cnVjdG9yfSAqL1xuICAgICAgNjY6IDU2LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0xfQ0hJTEQgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAge0lkZW50aWZpZXJ9ICovXG4gICAgICA2NzogNTUsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTF9DSElMRCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBcXHsgKi9cbiAgICAgIDY4OiA0LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0xfQ0hJTEQgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFx9ICovXG4gICAgICA2OTogNSxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBFWFBSRVNTSU9OICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIFxcfCAqL1xuICAgICAgNzA6IDE1LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IEVYUFJFU1NJT04gKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgPT4gKi9cbiAgICAgIDcxOiA1MCxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBFWFBSRVNTSU9OICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIC0+ICovXG4gICAgICA3MjogJy0+JyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBFWFBSRVNTSU9OICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIEAgKi9cbiAgICAgIDczOiAxOSxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBFWFBSRVNTSU9OICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGluc3RhbmNlb2YgKi9cbiAgICAgIDc0OiA2MyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBFWFBSRVNTSU9OICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIHRydWUgKi9cbiAgICAgIDc1OiA1MyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBFWFBSRVNTSU9OICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGZhbHNlICovXG4gICAgICA3NjogNTQsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogRVhQUkVTU0lPTiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBpZiAqL1xuICAgICAgNzc6IDQ1LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IEVYUFJFU1NJT04gKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgdGhlbiAqL1xuICAgICAgNzg6IDQ4LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IEVYUFJFU1NJT04gKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgZWxzZSAqL1xuICAgICAgNzk6IDQ0LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IEVYUFJFU1NJT04gKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgYXMgKi9cbiAgICAgIDgwOiAyNyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBFWFBSRVNTSU9OICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIHtDb25zdHJ1Y3Rvcn0gKi9cbiAgICAgIDgxOiA1NixcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBFWFBSRVNTSU9OICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIHtJZGVudGlmaWVyfSAqL1xuICAgICAgODI6IDU1LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IEVYUFJFU1NJT04gKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFx7ICovXG4gICAgICA4NDogNCxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBFWFBSRVNTSU9OICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIFxcfSAqL1xuICAgICAgODU6IDUsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogKiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICB7TnVtYmVyTGl0ZXJhbH0gKi9cbiAgICAgIDg3OiA1MixcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiAqICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIHtTdHJpbmdMaXRlcmFsfSAqL1xuICAgICAgODg6IDUxLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgPiAqL1xuICAgICAgODk6IDE0LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgPCAqL1xuICAgICAgOTA6IDEzLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFwoICovXG4gICAgICA5MTogNyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiAqICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIFxcKSAqL1xuICAgICAgOTI6IDgsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogKiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBcXFsgKi9cbiAgICAgIDkzOiAxMCxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiAqICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIFxcXSAqL1xuICAgICAgOTQ6IDExLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgOyAqL1xuICAgICAgOTU6IDIwLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgOiAqL1xuICAgICAgOTY6IDEyLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgPSAqL1xuICAgICAgOTc6IDksXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogKiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICA9PSAqL1xuICAgICAgOTg6IDU5LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgIT0gKi9cbiAgICAgIDk5OiA2MCxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiAqICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgID49ICovXG4gICAgICAxMDA6IDU3LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgPD0gKi9cbiAgICAgIDEwMTogNTgsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogKiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBcXCsgKi9cbiAgICAgIDEwMjogMjEsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogKiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICAtICovXG4gICAgICAxMDM6IDIzLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFwqICovXG4gICAgICAxMDQ6IDMsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogKiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBcXC8gKi9cbiAgICAgIDEwNTogMjIsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogKiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBcXFxcICovXG4gICAgICAxMDY6IDQ5LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgJiYgKi9cbiAgICAgIDEwNzogNjEsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogKiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBcXHxcXHwgKi9cbiAgICAgIDEwODogNjIsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogKiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBcXF4gKi9cbiAgICAgIDEwOTogMjQsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogKiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICAhICovXG4gICAgICAxMTA6IDE2LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgLCAqL1xuICAgICAgMTExOiA2LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFw/ICovXG4gICAgICAxMTI6IDE4LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFwuICovXG4gICAgICAxMTM6IDE3LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgJCAqL1xuICAgICAgMTE0OiAxXG4gICAgfSxcblxuICAgIHJ1bGVzOiBbXG4gICAgICAvKiAgIDA6ICovICAvXig/OlxccyspLyxcbiAgICAgIC8qICAgMTogKi8gIC9eKD86aW1wb3J0KS8sXG4gICAgICAvKiAgIDI6ICovICAvXig/OmZyb20pLyxcbiAgICAgIC8qICAgMzogKi8gIC9eKD86dXNpbmcpLyxcbiAgICAgIC8qICAgNDogKi8gIC9eKD86YXMpLyxcbiAgICAgIC8qICAgNTogKi8gIC9eKD86XFx7JSkvLFxuICAgICAgLyogICA2OiAqLyAgL14oPzo8IS0tKS8sXG4gICAgICAvKiAgIDc6ICovICAvXig/OjwpLyxcbiAgICAgIC8qICAgODogKi8gIC9eKD86XFx7XFx7KS8sXG4gICAgICAvKiAgIDk6ICovICAvXig/OihbQS1aXVtcXHckXFwtXSopKS8sXG4gICAgICAvKiAgMTA6ICovICAvXig/OihbJF9hLXpdW1xcdyRcXC1dKikpLyxcbiAgICAgIC8qICAxMTogKi8gIC9eKD86XFx7KS8sXG4gICAgICAvKiAgMTI6ICovICAvXig/OlxcfSkvLFxuICAgICAgLyogIDEzOiAqLyAgL14oPzp0cnVlKS8sXG4gICAgICAvKiAgMTQ6ICovICAvXig/OmZhbHNlKS8sXG4gICAgICAvKiAgMTU6ICovICAvXig/OihbQS1aXVtcXHckXFwtXSopKS8sXG4gICAgICAvKiAgMTY6ICovICAvXig/OihbJF9hLXpdW1xcdyRcXC1dKikpLyxcbiAgICAgIC8qICAxNzogKi8gIC9eKD86XFwvPikvLFxuICAgICAgLyogIDE4OiAqLyAgL14oPzpcXC8pLyxcbiAgICAgIC8qICAxOTogKi8gIC9eKD86PikvLFxuICAgICAgLyogIDIwOiAqLyAgL14oPzpcXHtcXHspLyxcbiAgICAgIC8qICAyMTogKi8gIC9eKD86XFx7KS8sXG4gICAgICAvKiAgMjI6ICovICAvXig/OlxcfSkvLFxuICAgICAgLyogIDIzOiAqLyAgL14oPzpcXHtcXHspLyxcbiAgICAgIC8qICAyNDogKi8gIC9eKD86XFx7JSkvLFxuICAgICAgLyogIDI1OiAqLyAgL14oPzo8IS0tKS8sXG4gICAgICAvKiAgMjY6ICovICAvXig/OjxcXC8pLyxcbiAgICAgIC8qICAyNzogKi8gIC9eKD86PCkvLFxuICAgICAgLyogIDI4OiAqLyAgL14oPzpcXHspLyxcbiAgICAgIC8qICAyOTogKi8gIC9eKD86XFx9KS8sXG4gICAgICAvKiAgMzA6ICovICAvXig/OlteXFwvPD57JX1dKykvLFxuICAgICAgLyogIDMxOiAqLyAgL14oPzptYWluKS8sXG4gICAgICAvKiAgMzI6ICovICAvXig/OmVuZG1haW4pLyxcbiAgICAgIC8qICAzMzogKi8gIC9eKD86bWFjcm8pLyxcbiAgICAgIC8qICAzNDogKi8gIC9eKD86ZW5kbWFjcm8pLyxcbiAgICAgIC8qICAzNTogKi8gIC9eKD86Zm9yKS8sXG4gICAgICAvKiAgMzY6ICovICAvXig/OmVuZGZvcikvLFxuICAgICAgLyogIDM3OiAqLyAgL14oPzppZikvLFxuICAgICAgLyogIDM4OiAqLyAgL14oPzplbmRpZikvLFxuICAgICAgLyogIDM5OiAqLyAgL14oPzplbHNlKS8sXG4gICAgICAvKiAgNDA6ICovICAvXig/OmVsc2VpZikvLFxuICAgICAgLyogIDQxOiAqLyAgL14oPzppbikvLFxuICAgICAgLyogIDQyOiAqLyAgL14oPzpjYXNlKS8sXG4gICAgICAvKiAgNDM6ICovICAvXig/OmVuZGNhc2UpLyxcbiAgICAgIC8qICA0NDogKi8gIC9eKD86ZXhwb3J0KS8sXG4gICAgICAvKiAgNDU6ICovICAvXig/OmZyb20pLyxcbiAgICAgIC8qICA0NjogKi8gIC9eKD86dmlldykvLFxuICAgICAgLyogIDQ3OiAqLyAgL14oPzp1c2luZykvLFxuICAgICAgLyogIDQ4OiAqLyAgL14oPzplbmR2aWV3KS8sXG4gICAgICAvKiAgNDk6ICovICAvXig/Omluc3RhbmNlb2YpLyxcbiAgICAgIC8qICA1MDogKi8gIC9eKD86dGhpcykvLFxuICAgICAgLyogIDUxOiAqLyAgL14oPzpmdW4pLyxcbiAgICAgIC8qICA1MjogKi8gIC9eKD86ZW5kZnVuKS8sXG4gICAgICAvKiAgNTM6ICovICAvXig/OmFzKS8sXG4gICAgICAvKiAgNTQ6ICovICAvXig/Ojo6KS8sXG4gICAgICAvKiAgNTU6ICovICAvXig/OkApLyxcbiAgICAgIC8qICA1NjogKi8gIC9eKD86XFwoXFwpKS8sXG4gICAgICAvKiAgNTc6ICovICAvXig/Oj0pLyxcbiAgICAgIC8qICA1ODogKi8gIC9eKD86KFtBLVpdW1xcdyRcXC1dKikpLyxcbiAgICAgIC8qICA1OTogKi8gIC9eKD86KFskX2Etel1bXFx3JFxcLV0qKSkvLFxuICAgICAgLyogIDYwOiAqLyAgL14oPzolXFx9KS8sXG4gICAgICAvKiAgNjE6ICovICAvXig/OlxceykvLFxuICAgICAgLyogIDYyOiAqLyAgL14oPzpcXH0pLyxcbiAgICAgIC8qICA2MzogKi8gIC9eKD86PCkvLFxuICAgICAgLyogIDY0OiAqLyAgL14oPzpcXHtcXHspLyxcbiAgICAgIC8qICA2NTogKi8gIC9eKD86JVxcfSkvLFxuICAgICAgLyogIDY2OiAqLyAgL14oPzooW0EtWl1bXFx3JFxcLV0qKSkvLFxuICAgICAgLyogIDY3OiAqLyAgL14oPzooWyRfYS16XVtcXHckXFwtXSopKS8sXG4gICAgICAvKiAgNjg6ICovICAvXig/OlxceykvLFxuICAgICAgLyogIDY5OiAqLyAgL14oPzpcXH0pLyxcbiAgICAgIC8qICA3MDogKi8gIC9eKD86XFx8KS8sXG4gICAgICAvKiAgNzE6ICovICAvXig/Oj0+KS8sXG4gICAgICAvKiAgNzI6ICovICAvXig/Oi0+KS8sXG4gICAgICAvKiAgNzM6ICovICAvXig/OkApLyxcbiAgICAgIC8qICA3NDogKi8gIC9eKD86aW5zdGFuY2VvZikvLFxuICAgICAgLyogIDc1OiAqLyAgL14oPzp0cnVlKS8sXG4gICAgICAvKiAgNzY6ICovICAvXig/OmZhbHNlKS8sXG4gICAgICAvKiAgNzc6ICovICAvXig/OmlmKS8sXG4gICAgICAvKiAgNzg6ICovICAvXig/OnRoZW4pLyxcbiAgICAgIC8qICA3OTogKi8gIC9eKD86ZWxzZSkvLFxuICAgICAgLyogIDgwOiAqLyAgL14oPzphcykvLFxuICAgICAgLyogIDgxOiAqLyAgL14oPzooW0EtWl1bXFx3JFxcLV0qKSkvLFxuICAgICAgLyogIDgyOiAqLyAgL14oPzooWyRfYS16XVtcXHckXFwtXSopKS8sXG4gICAgICAvKiAgODM6ICovICAvXig/OlxcfVxcfSkvLFxuICAgICAgLyogIDg0OiAqLyAgL14oPzpcXHspLyxcbiAgICAgIC8qICA4NTogKi8gIC9eKD86XFx9KS8sXG4gICAgICAvKiAgODY6ICovICAvXig/OigufFxccnxcXG4pKj8tLT4pLyxcbiAgICAgIC8qICA4NzogKi8gIC9eKD86KCg/OihbLV0/KD86Wy1dPyhbMF18KCg/OlsxLTldKSg/OlxcZCspKikpKVxcLig/OlxcZCspKig/Oig/OltFZV0pKD86WystXT9cXGQrKSk/KXwoXFwuKD86XFxkKykoPzooPzpbRWVdKSg/OlsrLV0/XFxkKykpPyl8KCg/OlstXT8oWzBdfCgoPzpbMS05XSkoPzpcXGQrKSopKSkoPzooPzpbRWVdKSg/OlsrLV0/XFxkKykpPykpfCg/OlswXVtYeF0oPzpbXFxkQS1GYS1mXSkrKXwoPzpbMF0oPzpbMC03XSkrKSkpLyxcbiAgICAgIC8qICA4ODogKi8gIC9eKD86KChcIig/OihbXlxcblxcclwiXFxcXF0rKXwoXFxcXCg/Oig/Oig/OltcIidcXFxcYmZucnR2XSl8KD86W15cXGRcIidcXFxcYmZucnQtdnhdKSl8KD86KD86WzEtN11bMC03XXswLDJ9fFswLTddezIsM30pKXwoPzpbeF0oPzpbXFxkQS1GYS1mXSl7Mn0pfCg/Olt1XSg/OltcXGRBLUZhLWZdKXs0fSkpKXwoPzpcXFxcKFxcclxcbnxcXHJ8XFxuKSkpKlwiKXwoJyg/OihbXlxcblxccidcXFxcXSspfChcXFxcKD86KD86KD86W1wiJ1xcXFxiZm5ydHZdKXwoPzpbXlxcZFwiJ1xcXFxiZm5ydC12eF0pKXwoPzooPzpbMS03XVswLTddezAsMn18WzAtN117MiwzfSkpfCg/Olt4XSg/OltcXGRBLUZhLWZdKXsyfSl8KD86W3VdKD86W1xcZEEtRmEtZl0pezR9KSkpfCg/OlxcXFwoXFxyXFxufFxccnxcXG4pKSkqJyl8KGAoPzooW15cXG5cXHJcXFxcYF0rKXwoXFxcXCg/Oig/Oig/OltcIidcXFxcYmZucnR2XSl8KD86W15cXGRcIidcXFxcYmZucnQtdnhdKSl8KD86KD86WzEtN11bMC03XXswLDJ9fFswLTddezIsM30pKXwoPzpbeF0oPzpbXFxkQS1GYS1mXSl7Mn0pfCg/Olt1XSg/OltcXGRBLUZhLWZdKXs0fSkpKXwoPzpcXFxcKFxcclxcbnxcXHJ8XFxuKSkpKmApKSkvLFxuICAgICAgLyogIDg5OiAqLyAgL14oPzo+KS8sXG4gICAgICAvKiAgOTA6ICovICAvXig/OjwpLyxcbiAgICAgIC8qICA5MTogKi8gIC9eKD86XFwoKS8sXG4gICAgICAvKiAgOTI6ICovICAvXig/OlxcKSkvLFxuICAgICAgLyogIDkzOiAqLyAgL14oPzpcXFspLyxcbiAgICAgIC8qICA5NDogKi8gIC9eKD86XFxdKS8sXG4gICAgICAvKiAgOTU6ICovICAvXig/OjspLyxcbiAgICAgIC8qICA5NjogKi8gIC9eKD86OikvLFxuICAgICAgLyogIDk3OiAqLyAgL14oPzo9KS8sXG4gICAgICAvKiAgOTg6ICovICAvXig/Oj09KS8sXG4gICAgICAvKiAgOTk6ICovICAvXig/OiE9KS8sXG4gICAgICAvKiAxMDA6ICovICAvXig/Oj49KS8sXG4gICAgICAvKiAxMDE6ICovICAvXig/Ojw9KS8sXG4gICAgICAvKiAxMDI6ICovICAvXig/OlxcKykvLFxuICAgICAgLyogMTAzOiAqLyAgL14oPzotKS8sXG4gICAgICAvKiAxMDQ6ICovICAvXig/OlxcKikvLFxuICAgICAgLyogMTA1OiAqLyAgL14oPzpcXC8pLyxcbiAgICAgIC8qIDEwNjogKi8gIC9eKD86XFxcXCkvLFxuICAgICAgLyogMTA3OiAqLyAgL14oPzomJikvLFxuICAgICAgLyogMTA4OiAqLyAgL14oPzpcXHxcXHwpLyxcbiAgICAgIC8qIDEwOTogKi8gIC9eKD86XFxeKS8sXG4gICAgICAvKiAxMTA6ICovICAvXig/OiEpLyxcbiAgICAgIC8qIDExMTogKi8gIC9eKD86LCkvLFxuICAgICAgLyogMTEyOiAqLyAgL14oPzpcXD8pLyxcbiAgICAgIC8qIDExMzogKi8gIC9eKD86XFwuKS8sXG4gICAgICAvKiAxMTQ6ICovICAvXig/OiQpLyxcbiAgICAgIC8qIDExNTogKi8gIC9eKD86LikvXG4gICAgXSxcblxuICAgIGNvbmRpdGlvbnM6IHtcbiAgICAgICdDSElMRFJFTic6IHtcbiAgICAgICAgcnVsZXM6IFtcbiAgICAgICAgICAwLFxuICAgICAgICAgIDIzLFxuICAgICAgICAgIDI0LFxuICAgICAgICAgIDI1LFxuICAgICAgICAgIDI2LFxuICAgICAgICAgIDI3LFxuICAgICAgICAgIDI4LFxuICAgICAgICAgIDI5LFxuICAgICAgICAgIDMwLFxuICAgICAgICAgIDg3LFxuICAgICAgICAgIDg4LFxuICAgICAgICAgIDg5LFxuICAgICAgICAgIDkwLFxuICAgICAgICAgIDkxLFxuICAgICAgICAgIDkyLFxuICAgICAgICAgIDkzLFxuICAgICAgICAgIDk0LFxuICAgICAgICAgIDk1LFxuICAgICAgICAgIDk2LFxuICAgICAgICAgIDk3LFxuICAgICAgICAgIDk4LFxuICAgICAgICAgIDk5LFxuICAgICAgICAgIDEwMCxcbiAgICAgICAgICAxMDEsXG4gICAgICAgICAgMTAyLFxuICAgICAgICAgIDEwMyxcbiAgICAgICAgICAxMDQsXG4gICAgICAgICAgMTA1LFxuICAgICAgICAgIDEwNixcbiAgICAgICAgICAxMDcsXG4gICAgICAgICAgMTA4LFxuICAgICAgICAgIDEwOSxcbiAgICAgICAgICAxMTAsXG4gICAgICAgICAgMTExLFxuICAgICAgICAgIDExMixcbiAgICAgICAgICAxMTMsXG4gICAgICAgICAgMTE0XG4gICAgICAgIF0sXG5cbiAgICAgICAgaW5jbHVzaXZlOiBmYWxzZVxuICAgICAgfSxcblxuICAgICAgJ0NPTU1FTlQnOiB7XG4gICAgICAgIHJ1bGVzOiBbXG4gICAgICAgICAgMCxcbiAgICAgICAgICA4NixcbiAgICAgICAgICA4NyxcbiAgICAgICAgICA4OCxcbiAgICAgICAgICA4OSxcbiAgICAgICAgICA5MCxcbiAgICAgICAgICA5MSxcbiAgICAgICAgICA5MixcbiAgICAgICAgICA5MyxcbiAgICAgICAgICA5NCxcbiAgICAgICAgICA5NSxcbiAgICAgICAgICA5NixcbiAgICAgICAgICA5NyxcbiAgICAgICAgICA5OCxcbiAgICAgICAgICA5OSxcbiAgICAgICAgICAxMDAsXG4gICAgICAgICAgMTAxLFxuICAgICAgICAgIDEwMixcbiAgICAgICAgICAxMDMsXG4gICAgICAgICAgMTA0LFxuICAgICAgICAgIDEwNSxcbiAgICAgICAgICAxMDYsXG4gICAgICAgICAgMTA3LFxuICAgICAgICAgIDEwOCxcbiAgICAgICAgICAxMDksXG4gICAgICAgICAgMTEwLFxuICAgICAgICAgIDExMSxcbiAgICAgICAgICAxMTIsXG4gICAgICAgICAgMTEzLFxuICAgICAgICAgIDExNFxuICAgICAgICBdLFxuXG4gICAgICAgIGluY2x1c2l2ZTogZmFsc2VcbiAgICAgIH0sXG5cbiAgICAgICdDT05UUk9MJzoge1xuICAgICAgICBydWxlczogW1xuICAgICAgICAgIDAsXG4gICAgICAgICAgMzEsXG4gICAgICAgICAgMzIsXG4gICAgICAgICAgMzMsXG4gICAgICAgICAgMzQsXG4gICAgICAgICAgMzUsXG4gICAgICAgICAgMzYsXG4gICAgICAgICAgMzcsXG4gICAgICAgICAgMzgsXG4gICAgICAgICAgMzksXG4gICAgICAgICAgNDAsXG4gICAgICAgICAgNDEsXG4gICAgICAgICAgNDIsXG4gICAgICAgICAgNDMsXG4gICAgICAgICAgNDQsXG4gICAgICAgICAgNDUsXG4gICAgICAgICAgNDYsXG4gICAgICAgICAgNDcsXG4gICAgICAgICAgNDgsXG4gICAgICAgICAgNDksXG4gICAgICAgICAgNTAsXG4gICAgICAgICAgNTEsXG4gICAgICAgICAgNTIsXG4gICAgICAgICAgNTMsXG4gICAgICAgICAgNTQsXG4gICAgICAgICAgNTUsXG4gICAgICAgICAgNTYsXG4gICAgICAgICAgNTcsXG4gICAgICAgICAgNTgsXG4gICAgICAgICAgNTksXG4gICAgICAgICAgNjAsXG4gICAgICAgICAgNjEsXG4gICAgICAgICAgNjIsXG4gICAgICAgICAgODcsXG4gICAgICAgICAgODgsXG4gICAgICAgICAgODksXG4gICAgICAgICAgOTAsXG4gICAgICAgICAgOTEsXG4gICAgICAgICAgOTIsXG4gICAgICAgICAgOTMsXG4gICAgICAgICAgOTQsXG4gICAgICAgICAgOTUsXG4gICAgICAgICAgOTYsXG4gICAgICAgICAgOTcsXG4gICAgICAgICAgOTgsXG4gICAgICAgICAgOTksXG4gICAgICAgICAgMTAwLFxuICAgICAgICAgIDEwMSxcbiAgICAgICAgICAxMDIsXG4gICAgICAgICAgMTAzLFxuICAgICAgICAgIDEwNCxcbiAgICAgICAgICAxMDUsXG4gICAgICAgICAgMTA2LFxuICAgICAgICAgIDEwNyxcbiAgICAgICAgICAxMDgsXG4gICAgICAgICAgMTA5LFxuICAgICAgICAgIDExMCxcbiAgICAgICAgICAxMTEsXG4gICAgICAgICAgMTEyLFxuICAgICAgICAgIDExMyxcbiAgICAgICAgICAxMTRcbiAgICAgICAgXSxcblxuICAgICAgICBpbmNsdXNpdmU6IGZhbHNlXG4gICAgICB9LFxuXG4gICAgICAnRVhQUkVTU0lPTic6IHtcbiAgICAgICAgcnVsZXM6IFtcbiAgICAgICAgICAwLFxuICAgICAgICAgIDcwLFxuICAgICAgICAgIDcxLFxuICAgICAgICAgIDcyLFxuICAgICAgICAgIDczLFxuICAgICAgICAgIDc0LFxuICAgICAgICAgIDc1LFxuICAgICAgICAgIDc2LFxuICAgICAgICAgIDc3LFxuICAgICAgICAgIDc4LFxuICAgICAgICAgIDc5LFxuICAgICAgICAgIDgwLFxuICAgICAgICAgIDgxLFxuICAgICAgICAgIDgyLFxuICAgICAgICAgIDgzLFxuICAgICAgICAgIDg0LFxuICAgICAgICAgIDg1LFxuICAgICAgICAgIDg3LFxuICAgICAgICAgIDg4LFxuICAgICAgICAgIDg5LFxuICAgICAgICAgIDkwLFxuICAgICAgICAgIDkxLFxuICAgICAgICAgIDkyLFxuICAgICAgICAgIDkzLFxuICAgICAgICAgIDk0LFxuICAgICAgICAgIDk1LFxuICAgICAgICAgIDk2LFxuICAgICAgICAgIDk3LFxuICAgICAgICAgIDk4LFxuICAgICAgICAgIDk5LFxuICAgICAgICAgIDEwMCxcbiAgICAgICAgICAxMDEsXG4gICAgICAgICAgMTAyLFxuICAgICAgICAgIDEwMyxcbiAgICAgICAgICAxMDQsXG4gICAgICAgICAgMTA1LFxuICAgICAgICAgIDEwNixcbiAgICAgICAgICAxMDcsXG4gICAgICAgICAgMTA4LFxuICAgICAgICAgIDEwOSxcbiAgICAgICAgICAxMTAsXG4gICAgICAgICAgMTExLFxuICAgICAgICAgIDExMixcbiAgICAgICAgICAxMTMsXG4gICAgICAgICAgMTE0XG4gICAgICAgIF0sXG5cbiAgICAgICAgaW5jbHVzaXZlOiBmYWxzZVxuICAgICAgfSxcblxuICAgICAgJ0NPTlRST0xfQ0hJTEQnOiB7XG4gICAgICAgIHJ1bGVzOiBbXG4gICAgICAgICAgMCxcbiAgICAgICAgICA2MyxcbiAgICAgICAgICA2NCxcbiAgICAgICAgICA2NSxcbiAgICAgICAgICA2NixcbiAgICAgICAgICA2NyxcbiAgICAgICAgICA2OCxcbiAgICAgICAgICA2OSxcbiAgICAgICAgICA4NyxcbiAgICAgICAgICA4OCxcbiAgICAgICAgICA4OSxcbiAgICAgICAgICA5MCxcbiAgICAgICAgICA5MSxcbiAgICAgICAgICA5MixcbiAgICAgICAgICA5MyxcbiAgICAgICAgICA5NCxcbiAgICAgICAgICA5NSxcbiAgICAgICAgICA5NixcbiAgICAgICAgICA5NyxcbiAgICAgICAgICA5OCxcbiAgICAgICAgICA5OSxcbiAgICAgICAgICAxMDAsXG4gICAgICAgICAgMTAxLFxuICAgICAgICAgIDEwMixcbiAgICAgICAgICAxMDMsXG4gICAgICAgICAgMTA0LFxuICAgICAgICAgIDEwNSxcbiAgICAgICAgICAxMDYsXG4gICAgICAgICAgMTA3LFxuICAgICAgICAgIDEwOCxcbiAgICAgICAgICAxMDksXG4gICAgICAgICAgMTEwLFxuICAgICAgICAgIDExMSxcbiAgICAgICAgICAxMTIsXG4gICAgICAgICAgMTEzLFxuICAgICAgICAgIDExNFxuICAgICAgICBdLFxuXG4gICAgICAgIGluY2x1c2l2ZTogZmFsc2VcbiAgICAgIH0sXG5cbiAgICAgICdUQUcnOiB7XG4gICAgICAgIHJ1bGVzOiBbXG4gICAgICAgICAgMCxcbiAgICAgICAgICAxMyxcbiAgICAgICAgICAxNCxcbiAgICAgICAgICAxNSxcbiAgICAgICAgICAxNixcbiAgICAgICAgICAxNyxcbiAgICAgICAgICAxOCxcbiAgICAgICAgICAxOSxcbiAgICAgICAgICAyMCxcbiAgICAgICAgICAyMSxcbiAgICAgICAgICAyMixcbiAgICAgICAgICA4NyxcbiAgICAgICAgICA4OCxcbiAgICAgICAgICA4OSxcbiAgICAgICAgICA5MCxcbiAgICAgICAgICA5MSxcbiAgICAgICAgICA5MixcbiAgICAgICAgICA5MyxcbiAgICAgICAgICA5NCxcbiAgICAgICAgICA5NSxcbiAgICAgICAgICA5NixcbiAgICAgICAgICA5NyxcbiAgICAgICAgICA5OCxcbiAgICAgICAgICA5OSxcbiAgICAgICAgICAxMDAsXG4gICAgICAgICAgMTAxLFxuICAgICAgICAgIDEwMixcbiAgICAgICAgICAxMDMsXG4gICAgICAgICAgMTA0LFxuICAgICAgICAgIDEwNSxcbiAgICAgICAgICAxMDYsXG4gICAgICAgICAgMTA3LFxuICAgICAgICAgIDEwOCxcbiAgICAgICAgICAxMDksXG4gICAgICAgICAgMTEwLFxuICAgICAgICAgIDExMSxcbiAgICAgICAgICAxMTIsXG4gICAgICAgICAgMTEzLFxuICAgICAgICAgIDExNFxuICAgICAgICBdLFxuXG4gICAgICAgIGluY2x1c2l2ZTogZmFsc2VcbiAgICAgIH0sXG5cbiAgICAgICdJTklUSUFMJzoge1xuICAgICAgICBydWxlczogW1xuICAgICAgICAgIDAsXG4gICAgICAgICAgMSxcbiAgICAgICAgICAyLFxuICAgICAgICAgIDMsXG4gICAgICAgICAgNCxcbiAgICAgICAgICA1LFxuICAgICAgICAgIDYsXG4gICAgICAgICAgNyxcbiAgICAgICAgICA4LFxuICAgICAgICAgIDksXG4gICAgICAgICAgMTAsXG4gICAgICAgICAgMTEsXG4gICAgICAgICAgMTIsXG4gICAgICAgICAgODcsXG4gICAgICAgICAgODgsXG4gICAgICAgICAgODksXG4gICAgICAgICAgOTAsXG4gICAgICAgICAgOTEsXG4gICAgICAgICAgOTIsXG4gICAgICAgICAgOTMsXG4gICAgICAgICAgOTQsXG4gICAgICAgICAgOTUsXG4gICAgICAgICAgOTYsXG4gICAgICAgICAgOTcsXG4gICAgICAgICAgOTgsXG4gICAgICAgICAgOTksXG4gICAgICAgICAgMTAwLFxuICAgICAgICAgIDEwMSxcbiAgICAgICAgICAxMDIsXG4gICAgICAgICAgMTAzLFxuICAgICAgICAgIDEwNCxcbiAgICAgICAgICAxMDUsXG4gICAgICAgICAgMTA2LFxuICAgICAgICAgIDEwNyxcbiAgICAgICAgICAxMDgsXG4gICAgICAgICAgMTA5LFxuICAgICAgICAgIDExMCxcbiAgICAgICAgICAxMTEsXG4gICAgICAgICAgMTEyLFxuICAgICAgICAgIDExMyxcbiAgICAgICAgICAxMTQsXG4gICAgICAgICAgMTE1XG4gICAgICAgIF0sXG5cbiAgICAgICAgaW5jbHVzaXZlOiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsZXhlcjtcbn0oKTtcbnBhcnNlci5sZXhlciA9IGxleGVyO1xuXG5mdW5jdGlvbiBQYXJzZXIoKSB7XG4gIHRoaXMueXkgPSB7fTtcbn1cblBhcnNlci5wcm90b3R5cGUgPSBwYXJzZXI7XG5wYXJzZXIuUGFyc2VyID0gUGFyc2VyO1xuXG5yZXR1cm4gbmV3IFBhcnNlcigpO1xufSkoKTtcblxuICAgICAgICBcblxuXG5pZiAodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICBleHBvcnRzLnBhcnNlciA9IFBhcnNlcjtcbiAgZXhwb3J0cy5QYXJzZXIgPSBQYXJzZXIuUGFyc2VyO1xuICBleHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBQYXJzZXIucGFyc2UuYXBwbHkoUGFyc2VyLCBhcmd1bWVudHMpO1xuICB9O1xuICBcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5vZGVzID0gcmVxdWlyZShcIi4vQVNUXCIpO1xudmFyIGFmcGwgPSByZXF1aXJlKFwiYWZwbFwiKTtcbnZhciBDT05URVhUID0gJ19fX2NvbnRleHQnO1xudmFyIFZJRVcgPSAnX19fdmlldyc7XG52YXIgV01MID0gJ19fX3dtbCc7XG52YXIgcHJpbXMgPSBbJ1N0cmluZycsICdCb29sZWFuJywgJ051bWJlcicsICdPYmplY3QnLCAnVW5kZWZpbmVkJywgJ051bGwnLCAnVm9pZCcsICdOZXZlcicsICdBbnknXTtcbi8qKlxuICogVHlwZXMgYW5kIGZ1bmN0aW9ucyBmb3IgZ2VuZXJhdGluZyB0eXBlc2NyaXB0IHByb2dyYW0gdGV4dC5cbiAqL1xudmFyIF90aHJvd05vdEtub3duID0gZnVuY3Rpb24gKG4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBBU1Qgbm9kZSBcIiArICh0eXBlb2YgbiA9PT0gJ29iamVjdCcgPyBuLmNvbnN0cnVjdG9yLm5hbWUgOiBuKSArIFwiIVwiKTtcbn07XG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiZnVuY3Rpb24gKCkge31cIjsgfTtcbi8qKlxuICogdmlldyB0ZW1wbGF0ZS5cbiAqL1xuZXhwb3J0cy52aWV3ID0gZnVuY3Rpb24gKGlkLCB0eXBlQ2xhc3NlcywgcGFyYW1zLCBjdHgsIHRhZykge1xuICAgIHJldHVybiBcImV4cG9ydCBjbGFzcyBcIiArIGlkICsgdHlwZUNsYXNzZXMgKyBcIiBleHRlbmRzIFwiICsgV01MICsgXCIuQXBwVmlldzxcIiArIGN0eCArIFwiPiB7XFxuXFxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQ6IFwiICsgY3R4ICsgKHBhcmFtcyA/ICcsJyArIHBhcmFtcyA6ICcnKSArIFwiKSB7XFxuXFxuICAgICAgICBzdXBlcihjb250ZXh0KTtcXG5cXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoXCIgKyBDT05URVhUICsgXCI6XCIgKyBjdHggKyBcIiwgXCIgKyBWSUVXICsgXCI6XCIgKyBXTUwgKyBcIi5BcHBWaWV3PFwiICsgY3R4ICsgXCI+KSA9PlxcbiAgICAgICAgICBcIiArICh0YWcgPyB0YWcgOiAnPE5vZGU+ZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpJykgKyBcIjtcXG5cXG4gICAgICAgfVxcblxcbiAgICAgfVxcblwiO1xufTtcbi8qKlxuICogY29kZSB0dXJucyBhbiBBU1QgaW50byB0eXBlc2NyaXB0IGNvZGUuXG4gKi9cbmV4cG9ydHMuY29kZSA9IGZ1bmN0aW9uIChuLCBvKSB7IHJldHVybiBleHBvcnRzLm1vZHVsZTJUUyhuLCBvKTsgfTtcbi8qKlxuICogbW9kdWxlMlRTIGNvbnZlcnRzIGEgbW9kdWxlIHRvIGEgdHlwZXNjcmlwdCBtb2R1bGUuXG4gKi9cbmV4cG9ydHMubW9kdWxlMlRTID0gZnVuY3Rpb24gKG4sIF9hKSB7XG4gICAgdmFyIG1vZHVsZSA9IF9hLm1vZHVsZTtcbiAgICByZXR1cm4gXCJcXG5pbXBvcnQgKiBhcyBcIiArIFdNTCArIFwiIGZyb20gJ1wiICsgbW9kdWxlICsgXCInO1xcblwiICsgbi5pbXBvcnRzLm1hcChleHBvcnRzLmltcG9ydFN0YXRlbWVudDJUUykuam9pbignO1xcbicpICsgXCJcXG5cXG5cIiArIG4uZXhwb3J0cy5tYXAoZXhwb3J0cy5leHBvcnRzMlRTKS5qb2luKCc7XFxuJykgKyBcIlxcblxcblwiICsgKG4ubWFpbiA/IGV4cG9ydHMubWFpbjJUUyhuLm1haW4pIDogJycpICsgXCJcXG5cIjtcbn07XG4vKipcbiAqIGV4cG9ydHMyVFMgY29udmVydHMgdmFyaW91cyBleHBvcnRzIHRvIHR5cGVzY3JpcHQuXG4gKi9cbmV4cG9ydHMuZXhwb3J0czJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5FeHBvcnRTdGF0ZW1lbnQpXG4gICAgICAgIHJldHVybiBleHBvcnRzLmV4cG9ydFN0YXRlbWVudDJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuRnVuU3RhdGVtZW50KVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5mdW5TdGF0ZW1lbnQyVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLlZpZXdTdGF0ZW1lbnQpXG4gICAgICAgIHJldHVybiBleHBvcnRzLnZpZXdTdGF0ZW1lbnQyVFMobik7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gX3Rocm93Tm90S25vd24obik7XG59O1xuLyoqXG4gKiBpbXBvcnRTdGF0ZW1lbnQyVFMgY29udmVydHMgYW4gaW1wb3J0IHN0YXRlbWVudC5cbiAqL1xuZXhwb3J0cy5pbXBvcnRTdGF0ZW1lbnQyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBcImltcG9ydCBcIiArIGV4cG9ydHMuaW1wb3J0TWVtYmVyMlRTKG4ubWVtYmVyKSArIFwiIGZyb20gJ1wiICsgbi5tb2R1bGUudmFsdWUgKyBcIic7IFwiO1xufTtcbi8qKlxuICogaW1wb3J0TWVtYmVyMlRTIGNvbnZlcnRzIHRoZSBtZW1iZXJzIG9mIGFuIGltcG9ydCB0byB0eXBlc2NyaXB0LlxuICovXG5leHBvcnRzLmltcG9ydE1lbWJlcjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5BZ2dyZWdhdGVNZW1iZXIpXG4gICAgICAgIHJldHVybiBleHBvcnRzLmFnZ3JlZ2F0ZU1lbWJlcjJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuQWxpYXNlZE1lbWJlcilcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuYWxpYXNlZE1lbWJlcjJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuQ29tcG9zaXRlTWVtYmVyKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5jb21wb3NpdGVNZW1iZXIyVFMobik7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gX3Rocm93Tm90S25vd247XG59O1xuLyoqXG4gKiBhbGlhc2VkTWVtYmVyMlRTIGNvbnZlcnRzIGEgbWVtYmVyIGFsaWFzIHRvIHR5cGVzY3JpcHQuXG4gKi9cbmV4cG9ydHMuYWxpYXNlZE1lbWJlcjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuaWRlbnRpZmllck9yQ29uc3RydWN0b3IyVFMobi5tZW1iZXIpICsgXCIgYXMgXCIgKyBleHBvcnRzLmlkZW50aWZpZXJPckNvbnN0cnVjdG9yMlRTKG4uYWxpYXMpICsgXCIgXCI7XG59O1xuLyoqXG4gKiBhZ2dyZWdhdGVNZW1iZXIyVFMgY29udmVydHMgYSBxdWFsaWZpZWQgbWVtYmVyIHRvIHR5cGVzY3JpcHQuXG4gKi9cbmV4cG9ydHMuYWdncmVnYXRlTWVtYmVyMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gXCIqIGFzIFwiICsgZXhwb3J0cy5pZGVudGlmaWVyT3JDb25zdHJ1Y3RvcjJUUyhuLmlkKSArIFwiIFwiO1xufTtcbi8qKlxuICogY29tcG9zaXRlTWVtYmVyMlRTIGNvdmVydHMgdG8gdHlwZXNjcmlwdC5cbiAqL1xuZXhwb3J0cy5jb21wb3NpdGVNZW1iZXIyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiAneycgKyAobi5tZW1iZXJzLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gKG0gaW5zdGFuY2VvZiBub2Rlcy5BbGlhc2VkTWVtYmVyKSA/XG4gICAgICAgIGV4cG9ydHMuYWxpYXNlZE1lbWJlcjJUUyhtKSA6XG4gICAgICAgIGV4cG9ydHMuaWRlbnRpZmllck9yQ29uc3RydWN0b3IyVFMobSk7IH0pLmpvaW4oJywnKSkgKyAnfSc7XG59O1xuLyoqXG4gKiBtYWluMlRTIGNvbnZlcnRzIHRvIHR5cGVzY3JpcHQuXG4gKi9cbmV4cG9ydHMubWFpbjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIChuIGluc3RhbmNlb2Ygbm9kZXMuVHlwZWRNYWluKSA/XG4gICAgICAgIGV4cG9ydHMudHlwZWRNYWluMlRTKG4pIDpcbiAgICAgICAgZXhwb3J0cy51bnR5cGVkTWFpbjJUUyhuKTtcbn07XG4vKipcbiAqIHR5cGVkTWFpbjJUUyBjb252ZXJ0cyBhIHR5cGVkIG1haW4gZmlsZSB0byB0eXBlc2NyaXB0LlxuICovXG5leHBvcnRzLnR5cGVkTWFpbjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMudmlldyhuLmlkID8gZXhwb3J0cy51bnF1YWxpZmllZElkZW50aWZpZXIyVFMobi5pZCkgOiAnTWFpbicsIGV4cG9ydHMudHlwZUNsYXNzZXMyVFMobi50eXBlQ2xhc3NlcyksIG4ucGFyYW1ldGVycy5tYXAoZXhwb3J0cy5wYXJhbWV0ZXIyVFMpLmpvaW4oJywnKSwgZXhwb3J0cy50eXBlMlRTKG4uY29udGV4dCksIGV4cG9ydHMudGFnMlRTKG4udGFnKSk7XG59O1xuLyoqXG4gKiB1bnR5cGVkTWFpbjJUUyBjb252ZXJ0cyBhbiB1bnR5cGVkIG1haW4gZmlsZSB0byB0eXBlc2NyaXB0LlxuICovXG5leHBvcnRzLnVudHlwZWRNYWluMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gZXhwb3J0cy52aWV3KCdNYWluJywgJycsICcnLCAndm9pZCcsIGV4cG9ydHMudGFnMlRTKG4udGFnKSk7XG59O1xuLyoqXG4gKiBleHBvcnRTdGF0ZW1lbnQyVFMgY29udmVydHMgYW4gZXhwb3J0IHN0YXRlbWVudCB0byB0eXBlc2NyaXB0LlxuICovXG5leHBvcnRzLmV4cG9ydFN0YXRlbWVudDJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIFwiZXhwb3J0IFwiICsgZXhwb3J0cy5jb21wb3NpdGVNZW1iZXIyVFMobi5tZW1iZXJzKSArIFwiIGZyb20gJ1wiICsgbi5tb2R1bGUudmFsdWUgKyBcIic7XFxuXCI7XG59O1xuLyoqXG4gKiB2aWV3U3RhdGVtZW50MlRTIGNvbnZlcnRzIGEgdmlldyBzdGF0ZW1lbnQgaW50byBhIHR5cGVzY3JpcHQgY2xhc3MuXG4gKi9cbmV4cG9ydHMudmlld1N0YXRlbWVudDJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMudmlldyhleHBvcnRzLmNvbnN0cnVjdG9yMlRTKG4uaWQpLCBleHBvcnRzLnR5cGVDbGFzc2VzMlRTKG4udHlwZUNsYXNzZXMpLCBuLnBhcmFtZXRlcnMubWFwKGV4cG9ydHMucGFyYW1ldGVyMlRTKS5qb2luKCcsJyksIGV4cG9ydHMudHlwZTJUUyhuLmNvbnRleHQpLCBleHBvcnRzLnRhZzJUUyhuLnRhZykpO1xufTtcbnZhciBfZnVuQ29udGV4dCA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBcIihcIiArIENPTlRFWFQgKyBcIjpcIiArIGV4cG9ydHMudHlwZTJUUyhuKSArIFwiKT0+XCI7IH07XG52YXIgX2Z1blZpZXcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBcIihcIiArIFZJRVcgKyBcIjpcIiArIFdNTCArIFwiLlZpZXcpPT5cIjsgfTtcbi8qKlxuICogZnVuU3RhdGVtZW50MlRTIGNvbnZlcnRzIGEgZnVuY3Rpb24gc3RhdGVtZW50IHRvIHR5cGVzY3JpcHQuXG4gKi9cbmV4cG9ydHMuZnVuU3RhdGVtZW50MlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gXCJleHBvcnQgY29uc3QgXCIgKyBleHBvcnRzLnVucXVhbGlmaWVkSWRlbnRpZmllcjJUUyhuLmlkKSArIFwiID0gXCIgK1xuICAgICAgICAoZXhwb3J0cy50eXBlQ2xhc3NlczJUUyhuLnR5cGVDbGFzc2VzKSArIFwiKFwiICsgbi5wYXJhbWV0ZXJzLm1hcChleHBvcnRzLnBhcmFtZXRlcjJUUykuam9pbignLCcpICsgXCIpPT5cIikgK1xuICAgICAgICAoKG4uY29udGV4dCAhPSBudWxsKSA/IF9mdW5Db250ZXh0KG4uY29udGV4dCkgOiAnJykgK1xuICAgICAgICBfZnVuVmlldygpICtcbiAgICAgICAgKChBcnJheS5pc0FycmF5KG4uYm9keSkgPyBleHBvcnRzLmNoaWxkcmVuMlRTKG4uYm9keSkgOiBleHBvcnRzLmNoaWxkMlRTKG4uYm9keSkpICsgXCI7XCIpO1xufTtcbi8qKlxuICogdHlwZUNsYXNzZXMyVFMgY29udmVydHMgYSBsaXN0IG9mIHR5cGVjbGFzc2VzIGludG8gdGhlIGEgbGlzdCBvZiB0eXBlc2NyaXB0IHR5cGVjbGFzc2VzLlxuICovXG5leHBvcnRzLnR5cGVDbGFzc2VzMlRTID0gZnVuY3Rpb24gKG5zKSB7XG4gICAgcmV0dXJuIChucy5sZW5ndGggPT09IDApID8gJycgOiBcIjwgXCIgKyBucy5tYXAoZXhwb3J0cy50eXBlQ2xhc3MyVFMpLmpvaW4oJywnKSArIFwiPlwiO1xufTtcbi8qKlxuICogdHlwZUNsYXNzMlRTIGNvbnZlcnRzIGEgdHlwZWNsYXNzIGludG8gYSB0eXBlc2NyaXB0IHR5cGVjbGFzcy5cbiAqL1xuZXhwb3J0cy50eXBlQ2xhc3MyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBleHBvcnRzLmlkZW50aWZpZXJPckNvbnN0cnVjdG9yMlRTKG4uaWQpICsgXCIgXCIgK1xuICAgICAgICAoKG4uY29uc3RyYWludCA/ICdleHRlbmRzICcgKyBleHBvcnRzLnR5cGUyVFMobi5jb25zdHJhaW50KSA6ICcnKSArIFwiIFwiKTtcbn07XG52YXIgX3RvUHJpbSA9IGZ1bmN0aW9uICh0eXApIHtcbiAgICByZXR1cm4gcHJpbXMuaW5kZXhPZih0eXApID4gLTEgPyB0eXAudG9Mb3dlckNhc2UoKSA6IHR5cDtcbn07XG4vKipcbiAqIHR5cGUyVFMgY29udmVydHMgYSB0eXBlIGhpbnQgdG8gYSB0eXBlc2NyaXB0IHR5cGUgaGludC5cbiAqL1xuZXhwb3J0cy50eXBlMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gX3RvUHJpbShleHBvcnRzLmlkZW50aWZpZXJPckNvbnN0cnVjdG9yMlRTKG4uaWQpKSArIFwiIFwiICtcbiAgICAgICAgKGV4cG9ydHMudHlwZUNsYXNzZXMyVFMobi50eXBlQ2xhc3NlcykgKyBcIiBcIiArIChuLmxpc3QgPyAnW10nIDogJycpKTtcbn07XG4vKipcbiAqIHBhcmFtZXRlcjJUUyBjb252ZXJ0cyBhIHBhcmFtZXRlciB0byBhIHR5cGVzY3JpcHQgcGFyYW1ldGVyLlxuICovXG5leHBvcnRzLnBhcmFtZXRlcjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIChuIGluc3RhbmNlb2Ygbm9kZXMuVHlwZWRQYXJhbWV0ZXIpID8gZXhwb3J0cy50eXBlZFBhcmFtZXRlcjJUUyhuKSA6XG4gICAgICAgIChuIGluc3RhbmNlb2Ygbm9kZXMuVW50eXBlZFBhcmFtZXRlcikgPyBleHBvcnRzLnVudHlwZWRQYXJhbWV0ZXIyVFMobikgOlxuICAgICAgICAgICAgX3Rocm93Tm90S25vd247XG59O1xuLyoqXG4gKiB0eXBlZFBhcmFtZXRlcjJUUyBjb252ZXJ0cyBhIHR5cGVkIHBhcmFtZXRlciBpbnRvIGEgbm9uLWFueSB0eXBlc2NyaXB0IHBhcmFtZXRlci5cbiAqL1xuZXhwb3J0cy50eXBlZFBhcmFtZXRlcjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuaWRlbnRpZmllcjJUUyhuLmlkKSArIFwiOlwiICsgZXhwb3J0cy50eXBlMlRTKG4uaGludCkgKyBcIiBcIjtcbn07XG4vKipcbiAqIHVudHlwZWRQYXJhbWV0ZXIyVFMgY29udmVydHMgYW4gdHlwZSBpbmZlcnJlZCBwYXJhbWV0ZXIgdG8gYSB0eXBlc2NyaXB0IHBhcmFtZXRlci5cbiAqL1xuZXhwb3J0cy51bnR5cGVkUGFyYW1ldGVyMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gZXhwb3J0cy5pZGVudGlmaWVyMlRTKG4uaWQpICsgXCIgXCI7XG59O1xuLyoqXG4gKiBjaGlsZHJlbjJUUyBjb252ZXJ0cyBhIGxpc3Qgb2YgY2hpbGRyZW4gdG8gdHlwZXNjcmlwdC5cbiAqL1xuZXhwb3J0cy5jaGlsZHJlbjJUUyA9IGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgcmV0dXJuIChsaXN0Lmxlbmd0aCA9PT0gMCkgPyAnZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpOycgOlxuICAgICAgICAobGlzdC5sZW5ndGggPT09IDEpID8gZXhwb3J0cy5jaGlsZDJUUyhsaXN0WzBdKSA6XG4gICAgICAgICAgICBXTUwgKyBcIi5ib3goXCIgKyBsaXN0Lm1hcChmdW5jdGlvbiAobCkgeyByZXR1cm4gZXhwb3J0cy5jaGlsZDJUUyhsKTsgfSkuam9pbignLCcpICsgXCIpIFwiO1xufTtcbi8qKlxuICogY2hpbGQyVFMgY29udmVydHMgY2hpbGRyZW4gdG8gdHlwZXNjcmlwdC5cbiAqL1xuZXhwb3J0cy5jaGlsZDJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgaWYgKChuIGluc3RhbmNlb2Ygbm9kZXMuTm9kZSkgfHwgKG4gaW5zdGFuY2VvZiBub2Rlcy5XaWRnZXQpKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy50YWcyVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLkludGVycG9sYXRpb24pXG4gICAgICAgIHJldHVybiBXTUwgKyBcIi5kb21pZnkoXCIgKyBleHBvcnRzLmludGVycG9sYXRpb24yVFMobikgKyBcIikgXCI7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLklmU3RhdGVtZW50KVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5pZlN0YXRlbWVudDJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuRm9yU3RhdGVtZW50KVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5mb3JTdGF0ZW1lbnQyVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLkNoYXJhY3RlcnMpXG4gICAgICAgIHJldHVybiBleHBvcnRzLmNoYXJhY3RlcnMyVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLkNvbnRleHRQcm9wZXJ0eSlcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuY29udGV4dFByb3BlcnR5MlRTKG4pO1xuICAgIGVsc2UgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5RdWFsaWZpZWRDb25zdHJ1Y3RvcilcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMucXVhbGlmaWVkQ29uc3RydWN0b3IyVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLlVucXVhbGlmaWVkQ29uc3RydWN0b3IpXG4gICAgICAgIHJldHVybiBleHBvcnRzLnVucXVhbGlmaWVkQ29uc3RydWN0b3IyVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLlVucXVhbGlmaWVkSWRlbnRpZmllcilcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMudW5xdWFsaWZpZWRJZGVudGlmaWVyMlRTKG4pO1xuICAgIGVsc2UgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5RdWFsaWZpZWRJZGVudGlmaWVyKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5xdWFsaWZpZWRJZGVudGlmaWVyMlRTKG4pO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIF90aHJvd05vdEtub3duKG4pO1xufTtcbi8qKlxuICogdGFnMlRTIGNvbnZlcnRzIGEgdGFnIChub2RlL3dpZGdldCkgdG8gdHlwZXNjcmlwdC5cbiAqL1xuZXhwb3J0cy50YWcyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHZhciBjaGlsZHJlbiA9IG4uY2hpbGRyZW4ubWFwKGV4cG9ydHMuY2hpbGQyVFMpO1xuICAgIHZhciBhdHRycyA9IGV4cG9ydHMuYXR0cnMyU3RyaW5nKGV4cG9ydHMuZ3JvdXBBdHRycyhuLmF0dHJpYnV0ZXMpKTtcbiAgICB2YXIgbmFtZSA9IGV4cG9ydHMuaWRlbnRpZmllck9yQ29uc3RydWN0b3IyVFMobi5vcGVuKTtcbiAgICByZXR1cm4gKG4udHlwZSA9PT0gJ3dpZGdldCcpID8gV01MICsgXCIud2lkZ2V0KFwiICsgbmFtZSArIFwiLCBcIiArIGF0dHJzICsgXCIsIFtcIiArIGNoaWxkcmVuICsgXCJdLCBcIiArIFZJRVcgKyBcIilcIiA6XG4gICAgICAgIFdNTCArIFwiLm5vZGUoJ1wiICsgbmFtZSArIFwiJywgXCIgKyBhdHRycyArIFwiLCBbXCIgKyBjaGlsZHJlbiArIFwiXSwgXCIgKyBWSUVXICsgXCIpIFwiO1xufTtcbi8qKlxuICogYXR0cnMyU3RyaW5nXG4gKi9cbmV4cG9ydHMuYXR0cnMyU3RyaW5nID0gZnVuY3Rpb24gKGF0dHJzKSB7IHJldHVybiAneycgK1xuICAgIChPYmplY3Qua2V5cyhhdHRycykubWFwKGZ1bmN0aW9uIChucykgeyByZXR1cm4gbnMgKyBcIiA6IHsgXCIgKyBhdHRyc1tuc10uam9pbignLCcpICsgXCIgfSBcIjsgfSkpICsgJ30nOyB9O1xuLyoqXG4gKiBncm91cEF0dHJzIGdyb3VwcyBhdHRyaWJ1dGVzIGFjY29yZGluZyB0byB0aGVpciBuYW1lc3BhY2UuXG4gKi9cbmV4cG9ydHMuZ3JvdXBBdHRycyA9IGZ1bmN0aW9uIChucykgeyByZXR1cm4gbnMucmVkdWNlKGZ1bmN0aW9uIChwLCBjKSB7XG4gICAgcmV0dXJuIGFmcGwudXRpbC5tZXJnZShwLCAoX2EgPSB7fSxcbiAgICAgICAgX2FbYy5uYW1lc3BhY2UuaWQgfHwgJ2h0bWwnXSA9IChwW2MubmFtZXNwYWNlLmlkIHx8ICdodG1sJ10gfHwgW10pLmNvbmNhdChleHBvcnRzLmF0dHJpYnV0ZTJUUyhjKSksXG4gICAgICAgIF9hKSk7XG4gICAgdmFyIF9hO1xufSwgeyBodG1sOiBbXSwgd21sOiBbXSB9KTsgfTtcbi8qKlxuICogYXR0cmlidXRlMlZhbHVlXG4gKi9cbmV4cG9ydHMuYXR0cmlidXRlMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gXCInXCIgKyBleHBvcnRzLnVucXVhbGlmaWVkSWRlbnRpZmllcjJUUyhuLm5hbWUpICsgXCInIDogXCIgKyBleHBvcnRzLmF0dHJpYnV0ZVZhbHVlMlRTKG4udmFsdWUpICsgXCIgXCI7XG59O1xuLyoqXG4gKiBhdHRyaWJ1dGVWYWx1ZTJUUyBjb252ZXJ0cyBhbiBhdHRyaWJ1dGUgdmFsdWUgdG8gdHlwZXNjcmlwdC5cbiAqL1xuZXhwb3J0cy5hdHRyaWJ1dGVWYWx1ZTJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIChuIGluc3RhbmNlb2Ygbm9kZXMuSW50ZXJwb2xhdGlvbikgPyBleHBvcnRzLmludGVycG9sYXRpb24yVFMobikgOiBleHBvcnRzLmxpdGVyYWwyVFMobik7XG59O1xuLyoqXG4gKiBpbnRlcnBvbGF0aW9uMlRTIGNvbnZlcnRzIGludGVycG9sYXRpb24gZXhwcmVzc2lvbnMgdG8gdHlwZXNjcmlwdC5cbiAqL1xuZXhwb3J0cy5pbnRlcnBvbGF0aW9uMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gbi5maWx0ZXJzLnJlZHVjZShmdW5jdGlvbiAocCwgYykgeyByZXR1cm4gZXhwb3J0cy5leHByZXNzaW9uMlRTKGMpICsgXCIgKFwiICsgcCArIFwiKVwiOyB9LCBleHBvcnRzLmV4cHJlc3Npb24yVFMobi5leHByZXNzaW9uKSk7XG59O1xuLyoqXG4gKiBmb3JTdGF0ZW1lbnQyVFMgY29udmVydHMgYSBmb3Igc3RhdGVtZW50IHRvIHR5cGVzY3JpcHQuXG4gKi9cbmV4cG9ydHMuZm9yU3RhdGVtZW50MlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gV01MICsgXCIubWFwKFwiICsgZXhwb3J0cy5leHByZXNzaW9uMlRTKG4ubGlzdCkgKyBcIiwgZnVuY3Rpb24gX21hcFwiICtcbiAgICAgICAgKFwiKFwiICsgW24udmFyaWFibGUsIG4uaW5kZXgsIG4uYWxsXS5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0pLm1hcChleHBvcnRzLnBhcmFtZXRlcjJUUykuam9pbignLCcpICsgXCIpIFwiKSArXG4gICAgICAgIChcInsgcmV0dXJuIFwiICsgZXhwb3J0cy5jaGlsZHJlbjJUUyhuLmJvZHkpICsgXCIgfSwgXCIpICtcbiAgICAgICAgKFwiZnVuY3Rpb24gb3RoZXJ3aXNlKCkgeyByZXR1cm4gXCIgKyBleHBvcnRzLmNoaWxkcmVuMlRTKG4ub3RoZXJ3aXNlKSArIFwiIH0pIFwiKTtcbn07XG4vKipcbiAqIGlmU3RhdGVtZW50MlRTIGNvbnZlcnRzIGFuIGlmIHN0YXRlbWVudCB0byB0eXBlc2NyaXB0LlxuICovXG5leHBvcnRzLmlmU3RhdGVtZW50MlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gXCIoXCIgKyBleHBvcnRzLmV4cHJlc3Npb24yVFMobi5jb25kaXRpb24pICsgXCIpPyBcIiArXG4gICAgICAgIChleHBvcnRzLmNoaWxkcmVuMlRTKG4udGhlbikgKyBcIjpcIikgK1xuICAgICAgICAoXCJcIiArIChuLmVsc2VDbGF1c2UgPyBlbHNlMlRTKG4uZWxzZUNsYXVzZSkgOiBub29wKCkpKTtcbn07XG52YXIgZWxzZTJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIChuIGluc3RhbmNlb2Ygbm9kZXMuRWxzZUNsYXVzZSkgPyBleHBvcnRzLmNoaWxkcmVuMlRTKG4uY2hpbGRyZW4pIDpcbiAgICAgICAgKG4gaW5zdGFuY2VvZiBub2Rlcy5FbHNlSWZDbGF1c2UpID8gZXhwb3J0cy5pZlN0YXRlbWVudDJUUyhuKSA6XG4gICAgICAgICAgICBfdGhyb3dOb3RLbm93bihuKTtcbn07XG4vKipcbiAqIGNoYXJhY3RlcnMyVFMgY29udmVydHMgY2hhcmFjdGVyIHRleHQgdG8gYSB0eXBlc2NyaXB0IHN0cmluZy5cbiAqL1xuZXhwb3J0cy5jaGFyYWN0ZXJzMlRTID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIFdNTCArIFwiLnRleHQoYFwiICsgbi52YWx1ZSArIFwiYClcIjsgfTtcbi8qKlxuICogZXhwcmVzc2lvbjJUUyBjb252ZXJ0cyBhIHdtbCBleHByZXNzaW9uIHRvIGEgdHlwZXNjcmlwdCBleHByZXNzaW9uLlxuICovXG5leHBvcnRzLmV4cHJlc3Npb24yVFMgPSBmdW5jdGlvbiAobikge1xuICAgIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuSWZUaGVuRXhwcmVzc2lvbilcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuaWZUaGVuRXhwcmVzc2lvbjJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuQmluYXJ5RXhwcmVzc2lvbilcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuYmluYXJ5RXhwcmVzc2lvbjJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuVW5hcnlFeHByZXNzaW9uKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy51bmFyeUV4cHJlc3Npb24yVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLlZpZXdDb25zdHJ1Y3Rpb24pXG4gICAgICAgIHJldHVybiBleHBvcnRzLnZpZXdDb25zdHJ1Y3Rpb24yVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLkZ1bkFwcGxpY2F0aW9uKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5mdW5BcHBsaWNhdGlvbjJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuQ29uc3RydWN0RXhwcmVzc2lvbilcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuY29uc3RydWN0RXhwcmVzc2lvbjJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuQ2FsbEV4cHJlc3Npb24pXG4gICAgICAgIHJldHVybiBleHBvcnRzLmNhbGxFeHByZXNzaW9uMlRTKG4pO1xuICAgIGVsc2UgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5NZW1iZXJFeHByZXNzaW9uKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5tZW1iZXJFeHByZXNzaW9uMlRTKG4pO1xuICAgIGVsc2UgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5SZWFkRXhwcmVzc2lvbilcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMucmVhZEV4cHJlc3Npb24yVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLkZ1bmN0aW9uRXhwcmVzc2lvbilcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuZnVuY3Rpb25FeHByZXNzaW9uMlRTKG4pO1xuICAgIGVsc2UgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5SZWNvcmQpXG4gICAgICAgIHJldHVybiBleHBvcnRzLnJlY29yZDJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuTGlzdClcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMubGlzdDJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuQm9vbGVhbkxpdGVyYWwpXG4gICAgICAgIHJldHVybiBleHBvcnRzLmJvb2xlYW4yVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLk51bWJlckxpdGVyYWwpXG4gICAgICAgIHJldHVybiBleHBvcnRzLm51bWJlcjJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuU3RyaW5nTGl0ZXJhbClcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuc3RyaW5nMlRTKG4pO1xuICAgIGVsc2UgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5Db250ZXh0UHJvcGVydHkpXG4gICAgICAgIHJldHVybiBleHBvcnRzLmNvbnRleHRQcm9wZXJ0eTJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuUXVhbGlmaWVkQ29uc3RydWN0b3IpXG4gICAgICAgIHJldHVybiBleHBvcnRzLnF1YWxpZmllZENvbnN0cnVjdG9yMlRTKG4pO1xuICAgIGVsc2UgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5VbnF1YWxpZmllZENvbnN0cnVjdG9yKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy51bnF1YWxpZmllZENvbnN0cnVjdG9yMlRTKG4pO1xuICAgIGVsc2UgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5VbnF1YWxpZmllZElkZW50aWZpZXIpXG4gICAgICAgIHJldHVybiBleHBvcnRzLnVucXVhbGlmaWVkSWRlbnRpZmllcjJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuUXVhbGlmaWVkSWRlbnRpZmllcilcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMucXVhbGlmaWVkSWRlbnRpZmllcjJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuQ29udGV4dFZhcmlhYmxlKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5jb250ZXh0VmFyaWFibGUyVFMobik7XG4gICAgZWxzZVxuICAgICAgICBfdGhyb3dOb3RLbm93bihuKTtcbn07XG4vKipcbiAqIGlmVGhlbkV4cHJlc3Npb24yVFMgY29udmVydHMgYW4gaWYtdGhlbi1lbHNlIGV4cHJlc3Npb24gdG8gdHlwZXNjcmlwdC5cbiAqL1xuZXhwb3J0cy5pZlRoZW5FeHByZXNzaW9uMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gXCIoXCIgKyBleHBvcnRzLmV4cHJlc3Npb24yVFMobi5jb25kaXRpb24pICsgXCIpID8gXCIgKyBleHBvcnRzLmV4cHJlc3Npb24yVFMobi5pZnRydWUpICsgXCIgOiBcIiArIGV4cG9ydHMuZXhwcmVzc2lvbjJUUyhuLmlmZmFsc2UpICsgXCIgXCI7XG59O1xuLyoqXG4gKiBiaW5hcnlFeHByZXNzaW9uMlRTIGNvbnZlcnRzIGEgYmluYXJ5IGV4cHJlc3Npb24gdG8gdHlwZXNjcmlwdC5cbiAqL1xuZXhwb3J0cy5iaW5hcnlFeHByZXNzaW9uMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gXCIoXCIgKyBleHBvcnRzLmV4cHJlc3Npb24yVFMobi5sZWZ0KSArIFwiIFwiICsgZXhwb3J0cy5jb252ZXJ0T3BlcmF0b3Iobi5vcGVyYXRvcikgKyBcIiBcIiArIGV4cG9ydHMuZXhwcmVzc2lvbjJUUyhuLnJpZ2h0KSArIFwiKSBcIjtcbn07XG4vKipcbiAqIGNvbnZlcnRPcGVyYXRvciBmb3Igc3RyaWN0bmVzcy5cbiAqL1xuZXhwb3J0cy5jb252ZXJ0T3BlcmF0b3IgPSBmdW5jdGlvbiAob3ApIHtcbiAgICByZXR1cm4gKG9wID09PSAnPT0nKSA/ICc9PT0nIDpcbiAgICAgICAgKG9wID09PSAnIT0nKSA/ICchPT0nIDpcbiAgICAgICAgICAgIG9wO1xufTtcbi8qKlxuICogdW5hcnlFeHByZXNzaW9uMlRTIGNvbnZlcnRzIGEgdW5hcnkgZXhwcmVzc2lvbiB0byB0eXBlc2NyaXB0LlxuICovXG5leHBvcnRzLnVuYXJ5RXhwcmVzc2lvbjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIG4ub3BlcmF0b3IgKyBcIiAoXCIgKyBleHBvcnRzLmV4cHJlc3Npb24yVFMobi5leHByZXNzaW9uKSArIFwiKVwiO1xufTtcbi8qKlxuICogdmlld0NvbnN0cnVjdGlvbjJUUyBjb252ZXJzIGEgdmlldyBjb25zdHJ1Y3Rpb24gdG8gdHlwZXNjcmlwdC5cbiAqL1xuZXhwb3J0cy52aWV3Q29uc3RydWN0aW9uMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gXCIobmV3IFwiICsgZXhwb3J0cy5jb25zdHJ1Y3RvcjJUUyhuLmNvbnMpICsgXCIoXCIgKyBleHBvcnRzLmFyZ3MyVFMobi5jb250ZXh0KSArIFwiKSkucmVuZGVyKClcIjtcbn07XG52YXIgX2FwcGx5RnVuID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICByZXR1cm4gKGNvbnRleHQubGVuZ3RoID4gMCA/IFwiKFwiICsgZXhwb3J0cy5hcmdzMlRTKGNvbnRleHQpICsgXCIpXCIgOiAnJykgKyAoXCIoXCIgKyBWSUVXICsgXCIpXCIpO1xufTtcbi8qKlxuICogZnVuQXBwbGljYXRpb24yVFMgY29udmVydHMgYSBmdW4gYXBwbGljYXRpb24gdG8gdHlwZXNjcmlwdC5cbiAqL1xuZXhwb3J0cy5mdW5BcHBsaWNhdGlvbjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZXhwcmVzc2lvbjJUUyhuLnRhcmdldCkgKyBcIiBcIiArIGV4cG9ydHMudHlwZUFyZ3MyVFMobi50eXBlQXJncykgKyBcIiBcIiArXG4gICAgICAgIChcIihcIiArIGV4cG9ydHMuYXJnczJUUyhuLmFyZ3MpICsgXCIpXCIgKyBfYXBwbHlGdW4obi5jb250ZXh0KSk7XG59O1xuLyoqXG4gKiBjb25zdHJ1Y3RFeHByZXNzaW9uMlRTIGNvbnZlcnRzIGEgY29uc3RydWN0IGV4cHJlc3Npb24gdG8gYSB0eXBlc2NyaXB0IG5ldyBleHByZXNzaW9uLlxuICovXG5leHBvcnRzLmNvbnN0cnVjdEV4cHJlc3Npb24yVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBcIm5ldyBcIiArIGV4cG9ydHMuY29uc3RydWN0b3IyVFMobi5jb25zKSArIFwiIChcIiArIGV4cG9ydHMuYXJnczJUUyhuLmFyZ3MpICsgXCIpXCI7XG59O1xuLyoqXG4gKiBjYWxsRXhwcmVzc2lvbjJUUyBjb252ZXJ0cyBhIGNhbGwgZXhwcmVzc2lvbiAoYXBwbHkpIHRvIGEgdHlwZXNjcmlwdCBpbnZvY2F0aW9uLlxuICovXG5leHBvcnRzLmNhbGxFeHByZXNzaW9uMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gZXhwb3J0cy5leHByZXNzaW9uMlRTKG4udGFyZ2V0KSArIFwiIFwiICsgZXhwb3J0cy50eXBlQXJnczJUUyhuLnR5cGVBcmdzKSArIFwiIChcIiArIGV4cG9ydHMuYXJnczJUUyhuLmFyZ3MpICsgXCIpXCI7XG59O1xuLyoqXG4gKiB0eXBlQXJnczJUUyBjb252ZXJ0cyBwYXNzZWQgdHlwZSBhcmd1bWVudHMgdG8gdHlwZXNjcmlwdFxuICovXG5leHBvcnRzLnR5cGVBcmdzMlRTID0gZnVuY3Rpb24gKG5zKSB7XG4gICAgcmV0dXJuIG5zLmxlbmd0aCA9PT0gMCA/ICcnIDogXCI8IFwiICsgbnMubWFwKGV4cG9ydHMudHlwZTJUUykuam9pbignLCcpICsgXCI+XCI7XG59O1xuLyoqXG4gKiBhcmdzMlRTIGNvbnZlcnRzIGEgbGlzdCBvZiBhcmd1bWVudHMgdG8gYSB0eXBlc2NyaXB0IGFyZ3VtZW50IHR1cHBsZS5cbiAqL1xuZXhwb3J0cy5hcmdzMlRTID0gZnVuY3Rpb24gKG5zKSB7XG4gICAgcmV0dXJuIChucy5sZW5ndGggPT09IDApID8gJycgOiBucy5tYXAoZXhwb3J0cy5leHByZXNzaW9uMlRTKS5qb2luKCcsJyk7XG59O1xuLyoqXG4gKiBtZW1iZXJFeHByZXNzaW9uMlRTIGNvbnZlcnRzIGEgbWVtYmVyIGV4cHJlc3Npb24gaW50byBhIHR5cGVzY3JpcHQgbWVtYmVyIGV4cHJlc3Npb24uXG4gKi9cbmV4cG9ydHMubWVtYmVyRXhwcmVzc2lvbjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZXhwcmVzc2lvbjJUUyhuLnRhcmdldCkgKyBcIi5cIiArIGV4cG9ydHMuaWRlbnRpZmllcjJUUyhuLm1lbWJlcikgKyBcIiBcIjtcbn07XG4vKipcbiAqIHJlYWRFeHByZXNzaW9uMlRTIGNvbnZlcnRzIGEgcmVhZCBleHByZXNzaW9uIHRvIHNpZGUgZWZmZWN0IGZ1bGwgcHJvcGVydHkgbG9vayB1cC5cbiAqXG4gKiBOT1RFOiB0aGlzIHBhcnQgb2YgdGhlIGxhbmd1YWdlIGlzIG1vc3QgbGlrZWx5IHRvIGNoYW5nZS5cbiAqL1xuZXhwb3J0cy5yZWFkRXhwcmVzc2lvbjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIFdNTCArIFwiLnJlYWQgPCBcIiArIGV4cG9ydHMudHlwZTJUUyhuLmhpbnQpICsgXCI+KFwiICsgZXhwb3J0cy5leHByZXNzaW9uMlRTKG4ucGF0aCkgKyBcIiwgXCIgKyBleHBvcnRzLmV4cHJlc3Npb24yVFMobi50YXJnZXQpICsgXCIgXCIgK1xuICAgICAgICAoKG4uZGVmYXVsdHMgPyAnLCcgKyBleHBvcnRzLmV4cHJlc3Npb24yVFMobi5kZWZhdWx0cykgOiAnJykgKyBcIilcIik7XG59O1xuLyoqXG4gKiBmdW5jdGlvbkV4cHJlc3Npb24yVFMgY29udmVydHMgYSBmdW5jdGlvbiBleHByZXNzaW9uIHRvIGEgdHlwZXNjcmlwdCBmdW5jdGlvbiBleHByZXNzaW9uLlxuICovXG5leHBvcnRzLmZ1bmN0aW9uRXhwcmVzc2lvbjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIFwiKFwiICsgbi5wYXJhbWV0ZXJzLm1hcChleHBvcnRzLnBhcmFtZXRlcjJUUykuam9pbignLCcpICsgXCIpPT5cIiArXG4gICAgICAgIChcIlwiICsgZXhwb3J0cy5leHByZXNzaW9uMlRTKG4uYm9keSkpO1xufTtcbi8qKlxuICogbGl0ZXJhbDJUUyBjb252ZXJ0cyBsaXRlcmFscy5cbiAqL1xuZXhwb3J0cy5saXRlcmFsMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gKG4gaW5zdGFuY2VvZiBub2Rlcy5Cb29sZWFuTGl0ZXJhbCkgPyBleHBvcnRzLmJvb2xlYW4yVFMobikgOlxuICAgICAgICAobiBpbnN0YW5jZW9mIG5vZGVzLlN0cmluZ0xpdGVyYWwpID8gZXhwb3J0cy5zdHJpbmcyVFMobikgOlxuICAgICAgICAgICAgKG4gaW5zdGFuY2VvZiBub2Rlcy5OdW1iZXJMaXRlcmFsKSA/IGV4cG9ydHMubnVtYmVyMlRTKG4pIDpcbiAgICAgICAgICAgICAgICAobiBpbnN0YW5jZW9mIG5vZGVzLlJlY29yZCkgPyBleHBvcnRzLnJlY29yZDJUUyhuKSA6XG4gICAgICAgICAgICAgICAgICAgIChuIGluc3RhbmNlb2Ygbm9kZXMuTGlzdCkgPyBleHBvcnRzLmxpc3QyVFMobikgOlxuICAgICAgICAgICAgICAgICAgICAgICAgX3Rocm93Tm90S25vd24obik7XG59O1xuLyoqXG4gKiBib29sZWFuMlRTIGNvbnZlcnRzIGEgYm9vbGVhbiBsaXRlcmFsIHRvIGEgdHlwZXNjcmlwdCBib29sZWFuIGxpdGVyYWwuXG4gKi9cbmV4cG9ydHMuYm9vbGVhbjJUUyA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLnZhbHVlICsgXCIgXCI7IH07XG4vKipcbiAqIHN0cmluZzJUUyBjb252ZXJ0cyBhIHN0cmluZyBsaXRlcmFsIHRvIGEgdHlwZXNjcmlwdCBzdHJpbmcgbGl0ZXJhbC5cbiAqL1xuZXhwb3J0cy5zdHJpbmcyVFMgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gXCJgXCIgKyBuLnZhbHVlICsgXCJgXCI7IH07XG4vKipcbiAqIG51bWJlcjJUUyBjb252ZXJ0cyBhIG51bWJlciBsaXRlcmFsIHRvIGEgdHlwZWNyaXB0IG51bWJlciBsaXRlcmFsLlxuICovXG5leHBvcnRzLm51bWJlcjJUUyA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBcIlwiICsgcGFyc2VGbG9hdChuLnZhbHVlKTsgfTtcbi8qKlxuICogcmVjb3JkMlRTIGNvbnZlcnRzIGEgcmVjb3JkIHRvIGEgdHlwZXNjcmlwdCBvYmplY3QgbGl0ZXJhbC5cbiAqL1xuZXhwb3J0cy5yZWNvcmQyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBcIntcIiArIG4ucHJvcGVydGllcy5tYXAoZXhwb3J0cy5wcm9wZXJ0eTJUUykuam9pbignLCcpICsgXCJ9XCI7XG59O1xuLyoqXG4gKiBsaXN0MlRTIGNvbnZlcnRzIGEgbGlzdCB0byBhIHR5cGVzY3JpcHQgYXJyYXkgbGl0ZXJhbC5cbiAqL1xuZXhwb3J0cy5saXN0MlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gXCJbXCIgKyBuLm1lbWJlcnMubWFwKGV4cG9ydHMuZXhwcmVzc2lvbjJUUykuam9pbignLCcpICsgXCJdXCI7XG59O1xuLyoqXG4gKiBwcm9wZXJ0eTJUUyBjb252ZXJ0cyBhIHByb3BlcnR5IG9mIGEgYSByZWNvcmQgdG8gdHlwZXNjcmlwdC5cbiAqL1xuZXhwb3J0cy5wcm9wZXJ0eTJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIFwiJ1wiICsgZXhwb3J0cy5rZXkyVFMobi5rZXkpICsgXCInIDogXCIgKyBleHBvcnRzLmV4cHJlc3Npb24yVFMobi52YWx1ZSk7XG59O1xuLyoqXG4gKiBrZXkyVFMgY29udmVydHMgYSBzaW5nbGUga2V5IG9uIGEgcmVjb3JkLlxuICovXG5leHBvcnRzLmtleTJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIChuIGluc3RhbmNlb2Ygbm9kZXMuU3RyaW5nTGl0ZXJhbCkgPyBleHBvcnRzLnN0cmluZzJUUyhuKSA6IGV4cG9ydHMuaWRlbnRpZmllcjJUUyhuKTtcbn07XG4vKipcbiAqIGNvbnRleHRQcm9wZXJ0eTJUUyB0dXJucyBwcm9wZXJ0eSBhY2Nlc3Mgb24gdGhlIGNvbnRleHQgdG8gcmVndWxhciBUU1xuICogcHJvcGVydHkgYWNjZXNzLlxuICovXG5leHBvcnRzLmNvbnRleHRQcm9wZXJ0eTJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIENPTlRFWFQgKyBcIi5cIiArIGV4cG9ydHMuaWRlbnRpZmllcjJUUyhuLm1lbWJlcik7XG59O1xuLyoqXG4gKiBjb250ZXh0VmFyaWFibGUyVFMgdHVybnMgdGhlIGNvbnRleHQgdmFyaWFibGUgaW50byB0aGUgY29udGV4dCBpZGVudGlmaWVyLlxuICovXG5leHBvcnRzLmNvbnRleHRWYXJpYWJsZTJUUyA9IGZ1bmN0aW9uIChfKSB7IHJldHVybiBcIlwiICsgQ09OVEVYVDsgfTtcbi8qKlxuICogaWRlbnRpZmllck9yQ29uc3RydWN0b3IyVFNcbiAqL1xuZXhwb3J0cy5pZGVudGlmaWVyT3JDb25zdHJ1Y3RvcjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgaWYgKChuIGluc3RhbmNlb2Ygbm9kZXMuVW5xdWFsaWZpZWRJZGVudGlmaWVyKSB8fFxuICAgICAgICAobiBpbnN0YW5jZW9mIG5vZGVzLlF1YWxpZmllZElkZW50aWZpZXIpKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5pZGVudGlmaWVyMlRTKG4pO1xuICAgIGVsc2UgaWYgKChuIGluc3RhbmNlb2Ygbm9kZXMuVW5xdWFsaWZpZWRDb25zdHJ1Y3RvcikgfHxcbiAgICAgICAgKG4gaW5zdGFuY2VvZiBub2Rlcy5RdWFsaWZpZWRDb25zdHJ1Y3RvcikpXG4gICAgICAgIHJldHVybiBleHBvcnRzLmNvbnN0cnVjdG9yMlRTKG4pO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIF90aHJvd05vdEtub3duKG4pO1xufTtcbi8qKlxuICogY29uc3RydWN0b3IyVFMgdHVybnMgYSBjb25zdHJ1Y3RvciB0byBhIHR5cGVzY3JpcHQgaWRlbnRpZmllci5cbiAqXG4gKiBSZW1lbWJlciBjb25zdHJ1Y3RvcnMgYXJlIHByb3BlciBjYXNlZC5cbiAqL1xuZXhwb3J0cy5jb25zdHJ1Y3RvcjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIChuIGluc3RhbmNlb2Ygbm9kZXMuUXVhbGlmaWVkQ29uc3RydWN0b3IpID8gZXhwb3J0cy5xdWFsaWZpZWRDb25zdHJ1Y3RvcjJUUyhuKSA6XG4gICAgICAgIChuIGluc3RhbmNlb2Ygbm9kZXMuVW5xdWFsaWZpZWRDb25zdHJ1Y3RvcikgPyBleHBvcnRzLnVucXVhbGlmaWVkQ29uc3RydWN0b3IyVFMobikgOlxuICAgICAgICAgICAgX3Rocm93Tm90S25vd24obik7XG59O1xuLyoqXG4gKiB1bnF1YWxpZmllZENvbnN0cnVjdG9yMlRTIGNvbnZlcnRzIGFuIHVucXVhbGlmaWVkIGNvbnN0cnVjdG9yIHRvIHR5cGVzY3JpcHRcbiAqL1xuZXhwb3J0cy51bnF1YWxpZmllZENvbnN0cnVjdG9yMlRTID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIFwiXCIgKyBuLmlkOyB9O1xuLyoqXG4gKiBxdWFsaWZpZWRDb25zdHJ1Y3RvciBjb252ZXJ0cyBhIHF1YWxpZmllZCBjb25zdHJ1Y3RvciB0byB0eXBlc2NyaXB0LlxuICovXG5leHBvcnRzLnF1YWxpZmllZENvbnN0cnVjdG9yMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gbi5xdWFsaWZpZXIgKyBcIi5cIiArIG4ubWVtYmVyO1xufTtcbi8qKlxuICogaWRlbnRpZmllcjJUUyB0dXJucyBhbiBpZGVudGlmaWVyIHRvIGEgdHlwZXNjcmlwdCBpZGVudGlmaWVyLlxuICovXG5leHBvcnRzLmlkZW50aWZpZXIyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiAobiBpbnN0YW5jZW9mIG5vZGVzLlF1YWxpZmllZElkZW50aWZpZXIpID8gZXhwb3J0cy5xdWFsaWZpZWRJZGVudGlmaWVyMlRTKG4pIDpcbiAgICAgICAgKG4gaW5zdGFuY2VvZiBub2Rlcy5VbnF1YWxpZmllZElkZW50aWZpZXIpID8gZXhwb3J0cy51bnF1YWxpZmllZElkZW50aWZpZXIyVFMobikgOlxuICAgICAgICAgICAgX3Rocm93Tm90S25vd24obik7XG59O1xuLyoqXG4gKiBxdWFsaWZpZWRJZGVudGlmaWVyMlRTIGNvbnZlcnRzIGEgcXVhbGlmaWVkIGlkZW50aWZpZXIgdG8gdHlwZXNjcmlwdFxuICovXG5leHBvcnRzLnF1YWxpZmllZElkZW50aWZpZXIyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBuLnF1YWxpZmllciArIFwiLlwiICsgbi5tZW1iZXI7XG59O1xuLyoqXG4gKiB1bnF1YWxpZmllZElkZW50aWZpZXIyVFMgY29udmVydHMgYW4gdW5xdWFsaWZpZWQgaWRlbnRpZmllciB0byB0eXBlc2NyaXB0XG4gKi9cbmV4cG9ydHMudW5xdWFsaWZpZWRJZGVudGlmaWVyMlRTID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIFwiXCIgKyBuLmlkOyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VHlwZVNjcmlwdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBwcm9wZXJ0eSA9IHJlcXVpcmUoXCJwcm9wZXJ0eS1zZWVrXCIpO1xudmFyIE1heWJlXzEgPSByZXF1aXJlKFwiYWZwbC9saWIvbW9uYWQvTWF5YmVcIik7XG52YXIgQ29tcGlsZXJfMSA9IHJlcXVpcmUoXCIuL0NvbXBpbGVyXCIpO1xuZXhwb3J0cy5wYXJzZSA9IENvbXBpbGVyXzEucGFyc2U7XG5leHBvcnRzLmNvbXBpbGUgPSBDb21waWxlcl8xLmNvbXBpbGU7XG47XG4vKipcbiAqIENvbXBvbmVudCBpcyBhbiBhYnN0cmFjdCBXaWRnZXQgaW1wbGVtZW50YXRpb25cbiAqIHRoYXQgY2FuIGJlIHVzZWQgaW5zdGVhZCBvZiBtYW51YWxseSBpbXBsZW1lbnRpbmcgdGhlIHdob2xlIGludGVyZmFjZS5cbiAqXG4gKi9cbnZhciBDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogYXR0cnMgaXMgdGhlIGF0dHJpYnV0ZXMgdGhpcyBDb21wb25lbnQgZXhjZXB0cy5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBjaGlsZHJlbiBpcyBhbiBhcnJheSBvZiBjb250ZW50IHBhc3NlZCB0byB0aGlzIENvbXBvbmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb21wb25lbnQoYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIH1cbiAgICBDb21wb25lbnQucHJvdG90eXBlLnJlbmRlcmVkID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIENvbXBvbmVudC5wcm90b3R5cGUucmVtb3ZlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBDb21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudmlldy5yZW5kZXIoKTsgfTtcbiAgICByZXR1cm4gQ29tcG9uZW50O1xufSgpKTtcbmV4cG9ydHMuQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuO1xuLyoqXG4gKiByZWFkIGEgdmFsdWUgZm9ybSBhbiBvYmplY3QuXG4gKlxuICogVGhpcyBpcyBhbiBhbHRlcm5hdGl2ZSB0byByZWd1bGFyIHByb3BlcnR5IGFjY2VzcyB0aGF0IHdpbGwgdGhyb3cgZXhjZXB0aW9uc1xuICogaWYgYW55IG9mIHRoZSB2YWx1ZXMgaW4gdGhlIHBhcnQgYXJlIG51bGwuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIFRoZSBwYXRoIHRvIGxvb2sgdXAgb24gdGhlIG9iamVjdC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBvIC0gVGhlIG9iamVjdFxuICogQHBhcmFtIHtBfSBbZGVmYXVsdFZhbHVlXSAtIFRoaXMgdmFsdWUgaXMgcmV0dXJuZWQgaWYgdGhlIHZhbHVlIGlzIG5vdCBzZXQuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAocGF0aCwgbywgZGVmYXVsdFZhbHVlKSB7XG4gICAgdmFyIHJldCA9IHByb3BlcnR5LmdldChwYXRoLnNwbGl0KCc6Jykuam9pbignLicpLCBvKTtcbiAgICByZXR1cm4gKHJldCAhPSBudWxsKSA/IHJldCA6IGRlZmF1bHRWYWx1ZTtcbn07XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBhZG9wdCA9IGZ1bmN0aW9uIChjaGlsZCwgZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIGNoaWxkKSB7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGNoaWxkKSk7XG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICBlLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjaGlsZCArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgY2hpbGQpO1xuICAgIH1cbn07XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuYm94ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb250ZW50ID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgY29udGVudFtfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICBjb250ZW50LmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGZyYWcuYXBwZW5kQ2hpbGQoYyk7IH0pO1xuICAgIHJldHVybiBmcmFnO1xufTtcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5kb21pZnkgPSBmdW5jdGlvbiAoYSkge1xuICAgIGlmIChhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuYm94LmFwcGx5KG51bGwsIGEubWFwKGV4cG9ydHMuZG9taWZ5KSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCh0eXBlb2YgYSA9PT0gJ3N0cmluZycpIHx8XG4gICAgICAgICh0eXBlb2YgYSA9PT0gJ251bWJlcicpIHx8XG4gICAgICAgICh0eXBlb2YgYSA9PT0gJ2Jvb2xlYW4nKSkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy50ZXh0KGEpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhIGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCB1c2UgJ1wiICsgYSArIFwiJyh0eXBlb2YgXCIgKyB0eXBlb2YgYSArIFwiKSBhcyBDb250ZW50IVwiKTtcbiAgICB9XG59O1xuLyoqXG4gKiB0ZXh0IGNyZWF0ZXMgYSBuZXcgVGV4dE5vZGUuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLnRleHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyB2YWx1ZSk7XG59O1xuLyoqXG4gKiBub2RlIGlzIGNhbGxlZCB0byBjcmVhdGUgYSByZWd1bGFyIERPTSBub2RlXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRyaWJ1dGVzLCBjaGlsZHJlbiwgdmlldykge1xuICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgIGlmICh0eXBlb2YgYXR0cmlidXRlc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGFkb3B0KGMsIGUpOyB9KTtcbiAgICB2YXIgaWQgPSBhdHRyaWJ1dGVzWyd3bWwnXS5pZDtcbiAgICB2YXIgZ3JvdXAgPSBhdHRyaWJ1dGVzLndtbC5ncm91cDtcbiAgICBpZiAoaWQpXG4gICAgICAgIHZpZXcucmVnaXN0ZXJCeUlkKGlkLCBlKTtcbiAgICBpZiAoZ3JvdXApXG4gICAgICAgIHZpZXcucmVnaXN0ZXJCeUdyb3VwKGdyb3VwLCBlKTtcbiAgICByZXR1cm4gZTtcbn07XG4vKipcbiAqIHdpZGdldCBjcmVhdGVzIGFuZCByZW5kZXJzIGEgbmV3IHdtbCB3aWRnZXQgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDb25zdHJ1dG9yXG4gKiBAcGFyYW0ge29iamVjdH0gYXR0cmlidXRlc1xuICogQHBhcmFtIHthcnJheTxzdHJpbmd8bnVtYmVyfFdpZGdldD59IGNoaWxkcmVuXG4gKiBAcGFyYW0ge1ZpZXd9IHZpZXdcbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJuIHtXaWRnZXR9XG4gKi9cbmV4cG9ydHMud2lkZ2V0ID0gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBhdHRyaWJ1dGVzLCBjaGlsZHJlbiwgdmlldykge1xuICAgIHZhciBjaGlsZHMgPSBbXTtcbiAgICB2YXIgdztcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gKGNoaWxkIGluc3RhbmNlb2YgQXJyYXkpID9cbiAgICAgICAgY2hpbGRzLnB1c2guYXBwbHkoY2hpbGRzLCBjaGlsZCkgOiBjaGlsZHMucHVzaChjaGlsZCk7IH0pO1xuICAgIHcgPSBuZXcgQ29uc3RydWN0b3IoYXR0cmlidXRlcywgY2hpbGRzKTtcbiAgICB2YXIgaWQgPSBhdHRyaWJ1dGVzLndtbC5pZDtcbiAgICB2YXIgZ3JvdXAgPSBhdHRyaWJ1dGVzLndtbC5ncm91cDtcbiAgICBpZiAoaWQpXG4gICAgICAgIHZpZXcucmVnaXN0ZXJCeUlkKGlkLCB3KTtcbiAgICBpZiAoZ3JvdXApXG4gICAgICAgIHZpZXcucmVnaXN0ZXJCeUdyb3VwKGdyb3VwLCB3KTtcbiAgICB2aWV3LnJlZ2lzdGVyV2lkZ2V0KHcpO1xuICAgIHJldHVybiB3LnJlbmRlcigpO1xufTtcbi8qKlxuICogaWZ0aGVuIHByb3ZpZGVzIGFuIGlmIHRoZW4gZXhwcmVzc2lvblxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5pZnRoZW4gPSBmdW5jdGlvbiAocHJlZGljYXRlLCBwb3NpdGl2ZSwgbmVnYXRpdmUpIHtcbiAgICByZXR1cm4gKHByZWRpY2F0ZSkgPyBwb3NpdGl2ZSgpIDogbmVnYXRpdmUoKTtcbn07XG4vKipcbiAqIGZvckUgcHJvdmlkZXMgYSBmb3IgZXhwcmVzc2lvblxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5tYXAgPSBmdW5jdGlvbiAoY29sbGVjdGlvbiwgY2IsIGNiMikge1xuICAgIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIGlmIChjb2xsZWN0aW9uIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgaWYgKGNvbGxlY3Rpb24ubGVuZ3RoID4gMClcbiAgICAgICAgICAgIGNvbGxlY3Rpb24uZm9yRWFjaChmdW5jdGlvbiAodiwgaywgYSkgeyByZXR1cm4gZnJhZy5hcHBlbmRDaGlsZChjYih2LCBrLCBhKSk7IH0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmcmFnLmFwcGVuZENoaWxkKGNiMigpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGNvbGxlY3Rpb24gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhciBsID0gT2JqZWN0LmtleXMoY29sbGVjdGlvbik7XG4gICAgICAgIGlmIChsLmxlbmd0aCA+IDApXG4gICAgICAgICAgICBsLmZvckVhY2goZnVuY3Rpb24gKGspIHsgcmV0dXJuIGZyYWcuYXBwZW5kQ2hpbGQoY2IoY29sbGVjdGlvbltrXSwgaywgY29sbGVjdGlvbikpOyB9KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZnJhZy5hcHBlbmRDaGlsZChjYjIoKSk7XG4gICAgfVxuICAgIHJldHVybiBmcmFnO1xufTtcbi8qKlxuICogQXBwVmlldyBpcyB0aGUgY29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgYSBWaWV3LlxuICpcbiAqIEBwcm9wZXJ0eSB7PEM+fSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdGhlIHZpZXcgaXMgcmVuZGVyZWQgaW4uXG4gKi9cbnZhciBBcHBWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFwcFZpZXcoY29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICB9XG4gICAgQXBwVmlldy5wcm90b3R5cGUucmVnaXN0ZXJXaWRnZXQgPSBmdW5jdGlvbiAodykge1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBBcHBWaWV3LnByb3RvdHlwZS5yZWdpc3RlckJ5SWQgPSBmdW5jdGlvbiAoaWQsIHcpIHtcbiAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgIHRoaXMuaWRzW2lkXSA9IHc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQXBwVmlldy5wcm90b3R5cGUucmVnaXN0ZXJCeUdyb3VwID0gZnVuY3Rpb24gKGdyb3VwLCBlKSB7XG4gICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQXBwVmlldy5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIE1heWJlXzEuTWF5YmVcbiAgICAgICAgICAgIC5mcm9tQW55KHRoaXMuaWRzW2lkXSlcbiAgICAgICAgICAgIC5vckVsc2UoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVGhlIGlkICdcIiArIGlkICsgXCInIGlzIG1pc3NpbmchXCIpO1xuICAgICAgICAgICAgcmV0dXJuIE1heWJlXzEuTWF5YmUubm90aGluZygpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEFwcFZpZXcucHJvdG90eXBlLmZpbmRHcm91cEJ5TmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBNYXliZV8xLk1heWJlLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHRoaXMuZ3JvdXBzW25hbWVdIDogW10pO1xuICAgIH07XG4gICAgQXBwVmlldy5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNoaWxkcztcbiAgICAgICAgdmFyIHJlYWxGaXJzdENoaWxkO1xuICAgICAgICB2YXIgcmVhbEZpcnN0Q2hpbGRJbmRleDtcbiAgICAgICAgdmFyIHRyZWUgPSAodGhpcy5fZnJhZ1Jvb3QpID8gdGhpcy5fZnJhZ1Jvb3QgOiB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCdBdHRlbXB0IHRvIGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIGluc2VydGVkIHRvIERPTSEnKTtcbiAgICAgICAgY2hpbGRzID0gdHJlZS5wYXJlbnROb2RlLmNoaWxkcmVuO1xuICAgICAgICAvL2ZvciBzb21lIHJlYXNvbiB0aGUgcmVmZXJlbmNlIHN0b3JlZCBkb2VzIG5vdCBoYXZlIHRoZSBjb3JyZWN0IHBhcmVudCBub2RlLlxuICAgICAgICAvL3dlIGRvIHRoaXMgdG8gZ2V0IGEgJ2xpdmUnIHZlcnNpb24gb2YgdGhlIG5vZGUuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKGNoaWxkc1tpXSA9PT0gdHJlZSkge1xuICAgICAgICAgICAgICAgIHJlYWxGaXJzdENoaWxkID0gY2hpbGRzW2ldO1xuICAgICAgICAgICAgICAgIHJlYWxGaXJzdENoaWxkSW5kZXggPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHJlYWxGaXJzdENoaWxkKTtcbiAgICB9O1xuICAgIEFwcFZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMuX2ZyYWdSb290ID0gbnVsbDtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzLmNvbnRleHQsIHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID8gdGhpcy5pZHNbJ3Jvb3QnXSA6IHRoaXMudHJlZTtcbiAgICAgICAgaWYgKHRoaXMudHJlZS5ub2RlTmFtZSA9PT0gKGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSkubm9kZU5hbWUpXG4gICAgICAgICAgICB0aGlzLl9mcmFnUm9vdCA9IHRoaXMudHJlZS5maXJzdENoaWxkO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBBcHBWaWV3O1xufSgpKTtcbmV4cG9ydHMuQXBwVmlldyA9IEFwcFZpZXc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZjEgPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gZjsgfTtcbmV4cG9ydHMuZjIgPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGZ1bmN0aW9uIChiKSB7IHJldHVybiBmKGEsIGIpOyB9OyB9OyB9O1xuZXhwb3J0cy5mMyA9IGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7IHJldHVybiBmdW5jdGlvbiAoYikgeyByZXR1cm4gZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGYoYSwgYiwgYyk7IH07IH07IH07XG59O1xuZXhwb3J0cy5mNCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7IHJldHVybiBmdW5jdGlvbiAoYikgeyByZXR1cm4gZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGZ1bmN0aW9uIChkKSB7IHJldHVybiBmKGEsIGIsIGMsIGQpOyB9OyB9OyB9OyB9O1xufTtcbmV4cG9ydHMuZjUgPSBmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGZ1bmN0aW9uIChjKSB7IHJldHVybiBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGYoYSwgYiwgYywgZCwgZSk7IH07IH07IH07IH07IH07XG59O1xuZXhwb3J0cy5mNiA9IGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7IHJldHVybiBmdW5jdGlvbiAoYikgeyByZXR1cm4gZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGZ1bmN0aW9uIChkKSB7IHJldHVybiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZnVuY3Rpb24gKF9mKSB7IHJldHVybiBmKGEsIGIsIGMsIGQsIGUsIF9mKTsgfTsgfTsgfTsgfTsgfTsgfTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmV4cG9ydHMudXRpbCA9IHV0aWw7XG52YXIgY3VycnkgPSByZXF1aXJlKFwiLi9jdXJyeVwiKTtcbmV4cG9ydHMuY3VycnkgPSBjdXJyeTtcbnZhciBJZGVudGl0eV8xID0gcmVxdWlyZShcIi4vbW9uYWQvSWRlbnRpdHlcIik7XG5leHBvcnRzLklkZW50aXR5ID0gSWRlbnRpdHlfMS5JZGVudGl0eTtcbnZhciBNYXliZV8xID0gcmVxdWlyZShcIi4vbW9uYWQvTWF5YmVcIik7XG5leHBvcnRzLk1heWJlID0gTWF5YmVfMS5NYXliZTtcbnZhciBFaXRoZXJfMSA9IHJlcXVpcmUoXCIuL21vbmFkL0VpdGhlclwiKTtcbmV4cG9ydHMuRWl0aGVyID0gRWl0aGVyXzEuRWl0aGVyO1xudmFyIFN0YXRlXzEgPSByZXF1aXJlKFwiLi9tb25hZC9TdGF0ZVwiKTtcbmV4cG9ydHMuU3RhdGUgPSBTdGF0ZV8xLlN0YXRlO1xudmFyIEZyZWVfMSA9IHJlcXVpcmUoXCIuL21vbmFkL0ZyZWVcIik7XG5leHBvcnRzLkZyZWUgPSBGcmVlXzEuRnJlZTtcbnZhciBJT18xID0gcmVxdWlyZShcIi4vbW9uYWQvSU9cIik7XG5leHBvcnRzLklPID0gSU9fMS5JTztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIGxlZnQgd3JhcHMgYSB2YWx1ZSBvbiB0aGUgbGVmdCBzaWRlLlxuICovXG5leHBvcnRzLmxlZnQgPSBmdW5jdGlvbiAoYSkgeyByZXR1cm4gbmV3IExlZnQoYSk7IH07XG4vKipcbiAqIHJpZ2h0IHdyYXBzIGEgdmFsdWUgb24gdGhlIHJpZ2h0IHNpZGUuXG4gKi9cbmV4cG9ydHMucmlnaHQgPSBmdW5jdGlvbiAoYikgeyByZXR1cm4gbmV3IFJpZ2h0KGIpOyB9O1xuLyoqXG4gKiBmcm9tQm9vbGVhbiBjb25zdHJ1Y3RzIGFuIEVpdGhlciB1c2luZyBhIGJvb2xlYW4gdmFsdWUuXG4gKi9cbmV4cG9ydHMuZnJvbUJvb2xlYW4gPSBmdW5jdGlvbiAoYikge1xuICAgIHJldHVybiBiID8gZXhwb3J0cy5yaWdodCh0cnVlKSA6IGV4cG9ydHMubGVmdChmYWxzZSk7XG59O1xuLyoqXG4gKiBFaXRoZXIgbW9uYWQgaW1wbGVtZW50YXRpb25cbiAqL1xudmFyIEVpdGhlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRWl0aGVyKCkge1xuICAgIH1cbiAgICBFaXRoZXIucHJvdG90eXBlLm9mID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSaWdodCh2KTtcbiAgICB9O1xuICAgIEVpdGhlci5sZWZ0ID0gZXhwb3J0cy5sZWZ0O1xuICAgIEVpdGhlci5yaWdodCA9IGV4cG9ydHMucmlnaHQ7XG4gICAgRWl0aGVyLmZyb21Cb29sZWFuID0gZXhwb3J0cy5mcm9tQm9vbGVhbjtcbiAgICByZXR1cm4gRWl0aGVyO1xufSgpKTtcbmV4cG9ydHMuRWl0aGVyID0gRWl0aGVyO1xudmFyIExlZnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMZWZ0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExlZnQobCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sID0gbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBMZWZ0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICByZXR1cm4gbmV3IExlZnQodGhpcy5sKTtcbiAgICB9O1xuICAgIExlZnQucHJvdG90eXBlLm1hcExlZnQgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gbmV3IExlZnQoZih0aGlzLmwpKTtcbiAgICB9O1xuICAgIExlZnQucHJvdG90eXBlLmJpbWFwID0gZnVuY3Rpb24gKGYsIF8pIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMubGVmdChmKHRoaXMubCkpO1xuICAgIH07XG4gICAgTGVmdC5wcm90b3R5cGUuY2hhaW4gPSBmdW5jdGlvbiAoXykge1xuICAgICAgICByZXR1cm4gbmV3IExlZnQodGhpcy5sKTtcbiAgICB9O1xuICAgIExlZnQucHJvdG90eXBlLm9yRWxzZSA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBmKHRoaXMubCk7XG4gICAgfTtcbiAgICBMZWZ0LnByb3RvdHlwZS5vclJpZ2h0ID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSaWdodChmKHRoaXMubCkpO1xuICAgIH07XG4gICAgTGVmdC5wcm90b3R5cGUuYXAgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICByZXR1cm4gbmV3IExlZnQodGhpcy5sKTtcbiAgICB9O1xuICAgIExlZnQucHJvdG90eXBlLnRha2VMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sO1xuICAgIH07XG4gICAgTGVmdC5wcm90b3R5cGUudGFrZVJpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTm90IHJpZ2h0IVwiKTtcbiAgICB9O1xuICAgIExlZnQucHJvdG90eXBlLmNhdGEgPSBmdW5jdGlvbiAoZiwgXykge1xuICAgICAgICByZXR1cm4gZih0aGlzLmwpO1xuICAgIH07XG4gICAgcmV0dXJuIExlZnQ7XG59KEVpdGhlcikpO1xuZXhwb3J0cy5MZWZ0ID0gTGVmdDtcbnZhciBSaWdodCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJpZ2h0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJpZ2h0KHIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuciA9IHI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUmlnaHQucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmlnaHQoZih0aGlzLnIpKTtcbiAgICB9O1xuICAgIFJpZ2h0LnByb3RvdHlwZS5tYXBMZWZ0ID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSaWdodCh0aGlzLnIpO1xuICAgIH07XG4gICAgUmlnaHQucHJvdG90eXBlLmJpbWFwID0gZnVuY3Rpb24gKF8sIGcpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMucmlnaHQoZyh0aGlzLnIpKTtcbiAgICB9O1xuICAgIFJpZ2h0LnByb3RvdHlwZS5jaGFpbiA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBmKHRoaXMucik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBvckVsc2UgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGYgaWYgdGhlIEVpdGhlciBpcyBsZWZ0LlxuICAgICAqL1xuICAgIFJpZ2h0LnByb3RvdHlwZS5vckVsc2UgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFJpZ2h0LnByb3RvdHlwZS5vclJpZ2h0ID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBhcFxuICAgICAqL1xuICAgIFJpZ2h0LnByb3RvdHlwZS5hcCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBlLm1hcChmdW5jdGlvbiAoZikgeyByZXR1cm4gZihfdGhpcy5yKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgICogdGFrZUxlZnQgZXh0cmFjdHMgdGhlIGxlZnQgdmFsdWUgb2YgYW4gRWl0aGVyLCB0aHJvd2luZyBhbiBlcnJvciBpZiB0aGUgRWl0aGVyIGlzIHJpZ2h0LlxuICAgICAgKi9cbiAgICBSaWdodC5wcm90b3R5cGUudGFrZUxlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJOb3QgbGVmdCFcIik7XG4gICAgfTtcbiAgICBSaWdodC5wcm90b3R5cGUudGFrZVJpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogY2F0YVxuICAgICAqL1xuICAgIFJpZ2h0LnByb3RvdHlwZS5jYXRhID0gZnVuY3Rpb24gKF8sIGcpIHtcbiAgICAgICAgcmV0dXJuIGcodGhpcy5yKTtcbiAgICB9O1xuICAgIHJldHVybiBSaWdodDtcbn0oRWl0aGVyKSk7XG5leHBvcnRzLlJpZ2h0ID0gUmlnaHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FaXRoZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBFaXRoZXJfMSA9IHJlcXVpcmUoXCIuL0VpdGhlclwiKTtcbi8qKlxuICogZnJlZSB3cmFwcyBhIHZhbHVlIGluIGEgZnJlZVxuICovXG5leHBvcnRzLmZyZWUgPSBmdW5jdGlvbiAoYSkgeyByZXR1cm4gbmV3IFJldHVybihhKTsgfTtcbi8qKlxuICogc3VzcGVuZCBsaWZ0cyBhIGZ1bmN0aW9uIGludG8gYSBGcmVlIG1vbmFkIHRvIG1pbWljIHRhaWwgY2FsbCByZWN1cnNpb24uXG4gKi9cbmV4cG9ydHMuc3VzcGVuZCA9IGZ1bmN0aW9uIChmKSB7IHJldHVybiBuZXcgU3VzcGVuZCh1dGlsXzEuY29tcG9zZShleHBvcnRzLmZyZWUsIGYpKTsgfTtcbi8qKlxuICogbGlmdEYgbGlmdHMgYSBGdW5jdG9yIGludG8gYSBGcmVlLlxuICovXG5leHBvcnRzLmxpZnRGID0gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIG5ldyBTdXNwZW5kKGYubWFwKGV4cG9ydHMuZnJlZSkpOyB9O1xuLyoqXG4gKiBGcmVlIGlzIGEgRnJlZSBtb25hZCB0aGF0IGFsc28gaW1wbGVtZW50cyBhIEZyZWUgQXBwbGljYXRpdmUgKGFsbW9zdCkuXG4gKlxuICogSW5zcGlyZWQgYnkgaHR0cHM6Ly9jd215ZXJzLmdpdGh1Yi5pby9tb25ldC5qcy8jZnJlZVxuICovXG52YXIgRnJlZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRnJlZSgpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogb2ZcbiAgICAgKi9cbiAgICBGcmVlLnByb3RvdHlwZS5vZiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmV0dXJuKGEpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogbWFwXG4gICAgICovXG4gICAgRnJlZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhaW4oZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGV4cG9ydHMuZnJlZShmKGEpKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBjaGFpblxuICAgICAqL1xuICAgIEZyZWUucHJvdG90eXBlLmNoYWluID0gZnVuY3Rpb24gKGcpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBTdXNwZW5kKSB7XG4gICAgICAgICAgICB2YXIgZl8xID0gdGhpcy5mO1xuICAgICAgICAgICAgcmV0dXJuICh0eXBlb2YgZl8xID09PSAnZnVuY3Rpb24nKSA/XG4gICAgICAgICAgICAgICAgbmV3IFN1c3BlbmQoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIGZfMSh4KS5jaGFpbihnKTsgfSkgOlxuICAgICAgICAgICAgICAgIG5ldyBTdXNwZW5kKGZfMS5tYXAoZnVuY3Rpb24gKGZyZWUpIHsgcmV0dXJuIGZyZWUuY2hhaW4oZyk7IH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzIGluc3RhbmNlb2YgUmV0dXJuKSB7XG4gICAgICAgICAgICBnKHRoaXMuYSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHJlc3VtZSB0aGUgbmV4dCBzdGFnZSBvZiB0aGUgY29tcHV0YXRpb25cbiAgICAgKi9cbiAgICBGcmVlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgU3VzcGVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIEVpdGhlcl8xLmxlZnQodGhpcy5mKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzIGluc3RhbmNlb2YgUmV0dXJuKSB7XG4gICAgICAgICAgICByZXR1cm4gRWl0aGVyXzEucmlnaHQodGhpcy5hKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogaG9pc3RcbiAgICBob2lzdDxCPihmdW5jOiAoZmI6IEZ1bmN0b3I8Qj4pID0+IEZ1bmN0b3I8Qj4pOiBGcmVlPEYsIEE+IHtcblxuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFN1c3BlbmQpIHtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdXNwZW5kKChmdW5jKHRoaXMuZikpXG4gICAgICAgICAgICAgICAgLm1hcCgoZnI6IEZyZWU8RiwgQj4pID0+IGZyLmhvaXN0PGFueT4oZnVuYykpKVxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9XG5cbiAgICB9XG4gICAgKi9cbiAgICAvKipcbiAgICAgKiBjYXRhXG4gICAgICovXG4gICAgRnJlZS5wcm90b3R5cGUuY2F0YSA9IGZ1bmN0aW9uIChmLCBnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VtZSgpLmNhdGEoZiwgZyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBnbyBydW5zIHRoZSBjb21wdXRhdGlvbiB0byBjb21wbGV0aW9uIHVzaW5nIGYgdG8gZXh0cmFjdCBlYWNoIHN0YWdlLlxuICAgICAqIEBzdW1tbWFyeSBnbyA6OiBGcmVlPEY8Kj4sIEE+IOKGkiAgKEY8RnJlZTxGLEE+PiDihpIgIEZyZWU8RixBPikg4oaSICBBXG4gICAgICovXG4gICAgRnJlZS5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiAoZikge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFN1c3BlbmQpIHtcbiAgICAgICAgICAgIHZhciByID0gdGhpcy5yZXN1bWUoKTtcbiAgICAgICAgICAgIHdoaWxlIChyIGluc3RhbmNlb2YgRWl0aGVyXzEuTGVmdClcbiAgICAgICAgICAgICAgICByID0gKGYoci50YWtlTGVmdCgpKSkucmVzdW1lKCk7XG4gICAgICAgICAgICByZXR1cm4gci50YWtlUmlnaHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzIGluc3RhbmNlb2YgUmV0dXJuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBydW4gdGhlIEZyZWUgY2hhaW4gdG8gY29tcGxldGlvblxuICAgICAqIEBzdW1tYXJ5IHJ1biA6OiBGcmVlPEHihpIgQSxBPiDihpIgIEFcbiAgICAgKi9cbiAgICBGcmVlLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdvKGZ1bmN0aW9uIChuZXh0KSB7IHJldHVybiBuZXh0KCk7IH0pO1xuICAgIH07XG4gICAgRnJlZS5mcmVlID0gZXhwb3J0cy5mcmVlO1xuICAgIEZyZWUuc3VzcGVuZCA9IGV4cG9ydHMuc3VzcGVuZDtcbiAgICBGcmVlLmxpZnRGID0gZXhwb3J0cy5saWZ0RjtcbiAgICByZXR1cm4gRnJlZTtcbn0oKSk7XG5leHBvcnRzLkZyZWUgPSBGcmVlO1xudmFyIFN1c3BlbmQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdXNwZW5kLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1c3BlbmQoZikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5mID0gZjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gU3VzcGVuZDtcbn0oRnJlZSkpO1xuZXhwb3J0cy5TdXNwZW5kID0gU3VzcGVuZDtcbnZhciBSZXR1cm4gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZXR1cm4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmV0dXJuKGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYSA9IGE7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJldHVybjtcbn0oRnJlZSkpO1xuZXhwb3J0cy5SZXR1cm4gPSBSZXR1cm47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GcmVlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiB3cmFwSU8gYSB2YWx1ZSBpbiB0aGUgSU8gbW9uYWRcbiAqL1xuZXhwb3J0cy53cmFwSU8gPSBmdW5jdGlvbiAoYSkgeyByZXR1cm4gbmV3IElPKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGE7IH0pOyB9O1xuLyoqXG4gKiBzYWZlSU8gYWNjZXB0cyBhIGZ1bmN0aW9uIHRoYXQgaGFzIHNpZGUgZWZmZWN0cyBhbmQgd3JhcElPcyBpdCBpbiBhbiBJTyBNb25hZC5cbiAqL1xuZXhwb3J0cy5zYWZlSU8gPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gbmV3IElPKGYpOyB9O1xuZXhwb3J0cy5wdXJlID0gZXhwb3J0cy53cmFwSU87XG5leHBvcnRzLnN1c3BlbmQgPSBleHBvcnRzLnNhZmVJTztcbi8qKlxuICogSU8gbW9uYWRpYyB0eXBlIGZvciBjb250YWluaW5nIGludGVyYWN0aW9ucyB3aXRoIHRoZSAncmVhbCB3b3JsZCcuXG4gKi9cbnZhciBJTyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSU8oZWZmZWN0KSB7XG4gICAgICAgIHRoaXMuZWZmZWN0ID0gZWZmZWN0O1xuICAgIH1cbiAgICBJTy5wcm90b3R5cGUub2YgPSBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gbmV3IElPKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHY7IH0pO1xuICAgIH07XG4gICAgSU8ucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgSU8oZnVuY3Rpb24gKCkgeyByZXR1cm4gZihfdGhpcy5lZmZlY3QoKSk7IH0pO1xuICAgIH07XG4gICAgSU8ucHJvdG90eXBlLm1hcEluID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGI7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogY2hhaW5cbiAgICAgKi9cbiAgICBJTy5wcm90b3R5cGUuY2hhaW4gPSBmdW5jdGlvbiAoZikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IElPKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGYoX3RoaXMuZWZmZWN0KCkpLnJ1bigpOyB9KTtcbiAgICB9O1xuICAgIElPLnByb3RvdHlwZS5jaGFpbkluID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhaW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhwb3J0cy53cmFwSU8oYik7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogcnVuXG4gICAgICovXG4gICAgSU8ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWZmZWN0KCk7XG4gICAgfTtcbiAgICBJTy5zYWZlSU8gPSBleHBvcnRzLnNhZmVJTztcbiAgICBJTy5wdXJlID0gZXhwb3J0cy5wdXJlO1xuICAgIElPLnN1c3BlbmQgPSBleHBvcnRzLnN1c3BlbmQ7XG4gICAgSU8uY2hhaW4gPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0uY2hhaW4oZik7IH07IH07XG4gICAgcmV0dXJuIElPO1xufSgpKTtcbmV4cG9ydHMuSU8gPSBJTztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlPLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBJZGVudGl0eVxuICovXG52YXIgSWRlbnRpdHkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElkZW50aXR5KGEpIHtcbiAgICAgICAgdGhpcy5hID0gYTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogb2ZcbiAgICAgKi9cbiAgICBJZGVudGl0eS5wcm90b3R5cGUub2YgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gbmV3IElkZW50aXR5KGEpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogbWFwXG4gICAgICovXG4gICAgSWRlbnRpdHkucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBuZXcgSWRlbnRpdHkoZih0aGlzLmdldCgpKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBjaGFpblxuICAgICAqL1xuICAgIElkZW50aXR5LnByb3RvdHlwZS5jaGFpbiA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBmKHRoaXMuZ2V0KCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogYXBcbiAgICAgKi9cbiAgICBJZGVudGl0eS5wcm90b3R5cGUuYXAgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gaS5tYXAoZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYoX3RoaXMuZ2V0KCkpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGdldCB0aGUgdmFsdWUgb2YgYW4gSWRlbnRpdHlcbiAgICAgKiBAc3VtbWFyeSBnZXQgOjogSWRlbnRpdHk8QT4g4oaSICBBXG4gICAgICovXG4gICAgSWRlbnRpdHkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYTtcbiAgICB9O1xuICAgIHJldHVybiBJZGVudGl0eTtcbn0oKSk7XG5leHBvcnRzLklkZW50aXR5ID0gSWRlbnRpdHk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JZGVudGl0eS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEVpdGhlcl8xID0gcmVxdWlyZShcIi4vRWl0aGVyXCIpO1xuLyoqXG4gKiBqdXN0IHdyYXBzIGEgdmFsdWUgaW4gYSBKdXN0XG4gKi9cbmV4cG9ydHMuanVzdCA9IGZ1bmN0aW9uIChhKSB7IHJldHVybiBuZXcgSnVzdChhKTsgfTtcbjtcbi8qKlxuICogbm90aGluZyBjb25zdHJ1Y3RzIG5vdGhpbmdcbiAqL1xuZXhwb3J0cy5ub3RoaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IE5vdGhpbmcoKTsgfTtcbi8qKlxuICogZnJvbUFueSBjb25zdHJ1Y3RzIGEgTWF5YmUgZnJvbSBhIHZhbHVlIHRoYXQgbWF5IGJlIG51bGwuXG4gKi9cbmV4cG9ydHMuZnJvbUFueSA9IGZ1bmN0aW9uIChhKSB7IHJldHVybiBhID09IG51bGwgPyBleHBvcnRzLm5vdGhpbmcoKSA6IGV4cG9ydHMuanVzdChhKTsgfTtcbi8qKlxuICogZnJvbUFycmF5IGNoZWNrcyBhbiBhcnJheSB0byBzZWUgaWYgaXQncyBlbXB0eSAob3IgZnVsbCBvZiBudWxscylcbiAqIGFuZCByZXR1cm5zIGEgTWF5YmUuXG4gKi9cbmV4cG9ydHMuZnJvbUFycmF5ID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gKChhLmxlbmd0aCA9PT0gMCkgfHwgKGEucmVkdWNlKGZ1bmN0aW9uIChjLCB2KSB7IHJldHVybiAodiA9PSBudWxsKSA/IGMgKyAxIDogYzsgfSwgMCkgPT09IGEubGVuZ3RoKSkgP1xuICAgICAgICBleHBvcnRzLm5vdGhpbmcoKSA6IGV4cG9ydHMuanVzdChhKTtcbn07XG4vKipcbiAqIGZyb21PQmplY3QgdXNlcyBPYmplY3Qua2V5cyB0byB0dXJuIHNlZSBpZiBhbiBvYmplY3QgaGFzIGFueSBvd24gcHJvcGVydGllcy5cbiAqL1xuZXhwb3J0cy5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobykubGVuZ3RoID09PSAwID8gZXhwb3J0cy5ub3RoaW5nKCkgOiBleHBvcnRzLmp1c3Qobyk7XG59O1xuLyoqXG4gKiBmcm9tU3RyaW5nIGNvbnN0cnVjdHMgbm90aGluZyBpZiB0aGUgc3RyaW5nIGlzIGVtcHR5IG9yIGp1c3Qgb3RoZXJ3aXNlLlxuICovXG5leHBvcnRzLmZyb21TdHJpbmcgPSBmdW5jdGlvbiAocykge1xuICAgIHJldHVybiAocyA9PT0gJycpID8gZXhwb3J0cy5ub3RoaW5nKCkgOiBleHBvcnRzLmp1c3Qocyk7XG59O1xuLyoqXG4gKiBmcm9tQm9vbGVhbiBjb25zdHJ1Y3RzIG5vdGhpbmcgaWYgYiBpcyBmYWxzZSwganVzdCBvdGhlcndpc2VcbiAqL1xuZXhwb3J0cy5mcm9tQm9vbGVhbiA9IGZ1bmN0aW9uIChiKSB7XG4gICAgcmV0dXJuIChiID09PSBmYWxzZSkgPyBleHBvcnRzLm5vdGhpbmcoKSA6IGV4cG9ydHMuanVzdChiKTtcbn07XG4vKipcbiAqIGZyb21OdW1iZXIgY29uc3RydWN0cyBub3RoaW5nIGlmIG4gaXMgMCBqdXN0IG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0cy5mcm9tTnVtYmVyID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gKG4gPT09IDApID8gZXhwb3J0cy5ub3RoaW5nKCkgOiBleHBvcnRzLmp1c3Qobik7XG59O1xuLyoqXG4gKiBNYXliZVxuICovXG52YXIgTWF5YmUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1heWJlKCkge1xuICAgIH1cbiAgICBNYXliZS5wcm90b3R5cGUub2YgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gbmV3IEp1c3QoYSk7XG4gICAgfTtcbiAgICBNYXliZS5qdXN0ID0gZXhwb3J0cy5qdXN0O1xuICAgIE1heWJlLm5vdGhpbmcgPSBleHBvcnRzLm5vdGhpbmc7XG4gICAgTWF5YmUuZnJvbUFueSA9IGV4cG9ydHMuZnJvbUFueTtcbiAgICBNYXliZS5mcm9tT2JqZWN0ID0gZXhwb3J0cy5mcm9tT2JqZWN0O1xuICAgIE1heWJlLmZyb21BcnJheSA9IGV4cG9ydHMuZnJvbUFycmF5O1xuICAgIE1heWJlLmZyb21TdHJpbmcgPSBleHBvcnRzLmZyb21TdHJpbmc7XG4gICAgTWF5YmUuZnJvbUJvb2xlYW4gPSBleHBvcnRzLmZyb21Cb29sZWFuO1xuICAgIE1heWJlLmZyb21OdW1iZXIgPSBleHBvcnRzLmZyb21OdW1iZXI7XG4gICAgcmV0dXJuIE1heWJlO1xufSgpKTtcbmV4cG9ydHMuTWF5YmUgPSBNYXliZTtcbi8qKlxuICogTm90aGluZ1xuICovXG52YXIgTm90aGluZyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5vdGhpbmcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTm90aGluZygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBOb3RoaW5nLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICByZXR1cm4gbmV3IE5vdGhpbmcoKTtcbiAgICB9O1xuICAgIE5vdGhpbmcucHJvdG90eXBlLmNoYWluID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb3RoaW5nKCk7XG4gICAgfTtcbiAgICBOb3RoaW5nLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBnZXQgYW55dGhpbmcgZnJvbSBOb3RoaW5nIScpO1xuICAgIH07XG4gICAgTm90aGluZy5wcm90b3R5cGUub3JFbHNlID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIGYoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIG9ySnVzdCB3aWxsIHR1cm4gTm90aGluZyBpbnRvIEp1c3QsIHdyYXBwaW5nIHRoZSB2YWx1ZSBzcGVjaWZpZWQuXG4gICAgICovXG4gICAgTm90aGluZy5wcm90b3R5cGUub3JKdXN0ID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuanVzdChmKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogY2F0YSBhcHBsaWVzIHRoZSBjb3JyZXNwb25kaW5nIGZ1bmN0aW9uIHRvIHRoZSBNYXliZVxuICAgICAqL1xuICAgIE5vdGhpbmcucHJvdG90eXBlLmNhdGEgPSBmdW5jdGlvbiAoZiwgX2cpIHtcbiAgICAgICAgcmV0dXJuIGYoKTtcbiAgICB9O1xuICAgIE5vdGhpbmcucHJvdG90eXBlLnRvRWl0aGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gRWl0aGVyXzEubGVmdCh1bmRlZmluZWQpO1xuICAgIH07XG4gICAgcmV0dXJuIE5vdGhpbmc7XG59KE1heWJlKSk7XG5leHBvcnRzLk5vdGhpbmcgPSBOb3RoaW5nO1xuLyoqXG4gKiBKdXN0XG4gKi9cbnZhciBKdXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSnVzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBKdXN0KGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYSA9IGE7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSnVzdC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBKdXN0KGYodGhpcy5hKSk7XG4gICAgfTtcbiAgICBKdXN0LnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hO1xuICAgIH07XG4gICAgSnVzdC5wcm90b3R5cGUuY2hhaW4gPSBmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gZih0aGlzLmEpO1xuICAgIH07XG4gICAgSnVzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hO1xuICAgIH07XG4gICAgSnVzdC5wcm90b3R5cGUub3JFbHNlID0gZnVuY3Rpb24gKF9mKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgSnVzdC5wcm90b3R5cGUub3JKdXN0ID0gZnVuY3Rpb24gKF9mKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgSnVzdC5wcm90b3R5cGUuY2F0YSA9IGZ1bmN0aW9uIChfZiwgZykge1xuICAgICAgICByZXR1cm4gZyh0aGlzLmEpO1xuICAgIH07XG4gICAgSnVzdC5wcm90b3R5cGUudG9FaXRoZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBFaXRoZXJfMS5yaWdodCh0aGlzLmEpO1xuICAgIH07XG4gICAgcmV0dXJuIEp1c3Q7XG59KE1heWJlKSk7XG5leHBvcnRzLkp1c3QgPSBKdXN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWF5YmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIGdldCB0aGUgc3RhdGUgZnJvbSB0aGUgaW50ZXJuYWxzIG9mIHRoZSBtb25hZFxuICovXG5leHBvcnRzLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBTdGF0ZShmdW5jdGlvbiAocykgeyByZXR1cm4gKFtzLCBzXSk7IH0pOyB9O1xuLyoqXG4gKiBwdXRcbiAqL1xuZXhwb3J0cy5wdXQgPSBmdW5jdGlvbiAocykgeyByZXR1cm4gbmV3IFN0YXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIChbbnVsbCwgc10pOyB9KTsgfTtcbi8qKlxuICogbW9kaWZ5IHRoZSBzdGF0ZVxuICogQHN1bW1hcnkgIChTIOKGkiAgUykg4oaSICBTdGF0ZTxTIOKGkiAge0EsIFN9ID5cbiAqL1xuZXhwb3J0cy5tb2RpZnkgPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gZXhwb3J0cy5nZXQoKS5jaGFpbihmdW5jdGlvbiAocykgeyByZXR1cm4gZXhwb3J0cy5wdXQoZihzKSk7IH0pOyB9O1xuLyoqXG4gKiBnZXRzIGFwcGxpZXMgYSBmdW5jdGlvbiB0byB0aGUgc3RhdGUgcHV0dGluZyB1c2luZyB0aGUgcmVzdWx0XG4gKiBhcyB0aGUgcmVzdWx0IG9mIHRoZSBjb21wdXRhdGlvbi5cbiAqIEBzdW1tYXJ5IChTIOKGkiAgQSkg4oaSICBTdGF0ZTxTIOKGkiAge0EsIFN9PlxuICovXG5leHBvcnRzLmdldHMgPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gZXhwb3J0cy5nZXQoKS5jaGFpbihmdW5jdGlvbiAocykgeyByZXR1cm4gZXhwb3J0cy5zdGF0ZShmKHMpKTsgfSk7IH07XG4vKipcbiAqIHN0YXRlIGNyZWF0ZSBhIG5ldyBTdGF0ZSBtb25hZFxuICovXG5leHBvcnRzLnN0YXRlID0gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIG5ldyBTdGF0ZShmdW5jdGlvbiAocykgeyByZXR1cm4gKFthLCBzXSk7IH0pOyB9O1xuLyoqXG4gKiBTdGF0ZSBpcyBhIG1vbmFkaWMgY2xhc3MgdGhhdCB3ZSB1c2UgdG8gaG9sZCBpbmZvcm1hdGlvbiB0aGF0IGNoYW5nZXNcbiAqIGR1cmluZyBjb21wdXRhdGlvbi5cbiAqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGluZmx1ZW5jZWQgYnk6XG4gKiBAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb25hZF8oZnVuY3Rpb25hbF9wcm9ncmFtbWluZykjU3RhdGVfbW9uYWRzXG4gKiBAcHJvcGVydHkge3Mg4oaSICAoYSwgcyl9IGFcbiAqL1xudmFyIFN0YXRlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0ZShmKSB7XG4gICAgICAgIHRoaXMuZiA9IGY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIG9mIHdyYXBzIGEgdmFsdWUgaW4gdGhlIFN0YXRlIG1vbmFkLlxuICAgICAqIEBzdW1tYXJ5IEEg4oaSICBTdGF0ZTxT4oaSIHtBLFN9PlxuICAgICAqL1xuICAgIFN0YXRlLnByb3RvdHlwZS5vZiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhdGUoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIChbYSwgc10pOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIG1hcFxuICAgICAqIEBzdW1tYXJ5IFN0YXRlPFMg4oaSIHtBLFN9PiDihpIgIChBIOKGkiAgQikg4oaSICBTdGF0ZTxTIOKGkiAge0MsIFN9PlxuICAgICAqL1xuICAgIFN0YXRlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFN0YXRlKGZ1bmN0aW9uICh4cykge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMucnVuKHhzKSwgYSA9IF9hWzBdLCBzID0gX2FbMV07XG4gICAgICAgICAgICByZXR1cm4gW2YoYSksIHNdO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGpvaW4gcmVwbGFjZXMgdGhlIG91dGVyIFN0YXRlIHdpdGggYW4gaW5uZXIgU3RhdGVcbiAgICAgKi9cbiAgICBTdGF0ZS5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBTdGF0ZShmdW5jdGlvbiAoeHMpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnJ1bih4cyksIGEgPSBfYVswXSwgcyA9IF9hWzFdO1xuICAgICAgICAgICAgcmV0dXJuIGEucnVuKHMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGNoYWluXG4gICAgICovXG4gICAgU3RhdGUucHJvdG90eXBlLmNoYWluID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwKGYpLmpvaW4oKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGV2YWx1YXRlIHRoZSBTdGF0ZSByZXR1cm5pbmcgdGhlIGZpbmFsIHZhbHVlXG4gICAgICovXG4gICAgU3RhdGUucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucnVuKHMpWzBdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZXhlY3V0ZSB0aGUgU3RhdGUgcmV0dXJuaW5nIHRoZSBmaW5hbCBzdGF0ZS5cbiAgICAgKi9cbiAgICBTdGF0ZS5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJ1bihzKVsxXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHJ1biB0aGUgU3RhdGUgeWllbGRpbmcgdGhlIGZpbmFsIHZhbHVlIGFuZCBzdGF0ZS5cbiAgICAgKiBAc3VtbWFyeSBTdGF0ZTxT4oaSIHtBPFN9PiDihpIgIFMg4oaSICB7QSxTfVxuICAgICAqL1xuICAgIFN0YXRlLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gdGhpcy5mKHMpO1xuICAgIH07XG4gICAgU3RhdGUuZ2V0ID0gZXhwb3J0cy5nZXQ7XG4gICAgU3RhdGUucHV0ID0gZXhwb3J0cy5wdXQ7XG4gICAgU3RhdGUubW9kaWZ5ID0gZXhwb3J0cy5tb2RpZnk7XG4gICAgU3RhdGUuZ2V0cyA9IGV4cG9ydHMuZ2V0cztcbiAgICBTdGF0ZS5zdGF0ZSA9IGV4cG9ydHMuc3RhdGU7XG4gICAgcmV0dXJuIFN0YXRlO1xufSgpKTtcbmV4cG9ydHMuU3RhdGUgPSBTdGF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0YXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuO1xuLyoqXG4gKiBpZGVudGl0eSBpcyB0aGUgZmFtZWQgaWRlbnRpdHkgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydHMuaWRlbnRpdHkgPSBmdW5jdGlvbiAoYSkgeyByZXR1cm4gYTsgfTtcbi8qKlxuICogbWVyZ2UgdHdvIG9iamVjdHMgZWFzaWx5XG4gKi9cbmV4cG9ydHMubWVyZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG8gPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduLmFwcGx5KE9iamVjdCwgW3t9XS5jb25jYXQobykpO1xufTtcbi8qKlxuICogZnVzZSBpcyB0aGUgZGVlcCB2ZXJzaW9uIG9mIG1lcmdlXG4gKi9cbmV4cG9ydHMuZnVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIGFyZ3MucmVkdWNlKGZ1bmN0aW9uIChvLCBjKSB7XG4gICAgICAgIGlmIChjID09PSB2b2lkIDApIHsgYyA9IHt9OyB9XG4gICAgICAgIHJldHVybiBleHBvcnRzLnJlZHVjZShjLCBmdW5jdGlvbiAoY28sIGNjLCBrKSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShjYykgP1xuICAgICAgICAgICAgICAgIChBcnJheS5pc0FycmF5KGNvW2tdKSA/XG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHMubWVyZ2UoY28sIChfYSA9IHt9LCBfYVtrXSA9IChjb1trXSkubWFwKGV4cG9ydHMuY29weSkuY29uY2F0KGNjLm1hcChleHBvcnRzLmNvcHkpKSwgX2EpKSA6XG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHMubWVyZ2UoY28sIChfYiA9IHt9LCBfYltrXSA9IGNjLm1hcChleHBvcnRzLmNvcHkpLCBfYikpKSA6XG4gICAgICAgICAgICAgICAgdHlwZW9mIGNjICE9PSAnb2JqZWN0JyA/XG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHMubWVyZ2UoY28sIChfYyA9IHt9LCBfY1trXSA9IGNjLCBfYykpIDpcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0cy5tZXJnZShjbywgKF9kID0ge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBfZFtrXSA9ICh0eXBlb2YgY29ba10gIT09ICdvYmplY3QnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0cy5tZXJnZShjb1trXSwgY2MpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRzLmZ1c2UoY29ba10sIGNjKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kKSk7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIH0sIG8pO1xuICAgIH0sIHt9KTtcbn07XG5leHBvcnRzLmNvcHkgPSBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiAoQXJyYXkuaXNBcnJheShvKSkgP1xuICAgICAgICBvLm1hcChleHBvcnRzLmNvcHkpIDpcbiAgICAgICAgKHR5cGVvZiBvID09PSAnb2JqZWN0JykgP1xuICAgICAgICAgICAgZXhwb3J0cy5yZWR1Y2UobywgZnVuY3Rpb24gKHAsIGMsIGspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5tZXJnZShwLCAoX2EgPSB7fSwgX2Fba10gPSBleHBvcnRzLmNvcHkoYyksIF9hKSk7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgfSwge30pIDogbztcbn07XG4vKipcbiAqIHJlZHVjZSBhbiBvYmplY3QncyBrZXlzIChpbiBubyBndWFyYW50ZWVkIG9yZGVyKVxuICovXG5leHBvcnRzLnJlZHVjZSA9IGZ1bmN0aW9uIChvLCBmLCBhY2N1bSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvKS5yZWR1Y2UoZnVuY3Rpb24gKHAsIGspIHsgcmV0dXJuIGYocCwgb1trXSwgaywgbyk7IH0sIGFjY3VtKTtcbn07XG4vKipcbiAqIG1hcCBvdmVyIGFuIG9iamVjdCAoaW4gbm8gZ3VhcmFudGVlZCBvcmVkZXIpXG4gKi9cbmV4cG9ydHMubWFwID0gZnVuY3Rpb24gKG8sIGYpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobykubWFwKChmdW5jdGlvbiAoaykgeyByZXR1cm4gZihvW2tdLCBrLCBvKTsgfSkpO1xufTtcbi8qKlxuICogY29tcG9zZSB0d28gZnVuY3Rpb25zIGludG8gb25lLlxuICovXG5leHBvcnRzLmNvbXBvc2UgPSBmdW5jdGlvbiAoZiwgZykgeyByZXR1cm4gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIGYoZyh4KSk7IH07IH07XG4vKipcbiAqIGZsaW5nIHJlbW92ZXMgYSBrZXkgZnJvbSBhbiBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBzdW1tYXJ5IHsoc3RyaW5nLE9iamVjdCkg4oaSICBPYmplY3R9XG4gKi9cbmV4cG9ydHMuZmxpbmcgPSBmdW5jdGlvbiAocywgbykge1xuICAgIGlmICgobyA9PSBudWxsKSB8fCAoby5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZmxpbmcoKTogb25seSB3b3JrcyB3aXRoIG9iamVjdCBsaXRlcmFscyEnKTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobykucmVkdWNlKGZ1bmN0aW9uIChvMiwgaykge1xuICAgICAgICByZXR1cm4gayA9PT0gcyA/IG8yIDogZXhwb3J0cy5tZXJnZShvMiwgKF9hID0ge30sXG4gICAgICAgICAgICBfYVtrXSA9IG9ba10sXG4gICAgICAgICAgICBfYSkpO1xuICAgICAgICB2YXIgX2E7XG4gICAgfSwge30pO1xufTtcbi8qKlxuICogaGVhZCByZXR1cm5zIHRoZSBpdGVtIGF0IGluZGV4IDAgb2YgYW4gYXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3RcbiAqIEByZXR1cm4geyp9XG4gKiBAc3VtbWFyeSB7IEFycmF5IOKGkiAgKiB9XG4gKi9cbmV4cG9ydHMuaGVhZCA9IGZ1bmN0aW9uIChsaXN0KSB7IHJldHVybiBsaXN0WzBdOyB9O1xuLyoqXG4gKiB0YWlsIHJldHVybnMgdGhlIGxhc3QgaXRlbSBpbiBhbiBhcnJheVxuICogQHBhcmFtIHtBcnJheX0gbGlzdFxuICogQHJldHVybiB7Kn1cbiAqIEBzdW1tYXJ5IHtBcnJheSDihpIgICp9XG4gKi9cbmV4cG9ydHMudGFpbCA9IGZ1bmN0aW9uIChsaXN0KSB7IHJldHVybiBsaXN0W2xpc3QubGVuZ3RoIC0gMV07IH07XG4vKipcbiAqIGNvbnN0YW50IGdpdmVuIGEgdmFsdWUsIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgYWx3YXlzIHJldHVybnMgdGhpcyB2YWx1ZS5cbiAqIEBzdW1tYXJ5IGNvbnN0YW50IFgg4oaSICAqIOKGkiAgWFxuICpcbiAqL1xuZXhwb3J0cy5jb25zdGFudCA9IGZ1bmN0aW9uIChhKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBhOyB9OyB9O1xuLyoqXG4gKiBmMSBwYXJ0aWFsIGFwcGxpY2F0aW9uLlxuICovXG5leHBvcnRzLmYxID0gZnVuY3Rpb24gKGYpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gZi5hcHBseShudWxsLCBhcmdzLmNvbmNhdChhKSk7IH07XG59O1xuLyoqXG4gKiBmMiBwYXJ0aWFsIGFwcGxpY2F0aW9uXG4gKi9cbmV4cG9ydHMuZjIgPSBmdW5jdGlvbiAoZikge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7IHJldHVybiBmdW5jdGlvbiAoYWEpIHsgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncy5jb25jYXQoYSwgYWEpKTsgfTsgfTtcbn07XG4vKipcbiAqIGYzIHBhcnRpYWwgYXBwbGljYXRpb25cbiAqL1xuZXhwb3J0cy5mMyA9IGZ1bmN0aW9uIChmKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGZ1bmN0aW9uIChhYSkgeyByZXR1cm4gZnVuY3Rpb24gKGFhYSkgeyByZXR1cm4gZi5hcHBseShudWxsLCBhcmdzLmNvbmNhdChhLCBhYSwgYWFhKSk7IH07IH07IH07XG59O1xuLyoqXG4gKiBmNCBwYXJ0aWFsIGFwcGxpY2F0aW9uXG4gKi9cbmV4cG9ydHMuZjQgPSBmdW5jdGlvbiAoZikge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7IHJldHVybiBmdW5jdGlvbiAoYWEpIHsgcmV0dXJuIGZ1bmN0aW9uIChhYWEpIHsgcmV0dXJuIGZ1bmN0aW9uIChhYWFhKSB7XG4gICAgICAgIHJldHVybiBmLmFwcGx5KG51bGwsIGFyZ3MuY29uY2F0KGEsIGFhLCBhYWEsIGFhYWEpKTtcbiAgICB9OyB9OyB9OyB9O1xufTtcbi8qKlxuICogZjUgcGFydGlhbCBhcHBsaWNhdGlvblxuICovXG5leHBvcnRzLmY1ID0gZnVuY3Rpb24gKGYpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gZnVuY3Rpb24gKGFhKSB7IHJldHVybiBmdW5jdGlvbiAoYWFhKSB7IHJldHVybiBmdW5jdGlvbiAoYWFhYSkgeyByZXR1cm4gZnVuY3Rpb24gKGFhYWFhKSB7XG4gICAgICAgIHJldHVybiBmLmFwcGx5KG51bGwsIGFyZ3MuY29uY2F0KGEsIGFhLCBhYWEsIGFhYWEsIGFhYWFhKSk7XG4gICAgfTsgfTsgfTsgfTsgfTtcbn07XG4vKipcbiAqIGV4Y2VwdCBjb3BpZXMgYW4gb2JqZWN0IHJlbW92aW5nIGEgc2luZ2xlIGtleS5cbiAqL1xuZXhwb3J0cy5leGNlcHQgPSBmdW5jdGlvbiAoa2V5cywgbykge1xuICAgIHJldHVybiBleHBvcnRzLnJlZHVjZShvLCBmdW5jdGlvbiAocCwgYywgaykge1xuICAgICAgICByZXR1cm4ga2V5cy5pbmRleE9mKGspID4gLTEgPyBwIDogZXhwb3J0cy5tZXJnZShwLCAoX2EgPSB7fSwgX2Fba10gPSBjLCBfYSkpO1xuICAgICAgICB2YXIgX2E7XG4gICAgfSwge30pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8qXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE3IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cblxuKi9cblxuLyoqXG5UaGUgZm9sbG93aW5nIGJhdGNoZXMgYXJlIGVxdWl2YWxlbnQ6XG5cbnZhciBiZWF1dGlmeV9qcyA9IHJlcXVpcmUoJ2pzLWJlYXV0aWZ5Jyk7XG52YXIgYmVhdXRpZnlfanMgPSByZXF1aXJlKCdqcy1iZWF1dGlmeScpLmpzO1xudmFyIGJlYXV0aWZ5X2pzID0gcmVxdWlyZSgnanMtYmVhdXRpZnknKS5qc19iZWF1dGlmeTtcblxudmFyIGJlYXV0aWZ5X2NzcyA9IHJlcXVpcmUoJ2pzLWJlYXV0aWZ5JykuY3NzO1xudmFyIGJlYXV0aWZ5X2NzcyA9IHJlcXVpcmUoJ2pzLWJlYXV0aWZ5JykuY3NzX2JlYXV0aWZ5O1xuXG52YXIgYmVhdXRpZnlfaHRtbCA9IHJlcXVpcmUoJ2pzLWJlYXV0aWZ5JykuaHRtbDtcbnZhciBiZWF1dGlmeV9odG1sID0gcmVxdWlyZSgnanMtYmVhdXRpZnknKS5odG1sX2JlYXV0aWZ5O1xuXG5BbGwgbWV0aG9kcyByZXR1cm5lZCBhY2NlcHQgdHdvIGFyZ3VtZW50cywgdGhlIHNvdXJjZSBzdHJpbmcgYW5kIGFuIG9wdGlvbnMgb2JqZWN0LlxuKiovXG5cbmZ1bmN0aW9uIGdldF9iZWF1dGlmeShqc19iZWF1dGlmeSwgY3NzX2JlYXV0aWZ5LCBodG1sX2JlYXV0aWZ5KSB7XG4gICAgLy8gdGhlIGRlZmF1bHQgaXMganNcbiAgICB2YXIgYmVhdXRpZnkgPSBmdW5jdGlvbihzcmMsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4ganNfYmVhdXRpZnkuanNfYmVhdXRpZnkoc3JjLCBjb25maWcpO1xuICAgIH07XG5cbiAgICAvLyBzaG9ydCBhbGlhc2VzXG4gICAgYmVhdXRpZnkuanMgPSBqc19iZWF1dGlmeS5qc19iZWF1dGlmeTtcbiAgICBiZWF1dGlmeS5jc3MgPSBjc3NfYmVhdXRpZnkuY3NzX2JlYXV0aWZ5O1xuICAgIGJlYXV0aWZ5Lmh0bWwgPSBodG1sX2JlYXV0aWZ5Lmh0bWxfYmVhdXRpZnk7XG5cbiAgICAvLyBsZWdhY3kgYWxpYXNlc1xuICAgIGJlYXV0aWZ5LmpzX2JlYXV0aWZ5ID0ganNfYmVhdXRpZnkuanNfYmVhdXRpZnk7XG4gICAgYmVhdXRpZnkuY3NzX2JlYXV0aWZ5ID0gY3NzX2JlYXV0aWZ5LmNzc19iZWF1dGlmeTtcbiAgICBiZWF1dGlmeS5odG1sX2JlYXV0aWZ5ID0gaHRtbF9iZWF1dGlmeS5odG1sX2JlYXV0aWZ5O1xuXG4gICAgcmV0dXJuIGJlYXV0aWZ5O1xufVxuXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBBZGQgc3VwcG9ydCBmb3IgQU1EICggaHR0cHM6Ly9naXRodWIuY29tL2FtZGpzL2FtZGpzLWFwaS93aWtpL0FNRCNkZWZpbmVhbWQtcHJvcGVydHktIClcbiAgICBkZWZpbmUoW1xuICAgICAgICBcIi4vbGliL2JlYXV0aWZ5XCIsXG4gICAgICAgIFwiLi9saWIvYmVhdXRpZnktY3NzXCIsXG4gICAgICAgIFwiLi9saWIvYmVhdXRpZnktaHRtbFwiXG4gICAgXSwgZnVuY3Rpb24oanNfYmVhdXRpZnksIGNzc19iZWF1dGlmeSwgaHRtbF9iZWF1dGlmeSkge1xuICAgICAgICByZXR1cm4gZ2V0X2JlYXV0aWZ5KGpzX2JlYXV0aWZ5LCBjc3NfYmVhdXRpZnksIGh0bWxfYmVhdXRpZnkpO1xuICAgIH0pO1xufSBlbHNlIHtcbiAgICAoZnVuY3Rpb24obW9kKSB7XG4gICAgICAgIHZhciBqc19iZWF1dGlmeSA9IHJlcXVpcmUoJy4vbGliL2JlYXV0aWZ5Jyk7XG4gICAgICAgIHZhciBjc3NfYmVhdXRpZnkgPSByZXF1aXJlKCcuL2xpYi9iZWF1dGlmeS1jc3MnKTtcbiAgICAgICAgdmFyIGh0bWxfYmVhdXRpZnkgPSByZXF1aXJlKCcuL2xpYi9iZWF1dGlmeS1odG1sJyk7XG5cbiAgICAgICAgbW9kLmV4cG9ydHMgPSBnZXRfYmVhdXRpZnkoanNfYmVhdXRpZnksIGNzc19iZWF1dGlmeSwgaHRtbF9iZWF1dGlmeSk7XG5cbiAgICB9KShtb2R1bGUpO1xufSIsIi8qanNoaW50IGN1cmx5OmZhbHNlLCBlcWVxZXE6dHJ1ZSwgbGF4YnJlYWs6dHJ1ZSwgbm9lbXB0eTpmYWxzZSAqL1xuLyogQVVUTy1HRU5FUkFURUQuIERPIE5PVCBNT0RJRlkuICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE3IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cblxuXG4gQ1NTIEJlYXV0aWZpZXJcbi0tLS0tLS0tLS0tLS0tLVxuXG4gICAgV3JpdHRlbiBieSBIYXJ1dHl1biBBbWlyamFueWFuLCAoYW1pcmphbnlhbkBnbWFpbC5jb20pXG5cbiAgICBCYXNlZCBvbiBjb2RlIGluaXRpYWxseSBkZXZlbG9wZWQgYnk6IEVpbmFyIExpZWxtYW5pcywgPGVpbmFyQGpzYmVhdXRpZmllci5vcmc+XG4gICAgICAgIGh0dHA6Ly9qc2JlYXV0aWZpZXIub3JnL1xuXG4gICAgVXNhZ2U6XG4gICAgICAgIGNzc19iZWF1dGlmeShzb3VyY2VfdGV4dCk7XG4gICAgICAgIGNzc19iZWF1dGlmeShzb3VyY2VfdGV4dCwgb3B0aW9ucyk7XG5cbiAgICBUaGUgb3B0aW9ucyBhcmUgKGRlZmF1bHQgaW4gYnJhY2tldHMpOlxuICAgICAgICBpbmRlbnRfc2l6ZSAoNCkgICAgICAgICAgICAgICAgICAgICAgICAg4oCUIGluZGVudGF0aW9uIHNpemUsXG4gICAgICAgIGluZGVudF9jaGFyIChzcGFjZSkgICAgICAgICAgICAgICAgICAgICDigJQgY2hhcmFjdGVyIHRvIGluZGVudCB3aXRoLFxuICAgICAgICBzZWxlY3Rvcl9zZXBhcmF0b3JfbmV3bGluZSAodHJ1ZSkgICAgICAgLSBzZXBhcmF0ZSBzZWxlY3RvcnMgd2l0aCBuZXdsaW5lIG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdCAoZS5nLiBcImEsXFxuYnJcIiBvciBcImEsIGJyXCIpXG4gICAgICAgIGVuZF93aXRoX25ld2xpbmUgKGZhbHNlKSAgICAgICAgICAgICAgICAtIGVuZCB3aXRoIGEgbmV3bGluZVxuICAgICAgICBuZXdsaW5lX2JldHdlZW5fcnVsZXMgKHRydWUpICAgICAgICAgICAgLSBhZGQgYSBuZXcgbGluZSBhZnRlciBldmVyeSBjc3MgcnVsZVxuICAgICAgICBzcGFjZV9hcm91bmRfc2VsZWN0b3Jfc2VwYXJhdG9yIChmYWxzZSkgLSBlbnN1cmUgc3BhY2UgYXJvdW5kIHNlbGVjdG9yIHNlcGFyYXRvcnM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc+JywgJysnLCAnficgKGUuZy4gXCJhPmJcIiAtPiBcImEgPiBiXCIpXG4gICAgZS5nXG5cbiAgICBjc3NfYmVhdXRpZnkoY3NzX3NvdXJjZV90ZXh0LCB7XG4gICAgICAnaW5kZW50X3NpemUnOiAxLFxuICAgICAgJ2luZGVudF9jaGFyJzogJ1xcdCcsXG4gICAgICAnc2VsZWN0b3Jfc2VwYXJhdG9yJzogJyAnLFxuICAgICAgJ2VuZF93aXRoX25ld2xpbmUnOiBmYWxzZSxcbiAgICAgICduZXdsaW5lX2JldHdlZW5fcnVsZXMnOiB0cnVlLFxuICAgICAgJ3NwYWNlX2Fyb3VuZF9zZWxlY3Rvcl9zZXBhcmF0b3InOiB0cnVlXG4gICAgfSk7XG4qL1xuXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjdG9rZW5pemF0aW9uXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXN5bnRheC9cblxuKGZ1bmN0aW9uKCkge1xudmFyIGxlZ2FjeV9iZWF1dGlmeV9jc3MgPVxuLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4vKioqKioqLyBcdFx0XHRcdGdldDogZ2V0dGVyXG4vKioqKioqLyBcdFx0XHR9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qanNoaW50IGN1cmx5OnRydWUsIGVxZXFlcTp0cnVlLCBsYXhicmVhazp0cnVlLCBub2VtcHR5OmZhbHNlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE3IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cbnZhciBtZXJnZU9wdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpLm1lcmdlT3B0cztcbnZhciBhY29ybiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgT3V0cHV0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKS5PdXRwdXQ7XG5cblxudmFyIGxpbmVCcmVhayA9IGFjb3JuLmxpbmVCcmVhaztcbnZhciBhbGxMaW5lQnJlYWtzID0gYWNvcm4uYWxsTGluZUJyZWFrcztcblxuZnVuY3Rpb24gQmVhdXRpZmllcihzb3VyY2VfdGV4dCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gQWxsb3cgdGhlIHNldHRpbmcgb2YgbGFuZ3VhZ2UvZmlsZS10eXBlIHNwZWNpZmljIG9wdGlvbnNcbiAgICAvLyB3aXRoIGluaGVyaXRhbmNlIG9mIG92ZXJhbGwgc2V0dGluZ3NcbiAgICBvcHRpb25zID0gbWVyZ2VPcHRzKG9wdGlvbnMsICdjc3MnKTtcblxuICAgIHNvdXJjZV90ZXh0ID0gc291cmNlX3RleHQgfHwgJyc7XG5cbiAgICB2YXIgbmV3bGluZXNGcm9tTGFzdFdTRWF0ID0gMDtcbiAgICB2YXIgaW5kZW50U2l6ZSA9IG9wdGlvbnMuaW5kZW50X3NpemUgPyBwYXJzZUludChvcHRpb25zLmluZGVudF9zaXplLCAxMCkgOiA0O1xuICAgIHZhciBpbmRlbnRDaGFyYWN0ZXIgPSBvcHRpb25zLmluZGVudF9jaGFyIHx8ICcgJztcbiAgICB2YXIgcHJlc2VydmVfbmV3bGluZXMgPSAob3B0aW9ucy5wcmVzZXJ2ZV9uZXdsaW5lcyA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogb3B0aW9ucy5wcmVzZXJ2ZV9uZXdsaW5lcztcbiAgICB2YXIgc2VsZWN0b3JTZXBhcmF0b3JOZXdsaW5lID0gKG9wdGlvbnMuc2VsZWN0b3Jfc2VwYXJhdG9yX25ld2xpbmUgPT09IHVuZGVmaW5lZCkgPyB0cnVlIDogb3B0aW9ucy5zZWxlY3Rvcl9zZXBhcmF0b3JfbmV3bGluZTtcbiAgICB2YXIgZW5kX3dpdGhfbmV3bGluZSA9IChvcHRpb25zLmVuZF93aXRoX25ld2xpbmUgPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IG9wdGlvbnMuZW5kX3dpdGhfbmV3bGluZTtcbiAgICB2YXIgbmV3bGluZV9iZXR3ZWVuX3J1bGVzID0gKG9wdGlvbnMubmV3bGluZV9iZXR3ZWVuX3J1bGVzID09PSB1bmRlZmluZWQpID8gdHJ1ZSA6IG9wdGlvbnMubmV3bGluZV9iZXR3ZWVuX3J1bGVzO1xuICAgIHZhciBzcGFjZV9hcm91bmRfY29tYmluYXRvciA9IChvcHRpb25zLnNwYWNlX2Fyb3VuZF9jb21iaW5hdG9yID09PSB1bmRlZmluZWQpID8gZmFsc2UgOiBvcHRpb25zLnNwYWNlX2Fyb3VuZF9jb21iaW5hdG9yO1xuICAgIHNwYWNlX2Fyb3VuZF9jb21iaW5hdG9yID0gc3BhY2VfYXJvdW5kX2NvbWJpbmF0b3IgfHwgKChvcHRpb25zLnNwYWNlX2Fyb3VuZF9zZWxlY3Rvcl9zZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IG9wdGlvbnMuc3BhY2VfYXJvdW5kX3NlbGVjdG9yX3NlcGFyYXRvcik7XG4gICAgdmFyIGVvbCA9IG9wdGlvbnMuZW9sID8gb3B0aW9ucy5lb2wgOiAnYXV0byc7XG5cbiAgICBpZiAob3B0aW9ucy5pbmRlbnRfd2l0aF90YWJzKSB7XG4gICAgICAgIGluZGVudENoYXJhY3RlciA9ICdcXHQnO1xuICAgICAgICBpbmRlbnRTaXplID0gMTtcbiAgICB9XG5cbiAgICBpZiAoZW9sID09PSAnYXV0bycpIHtcbiAgICAgICAgZW9sID0gJ1xcbic7XG4gICAgICAgIGlmIChzb3VyY2VfdGV4dCAmJiBsaW5lQnJlYWsudGVzdChzb3VyY2VfdGV4dCB8fCAnJykpIHtcbiAgICAgICAgICAgIGVvbCA9IHNvdXJjZV90ZXh0Lm1hdGNoKGxpbmVCcmVhaylbMF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBlb2wgPSBlb2wucmVwbGFjZSgvXFxcXHIvLCAnXFxyJykucmVwbGFjZSgvXFxcXG4vLCAnXFxuJyk7XG5cbiAgICAvLyBIQUNLOiBuZXdsaW5lIHBhcnNpbmcgaW5jb25zaXN0ZW50LiBUaGlzIGJydXRlIGZvcmNlIG5vcm1hbGl6ZXMgdGhlIGlucHV0LlxuICAgIHNvdXJjZV90ZXh0ID0gc291cmNlX3RleHQucmVwbGFjZShhbGxMaW5lQnJlYWtzLCAnXFxuJyk7XG5cbiAgICAvLyB0b2tlbml6ZXJcbiAgICB2YXIgd2hpdGVSZSA9IC9eXFxzKyQvO1xuXG4gICAgdmFyIHBvcyA9IC0xLFxuICAgICAgICBjaDtcbiAgICB2YXIgcGFyZW5MZXZlbCA9IDA7XG5cbiAgICBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICBjaCA9IHNvdXJjZV90ZXh0LmNoYXJBdCgrK3Bvcyk7XG4gICAgICAgIHJldHVybiBjaCB8fCAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWVrKHNraXBXaGl0ZXNwYWNlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgdmFyIHByZXZfcG9zID0gcG9zO1xuICAgICAgICBpZiAoc2tpcFdoaXRlc3BhY2UpIHtcbiAgICAgICAgICAgIGVhdFdoaXRlc3BhY2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBzb3VyY2VfdGV4dC5jaGFyQXQocG9zICsgMSkgfHwgJyc7XG4gICAgICAgIHBvcyA9IHByZXZfcG9zIC0gMTtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVhdFN0cmluZyhlbmRDaGFycykge1xuICAgICAgICB2YXIgc3RhcnQgPSBwb3M7XG4gICAgICAgIHdoaWxlIChuZXh0KCkpIHtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVuZENoYXJzLmluZGV4T2YoY2gpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb3VyY2VfdGV4dC5zdWJzdHJpbmcoc3RhcnQsIHBvcyArIDEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZWtTdHJpbmcoZW5kQ2hhcikge1xuICAgICAgICB2YXIgcHJldl9wb3MgPSBwb3M7XG4gICAgICAgIHZhciBzdHIgPSBlYXRTdHJpbmcoZW5kQ2hhcik7XG4gICAgICAgIHBvcyA9IHByZXZfcG9zIC0gMTtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVhdFdoaXRlc3BhY2UocHJlc2VydmVfbmV3bGluZXNfbG9jYWwpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgICAgIHdoaWxlICh3aGl0ZVJlLnRlc3QocGVlaygpKSkge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnXFxuJyAmJiBwcmVzZXJ2ZV9uZXdsaW5lc19sb2NhbCAmJiBwcmVzZXJ2ZV9uZXdsaW5lcykge1xuICAgICAgICAgICAgICAgIG91dHB1dC5hZGRfbmV3X2xpbmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3bGluZXNGcm9tTGFzdFdTRWF0ID0gcmVzdWx0O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNraXBXaGl0ZXNwYWNlKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgIGlmIChjaCAmJiB3aGl0ZVJlLnRlc3QoY2gpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjaDtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAod2hpdGVSZS50ZXN0KG5leHQoKSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBjaDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVhdENvbW1lbnQoKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHBvcztcbiAgICAgICAgdmFyIHNpbmdsZUxpbmUgPSBwZWVrKCkgPT09IFwiL1wiO1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHdoaWxlIChuZXh0KCkpIHtcbiAgICAgICAgICAgIGlmICghc2luZ2xlTGluZSAmJiBjaCA9PT0gXCIqXCIgJiYgcGVlaygpID09PSBcIi9cIikge1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2luZ2xlTGluZSAmJiBjaCA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2VfdGV4dC5zdWJzdHJpbmcoc3RhcnQsIHBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc291cmNlX3RleHQuc3Vic3RyaW5nKHN0YXJ0LCBwb3MpICsgY2g7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBsb29rQmFjayhzdHIpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZV90ZXh0LnN1YnN0cmluZyhwb3MgLSBzdHIubGVuZ3RoLCBwb3MpLnRvTG93ZXJDYXNlKCkgPT09XG4gICAgICAgICAgICBzdHI7XG4gICAgfVxuXG4gICAgLy8gTmVzdGVkIHBzZXVkby1jbGFzcyBpZiB3ZSBhcmUgaW5zaWRlUnVsZVxuICAgIC8vIGFuZCB0aGUgbmV4dCBzcGVjaWFsIGNoYXJhY3RlciBmb3VuZCBvcGVuc1xuICAgIC8vIGEgbmV3IGJsb2NrXG4gICAgZnVuY3Rpb24gZm91bmROZXN0ZWRQc2V1ZG9DbGFzcygpIHtcbiAgICAgICAgdmFyIG9wZW5QYXJlbiA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSBwb3MgKyAxOyBpIDwgc291cmNlX3RleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaCA9IHNvdXJjZV90ZXh0LmNoYXJBdChpKTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICcoJykge1xuICAgICAgICAgICAgICAgIC8vIHBzZXVkb2NsYXNzZXMgY2FuIGNvbnRhaW4gKClcbiAgICAgICAgICAgICAgICBvcGVuUGFyZW4gKz0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICcpJykge1xuICAgICAgICAgICAgICAgIGlmIChvcGVuUGFyZW4gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcGVuUGFyZW4gLT0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiO1wiIHx8IGNoID09PSBcIn1cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gcHJpbnRlclxuICAgIHZhciBiYXNlSW5kZW50U3RyaW5nID0gJyc7XG4gICAgdmFyIHByZWluZGVudF9pbmRleCA9IDA7XG4gICAgaWYgKHNvdXJjZV90ZXh0ICYmIHNvdXJjZV90ZXh0Lmxlbmd0aCkge1xuICAgICAgICB3aGlsZSAoKHNvdXJjZV90ZXh0LmNoYXJBdChwcmVpbmRlbnRfaW5kZXgpID09PSAnICcgfHxcbiAgICAgICAgICAgICAgICBzb3VyY2VfdGV4dC5jaGFyQXQocHJlaW5kZW50X2luZGV4KSA9PT0gJ1xcdCcpKSB7XG4gICAgICAgICAgICBwcmVpbmRlbnRfaW5kZXggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBiYXNlSW5kZW50U3RyaW5nID0gc291cmNlX3RleHQuc3Vic3RyaW5nKDAsIHByZWluZGVudF9pbmRleCk7XG4gICAgICAgIGpzX3NvdXJjZV90ZXh0ID0gc291cmNlX3RleHQuc3Vic3RyaW5nKHByZWluZGVudF9pbmRleCk7XG4gICAgfVxuXG5cbiAgICB2YXIgc2luZ2xlSW5kZW50ID0gbmV3IEFycmF5KGluZGVudFNpemUgKyAxKS5qb2luKGluZGVudENoYXJhY3Rlcik7XG4gICAgdmFyIGluZGVudExldmVsO1xuICAgIHZhciBuZXN0ZWRMZXZlbDtcbiAgICB2YXIgb3V0cHV0O1xuXG4gICAgZnVuY3Rpb24gcHJpbnRfc3RyaW5nKG91dHB1dF9zdHJpbmcpIHtcbiAgICAgICAgaWYgKG91dHB1dC5qdXN0X2FkZGVkX25ld2xpbmUoKSkge1xuICAgICAgICAgICAgb3V0cHV0LnNldF9pbmRlbnQoaW5kZW50TGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5hZGRfdG9rZW4ob3V0cHV0X3N0cmluZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlc2VydmVTaW5nbGVTcGFjZShpc0FmdGVyU3BhY2UpIHtcbiAgICAgICAgaWYgKGlzQWZ0ZXJTcGFjZSkge1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbmRlbnQoKSB7XG4gICAgICAgIGluZGVudExldmVsKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb3V0ZGVudCgpIHtcbiAgICAgICAgaWYgKGluZGVudExldmVsID4gMCkge1xuICAgICAgICAgICAgaW5kZW50TGV2ZWwtLTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qX19fX19fX19fX19fX19fX19fX19fLS0tLS0tLS0tLS0tLS0tLS0tLS1fX19fX19fX19fX19fX19fX19fX18qL1xuXG4gICAgdGhpcy5iZWF1dGlmeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyByZXNldFxuICAgICAgICBvdXRwdXQgPSBuZXcgT3V0cHV0KHNpbmdsZUluZGVudCwgYmFzZUluZGVudFN0cmluZyk7XG4gICAgICAgIGluZGVudExldmVsID0gMDtcbiAgICAgICAgbmVzdGVkTGV2ZWwgPSAwO1xuXG4gICAgICAgIHBvcyA9IC0xO1xuICAgICAgICBjaCA9IG51bGw7XG4gICAgICAgIHBhcmVuTGV2ZWwgPSAwO1xuXG4gICAgICAgIHZhciBpbnNpZGVSdWxlID0gZmFsc2U7XG4gICAgICAgIHZhciBpbnNpZGVQcm9wZXJ0eVZhbHVlID0gZmFsc2U7XG4gICAgICAgIHZhciBlbnRlcmluZ0NvbmRpdGlvbmFsR3JvdXAgPSBmYWxzZTtcbiAgICAgICAgdmFyIHRvcF9jaCA9ICcnO1xuICAgICAgICB2YXIgbGFzdF90b3BfY2ggPSAnJztcblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdmFyIHdoaXRlc3BhY2UgPSBza2lwV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgdmFyIGlzQWZ0ZXJTcGFjZSA9IHdoaXRlc3BhY2UgIT09ICcnO1xuICAgICAgICAgICAgdmFyIGlzQWZ0ZXJOZXdsaW5lID0gd2hpdGVzcGFjZS5pbmRleE9mKCdcXG4nKSAhPT0gLTE7XG4gICAgICAgICAgICBsYXN0X3RvcF9jaCA9IHRvcF9jaDtcbiAgICAgICAgICAgIHRvcF9jaCA9IGNoO1xuXG4gICAgICAgICAgICBpZiAoIWNoKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnLycgJiYgcGVlaygpID09PSAnKicpIHsgLyogY3NzIGNvbW1lbnQgKi9cbiAgICAgICAgICAgICAgICB2YXIgaGVhZGVyID0gaW5kZW50TGV2ZWwgPT09IDA7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNBZnRlck5ld2xpbmUgfHwgaGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5hZGRfbmV3X2xpbmUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwcmludF9zdHJpbmcoZWF0Q29tbWVudCgpKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuYWRkX25ld19saW5lKCk7XG4gICAgICAgICAgICAgICAgaWYgKGhlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuYWRkX25ld19saW5lKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICcvJyAmJiBwZWVrKCkgPT09ICcvJykgeyAvLyBzaW5nbGUgbGluZSBjb21tZW50XG4gICAgICAgICAgICAgICAgaWYgKCFpc0FmdGVyTmV3bGluZSAmJiBsYXN0X3RvcF9jaCAhPT0gJ3snKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC50cmltKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwcmludF9zdHJpbmcoZWF0Q29tbWVudCgpKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuYWRkX25ld19saW5lKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnQCcpIHtcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZVNpbmdsZVNwYWNlKGlzQWZ0ZXJTcGFjZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBkZWFsIHdpdGggbGVzcyBwcm9wZXJ5IG1peGlucyBAey4uLn1cbiAgICAgICAgICAgICAgICBpZiAocGVlaygpID09PSAneycpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRfc3RyaW5nKGVhdFN0cmluZygnfScpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmludF9zdHJpbmcoY2gpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0cmlwIHRyYWlsaW5nIHNwYWNlLCBpZiBwcmVzZW50LCBmb3IgaGFzaCBwcm9wZXJ0eSBjaGVja3NcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhcmlhYmxlT3JSdWxlID0gcGVla1N0cmluZyhcIjogLDt7fSgpW10vPSdcXFwiXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YXJpYWJsZU9yUnVsZS5tYXRjaCgvWyA6XSQvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSBhIHZhcmlhYmxlIG9yIHBzZXVkby1jbGFzcywgYWRkIGl0IGFuZCBpbnNlcnQgb25lIHNwYWNlIGJlZm9yZSBjb250aW51aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZU9yUnVsZSA9IGVhdFN0cmluZyhcIjogXCIpLnJlcGxhY2UoL1xccyQvLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmludF9zdHJpbmcodmFyaWFibGVPclJ1bGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZU9yUnVsZSA9IHZhcmlhYmxlT3JSdWxlLnJlcGxhY2UoL1xccyQvLCAnJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbWlnaHQgYmUgYSBuZXN0aW5nIGF0LXJ1bGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhcmlhYmxlT3JSdWxlIGluIHRoaXMuTkVTVEVEX0FUX1JVTEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lc3RlZExldmVsICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFyaWFibGVPclJ1bGUgaW4gdGhpcy5DT05ESVRJT05BTF9HUk9VUF9SVUxFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50ZXJpbmdDb25kaXRpb25hbEdyb3VwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICcjJyAmJiBwZWVrKCkgPT09ICd7Jykge1xuICAgICAgICAgICAgICAgIHByZXNlcnZlU2luZ2xlU3BhY2UoaXNBZnRlclNwYWNlKTtcbiAgICAgICAgICAgICAgICBwcmludF9zdHJpbmcoZWF0U3RyaW5nKCd9JykpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ3snKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBlZWsodHJ1ZSkgPT09ICd9Jykge1xuICAgICAgICAgICAgICAgICAgICBlYXRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHByaW50X3N0cmluZyhcInt9XCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVhdFdoaXRlc3BhY2UodHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5hZGRfbmV3X2xpbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdsaW5lc0Zyb21MYXN0V1NFYXQgPCAyICYmIG5ld2xpbmVfYmV0d2Vlbl9ydWxlcyAmJiBpbmRlbnRMZXZlbCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmFkZF9uZXdfbGluZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRfc3RyaW5nKGNoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlYXRXaGl0ZXNwYWNlKHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuYWRkX25ld19saW5lKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIGVudGVyaW5nIGNvbmRpdGlvbmFsIGdyb3Vwcywgb25seSBydWxlc2V0cyBhcmUgYWxsb3dlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoZW50ZXJpbmdDb25kaXRpb25hbEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRlcmluZ0NvbmRpdGlvbmFsR3JvdXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2lkZVJ1bGUgPSAoaW5kZW50TGV2ZWwgPiBuZXN0ZWRMZXZlbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UsIGRlY2xhcmF0aW9ucyBhcmUgYWxzbyBhbGxvd2VkXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNpZGVSdWxlID0gKGluZGVudExldmVsID49IG5lc3RlZExldmVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICd9Jykge1xuICAgICAgICAgICAgICAgIG91dGRlbnQoKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuYWRkX25ld19saW5lKCk7XG4gICAgICAgICAgICAgICAgcHJpbnRfc3RyaW5nKGNoKTtcbiAgICAgICAgICAgICAgICBpbnNpZGVSdWxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaW5zaWRlUHJvcGVydHlWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChuZXN0ZWRMZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICBuZXN0ZWRMZXZlbC0tO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghZWF0V2hpdGVzcGFjZSh0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuYWRkX25ld19saW5lKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG5ld2xpbmVzRnJvbUxhc3RXU0VhdCA8IDIgJiYgbmV3bGluZV9iZXR3ZWVuX3J1bGVzICYmIGluZGVudExldmVsID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5hZGRfbmV3X2xpbmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgICBlYXRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKChpbnNpZGVSdWxlIHx8IGVudGVyaW5nQ29uZGl0aW9uYWxHcm91cCkgJiZcbiAgICAgICAgICAgICAgICAgICAgIShsb29rQmFjayhcIiZcIikgfHwgZm91bmROZXN0ZWRQc2V1ZG9DbGFzcygpKSAmJlxuICAgICAgICAgICAgICAgICAgICAhbG9va0JhY2soXCIoXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICdwcm9wZXJ0eTogdmFsdWUnIGRlbGltaXRlclxuICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCBjb3VsZCBiZSBpbiBhIGNvbmRpdGlvbmFsIGdyb3VwIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgIHByaW50X3N0cmluZygnOicpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWluc2lkZVByb3BlcnR5VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2lkZVByb3BlcnR5VmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBzYXNzL2xlc3MgcGFyZW50IHJlZmVyZW5jZSBkb24ndCB1c2UgYSBzcGFjZVxuICAgICAgICAgICAgICAgICAgICAvLyBzYXNzIG5lc3RlZCBwc2V1ZG8tY2xhc3MgZG9uJ3QgdXNlIGEgc3BhY2VcblxuICAgICAgICAgICAgICAgICAgICAvLyBwcmVzZXJ2ZSBzcGFjZSBiZWZvcmUgcHNldWRvY2xhc3Nlcy9wc2V1ZG9lbGVtZW50cywgYXMgaXQgbWVhbnMgXCJpbiBhbnkgY2hpbGRcIlxuICAgICAgICAgICAgICAgICAgICBpZiAobG9va0JhY2soXCIgXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGVlaygpID09PSBcIjpcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHNldWRvLWVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW50X3N0cmluZyhcIjo6XCIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHNldWRvLWNsYXNzXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmludF9zdHJpbmcoJzonKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcIicgfHwgY2ggPT09ICdcXCcnKSB7XG4gICAgICAgICAgICAgICAgcHJlc2VydmVTaW5nbGVTcGFjZShpc0FmdGVyU3BhY2UpO1xuICAgICAgICAgICAgICAgIHByaW50X3N0cmluZyhlYXRTdHJpbmcoY2gpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICc7Jykge1xuICAgICAgICAgICAgICAgIGluc2lkZVByb3BlcnR5VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBwcmludF9zdHJpbmcoY2gpO1xuICAgICAgICAgICAgICAgIGlmICghZWF0V2hpdGVzcGFjZSh0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuYWRkX25ld19saW5lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJygnKSB7IC8vIG1heSBiZSBhIHVybFxuICAgICAgICAgICAgICAgIGlmIChsb29rQmFjayhcInVybFwiKSkge1xuICAgICAgICAgICAgICAgICAgICBwcmludF9zdHJpbmcoY2gpO1xuICAgICAgICAgICAgICAgICAgICBlYXRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCAhPT0gJyknICYmIGNoICE9PSAnXCInICYmIGNoICE9PSAnXFwnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW50X3N0cmluZyhlYXRTdHJpbmcoJyknKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcy0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW5MZXZlbCsrO1xuICAgICAgICAgICAgICAgICAgICBwcmVzZXJ2ZVNpbmdsZVNwYWNlKGlzQWZ0ZXJTcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgIHByaW50X3N0cmluZyhjaCk7XG4gICAgICAgICAgICAgICAgICAgIGVhdFdoaXRlc3BhY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnKScpIHtcbiAgICAgICAgICAgICAgICBwcmludF9zdHJpbmcoY2gpO1xuICAgICAgICAgICAgICAgIHBhcmVuTGV2ZWwtLTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICcsJykge1xuICAgICAgICAgICAgICAgIHByaW50X3N0cmluZyhjaCk7XG4gICAgICAgICAgICAgICAgaWYgKCFlYXRXaGl0ZXNwYWNlKHRydWUpICYmIHNlbGVjdG9yU2VwYXJhdG9yTmV3bGluZSAmJiAhaW5zaWRlUHJvcGVydHlWYWx1ZSAmJiBwYXJlbkxldmVsIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuYWRkX25ld19saW5lKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICgoY2ggPT09ICc+JyB8fCBjaCA9PT0gJysnIHx8IGNoID09PSAnficpICYmXG4gICAgICAgICAgICAgICAgIWluc2lkZVByb3BlcnR5VmFsdWUgJiYgcGFyZW5MZXZlbCA8IDEpIHtcbiAgICAgICAgICAgICAgICAvL2hhbmRsZSBjb21iaW5hdG9yIHNwYWNpbmdcbiAgICAgICAgICAgICAgICBpZiAoc3BhY2VfYXJvdW5kX2NvbWJpbmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHByaW50X3N0cmluZyhjaCk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW50X3N0cmluZyhjaCk7XG4gICAgICAgICAgICAgICAgICAgIGVhdFdoaXRlc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3F1YXNoIGV4dHJhIHdoaXRlc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoICYmIHdoaXRlUmUudGVzdChjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICBwcmludF9zdHJpbmcoY2gpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgcHJlc2VydmVTaW5nbGVTcGFjZShpc0FmdGVyU3BhY2UpO1xuICAgICAgICAgICAgICAgIHByaW50X3N0cmluZyhjaCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnPScpIHsgLy8gbm8gd2hpdGVzcGFjZSBiZWZvcmUgb3IgYWZ0ZXJcbiAgICAgICAgICAgICAgICBlYXRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgcHJpbnRfc3RyaW5nKCc9Jyk7XG4gICAgICAgICAgICAgICAgaWYgKHdoaXRlUmUudGVzdChjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2ggPSAnJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJlc2VydmVTaW5nbGVTcGFjZShpc0FmdGVyU3BhY2UpO1xuICAgICAgICAgICAgICAgIHByaW50X3N0cmluZyhjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3dlZXRDb2RlID0gb3V0cHV0LmdldF9jb2RlKGVuZF93aXRoX25ld2xpbmUsIGVvbCk7XG5cbiAgICAgICAgcmV0dXJuIHN3ZWV0Q29kZTtcbiAgICB9O1xuXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0F0LXJ1bGVcbiAgICB0aGlzLk5FU1RFRF9BVF9SVUxFID0ge1xuICAgICAgICBcIkBwYWdlXCI6IHRydWUsXG4gICAgICAgIFwiQGZvbnQtZmFjZVwiOiB0cnVlLFxuICAgICAgICBcIkBrZXlmcmFtZXNcIjogdHJ1ZSxcbiAgICAgICAgLy8gYWxzbyBpbiBDT05ESVRJT05BTF9HUk9VUF9SVUxFIGJlbG93XG4gICAgICAgIFwiQG1lZGlhXCI6IHRydWUsXG4gICAgICAgIFwiQHN1cHBvcnRzXCI6IHRydWUsXG4gICAgICAgIFwiQGRvY3VtZW50XCI6IHRydWVcbiAgICB9O1xuICAgIHRoaXMuQ09ORElUSU9OQUxfR1JPVVBfUlVMRSA9IHtcbiAgICAgICAgXCJAbWVkaWFcIjogdHJ1ZSxcbiAgICAgICAgXCJAc3VwcG9ydHNcIjogdHJ1ZSxcbiAgICAgICAgXCJAZG9jdW1lbnRcIjogdHJ1ZVxuICAgIH07XG59XG5cbm1vZHVsZS5leHBvcnRzLkJlYXV0aWZpZXIgPSBCZWF1dGlmaWVyO1xuXG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKiBqc2hpbnQgY3VybHk6IGZhbHNlICovXG4vLyBUaGlzIHNlY3Rpb24gb2YgY29kZSBpcyB0YWtlbiBmcm9tIGFjb3JuLlxuLy9cbi8vIEFjb3JuIHdhcyB3cml0dGVuIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIHJlbGVhc2VkIHVuZGVyIGFuIE1JVFxuLy8gbGljZW5zZS4gVGhlIFVuaWNvZGUgcmVnZXhwcyAoZm9yIGlkZW50aWZpZXJzIGFuZCB3aGl0ZXNwYWNlKSB3ZXJlXG4vLyB0YWtlbiBmcm9tIFtFc3ByaW1hXShodHRwOi8vZXNwcmltYS5vcmcpIGJ5IEFyaXlhIEhpZGF5YXQuXG4vL1xuLy8gR2l0IHJlcG9zaXRvcmllcyBmb3IgQWNvcm4gYXJlIGF2YWlsYWJsZSBhdFxuLy9cbi8vICAgICBodHRwOi8vbWFyaWpuaGF2ZXJiZWtlLm5sL2dpdC9hY29yblxuLy8gICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJpam5oL2Fjb3JuLmdpdFxuXG4vLyAjIyBDaGFyYWN0ZXIgY2F0ZWdvcmllc1xuXG4vLyBCaWcgdWdseSByZWd1bGFyIGV4cHJlc3Npb25zIHRoYXQgbWF0Y2ggY2hhcmFjdGVycyBpbiB0aGVcbi8vIHdoaXRlc3BhY2UsIGlkZW50aWZpZXIsIGFuZCBpZGVudGlmaWVyLXN0YXJ0IGNhdGVnb3JpZXMuIFRoZXNlXG4vLyBhcmUgb25seSBhcHBsaWVkIHdoZW4gYSBjaGFyYWN0ZXIgaXMgZm91bmQgdG8gYWN0dWFsbHkgaGF2ZSBhXG4vLyBjb2RlIHBvaW50IGFib3ZlIDEyOC5cblxudmFyIG5vbkFTQ0lJd2hpdGVzcGFjZSA9IC9bXFx1MTY4MFxcdTE4MGVcXHUyMDAwLVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHVmZWZmXS87IC8vIGpzaGludCBpZ25vcmU6bGluZVxudmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgPSBcIlxceGFhXFx4YjVcXHhiYVxceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMmMxXFx1MDJjNi1cXHUwMmQxXFx1MDJlMC1cXHUwMmU0XFx1MDJlY1xcdTAyZWVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN2EtXFx1MDM3ZFxcdTAzODZcXHUwMzg4LVxcdTAzOGFcXHUwMzhjXFx1MDM4ZS1cXHUwM2ExXFx1MDNhMy1cXHUwM2Y1XFx1MDNmNy1cXHUwNDgxXFx1MDQ4YS1cXHUwNTI3XFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1ZDAtXFx1MDVlYVxcdTA1ZjAtXFx1MDVmMlxcdTA2MjAtXFx1MDY0YVxcdTA2NmVcXHUwNjZmXFx1MDY3MS1cXHUwNmQzXFx1MDZkNVxcdTA2ZTVcXHUwNmU2XFx1MDZlZVxcdTA2ZWZcXHUwNmZhLVxcdTA2ZmNcXHUwNmZmXFx1MDcxMFxcdTA3MTItXFx1MDcyZlxcdTA3NGQtXFx1MDdhNVxcdTA3YjFcXHUwN2NhLVxcdTA3ZWFcXHUwN2Y0XFx1MDdmNVxcdTA3ZmFcXHUwODAwLVxcdTA4MTVcXHUwODFhXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwOGEwXFx1MDhhMi1cXHUwOGFjXFx1MDkwNC1cXHUwOTM5XFx1MDkzZFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5NzdcXHUwOTc5LVxcdTA5N2ZcXHUwOTg1LVxcdTA5OGNcXHUwOThmXFx1MDk5MFxcdTA5OTMtXFx1MDlhOFxcdTA5YWEtXFx1MDliMFxcdTA5YjJcXHUwOWI2LVxcdTA5YjlcXHUwOWJkXFx1MDljZVxcdTA5ZGNcXHUwOWRkXFx1MDlkZi1cXHUwOWUxXFx1MDlmMFxcdTA5ZjFcXHUwYTA1LVxcdTBhMGFcXHUwYTBmXFx1MGExMFxcdTBhMTMtXFx1MGEyOFxcdTBhMmEtXFx1MGEzMFxcdTBhMzJcXHUwYTMzXFx1MGEzNVxcdTBhMzZcXHUwYTM4XFx1MGEzOVxcdTBhNTktXFx1MGE1Y1xcdTBhNWVcXHUwYTcyLVxcdTBhNzRcXHUwYTg1LVxcdTBhOGRcXHUwYThmLVxcdTBhOTFcXHUwYTkzLVxcdTBhYThcXHUwYWFhLVxcdTBhYjBcXHUwYWIyXFx1MGFiM1xcdTBhYjUtXFx1MGFiOVxcdTBhYmRcXHUwYWQwXFx1MGFlMFxcdTBhZTFcXHUwYjA1LVxcdTBiMGNcXHUwYjBmXFx1MGIxMFxcdTBiMTMtXFx1MGIyOFxcdTBiMmEtXFx1MGIzMFxcdTBiMzJcXHUwYjMzXFx1MGIzNS1cXHUwYjM5XFx1MGIzZFxcdTBiNWNcXHUwYjVkXFx1MGI1Zi1cXHUwYjYxXFx1MGI3MVxcdTBiODNcXHUwYjg1LVxcdTBiOGFcXHUwYjhlLVxcdTBiOTBcXHUwYjkyLVxcdTBiOTVcXHUwYjk5XFx1MGI5YVxcdTBiOWNcXHUwYjllXFx1MGI5ZlxcdTBiYTNcXHUwYmE0XFx1MGJhOC1cXHUwYmFhXFx1MGJhZS1cXHUwYmI5XFx1MGJkMFxcdTBjMDUtXFx1MGMwY1xcdTBjMGUtXFx1MGMxMFxcdTBjMTItXFx1MGMyOFxcdTBjMmEtXFx1MGMzM1xcdTBjMzUtXFx1MGMzOVxcdTBjM2RcXHUwYzU4XFx1MGM1OVxcdTBjNjBcXHUwYzYxXFx1MGM4NS1cXHUwYzhjXFx1MGM4ZS1cXHUwYzkwXFx1MGM5Mi1cXHUwY2E4XFx1MGNhYS1cXHUwY2IzXFx1MGNiNS1cXHUwY2I5XFx1MGNiZFxcdTBjZGVcXHUwY2UwXFx1MGNlMVxcdTBjZjFcXHUwY2YyXFx1MGQwNS1cXHUwZDBjXFx1MGQwZS1cXHUwZDEwXFx1MGQxMi1cXHUwZDNhXFx1MGQzZFxcdTBkNGVcXHUwZDYwXFx1MGQ2MVxcdTBkN2EtXFx1MGQ3ZlxcdTBkODUtXFx1MGQ5NlxcdTBkOWEtXFx1MGRiMVxcdTBkYjMtXFx1MGRiYlxcdTBkYmRcXHUwZGMwLVxcdTBkYzZcXHUwZTAxLVxcdTBlMzBcXHUwZTMyXFx1MGUzM1xcdTBlNDAtXFx1MGU0NlxcdTBlODFcXHUwZTgyXFx1MGU4NFxcdTBlODdcXHUwZTg4XFx1MGU4YVxcdTBlOGRcXHUwZTk0LVxcdTBlOTdcXHUwZTk5LVxcdTBlOWZcXHUwZWExLVxcdTBlYTNcXHUwZWE1XFx1MGVhN1xcdTBlYWFcXHUwZWFiXFx1MGVhZC1cXHUwZWIwXFx1MGViMlxcdTBlYjNcXHUwZWJkXFx1MGVjMC1cXHUwZWM0XFx1MGVjNlxcdTBlZGMtXFx1MGVkZlxcdTBmMDBcXHUwZjQwLVxcdTBmNDdcXHUwZjQ5LVxcdTBmNmNcXHUwZjg4LVxcdTBmOGNcXHUxMDAwLVxcdTEwMmFcXHUxMDNmXFx1MTA1MC1cXHUxMDU1XFx1MTA1YS1cXHUxMDVkXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2ZS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4ZVxcdTEwYTAtXFx1MTBjNVxcdTEwYzdcXHUxMGNkXFx1MTBkMC1cXHUxMGZhXFx1MTBmYy1cXHUxMjQ4XFx1MTI0YS1cXHUxMjRkXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNWEtXFx1MTI1ZFxcdTEyNjAtXFx1MTI4OFxcdTEyOGEtXFx1MTI4ZFxcdTEyOTAtXFx1MTJiMFxcdTEyYjItXFx1MTJiNVxcdTEyYjgtXFx1MTJiZVxcdTEyYzBcXHUxMmMyLVxcdTEyYzVcXHUxMmM4LVxcdTEyZDZcXHUxMmQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNWFcXHUxMzgwLVxcdTEzOGZcXHUxM2EwLVxcdTEzZjRcXHUxNDAxLVxcdTE2NmNcXHUxNjZmLVxcdTE2N2ZcXHUxNjgxLVxcdTE2OWFcXHUxNmEwLVxcdTE2ZWFcXHUxNmVlLVxcdTE2ZjBcXHUxNzAwLVxcdTE3MGNcXHUxNzBlLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NmNcXHUxNzZlLVxcdTE3NzBcXHUxNzgwLVxcdTE3YjNcXHUxN2Q3XFx1MTdkY1xcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThhOFxcdTE4YWFcXHUxOGIwLVxcdTE4ZjVcXHUxOTAwLVxcdTE5MWNcXHUxOTUwLVxcdTE5NmRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5YWJcXHUxOWMxLVxcdTE5YzdcXHUxYTAwLVxcdTFhMTZcXHUxYTIwLVxcdTFhNTRcXHUxYWE3XFx1MWIwNS1cXHUxYjMzXFx1MWI0NS1cXHUxYjRiXFx1MWI4My1cXHUxYmEwXFx1MWJhZVxcdTFiYWZcXHUxYmJhLVxcdTFiZTVcXHUxYzAwLVxcdTFjMjNcXHUxYzRkLVxcdTFjNGZcXHUxYzVhLVxcdTFjN2RcXHUxY2U5LVxcdTFjZWNcXHUxY2VlLVxcdTFjZjFcXHUxY2Y1XFx1MWNmNlxcdTFkMDAtXFx1MWRiZlxcdTFlMDAtXFx1MWYxNVxcdTFmMTgtXFx1MWYxZFxcdTFmMjAtXFx1MWY0NVxcdTFmNDgtXFx1MWY0ZFxcdTFmNTAtXFx1MWY1N1xcdTFmNTlcXHUxZjViXFx1MWY1ZFxcdTFmNWYtXFx1MWY3ZFxcdTFmODAtXFx1MWZiNFxcdTFmYjYtXFx1MWZiY1xcdTFmYmVcXHUxZmMyLVxcdTFmYzRcXHUxZmM2LVxcdTFmY2NcXHUxZmQwLVxcdTFmZDNcXHUxZmQ2LVxcdTFmZGJcXHUxZmUwLVxcdTFmZWNcXHUxZmYyLVxcdTFmZjRcXHUxZmY2LVxcdTFmZmNcXHUyMDcxXFx1MjA3ZlxcdTIwOTAtXFx1MjA5Y1xcdTIxMDJcXHUyMTA3XFx1MjEwYS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExZFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMmEtXFx1MjEyZFxcdTIxMmYtXFx1MjEzOVxcdTIxM2MtXFx1MjEzZlxcdTIxNDUtXFx1MjE0OVxcdTIxNGVcXHUyMTYwLVxcdTIxODhcXHUyYzAwLVxcdTJjMmVcXHUyYzMwLVxcdTJjNWVcXHUyYzYwLVxcdTJjZTRcXHUyY2ViLVxcdTJjZWVcXHUyY2YyXFx1MmNmM1xcdTJkMDAtXFx1MmQyNVxcdTJkMjdcXHUyZDJkXFx1MmQzMC1cXHUyZDY3XFx1MmQ2ZlxcdTJkODAtXFx1MmQ5NlxcdTJkYTAtXFx1MmRhNlxcdTJkYTgtXFx1MmRhZVxcdTJkYjAtXFx1MmRiNlxcdTJkYjgtXFx1MmRiZVxcdTJkYzAtXFx1MmRjNlxcdTJkYzgtXFx1MmRjZVxcdTJkZDAtXFx1MmRkNlxcdTJkZDgtXFx1MmRkZVxcdTJlMmZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM2NcXHUzMDQxLVxcdTMwOTZcXHUzMDlkLVxcdTMwOWZcXHUzMGExLVxcdTMwZmFcXHUzMGZjLVxcdTMwZmZcXHUzMTA1LVxcdTMxMmRcXHUzMTMxLVxcdTMxOGVcXHUzMWEwLVxcdTMxYmFcXHUzMWYwLVxcdTMxZmZcXHUzNDAwLVxcdTRkYjVcXHU0ZTAwLVxcdTlmY2NcXHVhMDAwLVxcdWE0OGNcXHVhNGQwLVxcdWE0ZmRcXHVhNTAwLVxcdWE2MGNcXHVhNjEwLVxcdWE2MWZcXHVhNjJhXFx1YTYyYlxcdWE2NDAtXFx1YTY2ZVxcdWE2N2YtXFx1YTY5N1xcdWE2YTAtXFx1YTZlZlxcdWE3MTctXFx1YTcxZlxcdWE3MjItXFx1YTc4OFxcdWE3OGItXFx1YTc4ZVxcdWE3OTAtXFx1YTc5M1xcdWE3YTAtXFx1YTdhYVxcdWE3ZjgtXFx1YTgwMVxcdWE4MDMtXFx1YTgwNVxcdWE4MDctXFx1YTgwYVxcdWE4MGMtXFx1YTgyMlxcdWE4NDAtXFx1YTg3M1xcdWE4ODItXFx1YThiM1xcdWE4ZjItXFx1YThmN1xcdWE4ZmJcXHVhOTBhLVxcdWE5MjVcXHVhOTMwLVxcdWE5NDZcXHVhOTYwLVxcdWE5N2NcXHVhOTg0LVxcdWE5YjJcXHVhOWNmXFx1YWEwMC1cXHVhYTI4XFx1YWE0MC1cXHVhYTQyXFx1YWE0NC1cXHVhYTRiXFx1YWE2MC1cXHVhYTc2XFx1YWE3YVxcdWFhODAtXFx1YWFhZlxcdWFhYjFcXHVhYWI1XFx1YWFiNlxcdWFhYjktXFx1YWFiZFxcdWFhYzBcXHVhYWMyXFx1YWFkYi1cXHVhYWRkXFx1YWFlMC1cXHVhYWVhXFx1YWFmMi1cXHVhYWY0XFx1YWIwMS1cXHVhYjA2XFx1YWIwOS1cXHVhYjBlXFx1YWIxMS1cXHVhYjE2XFx1YWIyMC1cXHVhYjI2XFx1YWIyOC1cXHVhYjJlXFx1YWJjMC1cXHVhYmUyXFx1YWMwMC1cXHVkN2EzXFx1ZDdiMC1cXHVkN2M2XFx1ZDdjYi1cXHVkN2ZiXFx1ZjkwMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIwMC1cXHVmYjA2XFx1ZmIxMy1cXHVmYjE3XFx1ZmIxZFxcdWZiMWYtXFx1ZmIyOFxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwXFx1ZmI0MVxcdWZiNDNcXHVmYjQ0XFx1ZmI0Ni1cXHVmYmIxXFx1ZmJkMy1cXHVmZDNkXFx1ZmQ1MC1cXHVmZDhmXFx1ZmQ5Mi1cXHVmZGM3XFx1ZmRmMC1cXHVmZGZiXFx1ZmU3MC1cXHVmZTc0XFx1ZmU3Ni1cXHVmZWZjXFx1ZmYyMS1cXHVmZjNhXFx1ZmY0MS1cXHVmZjVhXFx1ZmY2Ni1cXHVmZmJlXFx1ZmZjMi1cXHVmZmM3XFx1ZmZjYS1cXHVmZmNmXFx1ZmZkMi1cXHVmZmQ3XFx1ZmZkYS1cXHVmZmRjXCI7XG52YXIgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgPSBcIlxcdTAzMDAtXFx1MDM2ZlxcdTA0ODMtXFx1MDQ4N1xcdTA1OTEtXFx1MDViZFxcdTA1YmZcXHUwNWMxXFx1MDVjMlxcdTA1YzRcXHUwNWM1XFx1MDVjN1xcdTA2MTAtXFx1MDYxYVxcdTA2MjAtXFx1MDY0OVxcdTA2NzItXFx1MDZkM1xcdTA2ZTctXFx1MDZlOFxcdTA2ZmItXFx1MDZmY1xcdTA3MzAtXFx1MDc0YVxcdTA4MDAtXFx1MDgxNFxcdTA4MWItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyZFxcdTA4NDAtXFx1MDg1N1xcdTA4ZTQtXFx1MDhmZVxcdTA5MDAtXFx1MDkwM1xcdTA5M2EtXFx1MDkzY1xcdTA5M2UtXFx1MDk0ZlxcdTA5NTEtXFx1MDk1N1xcdTA5NjItXFx1MDk2M1xcdTA5NjYtXFx1MDk2ZlxcdTA5ODEtXFx1MDk4M1xcdTA5YmNcXHUwOWJlLVxcdTA5YzRcXHUwOWM3XFx1MDljOFxcdTA5ZDdcXHUwOWRmLVxcdTA5ZTBcXHUwYTAxLVxcdTBhMDNcXHUwYTNjXFx1MGEzZS1cXHUwYTQyXFx1MGE0N1xcdTBhNDhcXHUwYTRiLVxcdTBhNGRcXHUwYTUxXFx1MGE2Ni1cXHUwYTcxXFx1MGE3NVxcdTBhODEtXFx1MGE4M1xcdTBhYmNcXHUwYWJlLVxcdTBhYzVcXHUwYWM3LVxcdTBhYzlcXHUwYWNiLVxcdTBhY2RcXHUwYWUyLVxcdTBhZTNcXHUwYWU2LVxcdTBhZWZcXHUwYjAxLVxcdTBiMDNcXHUwYjNjXFx1MGIzZS1cXHUwYjQ0XFx1MGI0N1xcdTBiNDhcXHUwYjRiLVxcdTBiNGRcXHUwYjU2XFx1MGI1N1xcdTBiNWYtXFx1MGI2MFxcdTBiNjYtXFx1MGI2ZlxcdTBiODJcXHUwYmJlLVxcdTBiYzJcXHUwYmM2LVxcdTBiYzhcXHUwYmNhLVxcdTBiY2RcXHUwYmQ3XFx1MGJlNi1cXHUwYmVmXFx1MGMwMS1cXHUwYzAzXFx1MGM0Ni1cXHUwYzQ4XFx1MGM0YS1cXHUwYzRkXFx1MGM1NVxcdTBjNTZcXHUwYzYyLVxcdTBjNjNcXHUwYzY2LVxcdTBjNmZcXHUwYzgyXFx1MGM4M1xcdTBjYmNcXHUwY2JlLVxcdTBjYzRcXHUwY2M2LVxcdTBjYzhcXHUwY2NhLVxcdTBjY2RcXHUwY2Q1XFx1MGNkNlxcdTBjZTItXFx1MGNlM1xcdTBjZTYtXFx1MGNlZlxcdTBkMDJcXHUwZDAzXFx1MGQ0Ni1cXHUwZDQ4XFx1MGQ1N1xcdTBkNjItXFx1MGQ2M1xcdTBkNjYtXFx1MGQ2ZlxcdTBkODJcXHUwZDgzXFx1MGRjYVxcdTBkY2YtXFx1MGRkNFxcdTBkZDZcXHUwZGQ4LVxcdTBkZGZcXHUwZGYyXFx1MGRmM1xcdTBlMzQtXFx1MGUzYVxcdTBlNDAtXFx1MGU0NVxcdTBlNTAtXFx1MGU1OVxcdTBlYjQtXFx1MGViOVxcdTBlYzgtXFx1MGVjZFxcdTBlZDAtXFx1MGVkOVxcdTBmMThcXHUwZjE5XFx1MGYyMC1cXHUwZjI5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGY0MS1cXHUwZjQ3XFx1MGY3MS1cXHUwZjg0XFx1MGY4Ni1cXHUwZjg3XFx1MGY4ZC1cXHUwZjk3XFx1MGY5OS1cXHUwZmJjXFx1MGZjNlxcdTEwMDAtXFx1MTAyOVxcdTEwNDAtXFx1MTA0OVxcdTEwNjctXFx1MTA2ZFxcdTEwNzEtXFx1MTA3NFxcdTEwODItXFx1MTA4ZFxcdTEwOGYtXFx1MTA5ZFxcdTEzNWQtXFx1MTM1ZlxcdTE3MGUtXFx1MTcxMFxcdTE3MjAtXFx1MTczMFxcdTE3NDAtXFx1MTc1MFxcdTE3NzJcXHUxNzczXFx1MTc4MC1cXHUxN2IyXFx1MTdkZFxcdTE3ZTAtXFx1MTdlOVxcdTE4MGItXFx1MTgwZFxcdTE4MTAtXFx1MTgxOVxcdTE5MjAtXFx1MTkyYlxcdTE5MzAtXFx1MTkzYlxcdTE5NTEtXFx1MTk2ZFxcdTE5YjAtXFx1MTljMFxcdTE5YzgtXFx1MTljOVxcdTE5ZDAtXFx1MTlkOVxcdTFhMDAtXFx1MWExNVxcdTFhMjAtXFx1MWE1M1xcdTFhNjAtXFx1MWE3Y1xcdTFhN2YtXFx1MWE4OVxcdTFhOTAtXFx1MWE5OVxcdTFiNDYtXFx1MWI0YlxcdTFiNTAtXFx1MWI1OVxcdTFiNmItXFx1MWI3M1xcdTFiYjAtXFx1MWJiOVxcdTFiZTYtXFx1MWJmM1xcdTFjMDAtXFx1MWMyMlxcdTFjNDAtXFx1MWM0OVxcdTFjNWItXFx1MWM3ZFxcdTFjZDAtXFx1MWNkMlxcdTFkMDAtXFx1MWRiZVxcdTFlMDEtXFx1MWYxNVxcdTIwMGNcXHUyMDBkXFx1MjAzZlxcdTIwNDBcXHUyMDU0XFx1MjBkMC1cXHUyMGRjXFx1MjBlMVxcdTIwZTUtXFx1MjBmMFxcdTJkODEtXFx1MmQ5NlxcdTJkZTAtXFx1MmRmZlxcdTMwMjEtXFx1MzAyOFxcdTMwOTlcXHUzMDlhXFx1YTY0MC1cXHVhNjZkXFx1YTY3NC1cXHVhNjdkXFx1YTY5ZlxcdWE2ZjAtXFx1YTZmMVxcdWE3ZjgtXFx1YTgwMFxcdWE4MDZcXHVhODBiXFx1YTgyMy1cXHVhODI3XFx1YTg4MC1cXHVhODgxXFx1YThiNC1cXHVhOGM0XFx1YThkMC1cXHVhOGQ5XFx1YThmMy1cXHVhOGY3XFx1YTkwMC1cXHVhOTA5XFx1YTkyNi1cXHVhOTJkXFx1YTkzMC1cXHVhOTQ1XFx1YTk4MC1cXHVhOTgzXFx1YTliMy1cXHVhOWMwXFx1YWEwMC1cXHVhYTI3XFx1YWE0MC1cXHVhYTQxXFx1YWE0Yy1cXHVhYTRkXFx1YWE1MC1cXHVhYTU5XFx1YWE3YlxcdWFhZTAtXFx1YWFlOVxcdWFhZjItXFx1YWFmM1xcdWFiYzAtXFx1YWJlMVxcdWFiZWNcXHVhYmVkXFx1YWJmMC1cXHVhYmY5XFx1ZmIyMC1cXHVmYjI4XFx1ZmUwMC1cXHVmZTBmXFx1ZmUyMC1cXHVmZTI2XFx1ZmUzM1xcdWZlMzRcXHVmZTRkLVxcdWZlNGZcXHVmZjEwLVxcdWZmMTlcXHVmZjNmXCI7XG52YXIgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIFwiXVwiKTtcbnZhciBub25BU0NJSWlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzICsgXCJdXCIpO1xuXG4vLyBXaGV0aGVyIGEgc2luZ2xlIGNoYXJhY3RlciBkZW5vdGVzIGEgbmV3bGluZS5cblxuZXhwb3J0cy5uZXdsaW5lID0gL1tcXG5cXHJcXHUyMDI4XFx1MjAyOV0vO1xuXG4vLyBNYXRjaGVzIGEgd2hvbGUgbGluZSBicmVhayAod2hlcmUgQ1JMRiBpcyBjb25zaWRlcmVkIGEgc2luZ2xlXG4vLyBsaW5lIGJyZWFrKS4gVXNlZCB0byBjb3VudCBsaW5lcy5cblxuLy8gaW4gamF2YXNjcmlwdCwgdGhlc2UgdHdvIGRpZmZlclxuLy8gaW4gcHl0aG9uIHRoZXkgYXJlIHRoZSBzYW1lLCBkaWZmZXJlbnQgbWV0aG9kcyBhcmUgY2FsbGVkIG9uIHRoZW1cbmV4cG9ydHMubGluZUJyZWFrID0gbmV3IFJlZ0V4cCgnXFxyXFxufCcgKyBleHBvcnRzLm5ld2xpbmUuc291cmNlKTtcbmV4cG9ydHMuYWxsTGluZUJyZWFrcyA9IG5ldyBSZWdFeHAoZXhwb3J0cy5saW5lQnJlYWsuc291cmNlLCAnZycpO1xuXG5cbi8vIFRlc3Qgd2hldGhlciBhIGdpdmVuIGNoYXJhY3RlciBjb2RlIHN0YXJ0cyBhbiBpZGVudGlmaWVyLlxuXG5leHBvcnRzLmlzSWRlbnRpZmllclN0YXJ0ID0gZnVuY3Rpb24oY29kZSkge1xuICAgIC8vIHBlcm1pdCAkICgzNikgYW5kIEAgKDY0KS4gQCBpcyB1c2VkIGluIEVTNyBkZWNvcmF0b3JzLlxuICAgIGlmIChjb2RlIDwgNjUpIHJldHVybiBjb2RlID09PSAzNiB8fCBjb2RlID09PSA2NDtcbiAgICAvLyA2NSB0aHJvdWdoIDkxIGFyZSB1cHBlcmNhc2UgbGV0dGVycy5cbiAgICBpZiAoY29kZSA8IDkxKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBwZXJtaXQgXyAoOTUpLlxuICAgIGlmIChjb2RlIDwgOTcpIHJldHVybiBjb2RlID09PSA5NTtcbiAgICAvLyA5NyB0aHJvdWdoIDEyMyBhcmUgbG93ZXJjYXNlIGxldHRlcnMuXG4gICAgaWYgKGNvZGUgPCAxMjMpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBjb2RlID49IDB4YWEgJiYgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbn07XG5cbi8vIFRlc3Qgd2hldGhlciBhIGdpdmVuIGNoYXJhY3RlciBpcyBwYXJ0IG9mIGFuIGlkZW50aWZpZXIuXG5cbmV4cG9ydHMuaXNJZGVudGlmaWVyQ2hhciA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgICBpZiAoY29kZSA8IDQ4KSByZXR1cm4gY29kZSA9PT0gMzY7XG4gICAgaWYgKGNvZGUgPCA1OCkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGNvZGUgPCA2NSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChjb2RlIDwgOTEpIHJldHVybiB0cnVlO1xuICAgIGlmIChjb2RlIDwgOTcpIHJldHVybiBjb2RlID09PSA5NTtcbiAgICBpZiAoY29kZSA8IDEyMykgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXIudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qanNoaW50IGN1cmx5OnRydWUsIGVxZXFlcTp0cnVlLCBsYXhicmVhazp0cnVlLCBub2VtcHR5OmZhbHNlICovXG4vKlxuXG4gICAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxNyBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAgICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICAgIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gICAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gICAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICAgIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gICAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICAgIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICAgIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gICAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgIFNPRlRXQVJFLlxuKi9cblxuZnVuY3Rpb24gbWVyZ2VPcHRzKGFsbE9wdGlvbnMsIHRhcmdldFR5cGUpIHtcbiAgICB2YXIgZmluYWxPcHRzID0ge307XG4gICAgdmFyIG5hbWU7XG5cbiAgICBmb3IgKG5hbWUgaW4gYWxsT3B0aW9ucykge1xuICAgICAgICBpZiAobmFtZSAhPT0gdGFyZ2V0VHlwZSkge1xuICAgICAgICAgICAgZmluYWxPcHRzW25hbWVdID0gYWxsT3B0aW9uc1tuYW1lXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vbWVyZ2UgaW4gdGhlIHBlciB0eXBlIHNldHRpbmdzIGZvciB0aGUgdGFyZ2V0VHlwZVxuICAgIGlmICh0YXJnZXRUeXBlIGluIGFsbE9wdGlvbnMpIHtcbiAgICAgICAgZm9yIChuYW1lIGluIGFsbE9wdGlvbnNbdGFyZ2V0VHlwZV0pIHtcbiAgICAgICAgICAgIGZpbmFsT3B0c1tuYW1lXSA9IGFsbE9wdGlvbnNbdGFyZ2V0VHlwZV1bbmFtZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpbmFsT3B0cztcbn1cblxubW9kdWxlLmV4cG9ydHMubWVyZ2VPcHRzID0gbWVyZ2VPcHRzO1xuXG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKmpzaGludCBjdXJseTp0cnVlLCBlcWVxZXE6dHJ1ZSwgbGF4YnJlYWs6dHJ1ZSwgbm9lbXB0eTpmYWxzZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxNyBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5mdW5jdGlvbiBPdXRwdXRMaW5lKHBhcmVudCkge1xuICAgIHZhciBfY2hhcmFjdGVyX2NvdW50ID0gMDtcbiAgICAvLyB1c2UgaW5kZW50X2NvdW50IGFzIGEgbWFya2VyIGZvciBsaW5lcyB0aGF0IGhhdmUgcHJlc2VydmVkIGluZGVudGF0aW9uXG4gICAgdmFyIF9pbmRlbnRfY291bnQgPSAtMTtcblxuICAgIHZhciBfaXRlbXMgPSBbXTtcbiAgICB2YXIgX2VtcHR5ID0gdHJ1ZTtcblxuICAgIHRoaXMuc2V0X2luZGVudCA9IGZ1bmN0aW9uKGxldmVsKSB7XG4gICAgICAgIF9jaGFyYWN0ZXJfY291bnQgPSBwYXJlbnQuYmFzZUluZGVudExlbmd0aCArIGxldmVsICogcGFyZW50LmluZGVudF9sZW5ndGg7XG4gICAgICAgIF9pbmRlbnRfY291bnQgPSBsZXZlbDtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRfY2hhcmFjdGVyX2NvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfY2hhcmFjdGVyX2NvdW50O1xuICAgIH07XG5cbiAgICB0aGlzLmlzX2VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfZW1wdHk7XG4gICAgfTtcblxuICAgIHRoaXMubGFzdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2VtcHR5KSB7XG4gICAgICAgICAgICByZXR1cm4gX2l0ZW1zW19pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMucHVzaCA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIF9pdGVtcy5wdXNoKGlucHV0KTtcbiAgICAgICAgX2NoYXJhY3Rlcl9jb3VudCArPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgIF9lbXB0eSA9IGZhbHNlO1xuICAgIH07XG5cbiAgICB0aGlzLnBvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaXRlbSA9IG51bGw7XG4gICAgICAgIGlmICghX2VtcHR5KSB7XG4gICAgICAgICAgICBpdGVtID0gX2l0ZW1zLnBvcCgpO1xuICAgICAgICAgICAgX2NoYXJhY3Rlcl9jb3VudCAtPSBpdGVtLmxlbmd0aDtcbiAgICAgICAgICAgIF9lbXB0eSA9IF9pdGVtcy5sZW5ndGggPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfTtcblxuICAgIHRoaXMucmVtb3ZlX2luZGVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoX2luZGVudF9jb3VudCA+IDApIHtcbiAgICAgICAgICAgIF9pbmRlbnRfY291bnQgLT0gMTtcbiAgICAgICAgICAgIF9jaGFyYWN0ZXJfY291bnQgLT0gcGFyZW50LmluZGVudF9sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy50cmltID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmxhc3QoKSA9PT0gJyAnKSB7XG4gICAgICAgICAgICBfaXRlbXMucG9wKCk7XG4gICAgICAgICAgICBfY2hhcmFjdGVyX2NvdW50IC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgX2VtcHR5ID0gX2l0ZW1zLmxlbmd0aCA9PT0gMDtcbiAgICB9O1xuXG4gICAgdGhpcy50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgIGlmICghdGhpcy5fZW1wdHkpIHtcbiAgICAgICAgICAgIGlmIChfaW5kZW50X2NvdW50ID49IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBwYXJlbnQuaW5kZW50X2NhY2hlW19pbmRlbnRfY291bnRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9IF9pdGVtcy5qb2luKCcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIE91dHB1dChpbmRlbnRfc3RyaW5nLCBiYXNlSW5kZW50U3RyaW5nKSB7XG4gICAgYmFzZUluZGVudFN0cmluZyA9IGJhc2VJbmRlbnRTdHJpbmcgfHwgJyc7XG4gICAgdGhpcy5pbmRlbnRfY2FjaGUgPSBbYmFzZUluZGVudFN0cmluZ107XG4gICAgdGhpcy5iYXNlSW5kZW50TGVuZ3RoID0gYmFzZUluZGVudFN0cmluZy5sZW5ndGg7XG4gICAgdGhpcy5pbmRlbnRfbGVuZ3RoID0gaW5kZW50X3N0cmluZy5sZW5ndGg7XG4gICAgdGhpcy5yYXcgPSBmYWxzZTtcblxuICAgIHZhciBsaW5lcyA9IFtdO1xuICAgIHRoaXMuYmFzZUluZGVudFN0cmluZyA9IGJhc2VJbmRlbnRTdHJpbmc7XG4gICAgdGhpcy5pbmRlbnRfc3RyaW5nID0gaW5kZW50X3N0cmluZztcbiAgICB0aGlzLnByZXZpb3VzX2xpbmUgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudF9saW5lID0gbnVsbDtcbiAgICB0aGlzLnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuXG4gICAgdGhpcy5hZGRfb3V0cHV0bGluZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnByZXZpb3VzX2xpbmUgPSB0aGlzLmN1cnJlbnRfbGluZTtcbiAgICAgICAgdGhpcy5jdXJyZW50X2xpbmUgPSBuZXcgT3V0cHV0TGluZSh0aGlzKTtcbiAgICAgICAgbGluZXMucHVzaCh0aGlzLmN1cnJlbnRfbGluZSk7XG4gICAgfTtcblxuICAgIC8vIGluaXRpYWxpemVcbiAgICB0aGlzLmFkZF9vdXRwdXRsaW5lKCk7XG5cblxuICAgIHRoaXMuZ2V0X2xpbmVfbnVtYmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBsaW5lcy5sZW5ndGg7XG4gICAgfTtcblxuICAgIC8vIFVzaW5nIG9iamVjdCBpbnN0ZWFkIG9mIHN0cmluZyB0byBhbGxvdyBmb3IgbGF0ZXIgZXhwYW5zaW9uIG9mIGluZm8gYWJvdXQgZWFjaCBsaW5lXG4gICAgdGhpcy5hZGRfbmV3X2xpbmUgPSBmdW5jdGlvbihmb3JjZV9uZXdsaW5lKSB7XG4gICAgICAgIGlmICh0aGlzLmdldF9saW5lX251bWJlcigpID09PSAxICYmIHRoaXMuanVzdF9hZGRlZF9uZXdsaW5lKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gbm8gbmV3bGluZSBvbiBzdGFydCBvZiBmaWxlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm9yY2VfbmV3bGluZSB8fCAhdGhpcy5qdXN0X2FkZGVkX25ld2xpbmUoKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJhdykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkX291dHB1dGxpbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB0aGlzLmdldF9jb2RlID0gZnVuY3Rpb24oZW5kX3dpdGhfbmV3bGluZSwgZW9sKSB7XG4gICAgICAgIHZhciBzd2VldF9jb2RlID0gbGluZXMuam9pbignXFxuJykucmVwbGFjZSgvW1xcclxcblxcdCBdKyQvLCAnJyk7XG5cbiAgICAgICAgaWYgKGVuZF93aXRoX25ld2xpbmUpIHtcbiAgICAgICAgICAgIHN3ZWV0X2NvZGUgKz0gJ1xcbic7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW9sICE9PSAnXFxuJykge1xuICAgICAgICAgICAgc3dlZXRfY29kZSA9IHN3ZWV0X2NvZGUucmVwbGFjZSgvW1xcbl0vZywgZW9sKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzd2VldF9jb2RlO1xuICAgIH07XG5cbiAgICB0aGlzLnNldF9pbmRlbnQgPSBmdW5jdGlvbihsZXZlbCkge1xuICAgICAgICAvLyBOZXZlciBpbmRlbnQgeW91ciBmaXJzdCBvdXRwdXQgaW5kZW50IGF0IHRoZSBzdGFydCBvZiB0aGUgZmlsZVxuICAgICAgICBpZiAobGluZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgd2hpbGUgKGxldmVsID49IHRoaXMuaW5kZW50X2NhY2hlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50X2NhY2hlLnB1c2godGhpcy5pbmRlbnRfY2FjaGVbdGhpcy5pbmRlbnRfY2FjaGUubGVuZ3RoIC0gMV0gKyB0aGlzLmluZGVudF9zdHJpbmcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRfbGluZS5zZXRfaW5kZW50KGxldmVsKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudF9saW5lLnNldF9pbmRlbnQoMCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgdGhpcy5hZGRfcmF3X3Rva2VuID0gZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB0b2tlbi5uZXdsaW5lczsgeCsrKSB7XG4gICAgICAgICAgICB0aGlzLmFkZF9vdXRwdXRsaW5lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50X2xpbmUucHVzaCh0b2tlbi53aGl0ZXNwYWNlX2JlZm9yZSk7XG4gICAgICAgIHRoaXMuY3VycmVudF9saW5lLnB1c2godG9rZW4udGV4dCk7XG4gICAgICAgIHRoaXMuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG4gICAgfTtcblxuICAgIHRoaXMuYWRkX3Rva2VuID0gZnVuY3Rpb24ocHJpbnRhYmxlX3Rva2VuKSB7XG4gICAgICAgIHRoaXMuYWRkX3NwYWNlX2JlZm9yZV90b2tlbigpO1xuICAgICAgICB0aGlzLmN1cnJlbnRfbGluZS5wdXNoKHByaW50YWJsZV90b2tlbik7XG4gICAgfTtcblxuICAgIHRoaXMuYWRkX3NwYWNlX2JlZm9yZV90b2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5zcGFjZV9iZWZvcmVfdG9rZW4gJiYgIXRoaXMuanVzdF9hZGRlZF9uZXdsaW5lKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudF9saW5lLnB1c2goJyAnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICAgIH07XG5cbiAgICB0aGlzLnJlbW92ZV9pbmRlbnQgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB2YXIgb3V0cHV0X2xlbmd0aCA9IGxpbmVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgb3V0cHV0X2xlbmd0aCkge1xuICAgICAgICAgICAgbGluZXNbaW5kZXhdLnJlbW92ZV9pbmRlbnQoKTtcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy50cmltID0gZnVuY3Rpb24oZWF0X25ld2xpbmVzKSB7XG4gICAgICAgIGVhdF9uZXdsaW5lcyA9IChlYXRfbmV3bGluZXMgPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IGVhdF9uZXdsaW5lcztcblxuICAgICAgICB0aGlzLmN1cnJlbnRfbGluZS50cmltKGluZGVudF9zdHJpbmcsIGJhc2VJbmRlbnRTdHJpbmcpO1xuXG4gICAgICAgIHdoaWxlIChlYXRfbmV3bGluZXMgJiYgbGluZXMubGVuZ3RoID4gMSAmJlxuICAgICAgICAgICAgdGhpcy5jdXJyZW50X2xpbmUuaXNfZW1wdHkoKSkge1xuICAgICAgICAgICAgbGluZXMucG9wKCk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRfbGluZSA9IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50X2xpbmUudHJpbSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcmV2aW91c19saW5lID0gbGluZXMubGVuZ3RoID4gMSA/IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDJdIDogbnVsbDtcbiAgICB9O1xuXG4gICAgdGhpcy5qdXN0X2FkZGVkX25ld2xpbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudF9saW5lLmlzX2VtcHR5KCk7XG4gICAgfTtcblxuICAgIHRoaXMuanVzdF9hZGRlZF9ibGFua2xpbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuanVzdF9hZGRlZF9uZXdsaW5lKCkpIHtcbiAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gc3RhcnQgb2YgdGhlIGZpbGUgYW5kIG5ld2xpbmUgPSBibGFua1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgcmV0dXJuIGxpbmUuaXNfZW1wdHkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMuT3V0cHV0ID0gT3V0cHV0O1xuXG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKmpzaGludCBjdXJseTp0cnVlLCBlcWVxZXE6dHJ1ZSwgbGF4YnJlYWs6dHJ1ZSwgbm9lbXB0eTpmYWxzZSAqL1xuLypcblxuICAgIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gICAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTcgRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gICAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gICAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICAgIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gICAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICAgIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICAgIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICAgIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICBTT0ZUV0FSRS5cbiovXG5cbnZhciBCZWF1dGlmaWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5CZWF1dGlmaWVyO1xuXG5mdW5jdGlvbiBjc3NfYmVhdXRpZnkoc291cmNlX3RleHQsIG9wdGlvbnMpIHtcbiAgICB2YXIgYmVhdXRpZmllciA9IG5ldyBCZWF1dGlmaWVyKHNvdXJjZV90ZXh0LCBvcHRpb25zKTtcbiAgICByZXR1cm4gYmVhdXRpZmllci5iZWF1dGlmeSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNzc19iZWF1dGlmeTtcblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xudmFyIGNzc19iZWF1dGlmeSA9IGxlZ2FjeV9iZWF1dGlmeV9jc3M7XG4vKiBGb290ZXIgKi9cbmlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEFkZCBzdXBwb3J0IGZvciBBTUQgKCBodHRwczovL2dpdGh1Yi5jb20vYW1kanMvYW1kanMtYXBpL3dpa2kvQU1EI2RlZmluZWFtZC1wcm9wZXJ0eS0gKVxuICAgIGRlZmluZShbXSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjc3NfYmVhdXRpZnk6IGNzc19iZWF1dGlmeVxuICAgICAgICB9O1xuICAgIH0pO1xufSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIEFkZCBzdXBwb3J0IGZvciBDb21tb25KUy4gSnVzdCBwdXQgdGhpcyBmaWxlIHNvbWV3aGVyZSBvbiB5b3VyIHJlcXVpcmUucGF0aHNcbiAgICAvLyBhbmQgeW91IHdpbGwgYmUgYWJsZSB0byBgdmFyIGh0bWxfYmVhdXRpZnkgPSByZXF1aXJlKFwiYmVhdXRpZnlcIikuaHRtbF9iZWF1dGlmeWAuXG4gICAgZXhwb3J0cy5jc3NfYmVhdXRpZnkgPSBjc3NfYmVhdXRpZnk7XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBJZiB3ZSdyZSBydW5uaW5nIGEgd2ViIHBhZ2UgYW5kIGRvbid0IGhhdmUgZWl0aGVyIG9mIHRoZSBhYm92ZSwgYWRkIG91ciBvbmUgZ2xvYmFsXG4gICAgd2luZG93LmNzc19iZWF1dGlmeSA9IGNzc19iZWF1dGlmeTtcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIElmIHdlIGRvbid0IGV2ZW4gaGF2ZSB3aW5kb3csIHRyeSBnbG9iYWwuXG4gICAgZ2xvYmFsLmNzc19iZWF1dGlmeSA9IGNzc19iZWF1dGlmeTtcbn1cblxufSgpKTtcbiIsIi8qanNoaW50IGN1cmx5OmZhbHNlLCBlcWVxZXE6dHJ1ZSwgbGF4YnJlYWs6dHJ1ZSwgbm9lbXB0eTpmYWxzZSAqL1xuLyogQVVUTy1HRU5FUkFURUQuIERPIE5PVCBNT0RJRlkuICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE3IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cblxuXG4gU3R5bGUgSFRNTFxuLS0tLS0tLS0tLS0tLS0tXG5cbiAgV3JpdHRlbiBieSBOb2NodW0gU29zc29ua28sIChuc29zc29ua29AaG90bWFpbC5jb20pXG5cbiAgQmFzZWQgb24gY29kZSBpbml0aWFsbHkgZGV2ZWxvcGVkIGJ5OiBFaW5hciBMaWVsbWFuaXMsIDxlaW5hckBqc2JlYXV0aWZpZXIub3JnPlxuICAgIGh0dHA6Ly9qc2JlYXV0aWZpZXIub3JnL1xuXG4gIFVzYWdlOlxuICAgIHN0eWxlX2h0bWwoaHRtbF9zb3VyY2UpO1xuXG4gICAgc3R5bGVfaHRtbChodG1sX3NvdXJjZSwgb3B0aW9ucyk7XG5cbiAgVGhlIG9wdGlvbnMgYXJlOlxuICAgIGluZGVudF9pbm5lcl9odG1sIChkZWZhdWx0IGZhbHNlKSAg4oCUIGluZGVudCA8aGVhZD4gYW5kIDxib2R5PiBzZWN0aW9ucyxcbiAgICBpbmRlbnRfc2l6ZSAoZGVmYXVsdCA0KSAgICAgICAgICDigJQgaW5kZW50YXRpb24gc2l6ZSxcbiAgICBpbmRlbnRfY2hhciAoZGVmYXVsdCBzcGFjZSkgICAgICDigJQgY2hhcmFjdGVyIHRvIGluZGVudCB3aXRoLFxuICAgIHdyYXBfbGluZV9sZW5ndGggKGRlZmF1bHQgMjUwKSAgICAgICAgICAgIC0gIG1heGltdW0gYW1vdW50IG9mIGNoYXJhY3RlcnMgcGVyIGxpbmUgKDAgPSBkaXNhYmxlKVxuICAgIGJyYWNlX3N0eWxlIChkZWZhdWx0IFwiY29sbGFwc2VcIikgLSBcImNvbGxhcHNlXCIgfCBcImV4cGFuZFwiIHwgXCJlbmQtZXhwYW5kXCIgfCBcIm5vbmVcIlxuICAgICAgICAgICAgcHV0IGJyYWNlcyBvbiB0aGUgc2FtZSBsaW5lIGFzIGNvbnRyb2wgc3RhdGVtZW50cyAoZGVmYXVsdCksIG9yIHB1dCBicmFjZXMgb24gb3duIGxpbmUgKEFsbG1hbiAvIEFOU0kgc3R5bGUpLCBvciBqdXN0IHB1dCBlbmQgYnJhY2VzIG9uIG93biBsaW5lLCBvciBhdHRlbXB0IHRvIGtlZXAgdGhlbSB3aGVyZSB0aGV5IGFyZS5cbiAgICB1bmZvcm1hdHRlZCAoZGVmYXVsdHMgdG8gaW5saW5lIHRhZ3MpIC0gbGlzdCBvZiB0YWdzLCB0aGF0IHNob3VsZG4ndCBiZSByZWZvcm1hdHRlZFxuICAgIGNvbnRlbnRfdW5mb3JtYXR0ZWQgKGRlZmF1bHRzIHRvIHByZSB0YWcpIC0gbGlzdCBvZiB0YWdzLCB3aG9zZSBjb250ZW50IHNob3VsZG4ndCBiZSByZWZvcm1hdHRlZFxuICAgIGluZGVudF9zY3JpcHRzIChkZWZhdWx0IG5vcm1hbCkgIC0gXCJrZWVwXCJ8XCJzZXBhcmF0ZVwifFwibm9ybWFsXCJcbiAgICBwcmVzZXJ2ZV9uZXdsaW5lcyAoZGVmYXVsdCB0cnVlKSAtIHdoZXRoZXIgZXhpc3RpbmcgbGluZSBicmVha3MgYmVmb3JlIGVsZW1lbnRzIHNob3VsZCBiZSBwcmVzZXJ2ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPbmx5IHdvcmtzIGJlZm9yZSBlbGVtZW50cywgbm90IGluc2lkZSB0YWdzIG9yIGZvciB0ZXh0LlxuICAgIG1heF9wcmVzZXJ2ZV9uZXdsaW5lcyAoZGVmYXVsdCB1bmxpbWl0ZWQpIC0gbWF4aW11bSBudW1iZXIgb2YgbGluZSBicmVha3MgdG8gYmUgcHJlc2VydmVkIGluIG9uZSBjaHVua1xuICAgIGluZGVudF9oYW5kbGViYXJzIChkZWZhdWx0IGZhbHNlKSAtIGZvcm1hdCBhbmQgaW5kZW50IHt7I2Zvb319IGFuZCB7ey9mb299fVxuICAgIGVuZF93aXRoX25ld2xpbmUgKGZhbHNlKSAgICAgICAgICAtIGVuZCB3aXRoIGEgbmV3bGluZVxuICAgIGV4dHJhX2xpbmVycyAoZGVmYXVsdCBbaGVhZCxib2R5LC9odG1sXSkgLUxpc3Qgb2YgdGFncyB0aGF0IHNob3VsZCBoYXZlIGFuIGV4dHJhIG5ld2xpbmUgYmVmb3JlIHRoZW0uXG5cbiAgICBlLmcuXG5cbiAgICBzdHlsZV9odG1sKGh0bWxfc291cmNlLCB7XG4gICAgICAnaW5kZW50X2lubmVyX2h0bWwnOiBmYWxzZSxcbiAgICAgICdpbmRlbnRfc2l6ZSc6IDIsXG4gICAgICAnaW5kZW50X2NoYXInOiAnICcsXG4gICAgICAnd3JhcF9saW5lX2xlbmd0aCc6IDc4LFxuICAgICAgJ2JyYWNlX3N0eWxlJzogJ2V4cGFuZCcsXG4gICAgICAncHJlc2VydmVfbmV3bGluZXMnOiB0cnVlLFxuICAgICAgJ21heF9wcmVzZXJ2ZV9uZXdsaW5lcyc6IDUsXG4gICAgICAnaW5kZW50X2hhbmRsZWJhcnMnOiBmYWxzZSxcbiAgICAgICdleHRyYV9saW5lcnMnOiBbJy9odG1sJ11cbiAgICB9KTtcbiovXG5cbihmdW5jdGlvbigpIHtcbnZhciBsZWdhY3lfYmVhdXRpZnlfaHRtbCA9XG4vKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbi8qKioqKiovIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbi8qKioqKiovIFx0XHRcdH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAzKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLypqc2hpbnQgY3VybHk6dHJ1ZSwgZXFlcWVxOnRydWUsIGxheGJyZWFrOnRydWUsIG5vZW1wdHk6ZmFsc2UgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTcgRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxudmFyIG1lcmdlT3B0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMikubWVyZ2VPcHRzO1xudmFyIGFjb3JuID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuXG52YXIgbGluZUJyZWFrID0gYWNvcm4ubGluZUJyZWFrO1xudmFyIGFsbExpbmVCcmVha3MgPSBhY29ybi5hbGxMaW5lQnJlYWtzO1xuXG4vLyBmdW5jdGlvbiB0cmltKHMpIHtcbi8vICAgICByZXR1cm4gcy5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG4vLyB9XG5cbmZ1bmN0aW9uIGx0cmltKHMpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKC9eXFxzKy9nLCAnJyk7XG59XG5cbmZ1bmN0aW9uIHJ0cmltKHMpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKC9cXHMrJC9nLCAnJyk7XG59XG5cbmZ1bmN0aW9uIEJlYXV0aWZpZXIoaHRtbF9zb3VyY2UsIG9wdGlvbnMsIGpzX2JlYXV0aWZ5LCBjc3NfYmVhdXRpZnkpIHtcbiAgICAvL1dyYXBwZXIgZnVuY3Rpb24gdG8gaW52b2tlIGFsbCB0aGUgbmVjZXNzYXJ5IGNvbnN0cnVjdG9ycyBhbmQgZGVhbCB3aXRoIHRoZSBvdXRwdXQuXG4gICAgaHRtbF9zb3VyY2UgPSBodG1sX3NvdXJjZSB8fCAnJztcblxuICAgIHZhciBtdWx0aV9wYXJzZXIsXG4gICAgICAgIGluZGVudF9pbm5lcl9odG1sLFxuICAgICAgICBpbmRlbnRfYm9keV9pbm5lcl9odG1sLFxuICAgICAgICBpbmRlbnRfaGVhZF9pbm5lcl9odG1sLFxuICAgICAgICBpbmRlbnRfc2l6ZSxcbiAgICAgICAgaW5kZW50X2NoYXJhY3RlcixcbiAgICAgICAgd3JhcF9saW5lX2xlbmd0aCxcbiAgICAgICAgYnJhY2Vfc3R5bGUsXG4gICAgICAgIHVuZm9ybWF0dGVkLFxuICAgICAgICBjb250ZW50X3VuZm9ybWF0dGVkLFxuICAgICAgICBwcmVzZXJ2ZV9uZXdsaW5lcyxcbiAgICAgICAgbWF4X3ByZXNlcnZlX25ld2xpbmVzLFxuICAgICAgICBpbmRlbnRfaGFuZGxlYmFycyxcbiAgICAgICAgd3JhcF9hdHRyaWJ1dGVzLFxuICAgICAgICB3cmFwX2F0dHJpYnV0ZXNfaW5kZW50X3NpemUsXG4gICAgICAgIGlzX3dyYXBfYXR0cmlidXRlc19mb3JjZSxcbiAgICAgICAgaXNfd3JhcF9hdHRyaWJ1dGVzX2ZvcmNlX2V4cGFuZF9tdWx0aWxpbmUsXG4gICAgICAgIGlzX3dyYXBfYXR0cmlidXRlc19mb3JjZV9hbGlnbmVkLFxuICAgICAgICBlbmRfd2l0aF9uZXdsaW5lLFxuICAgICAgICBleHRyYV9saW5lcnMsXG4gICAgICAgIGVvbDtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gQWxsb3cgdGhlIHNldHRpbmcgb2YgbGFuZ3VhZ2UvZmlsZS10eXBlIHNwZWNpZmljIG9wdGlvbnNcbiAgICAvLyB3aXRoIGluaGVyaXRhbmNlIG9mIG92ZXJhbGwgc2V0dGluZ3NcbiAgICBvcHRpb25zID0gbWVyZ2VPcHRzKG9wdGlvbnMsICdodG1sJyk7XG5cbiAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB0byAxLjMuNFxuICAgIGlmICgob3B0aW9ucy53cmFwX2xpbmVfbGVuZ3RoID09PSB1bmRlZmluZWQgfHwgcGFyc2VJbnQob3B0aW9ucy53cmFwX2xpbmVfbGVuZ3RoLCAxMCkgPT09IDApICYmXG4gICAgICAgIChvcHRpb25zLm1heF9jaGFyICE9PSB1bmRlZmluZWQgJiYgcGFyc2VJbnQob3B0aW9ucy5tYXhfY2hhciwgMTApICE9PSAwKSkge1xuICAgICAgICBvcHRpb25zLndyYXBfbGluZV9sZW5ndGggPSBvcHRpb25zLm1heF9jaGFyO1xuICAgIH1cblxuICAgIGluZGVudF9pbm5lcl9odG1sID0gKG9wdGlvbnMuaW5kZW50X2lubmVyX2h0bWwgPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IG9wdGlvbnMuaW5kZW50X2lubmVyX2h0bWw7XG4gICAgaW5kZW50X2JvZHlfaW5uZXJfaHRtbCA9IChvcHRpb25zLmluZGVudF9ib2R5X2lubmVyX2h0bWwgPT09IHVuZGVmaW5lZCkgPyB0cnVlIDogb3B0aW9ucy5pbmRlbnRfYm9keV9pbm5lcl9odG1sO1xuICAgIGluZGVudF9oZWFkX2lubmVyX2h0bWwgPSAob3B0aW9ucy5pbmRlbnRfaGVhZF9pbm5lcl9odG1sID09PSB1bmRlZmluZWQpID8gdHJ1ZSA6IG9wdGlvbnMuaW5kZW50X2hlYWRfaW5uZXJfaHRtbDtcbiAgICBpbmRlbnRfc2l6ZSA9IChvcHRpb25zLmluZGVudF9zaXplID09PSB1bmRlZmluZWQpID8gNCA6IHBhcnNlSW50KG9wdGlvbnMuaW5kZW50X3NpemUsIDEwKTtcbiAgICBpbmRlbnRfY2hhcmFjdGVyID0gKG9wdGlvbnMuaW5kZW50X2NoYXIgPT09IHVuZGVmaW5lZCkgPyAnICcgOiBvcHRpb25zLmluZGVudF9jaGFyO1xuICAgIGJyYWNlX3N0eWxlID0gKG9wdGlvbnMuYnJhY2Vfc3R5bGUgPT09IHVuZGVmaW5lZCkgPyAnY29sbGFwc2UnIDogb3B0aW9ucy5icmFjZV9zdHlsZTtcbiAgICB3cmFwX2xpbmVfbGVuZ3RoID0gcGFyc2VJbnQob3B0aW9ucy53cmFwX2xpbmVfbGVuZ3RoLCAxMCkgPT09IDAgPyAzMjc4NiA6IHBhcnNlSW50KG9wdGlvbnMud3JhcF9saW5lX2xlbmd0aCB8fCAyNTAsIDEwKTtcbiAgICB1bmZvcm1hdHRlZCA9IG9wdGlvbnMudW5mb3JtYXR0ZWQgfHwgW1xuICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZG9tLmh0bWwjcGhyYXNpbmctY29udGVudFxuICAgICAgICAnYScsICdhYmJyJywgJ2FyZWEnLCAnYXVkaW8nLCAnYicsICdiZGknLCAnYmRvJywgJ2JyJywgJ2J1dHRvbicsICdjYW52YXMnLCAnY2l0ZScsXG4gICAgICAgICdjb2RlJywgJ2RhdGEnLCAnZGF0YWxpc3QnLCAnZGVsJywgJ2RmbicsICdlbScsICdlbWJlZCcsICdpJywgJ2lmcmFtZScsICdpbWcnLFxuICAgICAgICAnaW5wdXQnLCAnaW5zJywgJ2tiZCcsICdrZXlnZW4nLCAnbGFiZWwnLCAnbWFwJywgJ21hcmsnLCAnbWF0aCcsICdtZXRlcicsICdub3NjcmlwdCcsXG4gICAgICAgICdvYmplY3QnLCAnb3V0cHV0JywgJ3Byb2dyZXNzJywgJ3EnLCAncnVieScsICdzJywgJ3NhbXAnLCAvKiAnc2NyaXB0JywgKi8gJ3NlbGVjdCcsICdzbWFsbCcsXG4gICAgICAgICdzcGFuJywgJ3N0cm9uZycsICdzdWInLCAnc3VwJywgJ3N2ZycsICd0ZW1wbGF0ZScsICd0ZXh0YXJlYScsICd0aW1lJywgJ3UnLCAndmFyJyxcbiAgICAgICAgJ3ZpZGVvJywgJ3dicicsICd0ZXh0JyxcbiAgICAgICAgLy8gcHJleGlzdGluZyAtIG5vdCBzdXJlIG9mIGZ1bGwgZWZmZWN0IG9mIHJlbW92aW5nLCBsZWF2aW5nIGluXG4gICAgICAgICdhY3JvbnltJywgJ2FkZHJlc3MnLCAnYmlnJywgJ2R0JywgJ2lucycsICdzdHJpa2UnLCAndHQnLFxuICAgIF07XG4gICAgY29udGVudF91bmZvcm1hdHRlZCA9IG9wdGlvbnMuY29udGVudF91bmZvcm1hdHRlZCB8fCBbXG4gICAgICAgICdwcmUnLFxuICAgIF07XG4gICAgcHJlc2VydmVfbmV3bGluZXMgPSAob3B0aW9ucy5wcmVzZXJ2ZV9uZXdsaW5lcyA9PT0gdW5kZWZpbmVkKSA/IHRydWUgOiBvcHRpb25zLnByZXNlcnZlX25ld2xpbmVzO1xuICAgIG1heF9wcmVzZXJ2ZV9uZXdsaW5lcyA9IHByZXNlcnZlX25ld2xpbmVzID9cbiAgICAgICAgKGlzTmFOKHBhcnNlSW50KG9wdGlvbnMubWF4X3ByZXNlcnZlX25ld2xpbmVzLCAxMCkpID8gMzI3ODYgOiBwYXJzZUludChvcHRpb25zLm1heF9wcmVzZXJ2ZV9uZXdsaW5lcywgMTApKSA6XG4gICAgICAgIDA7XG4gICAgaW5kZW50X2hhbmRsZWJhcnMgPSAob3B0aW9ucy5pbmRlbnRfaGFuZGxlYmFycyA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogb3B0aW9ucy5pbmRlbnRfaGFuZGxlYmFycztcbiAgICB3cmFwX2F0dHJpYnV0ZXMgPSAob3B0aW9ucy53cmFwX2F0dHJpYnV0ZXMgPT09IHVuZGVmaW5lZCkgPyAnYXV0bycgOiBvcHRpb25zLndyYXBfYXR0cmlidXRlcztcbiAgICB3cmFwX2F0dHJpYnV0ZXNfaW5kZW50X3NpemUgPSAoaXNOYU4ocGFyc2VJbnQob3B0aW9ucy53cmFwX2F0dHJpYnV0ZXNfaW5kZW50X3NpemUsIDEwKSkpID8gaW5kZW50X3NpemUgOiBwYXJzZUludChvcHRpb25zLndyYXBfYXR0cmlidXRlc19pbmRlbnRfc2l6ZSwgMTApO1xuICAgIGlzX3dyYXBfYXR0cmlidXRlc19mb3JjZSA9IHdyYXBfYXR0cmlidXRlcy5zdWJzdHIoMCwgJ2ZvcmNlJy5sZW5ndGgpID09PSAnZm9yY2UnO1xuICAgIGlzX3dyYXBfYXR0cmlidXRlc19mb3JjZV9leHBhbmRfbXVsdGlsaW5lID0gKHdyYXBfYXR0cmlidXRlcyA9PT0gJ2ZvcmNlLWV4cGFuZC1tdWx0aWxpbmUnKTtcbiAgICBpc193cmFwX2F0dHJpYnV0ZXNfZm9yY2VfYWxpZ25lZCA9ICh3cmFwX2F0dHJpYnV0ZXMgPT09ICdmb3JjZS1hbGlnbmVkJyk7XG4gICAgZW5kX3dpdGhfbmV3bGluZSA9IChvcHRpb25zLmVuZF93aXRoX25ld2xpbmUgPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IG9wdGlvbnMuZW5kX3dpdGhfbmV3bGluZTtcbiAgICBleHRyYV9saW5lcnMgPSAodHlwZW9mIG9wdGlvbnMuZXh0cmFfbGluZXJzID09PSAnb2JqZWN0JykgJiYgb3B0aW9ucy5leHRyYV9saW5lcnMgP1xuICAgICAgICBvcHRpb25zLmV4dHJhX2xpbmVycy5jb25jYXQoKSA6ICh0eXBlb2Ygb3B0aW9ucy5leHRyYV9saW5lcnMgPT09ICdzdHJpbmcnKSA/XG4gICAgICAgIG9wdGlvbnMuZXh0cmFfbGluZXJzLnNwbGl0KCcsJykgOiAnaGVhZCxib2R5LC9odG1sJy5zcGxpdCgnLCcpO1xuICAgIGVvbCA9IG9wdGlvbnMuZW9sID8gb3B0aW9ucy5lb2wgOiAnYXV0byc7XG5cbiAgICBpZiAob3B0aW9ucy5pbmRlbnRfd2l0aF90YWJzKSB7XG4gICAgICAgIGluZGVudF9jaGFyYWN0ZXIgPSAnXFx0JztcbiAgICAgICAgaW5kZW50X3NpemUgPSAxO1xuICAgIH1cblxuICAgIGlmIChlb2wgPT09ICdhdXRvJykge1xuICAgICAgICBlb2wgPSAnXFxuJztcbiAgICAgICAgaWYgKGh0bWxfc291cmNlICYmIGxpbmVCcmVhay50ZXN0KGh0bWxfc291cmNlIHx8ICcnKSkge1xuICAgICAgICAgICAgZW9sID0gaHRtbF9zb3VyY2UubWF0Y2gobGluZUJyZWFrKVswXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVvbCA9IGVvbC5yZXBsYWNlKC9cXFxcci8sICdcXHInKS5yZXBsYWNlKC9cXFxcbi8sICdcXG4nKTtcblxuICAgIC8vIEhBQ0s6IG5ld2xpbmUgcGFyc2luZyBpbmNvbnNpc3RlbnQuIFRoaXMgYnJ1dGUgZm9yY2Ugbm9ybWFsaXplcyB0aGUgaW5wdXQuXG4gICAgaHRtbF9zb3VyY2UgPSBodG1sX3NvdXJjZS5yZXBsYWNlKGFsbExpbmVCcmVha3MsICdcXG4nKTtcblxuICAgIGZ1bmN0aW9uIFBhcnNlcigpIHtcblxuICAgICAgICB0aGlzLnBvcyA9IDA7IC8vUGFyc2VyIHBvc2l0aW9uXG4gICAgICAgIHRoaXMudG9rZW4gPSAnJztcbiAgICAgICAgdGhpcy5jdXJyZW50X21vZGUgPSAnQ09OVEVOVCc7IC8vcmVmbGVjdHMgdGhlIGN1cnJlbnQgUGFyc2VyIG1vZGU6IFRBRy9DT05URU5UXG4gICAgICAgIHRoaXMudGFncyA9IHsgLy9BbiBvYmplY3QgdG8gaG9sZCB0YWdzLCB0aGVpciBwb3NpdGlvbiwgYW5kIHRoZWlyIHBhcmVudC10YWdzLCBpbml0aWF0ZWQgd2l0aCBkZWZhdWx0IHZhbHVlc1xuICAgICAgICAgICAgcGFyZW50OiAncGFyZW50MScsXG4gICAgICAgICAgICBwYXJlbnRjb3VudDogMSxcbiAgICAgICAgICAgIHBhcmVudDE6ICcnXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudGFnX3R5cGUgPSAnJztcbiAgICAgICAgdGhpcy50b2tlbl90ZXh0ID0gdGhpcy5sYXN0X3Rva2VuID0gdGhpcy5sYXN0X3RleHQgPSB0aGlzLnRva2VuX3R5cGUgPSAnJztcbiAgICAgICAgdGhpcy5uZXdsaW5lcyA9IDA7XG4gICAgICAgIHRoaXMuaW5kZW50X2NvbnRlbnQgPSBpbmRlbnRfaW5uZXJfaHRtbDtcbiAgICAgICAgdGhpcy5pbmRlbnRfYm9keV9pbm5lcl9odG1sID0gaW5kZW50X2JvZHlfaW5uZXJfaHRtbDtcbiAgICAgICAgdGhpcy5pbmRlbnRfaGVhZF9pbm5lcl9odG1sID0gaW5kZW50X2hlYWRfaW5uZXJfaHRtbDtcblxuICAgICAgICB0aGlzLlV0aWxzID0geyAvL1VpbGl0aWVzIG1hZGUgYXZhaWxhYmxlIHRvIHRoZSB2YXJpb3VzIGZ1bmN0aW9uc1xuICAgICAgICAgICAgd2hpdGVzcGFjZTogXCJcXG5cXHJcXHQgXCIuc3BsaXQoJycpLFxuXG4gICAgICAgICAgICBzaW5nbGVfdG9rZW46IG9wdGlvbnMudm9pZF9lbGVtZW50cyB8fCBbXG4gICAgICAgICAgICAgICAgLy8gSFRMTSB2b2lkIGVsZW1lbnRzIC0gYWthIHNlbGYtY2xvc2luZyB0YWdzIC0gYWthIHNpbmdsZXRvbnNcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvaHRtbC93Zy9kcmFmdHMvaHRtbC9tYXN0ZXIvc3ludGF4Lmh0bWwjdm9pZC1lbGVtZW50c1xuICAgICAgICAgICAgICAgICdhcmVhJywgJ2Jhc2UnLCAnYnInLCAnY29sJywgJ2VtYmVkJywgJ2hyJywgJ2ltZycsICdpbnB1dCcsICdrZXlnZW4nLFxuICAgICAgICAgICAgICAgICdsaW5rJywgJ21lbnVpdGVtJywgJ21ldGEnLCAncGFyYW0nLCAnc291cmNlJywgJ3RyYWNrJywgJ3dicicsXG4gICAgICAgICAgICAgICAgLy8gTk9URTogT3B0aW9uYWwgdGFncyAtIGFyZSBub3QgdW5kZXJzdG9vZC5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjb3B0aW9uYWwtdGFnc1xuICAgICAgICAgICAgICAgIC8vIFRoZSBydWxlcyBmb3Igb3B0aW9uYWwgdGFncyBhcmUgdG9vIGNvbXBsZXggZm9yIGEgc2ltcGxlIGxpc3RcbiAgICAgICAgICAgICAgICAvLyBBbHNvLCB0aGUgY29udGVudCBvZiB0aGVzZSB0YWdzIHNob3VsZCBzdGlsbCBiZSBpbmRlbnRlZCBpbiBtYW55IGNhc2VzLlxuICAgICAgICAgICAgICAgIC8vICdsaScgaXMgYSBnb29kIGV4bXBsZS5cblxuICAgICAgICAgICAgICAgIC8vIERvY3R5cGUgYW5kIHhtbCBlbGVtZW50c1xuICAgICAgICAgICAgICAgICchZG9jdHlwZScsICc/eG1sJyxcbiAgICAgICAgICAgICAgICAvLyA/cGhwIHRhZ1xuICAgICAgICAgICAgICAgICc/cGhwJyxcbiAgICAgICAgICAgICAgICAvLyBvdGhlciB0YWdzIHRoYXQgd2VyZSBpbiB0aGlzIGxpc3QsIGtlZXBpbmcganVzdCBpbiBjYXNlXG4gICAgICAgICAgICAgICAgJ2Jhc2Vmb250JywgJ2lzaW5kZXgnXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZXh0cmFfbGluZXJzOiBleHRyYV9saW5lcnMsIC8vZm9yIHRhZ3MgdGhhdCBuZWVkIGEgbGluZSBvZiB3aGl0ZXNwYWNlIGJlZm9yZSB0aGVtXG4gICAgICAgICAgICBpbl9hcnJheTogZnVuY3Rpb24od2hhdCwgYXJyKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdoYXQgPT09IGFycltpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFJldHVybiB0cnVlIGlmIHRoZSBnaXZlbiB0ZXh0IGlzIGNvbXBvc2VkIGVudGlyZWx5IG9mIHdoaXRlc3BhY2UuXG4gICAgICAgIHRoaXMuaXNfd2hpdGVzcGFjZSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgdGV4dC5sZW5ndGg7IG4rKykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5VdGlscy5pbl9hcnJheSh0ZXh0LmNoYXJBdChuKSwgdGhpcy5VdGlscy53aGl0ZXNwYWNlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy50cmF2ZXJzZV93aGl0ZXNwYWNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRfY2hhciA9ICcnO1xuXG4gICAgICAgICAgICBpbnB1dF9jaGFyID0gdGhpcy5pbnB1dC5jaGFyQXQodGhpcy5wb3MpO1xuICAgICAgICAgICAgaWYgKHRoaXMuVXRpbHMuaW5fYXJyYXkoaW5wdXRfY2hhciwgdGhpcy5VdGlscy53aGl0ZXNwYWNlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubmV3bGluZXMgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLlV0aWxzLmluX2FycmF5KGlucHV0X2NoYXIsIHRoaXMuVXRpbHMud2hpdGVzcGFjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXNlcnZlX25ld2xpbmVzICYmIGlucHV0X2NoYXIgPT09ICdcXG4nICYmIHRoaXMubmV3bGluZXMgPD0gbWF4X3ByZXNlcnZlX25ld2xpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5ld2xpbmVzICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcysrO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dF9jaGFyID0gdGhpcy5pbnB1dC5jaGFyQXQodGhpcy5wb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBBcHBlbmQgYSBzcGFjZSB0byB0aGUgZ2l2ZW4gY29udGVudCAoc3RyaW5nIGFycmF5KSBvciwgaWYgd2UgYXJlXG4gICAgICAgIC8vIGF0IHRoZSB3cmFwX2xpbmVfbGVuZ3RoLCBhcHBlbmQgYSBuZXdsaW5lL2luZGVudGF0aW9uLlxuICAgICAgICAvLyByZXR1cm4gdHJ1ZSBpZiBhIG5ld2xpbmUgd2FzIGFkZGVkLCBmYWxzZSBpZiBhIHNwYWNlIHdhcyBhZGRlZFxuICAgICAgICB0aGlzLnNwYWNlX29yX3dyYXAgPSBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5saW5lX2NoYXJfY291bnQgPj0gdGhpcy53cmFwX2xpbmVfbGVuZ3RoKSB7IC8vaW5zZXJ0IGEgbGluZSB3aGVuIHRoZSB3cmFwX2xpbmVfbGVuZ3RoIGlzIHJlYWNoZWRcbiAgICAgICAgICAgICAgICB0aGlzLnByaW50X25ld2xpbmUoZmFsc2UsIGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJpbnRfaW5kZW50YXRpb24oY29udGVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubGluZV9jaGFyX2NvdW50Kys7XG4gICAgICAgICAgICAgICAgY29udGVudC5wdXNoKCcgJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZ2V0X2NvbnRlbnQgPSBmdW5jdGlvbigpIHsgLy9mdW5jdGlvbiB0byBjYXB0dXJlIHJlZ3VsYXIgY29udGVudCBiZXR3ZWVuIHRhZ3NcbiAgICAgICAgICAgIHZhciBpbnB1dF9jaGFyID0gJycsXG4gICAgICAgICAgICAgICAgY29udGVudCA9IFtdLFxuICAgICAgICAgICAgICAgIGhhbmRsZWJhcnNTdGFydGVkID0gMDtcblxuICAgICAgICAgICAgd2hpbGUgKHRoaXMuaW5wdXQuY2hhckF0KHRoaXMucG9zKSAhPT0gJzwnIHx8IGhhbmRsZWJhcnNTdGFydGVkID09PSAyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50Lmxlbmd0aCA/IGNvbnRlbnQuam9pbignJykgOiBbJycsICdUS19FT0YnXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlYmFyc1N0YXJ0ZWQgPCAyICYmIHRoaXMudHJhdmVyc2Vfd2hpdGVzcGFjZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3BhY2Vfb3Jfd3JhcChjb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaW5wdXRfY2hhciA9IHRoaXMuaW5wdXQuY2hhckF0KHRoaXMucG9zKTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmRlbnRfaGFuZGxlYmFycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRfY2hhciA9PT0gJ3snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGViYXJzU3RhcnRlZCArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhhbmRsZWJhcnNTdGFydGVkIDwgMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlYmFyc1N0YXJ0ZWQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0X2NoYXIgPT09ICd9JyAmJiBoYW5kbGViYXJzU3RhcnRlZCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGViYXJzU3RhcnRlZC0tID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlYmFycyBwYXJzaW5nIGlzIGNvbXBsaWNhdGVkLlxuICAgICAgICAgICAgICAgICAgICAvLyB7eyNmb299fSBhbmQge3svZm9vfX0gYXJlIGZvcm1hdHRlZCB0YWdzLlxuICAgICAgICAgICAgICAgICAgICAvLyB7e3NvbWV0aGluZ319IHNob3VsZCBnZXQgdHJlYXRlZCBhcyBjb250ZW50LCBleGNlcHQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIHt7ZWxzZX19IHNwZWNpZmljYWxseSBiZWhhdmVzIGxpa2Uge3sjaWZ9fSBhbmQge3svaWZ9fVxuICAgICAgICAgICAgICAgICAgICB2YXIgcGVlazMgPSB0aGlzLmlucHV0LnN1YnN0cih0aGlzLnBvcywgMyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwZWVrMyA9PT0gJ3t7IycgfHwgcGVlazMgPT09ICd7ey8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVzZSBhcmUgdGFncyBhbmQgbm90IGNvbnRlbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwZWVrMyA9PT0gJ3t7IScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbdGhpcy5nZXRfdGFnKCksICdUS19UQUdfSEFORExFQkFSU19DT01NRU5UJ107XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pbnB1dC5zdWJzdHIodGhpcy5wb3MsIDIpID09PSAne3snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXRfdGFnKHRydWUpID09PSAne3tlbHNlfX0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnBvcysrO1xuICAgICAgICAgICAgICAgIHRoaXMubGluZV9jaGFyX2NvdW50Kys7XG4gICAgICAgICAgICAgICAgY29udGVudC5wdXNoKGlucHV0X2NoYXIpOyAvL2xldHRlciBhdC1hLXRpbWUgKG9yIHN0cmluZykgaW5zZXJ0ZWQgdG8gYW4gYXJyYXlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb250ZW50Lmxlbmd0aCA/IGNvbnRlbnQuam9pbignJykgOiAnJztcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmdldF9jb250ZW50c190byA9IGZ1bmN0aW9uKG5hbWUpIHsgLy9nZXQgdGhlIGZ1bGwgY29udGVudCBvZiBhIHNjcmlwdCBvciBzdHlsZSB0byBwYXNzIHRvIGpzX2JlYXV0aWZ5XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnJywgJ1RLX0VPRiddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSAnJztcbiAgICAgICAgICAgIHZhciByZWdfbWF0Y2ggPSBuZXcgUmVnRXhwKCc8LycgKyBuYW1lICsgJ1xcXFxzKj4nLCAnaWdtJyk7XG4gICAgICAgICAgICByZWdfbWF0Y2gubGFzdEluZGV4ID0gdGhpcy5wb3M7XG4gICAgICAgICAgICB2YXIgcmVnX2FycmF5ID0gcmVnX21hdGNoLmV4ZWModGhpcy5pbnB1dCk7XG4gICAgICAgICAgICB2YXIgZW5kX3NjcmlwdCA9IHJlZ19hcnJheSA/IHJlZ19hcnJheS5pbmRleCA6IHRoaXMuaW5wdXQubGVuZ3RoOyAvL2Fic29sdXRlIGVuZCBvZiBzY3JpcHRcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA8IGVuZF9zY3JpcHQpIHsgLy9nZXQgZXZlcnl0aGluZyBpbiBiZXR3ZWVuIHRoZSBzY3JpcHQgdGFnc1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLmlucHV0LnN1YnN0cmluZyh0aGlzLnBvcywgZW5kX3NjcmlwdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBlbmRfc2NyaXB0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5yZWNvcmRfdGFnID0gZnVuY3Rpb24odGFnKSB7IC8vZnVuY3Rpb24gdG8gcmVjb3JkIGEgdGFnIGFuZCBpdHMgcGFyZW50IGluIHRoaXMudGFncyBPYmplY3RcbiAgICAgICAgICAgIGlmICh0aGlzLnRhZ3NbdGFnICsgJ2NvdW50J10pIHsgLy9jaGVjayBmb3IgdGhlIGV4aXN0ZW5jZSBvZiB0aGlzIHRhZyB0eXBlXG4gICAgICAgICAgICAgICAgdGhpcy50YWdzW3RhZyArICdjb3VudCddKys7XG4gICAgICAgICAgICAgICAgdGhpcy50YWdzW3RhZyArIHRoaXMudGFnc1t0YWcgKyAnY291bnQnXV0gPSB0aGlzLmluZGVudF9sZXZlbDsgLy9hbmQgcmVjb3JkIHRoZSBwcmVzZW50IGluZGVudCBsZXZlbFxuICAgICAgICAgICAgfSBlbHNlIHsgLy9vdGhlcndpc2UgaW5pdGlhbGl6ZSB0aGlzIHRhZyB0eXBlXG4gICAgICAgICAgICAgICAgdGhpcy50YWdzW3RhZyArICdjb3VudCddID0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ3NbdGFnICsgdGhpcy50YWdzW3RhZyArICdjb3VudCddXSA9IHRoaXMuaW5kZW50X2xldmVsOyAvL2FuZCByZWNvcmQgdGhlIHByZXNlbnQgaW5kZW50IGxldmVsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRhZ3NbdGFnICsgdGhpcy50YWdzW3RhZyArICdjb3VudCddICsgJ3BhcmVudCddID0gdGhpcy50YWdzLnBhcmVudDsgLy9zZXQgdGhlIHBhcmVudCAoaS5lLiBpbiB0aGUgY2FzZSBvZiBhIGRpdiB0aGlzLnRhZ3MuZGl2MXBhcmVudClcbiAgICAgICAgICAgIHRoaXMudGFncy5wYXJlbnQgPSB0YWcgKyB0aGlzLnRhZ3NbdGFnICsgJ2NvdW50J107IC8vYW5kIG1ha2UgdGhpcyB0aGUgY3VycmVudCBwYXJlbnQgKGkuZS4gaW4gdGhlIGNhc2Ugb2YgYSBkaXYgJ2RpdjEnKVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucmV0cmlldmVfdGFnID0gZnVuY3Rpb24odGFnKSB7IC8vZnVuY3Rpb24gdG8gcmV0cmlldmUgdGhlIG9wZW5pbmcgdGFnIHRvIHRoZSBjb3JyZXNwb25kaW5nIGNsb3NlclxuICAgICAgICAgICAgaWYgKHRoaXMudGFnc1t0YWcgKyAnY291bnQnXSkgeyAvL2lmIHRoZSBvcGVuZW5lciBpcyBub3QgaW4gdGhlIE9iamVjdCB3ZSBpZ25vcmUgaXRcbiAgICAgICAgICAgICAgICB2YXIgdGVtcF9wYXJlbnQgPSB0aGlzLnRhZ3MucGFyZW50OyAvL2NoZWNrIHRvIHNlZSBpZiBpdCdzIGEgY2xvc2FibGUgdGFnLlxuICAgICAgICAgICAgICAgIHdoaWxlICh0ZW1wX3BhcmVudCkgeyAvL3RpbGwgd2UgcmVhY2ggJycgKHRoZSBpbml0aWFsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyArIHRoaXMudGFnc1t0YWcgKyAnY291bnQnXSA9PT0gdGVtcF9wYXJlbnQpIHsgLy9pZiB0aGlzIGlzIGl0IHVzZSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGVtcF9wYXJlbnQgPSB0aGlzLnRhZ3NbdGVtcF9wYXJlbnQgKyAncGFyZW50J107IC8vb3RoZXJ3aXNlIGtlZXAgb24gY2xpbWJpbmcgdXAgdGhlIERPTSBUcmVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0ZW1wX3BhcmVudCkgeyAvL2lmIHdlIGNhdWdodCBzb21ldGhpbmdcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRlbnRfbGV2ZWwgPSB0aGlzLnRhZ3NbdGFnICsgdGhpcy50YWdzW3RhZyArICdjb3VudCddXTsgLy9zZXQgdGhlIGluZGVudF9sZXZlbCBhY2NvcmRpbmdseVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhZ3MucGFyZW50ID0gdGhpcy50YWdzW3RlbXBfcGFyZW50ICsgJ3BhcmVudCddOyAvL2FuZCBzZXQgdGhlIGN1cnJlbnQgcGFyZW50XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnRhZ3NbdGFnICsgdGhpcy50YWdzW3RhZyArICdjb3VudCddICsgJ3BhcmVudCddOyAvL2RlbGV0ZSB0aGUgY2xvc2VkIHRhZ3MgcGFyZW50IHJlZmVyZW5jZS4uLlxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnRhZ3NbdGFnICsgdGhpcy50YWdzW3RhZyArICdjb3VudCddXTsgLy8uLi5hbmQgdGhlIHRhZyBpdHNlbGZcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50YWdzW3RhZyArICdjb3VudCddID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnRhZ3NbdGFnICsgJ2NvdW50J107XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YWdzW3RhZyArICdjb3VudCddLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuaW5kZW50X3RvX3RhZyA9IGZ1bmN0aW9uKHRhZykge1xuICAgICAgICAgICAgLy8gTWF0Y2ggdGhlIGluZGVudGF0aW9uIGxldmVsIHRvIHRoZSBsYXN0IHVzZSBvZiB0aGlzIHRhZywgYnV0IGRvbid0IHJlbW92ZSBpdC5cbiAgICAgICAgICAgIGlmICghdGhpcy50YWdzW3RhZyArICdjb3VudCddKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRlbXBfcGFyZW50ID0gdGhpcy50YWdzLnBhcmVudDtcbiAgICAgICAgICAgIHdoaWxlICh0ZW1wX3BhcmVudCkge1xuICAgICAgICAgICAgICAgIGlmICh0YWcgKyB0aGlzLnRhZ3NbdGFnICsgJ2NvdW50J10gPT09IHRlbXBfcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ZW1wX3BhcmVudCA9IHRoaXMudGFnc1t0ZW1wX3BhcmVudCArICdwYXJlbnQnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ZW1wX3BhcmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50X2xldmVsID0gdGhpcy50YWdzW3RhZyArIHRoaXMudGFnc1t0YWcgKyAnY291bnQnXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXRfdGFnID0gZnVuY3Rpb24ocGVlaykgeyAvL2Z1bmN0aW9uIHRvIGdldCBhIGZ1bGwgdGFnIGFuZCBwYXJzZSBpdHMgdHlwZVxuICAgICAgICAgICAgdmFyIGlucHV0X2NoYXIgPSAnJyxcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW10sXG4gICAgICAgICAgICAgICAgY29tbWVudCA9ICcnLFxuICAgICAgICAgICAgICAgIHNwYWNlID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgZmlyc3RfYXR0ciA9IHRydWUsXG4gICAgICAgICAgICAgICAgaGFzX3dyYXBwZWRfYXR0cnMgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICB0YWdfc3RhcnQsIHRhZ19lbmQsXG4gICAgICAgICAgICAgICAgdGFnX3N0YXJ0X2NoYXIsXG4gICAgICAgICAgICAgICAgb3JpZ19wb3MgPSB0aGlzLnBvcyxcbiAgICAgICAgICAgICAgICBvcmlnX2xpbmVfY2hhcl9jb3VudCA9IHRoaXMubGluZV9jaGFyX2NvdW50LFxuICAgICAgICAgICAgICAgIGlzX3RhZ19jbG9zZWQgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICB0YWlsO1xuXG4gICAgICAgICAgICBwZWVrID0gcGVlayAhPT0gdW5kZWZpbmVkID8gcGVlayA6IGZhbHNlO1xuXG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwZWVrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IG9yaWdfcG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lX2NoYXJfY291bnQgPSBvcmlnX2xpbmVfY2hhcl9jb3VudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudC5sZW5ndGggPyBjb250ZW50LmpvaW4oJycpIDogWycnLCAnVEtfRU9GJ107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaW5wdXRfY2hhciA9IHRoaXMuaW5wdXQuY2hhckF0KHRoaXMucG9zKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcysrO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuVXRpbHMuaW5fYXJyYXkoaW5wdXRfY2hhciwgdGhpcy5VdGlscy53aGl0ZXNwYWNlKSkgeyAvL2Rvbid0IHdhbnQgdG8gaW5zZXJ0IHVubmVjZXNzYXJ5IHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIHNwYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0X2NoYXIgPT09IFwiJ1wiIHx8IGlucHV0X2NoYXIgPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRfY2hhciArPSB0aGlzLmdldF91bmZvcm1hdHRlZChpbnB1dF9jaGFyKTtcbiAgICAgICAgICAgICAgICAgICAgc3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbnB1dF9jaGFyID09PSAnPScpIHsgLy9ubyBzcGFjZSBiZWZvcmUgPVxuICAgICAgICAgICAgICAgICAgICBzcGFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YWlsID0gdGhpcy5pbnB1dC5zdWJzdHIodGhpcy5wb3MgLSAxKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNfd3JhcF9hdHRyaWJ1dGVzX2ZvcmNlX2V4cGFuZF9tdWx0aWxpbmUgJiYgaGFzX3dyYXBwZWRfYXR0cnMgJiYgIWlzX3RhZ19jbG9zZWQgJiYgKGlucHV0X2NoYXIgPT09ICc+JyB8fCBpbnB1dF9jaGFyID09PSAnLycpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWlsLm1hdGNoKC9eXFwvP1xccyo+LykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYWNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc190YWdfY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByaW50X2luZGVudGF0aW9uKGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb250ZW50Lmxlbmd0aCAmJiBjb250ZW50W2NvbnRlbnQubGVuZ3RoIC0gMV0gIT09ICc9JyAmJiBpbnB1dF9jaGFyICE9PSAnPicgJiYgc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9ubyBzcGFjZSBhZnRlciA9IG9yIGJlZm9yZSA+XG4gICAgICAgICAgICAgICAgICAgIHZhciB3cmFwcGVkID0gdGhpcy5zcGFjZV9vcl93cmFwKGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZW50QXR0cnMgPSB3cmFwcGVkICYmIGlucHV0X2NoYXIgIT09ICcvJyAmJiAhaXNfd3JhcF9hdHRyaWJ1dGVzX2ZvcmNlO1xuICAgICAgICAgICAgICAgICAgICBzcGFjZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc193cmFwX2F0dHJpYnV0ZXNfZm9yY2UgJiYgaW5wdXRfY2hhciAhPT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm9yY2VfZmlyc3RfYXR0cl93cmFwID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNfd3JhcF9hdHRyaWJ1dGVzX2ZvcmNlX2V4cGFuZF9tdWx0aWxpbmUgJiYgZmlyc3RfYXR0cikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc19vbmx5X2F0dHJpYnV0ZSA9IHRhaWwubWF0Y2goL15cXFMqKD1cIihbXlwiXXxcXFxcXCIpKlwiKT9cXHMqXFwvP1xccyo+LykgIT09IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VfZmlyc3RfYXR0cl93cmFwID0gIWlzX29ubHlfYXR0cmlidXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaXJzdF9hdHRyIHx8IGZvcmNlX2ZpcnN0X2F0dHJfd3JhcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmludF9pbmRlbnRhdGlvbihjb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRlbnRBdHRycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGVudEF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNfd3JhcHBlZF9hdHRycyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaW5kZW50IGF0dHJpYnV0ZXMgYW4gYXV0bywgZm9yY2VkLCBvciBmb3JjZWQtYWxpZ24gbGluZS13cmFwXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWxpZ25tZW50X3NpemUgPSB3cmFwX2F0dHJpYnV0ZXNfaW5kZW50X3NpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNfd3JhcF9hdHRyaWJ1dGVzX2ZvcmNlX2FsaWduZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRfc2l6ZSA9IGNvbnRlbnQuaW5kZXhPZignICcpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgY291bnQgPSAwOyBjb3VudCA8IGFsaWdubWVudF9zaXplOyBjb3VudCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSBldmVyIGZ1cnRoZXIgaW5kZW50IHdpdGggc3BhY2VzIHNpbmNlIHdlJ3JlIHRyeWluZyB0byBhbGlnbiBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudC5wdXNoKCcgJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0X2F0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50W2ldID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RfYXR0ciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZW50X2hhbmRsZWJhcnMgJiYgdGFnX3N0YXJ0X2NoYXIgPT09ICc8Jykge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGluc2lkZSBhbiBhbmdsZS1icmFja2V0IHRhZywgcHV0IHNwYWNlcyBhcm91bmRcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlYmFycyBub3QgaW5zaWRlIG9mIHN0cmluZ3MuXG4gICAgICAgICAgICAgICAgICAgIGlmICgoaW5wdXRfY2hhciArIHRoaXMuaW5wdXQuY2hhckF0KHRoaXMucG9zKSkgPT09ICd7eycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0X2NoYXIgKz0gdGhpcy5nZXRfdW5mb3JtYXR0ZWQoJ319Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudC5sZW5ndGggJiYgY29udGVudFtjb250ZW50Lmxlbmd0aCAtIDFdICE9PSAnICcgJiYgY29udGVudFtjb250ZW50Lmxlbmd0aCAtIDFdICE9PSAnPCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dF9jaGFyID0gJyAnICsgaW5wdXRfY2hhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbnB1dF9jaGFyID09PSAnPCcgJiYgIXRhZ19zdGFydF9jaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhZ19zdGFydCA9IHRoaXMucG9zIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGFnX3N0YXJ0X2NoYXIgPSAnPCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGluZGVudF9oYW5kbGViYXJzICYmICF0YWdfc3RhcnRfY2hhcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudC5sZW5ndGggPj0gMiAmJiBjb250ZW50W2NvbnRlbnQubGVuZ3RoIC0gMV0gPT09ICd7JyAmJiBjb250ZW50W2NvbnRlbnQubGVuZ3RoIC0gMl0gPT09ICd7Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0X2NoYXIgPT09ICcjJyB8fCBpbnB1dF9jaGFyID09PSAnLycgfHwgaW5wdXRfY2hhciA9PT0gJyEnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnX3N0YXJ0ID0gdGhpcy5wb3MgLSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdfc3RhcnQgPSB0aGlzLnBvcyAtIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdfc3RhcnRfY2hhciA9ICd7JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMubGluZV9jaGFyX2NvdW50Kys7XG4gICAgICAgICAgICAgICAgY29udGVudC5wdXNoKGlucHV0X2NoYXIpOyAvL2luc2VydHMgY2hhcmFjdGVyIGF0LWEtdGltZSAob3Igc3RyaW5nKVxuXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRbMV0gJiYgKGNvbnRlbnRbMV0gPT09ICchJyB8fCBjb250ZW50WzFdID09PSAnPycgfHwgY29udGVudFsxXSA9PT0gJyUnKSkgeyAvL2lmIHdlJ3JlIGluIGEgY29tbWVudCwgZG8gc29tZXRoaW5nIHNwZWNpYWxcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgdHJlYXQgYWxsIGNvbW1lbnRzIGFzIGxpdGVyYWxzLCBldmVuIG1vcmUgdGhhbiBwcmVmb3JtYXR0ZWQgdGFnc1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBqdXN0IGxvb2sgZm9yIHRoZSBhcHByb3ByaWF0ZSBjbG9zZSB0YWdcbiAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IFt0aGlzLmdldF9jb21tZW50KHRhZ19zdGFydCldO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZW50X2hhbmRsZWJhcnMgJiYgY29udGVudFsxXSAmJiBjb250ZW50WzFdID09PSAneycgJiYgY29udGVudFsyXSAmJiBjb250ZW50WzJdID09PSAnIScpIHsgLy9pZiB3ZSdyZSBpbiBhIGNvbW1lbnQsIGRvIHNvbWV0aGluZyBzcGVjaWFsXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHRyZWF0IGFsbCBjb21tZW50cyBhcyBsaXRlcmFscywgZXZlbiBtb3JlIHRoYW4gcHJlZm9ybWF0dGVkIHRhZ3NcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UganVzdCBsb29rIGZvciB0aGUgYXBwcm9wcmlhdGUgY2xvc2UgdGFnXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbdGhpcy5nZXRfY29tbWVudCh0YWdfc3RhcnQpXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGluZGVudF9oYW5kbGViYXJzICYmIHRhZ19zdGFydF9jaGFyID09PSAneycgJiYgY29udGVudC5sZW5ndGggPiAyICYmIGNvbnRlbnRbY29udGVudC5sZW5ndGggLSAyXSA9PT0gJ30nICYmIGNvbnRlbnRbY29udGVudC5sZW5ndGggLSAxXSA9PT0gJ30nKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKGlucHV0X2NoYXIgIT09ICc+Jyk7XG5cbiAgICAgICAgICAgIHZhciB0YWdfY29tcGxldGUgPSBjb250ZW50LmpvaW4oJycpO1xuICAgICAgICAgICAgdmFyIHRhZ19pbmRleDtcbiAgICAgICAgICAgIHZhciB0YWdfb2Zmc2V0O1xuXG4gICAgICAgICAgICAvLyBtdXN0IGNoZWNrIGZvciBzcGFjZSBmaXJzdCBvdGhlcndpc2UgdGhlIHRhZyBjb3VsZCBoYXZlIHRoZSBmaXJzdCBhdHRyaWJ1dGUgaW5jbHVkZWQsIGFuZFxuICAgICAgICAgICAgLy8gdGhlbiBub3QgdW4taW5kZW50IGNvcnJlY3RseVxuICAgICAgICAgICAgaWYgKHRhZ19jb21wbGV0ZS5pbmRleE9mKCcgJykgIT09IC0xKSB7IC8vaWYgdGhlcmUncyB3aGl0ZXNwYWNlLCB0aGF0cyB3aGVyZSB0aGUgdGFnIG5hbWUgZW5kc1xuICAgICAgICAgICAgICAgIHRhZ19pbmRleCA9IHRhZ19jb21wbGV0ZS5pbmRleE9mKCcgJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhZ19jb21wbGV0ZS5pbmRleE9mKCdcXG4nKSAhPT0gLTEpIHsgLy9pZiB0aGVyZSdzIGEgbGluZSBicmVhaywgdGhhdHMgd2hlcmUgdGhlIHRhZyBuYW1lIGVuZHNcbiAgICAgICAgICAgICAgICB0YWdfaW5kZXggPSB0YWdfY29tcGxldGUuaW5kZXhPZignXFxuJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhZ19jb21wbGV0ZS5jaGFyQXQoMCkgPT09ICd7Jykge1xuICAgICAgICAgICAgICAgIHRhZ19pbmRleCA9IHRhZ19jb21wbGV0ZS5pbmRleE9mKCd9Jyk7XG4gICAgICAgICAgICB9IGVsc2UgeyAvL290aGVyd2lzZSBnbyB3aXRoIHRoZSB0YWcgZW5kaW5nXG4gICAgICAgICAgICAgICAgdGFnX2luZGV4ID0gdGFnX2NvbXBsZXRlLmluZGV4T2YoJz4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YWdfY29tcGxldGUuY2hhckF0KDApID09PSAnPCcgfHwgIWluZGVudF9oYW5kbGViYXJzKSB7XG4gICAgICAgICAgICAgICAgdGFnX29mZnNldCA9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhZ19vZmZzZXQgPSB0YWdfY29tcGxldGUuY2hhckF0KDIpID09PSAnIycgPyAzIDogMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0YWdfY2hlY2sgPSB0YWdfY29tcGxldGUuc3Vic3RyaW5nKHRhZ19vZmZzZXQsIHRhZ19pbmRleCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmICh0YWdfY29tcGxldGUuY2hhckF0KHRhZ19jb21wbGV0ZS5sZW5ndGggLSAyKSA9PT0gJy8nIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5VdGlscy5pbl9hcnJheSh0YWdfY2hlY2ssIHRoaXMuVXRpbHMuc2luZ2xlX3Rva2VuKSkgeyAvL2lmIHRoaXMgdGFnIG5hbWUgaXMgYSBzaW5nbGUgdGFnIHR5cGUgKGVpdGhlciBpbiB0aGUgbGlzdCBvciBoYXMgYSBjbG9zaW5nIC8pXG4gICAgICAgICAgICAgICAgaWYgKCFwZWVrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFnX3R5cGUgPSAnU0lOR0xFJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluZGVudF9oYW5kbGViYXJzICYmIHRhZ19jb21wbGV0ZS5jaGFyQXQoMCkgPT09ICd7JyAmJiB0YWdfY2hlY2sgPT09ICdlbHNlJykge1xuICAgICAgICAgICAgICAgIGlmICghcGVlaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGVudF90b190YWcoJ2lmJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFnX3R5cGUgPSAnSEFORExFQkFSU19FTFNFJztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRlbnRfY29udGVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhdmVyc2Vfd2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc191bmZvcm1hdHRlZCh0YWdfY2hlY2ssIHVuZm9ybWF0dGVkKSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuaXNfdW5mb3JtYXR0ZWQodGFnX2NoZWNrLCBjb250ZW50X3VuZm9ybWF0dGVkKSkge1xuICAgICAgICAgICAgICAgIC8vIGRvIG5vdCByZWZvcm1hdCB0aGUgXCJ1bmZvcm1hdHRlZFwiIG9yIFwiY29udGVudF91bmZvcm1hdHRlZFwiIHRhZ3NcbiAgICAgICAgICAgICAgICBjb21tZW50ID0gdGhpcy5nZXRfdW5mb3JtYXR0ZWQoJzwvJyArIHRhZ19jaGVjayArICc+JywgdGFnX2NvbXBsZXRlKTsgLy8uLi5kZWxlZ2F0ZSB0byBnZXRfdW5mb3JtYXR0ZWQgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICBjb250ZW50LnB1c2goY29tbWVudCk7XG4gICAgICAgICAgICAgICAgdGFnX2VuZCA9IHRoaXMucG9zIC0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ190eXBlID0gJ1NJTkdMRSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhZ19jaGVjayA9PT0gJ3NjcmlwdCcgJiZcbiAgICAgICAgICAgICAgICAodGFnX2NvbXBsZXRlLnNlYXJjaCgndHlwZScpID09PSAtMSB8fFxuICAgICAgICAgICAgICAgICAgICAodGFnX2NvbXBsZXRlLnNlYXJjaCgndHlwZScpID4gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ19jb21wbGV0ZS5zZWFyY2goL1xcYih0ZXh0fGFwcGxpY2F0aW9ufGRvam8pXFwvKHgtKT8oamF2YXNjcmlwdHxlY21hc2NyaXB0fGpzY3JpcHR8bGl2ZXNjcmlwdHwobGRcXCspP2pzb258bWV0aG9kfGFzcGVjdCkvKSA+IC0xKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXBlZWspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNvcmRfdGFnKHRhZ19jaGVjayk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFnX3R5cGUgPSAnU0NSSVBUJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhZ19jaGVjayA9PT0gJ3N0eWxlJyAmJlxuICAgICAgICAgICAgICAgICh0YWdfY29tcGxldGUuc2VhcmNoKCd0eXBlJykgPT09IC0xIHx8XG4gICAgICAgICAgICAgICAgICAgICh0YWdfY29tcGxldGUuc2VhcmNoKCd0eXBlJykgPiAtMSAmJiB0YWdfY29tcGxldGUuc2VhcmNoKCd0ZXh0L2NzcycpID4gLTEpKSkge1xuICAgICAgICAgICAgICAgIGlmICghcGVlaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlY29yZF90YWcodGFnX2NoZWNrKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YWdfdHlwZSA9ICdTVFlMRSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0YWdfY2hlY2suY2hhckF0KDApID09PSAnIScpIHsgLy9wZWVrIGZvciA8ISBjb21tZW50XG4gICAgICAgICAgICAgICAgLy8gZm9yIGNvbW1lbnRzIGNvbnRlbnQgaXMgYWxyZWFkeSBjb3JyZWN0LlxuICAgICAgICAgICAgICAgIGlmICghcGVlaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhZ190eXBlID0gJ1NJTkdMRSc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhdmVyc2Vfd2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXBlZWspIHtcbiAgICAgICAgICAgICAgICBpZiAodGFnX2NoZWNrLmNoYXJBdCgwKSA9PT0gJy8nKSB7IC8vdGhpcyB0YWcgaXMgYSBkb3VibGUgdGFnIHNvIGNoZWNrIGZvciB0YWctZW5kaW5nXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmV0cmlldmVfdGFnKHRhZ19jaGVjay5zdWJzdHJpbmcoMSkpOyAvL3JlbW92ZSBpdCBhbmQgYWxsIGFuY2VzdG9yc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhZ190eXBlID0gJ0VORCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy9vdGhlcndpc2UgaXQncyBhIHN0YXJ0LXRhZ1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlY29yZF90YWcodGFnX2NoZWNrKTsgLy9wdXNoIGl0IG9uIHRoZSB0YWcgc3RhY2tcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZ19jaGVjay50b0xvd2VyQ2FzZSgpICE9PSAnaHRtbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50X2NvbnRlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFnX3R5cGUgPSAnU1RBUlQnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFsbG93IHByZXNlcnZpbmcgb2YgbmV3bGluZXMgYWZ0ZXIgYSBzdGFydCBvciBlbmQgdGFnXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhdmVyc2Vfd2hpdGVzcGFjZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3BhY2Vfb3Jfd3JhcChjb250ZW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5VdGlscy5pbl9hcnJheSh0YWdfY2hlY2ssIHRoaXMuVXRpbHMuZXh0cmFfbGluZXJzKSkgeyAvL2NoZWNrIGlmIHRoaXMgZG91YmxlIG5lZWRzIGFuIGV4dHJhIGxpbmVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmludF9uZXdsaW5lKGZhbHNlLCB0aGlzLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dC5sZW5ndGggJiYgdGhpcy5vdXRwdXRbdGhpcy5vdXRwdXQubGVuZ3RoIC0gMl0gIT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByaW50X25ld2xpbmUodHJ1ZSwgdGhpcy5vdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGVlaykge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gb3JpZ19wb3M7XG4gICAgICAgICAgICAgICAgdGhpcy5saW5lX2NoYXJfY291bnQgPSBvcmlnX2xpbmVfY2hhcl9jb3VudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQuam9pbignJyk7IC8vcmV0dXJucyBmdWxseSBmb3JtYXR0ZWQgdGFnXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXRfY29tbWVudCA9IGZ1bmN0aW9uKHN0YXJ0X3BvcykgeyAvL2Z1bmN0aW9uIHRvIHJldHVybiBjb21tZW50IGNvbnRlbnQgaW4gaXRzIGVudGlyZXR5XG4gICAgICAgICAgICAvLyB0aGlzIGlzIHdpbGwgaGF2ZSB2ZXJ5IHBvb3IgcGVyZiwgYnV0IHdpbGwgd29yayBmb3Igbm93LlxuICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSAnJyxcbiAgICAgICAgICAgICAgICBkZWxpbWl0ZXIgPSAnPicsXG4gICAgICAgICAgICAgICAgbWF0Y2hlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICB0aGlzLnBvcyA9IHN0YXJ0X3BvcztcbiAgICAgICAgICAgIHZhciBpbnB1dF9jaGFyID0gdGhpcy5pbnB1dC5jaGFyQXQodGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MrKztcblxuICAgICAgICAgICAgd2hpbGUgKHRoaXMucG9zIDw9IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29tbWVudCArPSBpbnB1dF9jaGFyO1xuXG4gICAgICAgICAgICAgICAgLy8gb25seSBuZWVkIHRvIGNoZWNrIGZvciB0aGUgZGVsaW1pdGVyIGlmIHRoZSBsYXN0IGNoYXJzIG1hdGNoXG4gICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQuY2hhckF0KGNvbW1lbnQubGVuZ3RoIC0gMSkgPT09IGRlbGltaXRlci5jaGFyQXQoZGVsaW1pdGVyLmxlbmd0aCAtIDEpICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQuaW5kZXhPZihkZWxpbWl0ZXIpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBvbmx5IG5lZWQgdG8gc2VhcmNoIGZvciBjdXN0b20gZGVsaW1pdGVyIGZvciB0aGUgZmlyc3QgZmV3IGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZWQgJiYgY29tbWVudC5sZW5ndGggPCAxMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWVudC5pbmRleE9mKCc8IVtpZicpID09PSAwKSB7IC8vcGVlayBmb3IgPCFbaWYgY29uZGl0aW9uYWwgY29tbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsaW1pdGVyID0gJzwhW2VuZGlmXT4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tbWVudC5pbmRleE9mKCc8IVtjZGF0YVsnKSA9PT0gMCkgeyAvL2lmIGl0J3MgYSA8W2NkYXRhWyBjb21tZW50Li4uXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxpbWl0ZXIgPSAnXV0+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbW1lbnQuaW5kZXhPZignPCFbJykgPT09IDApIHsgLy8gc29tZSBvdGhlciAhWyBjb21tZW50PyAuLi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGltaXRlciA9ICddPic7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb21tZW50LmluZGV4T2YoJzwhLS0nKSA9PT0gMCkgeyAvLyA8IS0tIGNvbW1lbnQgLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxpbWl0ZXIgPSAnLS0+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbW1lbnQuaW5kZXhPZigne3shLS0nKSA9PT0gMCkgeyAvLyB7eyEtLSBoYW5kbGViYXJzIGNvbW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGltaXRlciA9ICctLX19JztcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbW1lbnQuaW5kZXhPZigne3shJykgPT09IDApIHsgLy8ge3shIGhhbmRsZWJhcnMgY29tbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQubGVuZ3RoID09PSA1ICYmIGNvbW1lbnQuaW5kZXhPZigne3shLS0nKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxpbWl0ZXIgPSAnfX0nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbW1lbnQuaW5kZXhPZignPD8nKSA9PT0gMCkgeyAvLyB7eyEgaGFuZGxlYmFycyBjb21tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxpbWl0ZXIgPSAnPz4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tbWVudC5pbmRleE9mKCc8JScpID09PSAwKSB7IC8vIHt7ISBoYW5kbGViYXJzIGNvbW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGltaXRlciA9ICclPic7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlucHV0X2NoYXIgPSB0aGlzLmlucHV0LmNoYXJBdCh0aGlzLnBvcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNvbW1lbnQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gdG9rZW5NYXRjaGVyKGRlbGltaXRlcikge1xuICAgICAgICAgICAgdmFyIHRva2VuID0gJyc7XG5cbiAgICAgICAgICAgIHZhciBhZGQgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3VG9rZW4gPSB0b2tlbiArIHN0ci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRva2VuID0gbmV3VG9rZW4ubGVuZ3RoIDw9IGRlbGltaXRlci5sZW5ndGggPyBuZXdUb2tlbiA6IG5ld1Rva2VuLnN1YnN0cihuZXdUb2tlbi5sZW5ndGggLSBkZWxpbWl0ZXIubGVuZ3RoLCBkZWxpbWl0ZXIubGVuZ3RoKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBkb2VzTm90TWF0Y2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4uaW5kZXhPZihkZWxpbWl0ZXIpID09PSAtMTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWRkOiBhZGQsXG4gICAgICAgICAgICAgICAgZG9lc05vdE1hdGNoOiBkb2VzTm90TWF0Y2hcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdldF91bmZvcm1hdHRlZCA9IGZ1bmN0aW9uKGRlbGltaXRlciwgb3JpZ190YWcpIHsgLy9mdW5jdGlvbiB0byByZXR1cm4gdW5mb3JtYXR0ZWQgY29udGVudCBpbiBpdHMgZW50aXJldHlcbiAgICAgICAgICAgIGlmIChvcmlnX3RhZyAmJiBvcmlnX3RhZy50b0xvd2VyQ2FzZSgpLmluZGV4T2YoZGVsaW1pdGVyKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW5wdXRfY2hhciA9ICcnO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSAnJztcbiAgICAgICAgICAgIHZhciBzcGFjZSA9IHRydWU7XG5cbiAgICAgICAgICAgIHZhciBkZWxpbWl0ZXJNYXRjaGVyID0gdG9rZW5NYXRjaGVyKGRlbGltaXRlcik7XG5cbiAgICAgICAgICAgIGRvIHtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpbnB1dF9jaGFyID0gdGhpcy5pbnB1dC5jaGFyQXQodGhpcy5wb3MpO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zKys7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5VdGlscy5pbl9hcnJheShpbnB1dF9jaGFyLCB0aGlzLlV0aWxzLndoaXRlc3BhY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGluZV9jaGFyX2NvdW50LS07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRfY2hhciA9PT0gJ1xcbicgfHwgaW5wdXRfY2hhciA9PT0gJ1xccicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiAgRG9uJ3QgY2hhbmdlIHRhYiBpbmRlbnRpb24gZm9yIHVuZm9ybWF0dGVkIGJsb2Nrcy4gIElmIHVzaW5nIGNvZGUgZm9yIGh0bWwgZWRpdGluZywgdGhpcyB3aWxsIGdyZWF0bHkgYWZmZWN0IDxwcmU+IHRhZ3MgaWYgdGhleSBhcmUgc3BlY2lmaWVkIGluIHRoZSAndW5mb3JtYXR0ZWQgYXJyYXknXG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy5pbmRlbnRfbGV2ZWw7IGkrKykge1xuICAgICAgICAgICAgICBjb250ZW50ICs9IHRoaXMuaW5kZW50X3N0cmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNwYWNlID0gZmFsc2U7IC8vLi4uYW5kIG1ha2Ugc3VyZSBvdGhlciBpbmRlbnRhdGlvbiBpcyBlcmFzZWRcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVfY2hhcl9jb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250ZW50ICs9IGlucHV0X2NoYXI7XG4gICAgICAgICAgICAgICAgZGVsaW1pdGVyTWF0Y2hlci5hZGQoaW5wdXRfY2hhcik7XG4gICAgICAgICAgICAgICAgdGhpcy5saW5lX2NoYXJfY291bnQrKztcbiAgICAgICAgICAgICAgICBzcGFjZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZW50X2hhbmRsZWJhcnMgJiYgaW5wdXRfY2hhciA9PT0gJ3snICYmIGNvbnRlbnQubGVuZ3RoICYmIGNvbnRlbnQuY2hhckF0KGNvbnRlbnQubGVuZ3RoIC0gMikgPT09ICd7Jykge1xuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGViYXJzIGV4cHJlc3Npb25zIGluIHN0cmluZ3Mgc2hvdWxkIGFsc28gYmUgdW5mb3JtYXR0ZWQuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gdGhpcy5nZXRfdW5mb3JtYXR0ZWQoJ319Jyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGNvbnNpZGVyIHdoZW4gc3RvcHBpbmcgZm9yIGRlbGltaXRlcnMuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoZGVsaW1pdGVyTWF0Y2hlci5kb2VzTm90TWF0Y2goKSk7XG5cbiAgICAgICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZ2V0X3Rva2VuID0gZnVuY3Rpb24oKSB7IC8vaW5pdGlhbCBoYW5kbGVyIGZvciB0b2tlbi1yZXRyaWV2YWxcbiAgICAgICAgICAgIHZhciB0b2tlbjtcblxuICAgICAgICAgICAgaWYgKHRoaXMubGFzdF90b2tlbiA9PT0gJ1RLX1RBR19TQ1JJUFQnIHx8IHRoaXMubGFzdF90b2tlbiA9PT0gJ1RLX1RBR19TVFlMRScpIHsgLy9jaGVjayBpZiB3ZSBuZWVkIHRvIGZvcm1hdCBqYXZhc2NyaXB0XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLmxhc3RfdG9rZW4uc3Vic3RyKDcpO1xuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5nZXRfY29udGVudHNfdG8odHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW3Rva2VuLCAnVEtfJyArIHR5cGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudF9tb2RlID09PSAnQ09OVEVOVCcpIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMuZ2V0X2NvbnRlbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt0b2tlbiwgJ1RLX0NPTlRFTlQnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRfbW9kZSA9PT0gJ1RBRycpIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMuZ2V0X3RhZygpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW4gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFnX25hbWVfdHlwZSA9ICdUS19UQUdfJyArIHRoaXMudGFnX3R5cGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbdG9rZW4sIHRhZ19uYW1lX3R5cGVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmdldF9mdWxsX2luZGVudCA9IGZ1bmN0aW9uKGxldmVsKSB7XG4gICAgICAgICAgICBsZXZlbCA9IHRoaXMuaW5kZW50X2xldmVsICsgbGV2ZWwgfHwgMDtcbiAgICAgICAgICAgIGlmIChsZXZlbCA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBBcnJheShsZXZlbCArIDEpLmpvaW4odGhpcy5pbmRlbnRfc3RyaW5nKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmlzX3VuZm9ybWF0dGVkID0gZnVuY3Rpb24odGFnX2NoZWNrLCB1bmZvcm1hdHRlZCkge1xuICAgICAgICAgICAgLy9pcyB0aGlzIGFuIEhUTUw1IGJsb2NrLWxldmVsIGxpbms/XG4gICAgICAgICAgICBpZiAoIXRoaXMuVXRpbHMuaW5fYXJyYXkodGFnX2NoZWNrLCB1bmZvcm1hdHRlZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0YWdfY2hlY2sudG9Mb3dlckNhc2UoKSAhPT0gJ2EnIHx8ICF0aGlzLlV0aWxzLmluX2FycmF5KCdhJywgdW5mb3JtYXR0ZWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vYXQgdGhpcyBwb2ludCB3ZSBoYXZlIGFuICB0YWc7IGlzIGl0cyBmaXJzdCBjaGlsZCBzb21ldGhpbmcgd2Ugd2FudCB0byByZW1haW5cbiAgICAgICAgICAgIC8vdW5mb3JtYXR0ZWQ/XG4gICAgICAgICAgICB2YXIgbmV4dF90YWcgPSB0aGlzLmdldF90YWcodHJ1ZSAvKiBwZWVrLiAqLyApO1xuXG4gICAgICAgICAgICAvLyB0ZXN0IG5leHRfdGFnIHRvIHNlZSBpZiBpdCBpcyBqdXN0IGh0bWwgdGFnIChubyBleHRlcm5hbCBjb250ZW50KVxuICAgICAgICAgICAgdmFyIHRhZyA9IChuZXh0X3RhZyB8fCBcIlwiKS5tYXRjaCgvXlxccyo8XFxzKlxcLz8oW2Etel0qKVxccypbXj5dKj5cXHMqJC8pO1xuXG4gICAgICAgICAgICAvLyBpZiBuZXh0X3RhZyBjb21lcyBiYWNrIGJ1dCBpcyBub3QgYW4gaXNvbGF0ZWQgdGFnLCB0aGVuXG4gICAgICAgICAgICAvLyBsZXQncyB0cmVhdCB0aGUgJ2EnIHRhZyBhcyBoYXZpbmcgY29udGVudFxuICAgICAgICAgICAgLy8gYW5kIHJlc3BlY3QgdGhlIHVuZm9ybWF0dGVkIG9wdGlvblxuICAgICAgICAgICAgaWYgKCF0YWcgfHwgdGhpcy5VdGlscy5pbl9hcnJheSh0YWdbMV0sIHVuZm9ybWF0dGVkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5wcmludGVyID0gZnVuY3Rpb24oanNfc291cmNlLCBpbmRlbnRfY2hhcmFjdGVyLCBpbmRlbnRfc2l6ZSwgd3JhcF9saW5lX2xlbmd0aCwgYnJhY2Vfc3R5bGUpIHsgLy9oYW5kbGVzIGlucHV0L291dHB1dCBhbmQgc29tZSBvdGhlciBwcmludGluZyBmdW5jdGlvbnNcblxuICAgICAgICAgICAgdGhpcy5pbnB1dCA9IGpzX3NvdXJjZSB8fCAnJzsgLy9nZXRzIHRoZSBpbnB1dCBmb3IgdGhlIFBhcnNlclxuXG4gICAgICAgICAgICAvLyBIQUNLOiBuZXdsaW5lIHBhcnNpbmcgaW5jb25zaXN0ZW50LiBUaGlzIGJydXRlIGZvcmNlIG5vcm1hbGl6ZXMgdGhlIGlucHV0LlxuICAgICAgICAgICAgdGhpcy5pbnB1dCA9IHRoaXMuaW5wdXQucmVwbGFjZSgvXFxyXFxufFtcXHJcXHUyMDI4XFx1MjAyOV0vZywgJ1xcbicpO1xuXG4gICAgICAgICAgICB0aGlzLm91dHB1dCA9IFtdO1xuICAgICAgICAgICAgdGhpcy5pbmRlbnRfY2hhcmFjdGVyID0gaW5kZW50X2NoYXJhY3RlcjtcbiAgICAgICAgICAgIHRoaXMuaW5kZW50X3N0cmluZyA9ICcnO1xuICAgICAgICAgICAgdGhpcy5pbmRlbnRfc2l6ZSA9IGluZGVudF9zaXplO1xuICAgICAgICAgICAgdGhpcy5icmFjZV9zdHlsZSA9IGJyYWNlX3N0eWxlO1xuICAgICAgICAgICAgdGhpcy5pbmRlbnRfbGV2ZWwgPSAwO1xuICAgICAgICAgICAgdGhpcy53cmFwX2xpbmVfbGVuZ3RoID0gd3JhcF9saW5lX2xlbmd0aDtcbiAgICAgICAgICAgIHRoaXMubGluZV9jaGFyX2NvdW50ID0gMDsgLy9jb3VudCB0byBzZWUgaWYgd3JhcF9saW5lX2xlbmd0aCB3YXMgZXhjZWVkZWRcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluZGVudF9zaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudF9zdHJpbmcgKz0gdGhpcy5pbmRlbnRfY2hhcmFjdGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnByaW50X25ld2xpbmUgPSBmdW5jdGlvbihmb3JjZSwgYXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saW5lX2NoYXJfY291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGlmICghYXJyIHx8ICFhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZvcmNlIHx8IChhcnJbYXJyLmxlbmd0aCAtIDFdICE9PSAnXFxuJykpIHsgLy93ZSBtaWdodCB3YW50IHRoZSBleHRyYSBsaW5lXG4gICAgICAgICAgICAgICAgICAgIGlmICgoYXJyW2Fyci5sZW5ndGggLSAxXSAhPT0gJ1xcbicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJbYXJyLmxlbmd0aCAtIDFdID0gcnRyaW0oYXJyW2Fyci5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2goJ1xcbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMucHJpbnRfaW5kZW50YXRpb24gPSBmdW5jdGlvbihhcnIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5kZW50X2xldmVsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2godGhpcy5pbmRlbnRfc3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lX2NoYXJfY291bnQgKz0gdGhpcy5pbmRlbnRfc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLnByaW50X3Rva2VuID0gZnVuY3Rpb24odGV4dCkge1xuICAgICAgICAgICAgICAgIC8vIEF2b2lkIHByaW50aW5nIGluaXRpYWwgd2hpdGVzcGFjZS5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc193aGl0ZXNwYWNlKHRleHQpICYmICF0aGlzLm91dHB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGV4dCB8fCB0ZXh0ICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vdXRwdXQubGVuZ3RoICYmIHRoaXMub3V0cHV0W3RoaXMub3V0cHV0Lmxlbmd0aCAtIDFdID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmludF9pbmRlbnRhdGlvbih0aGlzLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gbHRyaW0odGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wcmludF90b2tlbl9yYXcodGV4dCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLnByaW50X3Rva2VuX3JhdyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gcHJpbnQgbmV3bGluZXMsIHRydW5jYXRlIHRyYWlsaW5nXG4gICAgICAgICAgICAgICAgLy8gd2hpdGVzcGFjZSwgYXMgdGhlIG5ld2xpbmVzIHdpbGwgcmVwcmVzZW50IHRoZSBzcGFjZS5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uZXdsaW5lcyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHJ0cmltKHRleHQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0ZXh0ICYmIHRleHQgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDEgJiYgdGV4dC5jaGFyQXQodGV4dC5sZW5ndGggLSAxKSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVuZm9ybWF0dGVkIHRhZ3MgY2FuIGdyYWIgbmV3bGluZXMgYXMgdGhlaXIgbGFzdCBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0LnB1c2godGV4dC5zbGljZSgwLCAtMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmludF9uZXdsaW5lKGZhbHNlLCB0aGlzLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dC5wdXNoKHRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCB0aGlzLm5ld2xpbmVzOyBuKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmludF9uZXdsaW5lKG4gPiAwLCB0aGlzLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubmV3bGluZXMgPSAwO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5pbmRlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudF9sZXZlbCsrO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy51bmluZGVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZGVudF9sZXZlbCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRlbnRfbGV2ZWwtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKl9fX19fX19fX19fX19fX19fX19fXy0tLS0tLS0tLS0tLS0tLS0tLS0tX19fX19fX19fX19fX19fX19fX19fKi9cblxuICAgIHRoaXMuYmVhdXRpZnkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbXVsdGlfcGFyc2VyID0gbmV3IFBhcnNlcigpOyAvL3dyYXBwaW5nIGZ1bmN0aW9ucyBQYXJzZXJcbiAgICAgICAgbXVsdGlfcGFyc2VyLnByaW50ZXIoaHRtbF9zb3VyY2UsIGluZGVudF9jaGFyYWN0ZXIsIGluZGVudF9zaXplLCB3cmFwX2xpbmVfbGVuZ3RoLCBicmFjZV9zdHlsZSk7IC8vaW5pdGlhbGl6ZSBzdGFydGluZyB2YWx1ZXNcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHZhciB0ID0gbXVsdGlfcGFyc2VyLmdldF90b2tlbigpO1xuICAgICAgICAgICAgbXVsdGlfcGFyc2VyLnRva2VuX3RleHQgPSB0WzBdO1xuICAgICAgICAgICAgbXVsdGlfcGFyc2VyLnRva2VuX3R5cGUgPSB0WzFdO1xuXG4gICAgICAgICAgICBpZiAobXVsdGlfcGFyc2VyLnRva2VuX3R5cGUgPT09ICdUS19FT0YnKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN3aXRjaCAobXVsdGlfcGFyc2VyLnRva2VuX3R5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdUS19UQUdfU1RBUlQnOlxuICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIucHJpbnRfbmV3bGluZShmYWxzZSwgbXVsdGlfcGFyc2VyLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5wcmludF90b2tlbihtdWx0aV9wYXJzZXIudG9rZW5fdGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aV9wYXJzZXIuaW5kZW50X2NvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgobXVsdGlfcGFyc2VyLmluZGVudF9ib2R5X2lubmVyX2h0bWwgfHwgIW11bHRpX3BhcnNlci50b2tlbl90ZXh0Lm1hdGNoKC88Ym9keSg/Oi4qKT4vKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobXVsdGlfcGFyc2VyLmluZGVudF9oZWFkX2lubmVyX2h0bWwgfHwgIW11bHRpX3BhcnNlci50b2tlbl90ZXh0Lm1hdGNoKC88aGVhZCg/Oi4qKT4vKSkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5pbmRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLmluZGVudF9jb250ZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLmN1cnJlbnRfbW9kZSA9ICdDT05URU5UJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnVEtfVEFHX1NUWUxFJzpcbiAgICAgICAgICAgICAgICBjYXNlICdUS19UQUdfU0NSSVBUJzpcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLnByaW50X25ld2xpbmUoZmFsc2UsIG11bHRpX3BhcnNlci5vdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIucHJpbnRfdG9rZW4obXVsdGlfcGFyc2VyLnRva2VuX3RleHQpO1xuICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIuY3VycmVudF9tb2RlID0gJ0NPTlRFTlQnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdUS19UQUdfRU5EJzpcbiAgICAgICAgICAgICAgICAgICAgLy9QcmludCBuZXcgbGluZSBvbmx5IGlmIHRoZSB0YWcgaGFzIG5vIGNvbnRlbnQgYW5kIGhhcyBjaGlsZFxuICAgICAgICAgICAgICAgICAgICBpZiAobXVsdGlfcGFyc2VyLmxhc3RfdG9rZW4gPT09ICdUS19DT05URU5UJyAmJiBtdWx0aV9wYXJzZXIubGFzdF90ZXh0ID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhZ19uYW1lID0gKG11bHRpX3BhcnNlci50b2tlbl90ZXh0Lm1hdGNoKC9cXHcrLykgfHwgW10pWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhZ19leHRyYWN0ZWRfZnJvbV9sYXN0X291dHB1dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobXVsdGlfcGFyc2VyLm91dHB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdfZXh0cmFjdGVkX2Zyb21fbGFzdF9vdXRwdXQgPSBtdWx0aV9wYXJzZXIub3V0cHV0W211bHRpX3BhcnNlci5vdXRwdXQubGVuZ3RoIC0gMV0ubWF0Y2goLyg/Ojx8e3sjKVxccyooXFx3KykvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YWdfZXh0cmFjdGVkX2Zyb21fbGFzdF9vdXRwdXQgPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGFnX2V4dHJhY3RlZF9mcm9tX2xhc3Rfb3V0cHV0WzFdICE9PSB0YWdfbmFtZSAmJiAhbXVsdGlfcGFyc2VyLlV0aWxzLmluX2FycmF5KHRhZ19leHRyYWN0ZWRfZnJvbV9sYXN0X291dHB1dFsxXSwgdW5mb3JtYXR0ZWQpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5wcmludF9uZXdsaW5lKGZhbHNlLCBtdWx0aV9wYXJzZXIub3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIucHJpbnRfdG9rZW4obXVsdGlfcGFyc2VyLnRva2VuX3RleHQpO1xuICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIuY3VycmVudF9tb2RlID0gJ0NPTlRFTlQnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdUS19UQUdfU0lOR0xFJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgYWRkIGEgbmV3bGluZSBiZWZvcmUgZWxlbWVudHMgdGhhdCBzaG91bGQgcmVtYWluIHVuZm9ybWF0dGVkLlxuICAgICAgICAgICAgICAgICAgICB2YXIgdGFnX2NoZWNrID0gbXVsdGlfcGFyc2VyLnRva2VuX3RleHQubWF0Y2goL15cXHMqPChbYS16LV0rKS9pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0YWdfY2hlY2sgfHwgIW11bHRpX3BhcnNlci5VdGlscy5pbl9hcnJheSh0YWdfY2hlY2tbMV0sIHVuZm9ybWF0dGVkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLnByaW50X25ld2xpbmUoZmFsc2UsIG11bHRpX3BhcnNlci5vdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5wcmludF90b2tlbihtdWx0aV9wYXJzZXIudG9rZW5fdGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5jdXJyZW50X21vZGUgPSAnQ09OVEVOVCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1RLX1RBR19IQU5ETEVCQVJTX0VMU0UnOlxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBhZGQgYSBuZXdsaW5lIGlmIG9wZW5pbmcge3sjaWZ9fSB0YWcgaXMgb24gdGhlIGN1cnJlbnQgbGluZVxuICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmRJZk9uQ3VycmVudExpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbGFzdENoZWNrZWRPdXRwdXQgPSBtdWx0aV9wYXJzZXIub3V0cHV0Lmxlbmd0aCAtIDE7IGxhc3RDaGVja2VkT3V0cHV0ID49IDA7IGxhc3RDaGVja2VkT3V0cHV0LS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aV9wYXJzZXIub3V0cHV0W2xhc3RDaGVja2VkT3V0cHV0XSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG11bHRpX3BhcnNlci5vdXRwdXRbbGFzdENoZWNrZWRPdXRwdXRdLm1hdGNoKC97eyNpZi8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kSWZPbkN1cnJlbnRMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZm91bmRJZk9uQ3VycmVudExpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5wcmludF9uZXdsaW5lKGZhbHNlLCBtdWx0aV9wYXJzZXIub3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIucHJpbnRfdG9rZW4obXVsdGlfcGFyc2VyLnRva2VuX3RleHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobXVsdGlfcGFyc2VyLmluZGVudF9jb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIuaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIuaW5kZW50X2NvbnRlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIuY3VycmVudF9tb2RlID0gJ0NPTlRFTlQnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdUS19UQUdfSEFORExFQkFSU19DT01NRU5UJzpcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLnByaW50X3Rva2VuKG11bHRpX3BhcnNlci50b2tlbl90ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLmN1cnJlbnRfbW9kZSA9ICdUQUcnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdUS19DT05URU5UJzpcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLnByaW50X3Rva2VuKG11bHRpX3BhcnNlci50b2tlbl90ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLmN1cnJlbnRfbW9kZSA9ICdUQUcnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdUS19TVFlMRSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnVEtfU0NSSVBUJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKG11bHRpX3BhcnNlci50b2tlbl90ZXh0ICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLnByaW50X25ld2xpbmUoZmFsc2UsIG11bHRpX3BhcnNlci5vdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRleHQgPSBtdWx0aV9wYXJzZXIudG9rZW5fdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYmVhdXRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHRfaW5kZW50X2xldmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aV9wYXJzZXIudG9rZW5fdHlwZSA9PT0gJ1RLX1NDUklQVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYmVhdXRpZmllciA9IHR5cGVvZiBqc19iZWF1dGlmeSA9PT0gJ2Z1bmN0aW9uJyAmJiBqc19iZWF1dGlmeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobXVsdGlfcGFyc2VyLnRva2VuX3R5cGUgPT09ICdUS19TVFlMRScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYmVhdXRpZmllciA9IHR5cGVvZiBjc3NfYmVhdXRpZnkgPT09ICdmdW5jdGlvbicgJiYgY3NzX2JlYXV0aWZ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5pbmRlbnRfc2NyaXB0cyA9PT0gXCJrZWVwXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHRfaW5kZW50X2xldmVsID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5pbmRlbnRfc2NyaXB0cyA9PT0gXCJzZXBhcmF0ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0X2luZGVudF9sZXZlbCA9IC1tdWx0aV9wYXJzZXIuaW5kZW50X2xldmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZW50YXRpb24gPSBtdWx0aV9wYXJzZXIuZ2V0X2Z1bGxfaW5kZW50KHNjcmlwdF9pbmRlbnRfbGV2ZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9iZWF1dGlmaWVyKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWxsIHRoZSBCZWF1dGlmaWVyIGlmIGF2YWxpYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBDaGlsZF9vcHRpb25zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW9sID0gJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDaGlsZF9vcHRpb25zLnByb3RvdHlwZSA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkX29wdGlvbnMgPSBuZXcgQ2hpbGRfb3B0aW9ucygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSBfYmVhdXRpZmllcih0ZXh0LnJlcGxhY2UoL15cXHMqLywgaW5kZW50YXRpb24pLCBjaGlsZF9vcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2ltcGx5IGluZGVudCB0aGUgc3RyaW5nIG90aGVyd2lzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3aGl0ZSA9IHRleHQubWF0Y2goL15cXHMqLylbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9sZXZlbCA9IHdoaXRlLm1hdGNoKC9bXlxcblxccl0qJC8pWzBdLnNwbGl0KG11bHRpX3BhcnNlci5pbmRlbnRfc3RyaW5nKS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWluZGVudCA9IG11bHRpX3BhcnNlci5nZXRfZnVsbF9pbmRlbnQoc2NyaXB0X2luZGVudF9sZXZlbCAtIF9sZXZlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXlxccyovLCBpbmRlbnRhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcclxcbnxcXHJ8XFxuL2csICdcXG4nICsgcmVpbmRlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHMrJC8sICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLnByaW50X3Rva2VuX3Jhdyh0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIucHJpbnRfbmV3bGluZSh0cnVlLCBtdWx0aV9wYXJzZXIub3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIuY3VycmVudF9tb2RlID0gJ1RBRyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHNob3VsZCBub3QgYmUgZ2V0dGluZyBoZXJlIGJ1dCB3ZSBkb24ndCB3YW50IHRvIGRyb3AgaW5wdXQgb24gdGhlIGZsb29yXG4gICAgICAgICAgICAgICAgICAgIC8vIEp1c3Qgb3V0cHV0IHRoZSB0ZXh0IGFuZCBtb3ZlIG9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aV9wYXJzZXIudG9rZW5fdGV4dCAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5wcmludF90b2tlbihtdWx0aV9wYXJzZXIudG9rZW5fdGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtdWx0aV9wYXJzZXIubGFzdF90b2tlbiA9IG11bHRpX3BhcnNlci50b2tlbl90eXBlO1xuICAgICAgICAgICAgbXVsdGlfcGFyc2VyLmxhc3RfdGV4dCA9IG11bHRpX3BhcnNlci50b2tlbl90ZXh0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBzd2VldF9jb2RlID0gbXVsdGlfcGFyc2VyLm91dHB1dC5qb2luKCcnKS5yZXBsYWNlKC9bXFxyXFxuXFx0IF0rJC8sICcnKTtcblxuICAgICAgICAvLyBlc3RhYmxpc2ggZW5kX3dpdGhfbmV3bGluZVxuICAgICAgICBpZiAoZW5kX3dpdGhfbmV3bGluZSkge1xuICAgICAgICAgICAgc3dlZXRfY29kZSArPSAnXFxuJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlb2wgIT09ICdcXG4nKSB7XG4gICAgICAgICAgICBzd2VldF9jb2RlID0gc3dlZXRfY29kZS5yZXBsYWNlKC9bXFxuXS9nLCBlb2wpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN3ZWV0X2NvZGU7XG4gICAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMuQmVhdXRpZmllciA9IEJlYXV0aWZpZXI7XG5cblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qIGpzaGludCBjdXJseTogZmFsc2UgKi9cbi8vIFRoaXMgc2VjdGlvbiBvZiBjb2RlIGlzIHRha2VuIGZyb20gYWNvcm4uXG4vL1xuLy8gQWNvcm4gd2FzIHdyaXR0ZW4gYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgcmVsZWFzZWQgdW5kZXIgYW4gTUlUXG4vLyBsaWNlbnNlLiBUaGUgVW5pY29kZSByZWdleHBzIChmb3IgaWRlbnRpZmllcnMgYW5kIHdoaXRlc3BhY2UpIHdlcmVcbi8vIHRha2VuIGZyb20gW0VzcHJpbWFdKGh0dHA6Ly9lc3ByaW1hLm9yZykgYnkgQXJpeWEgSGlkYXlhdC5cbi8vXG4vLyBHaXQgcmVwb3NpdG9yaWVzIGZvciBBY29ybiBhcmUgYXZhaWxhYmxlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly9tYXJpam5oYXZlcmJla2UubmwvZ2l0L2Fjb3JuXG4vLyAgICAgaHR0cHM6Ly9naXRodWIuY29tL21hcmlqbmgvYWNvcm4uZ2l0XG5cbi8vICMjIENoYXJhY3RlciBjYXRlZ29yaWVzXG5cbi8vIEJpZyB1Z2x5IHJlZ3VsYXIgZXhwcmVzc2lvbnMgdGhhdCBtYXRjaCBjaGFyYWN0ZXJzIGluIHRoZVxuLy8gd2hpdGVzcGFjZSwgaWRlbnRpZmllciwgYW5kIGlkZW50aWZpZXItc3RhcnQgY2F0ZWdvcmllcy4gVGhlc2Vcbi8vIGFyZSBvbmx5IGFwcGxpZWQgd2hlbiBhIGNoYXJhY3RlciBpcyBmb3VuZCB0byBhY3R1YWxseSBoYXZlIGFcbi8vIGNvZGUgcG9pbnQgYWJvdmUgMTI4LlxuXG52YXIgbm9uQVNDSUl3aGl0ZXNwYWNlID0gL1tcXHUxNjgwXFx1MTgwZVxcdTIwMDAtXFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdWZlZmZdLzsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG52YXIgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IFwiXFx4YWFcXHhiNVxceGJhXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAyYzFcXHUwMmM2LVxcdTAyZDFcXHUwMmUwLVxcdTAyZTRcXHUwMmVjXFx1MDJlZVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3YS1cXHUwMzdkXFx1MDM4NlxcdTAzODgtXFx1MDM4YVxcdTAzOGNcXHUwMzhlLVxcdTAzYTFcXHUwM2EzLVxcdTAzZjVcXHUwM2Y3LVxcdTA0ODFcXHUwNDhhLVxcdTA1MjdcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVkMC1cXHUwNWVhXFx1MDVmMC1cXHUwNWYyXFx1MDYyMC1cXHUwNjRhXFx1MDY2ZVxcdTA2NmZcXHUwNjcxLVxcdTA2ZDNcXHUwNmQ1XFx1MDZlNVxcdTA2ZTZcXHUwNmVlXFx1MDZlZlxcdTA2ZmEtXFx1MDZmY1xcdTA2ZmZcXHUwNzEwXFx1MDcxMi1cXHUwNzJmXFx1MDc0ZC1cXHUwN2E1XFx1MDdiMVxcdTA3Y2EtXFx1MDdlYVxcdTA3ZjRcXHUwN2Y1XFx1MDdmYVxcdTA4MDAtXFx1MDgxNVxcdTA4MWFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4YTBcXHUwOGEyLVxcdTA4YWNcXHUwOTA0LVxcdTA5MzlcXHUwOTNkXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk3N1xcdTA5NzktXFx1MDk3ZlxcdTA5ODUtXFx1MDk4Y1xcdTA5OGZcXHUwOTkwXFx1MDk5My1cXHUwOWE4XFx1MDlhYS1cXHUwOWIwXFx1MDliMlxcdTA5YjYtXFx1MDliOVxcdTA5YmRcXHUwOWNlXFx1MDlkY1xcdTA5ZGRcXHUwOWRmLVxcdTA5ZTFcXHUwOWYwXFx1MDlmMVxcdTBhMDUtXFx1MGEwYVxcdTBhMGZcXHUwYTEwXFx1MGExMy1cXHUwYTI4XFx1MGEyYS1cXHUwYTMwXFx1MGEzMlxcdTBhMzNcXHUwYTM1XFx1MGEzNlxcdTBhMzhcXHUwYTM5XFx1MGE1OS1cXHUwYTVjXFx1MGE1ZVxcdTBhNzItXFx1MGE3NFxcdTBhODUtXFx1MGE4ZFxcdTBhOGYtXFx1MGE5MVxcdTBhOTMtXFx1MGFhOFxcdTBhYWEtXFx1MGFiMFxcdTBhYjJcXHUwYWIzXFx1MGFiNS1cXHUwYWI5XFx1MGFiZFxcdTBhZDBcXHUwYWUwXFx1MGFlMVxcdTBiMDUtXFx1MGIwY1xcdTBiMGZcXHUwYjEwXFx1MGIxMy1cXHUwYjI4XFx1MGIyYS1cXHUwYjMwXFx1MGIzMlxcdTBiMzNcXHUwYjM1LVxcdTBiMzlcXHUwYjNkXFx1MGI1Y1xcdTBiNWRcXHUwYjVmLVxcdTBiNjFcXHUwYjcxXFx1MGI4M1xcdTBiODUtXFx1MGI4YVxcdTBiOGUtXFx1MGI5MFxcdTBiOTItXFx1MGI5NVxcdTBiOTlcXHUwYjlhXFx1MGI5Y1xcdTBiOWVcXHUwYjlmXFx1MGJhM1xcdTBiYTRcXHUwYmE4LVxcdTBiYWFcXHUwYmFlLVxcdTBiYjlcXHUwYmQwXFx1MGMwNS1cXHUwYzBjXFx1MGMwZS1cXHUwYzEwXFx1MGMxMi1cXHUwYzI4XFx1MGMyYS1cXHUwYzMzXFx1MGMzNS1cXHUwYzM5XFx1MGMzZFxcdTBjNThcXHUwYzU5XFx1MGM2MFxcdTBjNjFcXHUwYzg1LVxcdTBjOGNcXHUwYzhlLVxcdTBjOTBcXHUwYzkyLVxcdTBjYThcXHUwY2FhLVxcdTBjYjNcXHUwY2I1LVxcdTBjYjlcXHUwY2JkXFx1MGNkZVxcdTBjZTBcXHUwY2UxXFx1MGNmMVxcdTBjZjJcXHUwZDA1LVxcdTBkMGNcXHUwZDBlLVxcdTBkMTBcXHUwZDEyLVxcdTBkM2FcXHUwZDNkXFx1MGQ0ZVxcdTBkNjBcXHUwZDYxXFx1MGQ3YS1cXHUwZDdmXFx1MGQ4NS1cXHUwZDk2XFx1MGQ5YS1cXHUwZGIxXFx1MGRiMy1cXHUwZGJiXFx1MGRiZFxcdTBkYzAtXFx1MGRjNlxcdTBlMDEtXFx1MGUzMFxcdTBlMzJcXHUwZTMzXFx1MGU0MC1cXHUwZTQ2XFx1MGU4MVxcdTBlODJcXHUwZTg0XFx1MGU4N1xcdTBlODhcXHUwZThhXFx1MGU4ZFxcdTBlOTQtXFx1MGU5N1xcdTBlOTktXFx1MGU5ZlxcdTBlYTEtXFx1MGVhM1xcdTBlYTVcXHUwZWE3XFx1MGVhYVxcdTBlYWJcXHUwZWFkLVxcdTBlYjBcXHUwZWIyXFx1MGViM1xcdTBlYmRcXHUwZWMwLVxcdTBlYzRcXHUwZWM2XFx1MGVkYy1cXHUwZWRmXFx1MGYwMFxcdTBmNDAtXFx1MGY0N1xcdTBmNDktXFx1MGY2Y1xcdTBmODgtXFx1MGY4Y1xcdTEwMDAtXFx1MTAyYVxcdTEwM2ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVhLVxcdTEwNWRcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZlLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhlXFx1MTBhMC1cXHUxMGM1XFx1MTBjN1xcdTEwY2RcXHUxMGQwLVxcdTEwZmFcXHUxMGZjLVxcdTEyNDhcXHUxMjRhLVxcdTEyNGRcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1YS1cXHUxMjVkXFx1MTI2MC1cXHUxMjg4XFx1MTI4YS1cXHUxMjhkXFx1MTI5MC1cXHUxMmIwXFx1MTJiMi1cXHUxMmI1XFx1MTJiOC1cXHUxMmJlXFx1MTJjMFxcdTEyYzItXFx1MTJjNVxcdTEyYzgtXFx1MTJkNlxcdTEyZDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1YVxcdTEzODAtXFx1MTM4ZlxcdTEzYTAtXFx1MTNmNFxcdTE0MDEtXFx1MTY2Y1xcdTE2NmYtXFx1MTY3ZlxcdTE2ODEtXFx1MTY5YVxcdTE2YTAtXFx1MTZlYVxcdTE2ZWUtXFx1MTZmMFxcdTE3MDAtXFx1MTcwY1xcdTE3MGUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Y1xcdTE3NmUtXFx1MTc3MFxcdTE3ODAtXFx1MTdiM1xcdTE3ZDdcXHUxN2RjXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOGE4XFx1MThhYVxcdTE4YjAtXFx1MThmNVxcdTE5MDAtXFx1MTkxY1xcdTE5NTAtXFx1MTk2ZFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlhYlxcdTE5YzEtXFx1MTljN1xcdTFhMDAtXFx1MWExNlxcdTFhMjAtXFx1MWE1NFxcdTFhYTdcXHUxYjA1LVxcdTFiMzNcXHUxYjQ1LVxcdTFiNGJcXHUxYjgzLVxcdTFiYTBcXHUxYmFlXFx1MWJhZlxcdTFiYmEtXFx1MWJlNVxcdTFjMDAtXFx1MWMyM1xcdTFjNGQtXFx1MWM0ZlxcdTFjNWEtXFx1MWM3ZFxcdTFjZTktXFx1MWNlY1xcdTFjZWUtXFx1MWNmMVxcdTFjZjVcXHUxY2Y2XFx1MWQwMC1cXHUxZGJmXFx1MWUwMC1cXHUxZjE1XFx1MWYxOC1cXHUxZjFkXFx1MWYyMC1cXHUxZjQ1XFx1MWY0OC1cXHUxZjRkXFx1MWY1MC1cXHUxZjU3XFx1MWY1OVxcdTFmNWJcXHUxZjVkXFx1MWY1Zi1cXHUxZjdkXFx1MWY4MC1cXHUxZmI0XFx1MWZiNi1cXHUxZmJjXFx1MWZiZVxcdTFmYzItXFx1MWZjNFxcdTFmYzYtXFx1MWZjY1xcdTFmZDAtXFx1MWZkM1xcdTFmZDYtXFx1MWZkYlxcdTFmZTAtXFx1MWZlY1xcdTFmZjItXFx1MWZmNFxcdTFmZjYtXFx1MWZmY1xcdTIwNzFcXHUyMDdmXFx1MjA5MC1cXHUyMDljXFx1MjEwMlxcdTIxMDdcXHUyMTBhLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFkXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyYS1cXHUyMTJkXFx1MjEyZi1cXHUyMTM5XFx1MjEzYy1cXHUyMTNmXFx1MjE0NS1cXHUyMTQ5XFx1MjE0ZVxcdTIxNjAtXFx1MjE4OFxcdTJjMDAtXFx1MmMyZVxcdTJjMzAtXFx1MmM1ZVxcdTJjNjAtXFx1MmNlNFxcdTJjZWItXFx1MmNlZVxcdTJjZjJcXHUyY2YzXFx1MmQwMC1cXHUyZDI1XFx1MmQyN1xcdTJkMmRcXHUyZDMwLVxcdTJkNjdcXHUyZDZmXFx1MmQ4MC1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MmUyZlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzY1xcdTMwNDEtXFx1MzA5NlxcdTMwOWQtXFx1MzA5ZlxcdTMwYTEtXFx1MzBmYVxcdTMwZmMtXFx1MzBmZlxcdTMxMDUtXFx1MzEyZFxcdTMxMzEtXFx1MzE4ZVxcdTMxYTAtXFx1MzFiYVxcdTMxZjAtXFx1MzFmZlxcdTM0MDAtXFx1NGRiNVxcdTRlMDAtXFx1OWZjY1xcdWEwMDAtXFx1YTQ4Y1xcdWE0ZDAtXFx1YTRmZFxcdWE1MDAtXFx1YTYwY1xcdWE2MTAtXFx1YTYxZlxcdWE2MmFcXHVhNjJiXFx1YTY0MC1cXHVhNjZlXFx1YTY3Zi1cXHVhNjk3XFx1YTZhMC1cXHVhNmVmXFx1YTcxNy1cXHVhNzFmXFx1YTcyMi1cXHVhNzg4XFx1YTc4Yi1cXHVhNzhlXFx1YTc5MC1cXHVhNzkzXFx1YTdhMC1cXHVhN2FhXFx1YTdmOC1cXHVhODAxXFx1YTgwMy1cXHVhODA1XFx1YTgwNy1cXHVhODBhXFx1YTgwYy1cXHVhODIyXFx1YTg0MC1cXHVhODczXFx1YTg4Mi1cXHVhOGIzXFx1YThmMi1cXHVhOGY3XFx1YThmYlxcdWE5MGEtXFx1YTkyNVxcdWE5MzAtXFx1YTk0NlxcdWE5NjAtXFx1YTk3Y1xcdWE5ODQtXFx1YTliMlxcdWE5Y2ZcXHVhYTAwLVxcdWFhMjhcXHVhYTQwLVxcdWFhNDJcXHVhYTQ0LVxcdWFhNGJcXHVhYTYwLVxcdWFhNzZcXHVhYTdhXFx1YWE4MC1cXHVhYWFmXFx1YWFiMVxcdWFhYjVcXHVhYWI2XFx1YWFiOS1cXHVhYWJkXFx1YWFjMFxcdWFhYzJcXHVhYWRiLVxcdWFhZGRcXHVhYWUwLVxcdWFhZWFcXHVhYWYyLVxcdWFhZjRcXHVhYjAxLVxcdWFiMDZcXHVhYjA5LVxcdWFiMGVcXHVhYjExLVxcdWFiMTZcXHVhYjIwLVxcdWFiMjZcXHVhYjI4LVxcdWFiMmVcXHVhYmMwLVxcdWFiZTJcXHVhYzAwLVxcdWQ3YTNcXHVkN2IwLVxcdWQ3YzZcXHVkN2NiLVxcdWQ3ZmJcXHVmOTAwLVxcdWZhNmRcXHVmYTcwLVxcdWZhZDlcXHVmYjAwLVxcdWZiMDZcXHVmYjEzLVxcdWZiMTdcXHVmYjFkXFx1ZmIxZi1cXHVmYjI4XFx1ZmIyYS1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDBcXHVmYjQxXFx1ZmI0M1xcdWZiNDRcXHVmYjQ2LVxcdWZiYjFcXHVmYmQzLVxcdWZkM2RcXHVmZDUwLVxcdWZkOGZcXHVmZDkyLVxcdWZkYzdcXHVmZGYwLVxcdWZkZmJcXHVmZTcwLVxcdWZlNzRcXHVmZTc2LVxcdWZlZmNcXHVmZjIxLVxcdWZmM2FcXHVmZjQxLVxcdWZmNWFcXHVmZjY2LVxcdWZmYmVcXHVmZmMyLVxcdWZmYzdcXHVmZmNhLVxcdWZmY2ZcXHVmZmQyLVxcdWZmZDdcXHVmZmRhLVxcdWZmZGNcIjtcbnZhciBub25BU0NJSWlkZW50aWZpZXJDaGFycyA9IFwiXFx1MDMwMC1cXHUwMzZmXFx1MDQ4My1cXHUwNDg3XFx1MDU5MS1cXHUwNWJkXFx1MDViZlxcdTA1YzFcXHUwNWMyXFx1MDVjNFxcdTA1YzVcXHUwNWM3XFx1MDYxMC1cXHUwNjFhXFx1MDYyMC1cXHUwNjQ5XFx1MDY3Mi1cXHUwNmQzXFx1MDZlNy1cXHUwNmU4XFx1MDZmYi1cXHUwNmZjXFx1MDczMC1cXHUwNzRhXFx1MDgwMC1cXHUwODE0XFx1MDgxYi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJkXFx1MDg0MC1cXHUwODU3XFx1MDhlNC1cXHUwOGZlXFx1MDkwMC1cXHUwOTAzXFx1MDkzYS1cXHUwOTNjXFx1MDkzZS1cXHUwOTRmXFx1MDk1MS1cXHUwOTU3XFx1MDk2Mi1cXHUwOTYzXFx1MDk2Ni1cXHUwOTZmXFx1MDk4MS1cXHUwOTgzXFx1MDliY1xcdTA5YmUtXFx1MDljNFxcdTA5YzdcXHUwOWM4XFx1MDlkN1xcdTA5ZGYtXFx1MDllMFxcdTBhMDEtXFx1MGEwM1xcdTBhM2NcXHUwYTNlLVxcdTBhNDJcXHUwYTQ3XFx1MGE0OFxcdTBhNGItXFx1MGE0ZFxcdTBhNTFcXHUwYTY2LVxcdTBhNzFcXHUwYTc1XFx1MGE4MS1cXHUwYTgzXFx1MGFiY1xcdTBhYmUtXFx1MGFjNVxcdTBhYzctXFx1MGFjOVxcdTBhY2ItXFx1MGFjZFxcdTBhZTItXFx1MGFlM1xcdTBhZTYtXFx1MGFlZlxcdTBiMDEtXFx1MGIwM1xcdTBiM2NcXHUwYjNlLVxcdTBiNDRcXHUwYjQ3XFx1MGI0OFxcdTBiNGItXFx1MGI0ZFxcdTBiNTZcXHUwYjU3XFx1MGI1Zi1cXHUwYjYwXFx1MGI2Ni1cXHUwYjZmXFx1MGI4MlxcdTBiYmUtXFx1MGJjMlxcdTBiYzYtXFx1MGJjOFxcdTBiY2EtXFx1MGJjZFxcdTBiZDdcXHUwYmU2LVxcdTBiZWZcXHUwYzAxLVxcdTBjMDNcXHUwYzQ2LVxcdTBjNDhcXHUwYzRhLVxcdTBjNGRcXHUwYzU1XFx1MGM1NlxcdTBjNjItXFx1MGM2M1xcdTBjNjYtXFx1MGM2ZlxcdTBjODJcXHUwYzgzXFx1MGNiY1xcdTBjYmUtXFx1MGNjNFxcdTBjYzYtXFx1MGNjOFxcdTBjY2EtXFx1MGNjZFxcdTBjZDVcXHUwY2Q2XFx1MGNlMi1cXHUwY2UzXFx1MGNlNi1cXHUwY2VmXFx1MGQwMlxcdTBkMDNcXHUwZDQ2LVxcdTBkNDhcXHUwZDU3XFx1MGQ2Mi1cXHUwZDYzXFx1MGQ2Ni1cXHUwZDZmXFx1MGQ4MlxcdTBkODNcXHUwZGNhXFx1MGRjZi1cXHUwZGQ0XFx1MGRkNlxcdTBkZDgtXFx1MGRkZlxcdTBkZjJcXHUwZGYzXFx1MGUzNC1cXHUwZTNhXFx1MGU0MC1cXHUwZTQ1XFx1MGU1MC1cXHUwZTU5XFx1MGViNC1cXHUwZWI5XFx1MGVjOC1cXHUwZWNkXFx1MGVkMC1cXHUwZWQ5XFx1MGYxOFxcdTBmMTlcXHUwZjIwLVxcdTBmMjlcXHUwZjM1XFx1MGYzN1xcdTBmMzlcXHUwZjQxLVxcdTBmNDdcXHUwZjcxLVxcdTBmODRcXHUwZjg2LVxcdTBmODdcXHUwZjhkLVxcdTBmOTdcXHUwZjk5LVxcdTBmYmNcXHUwZmM2XFx1MTAwMC1cXHUxMDI5XFx1MTA0MC1cXHUxMDQ5XFx1MTA2Ny1cXHUxMDZkXFx1MTA3MS1cXHUxMDc0XFx1MTA4Mi1cXHUxMDhkXFx1MTA4Zi1cXHUxMDlkXFx1MTM1ZC1cXHUxMzVmXFx1MTcwZS1cXHUxNzEwXFx1MTcyMC1cXHUxNzMwXFx1MTc0MC1cXHUxNzUwXFx1MTc3MlxcdTE3NzNcXHUxNzgwLVxcdTE3YjJcXHUxN2RkXFx1MTdlMC1cXHUxN2U5XFx1MTgwYi1cXHUxODBkXFx1MTgxMC1cXHUxODE5XFx1MTkyMC1cXHUxOTJiXFx1MTkzMC1cXHUxOTNiXFx1MTk1MS1cXHUxOTZkXFx1MTliMC1cXHUxOWMwXFx1MTljOC1cXHUxOWM5XFx1MTlkMC1cXHUxOWQ5XFx1MWEwMC1cXHUxYTE1XFx1MWEyMC1cXHUxYTUzXFx1MWE2MC1cXHUxYTdjXFx1MWE3Zi1cXHUxYTg5XFx1MWE5MC1cXHUxYTk5XFx1MWI0Ni1cXHUxYjRiXFx1MWI1MC1cXHUxYjU5XFx1MWI2Yi1cXHUxYjczXFx1MWJiMC1cXHUxYmI5XFx1MWJlNi1cXHUxYmYzXFx1MWMwMC1cXHUxYzIyXFx1MWM0MC1cXHUxYzQ5XFx1MWM1Yi1cXHUxYzdkXFx1MWNkMC1cXHUxY2QyXFx1MWQwMC1cXHUxZGJlXFx1MWUwMS1cXHUxZjE1XFx1MjAwY1xcdTIwMGRcXHUyMDNmXFx1MjA0MFxcdTIwNTRcXHUyMGQwLVxcdTIwZGNcXHUyMGUxXFx1MjBlNS1cXHUyMGYwXFx1MmQ4MS1cXHUyZDk2XFx1MmRlMC1cXHUyZGZmXFx1MzAyMS1cXHUzMDI4XFx1MzA5OVxcdTMwOWFcXHVhNjQwLVxcdWE2NmRcXHVhNjc0LVxcdWE2N2RcXHVhNjlmXFx1YTZmMC1cXHVhNmYxXFx1YTdmOC1cXHVhODAwXFx1YTgwNlxcdWE4MGJcXHVhODIzLVxcdWE4MjdcXHVhODgwLVxcdWE4ODFcXHVhOGI0LVxcdWE4YzRcXHVhOGQwLVxcdWE4ZDlcXHVhOGYzLVxcdWE4ZjdcXHVhOTAwLVxcdWE5MDlcXHVhOTI2LVxcdWE5MmRcXHVhOTMwLVxcdWE5NDVcXHVhOTgwLVxcdWE5ODNcXHVhOWIzLVxcdWE5YzBcXHVhYTAwLVxcdWFhMjdcXHVhYTQwLVxcdWFhNDFcXHVhYTRjLVxcdWFhNGRcXHVhYTUwLVxcdWFhNTlcXHVhYTdiXFx1YWFlMC1cXHVhYWU5XFx1YWFmMi1cXHVhYWYzXFx1YWJjMC1cXHVhYmUxXFx1YWJlY1xcdWFiZWRcXHVhYmYwLVxcdWFiZjlcXHVmYjIwLVxcdWZiMjhcXHVmZTAwLVxcdWZlMGZcXHVmZTIwLVxcdWZlMjZcXHVmZTMzXFx1ZmUzNFxcdWZlNGQtXFx1ZmU0ZlxcdWZmMTAtXFx1ZmYxOVxcdWZmM2ZcIjtcbnZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydCA9IG5ldyBSZWdFeHAoXCJbXCIgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgXCJdXCIpO1xudmFyIG5vbkFTQ0lJaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoXCJbXCIgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgKyBcIl1cIik7XG5cbi8vIFdoZXRoZXIgYSBzaW5nbGUgY2hhcmFjdGVyIGRlbm90ZXMgYSBuZXdsaW5lLlxuXG5leHBvcnRzLm5ld2xpbmUgPSAvW1xcblxcclxcdTIwMjhcXHUyMDI5XS87XG5cbi8vIE1hdGNoZXMgYSB3aG9sZSBsaW5lIGJyZWFrICh3aGVyZSBDUkxGIGlzIGNvbnNpZGVyZWQgYSBzaW5nbGVcbi8vIGxpbmUgYnJlYWspLiBVc2VkIHRvIGNvdW50IGxpbmVzLlxuXG4vLyBpbiBqYXZhc2NyaXB0LCB0aGVzZSB0d28gZGlmZmVyXG4vLyBpbiBweXRob24gdGhleSBhcmUgdGhlIHNhbWUsIGRpZmZlcmVudCBtZXRob2RzIGFyZSBjYWxsZWQgb24gdGhlbVxuZXhwb3J0cy5saW5lQnJlYWsgPSBuZXcgUmVnRXhwKCdcXHJcXG58JyArIGV4cG9ydHMubmV3bGluZS5zb3VyY2UpO1xuZXhwb3J0cy5hbGxMaW5lQnJlYWtzID0gbmV3IFJlZ0V4cChleHBvcnRzLmxpbmVCcmVhay5zb3VyY2UsICdnJyk7XG5cblxuLy8gVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gY2hhcmFjdGVyIGNvZGUgc3RhcnRzIGFuIGlkZW50aWZpZXIuXG5cbmV4cG9ydHMuaXNJZGVudGlmaWVyU3RhcnQgPSBmdW5jdGlvbihjb2RlKSB7XG4gICAgLy8gcGVybWl0ICQgKDM2KSBhbmQgQCAoNjQpLiBAIGlzIHVzZWQgaW4gRVM3IGRlY29yYXRvcnMuXG4gICAgaWYgKGNvZGUgPCA2NSkgcmV0dXJuIGNvZGUgPT09IDM2IHx8IGNvZGUgPT09IDY0O1xuICAgIC8vIDY1IHRocm91Z2ggOTEgYXJlIHVwcGVyY2FzZSBsZXR0ZXJzLlxuICAgIGlmIChjb2RlIDwgOTEpIHJldHVybiB0cnVlO1xuICAgIC8vIHBlcm1pdCBfICg5NSkuXG4gICAgaWYgKGNvZGUgPCA5NykgcmV0dXJuIGNvZGUgPT09IDk1O1xuICAgIC8vIDk3IHRocm91Z2ggMTIzIGFyZSBsb3dlcmNhc2UgbGV0dGVycy5cbiAgICBpZiAoY29kZSA8IDEyMykgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXJTdGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpO1xufTtcblxuLy8gVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gY2hhcmFjdGVyIGlzIHBhcnQgb2YgYW4gaWRlbnRpZmllci5cblxuZXhwb3J0cy5pc0lkZW50aWZpZXJDaGFyID0gZnVuY3Rpb24oY29kZSkge1xuICAgIGlmIChjb2RlIDwgNDgpIHJldHVybiBjb2RlID09PSAzNjtcbiAgICBpZiAoY29kZSA8IDU4KSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoY29kZSA8IDY1KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGNvZGUgPCA5MSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGNvZGUgPCA5NykgcmV0dXJuIGNvZGUgPT09IDk1O1xuICAgIGlmIChjb2RlIDwgMTIzKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gY29kZSA+PSAweGFhICYmIG5vbkFTQ0lJaWRlbnRpZmllci50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLypqc2hpbnQgY3VybHk6dHJ1ZSwgZXFlcWVxOnRydWUsIGxheGJyZWFrOnRydWUsIG5vZW1wdHk6ZmFsc2UgKi9cbi8qXG5cbiAgICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICAgIENvcHlyaWdodCAoYykgMjAwNy0yMDE3IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICAgIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICAgIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gICAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICAgIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gICAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gICAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gICAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgU09GVFdBUkUuXG4qL1xuXG5mdW5jdGlvbiBtZXJnZU9wdHMoYWxsT3B0aW9ucywgdGFyZ2V0VHlwZSkge1xuICAgIHZhciBmaW5hbE9wdHMgPSB7fTtcbiAgICB2YXIgbmFtZTtcblxuICAgIGZvciAobmFtZSBpbiBhbGxPcHRpb25zKSB7XG4gICAgICAgIGlmIChuYW1lICE9PSB0YXJnZXRUeXBlKSB7XG4gICAgICAgICAgICBmaW5hbE9wdHNbbmFtZV0gPSBhbGxPcHRpb25zW25hbWVdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9tZXJnZSBpbiB0aGUgcGVyIHR5cGUgc2V0dGluZ3MgZm9yIHRoZSB0YXJnZXRUeXBlXG4gICAgaWYgKHRhcmdldFR5cGUgaW4gYWxsT3B0aW9ucykge1xuICAgICAgICBmb3IgKG5hbWUgaW4gYWxsT3B0aW9uc1t0YXJnZXRUeXBlXSkge1xuICAgICAgICAgICAgZmluYWxPcHRzW25hbWVdID0gYWxsT3B0aW9uc1t0YXJnZXRUeXBlXVtuYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmluYWxPcHRzO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5tZXJnZU9wdHMgPSBtZXJnZU9wdHM7XG5cblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qanNoaW50IGN1cmx5OnRydWUsIGVxZXFlcTp0cnVlLCBsYXhicmVhazp0cnVlLCBub2VtcHR5OmZhbHNlICovXG4vKlxuXG4gICAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxNyBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAgICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICAgIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gICAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gICAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICAgIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gICAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICAgIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICAgIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gICAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgIFNPRlRXQVJFLlxuKi9cblxudmFyIEJlYXV0aWZpZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLkJlYXV0aWZpZXI7XG5cbmZ1bmN0aW9uIHN0eWxlX2h0bWwoaHRtbF9zb3VyY2UsIG9wdGlvbnMsIGpzX2JlYXV0aWZ5LCBjc3NfYmVhdXRpZnkpIHtcbiAgICB2YXIgYmVhdXRpZmllciA9IG5ldyBCZWF1dGlmaWVyKGh0bWxfc291cmNlLCBvcHRpb25zLCBqc19iZWF1dGlmeSwgY3NzX2JlYXV0aWZ5KTtcbiAgICByZXR1cm4gYmVhdXRpZmllci5iZWF1dGlmeSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0eWxlX2h0bWw7XG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbnZhciBzdHlsZV9odG1sID0gbGVnYWN5X2JlYXV0aWZ5X2h0bWw7XG4vKiBGb290ZXIgKi9cbmlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEFkZCBzdXBwb3J0IGZvciBBTUQgKCBodHRwczovL2dpdGh1Yi5jb20vYW1kanMvYW1kanMtYXBpL3dpa2kvQU1EI2RlZmluZWFtZC1wcm9wZXJ0eS0gKVxuICAgIGRlZmluZShbXCJyZXF1aXJlXCIsIFwiLi9iZWF1dGlmeVwiLCBcIi4vYmVhdXRpZnktY3NzXCJdLCBmdW5jdGlvbihyZXF1aXJlYW1kKSB7XG4gICAgICAgIHZhciBqc19iZWF1dGlmeSA9IHJlcXVpcmVhbWQoXCIuL2JlYXV0aWZ5XCIpO1xuICAgICAgICB2YXIgY3NzX2JlYXV0aWZ5ID0gcmVxdWlyZWFtZChcIi4vYmVhdXRpZnktY3NzXCIpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBodG1sX2JlYXV0aWZ5OiBmdW5jdGlvbihodG1sX3NvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHlsZV9odG1sKGh0bWxfc291cmNlLCBvcHRpb25zLCBqc19iZWF1dGlmeS5qc19iZWF1dGlmeSwgY3NzX2JlYXV0aWZ5LmNzc19iZWF1dGlmeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG59IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gQWRkIHN1cHBvcnQgZm9yIENvbW1vbkpTLiBKdXN0IHB1dCB0aGlzIGZpbGUgc29tZXdoZXJlIG9uIHlvdXIgcmVxdWlyZS5wYXRoc1xuICAgIC8vIGFuZCB5b3Ugd2lsbCBiZSBhYmxlIHRvIGB2YXIgaHRtbF9iZWF1dGlmeSA9IHJlcXVpcmUoXCJiZWF1dGlmeVwiKS5odG1sX2JlYXV0aWZ5YC5cbiAgICB2YXIganNfYmVhdXRpZnkgPSByZXF1aXJlKCcuL2JlYXV0aWZ5LmpzJyk7XG4gICAgdmFyIGNzc19iZWF1dGlmeSA9IHJlcXVpcmUoJy4vYmVhdXRpZnktY3NzLmpzJyk7XG5cbiAgICBleHBvcnRzLmh0bWxfYmVhdXRpZnkgPSBmdW5jdGlvbihodG1sX3NvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gc3R5bGVfaHRtbChodG1sX3NvdXJjZSwgb3B0aW9ucywganNfYmVhdXRpZnkuanNfYmVhdXRpZnksIGNzc19iZWF1dGlmeS5jc3NfYmVhdXRpZnkpO1xuICAgIH07XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBJZiB3ZSdyZSBydW5uaW5nIGEgd2ViIHBhZ2UgYW5kIGRvbid0IGhhdmUgZWl0aGVyIG9mIHRoZSBhYm92ZSwgYWRkIG91ciBvbmUgZ2xvYmFsXG4gICAgd2luZG93Lmh0bWxfYmVhdXRpZnkgPSBmdW5jdGlvbihodG1sX3NvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gc3R5bGVfaHRtbChodG1sX3NvdXJjZSwgb3B0aW9ucywgd2luZG93LmpzX2JlYXV0aWZ5LCB3aW5kb3cuY3NzX2JlYXV0aWZ5KTtcbiAgICB9O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gSWYgd2UgZG9uJ3QgZXZlbiBoYXZlIHdpbmRvdywgdHJ5IGdsb2JhbC5cbiAgICBnbG9iYWwuaHRtbF9iZWF1dGlmeSA9IGZ1bmN0aW9uKGh0bWxfc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBzdHlsZV9odG1sKGh0bWxfc291cmNlLCBvcHRpb25zLCBnbG9iYWwuanNfYmVhdXRpZnksIGdsb2JhbC5jc3NfYmVhdXRpZnkpO1xuICAgIH07XG59XG5cbn0oKSk7XG4iLCIvKmpzaGludCBjdXJseTpmYWxzZSwgZXFlcWVxOnRydWUsIGxheGJyZWFrOnRydWUsIG5vZW1wdHk6ZmFsc2UgKi9cbi8qIEFVVE8tR0VORVJBVEVELiBETyBOT1QgTU9ESUZZLiAqL1xuLyogc2VlIGpzL3NyYy9qYXZhc2NyaXB0L2luZGV4LmpzICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE3IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cblxuIEpTIEJlYXV0aWZpZXJcbi0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgV3JpdHRlbiBieSBFaW5hciBMaWVsbWFuaXMsIDxlaW5hckBqc2JlYXV0aWZpZXIub3JnPlxuICAgICAgaHR0cDovL2pzYmVhdXRpZmllci5vcmcvXG5cbiAgT3JpZ2luYWxseSBjb252ZXJ0ZWQgdG8gamF2YXNjcmlwdCBieSBWaXRhbCwgPHZpdGFsNzZAZ21haWwuY29tPlxuICBcIkVuZCBicmFjZXMgb24gb3duIGxpbmVcIiBhZGRlZCBieSBDaHJpcyBKLiBTaHVsbCwgPGNocmlzanNodWxsQGdtYWlsLmNvbT5cbiAgUGFyc2luZyBpbXByb3ZlbWVudHMgZm9yIGJyYWNlLWxlc3Mgc3RhdGVtZW50cyBieSBMaWFtIE5ld21hbiA8Yml0d2lzZW1hbkBnbWFpbC5jb20+XG5cblxuICBVc2FnZTpcbiAgICBqc19iZWF1dGlmeShqc19zb3VyY2VfdGV4dCk7XG4gICAganNfYmVhdXRpZnkoanNfc291cmNlX3RleHQsIG9wdGlvbnMpO1xuXG4gIFRoZSBvcHRpb25zIGFyZTpcbiAgICBpbmRlbnRfc2l6ZSAoZGVmYXVsdCA0KSAgICAgICAgICAtIGluZGVudGF0aW9uIHNpemUsXG4gICAgaW5kZW50X2NoYXIgKGRlZmF1bHQgc3BhY2UpICAgICAgLSBjaGFyYWN0ZXIgdG8gaW5kZW50IHdpdGgsXG4gICAgcHJlc2VydmVfbmV3bGluZXMgKGRlZmF1bHQgdHJ1ZSkgLSB3aGV0aGVyIGV4aXN0aW5nIGxpbmUgYnJlYWtzIHNob3VsZCBiZSBwcmVzZXJ2ZWQsXG4gICAgbWF4X3ByZXNlcnZlX25ld2xpbmVzIChkZWZhdWx0IHVubGltaXRlZCkgLSBtYXhpbXVtIG51bWJlciBvZiBsaW5lIGJyZWFrcyB0byBiZSBwcmVzZXJ2ZWQgaW4gb25lIGNodW5rLFxuXG4gICAganNsaW50X2hhcHB5IChkZWZhdWx0IGZhbHNlKSAtIGlmIHRydWUsIHRoZW4ganNsaW50LXN0cmljdGVyIG1vZGUgaXMgZW5mb3JjZWQuXG5cbiAgICAgICAgICAgIGpzbGludF9oYXBweSAgICAgICAgIWpzbGludF9oYXBweVxuICAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSAgICAgICAgIGZ1bmN0aW9uKClcblxuICAgICAgICAgICAgc3dpdGNoICgpIHsgICAgICAgICBzd2l0Y2goKSB7XG4gICAgICAgICAgICBjYXNlIDE6ICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBicmVhazsgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgIH1cblxuICAgIHNwYWNlX2FmdGVyX2Fub25fZnVuY3Rpb24gKGRlZmF1bHQgZmFsc2UpIC0gc2hvdWxkIHRoZSBzcGFjZSBiZWZvcmUgYW4gYW5vbnltb3VzIGZ1bmN0aW9uJ3MgcGFyZW5zIGJlIGFkZGVkLCBcImZ1bmN0aW9uKClcIiB2cyBcImZ1bmN0aW9uICgpXCIsXG4gICAgICAgICAgTk9URTogVGhpcyBvcHRpb24gaXMgb3ZlcnJpZGVuIGJ5IGpzbGludF9oYXBweSAoaS5lLiBpZiBqc2xpbnRfaGFwcHkgaXMgdHJ1ZSwgc3BhY2VfYWZ0ZXJfYW5vbl9mdW5jdGlvbiBpcyB0cnVlIGJ5IGRlc2lnbilcblxuICAgIGJyYWNlX3N0eWxlIChkZWZhdWx0IFwiY29sbGFwc2VcIikgLSBcImNvbGxhcHNlXCIgfCBcImV4cGFuZFwiIHwgXCJlbmQtZXhwYW5kXCIgfCBcIm5vbmVcIiB8IGFueSBvZiB0aGUgZm9ybWVyICsgXCIscHJlc2VydmUtaW5saW5lXCJcbiAgICAgICAgICAgIHB1dCBicmFjZXMgb24gdGhlIHNhbWUgbGluZSBhcyBjb250cm9sIHN0YXRlbWVudHMgKGRlZmF1bHQpLCBvciBwdXQgYnJhY2VzIG9uIG93biBsaW5lIChBbGxtYW4gLyBBTlNJIHN0eWxlKSwgb3IganVzdCBwdXQgZW5kIGJyYWNlcyBvbiBvd24gbGluZSwgb3IgYXR0ZW1wdCB0byBrZWVwIHRoZW0gd2hlcmUgdGhleSBhcmUuXG4gICAgICAgICAgICBwcmVzZXJ2ZS1pbmxpbmUgd2lsbCB0cnkgdG8gcHJlc2VydmUgaW5saW5lIGJsb2NrcyBvZiBjdXJseSBicmFjZXNcblxuICAgIHNwYWNlX2JlZm9yZV9jb25kaXRpb25hbCAoZGVmYXVsdCB0cnVlKSAtIHNob3VsZCB0aGUgc3BhY2UgYmVmb3JlIGNvbmRpdGlvbmFsIHN0YXRlbWVudCBiZSBhZGRlZCwgXCJpZih0cnVlKVwiIHZzIFwiaWYgKHRydWUpXCIsXG5cbiAgICB1bmVzY2FwZV9zdHJpbmdzIChkZWZhdWx0IGZhbHNlKSAtIHNob3VsZCBwcmludGFibGUgY2hhcmFjdGVycyBpbiBzdHJpbmdzIGVuY29kZWQgaW4gXFx4Tk4gbm90YXRpb24gYmUgdW5lc2NhcGVkLCBcImV4YW1wbGVcIiB2cyBcIlxceDY1XFx4NzhcXHg2MVxceDZkXFx4NzBcXHg2Y1xceDY1XCJcblxuICAgIHdyYXBfbGluZV9sZW5ndGggKGRlZmF1bHQgdW5saW1pdGVkKSAtIGxpbmVzIHNob3VsZCB3cmFwIGF0IG5leHQgb3Bwb3J0dW5pdHkgYWZ0ZXIgdGhpcyBudW1iZXIgb2YgY2hhcmFjdGVycy5cbiAgICAgICAgICBOT1RFOiBUaGlzIGlzIG5vdCBhIGhhcmQgbGltaXQuIExpbmVzIHdpbGwgY29udGludWUgdW50aWwgYSBwb2ludCB3aGVyZSBhIG5ld2xpbmUgd291bGRcbiAgICAgICAgICAgICAgICBiZSBwcmVzZXJ2ZWQgaWYgaXQgd2VyZSBwcmVzZW50LlxuXG4gICAgZW5kX3dpdGhfbmV3bGluZSAoZGVmYXVsdCBmYWxzZSkgIC0gZW5kIG91dHB1dCB3aXRoIGEgbmV3bGluZVxuXG5cbiAgICBlLmdcblxuICAgIGpzX2JlYXV0aWZ5KGpzX3NvdXJjZV90ZXh0LCB7XG4gICAgICAnaW5kZW50X3NpemUnOiAxLFxuICAgICAgJ2luZGVudF9jaGFyJzogJ1xcdCdcbiAgICB9KTtcblxuKi9cblxuKGZ1bmN0aW9uKCkge1xudmFyIGxlZ2FjeV9iZWF1dGlmeV9qcyA9XG4vKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbi8qKioqKiovIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbi8qKioqKiovIFx0XHRcdH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA2KTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoganNoaW50IGN1cmx5OiBmYWxzZSAqL1xuLy8gVGhpcyBzZWN0aW9uIG9mIGNvZGUgaXMgdGFrZW4gZnJvbSBhY29ybi5cbi8vXG4vLyBBY29ybiB3YXMgd3JpdHRlbiBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCByZWxlYXNlZCB1bmRlciBhbiBNSVRcbi8vIGxpY2Vuc2UuIFRoZSBVbmljb2RlIHJlZ2V4cHMgKGZvciBpZGVudGlmaWVycyBhbmQgd2hpdGVzcGFjZSkgd2VyZVxuLy8gdGFrZW4gZnJvbSBbRXNwcmltYV0oaHR0cDovL2VzcHJpbWEub3JnKSBieSBBcml5YSBIaWRheWF0LlxuLy9cbi8vIEdpdCByZXBvc2l0b3JpZXMgZm9yIEFjb3JuIGFyZSBhdmFpbGFibGUgYXRcbi8vXG4vLyAgICAgaHR0cDovL21hcmlqbmhhdmVyYmVrZS5ubC9naXQvYWNvcm5cbi8vICAgICBodHRwczovL2dpdGh1Yi5jb20vbWFyaWpuaC9hY29ybi5naXRcblxuLy8gIyMgQ2hhcmFjdGVyIGNhdGVnb3JpZXNcblxuLy8gQmlnIHVnbHkgcmVndWxhciBleHByZXNzaW9ucyB0aGF0IG1hdGNoIGNoYXJhY3RlcnMgaW4gdGhlXG4vLyB3aGl0ZXNwYWNlLCBpZGVudGlmaWVyLCBhbmQgaWRlbnRpZmllci1zdGFydCBjYXRlZ29yaWVzLiBUaGVzZVxuLy8gYXJlIG9ubHkgYXBwbGllZCB3aGVuIGEgY2hhcmFjdGVyIGlzIGZvdW5kIHRvIGFjdHVhbGx5IGhhdmUgYVxuLy8gY29kZSBwb2ludCBhYm92ZSAxMjguXG5cbnZhciBub25BU0NJSXdoaXRlc3BhY2UgPSAvW1xcdTE2ODBcXHUxODBlXFx1MjAwMC1cXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1ZmVmZl0vOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbnZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gXCJcXHhhYVxceGI1XFx4YmFcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJjMVxcdTAyYzYtXFx1MDJkMVxcdTAyZTAtXFx1MDJlNFxcdTAyZWNcXHUwMmVlXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdhLVxcdTAzN2RcXHUwMzg2XFx1MDM4OC1cXHUwMzhhXFx1MDM4Y1xcdTAzOGUtXFx1MDNhMVxcdTAzYTMtXFx1MDNmNVxcdTAzZjctXFx1MDQ4MVxcdTA0OGEtXFx1MDUyN1xcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNWQwLVxcdTA1ZWFcXHUwNWYwLVxcdTA1ZjJcXHUwNjIwLVxcdTA2NGFcXHUwNjZlXFx1MDY2ZlxcdTA2NzEtXFx1MDZkM1xcdTA2ZDVcXHUwNmU1XFx1MDZlNlxcdTA2ZWVcXHUwNmVmXFx1MDZmYS1cXHUwNmZjXFx1MDZmZlxcdTA3MTBcXHUwNzEyLVxcdTA3MmZcXHUwNzRkLVxcdTA3YTVcXHUwN2IxXFx1MDdjYS1cXHUwN2VhXFx1MDdmNFxcdTA3ZjVcXHUwN2ZhXFx1MDgwMC1cXHUwODE1XFx1MDgxYVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDhhMFxcdTA4YTItXFx1MDhhY1xcdTA5MDQtXFx1MDkzOVxcdTA5M2RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTc3XFx1MDk3OS1cXHUwOTdmXFx1MDk4NS1cXHUwOThjXFx1MDk4ZlxcdTA5OTBcXHUwOTkzLVxcdTA5YThcXHUwOWFhLVxcdTA5YjBcXHUwOWIyXFx1MDliNi1cXHUwOWI5XFx1MDliZFxcdTA5Y2VcXHUwOWRjXFx1MDlkZFxcdTA5ZGYtXFx1MDllMVxcdTA5ZjBcXHUwOWYxXFx1MGEwNS1cXHUwYTBhXFx1MGEwZlxcdTBhMTBcXHUwYTEzLVxcdTBhMjhcXHUwYTJhLVxcdTBhMzBcXHUwYTMyXFx1MGEzM1xcdTBhMzVcXHUwYTM2XFx1MGEzOFxcdTBhMzlcXHUwYTU5LVxcdTBhNWNcXHUwYTVlXFx1MGE3Mi1cXHUwYTc0XFx1MGE4NS1cXHUwYThkXFx1MGE4Zi1cXHUwYTkxXFx1MGE5My1cXHUwYWE4XFx1MGFhYS1cXHUwYWIwXFx1MGFiMlxcdTBhYjNcXHUwYWI1LVxcdTBhYjlcXHUwYWJkXFx1MGFkMFxcdTBhZTBcXHUwYWUxXFx1MGIwNS1cXHUwYjBjXFx1MGIwZlxcdTBiMTBcXHUwYjEzLVxcdTBiMjhcXHUwYjJhLVxcdTBiMzBcXHUwYjMyXFx1MGIzM1xcdTBiMzUtXFx1MGIzOVxcdTBiM2RcXHUwYjVjXFx1MGI1ZFxcdTBiNWYtXFx1MGI2MVxcdTBiNzFcXHUwYjgzXFx1MGI4NS1cXHUwYjhhXFx1MGI4ZS1cXHUwYjkwXFx1MGI5Mi1cXHUwYjk1XFx1MGI5OVxcdTBiOWFcXHUwYjljXFx1MGI5ZVxcdTBiOWZcXHUwYmEzXFx1MGJhNFxcdTBiYTgtXFx1MGJhYVxcdTBiYWUtXFx1MGJiOVxcdTBiZDBcXHUwYzA1LVxcdTBjMGNcXHUwYzBlLVxcdTBjMTBcXHUwYzEyLVxcdTBjMjhcXHUwYzJhLVxcdTBjMzNcXHUwYzM1LVxcdTBjMzlcXHUwYzNkXFx1MGM1OFxcdTBjNTlcXHUwYzYwXFx1MGM2MVxcdTBjODUtXFx1MGM4Y1xcdTBjOGUtXFx1MGM5MFxcdTBjOTItXFx1MGNhOFxcdTBjYWEtXFx1MGNiM1xcdTBjYjUtXFx1MGNiOVxcdTBjYmRcXHUwY2RlXFx1MGNlMFxcdTBjZTFcXHUwY2YxXFx1MGNmMlxcdTBkMDUtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQzYVxcdTBkM2RcXHUwZDRlXFx1MGQ2MFxcdTBkNjFcXHUwZDdhLVxcdTBkN2ZcXHUwZDg1LVxcdTBkOTZcXHUwZDlhLVxcdTBkYjFcXHUwZGIzLVxcdTBkYmJcXHUwZGJkXFx1MGRjMC1cXHUwZGM2XFx1MGUwMS1cXHUwZTMwXFx1MGUzMlxcdTBlMzNcXHUwZTQwLVxcdTBlNDZcXHUwZTgxXFx1MGU4MlxcdTBlODRcXHUwZTg3XFx1MGU4OFxcdTBlOGFcXHUwZThkXFx1MGU5NC1cXHUwZTk3XFx1MGU5OS1cXHUwZTlmXFx1MGVhMS1cXHUwZWEzXFx1MGVhNVxcdTBlYTdcXHUwZWFhXFx1MGVhYlxcdTBlYWQtXFx1MGViMFxcdTBlYjJcXHUwZWIzXFx1MGViZFxcdTBlYzAtXFx1MGVjNFxcdTBlYzZcXHUwZWRjLVxcdTBlZGZcXHUwZjAwXFx1MGY0MC1cXHUwZjQ3XFx1MGY0OS1cXHUwZjZjXFx1MGY4OC1cXHUwZjhjXFx1MTAwMC1cXHUxMDJhXFx1MTAzZlxcdTEwNTAtXFx1MTA1NVxcdTEwNWEtXFx1MTA1ZFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNmUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOGVcXHUxMGEwLVxcdTEwYzVcXHUxMGM3XFx1MTBjZFxcdTEwZDAtXFx1MTBmYVxcdTEwZmMtXFx1MTI0OFxcdTEyNGEtXFx1MTI0ZFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVhLVxcdTEyNWRcXHUxMjYwLVxcdTEyODhcXHUxMjhhLVxcdTEyOGRcXHUxMjkwLVxcdTEyYjBcXHUxMmIyLVxcdTEyYjVcXHUxMmI4LVxcdTEyYmVcXHUxMmMwXFx1MTJjMi1cXHUxMmM1XFx1MTJjOC1cXHUxMmQ2XFx1MTJkOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVhXFx1MTM4MC1cXHUxMzhmXFx1MTNhMC1cXHUxM2Y0XFx1MTQwMS1cXHUxNjZjXFx1MTY2Zi1cXHUxNjdmXFx1MTY4MS1cXHUxNjlhXFx1MTZhMC1cXHUxNmVhXFx1MTZlZS1cXHUxNmYwXFx1MTcwMC1cXHUxNzBjXFx1MTcwZS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZjXFx1MTc2ZS1cXHUxNzcwXFx1MTc4MC1cXHUxN2IzXFx1MTdkN1xcdTE3ZGNcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4YThcXHUxOGFhXFx1MThiMC1cXHUxOGY1XFx1MTkwMC1cXHUxOTFjXFx1MTk1MC1cXHUxOTZkXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOWFiXFx1MTljMS1cXHUxOWM3XFx1MWEwMC1cXHUxYTE2XFx1MWEyMC1cXHUxYTU0XFx1MWFhN1xcdTFiMDUtXFx1MWIzM1xcdTFiNDUtXFx1MWI0YlxcdTFiODMtXFx1MWJhMFxcdTFiYWVcXHUxYmFmXFx1MWJiYS1cXHUxYmU1XFx1MWMwMC1cXHUxYzIzXFx1MWM0ZC1cXHUxYzRmXFx1MWM1YS1cXHUxYzdkXFx1MWNlOS1cXHUxY2VjXFx1MWNlZS1cXHUxY2YxXFx1MWNmNVxcdTFjZjZcXHUxZDAwLVxcdTFkYmZcXHUxZTAwLVxcdTFmMTVcXHUxZjE4LVxcdTFmMWRcXHUxZjIwLVxcdTFmNDVcXHUxZjQ4LVxcdTFmNGRcXHUxZjUwLVxcdTFmNTdcXHUxZjU5XFx1MWY1YlxcdTFmNWRcXHUxZjVmLVxcdTFmN2RcXHUxZjgwLVxcdTFmYjRcXHUxZmI2LVxcdTFmYmNcXHUxZmJlXFx1MWZjMi1cXHUxZmM0XFx1MWZjNi1cXHUxZmNjXFx1MWZkMC1cXHUxZmQzXFx1MWZkNi1cXHUxZmRiXFx1MWZlMC1cXHUxZmVjXFx1MWZmMi1cXHUxZmY0XFx1MWZmNi1cXHUxZmZjXFx1MjA3MVxcdTIwN2ZcXHUyMDkwLVxcdTIwOWNcXHUyMTAyXFx1MjEwN1xcdTIxMGEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMWRcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJhLVxcdTIxMmRcXHUyMTJmLVxcdTIxMzlcXHUyMTNjLVxcdTIxM2ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRlXFx1MjE2MC1cXHUyMTg4XFx1MmMwMC1cXHUyYzJlXFx1MmMzMC1cXHUyYzVlXFx1MmM2MC1cXHUyY2U0XFx1MmNlYi1cXHUyY2VlXFx1MmNmMlxcdTJjZjNcXHUyZDAwLVxcdTJkMjVcXHUyZDI3XFx1MmQyZFxcdTJkMzAtXFx1MmQ2N1xcdTJkNmZcXHUyZDgwLVxcdTJkOTZcXHUyZGEwLVxcdTJkYTZcXHUyZGE4LVxcdTJkYWVcXHUyZGIwLVxcdTJkYjZcXHUyZGI4LVxcdTJkYmVcXHUyZGMwLVxcdTJkYzZcXHUyZGM4LVxcdTJkY2VcXHUyZGQwLVxcdTJkZDZcXHUyZGQ4LVxcdTJkZGVcXHUyZTJmXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5ZC1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJkXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWJhXFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGI1XFx1NGUwMC1cXHU5ZmNjXFx1YTAwMC1cXHVhNDhjXFx1YTRkMC1cXHVhNGZkXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjFmXFx1YTYyYVxcdWE2MmJcXHVhNjQwLVxcdWE2NmVcXHVhNjdmLVxcdWE2OTdcXHVhNmEwLVxcdWE2ZWZcXHVhNzE3LVxcdWE3MWZcXHVhNzIyLVxcdWE3ODhcXHVhNzhiLVxcdWE3OGVcXHVhNzkwLVxcdWE3OTNcXHVhN2EwLVxcdWE3YWFcXHVhN2Y4LVxcdWE4MDFcXHVhODAzLVxcdWE4MDVcXHVhODA3LVxcdWE4MGFcXHVhODBjLVxcdWE4MjJcXHVhODQwLVxcdWE4NzNcXHVhODgyLVxcdWE4YjNcXHVhOGYyLVxcdWE4ZjdcXHVhOGZiXFx1YTkwYS1cXHVhOTI1XFx1YTkzMC1cXHVhOTQ2XFx1YTk2MC1cXHVhOTdjXFx1YTk4NC1cXHVhOWIyXFx1YTljZlxcdWFhMDAtXFx1YWEyOFxcdWFhNDAtXFx1YWE0MlxcdWFhNDQtXFx1YWE0YlxcdWFhNjAtXFx1YWE3NlxcdWFhN2FcXHVhYTgwLVxcdWFhYWZcXHVhYWIxXFx1YWFiNVxcdWFhYjZcXHVhYWI5LVxcdWFhYmRcXHVhYWMwXFx1YWFjMlxcdWFhZGItXFx1YWFkZFxcdWFhZTAtXFx1YWFlYVxcdWFhZjItXFx1YWFmNFxcdWFiMDEtXFx1YWIwNlxcdWFiMDktXFx1YWIwZVxcdWFiMTEtXFx1YWIxNlxcdWFiMjAtXFx1YWIyNlxcdWFiMjgtXFx1YWIyZVxcdWFiYzAtXFx1YWJlMlxcdWFjMDAtXFx1ZDdhM1xcdWQ3YjAtXFx1ZDdjNlxcdWQ3Y2ItXFx1ZDdmYlxcdWY5MDAtXFx1ZmE2ZFxcdWZhNzAtXFx1ZmFkOVxcdWZiMDAtXFx1ZmIwNlxcdWZiMTMtXFx1ZmIxN1xcdWZiMWRcXHVmYjFmLVxcdWZiMjhcXHVmYjJhLVxcdWZiMzZcXHVmYjM4LVxcdWZiM2NcXHVmYjNlXFx1ZmI0MFxcdWZiNDFcXHVmYjQzXFx1ZmI0NFxcdWZiNDYtXFx1ZmJiMVxcdWZiZDMtXFx1ZmQzZFxcdWZkNTAtXFx1ZmQ4ZlxcdWZkOTItXFx1ZmRjN1xcdWZkZjAtXFx1ZmRmYlxcdWZlNzAtXFx1ZmU3NFxcdWZlNzYtXFx1ZmVmY1xcdWZmMjEtXFx1ZmYzYVxcdWZmNDEtXFx1ZmY1YVxcdWZmNjYtXFx1ZmZiZVxcdWZmYzItXFx1ZmZjN1xcdWZmY2EtXFx1ZmZjZlxcdWZmZDItXFx1ZmZkN1xcdWZmZGEtXFx1ZmZkY1wiO1xudmFyIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gXCJcXHUwMzAwLVxcdTAzNmZcXHUwNDgzLVxcdTA0ODdcXHUwNTkxLVxcdTA1YmRcXHUwNWJmXFx1MDVjMVxcdTA1YzJcXHUwNWM0XFx1MDVjNVxcdTA1YzdcXHUwNjEwLVxcdTA2MWFcXHUwNjIwLVxcdTA2NDlcXHUwNjcyLVxcdTA2ZDNcXHUwNmU3LVxcdTA2ZThcXHUwNmZiLVxcdTA2ZmNcXHUwNzMwLVxcdTA3NGFcXHUwODAwLVxcdTA4MTRcXHUwODFiLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MmRcXHUwODQwLVxcdTA4NTdcXHUwOGU0LVxcdTA4ZmVcXHUwOTAwLVxcdTA5MDNcXHUwOTNhLVxcdTA5M2NcXHUwOTNlLVxcdTA5NGZcXHUwOTUxLVxcdTA5NTdcXHUwOTYyLVxcdTA5NjNcXHUwOTY2LVxcdTA5NmZcXHUwOTgxLVxcdTA5ODNcXHUwOWJjXFx1MDliZS1cXHUwOWM0XFx1MDljN1xcdTA5YzhcXHUwOWQ3XFx1MDlkZi1cXHUwOWUwXFx1MGEwMS1cXHUwYTAzXFx1MGEzY1xcdTBhM2UtXFx1MGE0MlxcdTBhNDdcXHUwYTQ4XFx1MGE0Yi1cXHUwYTRkXFx1MGE1MVxcdTBhNjYtXFx1MGE3MVxcdTBhNzVcXHUwYTgxLVxcdTBhODNcXHUwYWJjXFx1MGFiZS1cXHUwYWM1XFx1MGFjNy1cXHUwYWM5XFx1MGFjYi1cXHUwYWNkXFx1MGFlMi1cXHUwYWUzXFx1MGFlNi1cXHUwYWVmXFx1MGIwMS1cXHUwYjAzXFx1MGIzY1xcdTBiM2UtXFx1MGI0NFxcdTBiNDdcXHUwYjQ4XFx1MGI0Yi1cXHUwYjRkXFx1MGI1NlxcdTBiNTdcXHUwYjVmLVxcdTBiNjBcXHUwYjY2LVxcdTBiNmZcXHUwYjgyXFx1MGJiZS1cXHUwYmMyXFx1MGJjNi1cXHUwYmM4XFx1MGJjYS1cXHUwYmNkXFx1MGJkN1xcdTBiZTYtXFx1MGJlZlxcdTBjMDEtXFx1MGMwM1xcdTBjNDYtXFx1MGM0OFxcdTBjNGEtXFx1MGM0ZFxcdTBjNTVcXHUwYzU2XFx1MGM2Mi1cXHUwYzYzXFx1MGM2Ni1cXHUwYzZmXFx1MGM4MlxcdTBjODNcXHUwY2JjXFx1MGNiZS1cXHUwY2M0XFx1MGNjNi1cXHUwY2M4XFx1MGNjYS1cXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2UyLVxcdTBjZTNcXHUwY2U2LVxcdTBjZWZcXHUwZDAyXFx1MGQwM1xcdTBkNDYtXFx1MGQ0OFxcdTBkNTdcXHUwZDYyLVxcdTBkNjNcXHUwZDY2LVxcdTBkNmZcXHUwZDgyXFx1MGQ4M1xcdTBkY2FcXHUwZGNmLVxcdTBkZDRcXHUwZGQ2XFx1MGRkOC1cXHUwZGRmXFx1MGRmMlxcdTBkZjNcXHUwZTM0LVxcdTBlM2FcXHUwZTQwLVxcdTBlNDVcXHUwZTUwLVxcdTBlNTlcXHUwZWI0LVxcdTBlYjlcXHUwZWM4LVxcdTBlY2RcXHUwZWQwLVxcdTBlZDlcXHUwZjE4XFx1MGYxOVxcdTBmMjAtXFx1MGYyOVxcdTBmMzVcXHUwZjM3XFx1MGYzOVxcdTBmNDEtXFx1MGY0N1xcdTBmNzEtXFx1MGY4NFxcdTBmODYtXFx1MGY4N1xcdTBmOGQtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDAwLVxcdTEwMjlcXHUxMDQwLVxcdTEwNDlcXHUxMDY3LVxcdTEwNmRcXHUxMDcxLVxcdTEwNzRcXHUxMDgyLVxcdTEwOGRcXHUxMDhmLVxcdTEwOWRcXHUxMzVkLVxcdTEzNWZcXHUxNzBlLVxcdTE3MTBcXHUxNzIwLVxcdTE3MzBcXHUxNzQwLVxcdTE3NTBcXHUxNzcyXFx1MTc3M1xcdTE3ODAtXFx1MTdiMlxcdTE3ZGRcXHUxN2UwLVxcdTE3ZTlcXHUxODBiLVxcdTE4MGRcXHUxODEwLVxcdTE4MTlcXHUxOTIwLVxcdTE5MmJcXHUxOTMwLVxcdTE5M2JcXHUxOTUxLVxcdTE5NmRcXHUxOWIwLVxcdTE5YzBcXHUxOWM4LVxcdTE5YzlcXHUxOWQwLVxcdTE5ZDlcXHUxYTAwLVxcdTFhMTVcXHUxYTIwLVxcdTFhNTNcXHUxYTYwLVxcdTFhN2NcXHUxYTdmLVxcdTFhODlcXHUxYTkwLVxcdTFhOTlcXHUxYjQ2LVxcdTFiNGJcXHUxYjUwLVxcdTFiNTlcXHUxYjZiLVxcdTFiNzNcXHUxYmIwLVxcdTFiYjlcXHUxYmU2LVxcdTFiZjNcXHUxYzAwLVxcdTFjMjJcXHUxYzQwLVxcdTFjNDlcXHUxYzViLVxcdTFjN2RcXHUxY2QwLVxcdTFjZDJcXHUxZDAwLVxcdTFkYmVcXHUxZTAxLVxcdTFmMTVcXHUyMDBjXFx1MjAwZFxcdTIwM2ZcXHUyMDQwXFx1MjA1NFxcdTIwZDAtXFx1MjBkY1xcdTIwZTFcXHUyMGU1LVxcdTIwZjBcXHUyZDgxLVxcdTJkOTZcXHUyZGUwLVxcdTJkZmZcXHUzMDIxLVxcdTMwMjhcXHUzMDk5XFx1MzA5YVxcdWE2NDAtXFx1YTY2ZFxcdWE2NzQtXFx1YTY3ZFxcdWE2OWZcXHVhNmYwLVxcdWE2ZjFcXHVhN2Y4LVxcdWE4MDBcXHVhODA2XFx1YTgwYlxcdWE4MjMtXFx1YTgyN1xcdWE4ODAtXFx1YTg4MVxcdWE4YjQtXFx1YThjNFxcdWE4ZDAtXFx1YThkOVxcdWE4ZjMtXFx1YThmN1xcdWE5MDAtXFx1YTkwOVxcdWE5MjYtXFx1YTkyZFxcdWE5MzAtXFx1YTk0NVxcdWE5ODAtXFx1YTk4M1xcdWE5YjMtXFx1YTljMFxcdWFhMDAtXFx1YWEyN1xcdWFhNDAtXFx1YWE0MVxcdWFhNGMtXFx1YWE0ZFxcdWFhNTAtXFx1YWE1OVxcdWFhN2JcXHVhYWUwLVxcdWFhZTlcXHVhYWYyLVxcdWFhZjNcXHVhYmMwLVxcdWFiZTFcXHVhYmVjXFx1YWJlZFxcdWFiZjAtXFx1YWJmOVxcdWZiMjAtXFx1ZmIyOFxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyNlxcdWZlMzNcXHVmZTM0XFx1ZmU0ZC1cXHVmZTRmXFx1ZmYxMC1cXHVmZjE5XFx1ZmYzZlwiO1xudmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0ID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBcIl1cIik7XG52YXIgbm9uQVNDSUlpZGVudGlmaWVyID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBub25BU0NJSWlkZW50aWZpZXJDaGFycyArIFwiXVwiKTtcblxuLy8gV2hldGhlciBhIHNpbmdsZSBjaGFyYWN0ZXIgZGVub3RlcyBhIG5ld2xpbmUuXG5cbmV4cG9ydHMubmV3bGluZSA9IC9bXFxuXFxyXFx1MjAyOFxcdTIwMjldLztcblxuLy8gTWF0Y2hlcyBhIHdob2xlIGxpbmUgYnJlYWsgKHdoZXJlIENSTEYgaXMgY29uc2lkZXJlZCBhIHNpbmdsZVxuLy8gbGluZSBicmVhaykuIFVzZWQgdG8gY291bnQgbGluZXMuXG5cbi8vIGluIGphdmFzY3JpcHQsIHRoZXNlIHR3byBkaWZmZXJcbi8vIGluIHB5dGhvbiB0aGV5IGFyZSB0aGUgc2FtZSwgZGlmZmVyZW50IG1ldGhvZHMgYXJlIGNhbGxlZCBvbiB0aGVtXG5leHBvcnRzLmxpbmVCcmVhayA9IG5ldyBSZWdFeHAoJ1xcclxcbnwnICsgZXhwb3J0cy5uZXdsaW5lLnNvdXJjZSk7XG5leHBvcnRzLmFsbExpbmVCcmVha3MgPSBuZXcgUmVnRXhwKGV4cG9ydHMubGluZUJyZWFrLnNvdXJjZSwgJ2cnKTtcblxuXG4vLyBUZXN0IHdoZXRoZXIgYSBnaXZlbiBjaGFyYWN0ZXIgY29kZSBzdGFydHMgYW4gaWRlbnRpZmllci5cblxuZXhwb3J0cy5pc0lkZW50aWZpZXJTdGFydCA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgICAvLyBwZXJtaXQgJCAoMzYpIGFuZCBAICg2NCkuIEAgaXMgdXNlZCBpbiBFUzcgZGVjb3JhdG9ycy5cbiAgICBpZiAoY29kZSA8IDY1KSByZXR1cm4gY29kZSA9PT0gMzYgfHwgY29kZSA9PT0gNjQ7XG4gICAgLy8gNjUgdGhyb3VnaCA5MSBhcmUgdXBwZXJjYXNlIGxldHRlcnMuXG4gICAgaWYgKGNvZGUgPCA5MSkgcmV0dXJuIHRydWU7XG4gICAgLy8gcGVybWl0IF8gKDk1KS5cbiAgICBpZiAoY29kZSA8IDk3KSByZXR1cm4gY29kZSA9PT0gOTU7XG4gICAgLy8gOTcgdGhyb3VnaCAxMjMgYXJlIGxvd2VyY2FzZSBsZXR0ZXJzLlxuICAgIGlmIChjb2RlIDwgMTIzKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gY29kZSA+PSAweGFhICYmIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XG59O1xuXG4vLyBUZXN0IHdoZXRoZXIgYSBnaXZlbiBjaGFyYWN0ZXIgaXMgcGFydCBvZiBhbiBpZGVudGlmaWVyLlxuXG5leHBvcnRzLmlzSWRlbnRpZmllckNoYXIgPSBmdW5jdGlvbihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPCA0OCkgcmV0dXJuIGNvZGUgPT09IDM2O1xuICAgIGlmIChjb2RlIDwgNTgpIHJldHVybiB0cnVlO1xuICAgIGlmIChjb2RlIDwgNjUpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoY29kZSA8IDkxKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoY29kZSA8IDk3KSByZXR1cm4gY29kZSA9PT0gOTU7XG4gICAgaWYgKGNvZGUgPCAxMjMpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBjb2RlID49IDB4YWEgJiYgbm9uQVNDSUlpZGVudGlmaWVyLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKmpzaGludCBjdXJseTp0cnVlLCBlcWVxZXE6dHJ1ZSwgbGF4YnJlYWs6dHJ1ZSwgbm9lbXB0eTpmYWxzZSAqL1xuLypcblxuICAgIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gICAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTcgRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gICAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gICAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICAgIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gICAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICAgIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICAgIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICAgIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICBTT0ZUV0FSRS5cbiovXG5cbnZhciBtZXJnZU9wdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpLm1lcmdlT3B0cztcbnZhciBhY29ybiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgT3V0cHV0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KS5PdXRwdXQ7XG52YXIgVG9rZW5pemVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KS5Ub2tlbml6ZXI7XG5cbmZ1bmN0aW9uIHJlbW92ZV9yZWR1bmRhbnRfaW5kZW50YXRpb24ob3V0cHV0LCBmcmFtZSkge1xuICAgIC8vIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgZWZmZWN0aXZlIGJ1dCBoYXMgc29tZSBpc3N1ZXM6XG4gICAgLy8gICAgIC0gY2FuIGNhdXNlIGxpbmUgd3JhcCB0byBoYXBwZW4gdG9vIHNvb24gZHVlIHRvIGluZGVudCByZW1vdmFsXG4gICAgLy8gICAgICAgICAgIGFmdGVyIHdyYXAgcG9pbnRzIGFyZSBjYWxjdWxhdGVkXG4gICAgLy8gVGhlc2UgaXNzdWVzIGFyZSBtaW5vciBjb21wYXJlZCB0byB1Z2x5IGluZGVudGF0aW9uLlxuXG4gICAgaWYgKGZyYW1lLm11bHRpbGluZV9mcmFtZSB8fFxuICAgICAgICBmcmFtZS5tb2RlID09PSBNT0RFLkZvckluaXRpYWxpemVyIHx8XG4gICAgICAgIGZyYW1lLm1vZGUgPT09IE1PREUuQ29uZGl0aW9uYWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBvbmUgaW5kZW50IGZyb20gZWFjaCBsaW5lIGluc2lkZSB0aGlzIHNlY3Rpb25cbiAgICB2YXIgc3RhcnRfaW5kZXggPSBmcmFtZS5zdGFydF9saW5lX2luZGV4O1xuXG4gICAgb3V0cHV0LnJlbW92ZV9pbmRlbnQoc3RhcnRfaW5kZXgpO1xufVxuXG5mdW5jdGlvbiBpbl9hcnJheSh3aGF0LCBhcnIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoYXJyW2ldID09PSB3aGF0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHRyaW0ocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcbn1cblxuZnVuY3Rpb24gbHRyaW0ocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoL15cXHMrL2csICcnKTtcbn1cblxuLy8gZnVuY3Rpb24gcnRyaW0ocykge1xuLy8gICAgIHJldHVybiBzLnJlcGxhY2UoL1xccyskL2csICcnKTtcbi8vIH1cblxuXG5mdW5jdGlvbiBnZW5lcmF0ZU1hcEZyb21TdHJpbmdzKGxpc3QpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCBsaXN0Lmxlbmd0aDsgeCsrKSB7XG4gICAgICAgIC8vIG1ha2UgdGhlIG1hcHBlZCBuYW1lcyB1bmRlcnNjb3JlZCBpbnN0ZWFkIG9mIGRhc2hcbiAgICAgICAgcmVzdWx0W2xpc3RbeF0ucmVwbGFjZSgvLS9nLCAnXycpXSA9IGxpc3RbeF07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHNhbml0aXplT3BlcmF0b3JQb3NpdGlvbihvcFBvc2l0aW9uKSB7XG4gICAgb3BQb3NpdGlvbiA9IG9wUG9zaXRpb24gfHwgT1BFUkFUT1JfUE9TSVRJT04uYmVmb3JlX25ld2xpbmU7XG5cbiAgICBpZiAoIWluX2FycmF5KG9wUG9zaXRpb24sIHZhbGlkUG9zaXRpb25WYWx1ZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgT3B0aW9uIFZhbHVlOiBUaGUgb3B0aW9uICdvcGVyYXRvcl9wb3NpdGlvbicgbXVzdCBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZyB2YWx1ZXNcXG5cIiArXG4gICAgICAgICAgICB2YWxpZFBvc2l0aW9uVmFsdWVzICtcbiAgICAgICAgICAgIFwiXFxuWW91IHBhc3NlZCBpbjogJ1wiICsgb3BQb3NpdGlvbiArIFwiJ1wiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3BQb3NpdGlvbjtcbn1cblxudmFyIHZhbGlkUG9zaXRpb25WYWx1ZXMgPSBbJ2JlZm9yZS1uZXdsaW5lJywgJ2FmdGVyLW5ld2xpbmUnLCAncHJlc2VydmUtbmV3bGluZSddO1xuXG4vLyBHZW5lcmF0ZSBtYXAgZnJvbSBhcnJheVxudmFyIE9QRVJBVE9SX1BPU0lUSU9OID0gZ2VuZXJhdGVNYXBGcm9tU3RyaW5ncyh2YWxpZFBvc2l0aW9uVmFsdWVzKTtcblxudmFyIE9QRVJBVE9SX1BPU0lUSU9OX0JFRk9SRV9PUl9QUkVTRVJWRSA9IFtPUEVSQVRPUl9QT1NJVElPTi5iZWZvcmVfbmV3bGluZSwgT1BFUkFUT1JfUE9TSVRJT04ucHJlc2VydmVfbmV3bGluZV07XG5cbnZhciBNT0RFID0ge1xuICAgIEJsb2NrU3RhdGVtZW50OiAnQmxvY2tTdGF0ZW1lbnQnLCAvLyAnQkxPQ0snXG4gICAgU3RhdGVtZW50OiAnU3RhdGVtZW50JywgLy8gJ1NUQVRFTUVOVCdcbiAgICBPYmplY3RMaXRlcmFsOiAnT2JqZWN0TGl0ZXJhbCcsIC8vICdPQkpFQ1QnLFxuICAgIEFycmF5TGl0ZXJhbDogJ0FycmF5TGl0ZXJhbCcsIC8vJ1tFWFBSRVNTSU9OXScsXG4gICAgRm9ySW5pdGlhbGl6ZXI6ICdGb3JJbml0aWFsaXplcicsIC8vJyhGT1ItRVhQUkVTU0lPTiknLFxuICAgIENvbmRpdGlvbmFsOiAnQ29uZGl0aW9uYWwnLCAvLycoQ09ORC1FWFBSRVNTSU9OKScsXG4gICAgRXhwcmVzc2lvbjogJ0V4cHJlc3Npb24nIC8vJyhFWFBSRVNTSU9OKSdcbn07XG5cbmZ1bmN0aW9uIEJlYXV0aWZpZXIoanNfc291cmNlX3RleHQsIG9wdGlvbnMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgb3V0cHV0O1xuICAgIHZhciB0b2tlbnMgPSBbXSxcbiAgICAgICAgdG9rZW5fcG9zO1xuICAgIHZhciB0b2tlbml6ZXI7XG4gICAgdmFyIGN1cnJlbnRfdG9rZW47XG4gICAgdmFyIGxhc3RfdHlwZSwgbGFzdF9sYXN0X3RleHQsIGluZGVudF9zdHJpbmc7XG4gICAgdmFyIGZsYWdzLCBwcmV2aW91c19mbGFncywgZmxhZ19zdG9yZTtcbiAgICB2YXIgcHJlZml4O1xuXG4gICAgdmFyIGhhbmRsZXJzLCBvcHQ7XG4gICAgdmFyIGJhc2VJbmRlbnRTdHJpbmcgPSAnJztcblxuICAgIGhhbmRsZXJzID0ge1xuICAgICAgICAnVEtfU1RBUlRfRVhQUic6IGhhbmRsZV9zdGFydF9leHByLFxuICAgICAgICAnVEtfRU5EX0VYUFInOiBoYW5kbGVfZW5kX2V4cHIsXG4gICAgICAgICdUS19TVEFSVF9CTE9DSyc6IGhhbmRsZV9zdGFydF9ibG9jayxcbiAgICAgICAgJ1RLX0VORF9CTE9DSyc6IGhhbmRsZV9lbmRfYmxvY2ssXG4gICAgICAgICdUS19XT1JEJzogaGFuZGxlX3dvcmQsXG4gICAgICAgICdUS19SRVNFUlZFRCc6IGhhbmRsZV93b3JkLFxuICAgICAgICAnVEtfU0VNSUNPTE9OJzogaGFuZGxlX3NlbWljb2xvbixcbiAgICAgICAgJ1RLX1NUUklORyc6IGhhbmRsZV9zdHJpbmcsXG4gICAgICAgICdUS19FUVVBTFMnOiBoYW5kbGVfZXF1YWxzLFxuICAgICAgICAnVEtfT1BFUkFUT1InOiBoYW5kbGVfb3BlcmF0b3IsXG4gICAgICAgICdUS19DT01NQSc6IGhhbmRsZV9jb21tYSxcbiAgICAgICAgJ1RLX0JMT0NLX0NPTU1FTlQnOiBoYW5kbGVfYmxvY2tfY29tbWVudCxcbiAgICAgICAgJ1RLX0NPTU1FTlQnOiBoYW5kbGVfY29tbWVudCxcbiAgICAgICAgJ1RLX0RPVCc6IGhhbmRsZV9kb3QsXG4gICAgICAgICdUS19VTktOT1dOJzogaGFuZGxlX3Vua25vd24sXG4gICAgICAgICdUS19FT0YnOiBoYW5kbGVfZW9mXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZV9mbGFncyhmbGFnc19iYXNlLCBtb2RlKSB7XG4gICAgICAgIHZhciBuZXh0X2luZGVudF9sZXZlbCA9IDA7XG4gICAgICAgIGlmIChmbGFnc19iYXNlKSB7XG4gICAgICAgICAgICBuZXh0X2luZGVudF9sZXZlbCA9IGZsYWdzX2Jhc2UuaW5kZW50YXRpb25fbGV2ZWw7XG4gICAgICAgICAgICBpZiAoIW91dHB1dC5qdXN0X2FkZGVkX25ld2xpbmUoKSAmJlxuICAgICAgICAgICAgICAgIGZsYWdzX2Jhc2UubGluZV9pbmRlbnRfbGV2ZWwgPiBuZXh0X2luZGVudF9sZXZlbCkge1xuICAgICAgICAgICAgICAgIG5leHRfaW5kZW50X2xldmVsID0gZmxhZ3NfYmFzZS5saW5lX2luZGVudF9sZXZlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXh0X2ZsYWdzID0ge1xuICAgICAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgICAgIHBhcmVudDogZmxhZ3NfYmFzZSxcbiAgICAgICAgICAgIGxhc3RfdGV4dDogZmxhZ3NfYmFzZSA/IGZsYWdzX2Jhc2UubGFzdF90ZXh0IDogJycsIC8vIGxhc3QgdG9rZW4gdGV4dFxuICAgICAgICAgICAgbGFzdF93b3JkOiBmbGFnc19iYXNlID8gZmxhZ3NfYmFzZS5sYXN0X3dvcmQgOiAnJywgLy8gbGFzdCAnVEtfV09SRCcgcGFzc2VkXG4gICAgICAgICAgICBkZWNsYXJhdGlvbl9zdGF0ZW1lbnQ6IGZhbHNlLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25fYXNzaWdubWVudDogZmFsc2UsXG4gICAgICAgICAgICBtdWx0aWxpbmVfZnJhbWU6IGZhbHNlLFxuICAgICAgICAgICAgaW5saW5lX2ZyYW1lOiBmYWxzZSxcbiAgICAgICAgICAgIGlmX2Jsb2NrOiBmYWxzZSxcbiAgICAgICAgICAgIGVsc2VfYmxvY2s6IGZhbHNlLFxuICAgICAgICAgICAgZG9fYmxvY2s6IGZhbHNlLFxuICAgICAgICAgICAgZG9fd2hpbGU6IGZhbHNlLFxuICAgICAgICAgICAgaW1wb3J0X2Jsb2NrOiBmYWxzZSxcbiAgICAgICAgICAgIGluX2Nhc2Vfc3RhdGVtZW50OiBmYWxzZSwgLy8gc3dpdGNoKC4uKXsgSU5TSURFIEhFUkUgfVxuICAgICAgICAgICAgaW5fY2FzZTogZmFsc2UsIC8vIHdlJ3JlIG9uIHRoZSBleGFjdCBsaW5lIHdpdGggXCJjYXNlIDA6XCJcbiAgICAgICAgICAgIGNhc2VfYm9keTogZmFsc2UsIC8vIHRoZSBpbmRlbnRlZCBjYXNlLWFjdGlvbiBibG9ja1xuICAgICAgICAgICAgaW5kZW50YXRpb25fbGV2ZWw6IG5leHRfaW5kZW50X2xldmVsLFxuICAgICAgICAgICAgbGluZV9pbmRlbnRfbGV2ZWw6IGZsYWdzX2Jhc2UgPyBmbGFnc19iYXNlLmxpbmVfaW5kZW50X2xldmVsIDogbmV4dF9pbmRlbnRfbGV2ZWwsXG4gICAgICAgICAgICBzdGFydF9saW5lX2luZGV4OiBvdXRwdXQuZ2V0X2xpbmVfbnVtYmVyKCksXG4gICAgICAgICAgICB0ZXJuYXJ5X2RlcHRoOiAwXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXh0X2ZsYWdzO1xuICAgIH1cblxuICAgIC8vIFNvbWUgaW50ZXJwcmV0ZXJzIGhhdmUgdW5leHBlY3RlZCByZXN1bHRzIHdpdGggZm9vID0gYmF6IHx8IGJhcjtcbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcblxuICAgIC8vIEFsbG93IHRoZSBzZXR0aW5nIG9mIGxhbmd1YWdlL2ZpbGUtdHlwZSBzcGVjaWZpYyBvcHRpb25zXG4gICAgLy8gd2l0aCBpbmhlcml0YW5jZSBvZiBvdmVyYWxsIHNldHRpbmdzXG4gICAgb3B0aW9ucyA9IG1lcmdlT3B0cyhvcHRpb25zLCAnanMnKTtcblxuICAgIG9wdCA9IHt9O1xuXG4gICAgLy8gY29tcGF0aWJpbGl0eSwgcmVcbiAgICBpZiAob3B0aW9ucy5icmFjZV9zdHlsZSA9PT0gXCJleHBhbmQtc3RyaWN0XCIpIHsgLy9ncmFjZWZ1bCBoYW5kbGluZyBvZiBkZXByZWNhdGVkIG9wdGlvblxuICAgICAgICBvcHRpb25zLmJyYWNlX3N0eWxlID0gXCJleHBhbmRcIjtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuYnJhY2Vfc3R5bGUgPT09IFwiY29sbGFwc2UtcHJlc2VydmUtaW5saW5lXCIpIHsgLy9ncmFjZWZ1bCBoYW5kbGluZyBvZiBkZXByZWNhdGVkIG9wdGlvblxuICAgICAgICBvcHRpb25zLmJyYWNlX3N0eWxlID0gXCJjb2xsYXBzZSxwcmVzZXJ2ZS1pbmxpbmVcIjtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuYnJhY2VzX29uX293bl9saW5lICE9PSB1bmRlZmluZWQpIHsgLy9ncmFjZWZ1bCBoYW5kbGluZyBvZiBkZXByZWNhdGVkIG9wdGlvblxuICAgICAgICBvcHRpb25zLmJyYWNlX3N0eWxlID0gb3B0aW9ucy5icmFjZXNfb25fb3duX2xpbmUgPyBcImV4cGFuZFwiIDogXCJjb2xsYXBzZVwiO1xuICAgIH0gZWxzZSBpZiAoIW9wdGlvbnMuYnJhY2Vfc3R5bGUpIC8vTm90aGluZyBleGlzdHMgdG8gc2V0IGl0XG4gICAge1xuICAgICAgICBvcHRpb25zLmJyYWNlX3N0eWxlID0gXCJjb2xsYXBzZVwiO1xuICAgIH1cblxuXG4gICAgdmFyIGJyYWNlX3N0eWxlX3NwbGl0ID0gb3B0aW9ucy5icmFjZV9zdHlsZS5zcGxpdCgvW15hLXpBLVowLTlfXFwtXSsvKTtcbiAgICBvcHQuYnJhY2Vfc3R5bGUgPSBicmFjZV9zdHlsZV9zcGxpdFswXTtcbiAgICBvcHQuYnJhY2VfcHJlc2VydmVfaW5saW5lID0gYnJhY2Vfc3R5bGVfc3BsaXRbMV0gPyBicmFjZV9zdHlsZV9zcGxpdFsxXSA6IGZhbHNlO1xuXG4gICAgb3B0LmluZGVudF9zaXplID0gb3B0aW9ucy5pbmRlbnRfc2l6ZSA/IHBhcnNlSW50KG9wdGlvbnMuaW5kZW50X3NpemUsIDEwKSA6IDQ7XG4gICAgb3B0LmluZGVudF9jaGFyID0gb3B0aW9ucy5pbmRlbnRfY2hhciA/IG9wdGlvbnMuaW5kZW50X2NoYXIgOiAnICc7XG4gICAgb3B0LmVvbCA9IG9wdGlvbnMuZW9sID8gb3B0aW9ucy5lb2wgOiAnYXV0byc7XG4gICAgb3B0LnByZXNlcnZlX25ld2xpbmVzID0gKG9wdGlvbnMucHJlc2VydmVfbmV3bGluZXMgPT09IHVuZGVmaW5lZCkgPyB0cnVlIDogb3B0aW9ucy5wcmVzZXJ2ZV9uZXdsaW5lcztcbiAgICBvcHQudW5pbmRlbnRfY2hhaW5lZF9tZXRob2RzID0gKG9wdGlvbnMudW5pbmRlbnRfY2hhaW5lZF9tZXRob2RzID09PSB1bmRlZmluZWQpID8gZmFsc2UgOiBvcHRpb25zLnVuaW5kZW50X2NoYWluZWRfbWV0aG9kcztcbiAgICBvcHQuYnJlYWtfY2hhaW5lZF9tZXRob2RzID0gKG9wdGlvbnMuYnJlYWtfY2hhaW5lZF9tZXRob2RzID09PSB1bmRlZmluZWQpID8gZmFsc2UgOiBvcHRpb25zLmJyZWFrX2NoYWluZWRfbWV0aG9kcztcbiAgICBvcHQubWF4X3ByZXNlcnZlX25ld2xpbmVzID0gKG9wdGlvbnMubWF4X3ByZXNlcnZlX25ld2xpbmVzID09PSB1bmRlZmluZWQpID8gMCA6IHBhcnNlSW50KG9wdGlvbnMubWF4X3ByZXNlcnZlX25ld2xpbmVzLCAxMCk7XG4gICAgb3B0LnNwYWNlX2luX3BhcmVuID0gKG9wdGlvbnMuc3BhY2VfaW5fcGFyZW4gPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IG9wdGlvbnMuc3BhY2VfaW5fcGFyZW47XG4gICAgb3B0LnNwYWNlX2luX2VtcHR5X3BhcmVuID0gKG9wdGlvbnMuc3BhY2VfaW5fZW1wdHlfcGFyZW4gPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IG9wdGlvbnMuc3BhY2VfaW5fZW1wdHlfcGFyZW47XG4gICAgb3B0LmpzbGludF9oYXBweSA9IChvcHRpb25zLmpzbGludF9oYXBweSA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogb3B0aW9ucy5qc2xpbnRfaGFwcHk7XG4gICAgb3B0LnNwYWNlX2FmdGVyX2Fub25fZnVuY3Rpb24gPSAob3B0aW9ucy5zcGFjZV9hZnRlcl9hbm9uX2Z1bmN0aW9uID09PSB1bmRlZmluZWQpID8gZmFsc2UgOiBvcHRpb25zLnNwYWNlX2FmdGVyX2Fub25fZnVuY3Rpb247XG4gICAgb3B0LmtlZXBfYXJyYXlfaW5kZW50YXRpb24gPSAob3B0aW9ucy5rZWVwX2FycmF5X2luZGVudGF0aW9uID09PSB1bmRlZmluZWQpID8gZmFsc2UgOiBvcHRpb25zLmtlZXBfYXJyYXlfaW5kZW50YXRpb247XG4gICAgb3B0LnNwYWNlX2JlZm9yZV9jb25kaXRpb25hbCA9IChvcHRpb25zLnNwYWNlX2JlZm9yZV9jb25kaXRpb25hbCA9PT0gdW5kZWZpbmVkKSA/IHRydWUgOiBvcHRpb25zLnNwYWNlX2JlZm9yZV9jb25kaXRpb25hbDtcbiAgICBvcHQudW5lc2NhcGVfc3RyaW5ncyA9IChvcHRpb25zLnVuZXNjYXBlX3N0cmluZ3MgPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IG9wdGlvbnMudW5lc2NhcGVfc3RyaW5ncztcbiAgICBvcHQud3JhcF9saW5lX2xlbmd0aCA9IChvcHRpb25zLndyYXBfbGluZV9sZW5ndGggPT09IHVuZGVmaW5lZCkgPyAwIDogcGFyc2VJbnQob3B0aW9ucy53cmFwX2xpbmVfbGVuZ3RoLCAxMCk7XG4gICAgb3B0LmU0eCA9IChvcHRpb25zLmU0eCA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogb3B0aW9ucy5lNHg7XG4gICAgb3B0LmVuZF93aXRoX25ld2xpbmUgPSAob3B0aW9ucy5lbmRfd2l0aF9uZXdsaW5lID09PSB1bmRlZmluZWQpID8gZmFsc2UgOiBvcHRpb25zLmVuZF93aXRoX25ld2xpbmU7XG4gICAgb3B0LmNvbW1hX2ZpcnN0ID0gKG9wdGlvbnMuY29tbWFfZmlyc3QgPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IG9wdGlvbnMuY29tbWFfZmlyc3Q7XG4gICAgb3B0Lm9wZXJhdG9yX3Bvc2l0aW9uID0gc2FuaXRpemVPcGVyYXRvclBvc2l0aW9uKG9wdGlvbnMub3BlcmF0b3JfcG9zaXRpb24pO1xuXG4gICAgLy8gRm9yIHRlc3Rpbmcgb2YgYmVhdXRpZnkgaWdub3JlOnN0YXJ0IGRpcmVjdGl2ZVxuICAgIG9wdC50ZXN0X291dHB1dF9yYXcgPSAob3B0aW9ucy50ZXN0X291dHB1dF9yYXcgPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IG9wdGlvbnMudGVzdF9vdXRwdXRfcmF3O1xuXG4gICAgLy8gZm9yY2Ugb3B0LnNwYWNlX2FmdGVyX2Fub25fZnVuY3Rpb24gdG8gdHJ1ZSBpZiBvcHQuanNsaW50X2hhcHB5XG4gICAgaWYgKG9wdC5qc2xpbnRfaGFwcHkpIHtcbiAgICAgICAgb3B0LnNwYWNlX2FmdGVyX2Fub25fZnVuY3Rpb24gPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmluZGVudF93aXRoX3RhYnMpIHtcbiAgICAgICAgb3B0LmluZGVudF9jaGFyID0gJ1xcdCc7XG4gICAgICAgIG9wdC5pbmRlbnRfc2l6ZSA9IDE7XG4gICAgfVxuXG4gICAgaWYgKG9wdC5lb2wgPT09ICdhdXRvJykge1xuICAgICAgICBvcHQuZW9sID0gJ1xcbic7XG4gICAgICAgIGlmIChqc19zb3VyY2VfdGV4dCAmJiBhY29ybi5saW5lQnJlYWsudGVzdChqc19zb3VyY2VfdGV4dCB8fCAnJykpIHtcbiAgICAgICAgICAgIG9wdC5lb2wgPSBqc19zb3VyY2VfdGV4dC5tYXRjaChhY29ybi5saW5lQnJlYWspWzBdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb3B0LmVvbCA9IG9wdC5lb2wucmVwbGFjZSgvXFxcXHIvLCAnXFxyJykucmVwbGFjZSgvXFxcXG4vLCAnXFxuJyk7XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBpbmRlbnRfc3RyaW5nID0gJyc7XG4gICAgd2hpbGUgKG9wdC5pbmRlbnRfc2l6ZSA+IDApIHtcbiAgICAgICAgaW5kZW50X3N0cmluZyArPSBvcHQuaW5kZW50X2NoYXI7XG4gICAgICAgIG9wdC5pbmRlbnRfc2l6ZSAtPSAxO1xuICAgIH1cblxuICAgIHZhciBwcmVpbmRlbnRfaW5kZXggPSAwO1xuICAgIGlmIChqc19zb3VyY2VfdGV4dCAmJiBqc19zb3VyY2VfdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgd2hpbGUgKChqc19zb3VyY2VfdGV4dC5jaGFyQXQocHJlaW5kZW50X2luZGV4KSA9PT0gJyAnIHx8XG4gICAgICAgICAgICAgICAganNfc291cmNlX3RleHQuY2hhckF0KHByZWluZGVudF9pbmRleCkgPT09ICdcXHQnKSkge1xuICAgICAgICAgICAgcHJlaW5kZW50X2luZGV4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgYmFzZUluZGVudFN0cmluZyA9IGpzX3NvdXJjZV90ZXh0LnN1YnN0cmluZygwLCBwcmVpbmRlbnRfaW5kZXgpO1xuICAgICAgICBqc19zb3VyY2VfdGV4dCA9IGpzX3NvdXJjZV90ZXh0LnN1YnN0cmluZyhwcmVpbmRlbnRfaW5kZXgpO1xuICAgIH1cblxuICAgIGxhc3RfdHlwZSA9ICdUS19TVEFSVF9CTE9DSyc7IC8vIGxhc3QgdG9rZW4gdHlwZVxuICAgIGxhc3RfbGFzdF90ZXh0ID0gJyc7IC8vIHByZS1sYXN0IHRva2VuIHRleHRcbiAgICBvdXRwdXQgPSBuZXcgT3V0cHV0KGluZGVudF9zdHJpbmcsIGJhc2VJbmRlbnRTdHJpbmcpO1xuXG4gICAgLy8gSWYgdGVzdGluZyB0aGUgaWdub3JlIGRpcmVjdGl2ZSwgc3RhcnQgd2l0aCBvdXRwdXQgZGlzYWJsZSBzZXQgdG8gdHJ1ZVxuICAgIG91dHB1dC5yYXcgPSBvcHQudGVzdF9vdXRwdXRfcmF3O1xuXG5cbiAgICAvLyBTdGFjayBvZiBwYXJzaW5nL2Zvcm1hdHRpbmcgc3RhdGVzLCBpbmNsdWRpbmcgTU9ERS5cbiAgICAvLyBXZSB0b2tlbml6ZSwgcGFyc2UsIGFuZCBvdXRwdXQgaW4gYW4gYWxtb3N0IHB1cmVseSBhIGZvcndhcmQtb25seSBzdHJlYW0gb2YgdG9rZW4gaW5wdXRcbiAgICAvLyBhbmQgZm9ybWF0dGVkIG91dHB1dC4gIFRoaXMgbWFrZXMgdGhlIGJlYXV0aWZpZXIgbGVzcyBhY2N1cmF0ZSB0aGFuIGZ1bGwgcGFyc2Vyc1xuICAgIC8vIGJ1dCBhbHNvIGZhciBtb3JlIHRvbGVyYW50IG9mIHN5bnRheCBlcnJvcnMuXG4gICAgLy9cbiAgICAvLyBGb3IgZXhhbXBsZSwgdGhlIGRlZmF1bHQgbW9kZSBpcyBNT0RFLkJsb2NrU3RhdGVtZW50LiBJZiB3ZSBzZWUgYSAneycgd2UgcHVzaCBhIG5ldyBmcmFtZSBvZiB0eXBlXG4gICAgLy8gTU9ERS5CbG9ja1N0YXRlbWVudCBvbiB0aGUgdGhlIHN0YWNrLCBldmVuIHRob3VnaCBpdCBjb3VsZCBiZSBvYmplY3QgbGl0ZXJhbC4gIElmIHdlIGxhdGVyXG4gICAgLy8gZW5jb3VudGVyIGEgXCI6XCIsIHdlJ2xsIHN3aXRjaCB0byB0byBNT0RFLk9iamVjdExpdGVyYWwuICBJZiB3ZSB0aGVuIHNlZSBhIFwiO1wiLFxuICAgIC8vIG1vc3QgZnVsbCBwYXJzZXJzIHdvdWxkIGRpZSwgYnV0IHRoZSBiZWF1dGlmaWVyIGdyYWNlZnVsbHkgZmFsbHMgYmFjayB0b1xuICAgIC8vIE1PREUuQmxvY2tTdGF0ZW1lbnQgYW5kIGNvbnRpbnVlcyBvbi5cbiAgICBmbGFnX3N0b3JlID0gW107XG4gICAgc2V0X21vZGUoTU9ERS5CbG9ja1N0YXRlbWVudCk7XG5cbiAgICB0aGlzLmJlYXV0aWZ5ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLypqc2hpbnQgb25ldmFyOnRydWUgKi9cbiAgICAgICAgdmFyIHN3ZWV0X2NvZGU7XG4gICAgICAgIHRva2VuaXplciA9IG5ldyBUb2tlbml6ZXIoanNfc291cmNlX3RleHQsIG9wdCwgaW5kZW50X3N0cmluZyk7XG4gICAgICAgIHRva2VucyA9IHRva2VuaXplci50b2tlbml6ZSgpO1xuICAgICAgICB0b2tlbl9wb3MgPSAwO1xuXG4gICAgICAgIGN1cnJlbnRfdG9rZW4gPSBnZXRfdG9rZW4oKTtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRfdG9rZW4pIHtcbiAgICAgICAgICAgIGhhbmRsZXJzW2N1cnJlbnRfdG9rZW4udHlwZV0oKTtcblxuICAgICAgICAgICAgbGFzdF9sYXN0X3RleHQgPSBmbGFncy5sYXN0X3RleHQ7XG4gICAgICAgICAgICBsYXN0X3R5cGUgPSBjdXJyZW50X3Rva2VuLnR5cGU7XG4gICAgICAgICAgICBmbGFncy5sYXN0X3RleHQgPSBjdXJyZW50X3Rva2VuLnRleHQ7XG5cbiAgICAgICAgICAgIHRva2VuX3BvcyArPSAxO1xuICAgICAgICAgICAgY3VycmVudF90b2tlbiA9IGdldF90b2tlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dlZXRfY29kZSA9IG91dHB1dC5nZXRfY29kZShvcHQuZW5kX3dpdGhfbmV3bGluZSwgb3B0LmVvbCk7XG5cbiAgICAgICAgcmV0dXJuIHN3ZWV0X2NvZGU7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhsb2NhbF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKSB7XG4gICAgICAgIHZhciBuZXdsaW5lcyA9IGxvY2FsX3Rva2VuLm5ld2xpbmVzO1xuICAgICAgICB2YXIga2VlcF93aGl0ZXNwYWNlID0gb3B0LmtlZXBfYXJyYXlfaW5kZW50YXRpb24gJiYgaXNfYXJyYXkoZmxhZ3MubW9kZSk7XG4gICAgICAgIHZhciB0ZW1wX3Rva2VuID0gY3VycmVudF90b2tlbjtcblxuICAgICAgICBmb3IgKHZhciBoID0gMDsgaCA8IGxvY2FsX3Rva2VuLmNvbW1lbnRzX2JlZm9yZS5sZW5ndGg7IGgrKykge1xuICAgICAgICAgICAgLy8gVGhlIGNsZWFuZXN0IGhhbmRsaW5nIG9mIGlubGluZSBjb21tZW50cyBpcyB0byB0cmVhdCB0aGVtIGFzIHRob3VnaCB0aGV5IGFyZW4ndCB0aGVyZS5cbiAgICAgICAgICAgIC8vIEp1c3QgY29udGludWUgZm9ybWF0dGluZyBhbmQgdGhlIGJlaGF2aW9yIHNob3VsZCBiZSBsb2dpY2FsLlxuICAgICAgICAgICAgLy8gQWxzbyBpZ25vcmUgdW5rbm93biB0b2tlbnMuICBBZ2FpbiwgdGhpcyBzaG91bGQgcmVzdWx0IGluIGJldHRlciBiZWhhdmlvci5cbiAgICAgICAgICAgIGN1cnJlbnRfdG9rZW4gPSBsb2NhbF90b2tlbi5jb21tZW50c19iZWZvcmVbaF07XG4gICAgICAgICAgICBoYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgICAgICAgICAgIGhhbmRsZXJzW2N1cnJlbnRfdG9rZW4udHlwZV0ocHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50X3Rva2VuID0gdGVtcF90b2tlbjtcblxuICAgICAgICBpZiAoa2VlcF93aGl0ZXNwYWNlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld2xpbmVzOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBwcmludF9uZXdsaW5lKGkgPiAwLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG9wdC5tYXhfcHJlc2VydmVfbmV3bGluZXMgJiYgbmV3bGluZXMgPiBvcHQubWF4X3ByZXNlcnZlX25ld2xpbmVzKSB7XG4gICAgICAgICAgICAgICAgbmV3bGluZXMgPSBvcHQubWF4X3ByZXNlcnZlX25ld2xpbmVzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3B0LnByZXNlcnZlX25ld2xpbmVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsX3Rva2VuLm5ld2xpbmVzID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBwcmludF9uZXdsaW5lKGZhbHNlLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IG5ld2xpbmVzOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW50X25ld2xpbmUodHJ1ZSwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gd2UgY291bGQgdXNlIGp1c3Qgc3RyaW5nLnNwbGl0LCBidXRcbiAgICAvLyBJRSBkb2Vzbid0IGxpa2UgcmV0dXJuaW5nIGVtcHR5IHN0cmluZ3NcbiAgICBmdW5jdGlvbiBzcGxpdF9saW5lYnJlYWtzKHMpIHtcbiAgICAgICAgLy9yZXR1cm4gcy5zcGxpdCgvXFx4MGRcXHgwYXxcXHgwYS8pO1xuXG4gICAgICAgIHMgPSBzLnJlcGxhY2UoYWNvcm4uYWxsTGluZUJyZWFrcywgJ1xcbicpO1xuICAgICAgICB2YXIgb3V0ID0gW10sXG4gICAgICAgICAgICBpZHggPSBzLmluZGV4T2YoXCJcXG5cIik7XG4gICAgICAgIHdoaWxlIChpZHggIT09IC0xKSB7XG4gICAgICAgICAgICBvdXQucHVzaChzLnN1YnN0cmluZygwLCBpZHgpKTtcbiAgICAgICAgICAgIHMgPSBzLnN1YnN0cmluZyhpZHggKyAxKTtcbiAgICAgICAgICAgIGlkeCA9IHMuaW5kZXhPZihcIlxcblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG91dC5wdXNoKHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgdmFyIG5ld2xpbmVfcmVzdHJpY3RlZF90b2tlbnMgPSBbJ2JyZWFrJywgJ2NvbnRpbnVlJywgJ3JldHVybicsICd0aHJvdycsICd5aWVsZCddO1xuXG4gICAgZnVuY3Rpb24gYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShmb3JjZV9saW5ld3JhcCkge1xuICAgICAgICBmb3JjZV9saW5ld3JhcCA9IChmb3JjZV9saW5ld3JhcCA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogZm9yY2VfbGluZXdyYXA7XG5cbiAgICAgICAgLy8gTmV2ZXIgd3JhcCB0aGUgZmlyc3QgdG9rZW4gb24gYSBsaW5lXG4gICAgICAgIGlmIChvdXRwdXQuanVzdF9hZGRlZF9uZXdsaW5lKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaG91bGRQcmVzZXJ2ZU9yRm9yY2UgPSAob3B0LnByZXNlcnZlX25ld2xpbmVzICYmIGN1cnJlbnRfdG9rZW4ud2FudGVkX25ld2xpbmUpIHx8IGZvcmNlX2xpbmV3cmFwO1xuICAgICAgICB2YXIgb3BlcmF0b3JMb2dpY0FwcGxpZXMgPSBpbl9hcnJheShmbGFncy5sYXN0X3RleHQsIHRva2VuaXplci5wb3NpdGlvbmFibGVfb3BlcmF0b3JzKSB8fCBpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsIHRva2VuaXplci5wb3NpdGlvbmFibGVfb3BlcmF0b3JzKTtcblxuICAgICAgICBpZiAob3BlcmF0b3JMb2dpY0FwcGxpZXMpIHtcbiAgICAgICAgICAgIHZhciBzaG91bGRQcmludE9wZXJhdG9yTmV3bGluZSA9IChcbiAgICAgICAgICAgICAgICAgICAgaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LCB0b2tlbml6ZXIucG9zaXRpb25hYmxlX29wZXJhdG9ycykgJiZcbiAgICAgICAgICAgICAgICAgICAgaW5fYXJyYXkob3B0Lm9wZXJhdG9yX3Bvc2l0aW9uLCBPUEVSQVRPUl9QT1NJVElPTl9CRUZPUkVfT1JfUFJFU0VSVkUpXG4gICAgICAgICAgICAgICAgKSB8fFxuICAgICAgICAgICAgICAgIGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgdG9rZW5pemVyLnBvc2l0aW9uYWJsZV9vcGVyYXRvcnMpO1xuICAgICAgICAgICAgc2hvdWxkUHJlc2VydmVPckZvcmNlID0gc2hvdWxkUHJlc2VydmVPckZvcmNlICYmIHNob3VsZFByaW50T3BlcmF0b3JOZXdsaW5lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNob3VsZFByZXNlcnZlT3JGb3JjZSkge1xuICAgICAgICAgICAgcHJpbnRfbmV3bGluZShmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0LndyYXBfbGluZV9sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LCBuZXdsaW5lX3Jlc3RyaWN0ZWRfdG9rZW5zKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZXNlIHRva2VucyBzaG91bGQgbmV2ZXIgaGF2ZSBhIG5ld2xpbmUgaW5zZXJ0ZWRcbiAgICAgICAgICAgICAgICAvLyBiZXR3ZWVuIHRoZW0gYW5kIHRoZSBmb2xsb3dpbmcgZXhwcmVzc2lvbi5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJvcG9zZWRfbGluZV9sZW5ndGggPSBvdXRwdXQuY3VycmVudF9saW5lLmdldF9jaGFyYWN0ZXJfY291bnQoKSArIGN1cnJlbnRfdG9rZW4udGV4dC5sZW5ndGggK1xuICAgICAgICAgICAgICAgIChvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID8gMSA6IDApO1xuICAgICAgICAgICAgaWYgKHByb3Bvc2VkX2xpbmVfbGVuZ3RoID49IG9wdC53cmFwX2xpbmVfbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcHJpbnRfbmV3bGluZShmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmludF9uZXdsaW5lKGZvcmNlX25ld2xpbmUsIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncykge1xuICAgICAgICBpZiAoIXByZXNlcnZlX3N0YXRlbWVudF9mbGFncykge1xuICAgICAgICAgICAgaWYgKGZsYWdzLmxhc3RfdGV4dCAhPT0gJzsnICYmIGZsYWdzLmxhc3RfdGV4dCAhPT0gJywnICYmIGZsYWdzLmxhc3RfdGV4dCAhPT0gJz0nICYmIGxhc3RfdHlwZSAhPT0gJ1RLX09QRVJBVE9SJykge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0X3Rva2VuID0gZ2V0X3Rva2VuKDEpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChmbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCAmJlxuICAgICAgICAgICAgICAgICAgICAhKGZsYWdzLmlmX2Jsb2NrICYmIG5leHRfdG9rZW4gJiYgbmV4dF90b2tlbi50eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIG5leHRfdG9rZW4udGV4dCA9PT0gJ2Vsc2UnKSAmJlxuICAgICAgICAgICAgICAgICAgICAhZmxhZ3MuZG9fYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdG9yZV9tb2RlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG91dHB1dC5hZGRfbmV3X2xpbmUoZm9yY2VfbmV3bGluZSkpIHtcbiAgICAgICAgICAgIGZsYWdzLm11bHRpbGluZV9mcmFtZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmludF90b2tlbl9saW5lX2luZGVudGF0aW9uKCkge1xuICAgICAgICBpZiAob3V0cHV0Lmp1c3RfYWRkZWRfbmV3bGluZSgpKSB7XG4gICAgICAgICAgICBpZiAob3B0LmtlZXBfYXJyYXlfaW5kZW50YXRpb24gJiYgaXNfYXJyYXkoZmxhZ3MubW9kZSkgJiYgY3VycmVudF90b2tlbi53YW50ZWRfbmV3bGluZSkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5jdXJyZW50X2xpbmUucHVzaChjdXJyZW50X3Rva2VuLndoaXRlc3BhY2VfYmVmb3JlKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG91dHB1dC5zZXRfaW5kZW50KGZsYWdzLmluZGVudGF0aW9uX2xldmVsKSkge1xuICAgICAgICAgICAgICAgIGZsYWdzLmxpbmVfaW5kZW50X2xldmVsID0gZmxhZ3MuaW5kZW50YXRpb25fbGV2ZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmludF90b2tlbihwcmludGFibGVfdG9rZW4pIHtcbiAgICAgICAgaWYgKG91dHB1dC5yYXcpIHtcbiAgICAgICAgICAgIG91dHB1dC5hZGRfcmF3X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdC5jb21tYV9maXJzdCAmJiBsYXN0X3R5cGUgPT09ICdUS19DT01NQScgJiZcbiAgICAgICAgICAgIG91dHB1dC5qdXN0X2FkZGVkX25ld2xpbmUoKSkge1xuICAgICAgICAgICAgaWYgKG91dHB1dC5wcmV2aW91c19saW5lLmxhc3QoKSA9PT0gJywnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvcHBlZCA9IG91dHB1dC5wcmV2aW91c19saW5lLnBvcCgpO1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjb21tYSB3YXMgYWxyZWFkeSBhdCB0aGUgc3RhcnQgb2YgdGhlIGxpbmUsXG4gICAgICAgICAgICAgICAgLy8gcHVsbCBiYWNrIG9udG8gdGhhdCBsaW5lIGFuZCByZXByaW50IHRoZSBpbmRlbnRhdGlvblxuICAgICAgICAgICAgICAgIGlmIChvdXRwdXQucHJldmlvdXNfbGluZS5pc19lbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmV2aW91c19saW5lLnB1c2gocG9wcGVkKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnRyaW0odHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5jdXJyZW50X2xpbmUucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC50cmltKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYWRkIHRoZSBjb21tYSBpbiBmcm9udCBvZiB0aGUgbmV4dCB0b2tlblxuICAgICAgICAgICAgICAgIHByaW50X3Rva2VuX2xpbmVfaW5kZW50YXRpb24oKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuYWRkX3Rva2VuKCcsJyk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwcmludGFibGVfdG9rZW4gPSBwcmludGFibGVfdG9rZW4gfHwgY3VycmVudF90b2tlbi50ZXh0O1xuICAgICAgICBwcmludF90b2tlbl9saW5lX2luZGVudGF0aW9uKCk7XG4gICAgICAgIG91dHB1dC5hZGRfdG9rZW4ocHJpbnRhYmxlX3Rva2VuKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbmRlbnQoKSB7XG4gICAgICAgIGZsYWdzLmluZGVudGF0aW9uX2xldmVsICs9IDE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVpbmRlbnQoKSB7XG4gICAgICAgIGlmIChmbGFncy5pbmRlbnRhdGlvbl9sZXZlbCA+IDAgJiZcbiAgICAgICAgICAgICgoIWZsYWdzLnBhcmVudCkgfHwgZmxhZ3MuaW5kZW50YXRpb25fbGV2ZWwgPiBmbGFncy5wYXJlbnQuaW5kZW50YXRpb25fbGV2ZWwpKSB7XG4gICAgICAgICAgICBmbGFncy5pbmRlbnRhdGlvbl9sZXZlbCAtPSAxO1xuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRfbW9kZShtb2RlKSB7XG4gICAgICAgIGlmIChmbGFncykge1xuICAgICAgICAgICAgZmxhZ19zdG9yZS5wdXNoKGZsYWdzKTtcbiAgICAgICAgICAgIHByZXZpb3VzX2ZsYWdzID0gZmxhZ3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmV2aW91c19mbGFncyA9IGNyZWF0ZV9mbGFncyhudWxsLCBtb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZsYWdzID0gY3JlYXRlX2ZsYWdzKHByZXZpb3VzX2ZsYWdzLCBtb2RlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc19hcnJheShtb2RlKSB7XG4gICAgICAgIHJldHVybiBtb2RlID09PSBNT0RFLkFycmF5TGl0ZXJhbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc19leHByZXNzaW9uKG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIGluX2FycmF5KG1vZGUsIFtNT0RFLkV4cHJlc3Npb24sIE1PREUuRm9ySW5pdGlhbGl6ZXIsIE1PREUuQ29uZGl0aW9uYWxdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXN0b3JlX21vZGUoKSB7XG4gICAgICAgIGlmIChmbGFnX3N0b3JlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHByZXZpb3VzX2ZsYWdzID0gZmxhZ3M7XG4gICAgICAgICAgICBmbGFncyA9IGZsYWdfc3RvcmUucG9wKCk7XG4gICAgICAgICAgICBpZiAocHJldmlvdXNfZmxhZ3MubW9kZSA9PT0gTU9ERS5TdGF0ZW1lbnQgJiYgIW9wdC51bmluZGVudF9jaGFpbmVkX21ldGhvZHMpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVfcmVkdW5kYW50X2luZGVudGF0aW9uKG91dHB1dCwgcHJldmlvdXNfZmxhZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhcnRfb2Zfb2JqZWN0X3Byb3BlcnR5KCkge1xuICAgICAgICByZXR1cm4gZmxhZ3MucGFyZW50Lm1vZGUgPT09IE1PREUuT2JqZWN0TGl0ZXJhbCAmJiBmbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCAmJiAoXG4gICAgICAgICAgICAoZmxhZ3MubGFzdF90ZXh0ID09PSAnOicgJiYgZmxhZ3MudGVybmFyeV9kZXB0aCA9PT0gMCkgfHwgKGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBpbl9hcnJheShmbGFncy5sYXN0X3RleHQsIFsnZ2V0JywgJ3NldCddKSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJ0X29mX3N0YXRlbWVudCgpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgKGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBpbl9hcnJheShmbGFncy5sYXN0X3RleHQsIFsndmFyJywgJ2xldCcsICdjb25zdCddKSAmJiBjdXJyZW50X3Rva2VuLnR5cGUgPT09ICdUS19XT1JEJykgfHxcbiAgICAgICAgICAgIChsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgZmxhZ3MubGFzdF90ZXh0ID09PSAnZG8nKSB8fFxuICAgICAgICAgICAgKGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBpbl9hcnJheShmbGFncy5sYXN0X3RleHQsIG5ld2xpbmVfcmVzdHJpY3RlZF90b2tlbnMpICYmICFjdXJyZW50X3Rva2VuLndhbnRlZF9uZXdsaW5lKSB8fFxuICAgICAgICAgICAgKGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBmbGFncy5sYXN0X3RleHQgPT09ICdlbHNlJyAmJlxuICAgICAgICAgICAgICAgICEoY3VycmVudF90b2tlbi50eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ2lmJyAmJiAhY3VycmVudF90b2tlbi5jb21tZW50c19iZWZvcmUubGVuZ3RoKSkgfHxcbiAgICAgICAgICAgIChsYXN0X3R5cGUgPT09ICdUS19FTkRfRVhQUicgJiYgKHByZXZpb3VzX2ZsYWdzLm1vZGUgPT09IE1PREUuRm9ySW5pdGlhbGl6ZXIgfHwgcHJldmlvdXNfZmxhZ3MubW9kZSA9PT0gTU9ERS5Db25kaXRpb25hbCkpIHx8XG4gICAgICAgICAgICAobGFzdF90eXBlID09PSAnVEtfV09SRCcgJiYgZmxhZ3MubW9kZSA9PT0gTU9ERS5CbG9ja1N0YXRlbWVudCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5pbl9jYXNlICYmXG4gICAgICAgICAgICAgICAgIShjdXJyZW50X3Rva2VuLnRleHQgPT09ICctLScgfHwgY3VycmVudF90b2tlbi50ZXh0ID09PSAnKysnKSAmJlxuICAgICAgICAgICAgICAgIGxhc3RfbGFzdF90ZXh0ICE9PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAgICAgY3VycmVudF90b2tlbi50eXBlICE9PSAnVEtfV09SRCcgJiYgY3VycmVudF90b2tlbi50eXBlICE9PSAnVEtfUkVTRVJWRUQnKSB8fFxuICAgICAgICAgICAgKGZsYWdzLm1vZGUgPT09IE1PREUuT2JqZWN0TGl0ZXJhbCAmJiAoXG4gICAgICAgICAgICAgICAgKGZsYWdzLmxhc3RfdGV4dCA9PT0gJzonICYmIGZsYWdzLnRlcm5hcnlfZGVwdGggPT09IDApIHx8IChsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LCBbJ2dldCcsICdzZXQnXSkpKSlcbiAgICAgICAgKSB7XG5cbiAgICAgICAgICAgIHNldF9tb2RlKE1PREUuU3RhdGVtZW50KTtcbiAgICAgICAgICAgIGlmICghb3B0LnVuaW5kZW50X2NoYWluZWRfbWV0aG9kcykge1xuICAgICAgICAgICAgICAgIGluZGVudCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbiwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIC8vIElzc3VlICMyNzY6XG4gICAgICAgICAgICAvLyBJZiBzdGFydGluZyBhIG5ldyBzdGF0ZW1lbnQgd2l0aCBbaWYsIGZvciwgd2hpbGUsIGRvXSwgcHVzaCB0byBhIG5ldyBsaW5lLlxuICAgICAgICAgICAgLy8gaWYgKGEpIGlmIChiKSBpZihjKSBkKCk7IGVsc2UgZSgpOyBlbHNlIGYoKTtcbiAgICAgICAgICAgIGlmICghc3RhcnRfb2Zfb2JqZWN0X3Byb3BlcnR5KCkpIHtcbiAgICAgICAgICAgICAgICBhbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50X3Rva2VuLnR5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LCBbJ2RvJywgJ2ZvcicsICdpZicsICd3aGlsZSddKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhbGxfbGluZXNfc3RhcnRfd2l0aChsaW5lcywgYykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbGluZSA9IHRyaW0obGluZXNbaV0pO1xuICAgICAgICAgICAgaWYgKGxpbmUuY2hhckF0KDApICE9PSBjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVhY2hfbGluZV9tYXRjaGVzX2luZGVudChsaW5lcywgaW5kZW50KSB7XG4gICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgIGxlbiA9IGxpbmVzLmxlbmd0aCxcbiAgICAgICAgICAgIGxpbmU7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgICAgICAgIC8vIGFsbG93IGVtcHR5IGxpbmVzIHRvIHBhc3MgdGhyb3VnaFxuICAgICAgICAgICAgaWYgKGxpbmUgJiYgbGluZS5pbmRleE9mKGluZGVudCkgIT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNfc3BlY2lhbF93b3JkKHdvcmQpIHtcbiAgICAgICAgcmV0dXJuIGluX2FycmF5KHdvcmQsIFsnY2FzZScsICdyZXR1cm4nLCAnZG8nLCAnaWYnLCAndGhyb3cnLCAnZWxzZSddKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRfdG9rZW4ob2Zmc2V0KSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRva2VuX3BvcyArIChvZmZzZXQgfHwgMCk7XG4gICAgICAgIHJldHVybiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRva2Vucy5sZW5ndGgpID8gbnVsbCA6IHRva2Vuc1tpbmRleF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlX3N0YXJ0X2V4cHIoKSB7XG4gICAgICAgIC8vIFRoZSBjb25kaXRpb25hbCBzdGFydHMgdGhlIHN0YXRlbWVudCBpZiBhcHByb3ByaWF0ZS5cbiAgICAgICAgaWYgKCFzdGFydF9vZl9zdGF0ZW1lbnQoKSkge1xuICAgICAgICAgICAgaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5leHRfbW9kZSA9IE1PREUuRXhwcmVzc2lvbjtcbiAgICAgICAgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ1snKSB7XG5cbiAgICAgICAgICAgIGlmIChsYXN0X3R5cGUgPT09ICdUS19XT1JEJyB8fCBmbGFncy5sYXN0X3RleHQgPT09ICcpJykge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYXJyYXkgaW5kZXggc3BlY2lmaWVyLCBicmVhayBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgIC8vIGFbeF0sIGZuKClbeF1cbiAgICAgICAgICAgICAgICBpZiAobGFzdF90eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGluX2FycmF5KGZsYWdzLmxhc3RfdGV4dCwgdG9rZW5pemVyLmxpbmVfc3RhcnRlcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRfbW9kZShuZXh0X21vZGUpO1xuICAgICAgICAgICAgICAgIHByaW50X3Rva2VuKCk7XG4gICAgICAgICAgICAgICAgaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdC5zcGFjZV9pbl9wYXJlbikge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBuZXh0X21vZGUgPSBNT0RFLkFycmF5TGl0ZXJhbDtcbiAgICAgICAgICAgIGlmIChpc19hcnJheShmbGFncy5tb2RlKSkge1xuICAgICAgICAgICAgICAgIGlmIChmbGFncy5sYXN0X3RleHQgPT09ICdbJyB8fFxuICAgICAgICAgICAgICAgICAgICAoZmxhZ3MubGFzdF90ZXh0ID09PSAnLCcgJiYgKGxhc3RfbGFzdF90ZXh0ID09PSAnXScgfHwgbGFzdF9sYXN0X3RleHQgPT09ICd9JykpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIF0sIFsgZ29lcyB0byBuZXcgbGluZVxuICAgICAgICAgICAgICAgICAgICAvLyB9LCBbIGdvZXMgdG8gbmV3IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHQua2VlcF9hcnJheV9pbmRlbnRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnRfbmV3bGluZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobGFzdF90eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGZsYWdzLmxhc3RfdGV4dCA9PT0gJ2ZvcicpIHtcbiAgICAgICAgICAgICAgICBuZXh0X21vZGUgPSBNT0RFLkZvckluaXRpYWxpemVyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LCBbJ2lmJywgJ3doaWxlJ10pKSB7XG4gICAgICAgICAgICAgICAgbmV4dF9tb2RlID0gTU9ERS5Db25kaXRpb25hbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbmV4dF9tb2RlID0gTU9ERS5FeHByZXNzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZsYWdzLmxhc3RfdGV4dCA9PT0gJzsnIHx8IGxhc3RfdHlwZSA9PT0gJ1RLX1NUQVJUX0JMT0NLJykge1xuICAgICAgICAgICAgcHJpbnRfbmV3bGluZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX0VORF9FWFBSJyB8fCBsYXN0X3R5cGUgPT09ICdUS19TVEFSVF9FWFBSJyB8fCBsYXN0X3R5cGUgPT09ICdUS19FTkRfQkxPQ0snIHx8IGZsYWdzLmxhc3RfdGV4dCA9PT0gJy4nKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBDb25zaWRlciB3aGV0aGVyIGZvcmNpbmcgdGhpcyBpcyByZXF1aXJlZC4gIFJldmlldyBmYWlsaW5nIHRlc3RzIHdoZW4gcmVtb3ZlZC5cbiAgICAgICAgICAgIGFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbi53YW50ZWRfbmV3bGluZSk7XG4gICAgICAgICAgICAvLyBkbyBub3RoaW5nIG9uICgoIGFuZCApKCBhbmQgXVsgYW5kIF0oIGFuZCAuKFxuICAgICAgICB9IGVsc2UgaWYgKCEobGFzdF90eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJygnKSAmJiBsYXN0X3R5cGUgIT09ICdUS19XT1JEJyAmJiBsYXN0X3R5cGUgIT09ICdUS19PUEVSQVRPUicpIHtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKChsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgKGZsYWdzLmxhc3Rfd29yZCA9PT0gJ2Z1bmN0aW9uJyB8fCBmbGFncy5sYXN0X3dvcmQgPT09ICd0eXBlb2YnKSkgfHxcbiAgICAgICAgICAgIChmbGFncy5sYXN0X3RleHQgPT09ICcqJyAmJlxuICAgICAgICAgICAgICAgIChpbl9hcnJheShsYXN0X2xhc3RfdGV4dCwgWydmdW5jdGlvbicsICd5aWVsZCddKSB8fFxuICAgICAgICAgICAgICAgICAgICAoZmxhZ3MubW9kZSA9PT0gTU9ERS5PYmplY3RMaXRlcmFsICYmIGluX2FycmF5KGxhc3RfbGFzdF90ZXh0LCBbJ3snLCAnLCddKSkpKSkge1xuICAgICAgICAgICAgLy8gZnVuY3Rpb24oKSB2cyBmdW5jdGlvbiAoKVxuICAgICAgICAgICAgLy8geWllbGQqKCkgdnMgeWllbGQqICgpXG4gICAgICAgICAgICAvLyBmdW5jdGlvbiooKSB2cyBmdW5jdGlvbiogKClcbiAgICAgICAgICAgIGlmIChvcHQuc3BhY2VfYWZ0ZXJfYW5vbl9mdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiAoaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LCB0b2tlbml6ZXIubGluZV9zdGFydGVycykgfHwgZmxhZ3MubGFzdF90ZXh0ID09PSAnY2F0Y2gnKSkge1xuICAgICAgICAgICAgaWYgKG9wdC5zcGFjZV9iZWZvcmVfY29uZGl0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNob3VsZCBiZSBhIHNwYWNlIGJldHdlZW4gYXdhaXQgYW5kIGFuIElJRkUsIG9yIGFzeW5jIGFuZCBhbiBhcnJvdyBmdW5jdGlvblxuICAgICAgICBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnKCcgJiYgbGFzdF90eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGluX2FycmF5KGZsYWdzLmxhc3Rfd29yZCwgWydhd2FpdCcsICdhc3luYyddKSkge1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdXBwb3J0IG9mIHRoaXMga2luZCBvZiBuZXdsaW5lIHByZXNlcnZhdGlvbi5cbiAgICAgICAgLy8gYSA9IChiICYmXG4gICAgICAgIC8vICAgICAoYyB8fCBkKSk7XG4gICAgICAgIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICcoJykge1xuICAgICAgICAgICAgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX0VRVUFMUycgfHwgbGFzdF90eXBlID09PSAnVEtfT1BFUkFUT1InKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdGFydF9vZl9vYmplY3RfcHJvcGVydHkoKSkge1xuICAgICAgICAgICAgICAgICAgICBhbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3VwcG9ydCBwcmVzZXJ2aW5nIHdyYXBwZWQgYXJyb3cgZnVuY3Rpb24gZXhwcmVzc2lvbnNcbiAgICAgICAgLy8gYS5iKCdjJyxcbiAgICAgICAgLy8gICAgICgpID0+IGQuZVxuICAgICAgICAvLyApXG4gICAgICAgIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICcoJyAmJiBsYXN0X3R5cGUgIT09ICdUS19XT1JEJyAmJiBsYXN0X3R5cGUgIT09ICdUS19SRVNFUlZFRCcpIHtcbiAgICAgICAgICAgIGFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldF9tb2RlKG5leHRfbW9kZSk7XG4gICAgICAgIHByaW50X3Rva2VuKCk7XG4gICAgICAgIGlmIChvcHQuc3BhY2VfaW5fcGFyZW4pIHtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW4gYWxsIGNhc2VzLCBpZiB3ZSBuZXdsaW5lIHdoaWxlIGluc2lkZSBhbiBleHByZXNzaW9uIGl0IHNob3VsZCBiZSBpbmRlbnRlZC5cbiAgICAgICAgaW5kZW50KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlX2VuZF9leHByKCkge1xuICAgICAgICAvLyBzdGF0ZW1lbnRzIGluc2lkZSBleHByZXNzaW9ucyBhcmUgbm90IHZhbGlkIHN5bnRheCwgYnV0Li4uXG4gICAgICAgIC8vIHN0YXRlbWVudHMgbXVzdCBhbGwgYmUgY2xvc2VkIHdoZW4gdGhlaXIgY29udGFpbmVyIGNsb3Nlc1xuICAgICAgICB3aGlsZSAoZmxhZ3MubW9kZSA9PT0gTU9ERS5TdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgIHJlc3RvcmVfbW9kZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4pO1xuXG4gICAgICAgIGlmIChmbGFncy5tdWx0aWxpbmVfZnJhbWUpIHtcbiAgICAgICAgICAgIGFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbi50ZXh0ID09PSAnXScgJiYgaXNfYXJyYXkoZmxhZ3MubW9kZSkgJiYgIW9wdC5rZWVwX2FycmF5X2luZGVudGF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHQuc3BhY2VfaW5fcGFyZW4pIHtcbiAgICAgICAgICAgIGlmIChsYXN0X3R5cGUgPT09ICdUS19TVEFSVF9FWFBSJyAmJiAhb3B0LnNwYWNlX2luX2VtcHR5X3BhcmVuKSB7XG4gICAgICAgICAgICAgICAgLy8gKCkgW10gbm8gaW5uZXIgc3BhY2UgaW4gZW1wdHkgcGFyZW5zIGxpa2UgdGhlc2UsIGV2ZXIsIHJlZiAjMzIwXG4gICAgICAgICAgICAgICAgb3V0cHV0LnRyaW0oKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICddJyAmJiBvcHQua2VlcF9hcnJheV9pbmRlbnRhdGlvbikge1xuICAgICAgICAgICAgcHJpbnRfdG9rZW4oKTtcbiAgICAgICAgICAgIHJlc3RvcmVfbW9kZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdG9yZV9tb2RlKCk7XG4gICAgICAgICAgICBwcmludF90b2tlbigpO1xuICAgICAgICB9XG4gICAgICAgIHJlbW92ZV9yZWR1bmRhbnRfaW5kZW50YXRpb24ob3V0cHV0LCBwcmV2aW91c19mbGFncyk7XG5cbiAgICAgICAgLy8gZG8ge30gd2hpbGUgKCkgLy8gbm8gc3RhdGVtZW50IHJlcXVpcmVkIGFmdGVyXG4gICAgICAgIGlmIChmbGFncy5kb193aGlsZSAmJiBwcmV2aW91c19mbGFncy5tb2RlID09PSBNT0RFLkNvbmRpdGlvbmFsKSB7XG4gICAgICAgICAgICBwcmV2aW91c19mbGFncy5tb2RlID0gTU9ERS5FeHByZXNzaW9uO1xuICAgICAgICAgICAgZmxhZ3MuZG9fYmxvY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIGZsYWdzLmRvX3doaWxlID0gZmFsc2U7XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZV9zdGFydF9ibG9jaygpIHtcbiAgICAgICAgaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4pO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYSBPYmplY3RMaXRlcmFsXG4gICAgICAgIHZhciBuZXh0X3Rva2VuID0gZ2V0X3Rva2VuKDEpO1xuICAgICAgICB2YXIgc2Vjb25kX3Rva2VuID0gZ2V0X3Rva2VuKDIpO1xuICAgICAgICBpZiAoc2Vjb25kX3Rva2VuICYmIChcbiAgICAgICAgICAgICAgICAoaW5fYXJyYXkoc2Vjb25kX3Rva2VuLnRleHQsIFsnOicsICcsJ10pICYmIGluX2FycmF5KG5leHRfdG9rZW4udHlwZSwgWydUS19TVFJJTkcnLCAnVEtfV09SRCcsICdUS19SRVNFUlZFRCddKSkgfHxcbiAgICAgICAgICAgICAgICAoaW5fYXJyYXkobmV4dF90b2tlbi50ZXh0LCBbJ2dldCcsICdzZXQnLCAnLi4uJ10pICYmIGluX2FycmF5KHNlY29uZF90b2tlbi50eXBlLCBbJ1RLX1dPUkQnLCAnVEtfUkVTRVJWRUQnXSkpXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCBzdXBwb3J0IFR5cGVTY3JpcHQsYnV0IHdlIGRpZG4ndCBicmVhayBpdCBmb3IgYSB2ZXJ5IGxvbmcgdGltZS5cbiAgICAgICAgICAgIC8vIFdlJ2xsIHRyeSB0byBrZWVwIG5vdCBicmVha2luZyBpdC5cbiAgICAgICAgICAgIGlmICghaW5fYXJyYXkobGFzdF9sYXN0X3RleHQsIFsnY2xhc3MnLCAnaW50ZXJmYWNlJ10pKSB7XG4gICAgICAgICAgICAgICAgc2V0X21vZGUoTU9ERS5PYmplY3RMaXRlcmFsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0X21vZGUoTU9ERS5CbG9ja1N0YXRlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdF90eXBlID09PSAnVEtfT1BFUkFUT1InICYmIGZsYWdzLmxhc3RfdGV4dCA9PT0gJz0+Jykge1xuICAgICAgICAgICAgLy8gYXJyb3cgZnVuY3Rpb246IChwYXJhbTEsIHBhcmFtTikgPT4geyBzdGF0ZW1lbnRzIH1cbiAgICAgICAgICAgIHNldF9tb2RlKE1PREUuQmxvY2tTdGF0ZW1lbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGluX2FycmF5KGxhc3RfdHlwZSwgWydUS19FUVVBTFMnLCAnVEtfU1RBUlRfRVhQUicsICdUS19DT01NQScsICdUS19PUEVSQVRPUiddKSB8fFxuICAgICAgICAgICAgKGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBpbl9hcnJheShmbGFncy5sYXN0X3RleHQsIFsncmV0dXJuJywgJ3Rocm93JywgJ2ltcG9ydCcsICdkZWZhdWx0J10pKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIERldGVjdGluZyBzaG9ydGhhbmQgZnVuY3Rpb24gc3ludGF4IGlzIGRpZmZpY3VsdCBieSBzY2FubmluZyBmb3J3YXJkLFxuICAgICAgICAgICAgLy8gICAgIHNvIGNoZWNrIHRoZSBzdXJyb3VuZGluZyBjb250ZXh0LlxuICAgICAgICAgICAgLy8gSWYgdGhlIGJsb2NrIGlzIGJlaW5nIHJldHVybmVkLCBpbXBvcnRlZCwgZXhwb3J0IGRlZmF1bHQsIHBhc3NlZCBhcyBhcmcsXG4gICAgICAgICAgICAvLyAgICAgYXNzaWduZWQgd2l0aCA9IG9yIGFzc2lnbmVkIGluIGEgbmVzdGVkIG9iamVjdCwgdHJlYXQgYXMgYW4gT2JqZWN0TGl0ZXJhbC5cbiAgICAgICAgICAgIHNldF9tb2RlKE1PREUuT2JqZWN0TGl0ZXJhbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRfbW9kZShNT0RFLkJsb2NrU3RhdGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbXB0eV9icmFjZXMgPSAhbmV4dF90b2tlbi5jb21tZW50c19iZWZvcmUubGVuZ3RoICYmIG5leHRfdG9rZW4udGV4dCA9PT0gJ30nO1xuICAgICAgICB2YXIgZW1wdHlfYW5vbnltb3VzX2Z1bmN0aW9uID0gZW1wdHlfYnJhY2VzICYmIGZsYWdzLmxhc3Rfd29yZCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgbGFzdF90eXBlID09PSAnVEtfRU5EX0VYUFInO1xuXG4gICAgICAgIGlmIChvcHQuYnJhY2VfcHJlc2VydmVfaW5saW5lKSAvLyBjaGVjayBmb3IgaW5saW5lLCBzZXQgaW5saW5lX2ZyYW1lIGlmIHNvXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIHNlYXJjaCBmb3J3YXJkIGZvciBhIG5ld2xpbmUgd2FudGVkIGluc2lkZSB0aGlzIGJsb2NrXG4gICAgICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICAgICAgdmFyIGNoZWNrX3Rva2VuID0gbnVsbDtcbiAgICAgICAgICAgIGZsYWdzLmlubGluZV9mcmFtZSA9IHRydWU7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgICAgICAgICBjaGVja190b2tlbiA9IGdldF90b2tlbihpbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrX3Rva2VuLndhbnRlZF9uZXdsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmlubGluZV9mcmFtZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChjaGVja190b2tlbi50eXBlICE9PSAnVEtfRU9GJyAmJlxuICAgICAgICAgICAgICAgICEoY2hlY2tfdG9rZW4udHlwZSA9PT0gJ1RLX0VORF9CTE9DSycgJiYgY2hlY2tfdG9rZW4ub3BlbmVkID09PSBjdXJyZW50X3Rva2VuKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKG9wdC5icmFjZV9zdHlsZSA9PT0gXCJleHBhbmRcIiB8fFxuICAgICAgICAgICAgICAgIChvcHQuYnJhY2Vfc3R5bGUgPT09IFwibm9uZVwiICYmIGN1cnJlbnRfdG9rZW4ud2FudGVkX25ld2xpbmUpKSAmJlxuICAgICAgICAgICAgIWZsYWdzLmlubGluZV9mcmFtZSkge1xuICAgICAgICAgICAgaWYgKGxhc3RfdHlwZSAhPT0gJ1RLX09QRVJBVE9SJyAmJlxuICAgICAgICAgICAgICAgIChlbXB0eV9hbm9ueW1vdXNfZnVuY3Rpb24gfHxcbiAgICAgICAgICAgICAgICAgICAgbGFzdF90eXBlID09PSAnVEtfRVFVQUxTJyB8fFxuICAgICAgICAgICAgICAgICAgICAobGFzdF90eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGlzX3NwZWNpYWxfd29yZChmbGFncy5sYXN0X3RleHQpICYmIGZsYWdzLmxhc3RfdGV4dCAhPT0gJ2Vsc2UnKSkpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJpbnRfbmV3bGluZShmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7IC8vIGNvbGxhcHNlIHx8IGlubGluZV9mcmFtZVxuICAgICAgICAgICAgaWYgKGlzX2FycmF5KHByZXZpb3VzX2ZsYWdzLm1vZGUpICYmIChsYXN0X3R5cGUgPT09ICdUS19TVEFSVF9FWFBSJyB8fCBsYXN0X3R5cGUgPT09ICdUS19DT01NQScpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX0NPTU1BJyB8fCBvcHQuc3BhY2VfaW5fcGFyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX0NPTU1BJyB8fCAobGFzdF90eXBlID09PSAnVEtfU1RBUlRfRVhQUicgJiYgZmxhZ3MuaW5saW5lX2ZyYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBhbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzX2ZsYWdzLm11bHRpbGluZV9mcmFtZSA9IHByZXZpb3VzX2ZsYWdzLm11bHRpbGluZV9mcmFtZSB8fCBmbGFncy5tdWx0aWxpbmVfZnJhbWU7XG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLm11bHRpbGluZV9mcmFtZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0X3R5cGUgIT09ICdUS19PUEVSQVRPUicgJiYgbGFzdF90eXBlICE9PSAnVEtfU1RBUlRfRVhQUicpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdF90eXBlID09PSAnVEtfU1RBUlRfQkxPQ0snICYmICFmbGFncy5pbmxpbmVfZnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRfbmV3bGluZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcmludF90b2tlbigpO1xuICAgICAgICBpbmRlbnQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVfZW5kX2Jsb2NrKCkge1xuICAgICAgICAvLyBzdGF0ZW1lbnRzIG11c3QgYWxsIGJlIGNsb3NlZCB3aGVuIHRoZWlyIGNvbnRhaW5lciBjbG9zZXNcbiAgICAgICAgaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4pO1xuXG4gICAgICAgIHdoaWxlIChmbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCkge1xuICAgICAgICAgICAgcmVzdG9yZV9tb2RlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZW1wdHlfYnJhY2VzID0gbGFzdF90eXBlID09PSAnVEtfU1RBUlRfQkxPQ0snO1xuXG4gICAgICAgIGlmIChmbGFncy5pbmxpbmVfZnJhbWUgJiYgIWVtcHR5X2JyYWNlcykgeyAvLyB0cnkgaW5saW5lX2ZyYW1lIChvbmx5IHNldCBpZiBvcHQuYnJhY2VzLXByZXNlcnZlLWlubGluZSkgZmlyc3RcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdC5icmFjZV9zdHlsZSA9PT0gXCJleHBhbmRcIikge1xuICAgICAgICAgICAgaWYgKCFlbXB0eV9icmFjZXMpIHtcbiAgICAgICAgICAgICAgICBwcmludF9uZXdsaW5lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBza2lwIHt9XG4gICAgICAgICAgICBpZiAoIWVtcHR5X2JyYWNlcykge1xuICAgICAgICAgICAgICAgIGlmIChpc19hcnJheShmbGFncy5tb2RlKSAmJiBvcHQua2VlcF9hcnJheV9pbmRlbnRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBSRUFMTFkgbmVlZCBhIG5ld2xpbmUgaGVyZSwgYnV0IG5ld2xpbmVyIHdvdWxkIHNraXAgdGhhdFxuICAgICAgICAgICAgICAgICAgICBvcHQua2VlcF9hcnJheV9pbmRlbnRhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBwcmludF9uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgICAgIG9wdC5rZWVwX2FycmF5X2luZGVudGF0aW9uID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW50X25ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdG9yZV9tb2RlKCk7XG4gICAgICAgIHByaW50X3Rva2VuKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlX3dvcmQoKSB7XG4gICAgICAgIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09ICdUS19SRVNFUlZFRCcpIHtcbiAgICAgICAgICAgIGlmIChpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsIFsnc2V0JywgJ2dldCddKSAmJiBmbGFncy5tb2RlICE9PSBNT0RFLk9iamVjdExpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50X3Rva2VuLnR5cGUgPSAnVEtfV09SRCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgWydhcycsICdmcm9tJ10pICYmICFmbGFncy5pbXBvcnRfYmxvY2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50X3Rva2VuLnR5cGUgPSAnVEtfV09SRCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZsYWdzLm1vZGUgPT09IE1PREUuT2JqZWN0TGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0X3Rva2VuID0gZ2V0X3Rva2VuKDEpO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0X3Rva2VuLnRleHQgPT09ICc6Jykge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50X3Rva2VuLnR5cGUgPSAnVEtfV09SRCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXJ0X29mX3N0YXRlbWVudCgpKSB7XG4gICAgICAgICAgICAvLyBUaGUgY29uZGl0aW9uYWwgc3RhcnRzIHRoZSBzdGF0ZW1lbnQgaWYgYXBwcm9wcmlhdGUuXG4gICAgICAgICAgICBpZiAobGFzdF90eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGluX2FycmF5KGZsYWdzLmxhc3RfdGV4dCwgWyd2YXInLCAnbGV0JywgJ2NvbnN0J10pICYmIGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gJ1RLX1dPUkQnKSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MuZGVjbGFyYXRpb25fc3RhdGVtZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLndhbnRlZF9uZXdsaW5lICYmICFpc19leHByZXNzaW9uKGZsYWdzLm1vZGUpICYmXG4gICAgICAgICAgICAobGFzdF90eXBlICE9PSAnVEtfT1BFUkFUT1InIHx8IChmbGFncy5sYXN0X3RleHQgPT09ICctLScgfHwgZmxhZ3MubGFzdF90ZXh0ID09PSAnKysnKSkgJiZcbiAgICAgICAgICAgIGxhc3RfdHlwZSAhPT0gJ1RLX0VRVUFMUycgJiZcbiAgICAgICAgICAgIChvcHQucHJlc2VydmVfbmV3bGluZXMgfHwgIShsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LCBbJ3ZhcicsICdsZXQnLCAnY29uc3QnLCAnc2V0JywgJ2dldCddKSkpKSB7XG4gICAgICAgICAgICBoYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG4gICAgICAgICAgICBwcmludF9uZXdsaW5lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmxhZ3MuZG9fYmxvY2sgJiYgIWZsYWdzLmRvX3doaWxlKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ3doaWxlJykge1xuICAgICAgICAgICAgICAgIC8vIGRvIHt9ICMjIHdoaWxlICgpXG4gICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgcHJpbnRfdG9rZW4oKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmbGFncy5kb193aGlsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkbyB7fSBzaG91bGQgYWx3YXlzIGhhdmUgd2hpbGUgYXMgdGhlIG5leHQgd29yZC5cbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBkb24ndCBzZWUgdGhlIGV4cGVjdGVkIHdoaWxlLCByZWNvdmVyXG4gICAgICAgICAgICAgICAgcHJpbnRfbmV3bGluZSgpO1xuICAgICAgICAgICAgICAgIGZsYWdzLmRvX2Jsb2NrID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBtYXkgYmUgZm9sbG93ZWQgYnkgZWxzZSwgb3Igbm90XG4gICAgICAgIC8vIEJhcmUvaW5saW5lIGlmcyBhcmUgdHJpY2t5XG4gICAgICAgIC8vIE5lZWQgdG8gdW53aW5kIHRoZSBtb2RlcyBjb3JyZWN0bHk6IGlmIChhKSBpZiAoYikgYygpOyBlbHNlIGQoKTsgZWxzZSBlKCk7XG4gICAgICAgIGlmIChmbGFncy5pZl9ibG9jaykge1xuICAgICAgICAgICAgaWYgKCFmbGFncy5lbHNlX2Jsb2NrICYmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgY3VycmVudF90b2tlbi50ZXh0ID09PSAnZWxzZScpKSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MuZWxzZV9ibG9jayA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdoaWxlIChmbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXN0b3JlX21vZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmxhZ3MuaWZfYmxvY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmbGFncy5lbHNlX2Jsb2NrID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICdjYXNlJyB8fCAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnZGVmYXVsdCcgJiYgZmxhZ3MuaW5fY2FzZV9zdGF0ZW1lbnQpKSkge1xuICAgICAgICAgICAgcHJpbnRfbmV3bGluZSgpO1xuICAgICAgICAgICAgaWYgKGZsYWdzLmNhc2VfYm9keSB8fCBvcHQuanNsaW50X2hhcHB5KSB7XG4gICAgICAgICAgICAgICAgLy8gc3dpdGNoIGNhc2VzIGZvbGxvd2luZyBvbmUgYW5vdGhlclxuICAgICAgICAgICAgICAgIGRlaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgZmxhZ3MuY2FzZV9ib2R5ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmludF90b2tlbigpO1xuICAgICAgICAgICAgZmxhZ3MuaW5fY2FzZSA9IHRydWU7XG4gICAgICAgICAgICBmbGFncy5pbl9jYXNlX3N0YXRlbWVudCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGFzdF90eXBlID09PSAnVEtfQ09NTUEnIHx8IGxhc3RfdHlwZSA9PT0gJ1RLX1NUQVJUX0VYUFInIHx8IGxhc3RfdHlwZSA9PT0gJ1RLX0VRVUFMUycgfHwgbGFzdF90eXBlID09PSAnVEtfT1BFUkFUT1InKSB7XG4gICAgICAgICAgICBpZiAoIXN0YXJ0X29mX29iamVjdF9wcm9wZXJ0eSgpKSB7XG4gICAgICAgICAgICAgICAgYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBjdXJyZW50X3Rva2VuLnRleHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmIChpbl9hcnJheShmbGFncy5sYXN0X3RleHQsIFsnfScsICc7J10pIHx8XG4gICAgICAgICAgICAgICAgKG91dHB1dC5qdXN0X2FkZGVkX25ld2xpbmUoKSAmJiAhKGluX2FycmF5KGZsYWdzLmxhc3RfdGV4dCwgWycoJywgJ1snLCAneycsICc6JywgJz0nLCAnLCddKSB8fCBsYXN0X3R5cGUgPT09ICdUS19PUEVSQVRPUicpKSkge1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGVyZSBpcyBhIG5pY2UgY2xlYW4gc3BhY2Ugb2YgYXQgbGVhc3Qgb25lIGJsYW5rIGxpbmVcbiAgICAgICAgICAgICAgICAvLyBiZWZvcmUgYSBuZXcgZnVuY3Rpb24gZGVmaW5pdGlvblxuICAgICAgICAgICAgICAgIGlmICghb3V0cHV0Lmp1c3RfYWRkZWRfYmxhbmtsaW5lKCkgJiYgIWN1cnJlbnRfdG9rZW4uY29tbWVudHNfYmVmb3JlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBwcmludF9uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgICAgIHByaW50X25ld2xpbmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyB8fCBsYXN0X3R5cGUgPT09ICdUS19XT1JEJykge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LCBbJ2dldCcsICdzZXQnLCAnbmV3JywgJ2V4cG9ydCcsICdhc3luYyddKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LCBuZXdsaW5lX3Jlc3RyaWN0ZWRfdG9rZW5zKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgZmxhZ3MubGFzdF90ZXh0ID09PSAnZGVmYXVsdCcgJiYgbGFzdF9sYXN0X3RleHQgPT09ICdleHBvcnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW50X25ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX09QRVJBVE9SJyB8fCBmbGFncy5sYXN0X3RleHQgPT09ICc9Jykge1xuICAgICAgICAgICAgICAgIC8vIGZvbyA9IGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFmbGFncy5tdWx0aWxpbmVfZnJhbWUgJiYgKGlzX2V4cHJlc3Npb24oZmxhZ3MubW9kZSkgfHwgaXNfYXJyYXkoZmxhZ3MubW9kZSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gKGZ1bmN0aW9uXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByaW50X25ld2xpbmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJpbnRfdG9rZW4oKTtcbiAgICAgICAgICAgIGZsYWdzLmxhc3Rfd29yZCA9IGN1cnJlbnRfdG9rZW4udGV4dDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZWZpeCA9ICdOT05FJztcblxuICAgICAgICBpZiAobGFzdF90eXBlID09PSAnVEtfRU5EX0JMT0NLJykge1xuXG4gICAgICAgICAgICBpZiAocHJldmlvdXNfZmxhZ3MuaW5saW5lX2ZyYW1lKSB7XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gJ1NQQUNFJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIShjdXJyZW50X3Rva2VuLnR5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LCBbJ2Vsc2UnLCAnY2F0Y2gnLCAnZmluYWxseScsICdmcm9tJ10pKSkge1xuICAgICAgICAgICAgICAgIHByZWZpeCA9ICdORVdMSU5FJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdC5icmFjZV9zdHlsZSA9PT0gXCJleHBhbmRcIiB8fFxuICAgICAgICAgICAgICAgICAgICBvcHQuYnJhY2Vfc3R5bGUgPT09IFwiZW5kLWV4cGFuZFwiIHx8XG4gICAgICAgICAgICAgICAgICAgIChvcHQuYnJhY2Vfc3R5bGUgPT09IFwibm9uZVwiICYmIGN1cnJlbnRfdG9rZW4ud2FudGVkX25ld2xpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWZpeCA9ICdORVdMSU5FJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmVmaXggPSAnU1BBQ0UnO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdF90eXBlID09PSAnVEtfU0VNSUNPTE9OJyAmJiBmbGFncy5tb2RlID09PSBNT0RFLkJsb2NrU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBTaG91bGQgdGhpcyBiZSBmb3IgU1RBVEVNRU5UIGFzIHdlbGw/XG4gICAgICAgICAgICBwcmVmaXggPSAnTkVXTElORSc7XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdF90eXBlID09PSAnVEtfU0VNSUNPTE9OJyAmJiBpc19leHByZXNzaW9uKGZsYWdzLm1vZGUpKSB7XG4gICAgICAgICAgICBwcmVmaXggPSAnU1BBQ0UnO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX1NUUklORycpIHtcbiAgICAgICAgICAgIHByZWZpeCA9ICdORVdMSU5FJztcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgfHwgbGFzdF90eXBlID09PSAnVEtfV09SRCcgfHxcbiAgICAgICAgICAgIChmbGFncy5sYXN0X3RleHQgPT09ICcqJyAmJlxuICAgICAgICAgICAgICAgIChpbl9hcnJheShsYXN0X2xhc3RfdGV4dCwgWydmdW5jdGlvbicsICd5aWVsZCddKSB8fFxuICAgICAgICAgICAgICAgICAgICAoZmxhZ3MubW9kZSA9PT0gTU9ERS5PYmplY3RMaXRlcmFsICYmIGluX2FycmF5KGxhc3RfbGFzdF90ZXh0LCBbJ3snLCAnLCddKSkpKSkge1xuICAgICAgICAgICAgcHJlZml4ID0gJ1NQQUNFJztcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0X3R5cGUgPT09ICdUS19TVEFSVF9CTE9DSycpIHtcbiAgICAgICAgICAgIGlmIChmbGFncy5pbmxpbmVfZnJhbWUpIHtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSAnU1BBQ0UnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSAnTkVXTElORSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdF90eXBlID09PSAnVEtfRU5EX0VYUFInKSB7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgIHByZWZpeCA9ICdORVdMSU5FJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LCB0b2tlbml6ZXIubGluZV9zdGFydGVycykgJiYgZmxhZ3MubGFzdF90ZXh0ICE9PSAnKScpIHtcbiAgICAgICAgICAgIGlmIChmbGFncy5pbmxpbmVfZnJhbWUgfHwgZmxhZ3MubGFzdF90ZXh0ID09PSAnZWxzZScgfHwgZmxhZ3MubGFzdF90ZXh0ID09PSAnZXhwb3J0Jykge1xuICAgICAgICAgICAgICAgIHByZWZpeCA9ICdTUEFDRSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZWZpeCA9ICdORVdMSU5FJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsIFsnZWxzZScsICdjYXRjaCcsICdmaW5hbGx5J10pKSB7XG4gICAgICAgICAgICBpZiAoKCEobGFzdF90eXBlID09PSAnVEtfRU5EX0JMT0NLJyAmJiBwcmV2aW91c19mbGFncy5tb2RlID09PSBNT0RFLkJsb2NrU3RhdGVtZW50KSB8fFxuICAgICAgICAgICAgICAgICAgICBvcHQuYnJhY2Vfc3R5bGUgPT09IFwiZXhwYW5kXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgb3B0LmJyYWNlX3N0eWxlID09PSBcImVuZC1leHBhbmRcIiB8fFxuICAgICAgICAgICAgICAgICAgICAob3B0LmJyYWNlX3N0eWxlID09PSBcIm5vbmVcIiAmJiBjdXJyZW50X3Rva2VuLndhbnRlZF9uZXdsaW5lKSkgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW5saW5lX2ZyYW1lKSB7XG4gICAgICAgICAgICAgICAgcHJpbnRfbmV3bGluZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQudHJpbSh0cnVlKTtcbiAgICAgICAgICAgICAgICB2YXIgbGluZSA9IG91dHB1dC5jdXJyZW50X2xpbmU7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgdHJpbW1lZCBhbmQgdGhlcmUncyBzb21ldGhpbmcgb3RoZXIgdGhhbiBhIGNsb3NlIGJsb2NrIGJlZm9yZSB1c1xuICAgICAgICAgICAgICAgIC8vIHB1dCBhIG5ld2xpbmUgYmFjayBpbi4gIEhhbmRsZXMgJ30gLy8gY29tbWVudCcgc2NlbmFyaW8uXG4gICAgICAgICAgICAgICAgaWYgKGxpbmUubGFzdCgpICE9PSAnfScpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRfbmV3bGluZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChwcmVmaXggPT09ICdORVdMSU5FJykge1xuICAgICAgICAgICAgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBpc19zcGVjaWFsX3dvcmQoZmxhZ3MubGFzdF90ZXh0KSkge1xuICAgICAgICAgICAgICAgIC8vIG5vIG5ld2xpbmUgYmV0d2VlbiAncmV0dXJuIG5ubidcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGFzdF90eXBlICE9PSAnVEtfRU5EX0VYUFInKSB7XG4gICAgICAgICAgICAgICAgaWYgKChsYXN0X3R5cGUgIT09ICdUS19TVEFSVF9FWFBSJyB8fCAhKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsIFsndmFyJywgJ2xldCcsICdjb25zdCddKSkpICYmIGZsYWdzLmxhc3RfdGV4dCAhPT0gJzonKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gZm9yY2UgbmV3bGluZSBvbiAndmFyJzogZm9yICh2YXIgeCA9IDAuLi4pXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgY3VycmVudF90b2tlbi50ZXh0ID09PSAnaWYnICYmIGZsYWdzLmxhc3RfdGV4dCA9PT0gJ2Vsc2UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBubyBuZXdsaW5lIGZvciB9IGVsc2UgaWYge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmludF9uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsIHRva2VuaXplci5saW5lX3N0YXJ0ZXJzKSAmJiBmbGFncy5sYXN0X3RleHQgIT09ICcpJykge1xuICAgICAgICAgICAgICAgIHByaW50X25ld2xpbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChmbGFncy5tdWx0aWxpbmVfZnJhbWUgJiYgaXNfYXJyYXkoZmxhZ3MubW9kZSkgJiYgZmxhZ3MubGFzdF90ZXh0ID09PSAnLCcgJiYgbGFzdF9sYXN0X3RleHQgPT09ICd9Jykge1xuICAgICAgICAgICAgcHJpbnRfbmV3bGluZSgpOyAvLyB9LCBpbiBsaXN0cyBnZXQgYSBuZXdsaW5lIHRyZWF0bWVudFxuICAgICAgICB9IGVsc2UgaWYgKHByZWZpeCA9PT0gJ1NQQUNFJykge1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcHJpbnRfdG9rZW4oKTtcbiAgICAgICAgZmxhZ3MubGFzdF93b3JkID0gY3VycmVudF90b2tlbi50ZXh0O1xuXG4gICAgICAgIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09ICdUS19SRVNFUlZFRCcpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICdkbycpIHtcbiAgICAgICAgICAgICAgICBmbGFncy5kb19ibG9jayA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ2lmJykge1xuICAgICAgICAgICAgICAgIGZsYWdzLmlmX2Jsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnaW1wb3J0Jykge1xuICAgICAgICAgICAgICAgIGZsYWdzLmltcG9ydF9ibG9jayA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZsYWdzLmltcG9ydF9ibG9jayAmJiBjdXJyZW50X3Rva2VuLnR5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgY3VycmVudF90b2tlbi50ZXh0ID09PSAnZnJvbScpIHtcbiAgICAgICAgICAgICAgICBmbGFncy5pbXBvcnRfYmxvY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZV9zZW1pY29sb24oKSB7XG4gICAgICAgIGlmIChzdGFydF9vZl9zdGF0ZW1lbnQoKSkge1xuICAgICAgICAgICAgLy8gVGhlIGNvbmRpdGlvbmFsIHN0YXJ0cyB0aGUgc3RhdGVtZW50IGlmIGFwcHJvcHJpYXRlLlxuICAgICAgICAgICAgLy8gU2VtaWNvbG9uIGNhbiBiZSB0aGUgc3RhcnQgKGFuZCBlbmQpIG9mIGEgc3RhdGVtZW50XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV4dF90b2tlbiA9IGdldF90b2tlbigxKTtcbiAgICAgICAgd2hpbGUgKGZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50ICYmXG4gICAgICAgICAgICAhKGZsYWdzLmlmX2Jsb2NrICYmIG5leHRfdG9rZW4gJiYgbmV4dF90b2tlbi50eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIG5leHRfdG9rZW4udGV4dCA9PT0gJ2Vsc2UnKSAmJlxuICAgICAgICAgICAgIWZsYWdzLmRvX2Jsb2NrKSB7XG4gICAgICAgICAgICByZXN0b3JlX21vZGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhY2t5IGJ1dCBlZmZlY3RpdmUgZm9yIHRoZSBtb21lbnRcbiAgICAgICAgaWYgKGZsYWdzLmltcG9ydF9ibG9jaykge1xuICAgICAgICAgICAgZmxhZ3MuaW1wb3J0X2Jsb2NrID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcHJpbnRfdG9rZW4oKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVfc3RyaW5nKCkge1xuICAgICAgICBpZiAoc3RhcnRfb2Zfc3RhdGVtZW50KCkpIHtcbiAgICAgICAgICAgIC8vIFRoZSBjb25kaXRpb25hbCBzdGFydHMgdGhlIHN0YXRlbWVudCBpZiBhcHByb3ByaWF0ZS5cbiAgICAgICAgICAgIC8vIE9uZSBkaWZmZXJlbmNlIC0gc3RyaW5ncyB3YW50IGF0IGxlYXN0IGEgc3BhY2UgYmVmb3JlXG4gICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuKTtcbiAgICAgICAgICAgIGlmIChsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgfHwgbGFzdF90eXBlID09PSAnVEtfV09SRCcgfHwgZmxhZ3MuaW5saW5lX2ZyYW1lKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX0NPTU1BJyB8fCBsYXN0X3R5cGUgPT09ICdUS19TVEFSVF9FWFBSJyB8fCBsYXN0X3R5cGUgPT09ICdUS19FUVVBTFMnIHx8IGxhc3RfdHlwZSA9PT0gJ1RLX09QRVJBVE9SJykge1xuICAgICAgICAgICAgICAgIGlmICghc3RhcnRfb2Zfb2JqZWN0X3Byb3BlcnR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJpbnRfbmV3bGluZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByaW50X3Rva2VuKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlX2VxdWFscygpIHtcbiAgICAgICAgaWYgKHN0YXJ0X29mX3N0YXRlbWVudCgpKSB7XG4gICAgICAgICAgICAvLyBUaGUgY29uZGl0aW9uYWwgc3RhcnRzIHRoZSBzdGF0ZW1lbnQgaWYgYXBwcm9wcmlhdGUuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmxhZ3MuZGVjbGFyYXRpb25fc3RhdGVtZW50KSB7XG4gICAgICAgICAgICAvLyBqdXN0IGdvdCBhbiAnPScgaW4gYSB2YXItbGluZSwgZGlmZmVyZW50IGZvcm1hdHRpbmcvbGluZS1icmVha2luZywgZXRjIHdpbGwgbm93IGJlIGRvbmVcbiAgICAgICAgICAgIGZsYWdzLmRlY2xhcmF0aW9uX2Fzc2lnbm1lbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICBwcmludF90b2tlbigpO1xuICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVfY29tbWEoKSB7XG4gICAgICAgIGhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuLCB0cnVlKTtcblxuICAgICAgICBwcmludF90b2tlbigpO1xuICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgaWYgKGZsYWdzLmRlY2xhcmF0aW9uX3N0YXRlbWVudCkge1xuICAgICAgICAgICAgaWYgKGlzX2V4cHJlc3Npb24oZmxhZ3MucGFyZW50Lm1vZGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IGJyZWFrIG9uIGNvbW1hLCBmb3IodmFyIGEgPSAxLCBiID0gMilcbiAgICAgICAgICAgICAgICBmbGFncy5kZWNsYXJhdGlvbl9hc3NpZ25tZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmbGFncy5kZWNsYXJhdGlvbl9hc3NpZ25tZW50KSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MuZGVjbGFyYXRpb25fYXNzaWdubWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHByaW50X25ld2xpbmUoZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHQuY29tbWFfZmlyc3QpIHtcbiAgICAgICAgICAgICAgICAvLyBmb3IgY29tbWEtZmlyc3QsIHdlIHdhbnQgdG8gYWxsb3cgYSBuZXdsaW5lIGJlZm9yZSB0aGUgY29tbWFcbiAgICAgICAgICAgICAgICAvLyB0byB0dXJuIGludG8gYSBuZXdsaW5lIGFmdGVyIHRoZSBjb21tYSwgd2hpY2ggd2Ugd2lsbCBmaXh1cCBsYXRlclxuICAgICAgICAgICAgICAgIGFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChmbGFncy5tb2RlID09PSBNT0RFLk9iamVjdExpdGVyYWwgfHxcbiAgICAgICAgICAgIChmbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCAmJiBmbGFncy5wYXJlbnQubW9kZSA9PT0gTU9ERS5PYmplY3RMaXRlcmFsKSkge1xuICAgICAgICAgICAgaWYgKGZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmVzdG9yZV9tb2RlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZmxhZ3MuaW5saW5lX2ZyYW1lKSB7XG4gICAgICAgICAgICAgICAgcHJpbnRfbmV3bGluZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG9wdC5jb21tYV9maXJzdCkge1xuICAgICAgICAgICAgLy8gRVhQUiBvciBET19CTE9DS1xuICAgICAgICAgICAgLy8gZm9yIGNvbW1hLWZpcnN0LCB3ZSB3YW50IHRvIGFsbG93IGEgbmV3bGluZSBiZWZvcmUgdGhlIGNvbW1hXG4gICAgICAgICAgICAvLyB0byB0dXJuIGludG8gYSBuZXdsaW5lIGFmdGVyIHRoZSBjb21tYSwgd2hpY2ggd2Ugd2lsbCBmaXh1cCBsYXRlclxuICAgICAgICAgICAgYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlX29wZXJhdG9yKCkge1xuICAgICAgICB2YXIgaXNHZW5lcmF0b3JBc3RlcmlzayA9IGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJyonICYmXG4gICAgICAgICAgICAoKGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBpbl9hcnJheShmbGFncy5sYXN0X3RleHQsIFsnZnVuY3Rpb24nLCAneWllbGQnXSkpIHx8XG4gICAgICAgICAgICAgICAgKGluX2FycmF5KGxhc3RfdHlwZSwgWydUS19TVEFSVF9CTE9DSycsICdUS19DT01NQScsICdUS19FTkRfQkxPQ0snLCAnVEtfU0VNSUNPTE9OJ10pKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgdmFyIGlzVW5hcnkgPSBpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsIFsnLScsICcrJ10pICYmIChcbiAgICAgICAgICAgIGluX2FycmF5KGxhc3RfdHlwZSwgWydUS19TVEFSVF9CTE9DSycsICdUS19TVEFSVF9FWFBSJywgJ1RLX0VRVUFMUycsICdUS19PUEVSQVRPUiddKSB8fFxuICAgICAgICAgICAgaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LCB0b2tlbml6ZXIubGluZV9zdGFydGVycykgfHxcbiAgICAgICAgICAgIGZsYWdzLmxhc3RfdGV4dCA9PT0gJywnXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHN0YXJ0X29mX3N0YXRlbWVudCgpKSB7XG4gICAgICAgICAgICAvLyBUaGUgY29uZGl0aW9uYWwgc3RhcnRzIHRoZSBzdGF0ZW1lbnQgaWYgYXBwcm9wcmlhdGUuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzID0gIWlzR2VuZXJhdG9yQXN0ZXJpc2s7XG4gICAgICAgICAgICBoYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgaXNfc3BlY2lhbF93b3JkKGZsYWdzLmxhc3RfdGV4dCkpIHtcbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgaGFkIGEgc3BlY2lhbCBoYW5kbGluZyBpbiBUS19XT1JELiBOb3cgd2UgbmVlZCB0byByZXR1cm4gdGhlIGZhdm9yXG4gICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgIHByaW50X3Rva2VuKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYWNrIGZvciBhY3Rpb25zY3JpcHQncyBpbXBvcnQgLio7XG4gICAgICAgIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICcqJyAmJiBsYXN0X3R5cGUgPT09ICdUS19ET1QnKSB7XG4gICAgICAgICAgICBwcmludF90b2tlbigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJzo6Jykge1xuICAgICAgICAgICAgLy8gbm8gc3BhY2VzIGFyb3VuZCBleG90aWMgbmFtZXNwYWNpbmcgc3ludGF4IG9wZXJhdG9yXG4gICAgICAgICAgICBwcmludF90b2tlbigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWxsb3cgbGluZSB3cmFwcGluZyBiZXR3ZWVuIG9wZXJhdG9ycyB3aGVuIG9wZXJhdG9yX3Bvc2l0aW9uIGlzXG4gICAgICAgIC8vICAgc2V0IHRvIGJlZm9yZSBvciBwcmVzZXJ2ZVxuICAgICAgICBpZiAobGFzdF90eXBlID09PSAnVEtfT1BFUkFUT1InICYmIGluX2FycmF5KG9wdC5vcGVyYXRvcl9wb3NpdGlvbiwgT1BFUkFUT1JfUE9TSVRJT05fQkVGT1JFX09SX1BSRVNFUlZFKSkge1xuICAgICAgICAgICAgYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJzonICYmIGZsYWdzLmluX2Nhc2UpIHtcbiAgICAgICAgICAgIGZsYWdzLmNhc2VfYm9keSA9IHRydWU7XG4gICAgICAgICAgICBpbmRlbnQoKTtcbiAgICAgICAgICAgIHByaW50X3Rva2VuKCk7XG4gICAgICAgICAgICBwcmludF9uZXdsaW5lKCk7XG4gICAgICAgICAgICBmbGFncy5pbl9jYXNlID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3BhY2VfYmVmb3JlID0gdHJ1ZTtcbiAgICAgICAgdmFyIHNwYWNlX2FmdGVyID0gdHJ1ZTtcbiAgICAgICAgdmFyIGluX3Rlcm5hcnkgPSBmYWxzZTtcbiAgICAgICAgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJzonKSB7XG4gICAgICAgICAgICBpZiAoZmxhZ3MudGVybmFyeV9kZXB0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIENvbG9uIGlzIGludmFsaWQgamF2YXNjcmlwdCBvdXRzaWRlIG9mIHRlcm5hcnkgYW5kIG9iamVjdCwgYnV0IGRvIG91ciBiZXN0IHRvIGd1ZXNzIHdoYXQgd2FzIG1lYW50LlxuICAgICAgICAgICAgICAgIHNwYWNlX2JlZm9yZSA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmbGFncy50ZXJuYXJ5X2RlcHRoIC09IDE7XG4gICAgICAgICAgICAgICAgaW5fdGVybmFyeSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnPycpIHtcbiAgICAgICAgICAgIGZsYWdzLnRlcm5hcnlfZGVwdGggKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxldCdzIGhhbmRsZSB0aGUgb3BlcmF0b3JfcG9zaXRpb24gb3B0aW9uIHByaW9yIHRvIGFueSBjb25mbGljdGluZyBsb2dpY1xuICAgICAgICBpZiAoIWlzVW5hcnkgJiYgIWlzR2VuZXJhdG9yQXN0ZXJpc2sgJiYgb3B0LnByZXNlcnZlX25ld2xpbmVzICYmIGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgdG9rZW5pemVyLnBvc2l0aW9uYWJsZV9vcGVyYXRvcnMpKSB7XG4gICAgICAgICAgICB2YXIgaXNDb2xvbiA9IGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJzonO1xuICAgICAgICAgICAgdmFyIGlzVGVybmFyeUNvbG9uID0gKGlzQ29sb24gJiYgaW5fdGVybmFyeSk7XG4gICAgICAgICAgICB2YXIgaXNPdGhlckNvbG9uID0gKGlzQ29sb24gJiYgIWluX3Rlcm5hcnkpO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKG9wdC5vcGVyYXRvcl9wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIGNhc2UgT1BFUkFUT1JfUE9TSVRJT04uYmVmb3JlX25ld2xpbmU6XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjdXJyZW50IHRva2VuIGlzIDogYW5kIGl0J3Mgbm90IGEgdGVybmFyeSBzdGF0ZW1lbnQgdGhlbiB3ZSBzZXQgc3BhY2VfYmVmb3JlIHRvIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSAhaXNPdGhlckNvbG9uO1xuXG4gICAgICAgICAgICAgICAgICAgIHByaW50X3Rva2VuKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0NvbG9uIHx8IGlzVGVybmFyeUNvbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBPUEVSQVRPUl9QT1NJVElPTi5hZnRlcl9uZXdsaW5lOlxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgY3VycmVudCB0b2tlbiBpcyBhbnl0aGluZyBidXQgY29sb24sIG9yICh2aWEgZGVkdWN0aW9uKSBpdCdzIGEgY29sb24gYW5kIGluIGEgdGVybmFyeSBzdGF0ZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIC8vICAgdGhlbiBwcmludCBhIG5ld2xpbmUuXG5cbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0NvbG9uIHx8IGlzVGVybmFyeUNvbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0X3Rva2VuKDEpLndhbnRlZF9uZXdsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnRfbmV3bGluZShmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHByaW50X3Rva2VuKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgICAgIGNhc2UgT1BFUkFUT1JfUE9TSVRJT04ucHJlc2VydmVfbmV3bGluZTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc090aGVyQ29sb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGp1c3QgYWRkZWQgYSBuZXdsaW5lLCBvciB0aGUgY3VycmVudCB0b2tlbiBpcyA6IGFuZCBpdCdzIG5vdCBhIHRlcm5hcnkgc3RhdGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAvLyAgIHRoZW4gd2Ugc2V0IHNwYWNlX2JlZm9yZSB0byBmYWxzZVxuICAgICAgICAgICAgICAgICAgICBzcGFjZV9iZWZvcmUgPSAhKG91dHB1dC5qdXN0X2FkZGVkX25ld2xpbmUoKSB8fCBpc090aGVyQ29sb24pO1xuXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSBzcGFjZV9iZWZvcmU7XG4gICAgICAgICAgICAgICAgICAgIHByaW50X3Rva2VuKCk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNHZW5lcmF0b3JBc3Rlcmlzaykge1xuICAgICAgICAgICAgYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZSgpO1xuICAgICAgICAgICAgc3BhY2VfYmVmb3JlID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgbmV4dF90b2tlbiA9IGdldF90b2tlbigxKTtcbiAgICAgICAgICAgIHNwYWNlX2FmdGVyID0gbmV4dF90b2tlbiAmJiBpbl9hcnJheShuZXh0X3Rva2VuLnR5cGUsIFsnVEtfV09SRCcsICdUS19SRVNFUlZFRCddKTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICcuLi4nKSB7XG4gICAgICAgICAgICBhbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKCk7XG4gICAgICAgICAgICBzcGFjZV9iZWZvcmUgPSBsYXN0X3R5cGUgPT09ICdUS19TVEFSVF9CTE9DSyc7XG4gICAgICAgICAgICBzcGFjZV9hZnRlciA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgWyctLScsICcrKycsICchJywgJ34nXSkgfHwgaXNVbmFyeSkge1xuICAgICAgICAgICAgLy8gdW5hcnkgb3BlcmF0b3JzIChhbmQgYmluYXJ5ICsvLSBwcmV0ZW5kaW5nIHRvIGJlIHVuYXJ5KSBzcGVjaWFsIGNhc2VzXG5cbiAgICAgICAgICAgIHNwYWNlX2JlZm9yZSA9IGZhbHNlO1xuICAgICAgICAgICAgc3BhY2VfYWZ0ZXIgPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLTcuOS4xXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIG5ld2xpbmUgYmV0d2VlbiAtLSBvciArKyBhbmQgYW55dGhpbmcgZWxzZSB3ZSBzaG91bGQgcHJlc2VydmUgaXQuXG4gICAgICAgICAgICBpZiAoY3VycmVudF90b2tlbi53YW50ZWRfbmV3bGluZSAmJiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnLS0nIHx8IGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJysrJykpIHtcbiAgICAgICAgICAgICAgICBwcmludF9uZXdsaW5lKGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZsYWdzLmxhc3RfdGV4dCA9PT0gJzsnICYmIGlzX2V4cHJlc3Npb24oZmxhZ3MubW9kZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBmb3IgKDs7ICsraSlcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgXl5eXG4gICAgICAgICAgICAgICAgc3BhY2VfYmVmb3JlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJykge1xuICAgICAgICAgICAgICAgIHNwYWNlX2JlZm9yZSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX0VORF9FWFBSJykge1xuICAgICAgICAgICAgICAgIHNwYWNlX2JlZm9yZSA9ICEoZmxhZ3MubGFzdF90ZXh0ID09PSAnXScgJiYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJy0tJyB8fCBjdXJyZW50X3Rva2VuLnRleHQgPT09ICcrKycpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGFzdF90eXBlID09PSAnVEtfT1BFUkFUT1InKSB7XG4gICAgICAgICAgICAgICAgLy8gYSsrICsgKytiO1xuICAgICAgICAgICAgICAgIC8vIGEgLSAtYlxuICAgICAgICAgICAgICAgIHNwYWNlX2JlZm9yZSA9IGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgWyctLScsICctJywgJysrJywgJysnXSkgJiYgaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LCBbJy0tJywgJy0nLCAnKysnLCAnKyddKTtcbiAgICAgICAgICAgICAgICAvLyArIGFuZCAtIGFyZSBub3QgdW5hcnkgd2hlbiBwcmVjZWVkZWQgYnkgLS0gb3IgKysgb3BlcmF0b3JcbiAgICAgICAgICAgICAgICAvLyBhLS0gKyBiXG4gICAgICAgICAgICAgICAgLy8gYSAqICtiXG4gICAgICAgICAgICAgICAgLy8gYSAtIC1iXG4gICAgICAgICAgICAgICAgaWYgKGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgWycrJywgJy0nXSkgJiYgaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LCBbJy0tJywgJysrJ10pKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwYWNlX2FmdGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgaWYgKCgoZmxhZ3MubW9kZSA9PT0gTU9ERS5CbG9ja1N0YXRlbWVudCAmJiAhZmxhZ3MuaW5saW5lX2ZyYW1lKSB8fCBmbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCkgJiZcbiAgICAgICAgICAgICAgICAoZmxhZ3MubGFzdF90ZXh0ID09PSAneycgfHwgZmxhZ3MubGFzdF90ZXh0ID09PSAnOycpKSB7XG4gICAgICAgICAgICAgICAgLy8geyBmb287IC0taSB9XG4gICAgICAgICAgICAgICAgLy8gZm9vKCk7IC0tYmFyO1xuICAgICAgICAgICAgICAgIHByaW50X25ld2xpbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuIHx8IHNwYWNlX2JlZm9yZTtcbiAgICAgICAgcHJpbnRfdG9rZW4oKTtcbiAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHNwYWNlX2FmdGVyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZV9ibG9ja19jb21tZW50KHByZXNlcnZlX3N0YXRlbWVudF9mbGFncykge1xuICAgICAgICBpZiAob3V0cHV0LnJhdykge1xuICAgICAgICAgICAgb3V0cHV0LmFkZF9yYXdfdG9rZW4oY3VycmVudF90b2tlbik7XG4gICAgICAgICAgICBpZiAoY3VycmVudF90b2tlbi5kaXJlY3RpdmVzICYmIGN1cnJlbnRfdG9rZW4uZGlyZWN0aXZlcy5wcmVzZXJ2ZSA9PT0gJ2VuZCcpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSB0ZXN0aW5nIHRoZSByYXcgb3V0cHV0IGJlaGF2aW9yLCBkbyBub3QgYWxsb3cgYSBkaXJlY3RpdmUgdG8gdHVybiBpdCBvZmYuXG4gICAgICAgICAgICAgICAgb3V0cHV0LnJhdyA9IG9wdC50ZXN0X291dHB1dF9yYXc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudF90b2tlbi5kaXJlY3RpdmVzKSB7XG4gICAgICAgICAgICBwcmludF9uZXdsaW5lKGZhbHNlLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICAgICAgICAgICAgcHJpbnRfdG9rZW4oKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50X3Rva2VuLmRpcmVjdGl2ZXMucHJlc2VydmUgPT09ICdzdGFydCcpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucmF3ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByaW50X25ld2xpbmUoZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW5saW5lIGJsb2NrXG4gICAgICAgIGlmICghYWNvcm4ubmV3bGluZS50ZXN0KGN1cnJlbnRfdG9rZW4udGV4dCkgJiYgIWN1cnJlbnRfdG9rZW4ud2FudGVkX25ld2xpbmUpIHtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgcHJpbnRfdG9rZW4oKTtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxpbmVzID0gc3BsaXRfbGluZWJyZWFrcyhjdXJyZW50X3Rva2VuLnRleHQpO1xuICAgICAgICB2YXIgajsgLy8gaXRlcmF0b3IgZm9yIHRoaXMgY2FzZVxuICAgICAgICB2YXIgamF2YWRvYyA9IGZhbHNlO1xuICAgICAgICB2YXIgc3Rhcmxlc3MgPSBmYWxzZTtcbiAgICAgICAgdmFyIGxhc3RJbmRlbnQgPSBjdXJyZW50X3Rva2VuLndoaXRlc3BhY2VfYmVmb3JlO1xuICAgICAgICB2YXIgbGFzdEluZGVudExlbmd0aCA9IGxhc3RJbmRlbnQubGVuZ3RoO1xuXG4gICAgICAgIC8vIGJsb2NrIGNvbW1lbnQgc3RhcnRzIHdpdGggYSBuZXcgbGluZVxuICAgICAgICBwcmludF9uZXdsaW5lKGZhbHNlLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICAgICAgICBpZiAobGluZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgamF2YWRvYyA9IGFsbF9saW5lc19zdGFydF93aXRoKGxpbmVzLnNsaWNlKDEpLCAnKicpO1xuICAgICAgICAgICAgc3Rhcmxlc3MgPSBlYWNoX2xpbmVfbWF0Y2hlc19pbmRlbnQobGluZXMuc2xpY2UoMSksIGxhc3RJbmRlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlyc3QgbGluZSBhbHdheXMgaW5kZW50ZWRcbiAgICAgICAgcHJpbnRfdG9rZW4obGluZXNbMF0pO1xuICAgICAgICBmb3IgKGogPSAxOyBqIDwgbGluZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHByaW50X25ld2xpbmUoZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgaWYgKGphdmFkb2MpIHtcbiAgICAgICAgICAgICAgICAvLyBqYXZhZG9jOiByZWZvcm1hdCBhbmQgcmUtaW5kZW50XG4gICAgICAgICAgICAgICAgcHJpbnRfdG9rZW4oJyAnICsgbHRyaW0obGluZXNbal0pKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3Rhcmxlc3MgJiYgbGluZXNbal0ubGVuZ3RoID4gbGFzdEluZGVudExlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIHN0YXJsZXNzOiByZS1pbmRlbnQgbm9uLWVtcHR5IGNvbnRlbnQsIGF2b2lkaW5nIHRyaW1cbiAgICAgICAgICAgICAgICBwcmludF90b2tlbihsaW5lc1tqXS5zdWJzdHJpbmcobGFzdEluZGVudExlbmd0aCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBub3JtYWwgY29tbWVudHMgb3V0cHV0IHJhd1xuICAgICAgICAgICAgICAgIG91dHB1dC5hZGRfdG9rZW4obGluZXNbal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZm9yIGNvbW1lbnRzIG9mIG1vcmUgdGhhbiBvbmUgbGluZSwgbWFrZSBzdXJlIHRoZXJlJ3MgYSBuZXcgbGluZSBhZnRlclxuICAgICAgICBwcmludF9uZXdsaW5lKGZhbHNlLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZV9jb21tZW50KHByZXNlcnZlX3N0YXRlbWVudF9mbGFncykge1xuICAgICAgICBpZiAoY3VycmVudF90b2tlbi53YW50ZWRfbmV3bGluZSkge1xuICAgICAgICAgICAgcHJpbnRfbmV3bGluZShmYWxzZSwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dC50cmltKHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgIHByaW50X3Rva2VuKCk7XG4gICAgICAgIHByaW50X25ld2xpbmUoZmFsc2UsIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlX2RvdCgpIHtcbiAgICAgICAgaWYgKHN0YXJ0X29mX3N0YXRlbWVudCgpKSB7XG4gICAgICAgICAgICAvLyBUaGUgY29uZGl0aW9uYWwgc3RhcnRzIHRoZSBzdGF0ZW1lbnQgaWYgYXBwcm9wcmlhdGUuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbiwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGFzdF90eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGlzX3NwZWNpYWxfd29yZChmbGFncy5sYXN0X3RleHQpKSB7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGFsbG93IHByZXNlcnZlZCBuZXdsaW5lcyBiZWZvcmUgZG90cyBpbiBnZW5lcmFsXG4gICAgICAgICAgICAvLyBmb3JjZSBuZXdsaW5lcyBvbiBkb3RzIGFmdGVyIGNsb3NlIHBhcmVuIHdoZW4gYnJlYWtfY2hhaW5lZCAtIGZvciBiYXIoKS5iYXooKVxuICAgICAgICAgICAgYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShmbGFncy5sYXN0X3RleHQgPT09ICcpJyAmJiBvcHQuYnJlYWtfY2hhaW5lZF9tZXRob2RzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByaW50X3Rva2VuKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlX3Vua25vd24ocHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKSB7XG4gICAgICAgIHByaW50X3Rva2VuKCk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRfdG9rZW4udGV4dFtjdXJyZW50X3Rva2VuLnRleHQubGVuZ3RoIC0gMV0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICBwcmludF9uZXdsaW5lKGZhbHNlLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlX2VvZigpIHtcbiAgICAgICAgLy8gVW53aW5kIGFueSBvcGVuIHN0YXRlbWVudHNcbiAgICAgICAgd2hpbGUgKGZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50KSB7XG4gICAgICAgICAgICByZXN0b3JlX21vZGUoKTtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5CZWF1dGlmaWVyID0gQmVhdXRpZmllcjtcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qanNoaW50IGN1cmx5OnRydWUsIGVxZXFlcTp0cnVlLCBsYXhicmVhazp0cnVlLCBub2VtcHR5OmZhbHNlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE3IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cbmZ1bmN0aW9uIElucHV0U2Nhbm5lcihpbnB1dCkge1xuICAgIHZhciBfaW5wdXQgPSBpbnB1dDtcbiAgICB2YXIgX2lucHV0X2xlbmd0aCA9IF9pbnB1dC5sZW5ndGg7XG4gICAgdmFyIF9wb3NpdGlvbiA9IDA7XG5cbiAgICB0aGlzLmJhY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgX3Bvc2l0aW9uIC09IDE7XG4gICAgfTtcblxuICAgIHRoaXMuaGFzTmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3Bvc2l0aW9uIDwgX2lucHV0X2xlbmd0aDtcbiAgICB9O1xuXG4gICAgdGhpcy5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWwgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgIHZhbCA9IF9pbnB1dC5jaGFyQXQoX3Bvc2l0aW9uKTtcbiAgICAgICAgICAgIF9wb3NpdGlvbiArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcblxuICAgIHRoaXMucGVlayA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHZhciB2YWwgPSBudWxsO1xuICAgICAgICBpbmRleCA9IGluZGV4IHx8IDA7XG4gICAgICAgIGluZGV4ICs9IF9wb3NpdGlvbjtcbiAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCBfaW5wdXRfbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YWwgPSBfaW5wdXQuY2hhckF0KGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH07XG5cbiAgICB0aGlzLnBlZWtDaGFyQ29kZSA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHZhciB2YWwgPSAwO1xuICAgICAgICBpbmRleCA9IGluZGV4IHx8IDA7XG4gICAgICAgIGluZGV4ICs9IF9wb3NpdGlvbjtcbiAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCBfaW5wdXRfbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YWwgPSBfaW5wdXQuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9O1xuXG4gICAgdGhpcy50ZXN0ID0gZnVuY3Rpb24ocGF0dGVybiwgaW5kZXgpIHtcbiAgICAgICAgaW5kZXggPSBpbmRleCB8fCAwO1xuICAgICAgICBwYXR0ZXJuLmxhc3RJbmRleCA9IF9wb3NpdGlvbiArIGluZGV4O1xuICAgICAgICByZXR1cm4gcGF0dGVybi50ZXN0KF9pbnB1dCk7XG4gICAgfTtcblxuICAgIHRoaXMudGVzdENoYXIgPSBmdW5jdGlvbihwYXR0ZXJuLCBpbmRleCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5wZWVrKGluZGV4KTtcbiAgICAgICAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiBwYXR0ZXJuLnRlc3QodmFsKTtcbiAgICB9O1xuXG4gICAgdGhpcy5tYXRjaCA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgICAgICAgcGF0dGVybi5sYXN0SW5kZXggPSBfcG9zaXRpb247XG4gICAgICAgIHZhciBwYXR0ZXJuX21hdGNoID0gcGF0dGVybi5leGVjKF9pbnB1dCk7XG4gICAgICAgIGlmIChwYXR0ZXJuX21hdGNoICYmIHBhdHRlcm5fbWF0Y2guaW5kZXggPT09IF9wb3NpdGlvbikge1xuICAgICAgICAgICAgX3Bvc2l0aW9uICs9IHBhdHRlcm5fbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0dGVybl9tYXRjaCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdHRlcm5fbWF0Y2g7XG4gICAgfTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cy5JbnB1dFNjYW5uZXIgPSBJbnB1dFNjYW5uZXI7XG5cblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qanNoaW50IGN1cmx5OnRydWUsIGVxZXFlcTp0cnVlLCBsYXhicmVhazp0cnVlLCBub2VtcHR5OmZhbHNlICovXG4vKlxuXG4gICAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxNyBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAgICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICAgIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gICAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gICAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICAgIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gICAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICAgIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICAgIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gICAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgIFNPRlRXQVJFLlxuKi9cblxuZnVuY3Rpb24gbWVyZ2VPcHRzKGFsbE9wdGlvbnMsIHRhcmdldFR5cGUpIHtcbiAgICB2YXIgZmluYWxPcHRzID0ge307XG4gICAgdmFyIG5hbWU7XG5cbiAgICBmb3IgKG5hbWUgaW4gYWxsT3B0aW9ucykge1xuICAgICAgICBpZiAobmFtZSAhPT0gdGFyZ2V0VHlwZSkge1xuICAgICAgICAgICAgZmluYWxPcHRzW25hbWVdID0gYWxsT3B0aW9uc1tuYW1lXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vbWVyZ2UgaW4gdGhlIHBlciB0eXBlIHNldHRpbmdzIGZvciB0aGUgdGFyZ2V0VHlwZVxuICAgIGlmICh0YXJnZXRUeXBlIGluIGFsbE9wdGlvbnMpIHtcbiAgICAgICAgZm9yIChuYW1lIGluIGFsbE9wdGlvbnNbdGFyZ2V0VHlwZV0pIHtcbiAgICAgICAgICAgIGZpbmFsT3B0c1tuYW1lXSA9IGFsbE9wdGlvbnNbdGFyZ2V0VHlwZV1bbmFtZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpbmFsT3B0cztcbn1cblxubW9kdWxlLmV4cG9ydHMubWVyZ2VPcHRzID0gbWVyZ2VPcHRzO1xuXG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKmpzaGludCBjdXJseTp0cnVlLCBlcWVxZXE6dHJ1ZSwgbGF4YnJlYWs6dHJ1ZSwgbm9lbXB0eTpmYWxzZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxNyBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5mdW5jdGlvbiBPdXRwdXRMaW5lKHBhcmVudCkge1xuICAgIHZhciBfY2hhcmFjdGVyX2NvdW50ID0gMDtcbiAgICAvLyB1c2UgaW5kZW50X2NvdW50IGFzIGEgbWFya2VyIGZvciBsaW5lcyB0aGF0IGhhdmUgcHJlc2VydmVkIGluZGVudGF0aW9uXG4gICAgdmFyIF9pbmRlbnRfY291bnQgPSAtMTtcblxuICAgIHZhciBfaXRlbXMgPSBbXTtcbiAgICB2YXIgX2VtcHR5ID0gdHJ1ZTtcblxuICAgIHRoaXMuc2V0X2luZGVudCA9IGZ1bmN0aW9uKGxldmVsKSB7XG4gICAgICAgIF9jaGFyYWN0ZXJfY291bnQgPSBwYXJlbnQuYmFzZUluZGVudExlbmd0aCArIGxldmVsICogcGFyZW50LmluZGVudF9sZW5ndGg7XG4gICAgICAgIF9pbmRlbnRfY291bnQgPSBsZXZlbDtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRfY2hhcmFjdGVyX2NvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfY2hhcmFjdGVyX2NvdW50O1xuICAgIH07XG5cbiAgICB0aGlzLmlzX2VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfZW1wdHk7XG4gICAgfTtcblxuICAgIHRoaXMubGFzdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2VtcHR5KSB7XG4gICAgICAgICAgICByZXR1cm4gX2l0ZW1zW19pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMucHVzaCA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIF9pdGVtcy5wdXNoKGlucHV0KTtcbiAgICAgICAgX2NoYXJhY3Rlcl9jb3VudCArPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgIF9lbXB0eSA9IGZhbHNlO1xuICAgIH07XG5cbiAgICB0aGlzLnBvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaXRlbSA9IG51bGw7XG4gICAgICAgIGlmICghX2VtcHR5KSB7XG4gICAgICAgICAgICBpdGVtID0gX2l0ZW1zLnBvcCgpO1xuICAgICAgICAgICAgX2NoYXJhY3Rlcl9jb3VudCAtPSBpdGVtLmxlbmd0aDtcbiAgICAgICAgICAgIF9lbXB0eSA9IF9pdGVtcy5sZW5ndGggPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfTtcblxuICAgIHRoaXMucmVtb3ZlX2luZGVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoX2luZGVudF9jb3VudCA+IDApIHtcbiAgICAgICAgICAgIF9pbmRlbnRfY291bnQgLT0gMTtcbiAgICAgICAgICAgIF9jaGFyYWN0ZXJfY291bnQgLT0gcGFyZW50LmluZGVudF9sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy50cmltID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmxhc3QoKSA9PT0gJyAnKSB7XG4gICAgICAgICAgICBfaXRlbXMucG9wKCk7XG4gICAgICAgICAgICBfY2hhcmFjdGVyX2NvdW50IC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgX2VtcHR5ID0gX2l0ZW1zLmxlbmd0aCA9PT0gMDtcbiAgICB9O1xuXG4gICAgdGhpcy50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgIGlmICghdGhpcy5fZW1wdHkpIHtcbiAgICAgICAgICAgIGlmIChfaW5kZW50X2NvdW50ID49IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBwYXJlbnQuaW5kZW50X2NhY2hlW19pbmRlbnRfY291bnRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9IF9pdGVtcy5qb2luKCcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIE91dHB1dChpbmRlbnRfc3RyaW5nLCBiYXNlSW5kZW50U3RyaW5nKSB7XG4gICAgYmFzZUluZGVudFN0cmluZyA9IGJhc2VJbmRlbnRTdHJpbmcgfHwgJyc7XG4gICAgdGhpcy5pbmRlbnRfY2FjaGUgPSBbYmFzZUluZGVudFN0cmluZ107XG4gICAgdGhpcy5iYXNlSW5kZW50TGVuZ3RoID0gYmFzZUluZGVudFN0cmluZy5sZW5ndGg7XG4gICAgdGhpcy5pbmRlbnRfbGVuZ3RoID0gaW5kZW50X3N0cmluZy5sZW5ndGg7XG4gICAgdGhpcy5yYXcgPSBmYWxzZTtcblxuICAgIHZhciBsaW5lcyA9IFtdO1xuICAgIHRoaXMuYmFzZUluZGVudFN0cmluZyA9IGJhc2VJbmRlbnRTdHJpbmc7XG4gICAgdGhpcy5pbmRlbnRfc3RyaW5nID0gaW5kZW50X3N0cmluZztcbiAgICB0aGlzLnByZXZpb3VzX2xpbmUgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudF9saW5lID0gbnVsbDtcbiAgICB0aGlzLnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuXG4gICAgdGhpcy5hZGRfb3V0cHV0bGluZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnByZXZpb3VzX2xpbmUgPSB0aGlzLmN1cnJlbnRfbGluZTtcbiAgICAgICAgdGhpcy5jdXJyZW50X2xpbmUgPSBuZXcgT3V0cHV0TGluZSh0aGlzKTtcbiAgICAgICAgbGluZXMucHVzaCh0aGlzLmN1cnJlbnRfbGluZSk7XG4gICAgfTtcblxuICAgIC8vIGluaXRpYWxpemVcbiAgICB0aGlzLmFkZF9vdXRwdXRsaW5lKCk7XG5cblxuICAgIHRoaXMuZ2V0X2xpbmVfbnVtYmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBsaW5lcy5sZW5ndGg7XG4gICAgfTtcblxuICAgIC8vIFVzaW5nIG9iamVjdCBpbnN0ZWFkIG9mIHN0cmluZyB0byBhbGxvdyBmb3IgbGF0ZXIgZXhwYW5zaW9uIG9mIGluZm8gYWJvdXQgZWFjaCBsaW5lXG4gICAgdGhpcy5hZGRfbmV3X2xpbmUgPSBmdW5jdGlvbihmb3JjZV9uZXdsaW5lKSB7XG4gICAgICAgIGlmICh0aGlzLmdldF9saW5lX251bWJlcigpID09PSAxICYmIHRoaXMuanVzdF9hZGRlZF9uZXdsaW5lKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gbm8gbmV3bGluZSBvbiBzdGFydCBvZiBmaWxlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm9yY2VfbmV3bGluZSB8fCAhdGhpcy5qdXN0X2FkZGVkX25ld2xpbmUoKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJhdykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkX291dHB1dGxpbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB0aGlzLmdldF9jb2RlID0gZnVuY3Rpb24oZW5kX3dpdGhfbmV3bGluZSwgZW9sKSB7XG4gICAgICAgIHZhciBzd2VldF9jb2RlID0gbGluZXMuam9pbignXFxuJykucmVwbGFjZSgvW1xcclxcblxcdCBdKyQvLCAnJyk7XG5cbiAgICAgICAgaWYgKGVuZF93aXRoX25ld2xpbmUpIHtcbiAgICAgICAgICAgIHN3ZWV0X2NvZGUgKz0gJ1xcbic7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW9sICE9PSAnXFxuJykge1xuICAgICAgICAgICAgc3dlZXRfY29kZSA9IHN3ZWV0X2NvZGUucmVwbGFjZSgvW1xcbl0vZywgZW9sKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzd2VldF9jb2RlO1xuICAgIH07XG5cbiAgICB0aGlzLnNldF9pbmRlbnQgPSBmdW5jdGlvbihsZXZlbCkge1xuICAgICAgICAvLyBOZXZlciBpbmRlbnQgeW91ciBmaXJzdCBvdXRwdXQgaW5kZW50IGF0IHRoZSBzdGFydCBvZiB0aGUgZmlsZVxuICAgICAgICBpZiAobGluZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgd2hpbGUgKGxldmVsID49IHRoaXMuaW5kZW50X2NhY2hlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50X2NhY2hlLnB1c2godGhpcy5pbmRlbnRfY2FjaGVbdGhpcy5pbmRlbnRfY2FjaGUubGVuZ3RoIC0gMV0gKyB0aGlzLmluZGVudF9zdHJpbmcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRfbGluZS5zZXRfaW5kZW50KGxldmVsKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudF9saW5lLnNldF9pbmRlbnQoMCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgdGhpcy5hZGRfcmF3X3Rva2VuID0gZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB0b2tlbi5uZXdsaW5lczsgeCsrKSB7XG4gICAgICAgICAgICB0aGlzLmFkZF9vdXRwdXRsaW5lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50X2xpbmUucHVzaCh0b2tlbi53aGl0ZXNwYWNlX2JlZm9yZSk7XG4gICAgICAgIHRoaXMuY3VycmVudF9saW5lLnB1c2godG9rZW4udGV4dCk7XG4gICAgICAgIHRoaXMuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG4gICAgfTtcblxuICAgIHRoaXMuYWRkX3Rva2VuID0gZnVuY3Rpb24ocHJpbnRhYmxlX3Rva2VuKSB7XG4gICAgICAgIHRoaXMuYWRkX3NwYWNlX2JlZm9yZV90b2tlbigpO1xuICAgICAgICB0aGlzLmN1cnJlbnRfbGluZS5wdXNoKHByaW50YWJsZV90b2tlbik7XG4gICAgfTtcblxuICAgIHRoaXMuYWRkX3NwYWNlX2JlZm9yZV90b2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5zcGFjZV9iZWZvcmVfdG9rZW4gJiYgIXRoaXMuanVzdF9hZGRlZF9uZXdsaW5lKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudF9saW5lLnB1c2goJyAnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICAgIH07XG5cbiAgICB0aGlzLnJlbW92ZV9pbmRlbnQgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB2YXIgb3V0cHV0X2xlbmd0aCA9IGxpbmVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgb3V0cHV0X2xlbmd0aCkge1xuICAgICAgICAgICAgbGluZXNbaW5kZXhdLnJlbW92ZV9pbmRlbnQoKTtcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy50cmltID0gZnVuY3Rpb24oZWF0X25ld2xpbmVzKSB7XG4gICAgICAgIGVhdF9uZXdsaW5lcyA9IChlYXRfbmV3bGluZXMgPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IGVhdF9uZXdsaW5lcztcblxuICAgICAgICB0aGlzLmN1cnJlbnRfbGluZS50cmltKGluZGVudF9zdHJpbmcsIGJhc2VJbmRlbnRTdHJpbmcpO1xuXG4gICAgICAgIHdoaWxlIChlYXRfbmV3bGluZXMgJiYgbGluZXMubGVuZ3RoID4gMSAmJlxuICAgICAgICAgICAgdGhpcy5jdXJyZW50X2xpbmUuaXNfZW1wdHkoKSkge1xuICAgICAgICAgICAgbGluZXMucG9wKCk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRfbGluZSA9IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50X2xpbmUudHJpbSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcmV2aW91c19saW5lID0gbGluZXMubGVuZ3RoID4gMSA/IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDJdIDogbnVsbDtcbiAgICB9O1xuXG4gICAgdGhpcy5qdXN0X2FkZGVkX25ld2xpbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudF9saW5lLmlzX2VtcHR5KCk7XG4gICAgfTtcblxuICAgIHRoaXMuanVzdF9hZGRlZF9ibGFua2xpbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuanVzdF9hZGRlZF9uZXdsaW5lKCkpIHtcbiAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gc3RhcnQgb2YgdGhlIGZpbGUgYW5kIG5ld2xpbmUgPSBibGFua1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgcmV0dXJuIGxpbmUuaXNfZW1wdHkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMuT3V0cHV0ID0gT3V0cHV0O1xuXG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKmpzaGludCBjdXJseTp0cnVlLCBlcWVxZXE6dHJ1ZSwgbGF4YnJlYWs6dHJ1ZSwgbm9lbXB0eTpmYWxzZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxNyBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5mdW5jdGlvbiBUb2tlbih0eXBlLCB0ZXh0LCBuZXdsaW5lcywgd2hpdGVzcGFjZV9iZWZvcmUsIHBhcmVudCkge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcblxuICAgIC8vIGNvbW1lbnRzX2JlZm9yZSBhcmVcbiAgICAvLyBjb21tZW50cyB0aGF0IGhhdmUgYSBuZXcgbGluZSBiZWZvcmUgdGhlbVxuICAgIC8vIGFuZCBtYXkgb3IgbWF5IG5vdCBoYXZlIGEgbmV3bGluZSBhZnRlclxuICAgIC8vIHRoaXMgaXMgYSBzZXQgb2YgY29tbWVudHMgYmVmb3JlXG4gICAgdGhpcy5jb21tZW50c19iZWZvcmUgPSAvKiBpbmxpbmUgY29tbWVudCovIFtdO1xuXG5cbiAgICB0aGlzLmNvbW1lbnRzX2FmdGVyID0gW107IC8vIG5vIG5ldyBsaW5lIGJlZm9yZSBhbmQgbmV3bGluZSBhZnRlclxuICAgIHRoaXMubmV3bGluZXMgPSBuZXdsaW5lcyB8fCAwO1xuICAgIHRoaXMud2FudGVkX25ld2xpbmUgPSBuZXdsaW5lcyA+IDA7XG4gICAgdGhpcy53aGl0ZXNwYWNlX2JlZm9yZSA9IHdoaXRlc3BhY2VfYmVmb3JlIHx8ICcnO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50IHx8IG51bGw7XG4gICAgdGhpcy5vcGVuZWQgPSBudWxsO1xuICAgIHRoaXMuZGlyZWN0aXZlcyA9IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzLlRva2VuID0gVG9rZW47XG5cblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qanNoaW50IGN1cmx5OnRydWUsIGVxZXFlcTp0cnVlLCBsYXhicmVhazp0cnVlLCBub2VtcHR5OmZhbHNlICovXG4vKlxuXG4gICAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxNyBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAgICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICAgIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gICAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gICAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICAgIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gICAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICAgIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICAgIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gICAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgIFNPRlRXQVJFLlxuKi9cblxudmFyIEJlYXV0aWZpZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpLkJlYXV0aWZpZXI7XG5cbmZ1bmN0aW9uIGpzX2JlYXV0aWZ5KGpzX3NvdXJjZV90ZXh0LCBvcHRpb25zKSB7XG4gICAgdmFyIGJlYXV0aWZpZXIgPSBuZXcgQmVhdXRpZmllcihqc19zb3VyY2VfdGV4dCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGJlYXV0aWZpZXIuYmVhdXRpZnkoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBqc19iZWF1dGlmeTtcblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qanNoaW50IGN1cmx5OnRydWUsIGVxZXFlcTp0cnVlLCBsYXhicmVhazp0cnVlLCBub2VtcHR5OmZhbHNlICovXG4vKlxuXG4gICAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxNyBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAgICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICAgIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gICAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gICAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICAgIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gICAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICAgIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICAgIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gICAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgIFNPRlRXQVJFLlxuKi9cblxudmFyIElucHV0U2Nhbm5lciA9IF9fd2VicGFja19yZXF1aXJlX18oMikuSW5wdXRTY2FubmVyO1xudmFyIFRva2VuID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KS5Ub2tlbjtcbnZhciBhY29ybiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbmZ1bmN0aW9uIHRyaW0ocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcbn1cblxuZnVuY3Rpb24gaW5fYXJyYXkod2hhdCwgYXJyKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGFycltpXSA9PT0gd2hhdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBUb2tlbml6ZXIoaW5wdXRfc3RyaW5nLCBvcHRzKSB7XG5cbiAgICB2YXIgd2hpdGVzcGFjZSA9IFwiXFxuXFxyXFx0IFwiLnNwbGl0KCcnKTtcbiAgICB2YXIgZGlnaXQgPSAvWzAtOV0vO1xuICAgIHZhciBkaWdpdF9iaW4gPSAvWzAxXS87XG4gICAgdmFyIGRpZ2l0X29jdCA9IC9bMDEyMzQ1NjddLztcbiAgICB2YXIgZGlnaXRfaGV4ID0gL1swMTIzNDU2Nzg5YWJjZGVmQUJDREVGXS87XG5cbiAgICB0aGlzLnBvc2l0aW9uYWJsZV9vcGVyYXRvcnMgPSAnIT0gIT09ICUgJiAmJiAqICoqICsgLSAvIDogPCA8PCA8PSA9PSA9PT0gPiA+PSA+PiA+Pj4gPyBeIHwgfHwnLnNwbGl0KCcgJyk7XG4gICAgdmFyIHB1bmN0ID0gdGhpcy5wb3NpdGlvbmFibGVfb3BlcmF0b3JzLmNvbmNhdChcbiAgICAgICAgLy8gbm9uLXBvc2l0aW9uYWJsZSBvcGVyYXRvcnMgLSB0aGVzZSBkbyBub3QgZm9sbG93IG9wZXJhdG9yIHBvc2l0aW9uIHNldHRpbmdzXG4gICAgICAgICchICU9ICY9ICo9ICoqPSArKyArPSAsIC0tIC09IC89IDo6IDw8PSA9ID0+ID4+PSA+Pj49IF49IHw9IH4gLi4uJy5zcGxpdCgnICcpKTtcblxuICAgIC8vIHdvcmRzIHdoaWNoIHNob3VsZCBhbHdheXMgc3RhcnQgb24gbmV3IGxpbmUuXG4gICAgdGhpcy5saW5lX3N0YXJ0ZXJzID0gJ2NvbnRpbnVlLHRyeSx0aHJvdyxyZXR1cm4sdmFyLGxldCxjb25zdCxpZixzd2l0Y2gsY2FzZSxkZWZhdWx0LGZvcix3aGlsZSxicmVhayxmdW5jdGlvbixpbXBvcnQsZXhwb3J0Jy5zcGxpdCgnLCcpO1xuICAgIHZhciByZXNlcnZlZF93b3JkcyA9IHRoaXMubGluZV9zdGFydGVycy5jb25jYXQoWydkbycsICdpbicsICdvZicsICdlbHNlJywgJ2dldCcsICdzZXQnLCAnbmV3JywgJ2NhdGNoJywgJ2ZpbmFsbHknLCAndHlwZW9mJywgJ3lpZWxkJywgJ2FzeW5jJywgJ2F3YWl0JywgJ2Zyb20nLCAnYXMnXSk7XG5cbiAgICAvLyAgLyogLi4uICovIGNvbW1lbnQgZW5kcyB3aXRoIG5lYXJlc3QgKi8gb3IgZW5kIG9mIGZpbGVcbiAgICB2YXIgYmxvY2tfY29tbWVudF9wYXR0ZXJuID0gLyhbXFxzXFxTXSo/KSgoPzpcXCpcXC8pfCQpL2c7XG5cbiAgICAvLyBjb21tZW50IGVuZHMganVzdCBiZWZvcmUgbmVhcmVzdCBsaW5lZmVlZCBvciBlbmQgb2YgZmlsZVxuICAgIHZhciBjb21tZW50X3BhdHRlcm4gPSAvKFteXFxuXFxyXFx1MjAyOFxcdTIwMjldKikvZztcblxuICAgIHZhciBkaXJlY3RpdmVzX2Jsb2NrX3BhdHRlcm4gPSAvXFwvXFwqIGJlYXV0aWZ5KCBcXHcrWzpdXFx3KykrIFxcKlxcLy9nO1xuICAgIHZhciBkaXJlY3RpdmVfcGF0dGVybiA9IC8gKFxcdyspWzpdKFxcdyspL2c7XG4gICAgdmFyIGRpcmVjdGl2ZXNfZW5kX2lnbm9yZV9wYXR0ZXJuID0gLyhbXFxzXFxTXSo/KSgoPzpcXC9cXCpcXHNiZWF1dGlmeVxcc2lnbm9yZTplbmRcXHNcXCpcXC8pfCQpL2c7XG5cbiAgICB2YXIgdGVtcGxhdGVfcGF0dGVybiA9IC8oKDxcXD9waHB8PFxcPz0pW1xcc1xcU10qP1xcPz4pfCg8JVtcXHNcXFNdKj8lPikvZztcblxuICAgIHZhciBuX25ld2xpbmVzLCB3aGl0ZXNwYWNlX2JlZm9yZV90b2tlbiwgaW5faHRtbF9jb21tZW50LCB0b2tlbnM7XG4gICAgdmFyIGlucHV0O1xuXG4gICAgdGhpcy50b2tlbml6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpbnB1dCA9IG5ldyBJbnB1dFNjYW5uZXIoaW5wdXRfc3RyaW5nKTtcbiAgICAgICAgaW5faHRtbF9jb21tZW50ID0gZmFsc2U7XG4gICAgICAgIHRva2VucyA9IFtdO1xuXG4gICAgICAgIHZhciBuZXh0LCBsYXN0O1xuICAgICAgICB2YXIgdG9rZW5fdmFsdWVzO1xuICAgICAgICB2YXIgb3BlbiA9IG51bGw7XG4gICAgICAgIHZhciBvcGVuX3N0YWNrID0gW107XG4gICAgICAgIHZhciBjb21tZW50cyA9IFtdO1xuXG4gICAgICAgIHdoaWxlICghKGxhc3QgJiYgbGFzdC50eXBlID09PSAnVEtfRU9GJykpIHtcbiAgICAgICAgICAgIHRva2VuX3ZhbHVlcyA9IHRva2VuaXplX25leHQoKTtcbiAgICAgICAgICAgIG5leHQgPSBuZXcgVG9rZW4odG9rZW5fdmFsdWVzWzFdLCB0b2tlbl92YWx1ZXNbMF0sIG5fbmV3bGluZXMsIHdoaXRlc3BhY2VfYmVmb3JlX3Rva2VuKTtcbiAgICAgICAgICAgIHdoaWxlIChuZXh0LnR5cGUgPT09ICdUS19DT01NRU5UJyB8fCBuZXh0LnR5cGUgPT09ICdUS19CTE9DS19DT01NRU5UJyB8fCBuZXh0LnR5cGUgPT09ICdUS19VTktOT1dOJykge1xuICAgICAgICAgICAgICAgIGlmIChuZXh0LnR5cGUgPT09ICdUS19CTE9DS19DT01NRU5UJykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0LmRpcmVjdGl2ZXMgPSB0b2tlbl92YWx1ZXNbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbW1lbnRzLnB1c2gobmV4dCk7XG4gICAgICAgICAgICAgICAgdG9rZW5fdmFsdWVzID0gdG9rZW5pemVfbmV4dCgpO1xuICAgICAgICAgICAgICAgIG5leHQgPSBuZXcgVG9rZW4odG9rZW5fdmFsdWVzWzFdLCB0b2tlbl92YWx1ZXNbMF0sIG5fbmV3bGluZXMsIHdoaXRlc3BhY2VfYmVmb3JlX3Rva2VuKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG5leHQuY29tbWVudHNfYmVmb3JlID0gY29tbWVudHM7XG4gICAgICAgICAgICAgICAgY29tbWVudHMgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5leHQudHlwZSA9PT0gJ1RLX1NUQVJUX0JMT0NLJyB8fCBuZXh0LnR5cGUgPT09ICdUS19TVEFSVF9FWFBSJykge1xuICAgICAgICAgICAgICAgIG5leHQucGFyZW50ID0gbGFzdDtcbiAgICAgICAgICAgICAgICBvcGVuX3N0YWNrLnB1c2gob3Blbik7XG4gICAgICAgICAgICAgICAgb3BlbiA9IG5leHQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChuZXh0LnR5cGUgPT09ICdUS19FTkRfQkxPQ0snIHx8IG5leHQudHlwZSA9PT0gJ1RLX0VORF9FWFBSJykgJiZcbiAgICAgICAgICAgICAgICAob3BlbiAmJiAoXG4gICAgICAgICAgICAgICAgICAgIChuZXh0LnRleHQgPT09ICddJyAmJiBvcGVuLnRleHQgPT09ICdbJykgfHxcbiAgICAgICAgICAgICAgICAgICAgKG5leHQudGV4dCA9PT0gJyknICYmIG9wZW4udGV4dCA9PT0gJygnKSB8fFxuICAgICAgICAgICAgICAgICAgICAobmV4dC50ZXh0ID09PSAnfScgJiYgb3Blbi50ZXh0ID09PSAneycpKSkpIHtcbiAgICAgICAgICAgICAgICBuZXh0LnBhcmVudCA9IG9wZW4ucGFyZW50O1xuICAgICAgICAgICAgICAgIG5leHQub3BlbmVkID0gb3BlbjtcblxuICAgICAgICAgICAgICAgIG9wZW4gPSBvcGVuX3N0YWNrLnBvcCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0b2tlbnMucHVzaChuZXh0KTtcbiAgICAgICAgICAgIGxhc3QgPSBuZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0X2RpcmVjdGl2ZXModGV4dCkge1xuICAgICAgICBpZiAoIXRleHQubWF0Y2goZGlyZWN0aXZlc19ibG9ja19wYXR0ZXJuKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGlyZWN0aXZlcyA9IHt9O1xuICAgICAgICBkaXJlY3RpdmVfcGF0dGVybi5sYXN0SW5kZXggPSAwO1xuICAgICAgICB2YXIgZGlyZWN0aXZlX21hdGNoID0gZGlyZWN0aXZlX3BhdHRlcm4uZXhlYyh0ZXh0KTtcblxuICAgICAgICB3aGlsZSAoZGlyZWN0aXZlX21hdGNoKSB7XG4gICAgICAgICAgICBkaXJlY3RpdmVzW2RpcmVjdGl2ZV9tYXRjaFsxXV0gPSBkaXJlY3RpdmVfbWF0Y2hbMl07XG4gICAgICAgICAgICBkaXJlY3RpdmVfbWF0Y2ggPSBkaXJlY3RpdmVfcGF0dGVybi5leGVjKHRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRpcmVjdGl2ZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9rZW5pemVfbmV4dCgpIHtcbiAgICAgICAgdmFyIHJlc3VsdGluZ19zdHJpbmc7XG4gICAgICAgIHZhciB3aGl0ZXNwYWNlX29uX3RoaXNfbGluZSA9IFtdO1xuXG4gICAgICAgIG5fbmV3bGluZXMgPSAwO1xuICAgICAgICB3aGl0ZXNwYWNlX2JlZm9yZV90b2tlbiA9ICcnO1xuXG4gICAgICAgIHZhciBjID0gaW5wdXQubmV4dCgpO1xuXG4gICAgICAgIGlmIChjID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gWycnLCAnVEtfRU9GJ107XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGFzdF90b2tlbjtcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxhc3RfdG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRm9yIHRoZSBzYWtlIG9mIHRva2VuaXppbmcgd2UgY2FuIHByZXRlbmQgdGhhdCB0aGVyZSB3YXMgb24gb3BlbiBicmFjZSB0byBzdGFydFxuICAgICAgICAgICAgbGFzdF90b2tlbiA9IG5ldyBUb2tlbignVEtfU1RBUlRfQkxPQ0snLCAneycpO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGluX2FycmF5KGMsIHdoaXRlc3BhY2UpKSB7XG5cbiAgICAgICAgICAgIGlmIChhY29ybi5uZXdsaW5lLnRlc3QoYykpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShjID09PSAnXFxuJyAmJiBpbnB1dC5wZWVrKC0yKSA9PT0gJ1xccicpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5fbmV3bGluZXMgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgd2hpdGVzcGFjZV9vbl90aGlzX2xpbmUgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdoaXRlc3BhY2Vfb25fdGhpc19saW5lLnB1c2goYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGMgPSBpbnB1dC5uZXh0KCk7XG5cbiAgICAgICAgICAgIGlmIChjID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnJywgJ1RLX0VPRiddO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHdoaXRlc3BhY2Vfb25fdGhpc19saW5lLmxlbmd0aCkge1xuICAgICAgICAgICAgd2hpdGVzcGFjZV9iZWZvcmVfdG9rZW4gPSB3aGl0ZXNwYWNlX29uX3RoaXNfbGluZS5qb2luKCcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaWdpdC50ZXN0KGMpIHx8IChjID09PSAnLicgJiYgaW5wdXQudGVzdENoYXIoZGlnaXQpKSkge1xuICAgICAgICAgICAgdmFyIGFsbG93X2RlY2ltYWwgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGFsbG93X2UgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGxvY2FsX2RpZ2l0ID0gZGlnaXQ7XG5cbiAgICAgICAgICAgIGlmIChjID09PSAnMCcgJiYgaW5wdXQudGVzdENoYXIoL1tYeE9vQmJdLykpIHtcbiAgICAgICAgICAgICAgICAvLyBzd2l0Y2ggdG8gaGV4L29jdC9iaW4gbnVtYmVyLCBubyBkZWNpbWFsIG9yIGUsIGp1c3QgaGV4L29jdC9iaW4gZGlnaXRzXG4gICAgICAgICAgICAgICAgYWxsb3dfZGVjaW1hbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGFsbG93X2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQudGVzdENoYXIoL1tCYl0vKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbF9kaWdpdCA9IGRpZ2l0X2JpbjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0LnRlc3RDaGFyKC9bT29dLykpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxfZGlnaXQgPSBkaWdpdF9vY3Q7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxfZGlnaXQgPSBkaWdpdF9oZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGMgKz0gaW5wdXQubmV4dCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICAvLyBBbHJlYWR5IGhhdmUgYSBkZWNpbWFsIGZvciB0aGlzIGxpdGVyYWwsIGRvbid0IGFsbG93IGFub3RoZXJcbiAgICAgICAgICAgICAgICBhbGxvd19kZWNpbWFsID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHdlIGtub3cgdGhpcyBmaXJzdCBsb29wIHdpbGwgcnVuLiAgSXQga2VlcHMgdGhlIGxvZ2ljIHNpbXBsZXIuXG4gICAgICAgICAgICAgICAgYyA9ICcnO1xuICAgICAgICAgICAgICAgIGlucHV0LmJhY2soKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIHRoZSBkaWdpdHNcbiAgICAgICAgICAgIHdoaWxlIChpbnB1dC50ZXN0Q2hhcihsb2NhbF9kaWdpdCkpIHtcbiAgICAgICAgICAgICAgICBjICs9IGlucHV0Lm5leHQoKTtcblxuICAgICAgICAgICAgICAgIGlmIChhbGxvd19kZWNpbWFsICYmIGlucHV0LnBlZWsoKSA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGMgKz0gaW5wdXQubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBhbGxvd19kZWNpbWFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYSA9IDEuZS03IGlzIHZhbGlkLCBzbyB3ZSB0ZXN0IGZvciAuIHRoZW4gZSBpbiBvbmUgbG9vcFxuICAgICAgICAgICAgICAgIGlmIChhbGxvd19lICYmIGlucHV0LnRlc3RDaGFyKC9bRWVdLykpIHtcbiAgICAgICAgICAgICAgICAgICAgYyArPSBpbnB1dC5uZXh0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnRlc3RDaGFyKC9bKy1dLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgKz0gaW5wdXQubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYWxsb3dfZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBhbGxvd19kZWNpbWFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW2MsICdUS19XT1JEJ107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWNvcm4uaXNJZGVudGlmaWVyU3RhcnQoaW5wdXQucGVla0NoYXJDb2RlKC0xKSkpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoYWNvcm4uaXNJZGVudGlmaWVyQ2hhcihpbnB1dC5wZWVrQ2hhckNvZGUoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYyArPSBpbnB1dC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5wdXQuaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEobGFzdF90b2tlbi50eXBlID09PSAnVEtfRE9UJyB8fFxuICAgICAgICAgICAgICAgICAgICAobGFzdF90b2tlbi50eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGluX2FycmF5KGxhc3RfdG9rZW4udGV4dCwgWydzZXQnLCAnZ2V0J10pKSkgJiZcbiAgICAgICAgICAgICAgICBpbl9hcnJheShjLCByZXNlcnZlZF93b3JkcykpIHtcbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJ2luJyB8fCBjID09PSAnb2YnKSB7IC8vIGhhY2sgZm9yICdpbicgYW5kICdvZicgb3BlcmF0b3JzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbYywgJ1RLX09QRVJBVE9SJ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbYywgJ1RLX1JFU0VSVkVEJ107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBbYywgJ1RLX1dPUkQnXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjID09PSAnKCcgfHwgYyA9PT0gJ1snKSB7XG4gICAgICAgICAgICByZXR1cm4gW2MsICdUS19TVEFSVF9FWFBSJ107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA9PT0gJyknIHx8IGMgPT09ICddJykge1xuICAgICAgICAgICAgcmV0dXJuIFtjLCAnVEtfRU5EX0VYUFInXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjID09PSAneycpIHtcbiAgICAgICAgICAgIHJldHVybiBbYywgJ1RLX1NUQVJUX0JMT0NLJ107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA9PT0gJ30nKSB7XG4gICAgICAgICAgICByZXR1cm4gW2MsICdUS19FTkRfQkxPQ0snXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjID09PSAnOycpIHtcbiAgICAgICAgICAgIHJldHVybiBbYywgJ1RLX1NFTUlDT0xPTiddO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPT09ICcvJykge1xuICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSAnJztcbiAgICAgICAgICAgIHZhciBjb21tZW50X21hdGNoO1xuICAgICAgICAgICAgLy8gcGVlayBmb3IgY29tbWVudCAvKiAuLi4gKi9cbiAgICAgICAgICAgIGlmIChpbnB1dC5wZWVrKCkgPT09ICcqJykge1xuICAgICAgICAgICAgICAgIGlucHV0Lm5leHQoKTtcbiAgICAgICAgICAgICAgICBjb21tZW50X21hdGNoID0gaW5wdXQubWF0Y2goYmxvY2tfY29tbWVudF9wYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICBjb21tZW50ID0gJy8qJyArIGNvbW1lbnRfbWF0Y2hbMF07XG4gICAgICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZXMgPSBnZXRfZGlyZWN0aXZlcyhjb21tZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aXZlcyAmJiBkaXJlY3RpdmVzLmlnbm9yZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50X21hdGNoID0gaW5wdXQubWF0Y2goZGlyZWN0aXZlc19lbmRfaWdub3JlX3BhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50ICs9IGNvbW1lbnRfbWF0Y2hbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBjb21tZW50LnJlcGxhY2UoYWNvcm4uYWxsTGluZUJyZWFrcywgJ1xcbicpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbY29tbWVudCwgJ1RLX0JMT0NLX0NPTU1FTlQnLCBkaXJlY3RpdmVzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHBlZWsgZm9yIGNvbW1lbnQgLy8gLi4uXG4gICAgICAgICAgICBpZiAoaW5wdXQucGVlaygpID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgY29tbWVudF9tYXRjaCA9IGlucHV0Lm1hdGNoKGNvbW1lbnRfcGF0dGVybik7XG4gICAgICAgICAgICAgICAgY29tbWVudCA9ICcvLycgKyBjb21tZW50X21hdGNoWzBdO1xuICAgICAgICAgICAgICAgIHJldHVybiBbY29tbWVudCwgJ1RLX0NPTU1FTlQnXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YXJ0WG1sUmVnRXhwID0gLzwoKShbLWEtekEtWjowLTlfLl0rfHtbXFxzXFxTXSs/fXwhXFxbQ0RBVEFcXFtbXFxzXFxTXSo/XFxdXFxdKShcXHMre1tcXHNcXFNdKz99fFxccytbLWEtekEtWjowLTlfLl0rfFxccytbLWEtekEtWjowLTlfLl0rXFxzKj1cXHMqKCdbXiddKid8XCJbXlwiXSpcInx7W1xcc1xcU10rP30pKSpcXHMqKFxcLz8pXFxzKj4vZztcblxuICAgICAgICBpZiAoYyA9PT0gJ2AnIHx8IGMgPT09IFwiJ1wiIHx8IGMgPT09ICdcIicgfHwgLy8gc3RyaW5nXG4gICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgKGMgPT09ICcvJykgfHwgLy8gcmVnZXhwXG4gICAgICAgICAgICAgICAgKG9wdHMuZTR4ICYmIGMgPT09IFwiPFwiICYmIGlucHV0LnRlc3Qoc3RhcnRYbWxSZWdFeHAsIC0xKSkgLy8geG1sXG4gICAgICAgICAgICApICYmICggLy8gcmVnZXggYW5kIHhtbCBjYW4gb25seSBhcHBlYXIgaW4gc3BlY2lmaWMgbG9jYXRpb25zIGR1cmluZyBwYXJzaW5nXG4gICAgICAgICAgICAgICAgKGxhc3RfdG9rZW4udHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBpbl9hcnJheShsYXN0X3Rva2VuLnRleHQsIFsncmV0dXJuJywgJ2Nhc2UnLCAndGhyb3cnLCAnZWxzZScsICdkbycsICd0eXBlb2YnLCAneWllbGQnXSkpIHx8XG4gICAgICAgICAgICAgICAgKGxhc3RfdG9rZW4udHlwZSA9PT0gJ1RLX0VORF9FWFBSJyAmJiBsYXN0X3Rva2VuLnRleHQgPT09ICcpJyAmJlxuICAgICAgICAgICAgICAgICAgICBsYXN0X3Rva2VuLnBhcmVudCAmJiBsYXN0X3Rva2VuLnBhcmVudC50eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGluX2FycmF5KGxhc3RfdG9rZW4ucGFyZW50LnRleHQsIFsnaWYnLCAnd2hpbGUnLCAnZm9yJ10pKSB8fFxuICAgICAgICAgICAgICAgIChpbl9hcnJheShsYXN0X3Rva2VuLnR5cGUsIFsnVEtfQ09NTUVOVCcsICdUS19TVEFSVF9FWFBSJywgJ1RLX1NUQVJUX0JMT0NLJyxcbiAgICAgICAgICAgICAgICAgICAgJ1RLX0VORF9CTE9DSycsICdUS19PUEVSQVRPUicsICdUS19FUVVBTFMnLCAnVEtfRU9GJywgJ1RLX1NFTUlDT0xPTicsICdUS19DT01NQSdcbiAgICAgICAgICAgICAgICBdKSlcbiAgICAgICAgICAgICkpIHtcblxuICAgICAgICAgICAgdmFyIHNlcCA9IGMsXG4gICAgICAgICAgICAgICAgZXNjID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgaGFzX2NoYXJfZXNjYXBlcyA9IGZhbHNlO1xuXG4gICAgICAgICAgICByZXN1bHRpbmdfc3RyaW5nID0gYztcblxuICAgICAgICAgICAgaWYgKHNlcCA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgcmVnZXhwXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICB2YXIgaW5fY2hhcl9jbGFzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpbnB1dC5oYXNOZXh0KCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKChlc2MgfHwgaW5fY2hhcl9jbGFzcyB8fCBpbnB1dC5wZWVrKCkgIT09IHNlcCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFpbnB1dC50ZXN0Q2hhcihhY29ybi5uZXdsaW5lKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSBpbnB1dC5wZWVrKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXNjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlc2MgPSBpbnB1dC5wZWVrKCkgPT09ICdcXFxcJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5wZWVrKCkgPT09ICdbJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluX2NoYXJfY2xhc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5wZWVrKCkgPT09ICddJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluX2NoYXJfY2xhc3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVzYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlucHV0Lm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdHMuZTR4ICYmIHNlcCA9PT0gJzwnKSB7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgZTR4IHhtbCBsaXRlcmFsc1xuICAgICAgICAgICAgICAgIC8vXG5cbiAgICAgICAgICAgICAgICB2YXIgeG1sUmVnRXhwID0gL1tcXHNcXFNdKj88KFxcLz8pKFstYS16QS1aOjAtOV8uXSt8e1tcXHNcXFNdKz99fCFcXFtDREFUQVxcW1tcXHNcXFNdKj9cXF1cXF0pKFxccyt7W1xcc1xcU10rP318XFxzK1stYS16QS1aOjAtOV8uXSt8XFxzK1stYS16QS1aOjAtOV8uXStcXHMqPVxccyooJ1teJ10qJ3xcIlteXCJdKlwifHtbXFxzXFxTXSs/fSkpKlxccyooXFwvPylcXHMqPi9nO1xuICAgICAgICAgICAgICAgIGlucHV0LmJhY2soKTtcbiAgICAgICAgICAgICAgICB2YXIgeG1sU3RyID0gJyc7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gaW5wdXQubWF0Y2goc3RhcnRYbWxSZWdFeHApO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUcmltIHJvb3QgdGFnIHRvIGF0dGVtcHQgdG9cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvb3RUYWcgPSBtYXRjaFsyXS5yZXBsYWNlKC9ee1xccysvLCAneycpLnJlcGxhY2UoL1xccyt9JC8sICd9Jyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpc0N1cmx5Um9vdCA9IHJvb3RUYWcuaW5kZXhPZigneycpID09PSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVwdGggPSAwO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0VuZFRhZyA9ICEhbWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFnTmFtZSA9IG1hdGNoWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzU2luZ2xldG9uVGFnID0gKCEhbWF0Y2hbbWF0Y2gubGVuZ3RoIC0gMV0pIHx8ICh0YWdOYW1lLnNsaWNlKDAsIDgpID09PSBcIiFbQ0RBVEFbXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1NpbmdsZXRvblRhZyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0YWdOYW1lID09PSByb290VGFnIHx8IChpc0N1cmx5Um9vdCAmJiB0YWdOYW1lLnJlcGxhY2UoL157XFxzKy8sICd7JykucmVwbGFjZSgvXFxzK30kLywgJ30nKSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRW5kVGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tZGVwdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKytkZXB0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB4bWxTdHIgKz0gbWF0Y2hbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVwdGggPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBpbnB1dC5tYXRjaCh4bWxSZWdFeHApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGRpZG4ndCBjbG9zZSBjb3JyZWN0bHksIGtlZXAgdW5mb3JtYXR0ZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhtbFN0ciArPSBpbnB1dC5tYXRjaCgvW1xcc1xcU10qL2cpWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHhtbFN0ciA9IHhtbFN0ci5yZXBsYWNlKGFjb3JuLmFsbExpbmVCcmVha3MsICdcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt4bWxTdHIsIFwiVEtfU1RSSU5HXCJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgc3RyaW5nXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICB2YXIgcGFyc2Vfc3RyaW5nID0gZnVuY3Rpb24oZGVsaW1pdGVyLCBhbGxvd191bmVzY2FwZWRfbmV3bGluZXMsIHN0YXJ0X3N1Yikge1xuICAgICAgICAgICAgICAgICAgICAvLyBUZW1wbGF0ZSBzdHJpbmdzIGNhbiB0cmF2ZXJzIGxpbmVzIHdpdGhvdXQgZXNjYXBlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyIHN0cmluZ3MgY2Fubm90XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50X2NoYXI7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpbnB1dC5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfY2hhciA9IGlucHV0LnBlZWsoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGVzYyB8fCAoY3VycmVudF9jaGFyICE9PSBkZWxpbWl0ZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGFsbG93X3VuZXNjYXBlZF9uZXdsaW5lcyB8fCAhYWNvcm4ubmV3bGluZS50ZXN0KGN1cnJlbnRfY2hhcikpKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIFxcclxcbiBsaW5lYnJlYWtzIGFmdGVyIGVzY2FwZXMgb3IgaW4gdGVtcGxhdGUgc3RyaW5nc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChlc2MgfHwgYWxsb3dfdW5lc2NhcGVkX25ld2xpbmVzKSAmJiBhY29ybi5uZXdsaW5lLnRlc3QoY3VycmVudF9jaGFyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50X2NoYXIgPT09ICdcXHInICYmIGlucHV0LnBlZWsoMSkgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0Lm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudF9jaGFyID0gaW5wdXQucGVlaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRpbmdfc3RyaW5nICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRpbmdfc3RyaW5nICs9IGN1cnJlbnRfY2hhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVzYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50X2NoYXIgPT09ICd4JyB8fCBjdXJyZW50X2NoYXIgPT09ICd1Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNfY2hhcl9lc2NhcGVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVzYyA9IGN1cnJlbnRfY2hhciA9PT0gJ1xcXFwnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5uZXh0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFydF9zdWIgJiYgcmVzdWx0aW5nX3N0cmluZy5pbmRleE9mKHN0YXJ0X3N1YiwgcmVzdWx0aW5nX3N0cmluZy5sZW5ndGggLSBzdGFydF9zdWIubGVuZ3RoKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVsaW1pdGVyID09PSAnYCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2Vfc3RyaW5nKCd9JywgYWxsb3dfdW5lc2NhcGVkX25ld2xpbmVzLCAnYCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlX3N0cmluZygnYCcsIGFsbG93X3VuZXNjYXBlZF9uZXdsaW5lcywgJyR7Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0Lmhhc05leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRpbmdfc3RyaW5nICs9IGlucHV0Lm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKHNlcCA9PT0gJ2AnKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlX3N0cmluZygnYCcsIHRydWUsICckeycpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlX3N0cmluZyhzZXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGhhc19jaGFyX2VzY2FwZXMgJiYgb3B0cy51bmVzY2FwZV9zdHJpbmdzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHVuZXNjYXBlX3N0cmluZyhyZXN1bHRpbmdfc3RyaW5nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlucHV0LnBlZWsoKSA9PT0gc2VwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSBzZXA7XG4gICAgICAgICAgICAgICAgaW5wdXQubmV4dCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNlcCA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlZ2V4cHMgbWF5IGhhdmUgbW9kaWZpZXJzIC9yZWdleHAvTU9EICwgc28gZmV0Y2ggdGhvc2UsIHRvb1xuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IFtnaW1dIGFyZSB2YWxpZCwgYnV0IGlmIHRoZSB1c2VyIHB1dHMgaW4gZ2FyYmFnZSwgZG8gd2hhdCB3ZSBjYW4gdG8gdGFrZSBpdC5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGlucHV0Lmhhc05leHQoKSAmJiBhY29ybi5pc0lkZW50aWZpZXJTdGFydChpbnB1dC5wZWVrQ2hhckNvZGUoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ19zdHJpbmcgKz0gaW5wdXQubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtyZXN1bHRpbmdfc3RyaW5nLCAnVEtfU1RSSU5HJ107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA9PT0gJyMnKSB7XG5cbiAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAwICYmIGlucHV0LnBlZWsoKSA9PT0gJyEnKSB7XG4gICAgICAgICAgICAgICAgLy8gc2hlYmFuZ1xuICAgICAgICAgICAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSBjO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpbnB1dC5oYXNOZXh0KCkgJiYgYyAhPT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgYyA9IGlucHV0Lm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSBjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW3RyaW0ocmVzdWx0aW5nX3N0cmluZykgKyAnXFxuJywgJ1RLX1VOS05PV04nXTtcbiAgICAgICAgICAgIH1cblxuXG5cbiAgICAgICAgICAgIC8vIFNwaWRlcm1vbmtleS1zcGVjaWZpYyBzaGFycCB2YXJpYWJsZXMgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXNcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL0VuL1NoYXJwX3ZhcmlhYmxlc19pbl9KYXZhU2NyaXB0XG4gICAgICAgICAgICAvLyBodHRwOi8vbXhyLm1vemlsbGEub3JnL21vemlsbGEtY2VudHJhbC9zb3VyY2UvanMvc3JjL2pzc2Nhbi5jcHAgYXJvdW5kIGxpbmUgMTkzNVxuICAgICAgICAgICAgdmFyIHNoYXJwID0gJyMnO1xuICAgICAgICAgICAgaWYgKGlucHV0Lmhhc05leHQoKSAmJiBpbnB1dC50ZXN0Q2hhcihkaWdpdCkpIHtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGMgPSBpbnB1dC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIHNoYXJwICs9IGM7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoaW5wdXQuaGFzTmV4dCgpICYmIGMgIT09ICcjJyAmJiBjICE9PSAnPScpO1xuICAgICAgICAgICAgICAgIGlmIChjID09PSAnIycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0LnBlZWsoKSA9PT0gJ1snICYmIGlucHV0LnBlZWsoMSkgPT09ICddJykge1xuICAgICAgICAgICAgICAgICAgICBzaGFycCArPSAnW10nO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0Lm5leHQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0LnBlZWsoKSA9PT0gJ3snICYmIGlucHV0LnBlZWsoMSkgPT09ICd9Jykge1xuICAgICAgICAgICAgICAgICAgICBzaGFycCArPSAne30nO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0Lm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtzaGFycCwgJ1RLX1dPUkQnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjID09PSAnPCcgJiYgKGlucHV0LnBlZWsoKSA9PT0gJz8nIHx8IGlucHV0LnBlZWsoKSA9PT0gJyUnKSkge1xuICAgICAgICAgICAgaW5wdXQuYmFjaygpO1xuICAgICAgICAgICAgdmFyIHRlbXBsYXRlX21hdGNoID0gaW5wdXQubWF0Y2godGVtcGxhdGVfcGF0dGVybik7XG4gICAgICAgICAgICBpZiAodGVtcGxhdGVfbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBjID0gdGVtcGxhdGVfbWF0Y2hbMF07XG4gICAgICAgICAgICAgICAgYyA9IGMucmVwbGFjZShhY29ybi5hbGxMaW5lQnJlYWtzLCAnXFxuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtjLCAnVEtfU1RSSU5HJ107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA9PT0gJzwnICYmIGlucHV0Lm1hdGNoKC9cXCEtLS9nKSkge1xuICAgICAgICAgICAgYyA9ICc8IS0tJztcbiAgICAgICAgICAgIHdoaWxlIChpbnB1dC5oYXNOZXh0KCkgJiYgIWlucHV0LnRlc3RDaGFyKGFjb3JuLm5ld2xpbmUpKSB7XG4gICAgICAgICAgICAgICAgYyArPSBpbnB1dC5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbl9odG1sX2NvbW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIFtjLCAnVEtfQ09NTUVOVCddO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPT09ICctJyAmJiBpbl9odG1sX2NvbW1lbnQgJiYgaW5wdXQubWF0Y2goLy0+L2cpKSB7XG4gICAgICAgICAgICBpbl9odG1sX2NvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBbJy0tPicsICdUS19DT01NRU5UJ107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA9PT0gJy4nKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQucGVlaygpID09PSAnLicgJiYgaW5wdXQucGVlaygxKSA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgYyArPSBpbnB1dC5uZXh0KCkgKyBpbnB1dC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtjLCAnVEtfT1BFUkFUT1InXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbYywgJ1RLX0RPVCddO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluX2FycmF5KGMsIHB1bmN0KSkge1xuICAgICAgICAgICAgd2hpbGUgKGlucHV0Lmhhc05leHQoKSAmJiBpbl9hcnJheShjICsgaW5wdXQucGVlaygpLCBwdW5jdCkpIHtcbiAgICAgICAgICAgICAgICBjICs9IGlucHV0Lm5leHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlucHV0Lmhhc05leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjID09PSAnLCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2MsICdUS19DT01NQSddO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnPScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2MsICdUS19FUVVBTFMnXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtjLCAnVEtfT1BFUkFUT1InXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbYywgJ1RLX1VOS05PV04nXTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHVuZXNjYXBlX3N0cmluZyhzKSB7XG4gICAgICAgIC8vIFlvdSB0aGluayB0aGF0IGEgcmVnZXggd291bGQgd29yayBmb3IgdGhpc1xuICAgICAgICAvLyByZXR1cm4gcy5yZXBsYWNlKC9cXFxceChbMC05YS1mXXsyfSkvZ2ksIGZ1bmN0aW9uKG1hdGNoLCB2YWwpIHtcbiAgICAgICAgLy8gICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludCh2YWwsIDE2KSk7XG4gICAgICAgIC8vICAgICB9KVxuICAgICAgICAvLyBIb3dldmVyLCBkZWFsaW5nIHdpdGggJ1xceGZmJywgJ1xcXFx4ZmYnLCAnXFxcXFxceGZmJyBtYWtlcyB0aGlzIG1vcmUgZnVuLlxuICAgICAgICB2YXIgb3V0ID0gJycsXG4gICAgICAgICAgICBlc2NhcGVkID0gMDtcblxuICAgICAgICB2YXIgaW5wdXRfc2NhbiA9IG5ldyBJbnB1dFNjYW5uZXIocyk7XG4gICAgICAgIHZhciBtYXRjaGVkID0gbnVsbDtcblxuICAgICAgICB3aGlsZSAoaW5wdXRfc2Nhbi5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgIC8vIEtlZXAgYW55IHdoaXRlc3BhY2UsIG5vbi1zbGFzaCBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAvLyBhbHNvIGtlZXAgc2xhc2ggcGFpcnMuXG4gICAgICAgICAgICBtYXRjaGVkID0gaW5wdXRfc2Nhbi5tYXRjaCgvKFtcXHNdfFteXFxcXF18XFxcXFxcXFwpKy9nKTtcblxuICAgICAgICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gbWF0Y2hlZFswXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlucHV0X3NjYW4ucGVlaygpID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICBpbnB1dF9zY2FuLm5leHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRfc2Nhbi5wZWVrKCkgPT09ICd4Jykge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gaW5wdXRfc2Nhbi5tYXRjaCgveChbMC05QS1GYS1mXXsyfSkvZyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dF9zY2FuLnBlZWsoKSA9PT0gJ3UnKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSBpbnB1dF9zY2FuLm1hdGNoKC91KFswLTlBLUZhLWZdezR9KS9nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gJ1xcXFwnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRfc2Nhbi5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dCArPSBpbnB1dF9zY2FuLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSdzIHNvbWUgZXJyb3IgZGVjb2RpbmcsIHJldHVybiB0aGUgb3JpZ2luYWwgc3RyaW5nXG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSBwYXJzZUludChtYXRjaGVkWzFdLCAxNik7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXNjYXBlZCA+IDB4N2UgJiYgZXNjYXBlZCA8PSAweGZmICYmIG1hdGNoZWRbMF0uaW5kZXhPZigneCcpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGJhaWwgb3V0IG9uIFxceDdmLi5cXHhmZixcbiAgICAgICAgICAgICAgICAgICAgLy8gbGVhdmluZyB3aG9sZSBzdHJpbmcgZXNjYXBlZCxcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgaXQncyBwcm9iYWJseSBjb21wbGV0ZWx5IGJpbmFyeVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVzY2FwZWQgPj0gMHgwMCAmJiBlc2NhcGVkIDwgMHgyMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBsZWF2ZSAweDAwLi4uMHgxZiBlc2NhcGVkXG4gICAgICAgICAgICAgICAgICAgIG91dCArPSAnXFxcXCcgKyBtYXRjaGVkWzBdO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVzY2FwZWQgPT09IDB4MjIgfHwgZXNjYXBlZCA9PT0gMHgyNyB8fCBlc2NhcGVkID09PSAweDVjKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZS1xdW90ZSwgYXBvc3Ryb3BoZSwgYmFja3NsYXNoIC0gZXNjYXBlIHRoZXNlXG4gICAgICAgICAgICAgICAgICAgIG91dCArPSAnXFxcXCcgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGVzY2FwZWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGVzY2FwZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5Ub2tlbml6ZXIgPSBUb2tlbml6ZXI7XG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbnZhciBqc19iZWF1dGlmeSA9IGxlZ2FjeV9iZWF1dGlmeV9qcztcbi8qIEZvb3RlciAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQWRkIHN1cHBvcnQgZm9yIEFNRCAoIGh0dHBzOi8vZ2l0aHViLmNvbS9hbWRqcy9hbWRqcy1hcGkvd2lraS9BTUQjZGVmaW5lYW1kLXByb3BlcnR5LSApXG4gICAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHsganNfYmVhdXRpZnk6IGpzX2JlYXV0aWZ5IH07XG4gICAgfSk7XG59IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gQWRkIHN1cHBvcnQgZm9yIENvbW1vbkpTLiBKdXN0IHB1dCB0aGlzIGZpbGUgc29tZXdoZXJlIG9uIHlvdXIgcmVxdWlyZS5wYXRoc1xuICAgIC8vIGFuZCB5b3Ugd2lsbCBiZSBhYmxlIHRvIGB2YXIganNfYmVhdXRpZnkgPSByZXF1aXJlKFwiYmVhdXRpZnlcIikuanNfYmVhdXRpZnlgLlxuICAgIGV4cG9ydHMuanNfYmVhdXRpZnkgPSBqc19iZWF1dGlmeTtcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIElmIHdlJ3JlIHJ1bm5pbmcgYSB3ZWIgcGFnZSBhbmQgZG9uJ3QgaGF2ZSBlaXRoZXIgb2YgdGhlIGFib3ZlLCBhZGQgb3VyIG9uZSBnbG9iYWxcbiAgICB3aW5kb3cuanNfYmVhdXRpZnkgPSBqc19iZWF1dGlmeTtcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIElmIHdlIGRvbid0IGV2ZW4gaGF2ZSB3aW5kb3csIHRyeSBnbG9iYWwuXG4gICAgZ2xvYmFsLmpzX2JlYXV0aWZ5ID0ganNfYmVhdXRpZnk7XG59XG5cbn0oKSk7XG4iLCIvLyEgbW9tZW50LmpzXG4vLyEgdmVyc2lvbiA6IDIuMTkuMVxuLy8hIGF1dGhvcnMgOiBUaW0gV29vZCwgSXNrcmVuIENoZXJuZXYsIE1vbWVudC5qcyBjb250cmlidXRvcnNcbi8vISBsaWNlbnNlIDogTUlUXG4vLyEgbW9tZW50anMuY29tXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIGdsb2JhbC5tb21lbnQgPSBmYWN0b3J5KClcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgaG9va0NhbGxiYWNrO1xuXG5mdW5jdGlvbiBob29rcyAoKSB7XG4gICAgcmV0dXJuIGhvb2tDYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuXG4vLyBUaGlzIGlzIGRvbmUgdG8gcmVnaXN0ZXIgdGhlIG1ldGhvZCBjYWxsZWQgd2l0aCBtb21lbnQoKVxuLy8gd2l0aG91dCBjcmVhdGluZyBjaXJjdWxhciBkZXBlbmRlbmNpZXMuXG5mdW5jdGlvbiBzZXRIb29rQ2FsbGJhY2sgKGNhbGxiYWNrKSB7XG4gICAgaG9va0NhbGxiYWNrID0gY2FsbGJhY2s7XG59XG5cbmZ1bmN0aW9uIGlzQXJyYXkoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBBcnJheSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChpbnB1dCkge1xuICAgIC8vIElFOCB3aWxsIHRyZWF0IHVuZGVmaW5lZCBhbmQgbnVsbCBhcyBvYmplY3QgaWYgaXQgd2Fzbid0IGZvclxuICAgIC8vIGlucHV0ICE9IG51bGxcbiAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3RFbXB0eShvYmopIHtcbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMpIHtcbiAgICAgICAgcmV0dXJuIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmxlbmd0aCA9PT0gMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGs7XG4gICAgICAgIGZvciAoayBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dCA9PT0gdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihpbnB1dCkge1xuICAgIHJldHVybiB0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IE51bWJlcl0nO1xufVxuXG5mdW5jdGlvbiBpc0RhdGUoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBEYXRlIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuZnVuY3Rpb24gbWFwKGFyciwgZm4pIHtcbiAgICB2YXIgcmVzID0gW10sIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgICAgICByZXMucHVzaChmbihhcnJbaV0sIGkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gaGFzT3duUHJvcChhLCBiKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLCBiKTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKGEsIGIpIHtcbiAgICBmb3IgKHZhciBpIGluIGIpIHtcbiAgICAgICAgaWYgKGhhc093blByb3AoYiwgaSkpIHtcbiAgICAgICAgICAgIGFbaV0gPSBiW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc093blByb3AoYiwgJ3RvU3RyaW5nJykpIHtcbiAgICAgICAgYS50b1N0cmluZyA9IGIudG9TdHJpbmc7XG4gICAgfVxuXG4gICAgaWYgKGhhc093blByb3AoYiwgJ3ZhbHVlT2YnKSkge1xuICAgICAgICBhLnZhbHVlT2YgPSBiLnZhbHVlT2Y7XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVVUQyAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgdHJ1ZSkudXRjKCk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQYXJzaW5nRmxhZ3MoKSB7XG4gICAgLy8gV2UgbmVlZCB0byBkZWVwIGNsb25lIHRoaXMgb2JqZWN0LlxuICAgIHJldHVybiB7XG4gICAgICAgIGVtcHR5ICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICB1bnVzZWRUb2tlbnMgICAgOiBbXSxcbiAgICAgICAgdW51c2VkSW5wdXQgICAgIDogW10sXG4gICAgICAgIG92ZXJmbG93ICAgICAgICA6IC0yLFxuICAgICAgICBjaGFyc0xlZnRPdmVyICAgOiAwLFxuICAgICAgICBudWxsSW5wdXQgICAgICAgOiBmYWxzZSxcbiAgICAgICAgaW52YWxpZE1vbnRoICAgIDogbnVsbCxcbiAgICAgICAgaW52YWxpZEZvcm1hdCAgIDogZmFsc2UsXG4gICAgICAgIHVzZXJJbnZhbGlkYXRlZCA6IGZhbHNlLFxuICAgICAgICBpc28gICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgcGFyc2VkRGF0ZVBhcnRzIDogW10sXG4gICAgICAgIG1lcmlkaWVtICAgICAgICA6IG51bGwsXG4gICAgICAgIHJmYzI4MjIgICAgICAgICA6IGZhbHNlLFxuICAgICAgICB3ZWVrZGF5TWlzbWF0Y2ggOiBmYWxzZVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldFBhcnNpbmdGbGFncyhtKSB7XG4gICAgaWYgKG0uX3BmID09IG51bGwpIHtcbiAgICAgICAgbS5fcGYgPSBkZWZhdWx0UGFyc2luZ0ZsYWdzKCk7XG4gICAgfVxuICAgIHJldHVybiBtLl9wZjtcbn1cblxudmFyIHNvbWU7XG5pZiAoQXJyYXkucHJvdG90eXBlLnNvbWUpIHtcbiAgICBzb21lID0gQXJyYXkucHJvdG90eXBlLnNvbWU7XG59IGVsc2Uge1xuICAgIHNvbWUgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xuICAgICAgICB2YXIgbGVuID0gdC5sZW5ndGggPj4+IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgaW4gdCAmJiBmdW4uY2FsbCh0aGlzLCB0W2ldLCBpLCB0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWQobSkge1xuICAgIGlmIChtLl9pc1ZhbGlkID09IG51bGwpIHtcbiAgICAgICAgdmFyIGZsYWdzID0gZ2V0UGFyc2luZ0ZsYWdzKG0pO1xuICAgICAgICB2YXIgcGFyc2VkUGFydHMgPSBzb21lLmNhbGwoZmxhZ3MucGFyc2VkRGF0ZVBhcnRzLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgcmV0dXJuIGkgIT0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBpc05vd1ZhbGlkID0gIWlzTmFOKG0uX2QuZ2V0VGltZSgpKSAmJlxuICAgICAgICAgICAgZmxhZ3Mub3ZlcmZsb3cgPCAwICYmXG4gICAgICAgICAgICAhZmxhZ3MuZW1wdHkgJiZcbiAgICAgICAgICAgICFmbGFncy5pbnZhbGlkTW9udGggJiZcbiAgICAgICAgICAgICFmbGFncy5pbnZhbGlkV2Vla2RheSAmJlxuICAgICAgICAgICAgIWZsYWdzLndlZWtkYXlNaXNtYXRjaCAmJlxuICAgICAgICAgICAgIWZsYWdzLm51bGxJbnB1dCAmJlxuICAgICAgICAgICAgIWZsYWdzLmludmFsaWRGb3JtYXQgJiZcbiAgICAgICAgICAgICFmbGFncy51c2VySW52YWxpZGF0ZWQgJiZcbiAgICAgICAgICAgICghZmxhZ3MubWVyaWRpZW0gfHwgKGZsYWdzLm1lcmlkaWVtICYmIHBhcnNlZFBhcnRzKSk7XG5cbiAgICAgICAgaWYgKG0uX3N0cmljdCkge1xuICAgICAgICAgICAgaXNOb3dWYWxpZCA9IGlzTm93VmFsaWQgJiZcbiAgICAgICAgICAgICAgICBmbGFncy5jaGFyc0xlZnRPdmVyID09PSAwICYmXG4gICAgICAgICAgICAgICAgZmxhZ3MudW51c2VkVG9rZW5zLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGZsYWdzLmJpZ0hvdXIgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChPYmplY3QuaXNGcm96ZW4gPT0gbnVsbCB8fCAhT2JqZWN0LmlzRnJvemVuKG0pKSB7XG4gICAgICAgICAgICBtLl9pc1ZhbGlkID0gaXNOb3dWYWxpZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpc05vd1ZhbGlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtLl9pc1ZhbGlkO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJbnZhbGlkIChmbGFncykge1xuICAgIHZhciBtID0gY3JlYXRlVVRDKE5hTik7XG4gICAgaWYgKGZsYWdzICE9IG51bGwpIHtcbiAgICAgICAgZXh0ZW5kKGdldFBhcnNpbmdGbGFncyhtKSwgZmxhZ3MpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLnVzZXJJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG07XG59XG5cbi8vIFBsdWdpbnMgdGhhdCBhZGQgcHJvcGVydGllcyBzaG91bGQgYWxzbyBhZGQgdGhlIGtleSBoZXJlIChudWxsIHZhbHVlKSxcbi8vIHNvIHdlIGNhbiBwcm9wZXJseSBjbG9uZSBvdXJzZWx2ZXMuXG52YXIgbW9tZW50UHJvcGVydGllcyA9IGhvb2tzLm1vbWVudFByb3BlcnRpZXMgPSBbXTtcblxuZnVuY3Rpb24gY29weUNvbmZpZyh0bywgZnJvbSkge1xuICAgIHZhciBpLCBwcm9wLCB2YWw7XG5cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2lzQU1vbWVudE9iamVjdCkpIHtcbiAgICAgICAgdG8uX2lzQU1vbWVudE9iamVjdCA9IGZyb20uX2lzQU1vbWVudE9iamVjdDtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pKSkge1xuICAgICAgICB0by5faSA9IGZyb20uX2k7XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fZikpIHtcbiAgICAgICAgdG8uX2YgPSBmcm9tLl9mO1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2wpKSB7XG4gICAgICAgIHRvLl9sID0gZnJvbS5fbDtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9zdHJpY3QpKSB7XG4gICAgICAgIHRvLl9zdHJpY3QgPSBmcm9tLl9zdHJpY3Q7XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fdHptKSkge1xuICAgICAgICB0by5fdHptID0gZnJvbS5fdHptO1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2lzVVRDKSkge1xuICAgICAgICB0by5faXNVVEMgPSBmcm9tLl9pc1VUQztcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9vZmZzZXQpKSB7XG4gICAgICAgIHRvLl9vZmZzZXQgPSBmcm9tLl9vZmZzZXQ7XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fcGYpKSB7XG4gICAgICAgIHRvLl9wZiA9IGdldFBhcnNpbmdGbGFncyhmcm9tKTtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9sb2NhbGUpKSB7XG4gICAgICAgIHRvLl9sb2NhbGUgPSBmcm9tLl9sb2NhbGU7XG4gICAgfVxuXG4gICAgaWYgKG1vbWVudFByb3BlcnRpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbW9tZW50UHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcHJvcCA9IG1vbWVudFByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICB2YWwgPSBmcm9tW3Byb3BdO1xuICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgdG9bcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdG87XG59XG5cbnZhciB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG5cbi8vIE1vbWVudCBwcm90b3R5cGUgb2JqZWN0XG5mdW5jdGlvbiBNb21lbnQoY29uZmlnKSB7XG4gICAgY29weUNvbmZpZyh0aGlzLCBjb25maWcpO1xuICAgIHRoaXMuX2QgPSBuZXcgRGF0ZShjb25maWcuX2QgIT0gbnVsbCA/IGNvbmZpZy5fZC5nZXRUaW1lKCkgOiBOYU4pO1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgfVxuICAgIC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcCBpbiBjYXNlIHVwZGF0ZU9mZnNldCBjcmVhdGVzIG5ldyBtb21lbnRcbiAgICAvLyBvYmplY3RzLlxuICAgIGlmICh1cGRhdGVJblByb2dyZXNzID09PSBmYWxzZSkge1xuICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc01vbWVudCAob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE1vbWVudCB8fCAob2JqICE9IG51bGwgJiYgb2JqLl9pc0FNb21lbnRPYmplY3QgIT0gbnVsbCk7XG59XG5cbmZ1bmN0aW9uIGFic0Zsb29yIChudW1iZXIpIHtcbiAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAvLyAtMCAtPiAwXG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKSB8fCAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB0b0ludChhcmd1bWVudEZvckNvZXJjaW9uKSB7XG4gICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcbiAgICAgICAgdmFsdWUgPSAwO1xuXG4gICAgaWYgKGNvZXJjZWROdW1iZXIgIT09IDAgJiYgaXNGaW5pdGUoY29lcmNlZE51bWJlcikpIHtcbiAgICAgICAgdmFsdWUgPSBhYnNGbG9vcihjb2VyY2VkTnVtYmVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIGNvbXBhcmUgdHdvIGFycmF5cywgcmV0dXJuIHRoZSBudW1iZXIgb2YgZGlmZmVyZW5jZXNcbmZ1bmN0aW9uIGNvbXBhcmVBcnJheXMoYXJyYXkxLCBhcnJheTIsIGRvbnRDb252ZXJ0KSB7XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKGFycmF5MS5sZW5ndGgsIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICBsZW5ndGhEaWZmID0gTWF0aC5hYnMoYXJyYXkxLmxlbmd0aCAtIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICBkaWZmcyA9IDAsXG4gICAgICAgIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICgoZG9udENvbnZlcnQgJiYgYXJyYXkxW2ldICE9PSBhcnJheTJbaV0pIHx8XG4gICAgICAgICAgICAoIWRvbnRDb252ZXJ0ICYmIHRvSW50KGFycmF5MVtpXSkgIT09IHRvSW50KGFycmF5MltpXSkpKSB7XG4gICAgICAgICAgICBkaWZmcysrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaWZmcyArIGxlbmd0aERpZmY7XG59XG5cbmZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gICAgaWYgKGhvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgICh0eXBlb2YgY29uc29sZSAhPT0gICd1bmRlZmluZWQnKSAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGlvbiB3YXJuaW5nOiAnICsgbXNnKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZShtc2csIGZuKSB7XG4gICAgdmFyIGZpcnN0VGltZSA9IHRydWU7XG5cbiAgICByZXR1cm4gZXh0ZW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobnVsbCwgbXNnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgdmFyIGFyZztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZyArPSAnXFxuWycgKyBpICsgJ10gJztcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGFyZ3VtZW50c1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnICs9IGtleSArICc6ICcgKyBhcmd1bWVudHNbMF1ba2V5XSArICcsICc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKDAsIC0yKTsgLy8gUmVtb3ZlIHRyYWlsaW5nIGNvbW1hIGFuZCBzcGFjZVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3YXJuKG1zZyArICdcXG5Bcmd1bWVudHM6ICcgKyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKS5qb2luKCcnKSArICdcXG4nICsgKG5ldyBFcnJvcigpKS5zdGFjayk7XG4gICAgICAgICAgICBmaXJzdFRpbWUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCBmbik7XG59XG5cbnZhciBkZXByZWNhdGlvbnMgPSB7fTtcblxuZnVuY3Rpb24gZGVwcmVjYXRlU2ltcGxlKG5hbWUsIG1zZykge1xuICAgIGlmIChob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobmFtZSwgbXNnKTtcbiAgICB9XG4gICAgaWYgKCFkZXByZWNhdGlvbnNbbmFtZV0pIHtcbiAgICAgICAgd2Fybihtc2cpO1xuICAgICAgICBkZXByZWNhdGlvbnNbbmFtZV0gPSB0cnVlO1xuICAgIH1cbn1cblxuaG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID0gZmFsc2U7XG5ob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgPSBudWxsO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgRnVuY3Rpb24gfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuZnVuY3Rpb24gc2V0IChjb25maWcpIHtcbiAgICB2YXIgcHJvcCwgaTtcbiAgICBmb3IgKGkgaW4gY29uZmlnKSB7XG4gICAgICAgIHByb3AgPSBjb25maWdbaV07XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHByb3ApKSB7XG4gICAgICAgICAgICB0aGlzW2ldID0gcHJvcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbJ18nICsgaV0gPSBwcm9wO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcbiAgICAvLyBMZW5pZW50IG9yZGluYWwgcGFyc2luZyBhY2NlcHRzIGp1c3QgYSBudW1iZXIgaW4gYWRkaXRpb24gdG9cbiAgICAvLyBudW1iZXIgKyAocG9zc2libHkpIHN0dWZmIGNvbWluZyBmcm9tIF9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlLlxuICAgIC8vIFRPRE86IFJlbW92ZSBcIm9yZGluYWxQYXJzZVwiIGZhbGxiYWNrIGluIG5leHQgbWFqb3IgcmVsZWFzZS5cbiAgICB0aGlzLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICh0aGlzLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlLnNvdXJjZSB8fCB0aGlzLl9vcmRpbmFsUGFyc2Uuc291cmNlKSArXG4gICAgICAgICAgICAnfCcgKyAoL1xcZHsxLDJ9Lykuc291cmNlKTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY2hpbGRDb25maWcpIHtcbiAgICB2YXIgcmVzID0gZXh0ZW5kKHt9LCBwYXJlbnRDb25maWcpLCBwcm9wO1xuICAgIGZvciAocHJvcCBpbiBjaGlsZENvbmZpZykge1xuICAgICAgICBpZiAoaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkpIHtcbiAgICAgICAgICAgIGlmIChpc09iamVjdChwYXJlbnRDb25maWdbcHJvcF0pICYmIGlzT2JqZWN0KGNoaWxkQ29uZmlnW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IHt9O1xuICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIHBhcmVudENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICAgICAgZXh0ZW5kKHJlc1twcm9wXSwgY2hpbGRDb25maWdbcHJvcF0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZENvbmZpZ1twcm9wXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gY2hpbGRDb25maWdbcHJvcF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByZXNbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChwcm9wIGluIHBhcmVudENvbmZpZykge1xuICAgICAgICBpZiAoaGFzT3duUHJvcChwYXJlbnRDb25maWcsIHByb3ApICYmXG4gICAgICAgICAgICAgICAgIWhhc093blByb3AoY2hpbGRDb25maWcsIHByb3ApICYmXG4gICAgICAgICAgICAgICAgaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSkge1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGNoYW5nZXMgdG8gcHJvcGVydGllcyBkb24ndCBtb2RpZnkgcGFyZW50IGNvbmZpZ1xuICAgICAgICAgICAgcmVzW3Byb3BdID0gZXh0ZW5kKHt9LCByZXNbcHJvcF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIExvY2FsZShjb25maWcpIHtcbiAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5zZXQoY29uZmlnKTtcbiAgICB9XG59XG5cbnZhciBrZXlzO1xuXG5pZiAoT2JqZWN0LmtleXMpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXM7XG59IGVsc2Uge1xuICAgIGtleXMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciBpLCByZXMgPSBbXTtcbiAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3Aob2JqLCBpKSkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbn1cblxudmFyIGRlZmF1bHRDYWxlbmRhciA9IHtcbiAgICBzYW1lRGF5IDogJ1tUb2RheSBhdF0gTFQnLFxuICAgIG5leHREYXkgOiAnW1RvbW9ycm93IGF0XSBMVCcsXG4gICAgbmV4dFdlZWsgOiAnZGRkZCBbYXRdIExUJyxcbiAgICBsYXN0RGF5IDogJ1tZZXN0ZXJkYXkgYXRdIExUJyxcbiAgICBsYXN0V2VlayA6ICdbTGFzdF0gZGRkZCBbYXRdIExUJyxcbiAgICBzYW1lRWxzZSA6ICdMJ1xufTtcblxuZnVuY3Rpb24gY2FsZW5kYXIgKGtleSwgbW9tLCBub3cpIHtcbiAgICB2YXIgb3V0cHV0ID0gdGhpcy5fY2FsZW5kYXJba2V5XSB8fCB0aGlzLl9jYWxlbmRhclsnc2FtZUVsc2UnXTtcbiAgICByZXR1cm4gaXNGdW5jdGlvbihvdXRwdXQpID8gb3V0cHV0LmNhbGwobW9tLCBub3cpIDogb3V0cHV0O1xufVxuXG52YXIgZGVmYXVsdExvbmdEYXRlRm9ybWF0ID0ge1xuICAgIExUUyAgOiAnaDptbTpzcyBBJyxcbiAgICBMVCAgIDogJ2g6bW0gQScsXG4gICAgTCAgICA6ICdNTS9ERC9ZWVlZJyxcbiAgICBMTCAgIDogJ01NTU0gRCwgWVlZWScsXG4gICAgTExMICA6ICdNTU1NIEQsIFlZWVkgaDptbSBBJyxcbiAgICBMTExMIDogJ2RkZGQsIE1NTU0gRCwgWVlZWSBoOm1tIEEnXG59O1xuXG5mdW5jdGlvbiBsb25nRGF0ZUZvcm1hdCAoa2V5KSB7XG4gICAgdmFyIGZvcm1hdCA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0sXG4gICAgICAgIGZvcm1hdFVwcGVyID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5LnRvVXBwZXJDYXNlKCldO1xuXG4gICAgaWYgKGZvcm1hdCB8fCAhZm9ybWF0VXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG5cbiAgICB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldID0gZm9ybWF0VXBwZXIucmVwbGFjZSgvTU1NTXxNTXxERHxkZGRkL2csIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbC5zbGljZSgxKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldO1xufVxuXG52YXIgZGVmYXVsdEludmFsaWREYXRlID0gJ0ludmFsaWQgZGF0ZSc7XG5cbmZ1bmN0aW9uIGludmFsaWREYXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5faW52YWxpZERhdGU7XG59XG5cbnZhciBkZWZhdWx0T3JkaW5hbCA9ICclZCc7XG52YXIgZGVmYXVsdERheU9mTW9udGhPcmRpbmFsUGFyc2UgPSAvXFxkezEsMn0vO1xuXG5mdW5jdGlvbiBvcmRpbmFsIChudW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fb3JkaW5hbC5yZXBsYWNlKCclZCcsIG51bWJlcik7XG59XG5cbnZhciBkZWZhdWx0UmVsYXRpdmVUaW1lID0ge1xuICAgIGZ1dHVyZSA6ICdpbiAlcycsXG4gICAgcGFzdCAgIDogJyVzIGFnbycsXG4gICAgcyAgOiAnYSBmZXcgc2Vjb25kcycsXG4gICAgc3MgOiAnJWQgc2Vjb25kcycsXG4gICAgbSAgOiAnYSBtaW51dGUnLFxuICAgIG1tIDogJyVkIG1pbnV0ZXMnLFxuICAgIGggIDogJ2FuIGhvdXInLFxuICAgIGhoIDogJyVkIGhvdXJzJyxcbiAgICBkICA6ICdhIGRheScsXG4gICAgZGQgOiAnJWQgZGF5cycsXG4gICAgTSAgOiAnYSBtb250aCcsXG4gICAgTU0gOiAnJWQgbW9udGhzJyxcbiAgICB5ICA6ICdhIHllYXInLFxuICAgIHl5IDogJyVkIHllYXJzJ1xufTtcblxuZnVuY3Rpb24gcmVsYXRpdmVUaW1lIChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIHtcbiAgICB2YXIgb3V0cHV0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW3N0cmluZ107XG4gICAgcmV0dXJuIChpc0Z1bmN0aW9uKG91dHB1dCkpID9cbiAgICAgICAgb3V0cHV0KG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkgOlxuICAgICAgICBvdXRwdXQucmVwbGFjZSgvJWQvaSwgbnVtYmVyKTtcbn1cblxuZnVuY3Rpb24gcGFzdEZ1dHVyZSAoZGlmZiwgb3V0cHV0KSB7XG4gICAgdmFyIGZvcm1hdCA9IHRoaXMuX3JlbGF0aXZlVGltZVtkaWZmID4gMCA/ICdmdXR1cmUnIDogJ3Bhc3QnXTtcbiAgICByZXR1cm4gaXNGdW5jdGlvbihmb3JtYXQpID8gZm9ybWF0KG91dHB1dCkgOiBmb3JtYXQucmVwbGFjZSgvJXMvaSwgb3V0cHV0KTtcbn1cblxudmFyIGFsaWFzZXMgPSB7fTtcblxuZnVuY3Rpb24gYWRkVW5pdEFsaWFzICh1bml0LCBzaG9ydGhhbmQpIHtcbiAgICB2YXIgbG93ZXJDYXNlID0gdW5pdC50b0xvd2VyQ2FzZSgpO1xuICAgIGFsaWFzZXNbbG93ZXJDYXNlXSA9IGFsaWFzZXNbbG93ZXJDYXNlICsgJ3MnXSA9IGFsaWFzZXNbc2hvcnRoYW5kXSA9IHVuaXQ7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB1bml0cyA9PT0gJ3N0cmluZycgPyBhbGlhc2VzW3VuaXRzXSB8fCBhbGlhc2VzW3VuaXRzLnRvTG93ZXJDYXNlKCldIDogdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVPYmplY3RVbml0cyhpbnB1dE9iamVjdCkge1xuICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSB7fSxcbiAgICAgICAgbm9ybWFsaXplZFByb3AsXG4gICAgICAgIHByb3A7XG5cbiAgICBmb3IgKHByb3AgaW4gaW5wdXRPYmplY3QpIHtcbiAgICAgICAgaWYgKGhhc093blByb3AoaW5wdXRPYmplY3QsIHByb3ApKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkUHJvcCA9IG5vcm1hbGl6ZVVuaXRzKHByb3ApO1xuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRQcm9wKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZElucHV0W25vcm1hbGl6ZWRQcm9wXSA9IGlucHV0T2JqZWN0W3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRJbnB1dDtcbn1cblxudmFyIHByaW9yaXRpZXMgPSB7fTtcblxuZnVuY3Rpb24gYWRkVW5pdFByaW9yaXR5KHVuaXQsIHByaW9yaXR5KSB7XG4gICAgcHJpb3JpdGllc1t1bml0XSA9IHByaW9yaXR5O1xufVxuXG5mdW5jdGlvbiBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzT2JqKSB7XG4gICAgdmFyIHVuaXRzID0gW107XG4gICAgZm9yICh2YXIgdSBpbiB1bml0c09iaikge1xuICAgICAgICB1bml0cy5wdXNoKHt1bml0OiB1LCBwcmlvcml0eTogcHJpb3JpdGllc1t1XX0pO1xuICAgIH1cbiAgICB1bml0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eTtcbiAgICB9KTtcbiAgICByZXR1cm4gdW5pdHM7XG59XG5cbmZ1bmN0aW9uIHplcm9GaWxsKG51bWJlciwgdGFyZ2V0TGVuZ3RoLCBmb3JjZVNpZ24pIHtcbiAgICB2YXIgYWJzTnVtYmVyID0gJycgKyBNYXRoLmFicyhudW1iZXIpLFxuICAgICAgICB6ZXJvc1RvRmlsbCA9IHRhcmdldExlbmd0aCAtIGFic051bWJlci5sZW5ndGgsXG4gICAgICAgIHNpZ24gPSBudW1iZXIgPj0gMDtcbiAgICByZXR1cm4gKHNpZ24gPyAoZm9yY2VTaWduID8gJysnIDogJycpIDogJy0nKSArXG4gICAgICAgIE1hdGgucG93KDEwLCBNYXRoLm1heCgwLCB6ZXJvc1RvRmlsbCkpLnRvU3RyaW5nKCkuc3Vic3RyKDEpICsgYWJzTnVtYmVyO1xufVxuXG52YXIgZm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhbSGhdbW0oc3MpP3xNb3xNTT9NP00/fERvfERERG98REQ/RD9EP3xkZGQ/ZD98ZG8/fHdbb3x3XT98V1tvfFddP3xRbz98WVlZWVlZfFlZWVlZfFlZWVl8WVl8Z2coZ2dnPyk/fEdHKEdHRz8pP3xlfEV8YXxBfGhoP3xISD98a2s/fG1tP3xzcz98U3sxLDl9fHh8WHx6ej98Wlo/fC4pL2c7XG5cbnZhciBsb2NhbEZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oTFRTfExUfExMP0w/TD98bHsxLDR9KS9nO1xuXG52YXIgZm9ybWF0RnVuY3Rpb25zID0ge307XG5cbnZhciBmb3JtYXRUb2tlbkZ1bmN0aW9ucyA9IHt9O1xuXG4vLyB0b2tlbjogICAgJ00nXG4vLyBwYWRkZWQ6ICAgWydNTScsIDJdXG4vLyBvcmRpbmFsOiAgJ01vJ1xuLy8gY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHsgdGhpcy5tb250aCgpICsgMSB9XG5mdW5jdGlvbiBhZGRGb3JtYXRUb2tlbiAodG9rZW4sIHBhZGRlZCwgb3JkaW5hbCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZnVuYyA9IGNhbGxiYWNrO1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tjYWxsYmFja10oKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRva2VuKSB7XG4gICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSA9IGZ1bmM7XG4gICAgfVxuICAgIGlmIChwYWRkZWQpIHtcbiAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbcGFkZGVkWzBdXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB6ZXJvRmlsbChmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHBhZGRlZFsxXSwgcGFkZGVkWzJdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKG9yZGluYWwpIHtcbiAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbb3JkaW5hbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkub3JkaW5hbChmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRva2VuKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQubWF0Y2goL1xcW1tcXHNcXFNdLykpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL15cXFt8XFxdJC9nLCAnJyk7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9cXFxcL2csICcnKTtcbn1cblxuZnVuY3Rpb24gbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCkge1xuICAgIHZhciBhcnJheSA9IGZvcm1hdC5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSwgaSwgbGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXSkge1xuICAgICAgICAgICAgYXJyYXlbaV0gPSBmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcnJheVtpXSA9IHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoYXJyYXlbaV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb20pIHtcbiAgICAgICAgdmFyIG91dHB1dCA9ICcnLCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG91dHB1dCArPSBpc0Z1bmN0aW9uKGFycmF5W2ldKSA/IGFycmF5W2ldLmNhbGwobW9tLCBmb3JtYXQpIDogYXJyYXlbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xufVxuXG4vLyBmb3JtYXQgZGF0ZSB1c2luZyBuYXRpdmUgZGF0ZSBvYmplY3RcbmZ1bmN0aW9uIGZvcm1hdE1vbWVudChtLCBmb3JtYXQpIHtcbiAgICBpZiAoIW0uaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBtLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgIH1cblxuICAgIGZvcm1hdCA9IGV4cGFuZEZvcm1hdChmb3JtYXQsIG0ubG9jYWxlRGF0YSgpKTtcbiAgICBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSA9IGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdIHx8IG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpO1xuXG4gICAgcmV0dXJuIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdKG0pO1xufVxuXG5mdW5jdGlvbiBleHBhbmRGb3JtYXQoZm9ybWF0LCBsb2NhbGUpIHtcbiAgICB2YXIgaSA9IDU7XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5sb25nRGF0ZUZvcm1hdChpbnB1dCkgfHwgaW5wdXQ7XG4gICAgfVxuXG4gICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKGkgPj0gMCAmJiBsb2NhbEZvcm1hdHRpbmdUb2tlbnMudGVzdChmb3JtYXQpKSB7XG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKGxvY2FsRm9ybWF0dGluZ1Rva2VucywgcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKTtcbiAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIGkgLT0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm9ybWF0O1xufVxuXG52YXIgbWF0Y2gxICAgICAgICAgPSAvXFxkLzsgICAgICAgICAgICAvLyAgICAgICAwIC0gOVxudmFyIG1hdGNoMiAgICAgICAgID0gL1xcZFxcZC87ICAgICAgICAgIC8vICAgICAgMDAgLSA5OVxudmFyIG1hdGNoMyAgICAgICAgID0gL1xcZHszfS87ICAgICAgICAgLy8gICAgIDAwMCAtIDk5OVxudmFyIG1hdGNoNCAgICAgICAgID0gL1xcZHs0fS87ICAgICAgICAgLy8gICAgMDAwMCAtIDk5OTlcbnZhciBtYXRjaDYgICAgICAgICA9IC9bKy1dP1xcZHs2fS87ICAgIC8vIC05OTk5OTkgLSA5OTk5OTlcbnZhciBtYXRjaDF0bzIgICAgICA9IC9cXGRcXGQ/LzsgICAgICAgICAvLyAgICAgICAwIC0gOTlcbnZhciBtYXRjaDN0bzQgICAgICA9IC9cXGRcXGRcXGRcXGQ/LzsgICAgIC8vICAgICA5OTkgLSA5OTk5XG52YXIgbWF0Y2g1dG82ICAgICAgPSAvXFxkXFxkXFxkXFxkXFxkXFxkPy87IC8vICAgOTk5OTkgLSA5OTk5OTlcbnZhciBtYXRjaDF0bzMgICAgICA9IC9cXGR7MSwzfS87ICAgICAgIC8vICAgICAgIDAgLSA5OTlcbnZhciBtYXRjaDF0bzQgICAgICA9IC9cXGR7MSw0fS87ICAgICAgIC8vICAgICAgIDAgLSA5OTk5XG52YXIgbWF0Y2gxdG82ICAgICAgPSAvWystXT9cXGR7MSw2fS87ICAvLyAtOTk5OTk5IC0gOTk5OTk5XG5cbnZhciBtYXRjaFVuc2lnbmVkICA9IC9cXGQrLzsgICAgICAgICAgIC8vICAgICAgIDAgLSBpbmZcbnZhciBtYXRjaFNpZ25lZCAgICA9IC9bKy1dP1xcZCsvOyAgICAgIC8vICAgIC1pbmYgLSBpbmZcblxudmFyIG1hdGNoT2Zmc2V0ICAgID0gL1p8WystXVxcZFxcZDo/XFxkXFxkL2dpOyAvLyArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcbnZhciBtYXRjaFNob3J0T2Zmc2V0ID0gL1p8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8vZ2k7IC8vICswMCAtMDAgKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG5cbnZhciBtYXRjaFRpbWVzdGFtcCA9IC9bKy1dP1xcZCsoXFwuXFxkezEsM30pPy87IC8vIDEyMzQ1Njc4OSAxMjM0NTY3ODkuMTIzXG5cbi8vIGFueSB3b3JkIChvciB0d28pIGNoYXJhY3RlcnMgb3IgbnVtYmVycyBpbmNsdWRpbmcgdHdvL3RocmVlIHdvcmQgbW9udGggaW4gYXJhYmljLlxuLy8gaW5jbHVkZXMgc2NvdHRpc2ggZ2FlbGljIHR3byB3b3JkIGFuZCBoeXBoZW5hdGVkIG1vbnRoc1xudmFyIG1hdGNoV29yZCA9IC9bMC05XSpbJ2EtelxcdTAwQTAtXFx1MDVGRlxcdTA3MDAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0rfFtcXHUwNjAwLVxcdTA2RkZcXC9dKyhcXHMqP1tcXHUwNjAwLVxcdTA2RkZdKyl7MSwyfS9pO1xuXG5cbnZhciByZWdleGVzID0ge307XG5cbmZ1bmN0aW9uIGFkZFJlZ2V4VG9rZW4gKHRva2VuLCByZWdleCwgc3RyaWN0UmVnZXgpIHtcbiAgICByZWdleGVzW3Rva2VuXSA9IGlzRnVuY3Rpb24ocmVnZXgpID8gcmVnZXggOiBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIChpc1N0cmljdCAmJiBzdHJpY3RSZWdleCkgPyBzdHJpY3RSZWdleCA6IHJlZ2V4O1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldFBhcnNlUmVnZXhGb3JUb2tlbiAodG9rZW4sIGNvbmZpZykge1xuICAgIGlmICghaGFzT3duUHJvcChyZWdleGVzLCB0b2tlbikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodW5lc2NhcGVGb3JtYXQodG9rZW4pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVnZXhlc1t0b2tlbl0oY29uZmlnLl9zdHJpY3QsIGNvbmZpZy5fbG9jYWxlKTtcbn1cblxuLy8gQ29kZSBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzU2MTQ5My9pcy10aGVyZS1hLXJlZ2V4cC1lc2NhcGUtZnVuY3Rpb24taW4tamF2YXNjcmlwdFxuZnVuY3Rpb24gdW5lc2NhcGVGb3JtYXQocykge1xuICAgIHJldHVybiByZWdleEVzY2FwZShzLnJlcGxhY2UoJ1xcXFwnLCAnJykucmVwbGFjZSgvXFxcXChcXFspfFxcXFwoXFxdKXxcXFsoW15cXF1cXFtdKilcXF18XFxcXCguKS9nLCBmdW5jdGlvbiAobWF0Y2hlZCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgcmV0dXJuIHAxIHx8IHAyIHx8IHAzIHx8IHA0O1xuICAgIH0pKTtcbn1cblxuZnVuY3Rpb24gcmVnZXhFc2NhcGUocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xufVxuXG52YXIgdG9rZW5zID0ge307XG5cbmZ1bmN0aW9uIGFkZFBhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xuICAgIHZhciBpLCBmdW5jID0gY2FsbGJhY2s7XG4gICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdG9rZW4gPSBbdG9rZW5dO1xuICAgIH1cbiAgICBpZiAoaXNOdW1iZXIoY2FsbGJhY2spKSB7XG4gICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgICAgICBhcnJheVtjYWxsYmFja10gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB0b2tlbnNbdG9rZW5baV1dID0gZnVuYztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFkZFdlZWtQYXJzZVRva2VuICh0b2tlbiwgY2FsbGJhY2spIHtcbiAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIGNvbmZpZy5fdyA9IGNvbmZpZy5fdyB8fCB7fTtcbiAgICAgICAgY2FsbGJhY2soaW5wdXQsIGNvbmZpZy5fdywgY29uZmlnLCB0b2tlbik7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBpbnB1dCwgY29uZmlnKSB7XG4gICAgaWYgKGlucHV0ICE9IG51bGwgJiYgaGFzT3duUHJvcCh0b2tlbnMsIHRva2VuKSkge1xuICAgICAgICB0b2tlbnNbdG9rZW5dKGlucHV0LCBjb25maWcuX2EsIGNvbmZpZywgdG9rZW4pO1xuICAgIH1cbn1cblxudmFyIFlFQVIgPSAwO1xudmFyIE1PTlRIID0gMTtcbnZhciBEQVRFID0gMjtcbnZhciBIT1VSID0gMztcbnZhciBNSU5VVEUgPSA0O1xudmFyIFNFQ09ORCA9IDU7XG52YXIgTUlMTElTRUNPTkQgPSA2O1xudmFyIFdFRUsgPSA3O1xudmFyIFdFRUtEQVkgPSA4O1xuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdZJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB5ID0gdGhpcy55ZWFyKCk7XG4gICAgcmV0dXJuIHkgPD0gOTk5OSA/ICcnICsgeSA6ICcrJyArIHk7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oMCwgWydZWScsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMueWVhcigpICUgMTAwO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWScsICAgNF0sICAgICAgIDAsICd5ZWFyJyk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZJywgIDVdLCAgICAgICAwLCAneWVhcicpO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWVknLCA2LCB0cnVlXSwgMCwgJ3llYXInKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ3llYXInLCAneScpO1xuXG4vLyBQUklPUklUSUVTXG5cbmFkZFVuaXRQcmlvcml0eSgneWVhcicsIDEpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ1knLCAgICAgIG1hdGNoU2lnbmVkKTtcbmFkZFJlZ2V4VG9rZW4oJ1lZJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ1lZWVknLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbmFkZFJlZ2V4VG9rZW4oJ1lZWVlZJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbmFkZFJlZ2V4VG9rZW4oJ1lZWVlZWScsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuYWRkUGFyc2VUb2tlbihbJ1lZWVlZJywgJ1lZWVlZWSddLCBZRUFSKTtcbmFkZFBhcnNlVG9rZW4oJ1lZWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbWUVBUl0gPSBpbnB1dC5sZW5ndGggPT09IDIgPyBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCkgOiB0b0ludChpbnB1dCk7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ1lZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgIGFycmF5W1lFQVJdID0gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xufSk7XG5hZGRQYXJzZVRva2VuKCdZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgIGFycmF5W1lFQVJdID0gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbn0pO1xuXG4vLyBIRUxQRVJTXG5cbmZ1bmN0aW9uIGRheXNJblllYXIoeWVhcikge1xuICAgIHJldHVybiBpc0xlYXBZZWFyKHllYXIpID8gMzY2IDogMzY1O1xufVxuXG5mdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICByZXR1cm4gKHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDApIHx8IHllYXIgJSA0MDAgPT09IDA7XG59XG5cbi8vIEhPT0tTXG5cbmhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgcmV0dXJuIHRvSW50KGlucHV0KSArICh0b0ludChpbnB1dCkgPiA2OCA/IDE5MDAgOiAyMDAwKTtcbn07XG5cbi8vIE1PTUVOVFNcblxudmFyIGdldFNldFllYXIgPSBtYWtlR2V0U2V0KCdGdWxsWWVhcicsIHRydWUpO1xuXG5mdW5jdGlvbiBnZXRJc0xlYXBZZWFyICgpIHtcbiAgICByZXR1cm4gaXNMZWFwWWVhcih0aGlzLnllYXIoKSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VHZXRTZXQgKHVuaXQsIGtlZXBUaW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0JDEodGhpcywgdW5pdCwgdmFsdWUpO1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIGtlZXBUaW1lKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdldCh0aGlzLCB1bml0KTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldCAobW9tLCB1bml0KSB7XG4gICAgcmV0dXJuIG1vbS5pc1ZhbGlkKCkgP1xuICAgICAgICBtb20uX2RbJ2dldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oKSA6IE5hTjtcbn1cblxuZnVuY3Rpb24gc2V0JDEgKG1vbSwgdW5pdCwgdmFsdWUpIHtcbiAgICBpZiAobW9tLmlzVmFsaWQoKSAmJiAhaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIGlmICh1bml0ID09PSAnRnVsbFllYXInICYmIGlzTGVhcFllYXIobW9tLnllYXIoKSkpIHtcbiAgICAgICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSh2YWx1ZSwgbW9tLm1vbnRoKCksIGRheXNJbk1vbnRoKHZhbHVlLCBtb20ubW9udGgoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gTU9NRU5UU1xuXG5mdW5jdGlvbiBzdHJpbmdHZXQgKHVuaXRzKSB7XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cblxuXG5mdW5jdGlvbiBzdHJpbmdTZXQgKHVuaXRzLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdW5pdHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplT2JqZWN0VW5pdHModW5pdHMpO1xuICAgICAgICB2YXIgcHJpb3JpdGl6ZWQgPSBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmlvcml0aXplZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpc1twcmlvcml0aXplZFtpXS51bml0XSh1bml0c1twcmlvcml0aXplZFtpXS51bml0XSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10odmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBtb2QobiwgeCkge1xuICAgIHJldHVybiAoKG4gJSB4KSArIHgpICUgeDtcbn1cblxudmFyIGluZGV4T2Y7XG5cbmlmIChBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuICAgIGluZGV4T2YgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZjtcbn0gZWxzZSB7XG4gICAgaW5kZXhPZiA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIC8vIEkga25vd1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzW2ldID09PSBvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gICAgaWYgKGlzTmFOKHllYXIpIHx8IGlzTmFOKG1vbnRoKSkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICB2YXIgbW9kTW9udGggPSBtb2QobW9udGgsIDEyKTtcbiAgICB5ZWFyICs9IChtb250aCAtIG1vZE1vbnRoKSAvIDEyO1xuICAgIHJldHVybiBtb2RNb250aCA9PT0gMSA/IChpc0xlYXBZZWFyKHllYXIpID8gMjkgOiAyOCkgOiAoMzEgLSBtb2RNb250aCAlIDcgJSAyKTtcbn1cblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignTScsIFsnTU0nLCAyXSwgJ01vJywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1vbnRoKCkgKyAxO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKCdNTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRoc1Nob3J0KHRoaXMsIGZvcm1hdCk7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ01NTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRocyh0aGlzLCBmb3JtYXQpO1xufSk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdtb250aCcsICdNJyk7XG5cbi8vIFBSSU9SSVRZXG5cbmFkZFVuaXRQcmlvcml0eSgnbW9udGgnLCA4KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdNJywgICAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ01NJywgICBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdNTU0nLCAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xufSk7XG5hZGRSZWdleFRva2VuKCdNTU1NJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1JlZ2V4KGlzU3RyaWN0KTtcbn0pO1xuXG5hZGRQYXJzZVRva2VuKFsnTScsICdNTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbTU9OVEhdID0gdG9JbnQoaW5wdXQpIC0gMTtcbn0pO1xuXG5hZGRQYXJzZVRva2VuKFsnTU1NJywgJ01NTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgIHZhciBtb250aCA9IGNvbmZpZy5fbG9jYWxlLm1vbnRoc1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgIC8vIGlmIHdlIGRpZG4ndCBmaW5kIGEgbW9udGggbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkLlxuICAgIGlmIChtb250aCAhPSBudWxsKSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9IG1vbnRoO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRNb250aCA9IGlucHV0O1xuICAgIH1cbn0pO1xuXG4vLyBMT0NBTEVTXG5cbnZhciBNT05USFNfSU5fRk9STUFUID0gL0Rbb0RdPyhcXFtbXlxcW1xcXV0qXFxdfFxccykrTU1NTT8vO1xudmFyIGRlZmF1bHRMb2NhbGVNb250aHMgPSAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoJ18nKTtcbmZ1bmN0aW9uIGxvY2FsZU1vbnRocyAobSwgZm9ybWF0KSB7XG4gICAgaWYgKCFtKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocykgPyB0aGlzLl9tb250aHMgOlxuICAgICAgICAgICAgdGhpcy5fbW9udGhzWydzdGFuZGFsb25lJ107XG4gICAgfVxuICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocykgPyB0aGlzLl9tb250aHNbbS5tb250aCgpXSA6XG4gICAgICAgIHRoaXMuX21vbnRoc1sodGhpcy5fbW9udGhzLmlzRm9ybWF0IHx8IE1PTlRIU19JTl9GT1JNQVQpLnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLm1vbnRoKCldO1xufVxuXG52YXIgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0ID0gJ0phbl9GZWJfTWFyX0Fwcl9NYXlfSnVuX0p1bF9BdWdfU2VwX09jdF9Ob3ZfRGVjJy5zcGxpdCgnXycpO1xuZnVuY3Rpb24gbG9jYWxlTW9udGhzU2hvcnQgKG0sIGZvcm1hdCkge1xuICAgIGlmICghbSkge1xuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHNTaG9ydCkgPyB0aGlzLl9tb250aHNTaG9ydCA6XG4gICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFsnc3RhbmRhbG9uZSddO1xuICAgIH1cbiAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHNTaG9ydCkgPyB0aGlzLl9tb250aHNTaG9ydFttLm1vbnRoKCldIDpcbiAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRbTU9OVEhTX0lOX0ZPUk1BVC50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5tb250aCgpXTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlU3RyaWN0UGFyc2UobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgIHZhciBpLCBpaSwgbW9tLCBsbGMgPSBtb250aE5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgbm90IHVzZWRcbiAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyArK2kpIHtcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT09ICdNTU0nKSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBsb2NhbGVNb250aHNQYXJzZSAobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZVN0cmljdFBhcnNlLmNhbGwodGhpcywgbW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgIH1cblxuICAgIC8vIFRPRE86IGFkZCBzb3J0aW5nXG4gICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlclxuICAgIC8vIHNlZSBzb3J0aW5nIGluIGNvbXB1dGVNb250aHNQYXJzZVxuICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdHJpY3QgJiYgIXRoaXMuX21vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICByZWdleCA9ICdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTU0nICYmIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdNTU0nICYmIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX21vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIE1PTUVOVFNcblxuZnVuY3Rpb24gc2V0TW9udGggKG1vbSwgdmFsdWUpIHtcbiAgICB2YXIgZGF5T2ZNb250aDtcblxuICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAvLyBObyBvcFxuICAgICAgICByZXR1cm4gbW9tO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICgvXlxcZCskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB0b0ludCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG1vbS5sb2NhbGVEYXRhKCkubW9udGhzUGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgLy8gVE9ETzogQW5vdGhlciBzaWxlbnQgZmFpbHVyZT9cbiAgICAgICAgICAgIGlmICghaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRheU9mTW9udGggPSBNYXRoLm1pbihtb20uZGF0ZSgpLCBkYXlzSW5Nb250aChtb20ueWVhcigpLCB2YWx1ZSkpO1xuICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyAnTW9udGgnXSh2YWx1ZSwgZGF5T2ZNb250aCk7XG4gICAgcmV0dXJuIG1vbTtcbn1cblxuZnVuY3Rpb24gZ2V0U2V0TW9udGggKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgc2V0TW9udGgodGhpcywgdmFsdWUpO1xuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBnZXQodGhpcywgJ01vbnRoJyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXREYXlzSW5Nb250aCAoKSB7XG4gICAgcmV0dXJuIGRheXNJbk1vbnRoKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkpO1xufVxuXG52YXIgZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXggPSBtYXRjaFdvcmQ7XG5mdW5jdGlvbiBtb250aHNTaG9ydFJlZ2V4IChpc1N0cmljdCkge1xuICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1Nob3J0UmVnZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRSZWdleCA9IGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggOiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgIH1cbn1cblxudmFyIGRlZmF1bHRNb250aHNSZWdleCA9IG1hdGNoV29yZDtcbmZ1bmN0aW9uIG1vbnRoc1JlZ2V4IChpc1N0cmljdCkge1xuICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzUmVnZXggPSBkZWZhdWx0TW9udGhzUmVnZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4IDogdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjb21wdXRlTW9udGhzUGFyc2UgKCkge1xuICAgIGZ1bmN0aW9uIGNtcExlblJldihhLCBiKSB7XG4gICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgIH1cblxuICAgIHZhciBzaG9ydFBpZWNlcyA9IFtdLCBsb25nUGllY2VzID0gW10sIG1peGVkUGllY2VzID0gW10sXG4gICAgICAgIGksIG1vbTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgIHNob3J0UGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgICAgIGxvbmdQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgIG1peGVkUGllY2VzLnB1c2godGhpcy5tb250aHMobW9tLCAnJykpO1xuICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xuICAgIH1cbiAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIG1vbnRoIChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgIHNob3J0UGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgc2hvcnRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShzaG9ydFBpZWNlc1tpXSk7XG4gICAgICAgIGxvbmdQaWVjZXNbaV0gPSByZWdleEVzY2FwZShsb25nUGllY2VzW2ldKTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IDI0OyBpKyspIHtcbiAgICAgICAgbWl4ZWRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShtaXhlZFBpZWNlc1tpXSk7XG4gICAgfVxuXG4gICAgdGhpcy5fbW9udGhzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgdGhpcy5fbW9udGhzU2hvcnRSZWdleCA9IHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbG9uZ1BpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIHNob3J0UGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGF0ZSAoeSwgbSwgZCwgaCwgTSwgcywgbXMpIHtcbiAgICAvLyBjYW4ndCBqdXN0IGFwcGx5KCkgdG8gY3JlYXRlIGEgZGF0ZTpcbiAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMTgxMzQ4XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh5LCBtLCBkLCBoLCBNLCBzLCBtcyk7XG5cbiAgICAvLyB0aGUgZGF0ZSBjb25zdHJ1Y3RvciByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDAgJiYgaXNGaW5pdGUoZGF0ZS5nZXRGdWxsWWVhcigpKSkge1xuICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKHkpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVVRDRGF0ZSAoeSkge1xuICAgIHZhciBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG5cbiAgICAvLyB0aGUgRGF0ZS5VVEMgZnVuY3Rpb24gcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwICYmIGlzRmluaXRlKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSkpIHtcbiAgICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5KTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGU7XG59XG5cbi8vIHN0YXJ0LW9mLWZpcnN0LXdlZWsgLSBzdGFydC1vZi15ZWFyXG5mdW5jdGlvbiBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpIHtcbiAgICB2YXIgLy8gZmlyc3Qtd2VlayBkYXkgLS0gd2hpY2ggamFudWFyeSBpcyBhbHdheXMgaW4gdGhlIGZpcnN0IHdlZWsgKDQgZm9yIGlzbywgMSBmb3Igb3RoZXIpXG4gICAgICAgIGZ3ZCA9IDcgKyBkb3cgLSBkb3ksXG4gICAgICAgIC8vIGZpcnN0LXdlZWsgZGF5IGxvY2FsIHdlZWtkYXkgLS0gd2hpY2ggbG9jYWwgd2Vla2RheSBpcyBmd2RcbiAgICAgICAgZndkbHcgPSAoNyArIGNyZWF0ZVVUQ0RhdGUoeWVhciwgMCwgZndkKS5nZXRVVENEYXkoKSAtIGRvdykgJSA3O1xuXG4gICAgcmV0dXJuIC1md2RsdyArIGZ3ZCAtIDE7XG59XG5cbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGUjQ2FsY3VsYXRpbmdfYV9kYXRlX2dpdmVuX3RoZV95ZWFyLjJDX3dlZWtfbnVtYmVyX2FuZF93ZWVrZGF5XG5mdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla3MoeWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICB2YXIgbG9jYWxXZWVrZGF5ID0gKDcgKyB3ZWVrZGF5IC0gZG93KSAlIDcsXG4gICAgICAgIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICBkYXlPZlllYXIgPSAxICsgNyAqICh3ZWVrIC0gMSkgKyBsb2NhbFdlZWtkYXkgKyB3ZWVrT2Zmc2V0LFxuICAgICAgICByZXNZZWFyLCByZXNEYXlPZlllYXI7XG5cbiAgICBpZiAoZGF5T2ZZZWFyIDw9IDApIHtcbiAgICAgICAgcmVzWWVhciA9IHllYXIgLSAxO1xuICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlzSW5ZZWFyKHJlc1llYXIpICsgZGF5T2ZZZWFyO1xuICAgIH0gZWxzZSBpZiAoZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyKSkge1xuICAgICAgICByZXNZZWFyID0geWVhciArIDE7XG4gICAgICAgIHJlc0RheU9mWWVhciA9IGRheU9mWWVhciAtIGRheXNJblllYXIoeWVhcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzWWVhciA9IHllYXI7XG4gICAgICAgIHJlc0RheU9mWWVhciA9IGRheU9mWWVhcjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB5ZWFyOiByZXNZZWFyLFxuICAgICAgICBkYXlPZlllYXI6IHJlc0RheU9mWWVhclxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHdlZWtPZlllYXIobW9tLCBkb3csIGRveSkge1xuICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KG1vbS55ZWFyKCksIGRvdywgZG95KSxcbiAgICAgICAgd2VlayA9IE1hdGguZmxvb3IoKG1vbS5kYXlPZlllYXIoKSAtIHdlZWtPZmZzZXQgLSAxKSAvIDcpICsgMSxcbiAgICAgICAgcmVzV2VlaywgcmVzWWVhcjtcblxuICAgIGlmICh3ZWVrIDwgMSkge1xuICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSAtIDE7XG4gICAgICAgIHJlc1dlZWsgPSB3ZWVrICsgd2Vla3NJblllYXIocmVzWWVhciwgZG93LCBkb3kpO1xuICAgIH0gZWxzZSBpZiAod2VlayA+IHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KSkge1xuICAgICAgICByZXNXZWVrID0gd2VlayAtIHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KTtcbiAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpO1xuICAgICAgICByZXNXZWVrID0gd2VlaztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB3ZWVrOiByZXNXZWVrLFxuICAgICAgICB5ZWFyOiByZXNZZWFyXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gd2Vla3NJblllYXIoeWVhciwgZG93LCBkb3kpIHtcbiAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXG4gICAgICAgIHdlZWtPZmZzZXROZXh0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIgKyAxLCBkb3csIGRveSk7XG4gICAgcmV0dXJuIChkYXlzSW5ZZWFyKHllYXIpIC0gd2Vla09mZnNldCArIHdlZWtPZmZzZXROZXh0KSAvIDc7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ3cnLCBbJ3d3JywgMl0sICd3bycsICd3ZWVrJyk7XG5hZGRGb3JtYXRUb2tlbignVycsIFsnV1cnLCAyXSwgJ1dvJywgJ2lzb1dlZWsnKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ3dlZWsnLCAndycpO1xuYWRkVW5pdEFsaWFzKCdpc29XZWVrJywgJ1cnKTtcblxuLy8gUFJJT1JJVElFU1xuXG5hZGRVbml0UHJpb3JpdHkoJ3dlZWsnLCA1KTtcbmFkZFVuaXRQcmlvcml0eSgnaXNvV2VlaycsIDUpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ3cnLCAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ3d3JywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignVycsICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignV1cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbmFkZFdlZWtQYXJzZVRva2VuKFsndycsICd3dycsICdXJywgJ1dXJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDEpXSA9IHRvSW50KGlucHV0KTtcbn0pO1xuXG4vLyBIRUxQRVJTXG5cbi8vIExPQ0FMRVNcblxuZnVuY3Rpb24gbG9jYWxlV2VlayAobW9tKSB7XG4gICAgcmV0dXJuIHdlZWtPZlllYXIobW9tLCB0aGlzLl93ZWVrLmRvdywgdGhpcy5fd2Vlay5kb3kpLndlZWs7XG59XG5cbnZhciBkZWZhdWx0TG9jYWxlV2VlayA9IHtcbiAgICBkb3cgOiAwLCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG59O1xuXG5mdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mV2VlayAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlZWsuZG93O1xufVxuXG5mdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mWWVhciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlZWsuZG95O1xufVxuXG4vLyBNT01FTlRTXG5cbmZ1bmN0aW9uIGdldFNldFdlZWsgKGlucHV0KSB7XG4gICAgdmFyIHdlZWsgPSB0aGlzLmxvY2FsZURhdGEoKS53ZWVrKHRoaXMpO1xuICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2V0SVNPV2VlayAoaW5wdXQpIHtcbiAgICB2YXIgd2VlayA9IHdlZWtPZlllYXIodGhpcywgMSwgNCkud2VlaztcbiAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ2QnLCAwLCAnZG8nLCAnZGF5Jyk7XG5cbmFkZEZvcm1hdFRva2VuKCdkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNNaW4odGhpcywgZm9ybWF0KTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c1Nob3J0KHRoaXMsIGZvcm1hdCk7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ2RkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzKHRoaXMsIGZvcm1hdCk7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ2UnLCAwLCAwLCAnd2Vla2RheScpO1xuYWRkRm9ybWF0VG9rZW4oJ0UnLCAwLCAwLCAnaXNvV2Vla2RheScpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnZGF5JywgJ2QnKTtcbmFkZFVuaXRBbGlhcygnd2Vla2RheScsICdlJyk7XG5hZGRVbml0QWxpYXMoJ2lzb1dlZWtkYXknLCAnRScpO1xuXG4vLyBQUklPUklUWVxuYWRkVW5pdFByaW9yaXR5KCdkYXknLCAxMSk7XG5hZGRVbml0UHJpb3JpdHkoJ3dlZWtkYXknLCAxMSk7XG5hZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtkYXknLCAxMSk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignZCcsICAgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdlJywgICAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ0UnLCAgICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c01pblJlZ2V4KGlzU3RyaWN0KTtcbn0pO1xuYWRkUmVnZXhUb2tlbignZGRkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbn0pO1xuYWRkUmVnZXhUb2tlbignZGRkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUmVnZXgoaXNTdHJpY3QpO1xufSk7XG5cbmFkZFdlZWtQYXJzZVRva2VuKFsnZGQnLCAnZGRkJywgJ2RkZGQnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgdmFyIHdlZWtkYXkgPSBjb25maWcuX2xvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgIC8vIGlmIHdlIGRpZG4ndCBnZXQgYSB3ZWVrZGF5IG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZFxuICAgIGlmICh3ZWVrZGF5ICE9IG51bGwpIHtcbiAgICAgICAgd2Vlay5kID0gd2Vla2RheTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkV2Vla2RheSA9IGlucHV0O1xuICAgIH1cbn0pO1xuXG5hZGRXZWVrUGFyc2VUb2tlbihbJ2QnLCAnZScsICdFJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgIHdlZWtbdG9rZW5dID0gdG9JbnQoaW5wdXQpO1xufSk7XG5cbi8vIEhFTFBFUlNcblxuZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuXG4gICAgaWYgKCFpc05hTihpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgfVxuXG4gICAgaW5wdXQgPSBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCk7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwYXJzZUlzb1dlZWtkYXkoaW5wdXQsIGxvY2FsZSkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCkgJSA3IHx8IDc7XG4gICAgfVxuICAgIHJldHVybiBpc05hTihpbnB1dCkgPyBudWxsIDogaW5wdXQ7XG59XG5cbi8vIExPQ0FMRVNcblxudmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5cyA9ICdTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheScuc3BsaXQoJ18nKTtcbmZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzIChtLCBmb3JtYXQpIHtcbiAgICBpZiAoIW0pIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fd2Vla2RheXMpID8gdGhpcy5fd2Vla2RheXMgOlxuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNbJ3N0YW5kYWxvbmUnXTtcbiAgICB9XG4gICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fd2Vla2RheXMpID8gdGhpcy5fd2Vla2RheXNbbS5kYXkoKV0gOlxuICAgICAgICB0aGlzLl93ZWVrZGF5c1t0aGlzLl93ZWVrZGF5cy5pc0Zvcm1hdC50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5kYXkoKV07XG59XG5cbnZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCA9ICdTdW5fTW9uX1R1ZV9XZWRfVGh1X0ZyaV9TYXQnLnNwbGl0KCdfJyk7XG5mdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1Nob3J0IChtKSB7XG4gICAgcmV0dXJuIChtKSA/IHRoaXMuX3dlZWtkYXlzU2hvcnRbbS5kYXkoKV0gOiB0aGlzLl93ZWVrZGF5c1Nob3J0O1xufVxuXG52YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluID0gJ1N1X01vX1R1X1dlX1RoX0ZyX1NhJy5zcGxpdCgnXycpO1xuZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNNaW4gKG0pIHtcbiAgICByZXR1cm4gKG0pID8gdGhpcy5fd2Vla2RheXNNaW5bbS5kYXkoKV0gOiB0aGlzLl93ZWVrZGF5c01pbjtcbn1cblxuZnVuY3Rpb24gaGFuZGxlU3RyaWN0UGFyc2UkMSh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICB2YXIgaSwgaWksIG1vbSwgbGxjID0gd2Vla2RheU5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2UpIHtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyArK2kpIHtcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT09ICdkZGRkJykge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAnZGRkJykge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICdkZGQnKSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1BhcnNlICh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZVN0cmljdFBhcnNlJDEuY2FsbCh0aGlzLCB3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlID0gW107XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcblxuICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcLj8nKSArICckJywgJ2knKTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcLj8nKSArICckJywgJ2knKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykgKyAnfF4nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZGRkJyAmJiB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkZCcgJiYgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGQnICYmIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fd2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIE1PTUVOVFNcblxuZnVuY3Rpb24gZ2V0U2V0RGF5T2ZXZWVrIChpbnB1dCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgIH1cbiAgICB2YXIgZGF5ID0gdGhpcy5faXNVVEMgPyB0aGlzLl9kLmdldFVUQ0RheSgpIDogdGhpcy5fZC5nZXREYXkoKTtcbiAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICBpbnB1dCA9IHBhcnNlV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQoaW5wdXQgLSBkYXksICdkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRheTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldFNldExvY2FsZURheU9mV2VlayAoaW5wdXQpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICB9XG4gICAgdmFyIHdlZWtkYXkgPSAodGhpcy5kYXkoKSArIDcgLSB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3cpICUgNztcbiAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWtkYXkgOiB0aGlzLmFkZChpbnB1dCAtIHdlZWtkYXksICdkJyk7XG59XG5cbmZ1bmN0aW9uIGdldFNldElTT0RheU9mV2VlayAoaW5wdXQpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICB9XG5cbiAgICAvLyBiZWhhdmVzIHRoZSBzYW1lIGFzIG1vbWVudCNkYXkgZXhjZXB0XG4gICAgLy8gYXMgYSBnZXR0ZXIsIHJldHVybnMgNyBpbnN0ZWFkIG9mIDAgKDEtNyByYW5nZSBpbnN0ZWFkIG9mIDAtNilcbiAgICAvLyBhcyBhIHNldHRlciwgc3VuZGF5IHNob3VsZCBiZWxvbmcgdG8gdGhlIHByZXZpb3VzIHdlZWsuXG5cbiAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICB2YXIgd2Vla2RheSA9IHBhcnNlSXNvV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXkodGhpcy5kYXkoKSAlIDcgPyB3ZWVrZGF5IDogd2Vla2RheSAtIDcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRheSgpIHx8IDc7XG4gICAgfVxufVxuXG52YXIgZGVmYXVsdFdlZWtkYXlzUmVnZXggPSBtYXRjaFdvcmQ7XG5mdW5jdGlvbiB3ZWVrZGF5c1JlZ2V4IChpc1N0cmljdCkge1xuICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1JlZ2V4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgIH1cbn1cblxudmFyIGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXggPSBtYXRjaFdvcmQ7XG5mdW5jdGlvbiB3ZWVrZGF5c1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XG4gICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzU2hvcnRSZWdleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgIH1cbn1cblxudmFyIGRlZmF1bHRXZWVrZGF5c01pblJlZ2V4ID0gbWF0Y2hXb3JkO1xuZnVuY3Rpb24gd2Vla2RheXNNaW5SZWdleCAoaXNTdHJpY3QpIHtcbiAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c01pblJlZ2V4JykpIHtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSBkZWZhdWx0V2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gY29tcHV0ZVdlZWtkYXlzUGFyc2UgKCkge1xuICAgIGZ1bmN0aW9uIGNtcExlblJldihhLCBiKSB7XG4gICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgIH1cblxuICAgIHZhciBtaW5QaWVjZXMgPSBbXSwgc2hvcnRQaWVjZXMgPSBbXSwgbG9uZ1BpZWNlcyA9IFtdLCBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICBpLCBtb20sIG1pbnAsIHNob3J0cCwgbG9uZ3A7XG4gICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICBtaW5wID0gdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgc2hvcnRwID0gdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpO1xuICAgICAgICBsb25ncCA9IHRoaXMud2Vla2RheXMobW9tLCAnJyk7XG4gICAgICAgIG1pblBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICBzaG9ydFBpZWNlcy5wdXNoKHNob3J0cCk7XG4gICAgICAgIGxvbmdQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgIG1peGVkUGllY2VzLnB1c2gobWlucCk7XG4gICAgICAgIG1peGVkUGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChsb25ncCk7XG4gICAgfVxuICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgd2Vla2RheSAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlciBpdFxuICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICBtaW5QaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgIHNob3J0UGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgbG9uZ1BpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKGxvbmdQaWVjZXNbaV0pO1xuICAgICAgICBtaXhlZFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKG1peGVkUGllY2VzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLl93ZWVrZGF5c1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgdGhpcy5fd2Vla2RheXNNaW5SZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG5cbiAgICB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbG9uZ1BpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaW5QaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xufVxuXG4vLyBGT1JNQVRUSU5HXG5cbmZ1bmN0aW9uIGhGb3JtYXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaG91cnMoKSAlIDEyIHx8IDEyO1xufVxuXG5mdW5jdGlvbiBrRm9ybWF0KCkge1xuICAgIHJldHVybiB0aGlzLmhvdXJzKCkgfHwgMjQ7XG59XG5cbmFkZEZvcm1hdFRva2VuKCdIJywgWydISCcsIDJdLCAwLCAnaG91cicpO1xuYWRkRm9ybWF0VG9rZW4oJ2gnLCBbJ2hoJywgMl0sIDAsIGhGb3JtYXQpO1xuYWRkRm9ybWF0VG9rZW4oJ2snLCBbJ2trJywgMl0sIDAsIGtGb3JtYXQpO1xuXG5hZGRGb3JtYXRUb2tlbignaG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ2htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICB6ZXJvRmlsbCh0aGlzLnNlY29uZHMoKSwgMik7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ0htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJycgKyB0aGlzLmhvdXJzKCkgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ0htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnJyArIHRoaXMuaG91cnMoKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXG4gICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKTtcbn0pO1xuXG5mdW5jdGlvbiBtZXJpZGllbSAodG9rZW4sIGxvd2VyY2FzZSkge1xuICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tZXJpZGllbSh0aGlzLmhvdXJzKCksIHRoaXMubWludXRlcygpLCBsb3dlcmNhc2UpO1xuICAgIH0pO1xufVxuXG5tZXJpZGllbSgnYScsIHRydWUpO1xubWVyaWRpZW0oJ0EnLCBmYWxzZSk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdob3VyJywgJ2gnKTtcblxuLy8gUFJJT1JJVFlcbmFkZFVuaXRQcmlvcml0eSgnaG91cicsIDEzKTtcblxuLy8gUEFSU0lOR1xuXG5mdW5jdGlvbiBtYXRjaE1lcmlkaWVtIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS5fbWVyaWRpZW1QYXJzZTtcbn1cblxuYWRkUmVnZXhUb2tlbignYScsICBtYXRjaE1lcmlkaWVtKTtcbmFkZFJlZ2V4VG9rZW4oJ0EnLCAgbWF0Y2hNZXJpZGllbSk7XG5hZGRSZWdleFRva2VuKCdIJywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdoJywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdrJywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdISCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ2hoJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbigna2snLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbmFkZFJlZ2V4VG9rZW4oJ2htbScsIG1hdGNoM3RvNCk7XG5hZGRSZWdleFRva2VuKCdobW1zcycsIG1hdGNoNXRvNik7XG5hZGRSZWdleFRva2VuKCdIbW0nLCBtYXRjaDN0bzQpO1xuYWRkUmVnZXhUb2tlbignSG1tc3MnLCBtYXRjaDV0bzYpO1xuXG5hZGRQYXJzZVRva2VuKFsnSCcsICdISCddLCBIT1VSKTtcbmFkZFBhcnNlVG9rZW4oWydrJywgJ2trJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIHZhciBrSW5wdXQgPSB0b0ludChpbnB1dCk7XG4gICAgYXJyYXlbSE9VUl0gPSBrSW5wdXQgPT09IDI0ID8gMCA6IGtJbnB1dDtcbn0pO1xuYWRkUGFyc2VUb2tlbihbJ2EnLCAnQSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICBjb25maWcuX2lzUG0gPSBjb25maWcuX2xvY2FsZS5pc1BNKGlucHV0KTtcbiAgICBjb25maWcuX21lcmlkaWVtID0gaW5wdXQ7XG59KTtcbmFkZFBhcnNlVG9rZW4oWydoJywgJ2hoJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQpO1xuICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xufSk7XG5hZGRQYXJzZVRva2VuKCdobW0nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvcykpO1xuICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xufSk7XG5hZGRQYXJzZVRva2VuKCdobW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNDtcbiAgICB2YXIgcG9zMiA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgIGFycmF5W1NFQ09ORF0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMikpO1xuICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xufSk7XG5hZGRQYXJzZVRva2VuKCdIbW0nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvcykpO1xufSk7XG5hZGRQYXJzZVRva2VuKCdIbW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNDtcbiAgICB2YXIgcG9zMiA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgIGFycmF5W1NFQ09ORF0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMikpO1xufSk7XG5cbi8vIExPQ0FMRVNcblxuZnVuY3Rpb24gbG9jYWxlSXNQTSAoaW5wdXQpIHtcbiAgICAvLyBJRTggUXVpcmtzIE1vZGUgJiBJRTcgU3RhbmRhcmRzIE1vZGUgZG8gbm90IGFsbG93IGFjY2Vzc2luZyBzdHJpbmdzIGxpa2UgYXJyYXlzXG4gICAgLy8gVXNpbmcgY2hhckF0IHNob3VsZCBiZSBtb3JlIGNvbXBhdGlibGUuXG4gICAgcmV0dXJuICgoaW5wdXQgKyAnJykudG9Mb3dlckNhc2UoKS5jaGFyQXQoMCkgPT09ICdwJyk7XG59XG5cbnZhciBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZSA9IC9bYXBdXFwuP20/XFwuPy9pO1xuZnVuY3Rpb24gbG9jYWxlTWVyaWRpZW0gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XG4gICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAncG0nIDogJ1BNJztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdhbScgOiAnQU0nO1xuICAgIH1cbn1cblxuXG4vLyBNT01FTlRTXG5cbi8vIFNldHRpbmcgdGhlIGhvdXIgc2hvdWxkIGtlZXAgdGhlIHRpbWUsIGJlY2F1c2UgdGhlIHVzZXIgZXhwbGljaXRseVxuLy8gc3BlY2lmaWVkIHdoaWNoIGhvdXIgaGUgd2FudHMuIFNvIHRyeWluZyB0byBtYWludGFpbiB0aGUgc2FtZSBob3VyIChpblxuLy8gYSBuZXcgdGltZXpvbmUpIG1ha2VzIHNlbnNlLiBBZGRpbmcvc3VidHJhY3RpbmcgaG91cnMgZG9lcyBub3QgZm9sbG93XG4vLyB0aGlzIHJ1bGUuXG52YXIgZ2V0U2V0SG91ciA9IG1ha2VHZXRTZXQoJ0hvdXJzJywgdHJ1ZSk7XG5cbi8vIG1vbnRoc1xuLy8gd2Vla1xuLy8gd2Vla2RheXNcbi8vIG1lcmlkaWVtXG52YXIgYmFzZUNvbmZpZyA9IHtcbiAgICBjYWxlbmRhcjogZGVmYXVsdENhbGVuZGFyLFxuICAgIGxvbmdEYXRlRm9ybWF0OiBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQsXG4gICAgaW52YWxpZERhdGU6IGRlZmF1bHRJbnZhbGlkRGF0ZSxcbiAgICBvcmRpbmFsOiBkZWZhdWx0T3JkaW5hbCxcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSxcbiAgICByZWxhdGl2ZVRpbWU6IGRlZmF1bHRSZWxhdGl2ZVRpbWUsXG5cbiAgICBtb250aHM6IGRlZmF1bHRMb2NhbGVNb250aHMsXG4gICAgbW9udGhzU2hvcnQ6IGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCxcblxuICAgIHdlZWs6IGRlZmF1bHRMb2NhbGVXZWVrLFxuXG4gICAgd2Vla2RheXM6IGRlZmF1bHRMb2NhbGVXZWVrZGF5cyxcbiAgICB3ZWVrZGF5c01pbjogZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluLFxuICAgIHdlZWtkYXlzU2hvcnQ6IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0LFxuXG4gICAgbWVyaWRpZW1QYXJzZTogZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2Vcbn07XG5cbi8vIGludGVybmFsIHN0b3JhZ2UgZm9yIGxvY2FsZSBjb25maWcgZmlsZXNcbnZhciBsb2NhbGVzID0ge307XG52YXIgbG9jYWxlRmFtaWxpZXMgPSB7fTtcbnZhciBnbG9iYWxMb2NhbGU7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2FsZShrZXkpIHtcbiAgICByZXR1cm4ga2V5ID8ga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICctJykgOiBrZXk7XG59XG5cbi8vIHBpY2sgdGhlIGxvY2FsZSBmcm9tIHRoZSBhcnJheVxuLy8gdHJ5IFsnZW4tYXUnLCAnZW4tZ2InXSBhcyAnZW4tYXUnLCAnZW4tZ2InLCAnZW4nLCBhcyBpbiBtb3ZlIHRocm91Z2ggdGhlIGxpc3QgdHJ5aW5nIGVhY2hcbi8vIHN1YnN0cmluZyBmcm9tIG1vc3Qgc3BlY2lmaWMgdG8gbGVhc3QsIGJ1dCBtb3ZlIHRvIHRoZSBuZXh0IGFycmF5IGl0ZW0gaWYgaXQncyBhIG1vcmUgc3BlY2lmaWMgdmFyaWFudCB0aGFuIHRoZSBjdXJyZW50IHJvb3RcbmZ1bmN0aW9uIGNob29zZUxvY2FsZShuYW1lcykge1xuICAgIHZhciBpID0gMCwgaiwgbmV4dCwgbG9jYWxlLCBzcGxpdDtcblxuICAgIHdoaWxlIChpIDwgbmFtZXMubGVuZ3RoKSB7XG4gICAgICAgIHNwbGl0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2ldKS5zcGxpdCgnLScpO1xuICAgICAgICBqID0gc3BsaXQubGVuZ3RoO1xuICAgICAgICBuZXh0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2kgKyAxXSk7XG4gICAgICAgIG5leHQgPSBuZXh0ID8gbmV4dC5zcGxpdCgnLScpIDogbnVsbDtcbiAgICAgICAgd2hpbGUgKGogPiAwKSB7XG4gICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKHNwbGl0LnNsaWNlKDAsIGopLmpvaW4oJy0nKSk7XG4gICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQubGVuZ3RoID49IGogJiYgY29tcGFyZUFycmF5cyhzcGxpdCwgbmV4dCwgdHJ1ZSkgPj0gaiAtIDEpIHtcbiAgICAgICAgICAgICAgICAvL3RoZSBuZXh0IGFycmF5IGl0ZW0gaXMgYmV0dGVyIHRoYW4gYSBzaGFsbG93ZXIgc3Vic3RyaW5nIG9mIHRoaXMgb25lXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBqLS07XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gbG9hZExvY2FsZShuYW1lKSB7XG4gICAgdmFyIG9sZExvY2FsZSA9IG51bGw7XG4gICAgLy8gVE9ETzogRmluZCBhIGJldHRlciB3YXkgdG8gcmVnaXN0ZXIgYW5kIGxvYWQgYWxsIHRoZSBsb2NhbGVzIGluIE5vZGVcbiAgICBpZiAoIWxvY2FsZXNbbmFtZV0gJiYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvbGRMb2NhbGUgPSBnbG9iYWxMb2NhbGUuX2FiYnI7XG4gICAgICAgICAgICB2YXIgYWxpYXNlZFJlcXVpcmUgPSByZXF1aXJlO1xuICAgICAgICAgICAgYWxpYXNlZFJlcXVpcmUoJy4vbG9jYWxlLycgKyBuYW1lKTtcbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShvbGRMb2NhbGUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cbiAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbG9jYWxlIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxvY2FsZS4gIElmXG4vLyBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbiwgaXQgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZSBjdXJyZW50IGdsb2JhbFxuLy8gbG9jYWxlIGtleS5cbmZ1bmN0aW9uIGdldFNldEdsb2JhbExvY2FsZSAoa2V5LCB2YWx1ZXMpIHtcbiAgICB2YXIgZGF0YTtcbiAgICBpZiAoa2V5KSB7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZXMpKSB7XG4gICAgICAgICAgICBkYXRhID0gZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gZGVmaW5lTG9jYWxlKGtleSwgdmFsdWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAvLyBtb21lbnQuZHVyYXRpb24uX2xvY2FsZSA9IG1vbWVudC5fbG9jYWxlID0gZGF0YTtcbiAgICAgICAgICAgIGdsb2JhbExvY2FsZSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZ2xvYmFsTG9jYWxlLl9hYmJyO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVMb2NhbGUgKG5hbWUsIGNvbmZpZykge1xuICAgIGlmIChjb25maWcgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgIGNvbmZpZy5hYmJyID0gbmFtZTtcbiAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKCdkZWZpbmVMb2NhbGVPdmVycmlkZScsXG4gICAgICAgICAgICAgICAgICAgICd1c2UgbW9tZW50LnVwZGF0ZUxvY2FsZShsb2NhbGVOYW1lLCBjb25maWcpIHRvIGNoYW5nZSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2FuIGV4aXN0aW5nIGxvY2FsZS4gbW9tZW50LmRlZmluZUxvY2FsZShsb2NhbGVOYW1lLCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2NvbmZpZykgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlICcgK1xuICAgICAgICAgICAgICAgICAgICAnU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvZGVmaW5lLWxvY2FsZS8gZm9yIG1vcmUgaW5mby4nKTtcbiAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbbmFtZV0uX2NvbmZpZztcbiAgICAgICAgfSBlbHNlIGlmIChjb25maWcucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChsb2NhbGVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdLl9jb25maWc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbG9jYWxlc1tuYW1lXSA9IG5ldyBMb2NhbGUobWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKSk7XG5cbiAgICAgICAgaWYgKGxvY2FsZUZhbWlsaWVzW25hbWVdKSB7XG4gICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lTG9jYWxlKHgubmFtZSwgeC5jb25maWcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgLy8gbWFrZSBzdXJlIHdlIHNldCB0aGUgbG9jYWxlIEFGVEVSIGFsbCBjaGlsZCBsb2NhbGVzIGhhdmUgYmVlblxuICAgICAgICAvLyBjcmVhdGVkLCBzbyB3ZSB3b24ndCBlbmQgdXAgd2l0aCB0aGUgY2hpbGQgbG9jYWxlIHNldC5cbiAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuXG5cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdXNlZnVsIGZvciB0ZXN0aW5nXG4gICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxvY2FsZShuYW1lLCBjb25maWcpIHtcbiAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGxvY2FsZSwgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcbiAgICAgICAgLy8gTUVSR0VcbiAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tuYW1lXS5fY29uZmlnO1xuICAgICAgICB9XG4gICAgICAgIGNvbmZpZyA9IG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNvbmZpZyk7XG4gICAgICAgIGxvY2FsZSA9IG5ldyBMb2NhbGUoY29uZmlnKTtcbiAgICAgICAgbG9jYWxlLnBhcmVudExvY2FsZSA9IGxvY2FsZXNbbmFtZV07XG4gICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGU7XG5cbiAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBwYXNzIG51bGwgZm9yIGNvbmZpZyB0byB1bnVwZGF0ZSwgdXNlZnVsIGZvciB0ZXN0c1xuICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXS5wYXJlbnRMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG59XG5cbi8vIHJldHVybnMgbG9jYWxlIGRhdGFcbmZ1bmN0aW9uIGdldExvY2FsZSAoa2V5KSB7XG4gICAgdmFyIGxvY2FsZTtcblxuICAgIGlmIChrZXkgJiYga2V5Ll9sb2NhbGUgJiYga2V5Ll9sb2NhbGUuX2FiYnIpIHtcbiAgICAgICAga2V5ID0ga2V5Ll9sb2NhbGUuX2FiYnI7XG4gICAgfVxuXG4gICAgaWYgKCFrZXkpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZTtcbiAgICB9XG5cbiAgICBpZiAoIWlzQXJyYXkoa2V5KSkge1xuICAgICAgICAvL3Nob3J0LWNpcmN1aXQgZXZlcnl0aGluZyBlbHNlXG4gICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoa2V5KTtcbiAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBrZXkgPSBba2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hvb3NlTG9jYWxlKGtleSk7XG59XG5cbmZ1bmN0aW9uIGxpc3RMb2NhbGVzKCkge1xuICAgIHJldHVybiBrZXlzKGxvY2FsZXMpO1xufVxuXG5mdW5jdGlvbiBjaGVja092ZXJmbG93IChtKSB7XG4gICAgdmFyIG92ZXJmbG93O1xuICAgIHZhciBhID0gbS5fYTtcblxuICAgIGlmIChhICYmIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9PT0gLTIpIHtcbiAgICAgICAgb3ZlcmZsb3cgPVxuICAgICAgICAgICAgYVtNT05USF0gICAgICAgPCAwIHx8IGFbTU9OVEhdICAgICAgID4gMTEgID8gTU9OVEggOlxuICAgICAgICAgICAgYVtEQVRFXSAgICAgICAgPCAxIHx8IGFbREFURV0gICAgICAgID4gZGF5c0luTW9udGgoYVtZRUFSXSwgYVtNT05USF0pID8gREFURSA6XG4gICAgICAgICAgICBhW0hPVVJdICAgICAgICA8IDAgfHwgYVtIT1VSXSAgICAgICAgPiAyNCB8fCAoYVtIT1VSXSA9PT0gMjQgJiYgKGFbTUlOVVRFXSAhPT0gMCB8fCBhW1NFQ09ORF0gIT09IDAgfHwgYVtNSUxMSVNFQ09ORF0gIT09IDApKSA/IEhPVVIgOlxuICAgICAgICAgICAgYVtNSU5VVEVdICAgICAgPCAwIHx8IGFbTUlOVVRFXSAgICAgID4gNTkgID8gTUlOVVRFIDpcbiAgICAgICAgICAgIGFbU0VDT05EXSAgICAgIDwgMCB8fCBhW1NFQ09ORF0gICAgICA+IDU5ICA/IFNFQ09ORCA6XG4gICAgICAgICAgICBhW01JTExJU0VDT05EXSA8IDAgfHwgYVtNSUxMSVNFQ09ORF0gPiA5OTkgPyBNSUxMSVNFQ09ORCA6XG4gICAgICAgICAgICAtMTtcblxuICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd0RheU9mWWVhciAmJiAob3ZlcmZsb3cgPCBZRUFSIHx8IG92ZXJmbG93ID4gREFURSkpIHtcbiAgICAgICAgICAgIG92ZXJmbG93ID0gREFURTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd1dlZWtzICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla2RheSAmJiBvdmVyZmxvdyA9PT0gLTEpIHtcbiAgICAgICAgICAgIG92ZXJmbG93ID0gV0VFS0RBWTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9IG92ZXJmbG93O1xuICAgIH1cblxuICAgIHJldHVybiBtO1xufVxuXG4vLyBQaWNrIHRoZSBmaXJzdCBkZWZpbmVkIG9mIHR3byBvciB0aHJlZSBhcmd1bWVudHMuXG5mdW5jdGlvbiBkZWZhdWx0cyhhLCBiLCBjKSB7XG4gICAgaWYgKGEgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgaWYgKGIgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYjtcbiAgICB9XG4gICAgcmV0dXJuIGM7XG59XG5cbmZ1bmN0aW9uIGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKSB7XG4gICAgLy8gaG9va3MgaXMgYWN0dWFsbHkgdGhlIGV4cG9ydGVkIG1vbWVudCBvYmplY3RcbiAgICB2YXIgbm93VmFsdWUgPSBuZXcgRGF0ZShob29rcy5ub3coKSk7XG4gICAgaWYgKGNvbmZpZy5fdXNlVVRDKSB7XG4gICAgICAgIHJldHVybiBbbm93VmFsdWUuZ2V0VVRDRnVsbFllYXIoKSwgbm93VmFsdWUuZ2V0VVRDTW9udGgoKSwgbm93VmFsdWUuZ2V0VVRDRGF0ZSgpXTtcbiAgICB9XG4gICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRNb250aCgpLCBub3dWYWx1ZS5nZXREYXRlKCldO1xufVxuXG4vLyBjb252ZXJ0IGFuIGFycmF5IHRvIGEgZGF0ZS5cbi8vIHRoZSBhcnJheSBzaG91bGQgbWlycm9yIHRoZSBwYXJhbWV0ZXJzIGJlbG93XG4vLyBub3RlOiBhbGwgdmFsdWVzIHBhc3QgdGhlIHllYXIgYXJlIG9wdGlvbmFsIGFuZCB3aWxsIGRlZmF1bHQgdG8gdGhlIGxvd2VzdCBwb3NzaWJsZSB2YWx1ZS5cbi8vIFt5ZWFyLCBtb250aCwgZGF5ICwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXVxuZnVuY3Rpb24gY29uZmlnRnJvbUFycmF5IChjb25maWcpIHtcbiAgICB2YXIgaSwgZGF0ZSwgaW5wdXQgPSBbXSwgY3VycmVudERhdGUsIHllYXJUb1VzZTtcblxuICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN1cnJlbnREYXRlID0gY3VycmVudERhdGVBcnJheShjb25maWcpO1xuXG4gICAgLy9jb21wdXRlIGRheSBvZiB0aGUgeWVhciBmcm9tIHdlZWtzIGFuZCB3ZWVrZGF5c1xuICAgIGlmIChjb25maWcuX3cgJiYgY29uZmlnLl9hW0RBVEVdID09IG51bGwgJiYgY29uZmlnLl9hW01PTlRIXSA9PSBudWxsKSB7XG4gICAgICAgIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpO1xuICAgIH1cblxuICAgIC8vaWYgdGhlIGRheSBvZiB0aGUgeWVhciBpcyBzZXQsIGZpZ3VyZSBvdXQgd2hhdCBpdCBpc1xuICAgIGlmIChjb25maWcuX2RheU9mWWVhciAhPSBudWxsKSB7XG4gICAgICAgIHllYXJUb1VzZSA9IGRlZmF1bHRzKGNvbmZpZy5fYVtZRUFSXSwgY3VycmVudERhdGVbWUVBUl0pO1xuXG4gICAgICAgIGlmIChjb25maWcuX2RheU9mWWVhciA+IGRheXNJblllYXIoeWVhclRvVXNlKSB8fCBjb25maWcuX2RheU9mWWVhciA9PT0gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93RGF5T2ZZZWFyID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKHllYXJUb1VzZSwgMCwgY29uZmlnLl9kYXlPZlllYXIpO1xuICAgICAgICBjb25maWcuX2FbTU9OVEhdID0gZGF0ZS5nZXRVVENNb250aCgpO1xuICAgICAgICBjb25maWcuX2FbREFURV0gPSBkYXRlLmdldFVUQ0RhdGUoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IHRvIGN1cnJlbnQgZGF0ZS5cbiAgICAvLyAqIGlmIG5vIHllYXIsIG1vbnRoLCBkYXkgb2YgbW9udGggYXJlIGdpdmVuLCBkZWZhdWx0IHRvIHRvZGF5XG4gICAgLy8gKiBpZiBkYXkgb2YgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgbW9udGggYW5kIHllYXJcbiAgICAvLyAqIGlmIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG9ubHkgeWVhclxuICAgIC8vICogaWYgeWVhciBpcyBnaXZlbiwgZG9uJ3QgZGVmYXVsdCBhbnl0aGluZ1xuICAgIGZvciAoaSA9IDA7IGkgPCAzICYmIGNvbmZpZy5fYVtpXSA9PSBudWxsOyArK2kpIHtcbiAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSBjdXJyZW50RGF0ZVtpXTtcbiAgICB9XG5cbiAgICAvLyBaZXJvIG91dCB3aGF0ZXZlciB3YXMgbm90IGRlZmF1bHRlZCwgaW5jbHVkaW5nIHRpbWVcbiAgICBmb3IgKDsgaSA8IDc7IGkrKykge1xuICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IChjb25maWcuX2FbaV0gPT0gbnVsbCkgPyAoaSA9PT0gMiA/IDEgOiAwKSA6IGNvbmZpZy5fYVtpXTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgMjQ6MDA6MDAuMDAwXG4gICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA9PT0gMjQgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNSU5VVEVdID09PSAwICYmXG4gICAgICAgICAgICBjb25maWcuX2FbU0VDT05EXSA9PT0gMCAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW01JTExJU0VDT05EXSA9PT0gMCkge1xuICAgICAgICBjb25maWcuX25leHREYXkgPSB0cnVlO1xuICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAwO1xuICAgIH1cblxuICAgIGNvbmZpZy5fZCA9IChjb25maWcuX3VzZVVUQyA/IGNyZWF0ZVVUQ0RhdGUgOiBjcmVhdGVEYXRlKS5hcHBseShudWxsLCBpbnB1dCk7XG4gICAgLy8gQXBwbHkgdGltZXpvbmUgb2Zmc2V0IGZyb20gaW5wdXQuIFRoZSBhY3R1YWwgdXRjT2Zmc2V0IGNhbiBiZSBjaGFuZ2VkXG4gICAgLy8gd2l0aCBwYXJzZVpvbmUuXG4gICAgaWYgKGNvbmZpZy5fdHptICE9IG51bGwpIHtcbiAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLl9uZXh0RGF5KSB7XG4gICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDI0O1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZvciBtaXNtYXRjaGluZyBkYXkgb2Ygd2Vla1xuICAgIGlmIChjb25maWcuX3cgJiYgdHlwZW9mIGNvbmZpZy5fdy5kICE9PSAndW5kZWZpbmVkJyAmJiBjb25maWcuX3cuZCAhPT0gY29uZmlnLl9kLmdldERheSgpKSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLndlZWtkYXlNaXNtYXRjaCA9IHRydWU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKSB7XG4gICAgdmFyIHcsIHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSwgdGVtcCwgd2Vla2RheU92ZXJmbG93O1xuXG4gICAgdyA9IGNvbmZpZy5fdztcbiAgICBpZiAody5HRyAhPSBudWxsIHx8IHcuVyAhPSBudWxsIHx8IHcuRSAhPSBudWxsKSB7XG4gICAgICAgIGRvdyA9IDE7XG4gICAgICAgIGRveSA9IDQ7XG5cbiAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byB0YWtlIHRoZSBjdXJyZW50IGlzb1dlZWtZZWFyLCBidXQgdGhhdCBkZXBlbmRzIG9uXG4gICAgICAgIC8vIGhvdyB3ZSBpbnRlcnByZXQgbm93IChsb2NhbCwgdXRjLCBmaXhlZCBvZmZzZXQpLiBTbyBjcmVhdGVcbiAgICAgICAgLy8gYSBub3cgdmVyc2lvbiBvZiBjdXJyZW50IGNvbmZpZyAodGFrZSBsb2NhbC91dGMvb2Zmc2V0IGZsYWdzLCBhbmRcbiAgICAgICAgLy8gY3JlYXRlIG5vdykuXG4gICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMody5HRywgY29uZmlnLl9hW1lFQVJdLCB3ZWVrT2ZZZWFyKGNyZWF0ZUxvY2FsKCksIDEsIDQpLnllYXIpO1xuICAgICAgICB3ZWVrID0gZGVmYXVsdHMody5XLCAxKTtcbiAgICAgICAgd2Vla2RheSA9IGRlZmF1bHRzKHcuRSwgMSk7XG4gICAgICAgIGlmICh3ZWVrZGF5IDwgMSB8fCB3ZWVrZGF5ID4gNykge1xuICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGRvdyA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRvdztcbiAgICAgICAgZG95ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG95O1xuXG4gICAgICAgIHZhciBjdXJXZWVrID0gd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCBkb3csIGRveSk7XG5cbiAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyh3LmdnLCBjb25maWcuX2FbWUVBUl0sIGN1cldlZWsueWVhcik7XG5cbiAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IHdlZWsuXG4gICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LncsIGN1cldlZWsud2Vlayk7XG5cbiAgICAgICAgaWYgKHcuZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyB3ZWVrZGF5IC0tIGxvdyBkYXkgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBuZXh0IHdlZWtcbiAgICAgICAgICAgIHdlZWtkYXkgPSB3LmQ7XG4gICAgICAgICAgICBpZiAod2Vla2RheSA8IDAgfHwgd2Vla2RheSA+IDYpIHtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHcuZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBsb2NhbCB3ZWVrZGF5IC0tIGNvdW50aW5nIHN0YXJ0cyBmcm9tIGJlZ2luaW5nIG9mIHdlZWtcbiAgICAgICAgICAgIHdlZWtkYXkgPSB3LmUgKyBkb3c7XG4gICAgICAgICAgICBpZiAody5lIDwgMCB8fCB3LmUgPiA2KSB7XG4gICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgd2Vla2RheSA9IGRvdztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAod2VlayA8IDEgfHwgd2VlayA+IHdlZWtzSW5ZZWFyKHdlZWtZZWFyLCBkb3csIGRveSkpIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla3MgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAod2Vla2RheU92ZXJmbG93ICE9IG51bGwpIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla2RheSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGVtcCA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgICAgICBjb25maWcuX2FbWUVBUl0gPSB0ZW1wLnllYXI7XG4gICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdGVtcC5kYXlPZlllYXI7XG4gICAgfVxufVxuXG4vLyBpc28gODYwMSByZWdleFxuLy8gMDAwMC0wMC0wMCAwMDAwLVcwMCBvciAwMDAwLVcwMC0wICsgVCArIDAwIG9yIDAwOjAwIG9yIDAwOjAwOjAwIG9yIDAwOjAwOjAwLjAwMCArICswMDowMCBvciArMDAwMCBvciArMDApXG52YXIgZXh0ZW5kZWRJc29SZWdleCA9IC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSktKD86XFxkXFxkLVxcZFxcZHxXXFxkXFxkLVxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGQpKSg/OihUfCApKFxcZFxcZCg/OjpcXGRcXGQoPzo6XFxkXFxkKD86Wy4sXVxcZCspPyk/KT8pKFtcXCtcXC1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLztcbnZhciBiYXNpY0lzb1JlZ2V4ID0gL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KSg/OlxcZFxcZFxcZFxcZHxXXFxkXFxkXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZCkpKD86KFR8ICkoXFxkXFxkKD86XFxkXFxkKD86XFxkXFxkKD86Wy4sXVxcZCspPyk/KT8pKFtcXCtcXC1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLztcblxudmFyIHR6UmVnZXggPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy87XG5cbnZhciBpc29EYXRlcyA9IFtcbiAgICBbJ1lZWVlZWS1NTS1ERCcsIC9bKy1dXFxkezZ9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICBbJ1lZWVktTU0tREQnLCAvXFxkezR9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICBbJ0dHR0ctW1ddV1ctRScsIC9cXGR7NH0tV1xcZFxcZC1cXGQvXSxcbiAgICBbJ0dHR0ctW1ddV1cnLCAvXFxkezR9LVdcXGRcXGQvLCBmYWxzZV0sXG4gICAgWydZWVlZLURERCcsIC9cXGR7NH0tXFxkezN9L10sXG4gICAgWydZWVlZLU1NJywgL1xcZHs0fS1cXGRcXGQvLCBmYWxzZV0sXG4gICAgWydZWVlZWVlNTUREJywgL1srLV1cXGR7MTB9L10sXG4gICAgWydZWVlZTU1ERCcsIC9cXGR7OH0vXSxcbiAgICAvLyBZWVlZTU0gaXMgTk9UIGFsbG93ZWQgYnkgdGhlIHN0YW5kYXJkXG4gICAgWydHR0dHW1ddV1dFJywgL1xcZHs0fVdcXGR7M30vXSxcbiAgICBbJ0dHR0dbV11XVycsIC9cXGR7NH1XXFxkezJ9LywgZmFsc2VdLFxuICAgIFsnWVlZWURERCcsIC9cXGR7N30vXVxuXTtcblxuLy8gaXNvIHRpbWUgZm9ybWF0cyBhbmQgcmVnZXhlc1xudmFyIGlzb1RpbWVzID0gW1xuICAgIFsnSEg6bW06c3MuU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZFxcLlxcZCsvXSxcbiAgICBbJ0hIOm1tOnNzLFNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQsXFxkKy9dLFxuICAgIFsnSEg6bW06c3MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQvXSxcbiAgICBbJ0hIOm1tJywgL1xcZFxcZDpcXGRcXGQvXSxcbiAgICBbJ0hIbW1zcy5TU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZFxcLlxcZCsvXSxcbiAgICBbJ0hIbW1zcyxTU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZCxcXGQrL10sXG4gICAgWydISG1tc3MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkL10sXG4gICAgWydISG1tJywgL1xcZFxcZFxcZFxcZC9dLFxuICAgIFsnSEgnLCAvXFxkXFxkL11cbl07XG5cbnZhciBhc3BOZXRKc29uUmVnZXggPSAvXlxcLz9EYXRlXFwoKFxcLT9cXGQrKS9pO1xuXG4vLyBkYXRlIGZyb20gaXNvIGZvcm1hdFxuZnVuY3Rpb24gY29uZmlnRnJvbUlTTyhjb25maWcpIHtcbiAgICB2YXIgaSwgbCxcbiAgICAgICAgc3RyaW5nID0gY29uZmlnLl9pLFxuICAgICAgICBtYXRjaCA9IGV4dGVuZGVkSXNvUmVnZXguZXhlYyhzdHJpbmcpIHx8IGJhc2ljSXNvUmVnZXguZXhlYyhzdHJpbmcpLFxuICAgICAgICBhbGxvd1RpbWUsIGRhdGVGb3JtYXQsIHRpbWVGb3JtYXQsIHR6Rm9ybWF0O1xuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmlzbyA9IHRydWU7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb0RhdGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKGlzb0RhdGVzW2ldWzFdLmV4ZWMobWF0Y2hbMV0pKSB7XG4gICAgICAgICAgICAgICAgZGF0ZUZvcm1hdCA9IGlzb0RhdGVzW2ldWzBdO1xuICAgICAgICAgICAgICAgIGFsbG93VGltZSA9IGlzb0RhdGVzW2ldWzJdICE9PSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0ZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29UaW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNvVGltZXNbaV1bMV0uZXhlYyhtYXRjaFszXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2hbMl0gc2hvdWxkIGJlICdUJyBvciBzcGFjZVxuICAgICAgICAgICAgICAgICAgICB0aW1lRm9ybWF0ID0gKG1hdGNoWzJdIHx8ICcgJykgKyBpc29UaW1lc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpbWVGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFsbG93VGltZSAmJiB0aW1lRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaFs0XSkge1xuICAgICAgICAgICAgaWYgKHR6UmVnZXguZXhlYyhtYXRjaFs0XSkpIHtcbiAgICAgICAgICAgICAgICB0ekZvcm1hdCA9ICdaJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbmZpZy5fZiA9IGRhdGVGb3JtYXQgKyAodGltZUZvcm1hdCB8fCAnJykgKyAodHpGb3JtYXQgfHwgJycpO1xuICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgfVxufVxuXG4vLyBSRkMgMjgyMiByZWdleDogRm9yIGRldGFpbHMgc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyODIyI3NlY3Rpb24tMy4zXG52YXIgcmZjMjgyMiA9IC9eKD86KE1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1biksP1xccyk/KFxcZHsxLDJ9KVxccyhKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYylcXHMoXFxkezIsNH0pXFxzKFxcZFxcZCk6KFxcZFxcZCkoPzo6KFxcZFxcZCkpP1xccyg/OihVVHxHTVR8W0VDTVBdW1NEXVQpfChbWnpdKXwoWystXVxcZHs0fSkpJC87XG5cbmZ1bmN0aW9uIGV4dHJhY3RGcm9tUkZDMjgyMlN0cmluZ3MoeWVhclN0ciwgbW9udGhTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIpIHtcbiAgICB2YXIgcmVzdWx0ID0gW1xuICAgICAgICB1bnRydW5jYXRlWWVhcih5ZWFyU3RyKSxcbiAgICAgICAgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LmluZGV4T2YobW9udGhTdHIpLFxuICAgICAgICBwYXJzZUludChkYXlTdHIsIDEwKSxcbiAgICAgICAgcGFyc2VJbnQoaG91clN0ciwgMTApLFxuICAgICAgICBwYXJzZUludChtaW51dGVTdHIsIDEwKVxuICAgIF07XG5cbiAgICBpZiAoc2Vjb25kU3RyKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlSW50KHNlY29uZFN0ciwgMTApKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiB1bnRydW5jYXRlWWVhcih5ZWFyU3RyKSB7XG4gICAgdmFyIHllYXIgPSBwYXJzZUludCh5ZWFyU3RyLCAxMCk7XG4gICAgaWYgKHllYXIgPD0gNDkpIHtcbiAgICAgICAgcmV0dXJuIDIwMDAgKyB5ZWFyO1xuICAgIH0gZWxzZSBpZiAoeWVhciA8PSA5OTkpIHtcbiAgICAgICAgcmV0dXJuIDE5MDAgKyB5ZWFyO1xuICAgIH1cbiAgICByZXR1cm4geWVhcjtcbn1cblxuZnVuY3Rpb24gcHJlcHJvY2Vzc1JGQzI4MjIocykge1xuICAgIC8vIFJlbW92ZSBjb21tZW50cyBhbmQgZm9sZGluZyB3aGl0ZXNwYWNlIGFuZCByZXBsYWNlIG11bHRpcGxlLXNwYWNlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG4gICAgcmV0dXJuIHMucmVwbGFjZSgvXFwoW14pXSpcXCl8W1xcblxcdF0vZywgJyAnKS5yZXBsYWNlKC8oXFxzXFxzKykvZywgJyAnKS50cmltKCk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrV2Vla2RheSh3ZWVrZGF5U3RyLCBwYXJzZWRJbnB1dCwgY29uZmlnKSB7XG4gICAgaWYgKHdlZWtkYXlTdHIpIHtcbiAgICAgICAgLy8gVE9ETzogUmVwbGFjZSB0aGUgdmFuaWxsYSBKUyBEYXRlIG9iamVjdCB3aXRoIGFuIGluZGVwZW50ZW50IGRheS1vZi13ZWVrIGNoZWNrLlxuICAgICAgICB2YXIgd2Vla2RheVByb3ZpZGVkID0gZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQuaW5kZXhPZih3ZWVrZGF5U3RyKSxcbiAgICAgICAgICAgIHdlZWtkYXlBY3R1YWwgPSBuZXcgRGF0ZShwYXJzZWRJbnB1dFswXSwgcGFyc2VkSW5wdXRbMV0sIHBhcnNlZElucHV0WzJdKS5nZXREYXkoKTtcbiAgICAgICAgaWYgKHdlZWtkYXlQcm92aWRlZCAhPT0gd2Vla2RheUFjdHVhbCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykud2Vla2RheU1pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG52YXIgb2JzT2Zmc2V0cyA9IHtcbiAgICBVVDogMCxcbiAgICBHTVQ6IDAsXG4gICAgRURUOiAtNCAqIDYwLFxuICAgIEVTVDogLTUgKiA2MCxcbiAgICBDRFQ6IC01ICogNjAsXG4gICAgQ1NUOiAtNiAqIDYwLFxuICAgIE1EVDogLTYgKiA2MCxcbiAgICBNU1Q6IC03ICogNjAsXG4gICAgUERUOiAtNyAqIDYwLFxuICAgIFBTVDogLTggKiA2MFxufTtcblxuZnVuY3Rpb24gY2FsY3VsYXRlT2Zmc2V0KG9ic09mZnNldCwgbWlsaXRhcnlPZmZzZXQsIG51bU9mZnNldCkge1xuICAgIGlmIChvYnNPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG9ic09mZnNldHNbb2JzT2Zmc2V0XTtcbiAgICB9IGVsc2UgaWYgKG1pbGl0YXJ5T2Zmc2V0KSB7XG4gICAgICAgIC8vIHRoZSBvbmx5IGFsbG93ZWQgbWlsaXRhcnkgdHogaXMgWlxuICAgICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaG0gPSBwYXJzZUludChudW1PZmZzZXQsIDEwKTtcbiAgICAgICAgdmFyIG0gPSBobSAlIDEwMCwgaCA9IChobSAtIG0pIC8gMTAwO1xuICAgICAgICByZXR1cm4gaCAqIDYwICsgbTtcbiAgICB9XG59XG5cbi8vIGRhdGUgYW5kIHRpbWUgZnJvbSByZWYgMjgyMiBmb3JtYXRcbmZ1bmN0aW9uIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZykge1xuICAgIHZhciBtYXRjaCA9IHJmYzI4MjIuZXhlYyhwcmVwcm9jZXNzUkZDMjgyMihjb25maWcuX2kpKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdmFyIHBhcnNlZEFycmF5ID0gZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyhtYXRjaFs0XSwgbWF0Y2hbM10sIG1hdGNoWzJdLCBtYXRjaFs1XSwgbWF0Y2hbNl0sIG1hdGNoWzddKTtcbiAgICAgICAgaWYgKCFjaGVja1dlZWtkYXkobWF0Y2hbMV0sIHBhcnNlZEFycmF5LCBjb25maWcpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcuX2EgPSBwYXJzZWRBcnJheTtcbiAgICAgICAgY29uZmlnLl90em0gPSBjYWxjdWxhdGVPZmZzZXQobWF0Y2hbOF0sIG1hdGNoWzldLCBtYXRjaFsxMF0pO1xuXG4gICAgICAgIGNvbmZpZy5fZCA9IGNyZWF0ZVVUQ0RhdGUuYXBwbHkobnVsbCwgY29uZmlnLl9hKTtcbiAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcblxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5yZmMyODIyID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICB9XG59XG5cbi8vIGRhdGUgZnJvbSBpc28gZm9ybWF0IG9yIGZhbGxiYWNrXG5mdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nKGNvbmZpZykge1xuICAgIHZhciBtYXRjaGVkID0gYXNwTmV0SnNvblJlZ2V4LmV4ZWMoY29uZmlnLl9pKTtcblxuICAgIGlmIChtYXRjaGVkICE9PSBudWxsKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCttYXRjaGVkWzFdKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25maWdGcm9tUkZDMjgyMihjb25maWcpO1xuICAgIGlmIChjb25maWcuX2lzVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEZpbmFsIGF0dGVtcHQsIHVzZSBJbnB1dCBGYWxsYmFja1xuICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG59XG5cbmhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrID0gZGVwcmVjYXRlKFxuICAgICd2YWx1ZSBwcm92aWRlZCBpcyBub3QgaW4gYSByZWNvZ25pemVkIFJGQzI4MjIgb3IgSVNPIGZvcm1hdC4gbW9tZW50IGNvbnN0cnVjdGlvbiBmYWxscyBiYWNrIHRvIGpzIERhdGUoKSwgJyArXG4gICAgJ3doaWNoIGlzIG5vdCByZWxpYWJsZSBhY3Jvc3MgYWxsIGJyb3dzZXJzIGFuZCB2ZXJzaW9ucy4gTm9uIFJGQzI4MjIvSVNPIGRhdGUgZm9ybWF0cyBhcmUgJyArXG4gICAgJ2Rpc2NvdXJhZ2VkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYW4gdXBjb21pbmcgbWFqb3IgcmVsZWFzZS4gUGxlYXNlIHJlZmVyIHRvICcgK1xuICAgICdodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2pzLWRhdGUvIGZvciBtb3JlIGluZm8uJyxcbiAgICBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5faSArIChjb25maWcuX3VzZVVUQyA/ICcgVVRDJyA6ICcnKSk7XG4gICAgfVxuKTtcblxuLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIElTTyBzdGFuZGFyZFxuaG9va3MuSVNPXzg2MDEgPSBmdW5jdGlvbiAoKSB7fTtcblxuLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIFJGQyAyODIyIGZvcm1cbmhvb2tzLlJGQ18yODIyID0gZnVuY3Rpb24gKCkge307XG5cbi8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGZvcm1hdCBzdHJpbmdcbmZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKSB7XG4gICAgLy8gVE9ETzogTW92ZSB0aGlzIHRvIGFub3RoZXIgcGFydCBvZiB0aGUgY3JlYXRpb24gZmxvdyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcHNcbiAgICBpZiAoY29uZmlnLl9mID09PSBob29rcy5JU09fODYwMSkge1xuICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5fZiA9PT0gaG9va3MuUkZDXzI4MjIpIHtcbiAgICAgICAgY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25maWcuX2EgPSBbXTtcbiAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IHRydWU7XG5cbiAgICAvLyBUaGlzIGFycmF5IGlzIHVzZWQgdG8gbWFrZSBhIERhdGUsIGVpdGhlciB3aXRoIGBuZXcgRGF0ZWAgb3IgYERhdGUuVVRDYFxuICAgIHZhciBzdHJpbmcgPSAnJyArIGNvbmZpZy5faSxcbiAgICAgICAgaSwgcGFyc2VkSW5wdXQsIHRva2VucywgdG9rZW4sIHNraXBwZWQsXG4gICAgICAgIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG4gICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggPSAwO1xuXG4gICAgdG9rZW5zID0gZXhwYW5kRm9ybWF0KGNvbmZpZy5fZiwgY29uZmlnLl9sb2NhbGUpLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpIHx8IFtdO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgcGFyc2VkSW5wdXQgPSAoc3RyaW5nLm1hdGNoKGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSkgfHwgW10pWzBdO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygndG9rZW4nLCB0b2tlbiwgJ3BhcnNlZElucHV0JywgcGFyc2VkSW5wdXQsXG4gICAgICAgIC8vICAgICAgICAgJ3JlZ2V4JywgZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKTtcbiAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICBza2lwcGVkID0gc3RyaW5nLnN1YnN0cigwLCBzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkpO1xuICAgICAgICAgICAgaWYgKHNraXBwZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc2tpcHBlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2Uoc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpICsgcGFyc2VkSW5wdXQubGVuZ3RoKTtcbiAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggKz0gcGFyc2VkSW5wdXQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRvbid0IHBhcnNlIGlmIGl0J3Mgbm90IGEga25vd24gdG9rZW5cbiAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSkge1xuICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBwYXJzZWRJbnB1dCwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb25maWcuX3N0cmljdCAmJiAhcGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkZCByZW1haW5pbmcgdW5wYXJzZWQgaW5wdXQgbGVuZ3RoIHRvIHRoZSBzdHJpbmdcbiAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5jaGFyc0xlZnRPdmVyID0gc3RyaW5nTGVuZ3RoIC0gdG90YWxQYXJzZWRJbnB1dExlbmd0aDtcbiAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChzdHJpbmcpO1xuICAgIH1cblxuICAgIC8vIGNsZWFyIF8xMmggZmxhZyBpZiBob3VyIGlzIDw9IDEyXG4gICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA8PSAxMiAmJlxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID09PSB0cnVlICYmXG4gICAgICAgIGNvbmZpZy5fYVtIT1VSXSA+IDApIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5wYXJzZWREYXRlUGFydHMgPSBjb25maWcuX2Euc2xpY2UoMCk7XG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykubWVyaWRpZW0gPSBjb25maWcuX21lcmlkaWVtO1xuICAgIC8vIGhhbmRsZSBtZXJpZGllbVxuICAgIGNvbmZpZy5fYVtIT1VSXSA9IG1lcmlkaWVtRml4V3JhcChjb25maWcuX2xvY2FsZSwgY29uZmlnLl9hW0hPVVJdLCBjb25maWcuX21lcmlkaWVtKTtcblxuICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgIGNoZWNrT3ZlcmZsb3coY29uZmlnKTtcbn1cblxuXG5mdW5jdGlvbiBtZXJpZGllbUZpeFdyYXAgKGxvY2FsZSwgaG91ciwgbWVyaWRpZW0pIHtcbiAgICB2YXIgaXNQbTtcblxuICAgIGlmIChtZXJpZGllbSA9PSBudWxsKSB7XG4gICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgfVxuICAgIGlmIChsb2NhbGUubWVyaWRpZW1Ib3VyICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tZXJpZGllbUhvdXIoaG91ciwgbWVyaWRpZW0pO1xuICAgIH0gZWxzZSBpZiAobG9jYWxlLmlzUE0gIT0gbnVsbCkge1xuICAgICAgICAvLyBGYWxsYmFja1xuICAgICAgICBpc1BtID0gbG9jYWxlLmlzUE0obWVyaWRpZW0pO1xuICAgICAgICBpZiAoaXNQbSAmJiBob3VyIDwgMTIpIHtcbiAgICAgICAgICAgIGhvdXIgKz0gMTI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1BtICYmIGhvdXIgPT09IDEyKSB7XG4gICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaG91cjtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGlzIGlzIG5vdCBzdXBwb3NlZCB0byBoYXBwZW5cbiAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgfVxufVxuXG4vLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBhcnJheSBvZiBmb3JtYXQgc3RyaW5nc1xuZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZykge1xuICAgIHZhciB0ZW1wQ29uZmlnLFxuICAgICAgICBiZXN0TW9tZW50LFxuXG4gICAgICAgIHNjb3JlVG9CZWF0LFxuICAgICAgICBpLFxuICAgICAgICBjdXJyZW50U2NvcmU7XG5cbiAgICBpZiAoY29uZmlnLl9mLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkRm9ybWF0ID0gdHJ1ZTtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoTmFOKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBjb25maWcuX2YubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3VycmVudFNjb3JlID0gMDtcbiAgICAgICAgdGVtcENvbmZpZyA9IGNvcHlDb25maWcoe30sIGNvbmZpZyk7XG4gICAgICAgIGlmIChjb25maWcuX3VzZVVUQyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0ZW1wQ29uZmlnLl91c2VVVEMgPSBjb25maWcuX3VzZVVUQztcbiAgICAgICAgfVxuICAgICAgICB0ZW1wQ29uZmlnLl9mID0gY29uZmlnLl9mW2ldO1xuICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KHRlbXBDb25maWcpO1xuXG4gICAgICAgIGlmICghaXNWYWxpZCh0ZW1wQ29uZmlnKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbnkgaW5wdXQgdGhhdCB3YXMgbm90IHBhcnNlZCBhZGQgYSBwZW5hbHR5IGZvciB0aGF0IGZvcm1hdFxuICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLmNoYXJzTGVmdE92ZXI7XG5cbiAgICAgICAgLy9vciB0b2tlbnNcbiAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS51bnVzZWRUb2tlbnMubGVuZ3RoICogMTA7XG5cbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnNjb3JlID0gY3VycmVudFNjb3JlO1xuXG4gICAgICAgIGlmIChzY29yZVRvQmVhdCA9PSBudWxsIHx8IGN1cnJlbnRTY29yZSA8IHNjb3JlVG9CZWF0KSB7XG4gICAgICAgICAgICBzY29yZVRvQmVhdCA9IGN1cnJlbnRTY29yZTtcbiAgICAgICAgICAgIGJlc3RNb21lbnQgPSB0ZW1wQ29uZmlnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXh0ZW5kKGNvbmZpZywgYmVzdE1vbWVudCB8fCB0ZW1wQ29uZmlnKTtcbn1cblxuZnVuY3Rpb24gY29uZmlnRnJvbU9iamVjdChjb25maWcpIHtcbiAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaSA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGNvbmZpZy5faSk7XG4gICAgY29uZmlnLl9hID0gbWFwKFtpLnllYXIsIGkubW9udGgsIGkuZGF5IHx8IGkuZGF0ZSwgaS5ob3VyLCBpLm1pbnV0ZSwgaS5zZWNvbmQsIGkubWlsbGlzZWNvbmRdLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgfSk7XG5cbiAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRnJvbUNvbmZpZyAoY29uZmlnKSB7XG4gICAgdmFyIHJlcyA9IG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhwcmVwYXJlQ29uZmlnKGNvbmZpZykpKTtcbiAgICBpZiAocmVzLl9uZXh0RGF5KSB7XG4gICAgICAgIC8vIEFkZGluZyBpcyBzbWFydCBlbm91Z2ggYXJvdW5kIERTVFxuICAgICAgICByZXMuYWRkKDEsICdkJyk7XG4gICAgICAgIHJlcy5fbmV4dERheSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlQ29uZmlnIChjb25maWcpIHtcbiAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksXG4gICAgICAgIGZvcm1hdCA9IGNvbmZpZy5fZjtcblxuICAgIGNvbmZpZy5fbG9jYWxlID0gY29uZmlnLl9sb2NhbGUgfHwgZ2V0TG9jYWxlKGNvbmZpZy5fbCk7XG5cbiAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgKGZvcm1hdCA9PT0gdW5kZWZpbmVkICYmIGlucHV0ID09PSAnJykpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoe251bGxJbnB1dDogdHJ1ZX0pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbmZpZy5faSA9IGlucHV0ID0gY29uZmlnLl9sb2NhbGUucHJlcGFyc2UoaW5wdXQpO1xuICAgIH1cblxuICAgIGlmIChpc01vbWVudChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhpbnB1dCkpO1xuICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICBjb25maWcuX2QgPSBpbnB1dDtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZm9ybWF0KSkge1xuICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKTtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdCkge1xuICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgfSAgZWxzZSB7XG4gICAgICAgIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpO1xuICAgIH1cblxuICAgIGlmICghaXNWYWxpZChjb25maWcpKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmZpZztcbn1cblxuZnVuY3Rpb24gY29uZmlnRnJvbUlucHV0KGNvbmZpZykge1xuICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faTtcbiAgICBpZiAoaXNVbmRlZmluZWQoaW5wdXQpKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGhvb2tzLm5vdygpKTtcbiAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQudmFsdWVPZigpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uZmlnRnJvbVN0cmluZyhjb25maWcpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgY29uZmlnLl9hID0gbWFwKGlucHV0LnNsaWNlKDApLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGlucHV0KSkge1xuICAgICAgICBjb25maWdGcm9tT2JqZWN0KGNvbmZpZyk7XG4gICAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkpIHtcbiAgICAgICAgLy8gZnJvbSBtaWxsaXNlY29uZHNcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVMb2NhbE9yVVRDIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgaXNVVEMpIHtcbiAgICB2YXIgYyA9IHt9O1xuXG4gICAgaWYgKGxvY2FsZSA9PT0gdHJ1ZSB8fCBsb2NhbGUgPT09IGZhbHNlKSB7XG4gICAgICAgIHN0cmljdCA9IGxvY2FsZTtcbiAgICAgICAgbG9jYWxlID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICgoaXNPYmplY3QoaW5wdXQpICYmIGlzT2JqZWN0RW1wdHkoaW5wdXQpKSB8fFxuICAgICAgICAgICAgKGlzQXJyYXkoaW5wdXQpICYmIGlucHV0Lmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgaW5wdXQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIG9iamVjdCBjb25zdHJ1Y3Rpb24gbXVzdCBiZSBkb25lIHRoaXMgd2F5LlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNDIzXG4gICAgYy5faXNBTW9tZW50T2JqZWN0ID0gdHJ1ZTtcbiAgICBjLl91c2VVVEMgPSBjLl9pc1VUQyA9IGlzVVRDO1xuICAgIGMuX2wgPSBsb2NhbGU7XG4gICAgYy5faSA9IGlucHV0O1xuICAgIGMuX2YgPSBmb3JtYXQ7XG4gICAgYy5fc3RyaWN0ID0gc3RyaWN0O1xuXG4gICAgcmV0dXJuIGNyZWF0ZUZyb21Db25maWcoYyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvY2FsIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBmYWxzZSk7XG59XG5cbnZhciBwcm90b3R5cGVNaW4gPSBkZXByZWNhdGUoXG4gICAgJ21vbWVudCgpLm1pbiBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1heCBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBvdGhlciA8IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICB9XG4gICAgfVxuKTtcblxudmFyIHByb3RvdHlwZU1heCA9IGRlcHJlY2F0ZShcbiAgICAnbW9tZW50KCkubWF4IGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWluIGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG90aGVyID4gdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgIH1cbiAgICB9XG4pO1xuXG4vLyBQaWNrIGEgbW9tZW50IG0gZnJvbSBtb21lbnRzIHNvIHRoYXQgbVtmbl0ob3RoZXIpIGlzIHRydWUgZm9yIGFsbFxuLy8gb3RoZXIuIFRoaXMgcmVsaWVzIG9uIHRoZSBmdW5jdGlvbiBmbiB0byBiZSB0cmFuc2l0aXZlLlxuLy9cbi8vIG1vbWVudHMgc2hvdWxkIGVpdGhlciBiZSBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cyBvciBhbiBhcnJheSwgd2hvc2Vcbi8vIGZpcnN0IGVsZW1lbnQgaXMgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMuXG5mdW5jdGlvbiBwaWNrQnkoZm4sIG1vbWVudHMpIHtcbiAgICB2YXIgcmVzLCBpO1xuICAgIGlmIChtb21lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KG1vbWVudHNbMF0pKSB7XG4gICAgICAgIG1vbWVudHMgPSBtb21lbnRzWzBdO1xuICAgIH1cbiAgICBpZiAoIW1vbWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbCgpO1xuICAgIH1cbiAgICByZXMgPSBtb21lbnRzWzBdO1xuICAgIGZvciAoaSA9IDE7IGkgPCBtb21lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICghbW9tZW50c1tpXS5pc1ZhbGlkKCkgfHwgbW9tZW50c1tpXVtmbl0ocmVzKSkge1xuICAgICAgICAgICAgcmVzID0gbW9tZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBUT0RPOiBVc2UgW10uc29ydCBpbnN0ZWFkP1xuZnVuY3Rpb24gbWluICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgIHJldHVybiBwaWNrQnkoJ2lzQmVmb3JlJywgYXJncyk7XG59XG5cbmZ1bmN0aW9uIG1heCAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICByZXR1cm4gcGlja0J5KCdpc0FmdGVyJywgYXJncyk7XG59XG5cbnZhciBub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIERhdGUubm93ID8gRGF0ZS5ub3coKSA6ICsobmV3IERhdGUoKSk7XG59O1xuXG52YXIgb3JkZXJpbmcgPSBbJ3llYXInLCAncXVhcnRlcicsICdtb250aCcsICd3ZWVrJywgJ2RheScsICdob3VyJywgJ21pbnV0ZScsICdzZWNvbmQnLCAnbWlsbGlzZWNvbmQnXTtcblxuZnVuY3Rpb24gaXNEdXJhdGlvblZhbGlkKG0pIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gbSkge1xuICAgICAgICBpZiAoIShpbmRleE9mLmNhbGwob3JkZXJpbmcsIGtleSkgIT09IC0xICYmIChtW2tleV0gPT0gbnVsbCB8fCAhaXNOYU4obVtrZXldKSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5pdEhhc0RlY2ltYWwgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyaW5nLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChtW29yZGVyaW5nW2ldXSkge1xuICAgICAgICAgICAgaWYgKHVuaXRIYXNEZWNpbWFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBvbmx5IGFsbG93IG5vbi1pbnRlZ2VycyBmb3Igc21hbGxlc3QgdW5pdFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcnNlRmxvYXQobVtvcmRlcmluZ1tpXV0pICE9PSB0b0ludChtW29yZGVyaW5nW2ldXSkpIHtcbiAgICAgICAgICAgICAgICB1bml0SGFzRGVjaW1hbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZCQxKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1ZhbGlkO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJbnZhbGlkJDEoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKE5hTik7XG59XG5cbmZ1bmN0aW9uIER1cmF0aW9uIChkdXJhdGlvbikge1xuICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSBub3JtYWxpemVPYmplY3RVbml0cyhkdXJhdGlvbiksXG4gICAgICAgIHllYXJzID0gbm9ybWFsaXplZElucHV0LnllYXIgfHwgMCxcbiAgICAgICAgcXVhcnRlcnMgPSBub3JtYWxpemVkSW5wdXQucXVhcnRlciB8fCAwLFxuICAgICAgICBtb250aHMgPSBub3JtYWxpemVkSW5wdXQubW9udGggfHwgMCxcbiAgICAgICAgd2Vla3MgPSBub3JtYWxpemVkSW5wdXQud2VlayB8fCAwLFxuICAgICAgICBkYXlzID0gbm9ybWFsaXplZElucHV0LmRheSB8fCAwLFxuICAgICAgICBob3VycyA9IG5vcm1hbGl6ZWRJbnB1dC5ob3VyIHx8IDAsXG4gICAgICAgIG1pbnV0ZXMgPSBub3JtYWxpemVkSW5wdXQubWludXRlIHx8IDAsXG4gICAgICAgIHNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQuc2Vjb25kIHx8IDAsXG4gICAgICAgIG1pbGxpc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5taWxsaXNlY29uZCB8fCAwO1xuXG4gICAgdGhpcy5faXNWYWxpZCA9IGlzRHVyYXRpb25WYWxpZChub3JtYWxpemVkSW5wdXQpO1xuXG4gICAgLy8gcmVwcmVzZW50YXRpb24gZm9yIGRhdGVBZGRSZW1vdmVcbiAgICB0aGlzLl9taWxsaXNlY29uZHMgPSArbWlsbGlzZWNvbmRzICtcbiAgICAgICAgc2Vjb25kcyAqIDFlMyArIC8vIDEwMDBcbiAgICAgICAgbWludXRlcyAqIDZlNCArIC8vIDEwMDAgKiA2MFxuICAgICAgICBob3VycyAqIDEwMDAgKiA2MCAqIDYwOyAvL3VzaW5nIDEwMDAgKiA2MCAqIDYwIGluc3RlYWQgb2YgMzZlNSB0byBhdm9pZCBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvcnMgaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzI5NzhcbiAgICAvLyBCZWNhdXNlIG9mIGRhdGVBZGRSZW1vdmUgdHJlYXRzIDI0IGhvdXJzIGFzIGRpZmZlcmVudCBmcm9tIGFcbiAgICAvLyBkYXkgd2hlbiB3b3JraW5nIGFyb3VuZCBEU1QsIHdlIG5lZWQgdG8gc3RvcmUgdGhlbSBzZXBhcmF0ZWx5XG4gICAgdGhpcy5fZGF5cyA9ICtkYXlzICtcbiAgICAgICAgd2Vla3MgKiA3O1xuICAgIC8vIEl0IGlzIGltcG9zc2libGUgdG8gdHJhbnNsYXRlIG1vbnRocyBpbnRvIGRheXMgd2l0aG91dCBrbm93aW5nXG4gICAgLy8gd2hpY2ggbW9udGhzIHlvdSBhcmUgYXJlIHRhbGtpbmcgYWJvdXQsIHNvIHdlIGhhdmUgdG8gc3RvcmVcbiAgICAvLyBpdCBzZXBhcmF0ZWx5LlxuICAgIHRoaXMuX21vbnRocyA9ICttb250aHMgK1xuICAgICAgICBxdWFydGVycyAqIDMgK1xuICAgICAgICB5ZWFycyAqIDEyO1xuXG4gICAgdGhpcy5fZGF0YSA9IHt9O1xuXG4gICAgdGhpcy5fbG9jYWxlID0gZ2V0TG9jYWxlKCk7XG5cbiAgICB0aGlzLl9idWJibGUoKTtcbn1cblxuZnVuY3Rpb24gaXNEdXJhdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIER1cmF0aW9uO1xufVxuXG5mdW5jdGlvbiBhYnNSb3VuZCAobnVtYmVyKSB7XG4gICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoLTEgKiBudW1iZXIpICogLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQobnVtYmVyKTtcbiAgICB9XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuZnVuY3Rpb24gb2Zmc2V0ICh0b2tlbiwgc2VwYXJhdG9yKSB7XG4gICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICAgIHZhciBzaWduID0gJysnO1xuICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gLW9mZnNldDtcbiAgICAgICAgICAgIHNpZ24gPSAnLSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpZ24gKyB6ZXJvRmlsbCh+fihvZmZzZXQgLyA2MCksIDIpICsgc2VwYXJhdG9yICsgemVyb0ZpbGwofn4ob2Zmc2V0KSAlIDYwLCAyKTtcbiAgICB9KTtcbn1cblxub2Zmc2V0KCdaJywgJzonKTtcbm9mZnNldCgnWlonLCAnJyk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignWicsICBtYXRjaFNob3J0T2Zmc2V0KTtcbmFkZFJlZ2V4VG9rZW4oJ1paJywgbWF0Y2hTaG9ydE9mZnNldCk7XG5hZGRQYXJzZVRva2VuKFsnWicsICdaWiddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICBjb25maWcuX3VzZVVUQyA9IHRydWU7XG4gICAgY29uZmlnLl90em0gPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbn0pO1xuXG4vLyBIRUxQRVJTXG5cbi8vIHRpbWV6b25lIGNodW5rZXJcbi8vICcrMTA6MDAnID4gWycxMCcsICAnMDAnXVxuLy8gJy0xNTMwJyAgPiBbJy0xNScsICczMCddXG52YXIgY2h1bmtPZmZzZXQgPSAvKFtcXCtcXC1dfFxcZFxcZCkvZ2k7XG5cbmZ1bmN0aW9uIG9mZnNldEZyb21TdHJpbmcobWF0Y2hlciwgc3RyaW5nKSB7XG4gICAgdmFyIG1hdGNoZXMgPSAoc3RyaW5nIHx8ICcnKS5tYXRjaChtYXRjaGVyKTtcblxuICAgIGlmIChtYXRjaGVzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBjaHVuayAgID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdIHx8IFtdO1xuICAgIHZhciBwYXJ0cyAgID0gKGNodW5rICsgJycpLm1hdGNoKGNodW5rT2Zmc2V0KSB8fCBbJy0nLCAwLCAwXTtcbiAgICB2YXIgbWludXRlcyA9ICsocGFydHNbMV0gKiA2MCkgKyB0b0ludChwYXJ0c1syXSk7XG5cbiAgICByZXR1cm4gbWludXRlcyA9PT0gMCA/XG4gICAgICAwIDpcbiAgICAgIHBhcnRzWzBdID09PSAnKycgPyBtaW51dGVzIDogLW1pbnV0ZXM7XG59XG5cbi8vIFJldHVybiBhIG1vbWVudCBmcm9tIGlucHV0LCB0aGF0IGlzIGxvY2FsL3V0Yy96b25lIGVxdWl2YWxlbnQgdG8gbW9kZWwuXG5mdW5jdGlvbiBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIG1vZGVsKSB7XG4gICAgdmFyIHJlcywgZGlmZjtcbiAgICBpZiAobW9kZWwuX2lzVVRDKSB7XG4gICAgICAgIHJlcyA9IG1vZGVsLmNsb25lKCk7XG4gICAgICAgIGRpZmYgPSAoaXNNb21lbnQoaW5wdXQpIHx8IGlzRGF0ZShpbnB1dCkgPyBpbnB1dC52YWx1ZU9mKCkgOiBjcmVhdGVMb2NhbChpbnB1dCkudmFsdWVPZigpKSAtIHJlcy52YWx1ZU9mKCk7XG4gICAgICAgIC8vIFVzZSBsb3ctbGV2ZWwgYXBpLCBiZWNhdXNlIHRoaXMgZm4gaXMgbG93LWxldmVsIGFwaS5cbiAgICAgICAgcmVzLl9kLnNldFRpbWUocmVzLl9kLnZhbHVlT2YoKSArIGRpZmYpO1xuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQocmVzLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0KS5sb2NhbCgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGF0ZU9mZnNldCAobSkge1xuICAgIC8vIE9uIEZpcmVmb3guMjQgRGF0ZSNnZXRUaW1lem9uZU9mZnNldCByZXR1cm5zIGEgZmxvYXRpbmcgcG9pbnQuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvcHVsbC8xODcxXG4gICAgcmV0dXJuIC1NYXRoLnJvdW5kKG0uX2QuZ2V0VGltZXpvbmVPZmZzZXQoKSAvIDE1KSAqIDE1O1xufVxuXG4vLyBIT09LU1xuXG4vLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIGEgbW9tZW50IGlzIG11dGF0ZWQuXG4vLyBJdCBpcyBpbnRlbmRlZCB0byBrZWVwIHRoZSBvZmZzZXQgaW4gc3luYyB3aXRoIHRoZSB0aW1lem9uZS5cbmhvb2tzLnVwZGF0ZU9mZnNldCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4vLyBNT01FTlRTXG5cbi8vIGtlZXBMb2NhbFRpbWUgPSB0cnVlIG1lYW5zIG9ubHkgY2hhbmdlIHRoZSB0aW1lem9uZSwgd2l0aG91dFxuLy8gYWZmZWN0aW5nIHRoZSBsb2NhbCBob3VyLiBTbyA1OjMxOjI2ICswMzAwIC0tW3V0Y09mZnNldCgyLCB0cnVlKV0tLT5cbi8vIDU6MzE6MjYgKzAyMDAgSXQgaXMgcG9zc2libGUgdGhhdCA1OjMxOjI2IGRvZXNuJ3QgZXhpc3Qgd2l0aCBvZmZzZXRcbi8vICswMjAwLCBzbyB3ZSBhZGp1c3QgdGhlIHRpbWUgYXMgbmVlZGVkLCB0byBiZSB2YWxpZC5cbi8vXG4vLyBLZWVwaW5nIHRoZSB0aW1lIGFjdHVhbGx5IGFkZHMvc3VidHJhY3RzIChvbmUgaG91cilcbi8vIGZyb20gdGhlIGFjdHVhbCByZXByZXNlbnRlZCB0aW1lLiBUaGF0IGlzIHdoeSB3ZSBjYWxsIHVwZGF0ZU9mZnNldFxuLy8gYSBzZWNvbmQgdGltZS4gSW4gY2FzZSBpdCB3YW50cyB1cyB0byBjaGFuZ2UgdGhlIG9mZnNldCBhZ2FpblxuLy8gX2NoYW5nZUluUHJvZ3Jlc3MgPT0gdHJ1ZSBjYXNlLCB0aGVuIHdlIGhhdmUgdG8gYWRqdXN0LCBiZWNhdXNlXG4vLyB0aGVyZSBpcyBubyBzdWNoIHRpbWUgaW4gdGhlIGdpdmVuIHRpbWV6b25lLlxuZnVuY3Rpb24gZ2V0U2V0T2Zmc2V0IChpbnB1dCwga2VlcExvY2FsVGltZSwga2VlcE1pbnV0ZXMpIHtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0IHx8IDAsXG4gICAgICAgIGxvY2FsQWRqdXN0O1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgIH1cbiAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaW5wdXQgPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGlucHV0KSA8IDE2ICYmICFrZWVwTWludXRlcykge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dCAqIDYwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faXNVVEMgJiYga2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgbG9jYWxBZGp1c3QgPSBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29mZnNldCA9IGlucHV0O1xuICAgICAgICB0aGlzLl9pc1VUQyA9IHRydWU7XG4gICAgICAgIGlmIChsb2NhbEFkanVzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmFkZChsb2NhbEFkanVzdCwgJ20nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0ICE9PSBpbnB1dCkge1xuICAgICAgICAgICAgaWYgKCFrZWVwTG9jYWxUaW1lIHx8IHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICBhZGRTdWJ0cmFjdCh0aGlzLCBjcmVhdGVEdXJhdGlvbihpbnB1dCAtIG9mZnNldCwgJ20nKSwgMSwgZmFsc2UpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyBvZmZzZXQgOiBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2V0Wm9uZSAoaW5wdXQsIGtlZXBMb2NhbFRpbWUpIHtcbiAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaW5wdXQgPSAtaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnV0Y09mZnNldChpbnB1dCwga2VlcExvY2FsVGltZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC10aGlzLnV0Y09mZnNldCgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0T2Zmc2V0VG9VVEMgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICByZXR1cm4gdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG59XG5cbmZ1bmN0aW9uIHNldE9mZnNldFRvTG9jYWwgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICBpZiAodGhpcy5faXNVVEMpIHtcbiAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgICAgIHRoaXMuX2lzVVRDID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMuc3VidHJhY3QoZ2V0RGF0ZU9mZnNldCh0aGlzKSwgJ20nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQgKCkge1xuICAgIGlmICh0aGlzLl90em0gIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnV0Y09mZnNldCh0aGlzLl90em0sIGZhbHNlLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9pID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgdFpvbmUgPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoT2Zmc2V0LCB0aGlzLl9pKTtcbiAgICAgICAgaWYgKHRab25lICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KHRab25lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBoYXNBbGlnbmVkSG91ck9mZnNldCAoaW5wdXQpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaW5wdXQgPSBpbnB1dCA/IGNyZWF0ZUxvY2FsKGlucHV0KS51dGNPZmZzZXQoKSA6IDA7XG5cbiAgICByZXR1cm4gKHRoaXMudXRjT2Zmc2V0KCkgLSBpbnB1dCkgJSA2MCA9PT0gMDtcbn1cblxuZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWUgKCkge1xuICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoMCkudXRjT2Zmc2V0KCkgfHxcbiAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCg1KS51dGNPZmZzZXQoKVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZCAoKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9pc0RTVFNoaWZ0ZWQpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgfVxuXG4gICAgdmFyIGMgPSB7fTtcblxuICAgIGNvcHlDb25maWcoYywgdGhpcyk7XG4gICAgYyA9IHByZXBhcmVDb25maWcoYyk7XG5cbiAgICBpZiAoYy5fYSkge1xuICAgICAgICB2YXIgb3RoZXIgPSBjLl9pc1VUQyA/IGNyZWF0ZVVUQyhjLl9hKSA6IGNyZWF0ZUxvY2FsKGMuX2EpO1xuICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSB0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgY29tcGFyZUFycmF5cyhjLl9hLCBvdGhlci50b0FycmF5KCkpID4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xufVxuXG5mdW5jdGlvbiBpc0xvY2FsICgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyAhdGhpcy5faXNVVEMgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNVdGNPZmZzZXQgKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVXRjICgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyAmJiB0aGlzLl9vZmZzZXQgPT09IDAgOiBmYWxzZTtcbn1cblxuLy8gQVNQLk5FVCBqc29uIGRhdGUgZm9ybWF0IHJlZ2V4XG52YXIgYXNwTmV0UmVnZXggPSAvXihcXC18XFwrKT8oPzooXFxkKilbLiBdKT8oXFxkKylcXDooXFxkKykoPzpcXDooXFxkKykoXFwuXFxkKik/KT8kLztcblxuLy8gZnJvbSBodHRwOi8vZG9jcy5jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vZ2l0L2Nsb3N1cmVfZ29vZ19kYXRlX2RhdGUuanMuc291cmNlLmh0bWxcbi8vIHNvbWV3aGF0IG1vcmUgaW4gbGluZSB3aXRoIDQuNC4zLjIgMjAwNCBzcGVjLCBidXQgYWxsb3dzIGRlY2ltYWwgYW55d2hlcmVcbi8vIGFuZCBmdXJ0aGVyIG1vZGlmaWVkIHRvIGFsbG93IGZvciBzdHJpbmdzIGNvbnRhaW5pbmcgYm90aCB3ZWVrIGFuZCBkYXlcbnZhciBpc29SZWdleCA9IC9eKC18XFwrKT9QKD86KFstK10/WzAtOSwuXSopWSk/KD86KFstK10/WzAtOSwuXSopTSk/KD86KFstK10/WzAtOSwuXSopVyk/KD86KFstK10/WzAtOSwuXSopRCk/KD86VCg/OihbLStdP1swLTksLl0qKUgpPyg/OihbLStdP1swLTksLl0qKU0pPyg/OihbLStdP1swLTksLl0qKVMpPyk/JC87XG5cbmZ1bmN0aW9uIGNyZWF0ZUR1cmF0aW9uIChpbnB1dCwga2V5KSB7XG4gICAgdmFyIGR1cmF0aW9uID0gaW5wdXQsXG4gICAgICAgIC8vIG1hdGNoaW5nIGFnYWluc3QgcmVnZXhwIGlzIGV4cGVuc2l2ZSwgZG8gaXQgb24gZGVtYW5kXG4gICAgICAgIG1hdGNoID0gbnVsbCxcbiAgICAgICAgc2lnbixcbiAgICAgICAgcmV0LFxuICAgICAgICBkaWZmUmVzO1xuXG4gICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpKSB7XG4gICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgbXMgOiBpbnB1dC5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgZCAgOiBpbnB1dC5fZGF5cyxcbiAgICAgICAgICAgIE0gIDogaW5wdXQuX21vbnRoc1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uW2tleV0gPSBpbnB1dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGR1cmF0aW9uLm1pbGxpc2Vjb25kcyA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGFzcE5ldFJlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSAnLScpID8gLTEgOiAxO1xuICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgIHkgIDogMCxcbiAgICAgICAgICAgIGQgIDogdG9JbnQobWF0Y2hbREFURV0pICAgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgIGggIDogdG9JbnQobWF0Y2hbSE9VUl0pICAgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgIG0gIDogdG9JbnQobWF0Y2hbTUlOVVRFXSkgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgIHMgIDogdG9JbnQobWF0Y2hbU0VDT05EXSkgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgIG1zIDogdG9JbnQoYWJzUm91bmQobWF0Y2hbTUlMTElTRUNPTkRdICogMTAwMCkpICogc2lnbiAvLyB0aGUgbWlsbGlzZWNvbmQgZGVjaW1hbCBwb2ludCBpcyBpbmNsdWRlZCBpbiB0aGUgbWF0Y2hcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gaXNvUmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IChtYXRjaFsxXSA9PT0gJysnKSA/IDEgOiAxO1xuICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgIHkgOiBwYXJzZUlzbyhtYXRjaFsyXSwgc2lnbiksXG4gICAgICAgICAgICBNIDogcGFyc2VJc28obWF0Y2hbM10sIHNpZ24pLFxuICAgICAgICAgICAgdyA6IHBhcnNlSXNvKG1hdGNoWzRdLCBzaWduKSxcbiAgICAgICAgICAgIGQgOiBwYXJzZUlzbyhtYXRjaFs1XSwgc2lnbiksXG4gICAgICAgICAgICBoIDogcGFyc2VJc28obWF0Y2hbNl0sIHNpZ24pLFxuICAgICAgICAgICAgbSA6IHBhcnNlSXNvKG1hdGNoWzddLCBzaWduKSxcbiAgICAgICAgICAgIHMgOiBwYXJzZUlzbyhtYXRjaFs4XSwgc2lnbilcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGR1cmF0aW9uID09IG51bGwpIHsvLyBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdvYmplY3QnICYmICgnZnJvbScgaW4gZHVyYXRpb24gfHwgJ3RvJyBpbiBkdXJhdGlvbikpIHtcbiAgICAgICAgZGlmZlJlcyA9IG1vbWVudHNEaWZmZXJlbmNlKGNyZWF0ZUxvY2FsKGR1cmF0aW9uLmZyb20pLCBjcmVhdGVMb2NhbChkdXJhdGlvbi50bykpO1xuXG4gICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgIGR1cmF0aW9uLm1zID0gZGlmZlJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgIGR1cmF0aW9uLk0gPSBkaWZmUmVzLm1vbnRocztcbiAgICB9XG5cbiAgICByZXQgPSBuZXcgRHVyYXRpb24oZHVyYXRpb24pO1xuXG4gICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpICYmIGhhc093blByb3AoaW5wdXQsICdfbG9jYWxlJykpIHtcbiAgICAgICAgcmV0Ll9sb2NhbGUgPSBpbnB1dC5fbG9jYWxlO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG59XG5cbmNyZWF0ZUR1cmF0aW9uLmZuID0gRHVyYXRpb24ucHJvdG90eXBlO1xuY3JlYXRlRHVyYXRpb24uaW52YWxpZCA9IGNyZWF0ZUludmFsaWQkMTtcblxuZnVuY3Rpb24gcGFyc2VJc28gKGlucCwgc2lnbikge1xuICAgIC8vIFdlJ2Qgbm9ybWFsbHkgdXNlIH5+aW5wIGZvciB0aGlzLCBidXQgdW5mb3J0dW5hdGVseSBpdCBhbHNvXG4gICAgLy8gY29udmVydHMgZmxvYXRzIHRvIGludHMuXG4gICAgLy8gaW5wIG1heSBiZSB1bmRlZmluZWQsIHNvIGNhcmVmdWwgY2FsbGluZyByZXBsYWNlIG9uIGl0LlxuICAgIHZhciByZXMgPSBpbnAgJiYgcGFyc2VGbG9hdChpbnAucmVwbGFjZSgnLCcsICcuJykpO1xuICAgIC8vIGFwcGx5IHNpZ24gd2hpbGUgd2UncmUgYXQgaXRcbiAgICByZXR1cm4gKGlzTmFOKHJlcykgPyAwIDogcmVzKSAqIHNpZ247XG59XG5cbmZ1bmN0aW9uIHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICB2YXIgcmVzID0ge21pbGxpc2Vjb25kczogMCwgbW9udGhzOiAwfTtcblxuICAgIHJlcy5tb250aHMgPSBvdGhlci5tb250aCgpIC0gYmFzZS5tb250aCgpICtcbiAgICAgICAgKG90aGVyLnllYXIoKSAtIGJhc2UueWVhcigpKSAqIDEyO1xuICAgIGlmIChiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykuaXNBZnRlcihvdGhlcikpIHtcbiAgICAgICAgLS1yZXMubW9udGhzO1xuICAgIH1cblxuICAgIHJlcy5taWxsaXNlY29uZHMgPSArb3RoZXIgLSArKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKSk7XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBtb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgIHZhciByZXM7XG4gICAgaWYgKCEoYmFzZS5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSkge1xuICAgICAgICByZXR1cm4ge21pbGxpc2Vjb25kczogMCwgbW9udGhzOiAwfTtcbiAgICB9XG5cbiAgICBvdGhlciA9IGNsb25lV2l0aE9mZnNldChvdGhlciwgYmFzZSk7XG4gICAgaWYgKGJhc2UuaXNCZWZvcmUob3RoZXIpKSB7XG4gICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2Uob3RoZXIsIGJhc2UpO1xuICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gLXJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgIHJlcy5tb250aHMgPSAtcmVzLm1vbnRocztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBUT0RPOiByZW1vdmUgJ25hbWUnIGFyZyBhZnRlciBkZXByZWNhdGlvbiBpcyByZW1vdmVkXG5mdW5jdGlvbiBjcmVhdGVBZGRlcihkaXJlY3Rpb24sIG5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCwgcGVyaW9kKSB7XG4gICAgICAgIHZhciBkdXIsIHRtcDtcbiAgICAgICAgLy9pbnZlcnQgdGhlIGFyZ3VtZW50cywgYnV0IGNvbXBsYWluIGFib3V0IGl0XG4gICAgICAgIGlmIChwZXJpb2QgIT09IG51bGwgJiYgIWlzTmFOKCtwZXJpb2QpKSB7XG4gICAgICAgICAgICBkZXByZWNhdGVTaW1wbGUobmFtZSwgJ21vbWVudCgpLicgKyBuYW1lICArICcocGVyaW9kLCBudW1iZXIpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgbW9tZW50KCkuJyArIG5hbWUgKyAnKG51bWJlciwgcGVyaW9kKS4gJyArXG4gICAgICAgICAgICAnU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvYWRkLWludmVydGVkLXBhcmFtLyBmb3IgbW9yZSBpbmZvLicpO1xuICAgICAgICAgICAgdG1wID0gdmFsOyB2YWwgPSBwZXJpb2Q7IHBlcmlvZCA9IHRtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbCA9IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gK3ZhbCA6IHZhbDtcbiAgICAgICAgZHVyID0gY3JlYXRlRHVyYXRpb24odmFsLCBwZXJpb2QpO1xuICAgICAgICBhZGRTdWJ0cmFjdCh0aGlzLCBkdXIsIGRpcmVjdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGFkZFN1YnRyYWN0IChtb20sIGR1cmF0aW9uLCBpc0FkZGluZywgdXBkYXRlT2Zmc2V0KSB7XG4gICAgdmFyIG1pbGxpc2Vjb25kcyA9IGR1cmF0aW9uLl9taWxsaXNlY29uZHMsXG4gICAgICAgIGRheXMgPSBhYnNSb3VuZChkdXJhdGlvbi5fZGF5cyksXG4gICAgICAgIG1vbnRocyA9IGFic1JvdW5kKGR1cmF0aW9uLl9tb250aHMpO1xuXG4gICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgIC8vIE5vIG9wXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB1cGRhdGVPZmZzZXQgPSB1cGRhdGVPZmZzZXQgPT0gbnVsbCA/IHRydWUgOiB1cGRhdGVPZmZzZXQ7XG5cbiAgICBpZiAobW9udGhzKSB7XG4gICAgICAgIHNldE1vbnRoKG1vbSwgZ2V0KG1vbSwgJ01vbnRoJykgKyBtb250aHMgKiBpc0FkZGluZyk7XG4gICAgfVxuICAgIGlmIChkYXlzKSB7XG4gICAgICAgIHNldCQxKG1vbSwgJ0RhdGUnLCBnZXQobW9tLCAnRGF0ZScpICsgZGF5cyAqIGlzQWRkaW5nKTtcbiAgICB9XG4gICAgaWYgKG1pbGxpc2Vjb25kcykge1xuICAgICAgICBtb20uX2Quc2V0VGltZShtb20uX2QudmFsdWVPZigpICsgbWlsbGlzZWNvbmRzICogaXNBZGRpbmcpO1xuICAgIH1cbiAgICBpZiAodXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldChtb20sIGRheXMgfHwgbW9udGhzKTtcbiAgICB9XG59XG5cbnZhciBhZGQgICAgICA9IGNyZWF0ZUFkZGVyKDEsICdhZGQnKTtcbnZhciBzdWJ0cmFjdCA9IGNyZWF0ZUFkZGVyKC0xLCAnc3VidHJhY3QnKTtcblxuZnVuY3Rpb24gZ2V0Q2FsZW5kYXJGb3JtYXQobXlNb21lbnQsIG5vdykge1xuICAgIHZhciBkaWZmID0gbXlNb21lbnQuZGlmZihub3csICdkYXlzJywgdHJ1ZSk7XG4gICAgcmV0dXJuIGRpZmYgPCAtNiA/ICdzYW1lRWxzZScgOlxuICAgICAgICAgICAgZGlmZiA8IC0xID8gJ2xhc3RXZWVrJyA6XG4gICAgICAgICAgICBkaWZmIDwgMCA/ICdsYXN0RGF5JyA6XG4gICAgICAgICAgICBkaWZmIDwgMSA/ICdzYW1lRGF5JyA6XG4gICAgICAgICAgICBkaWZmIDwgMiA/ICduZXh0RGF5JyA6XG4gICAgICAgICAgICBkaWZmIDwgNyA/ICduZXh0V2VlaycgOiAnc2FtZUVsc2UnO1xufVxuXG5mdW5jdGlvbiBjYWxlbmRhciQxICh0aW1lLCBmb3JtYXRzKSB7XG4gICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cbiAgICAvLyBHZXR0aW5nIHN0YXJ0LW9mLXRvZGF5IGRlcGVuZHMgb24gd2hldGhlciB3ZSdyZSBsb2NhbC91dGMvb2Zmc2V0IG9yIG5vdC5cbiAgICB2YXIgbm93ID0gdGltZSB8fCBjcmVhdGVMb2NhbCgpLFxuICAgICAgICBzb2QgPSBjbG9uZVdpdGhPZmZzZXQobm93LCB0aGlzKS5zdGFydE9mKCdkYXknKSxcbiAgICAgICAgZm9ybWF0ID0gaG9va3MuY2FsZW5kYXJGb3JtYXQodGhpcywgc29kKSB8fCAnc2FtZUVsc2UnO1xuXG4gICAgdmFyIG91dHB1dCA9IGZvcm1hdHMgJiYgKGlzRnVuY3Rpb24oZm9ybWF0c1tmb3JtYXRdKSA/IGZvcm1hdHNbZm9ybWF0XS5jYWxsKHRoaXMsIG5vdykgOiBmb3JtYXRzW2Zvcm1hdF0pO1xuXG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0KG91dHB1dCB8fCB0aGlzLmxvY2FsZURhdGEoKS5jYWxlbmRhcihmb3JtYXQsIHRoaXMsIGNyZWF0ZUxvY2FsKG5vdykpKTtcbn1cblxuZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgIHJldHVybiBuZXcgTW9tZW50KHRoaXMpO1xufVxuXG5mdW5jdGlvbiBpc0FmdGVyIChpbnB1dCwgdW5pdHMpIHtcbiAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHMoIWlzVW5kZWZpbmVkKHVuaXRzKSA/IHVuaXRzIDogJ21pbGxpc2Vjb25kJyk7XG4gICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA+IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBsb2NhbElucHV0LnZhbHVlT2YoKSA8IHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0JlZm9yZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKCFpc1VuZGVmaW5lZCh1bml0cykgPyB1bml0cyA6ICdtaWxsaXNlY29uZCcpO1xuICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPCBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKS52YWx1ZU9mKCkgPCBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzQmV0d2VlbiAoZnJvbSwgdG8sIHVuaXRzLCBpbmNsdXNpdml0eSkge1xuICAgIGluY2x1c2l2aXR5ID0gaW5jbHVzaXZpdHkgfHwgJygpJztcbiAgICByZXR1cm4gKGluY2x1c2l2aXR5WzBdID09PSAnKCcgPyB0aGlzLmlzQWZ0ZXIoZnJvbSwgdW5pdHMpIDogIXRoaXMuaXNCZWZvcmUoZnJvbSwgdW5pdHMpKSAmJlxuICAgICAgICAoaW5jbHVzaXZpdHlbMV0gPT09ICcpJyA/IHRoaXMuaXNCZWZvcmUodG8sIHVuaXRzKSA6ICF0aGlzLmlzQWZ0ZXIodG8sIHVuaXRzKSk7XG59XG5cbmZ1bmN0aW9uIGlzU2FtZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KSxcbiAgICAgICAgaW5wdXRNcztcbiAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzIHx8ICdtaWxsaXNlY29uZCcpO1xuICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPT09IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlucHV0TXMgPSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCkgPD0gaW5wdXRNcyAmJiBpbnB1dE1zIDw9IHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lT3JBZnRlciAoaW5wdXQsIHVuaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0FmdGVyKGlucHV0LHVuaXRzKTtcbn1cblxuZnVuY3Rpb24gaXNTYW1lT3JCZWZvcmUgKGlucHV0LCB1bml0cykge1xuICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNCZWZvcmUoaW5wdXQsdW5pdHMpO1xufVxuXG5mdW5jdGlvbiBkaWZmIChpbnB1dCwgdW5pdHMsIGFzRmxvYXQpIHtcbiAgICB2YXIgdGhhdCxcbiAgICAgICAgem9uZURlbHRhLFxuICAgICAgICBkZWx0YSwgb3V0cHV0O1xuXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH1cblxuICAgIHRoYXQgPSBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIHRoaXMpO1xuXG4gICAgaWYgKCF0aGF0LmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH1cblxuICAgIHpvbmVEZWx0YSA9ICh0aGF0LnV0Y09mZnNldCgpIC0gdGhpcy51dGNPZmZzZXQoKSkgKiA2ZTQ7XG5cbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgY2FzZSAneWVhcic6IG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KSAvIDEyOyBicmVhaztcbiAgICAgICAgY2FzZSAnbW9udGgnOiBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCk7IGJyZWFrO1xuICAgICAgICBjYXNlICdxdWFydGVyJzogb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpIC8gMzsgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NlY29uZCc6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyAxZTM7IGJyZWFrOyAvLyAxMDAwXG4gICAgICAgIGNhc2UgJ21pbnV0ZSc6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyA2ZTQ7IGJyZWFrOyAvLyAxMDAwICogNjBcbiAgICAgICAgY2FzZSAnaG91cic6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyAzNmU1OyBicmVhazsgLy8gMTAwMCAqIDYwICogNjBcbiAgICAgICAgY2FzZSAnZGF5Jzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0IC0gem9uZURlbHRhKSAvIDg2NGU1OyBicmVhazsgLy8gMTAwMCAqIDYwICogNjAgKiAyNCwgbmVnYXRlIGRzdFxuICAgICAgICBjYXNlICd3ZWVrJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0IC0gem9uZURlbHRhKSAvIDYwNDhlNTsgYnJlYWs7IC8vIDEwMDAgKiA2MCAqIDYwICogMjQgKiA3LCBuZWdhdGUgZHN0XG4gICAgICAgIGRlZmF1bHQ6IG91dHB1dCA9IHRoaXMgLSB0aGF0O1xuICAgIH1cblxuICAgIHJldHVybiBhc0Zsb2F0ID8gb3V0cHV0IDogYWJzRmxvb3Iob3V0cHV0KTtcbn1cblxuZnVuY3Rpb24gbW9udGhEaWZmIChhLCBiKSB7XG4gICAgLy8gZGlmZmVyZW5jZSBpbiBtb250aHNcbiAgICB2YXIgd2hvbGVNb250aERpZmYgPSAoKGIueWVhcigpIC0gYS55ZWFyKCkpICogMTIpICsgKGIubW9udGgoKSAtIGEubW9udGgoKSksXG4gICAgICAgIC8vIGIgaXMgaW4gKGFuY2hvciAtIDEgbW9udGgsIGFuY2hvciArIDEgbW9udGgpXG4gICAgICAgIGFuY2hvciA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYsICdtb250aHMnKSxcbiAgICAgICAgYW5jaG9yMiwgYWRqdXN0O1xuXG4gICAgaWYgKGIgLSBhbmNob3IgPCAwKSB7XG4gICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmIC0gMSwgJ21vbnRocycpO1xuICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICBhZGp1c3QgPSAoYiAtIGFuY2hvcikgLyAoYW5jaG9yIC0gYW5jaG9yMik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgKyAxLCAnbW9udGhzJyk7XG4gICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXG4gICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IyIC0gYW5jaG9yKTtcbiAgICB9XG5cbiAgICAvL2NoZWNrIGZvciBuZWdhdGl2ZSB6ZXJvLCByZXR1cm4gemVybyBpZiBuZWdhdGl2ZSB6ZXJvXG4gICAgcmV0dXJuIC0od2hvbGVNb250aERpZmYgKyBhZGp1c3QpIHx8IDA7XG59XG5cbmhvb2tzLmRlZmF1bHRGb3JtYXQgPSAnWVlZWS1NTS1ERFRISDptbTpzc1onO1xuaG9va3MuZGVmYXVsdEZvcm1hdFV0YyA9ICdZWVlZLU1NLUREVEhIOm1tOnNzW1pdJztcblxuZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkubG9jYWxlKCdlbicpLmZvcm1hdCgnZGRkIE1NTSBERCBZWVlZIEhIOm1tOnNzIFtHTVRdWlonKTtcbn1cblxuZnVuY3Rpb24gdG9JU09TdHJpbmcoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIG0gPSB0aGlzLmNsb25lKCkudXRjKCk7XG4gICAgaWYgKG0ueWVhcigpIDwgMCB8fCBtLnllYXIoKSA+IDk5OTkpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCAnWVlZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyk7XG4gICAgfVxuICAgIGlmIChpc0Z1bmN0aW9uKERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKSkge1xuICAgICAgICAvLyBuYXRpdmUgaW1wbGVtZW50YXRpb24gaXMgfjUweCBmYXN0ZXIsIHVzZSBpdCB3aGVuIHdlIGNhblxuICAgICAgICByZXR1cm4gdGhpcy50b0RhdGUoKS50b0lTT1N0cmluZygpO1xuICAgIH1cbiAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyk7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgaHVtYW4gcmVhZGFibGUgcmVwcmVzZW50YXRpb24gb2YgYSBtb21lbnQgdGhhdCBjYW5cbiAqIGFsc28gYmUgZXZhbHVhdGVkIHRvIGdldCBhIG5ldyBtb21lbnQgd2hpY2ggaXMgdGhlIHNhbWVcbiAqXG4gKiBAbGluayBodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QvZG9jcy9hcGkvdXRpbC5odG1sI3V0aWxfY3VzdG9tX2luc3BlY3RfZnVuY3Rpb25fb25fb2JqZWN0c1xuICovXG5mdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiAnbW9tZW50LmludmFsaWQoLyogJyArIHRoaXMuX2kgKyAnICovKSc7XG4gICAgfVxuICAgIHZhciBmdW5jID0gJ21vbWVudCc7XG4gICAgdmFyIHpvbmUgPSAnJztcbiAgICBpZiAoIXRoaXMuaXNMb2NhbCgpKSB7XG4gICAgICAgIGZ1bmMgPSB0aGlzLnV0Y09mZnNldCgpID09PSAwID8gJ21vbWVudC51dGMnIDogJ21vbWVudC5wYXJzZVpvbmUnO1xuICAgICAgICB6b25lID0gJ1onO1xuICAgIH1cbiAgICB2YXIgcHJlZml4ID0gJ1snICsgZnVuYyArICcoXCJdJztcbiAgICB2YXIgeWVhciA9ICgwIDw9IHRoaXMueWVhcigpICYmIHRoaXMueWVhcigpIDw9IDk5OTkpID8gJ1lZWVknIDogJ1lZWVlZWSc7XG4gICAgdmFyIGRhdGV0aW1lID0gJy1NTS1ERFtUXUhIOm1tOnNzLlNTUyc7XG4gICAgdmFyIHN1ZmZpeCA9IHpvbmUgKyAnW1wiKV0nO1xuXG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0KHByZWZpeCArIHllYXIgKyBkYXRldGltZSArIHN1ZmZpeCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdCAoaW5wdXRTdHJpbmcpIHtcbiAgICBpZiAoIWlucHV0U3RyaW5nKSB7XG4gICAgICAgIGlucHV0U3RyaW5nID0gdGhpcy5pc1V0YygpID8gaG9va3MuZGVmYXVsdEZvcm1hdFV0YyA6IGhvb2tzLmRlZmF1bHRGb3JtYXQ7XG4gICAgfVxuICAgIHZhciBvdXRwdXQgPSBmb3JtYXRNb21lbnQodGhpcywgaW5wdXRTdHJpbmcpO1xuICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5wb3N0Zm9ybWF0KG91dHB1dCk7XG59XG5cbmZ1bmN0aW9uIGZyb20gKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8XG4gICAgICAgICAgICAgY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oe3RvOiB0aGlzLCBmcm9tOiB0aW1lfSkubG9jYWxlKHRoaXMubG9jYWxlKCkpLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZyb21Ob3cgKHdpdGhvdXRTdWZmaXgpIHtcbiAgICByZXR1cm4gdGhpcy5mcm9tKGNyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xufVxuXG5mdW5jdGlvbiB0byAodGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHxcbiAgICAgICAgICAgICBjcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7ZnJvbTogdGhpcywgdG86IHRpbWV9KS5sb2NhbGUodGhpcy5sb2NhbGUoKSkuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdG9Ob3cgKHdpdGhvdXRTdWZmaXgpIHtcbiAgICByZXR1cm4gdGhpcy50byhjcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbn1cblxuLy8gSWYgcGFzc2VkIGEgbG9jYWxlIGtleSwgaXQgd2lsbCBzZXQgdGhlIGxvY2FsZSBmb3IgdGhpc1xuLy8gaW5zdGFuY2UuICBPdGhlcndpc2UsIGl0IHdpbGwgcmV0dXJuIHRoZSBsb2NhbGUgY29uZmlndXJhdGlvblxuLy8gdmFyaWFibGVzIGZvciB0aGlzIGluc3RhbmNlLlxuZnVuY3Rpb24gbG9jYWxlIChrZXkpIHtcbiAgICB2YXIgbmV3TG9jYWxlRGF0YTtcblxuICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlLl9hYmJyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0xvY2FsZURhdGEgPSBnZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgaWYgKG5ld0xvY2FsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fbG9jYWxlID0gbmV3TG9jYWxlRGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbnZhciBsYW5nID0gZGVwcmVjYXRlKFxuICAgICdtb21lbnQoKS5sYW5nKCkgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlIG1vbWVudCgpLmxvY2FsZURhdGEoKSB0byBnZXQgdGhlIGxhbmd1YWdlIGNvbmZpZ3VyYXRpb24uIFVzZSBtb21lbnQoKS5sb2NhbGUoKSB0byBjaGFuZ2UgbGFuZ3VhZ2VzLicsXG4gICAgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZShrZXkpO1xuICAgICAgICB9XG4gICAgfVxuKTtcblxuZnVuY3Rpb24gbG9jYWxlRGF0YSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvY2FsZTtcbn1cblxuZnVuY3Rpb24gc3RhcnRPZiAodW5pdHMpIHtcbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAvLyB0aGUgZm9sbG93aW5nIHN3aXRjaCBpbnRlbnRpb25hbGx5IG9taXRzIGJyZWFrIGtleXdvcmRzXG4gICAgLy8gdG8gdXRpbGl6ZSBmYWxsaW5nIHRocm91Z2ggdGhlIGNhc2VzLlxuICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICB0aGlzLm1vbnRoKDApO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgdGhpcy5kYXRlKDEpO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgdGhpcy5ob3VycygwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICB0aGlzLm1pbnV0ZXMoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICB0aGlzLnNlY29uZHMoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICB0aGlzLm1pbGxpc2Vjb25kcygwKTtcbiAgICB9XG5cbiAgICAvLyB3ZWVrcyBhcmUgYSBzcGVjaWFsIGNhc2VcbiAgICBpZiAodW5pdHMgPT09ICd3ZWVrJykge1xuICAgICAgICB0aGlzLndlZWtkYXkoMCk7XG4gICAgfVxuICAgIGlmICh1bml0cyA9PT0gJ2lzb1dlZWsnKSB7XG4gICAgICAgIHRoaXMuaXNvV2Vla2RheSgxKTtcbiAgICB9XG5cbiAgICAvLyBxdWFydGVycyBhcmUgYWxzbyBzcGVjaWFsXG4gICAgaWYgKHVuaXRzID09PSAncXVhcnRlcicpIHtcbiAgICAgICAgdGhpcy5tb250aChNYXRoLmZsb29yKHRoaXMubW9udGgoKSAvIDMpICogMyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGVuZE9mICh1bml0cykge1xuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgIGlmICh1bml0cyA9PT0gdW5kZWZpbmVkIHx8IHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vICdkYXRlJyBpcyBhbiBhbGlhcyBmb3IgJ2RheScsIHNvIGl0IHNob3VsZCBiZSBjb25zaWRlcmVkIGFzIHN1Y2guXG4gICAgaWYgKHVuaXRzID09PSAnZGF0ZScpIHtcbiAgICAgICAgdW5pdHMgPSAnZGF5JztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdGFydE9mKHVuaXRzKS5hZGQoMSwgKHVuaXRzID09PSAnaXNvV2VlaycgPyAnd2VlaycgOiB1bml0cykpLnN1YnRyYWN0KDEsICdtcycpO1xufVxuXG5mdW5jdGlvbiB2YWx1ZU9mICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZC52YWx1ZU9mKCkgLSAoKHRoaXMuX29mZnNldCB8fCAwKSAqIDYwMDAwKTtcbn1cblxuZnVuY3Rpb24gdW5peCAoKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy52YWx1ZU9mKCkgLyAxMDAwKTtcbn1cblxuZnVuY3Rpb24gdG9EYXRlICgpIHtcbiAgICByZXR1cm4gbmV3IERhdGUodGhpcy52YWx1ZU9mKCkpO1xufVxuXG5mdW5jdGlvbiB0b0FycmF5ICgpIHtcbiAgICB2YXIgbSA9IHRoaXM7XG4gICAgcmV0dXJuIFttLnllYXIoKSwgbS5tb250aCgpLCBtLmRhdGUoKSwgbS5ob3VyKCksIG0ubWludXRlKCksIG0uc2Vjb25kKCksIG0ubWlsbGlzZWNvbmQoKV07XG59XG5cbmZ1bmN0aW9uIHRvT2JqZWN0ICgpIHtcbiAgICB2YXIgbSA9IHRoaXM7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcnM6IG0ueWVhcigpLFxuICAgICAgICBtb250aHM6IG0ubW9udGgoKSxcbiAgICAgICAgZGF0ZTogbS5kYXRlKCksXG4gICAgICAgIGhvdXJzOiBtLmhvdXJzKCksXG4gICAgICAgIG1pbnV0ZXM6IG0ubWludXRlcygpLFxuICAgICAgICBzZWNvbmRzOiBtLnNlY29uZHMoKSxcbiAgICAgICAgbWlsbGlzZWNvbmRzOiBtLm1pbGxpc2Vjb25kcygpXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgICAvLyBuZXcgRGF0ZShOYU4pLnRvSlNPTigpID09PSBudWxsXG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy50b0lTT1N0cmluZygpIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZCQyICgpIHtcbiAgICByZXR1cm4gaXNWYWxpZCh0aGlzKTtcbn1cblxuZnVuY3Rpb24gcGFyc2luZ0ZsYWdzICgpIHtcbiAgICByZXR1cm4gZXh0ZW5kKHt9LCBnZXRQYXJzaW5nRmxhZ3ModGhpcykpO1xufVxuXG5mdW5jdGlvbiBpbnZhbGlkQXQgKCkge1xuICAgIHJldHVybiBnZXRQYXJzaW5nRmxhZ3ModGhpcykub3ZlcmZsb3c7XG59XG5cbmZ1bmN0aW9uIGNyZWF0aW9uRGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbnB1dDogdGhpcy5faSxcbiAgICAgICAgZm9ybWF0OiB0aGlzLl9mLFxuICAgICAgICBsb2NhbGU6IHRoaXMuX2xvY2FsZSxcbiAgICAgICAgaXNVVEM6IHRoaXMuX2lzVVRDLFxuICAgICAgICBzdHJpY3Q6IHRoaXMuX3N0cmljdFxuICAgIH07XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oMCwgWydnZycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMud2Vla1llYXIoKSAlIDEwMDtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbigwLCBbJ0dHJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pc29XZWVrWWVhcigpICUgMTAwO1xufSk7XG5cbmZ1bmN0aW9uIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4gKHRva2VuLCBnZXR0ZXIpIHtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbdG9rZW4sIHRva2VuLmxlbmd0aF0sIDAsIGdldHRlcik7XG59XG5cbmFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2cnLCAgICAgJ3dlZWtZZWFyJyk7XG5hZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnZycsICAgICd3ZWVrWWVhcicpO1xuYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHRycsICAnaXNvV2Vla1llYXInKTtcbmFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0dHJywgJ2lzb1dlZWtZZWFyJyk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCd3ZWVrWWVhcicsICdnZycpO1xuYWRkVW5pdEFsaWFzKCdpc29XZWVrWWVhcicsICdHRycpO1xuXG4vLyBQUklPUklUWVxuXG5hZGRVbml0UHJpb3JpdHkoJ3dlZWtZZWFyJywgMSk7XG5hZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtZZWFyJywgMSk7XG5cblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdHJywgICAgICBtYXRjaFNpZ25lZCk7XG5hZGRSZWdleFRva2VuKCdnJywgICAgICBtYXRjaFNpZ25lZCk7XG5hZGRSZWdleFRva2VuKCdHRycsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdnZycsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdHR0dHJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG5hZGRSZWdleFRva2VuKCdnZ2dnJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG5hZGRSZWdleFRva2VuKCdHR0dHRycsICBtYXRjaDF0bzYsIG1hdGNoNik7XG5hZGRSZWdleFRva2VuKCdnZ2dnZycsICBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbmFkZFdlZWtQYXJzZVRva2VuKFsnZ2dnZycsICdnZ2dnZycsICdHR0dHJywgJ0dHR0dHJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDIpXSA9IHRvSW50KGlucHV0KTtcbn0pO1xuXG5hZGRXZWVrUGFyc2VUb2tlbihbJ2dnJywgJ0dHJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgIHdlZWtbdG9rZW5dID0gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xufSk7XG5cbi8vIE1PTUVOVFNcblxuZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXIgKGlucHV0KSB7XG4gICAgcmV0dXJuIGdldFNldFdlZWtZZWFySGVscGVyLmNhbGwodGhpcyxcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgdGhpcy53ZWVrKCksXG4gICAgICAgICAgICB0aGlzLndlZWtkYXkoKSxcbiAgICAgICAgICAgIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdyxcbiAgICAgICAgICAgIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRveSk7XG59XG5cbmZ1bmN0aW9uIGdldFNldElTT1dlZWtZZWFyIChpbnB1dCkge1xuICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKHRoaXMsXG4gICAgICAgICAgICBpbnB1dCwgdGhpcy5pc29XZWVrKCksIHRoaXMuaXNvV2Vla2RheSgpLCAxLCA0KTtcbn1cblxuZnVuY3Rpb24gZ2V0SVNPV2Vla3NJblllYXIgKCkge1xuICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgMSwgNCk7XG59XG5cbmZ1bmN0aW9uIGdldFdlZWtzSW5ZZWFyICgpIHtcbiAgICB2YXIgd2Vla0luZm8gPSB0aGlzLmxvY2FsZURhdGEoKS5fd2VlaztcbiAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIHdlZWtJbmZvLmRvdywgd2Vla0luZm8uZG95KTtcbn1cblxuZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXJIZWxwZXIoaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgdmFyIHdlZWtzVGFyZ2V0O1xuICAgIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKHRoaXMsIGRvdywgZG95KS55ZWFyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdlZWtzVGFyZ2V0ID0gd2Vla3NJblllYXIoaW5wdXQsIGRvdywgZG95KTtcbiAgICAgICAgaWYgKHdlZWsgPiB3ZWVrc1RhcmdldCkge1xuICAgICAgICAgICAgd2VlayA9IHdlZWtzVGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXRXZWVrQWxsLmNhbGwodGhpcywgaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNldFdlZWtBbGwod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgdmFyIGRheU9mWWVhckRhdGEgPSBkYXlPZlllYXJGcm9tV2Vla3Mod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSxcbiAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoZGF5T2ZZZWFyRGF0YS55ZWFyLCAwLCBkYXlPZlllYXJEYXRhLmRheU9mWWVhcik7XG5cbiAgICB0aGlzLnllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpKTtcbiAgICB0aGlzLm1vbnRoKGRhdGUuZ2V0VVRDTW9udGgoKSk7XG4gICAgdGhpcy5kYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpKTtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignUScsIDAsICdRbycsICdxdWFydGVyJyk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdxdWFydGVyJywgJ1EnKTtcblxuLy8gUFJJT1JJVFlcblxuYWRkVW5pdFByaW9yaXR5KCdxdWFydGVyJywgNyk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignUScsIG1hdGNoMSk7XG5hZGRQYXJzZVRva2VuKCdRJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgIGFycmF5W01PTlRIXSA9ICh0b0ludChpbnB1dCkgLSAxKSAqIDM7XG59KTtcblxuLy8gTU9NRU5UU1xuXG5mdW5jdGlvbiBnZXRTZXRRdWFydGVyIChpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gTWF0aC5jZWlsKCh0aGlzLm1vbnRoKCkgKyAxKSAvIDMpIDogdGhpcy5tb250aCgoaW5wdXQgLSAxKSAqIDMgKyB0aGlzLm1vbnRoKCkgJSAzKTtcbn1cblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignRCcsIFsnREQnLCAyXSwgJ0RvJywgJ2RhdGUnKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ2RhdGUnLCAnRCcpO1xuXG4vLyBQUklPUk9JVFlcbmFkZFVuaXRQcmlvcml0eSgnZGF0ZScsIDkpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ0QnLCAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ0REJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignRG8nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgIC8vIFRPRE86IFJlbW92ZSBcIm9yZGluYWxQYXJzZVwiIGZhbGxiYWNrIGluIG5leHQgbWFqb3IgcmVsZWFzZS5cbiAgICByZXR1cm4gaXNTdHJpY3QgP1xuICAgICAgKGxvY2FsZS5fZGF5T2ZNb250aE9yZGluYWxQYXJzZSB8fCBsb2NhbGUuX29yZGluYWxQYXJzZSkgOlxuICAgICAgbG9jYWxlLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudDtcbn0pO1xuXG5hZGRQYXJzZVRva2VuKFsnRCcsICdERCddLCBEQVRFKTtcbmFkZFBhcnNlVG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgIGFycmF5W0RBVEVdID0gdG9JbnQoaW5wdXQubWF0Y2gobWF0Y2gxdG8yKVswXSwgMTApO1xufSk7XG5cbi8vIE1PTUVOVFNcblxudmFyIGdldFNldERheU9mTW9udGggPSBtYWtlR2V0U2V0KCdEYXRlJywgdHJ1ZSk7XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ0RERCcsIFsnRERERCcsIDNdLCAnREREbycsICdkYXlPZlllYXInKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ2RheU9mWWVhcicsICdEREQnKTtcblxuLy8gUFJJT1JJVFlcbmFkZFVuaXRQcmlvcml0eSgnZGF5T2ZZZWFyJywgNCk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignREREJywgIG1hdGNoMXRvMyk7XG5hZGRSZWdleFRva2VuKCdEREREJywgbWF0Y2gzKTtcbmFkZFBhcnNlVG9rZW4oWydEREQnLCAnRERERCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICBjb25maWcuX2RheU9mWWVhciA9IHRvSW50KGlucHV0KTtcbn0pO1xuXG4vLyBIRUxQRVJTXG5cbi8vIE1PTUVOVFNcblxuZnVuY3Rpb24gZ2V0U2V0RGF5T2ZZZWFyIChpbnB1dCkge1xuICAgIHZhciBkYXlPZlllYXIgPSBNYXRoLnJvdW5kKCh0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykgLSB0aGlzLmNsb25lKCkuc3RhcnRPZigneWVhcicpKSAvIDg2NGU1KSArIDE7XG4gICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBkYXlPZlllYXIgOiB0aGlzLmFkZCgoaW5wdXQgLSBkYXlPZlllYXIpLCAnZCcpO1xufVxuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdtJywgWydtbScsIDJdLCAwLCAnbWludXRlJyk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdtaW51dGUnLCAnbScpO1xuXG4vLyBQUklPUklUWVxuXG5hZGRVbml0UHJpb3JpdHkoJ21pbnV0ZScsIDE0KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdtJywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdtbScsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFBhcnNlVG9rZW4oWydtJywgJ21tJ10sIE1JTlVURSk7XG5cbi8vIE1PTUVOVFNcblxudmFyIGdldFNldE1pbnV0ZSA9IG1ha2VHZXRTZXQoJ01pbnV0ZXMnLCBmYWxzZSk7XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ3MnLCBbJ3NzJywgMl0sIDAsICdzZWNvbmQnKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ3NlY29uZCcsICdzJyk7XG5cbi8vIFBSSU9SSVRZXG5cbmFkZFVuaXRQcmlvcml0eSgnc2Vjb25kJywgMTUpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ3MnLCAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ3NzJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUGFyc2VUb2tlbihbJ3MnLCAnc3MnXSwgU0VDT05EKTtcblxuLy8gTU9NRU5UU1xuXG52YXIgZ2V0U2V0U2Vjb25kID0gbWFrZUdldFNldCgnU2Vjb25kcycsIGZhbHNlKTtcblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignUycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTAwKTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTApO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKDAsIFsnU1NTJywgM10sIDAsICdtaWxsaXNlY29uZCcpO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTJywgNF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTA7XG59KTtcbmFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1MnLCA1XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDA7XG59KTtcbmFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTJywgNl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDtcbn0pO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTJywgN10sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDA7XG59KTtcbmFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1MnLCA4XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDA7XG59KTtcbmFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1NTJywgOV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwMDtcbn0pO1xuXG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdtaWxsaXNlY29uZCcsICdtcycpO1xuXG4vLyBQUklPUklUWVxuXG5hZGRVbml0UHJpb3JpdHkoJ21pbGxpc2Vjb25kJywgMTYpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ1MnLCAgICBtYXRjaDF0bzMsIG1hdGNoMSk7XG5hZGRSZWdleFRva2VuKCdTUycsICAgbWF0Y2gxdG8zLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignU1NTJywgIG1hdGNoMXRvMywgbWF0Y2gzKTtcblxudmFyIHRva2VuO1xuZm9yICh0b2tlbiA9ICdTU1NTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgIGFkZFJlZ2V4VG9rZW4odG9rZW4sIG1hdGNoVW5zaWduZWQpO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1zKGlucHV0LCBhcnJheSkge1xuICAgIGFycmF5W01JTExJU0VDT05EXSA9IHRvSW50KCgnMC4nICsgaW5wdXQpICogMTAwMCk7XG59XG5cbmZvciAodG9rZW4gPSAnUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBwYXJzZU1zKTtcbn1cbi8vIE1PTUVOVFNcblxudmFyIGdldFNldE1pbGxpc2Vjb25kID0gbWFrZUdldFNldCgnTWlsbGlzZWNvbmRzJywgZmFsc2UpO1xuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCd6JywgIDAsIDAsICd6b25lQWJicicpO1xuYWRkRm9ybWF0VG9rZW4oJ3p6JywgMCwgMCwgJ3pvbmVOYW1lJyk7XG5cbi8vIE1PTUVOVFNcblxuZnVuY3Rpb24gZ2V0Wm9uZUFiYnIgKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdVVEMnIDogJyc7XG59XG5cbmZ1bmN0aW9uIGdldFpvbmVOYW1lICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnQ29vcmRpbmF0ZWQgVW5pdmVyc2FsIFRpbWUnIDogJyc7XG59XG5cbnZhciBwcm90byA9IE1vbWVudC5wcm90b3R5cGU7XG5cbnByb3RvLmFkZCAgICAgICAgICAgICAgID0gYWRkO1xucHJvdG8uY2FsZW5kYXIgICAgICAgICAgPSBjYWxlbmRhciQxO1xucHJvdG8uY2xvbmUgICAgICAgICAgICAgPSBjbG9uZTtcbnByb3RvLmRpZmYgICAgICAgICAgICAgID0gZGlmZjtcbnByb3RvLmVuZE9mICAgICAgICAgICAgID0gZW5kT2Y7XG5wcm90by5mb3JtYXQgICAgICAgICAgICA9IGZvcm1hdDtcbnByb3RvLmZyb20gICAgICAgICAgICAgID0gZnJvbTtcbnByb3RvLmZyb21Ob3cgICAgICAgICAgID0gZnJvbU5vdztcbnByb3RvLnRvICAgICAgICAgICAgICAgID0gdG87XG5wcm90by50b05vdyAgICAgICAgICAgICA9IHRvTm93O1xucHJvdG8uZ2V0ICAgICAgICAgICAgICAgPSBzdHJpbmdHZXQ7XG5wcm90by5pbnZhbGlkQXQgICAgICAgICA9IGludmFsaWRBdDtcbnByb3RvLmlzQWZ0ZXIgICAgICAgICAgID0gaXNBZnRlcjtcbnByb3RvLmlzQmVmb3JlICAgICAgICAgID0gaXNCZWZvcmU7XG5wcm90by5pc0JldHdlZW4gICAgICAgICA9IGlzQmV0d2VlbjtcbnByb3RvLmlzU2FtZSAgICAgICAgICAgID0gaXNTYW1lO1xucHJvdG8uaXNTYW1lT3JBZnRlciAgICAgPSBpc1NhbWVPckFmdGVyO1xucHJvdG8uaXNTYW1lT3JCZWZvcmUgICAgPSBpc1NhbWVPckJlZm9yZTtcbnByb3RvLmlzVmFsaWQgICAgICAgICAgID0gaXNWYWxpZCQyO1xucHJvdG8ubGFuZyAgICAgICAgICAgICAgPSBsYW5nO1xucHJvdG8ubG9jYWxlICAgICAgICAgICAgPSBsb2NhbGU7XG5wcm90by5sb2NhbGVEYXRhICAgICAgICA9IGxvY2FsZURhdGE7XG5wcm90by5tYXggICAgICAgICAgICAgICA9IHByb3RvdHlwZU1heDtcbnByb3RvLm1pbiAgICAgICAgICAgICAgID0gcHJvdG90eXBlTWluO1xucHJvdG8ucGFyc2luZ0ZsYWdzICAgICAgPSBwYXJzaW5nRmxhZ3M7XG5wcm90by5zZXQgICAgICAgICAgICAgICA9IHN0cmluZ1NldDtcbnByb3RvLnN0YXJ0T2YgICAgICAgICAgID0gc3RhcnRPZjtcbnByb3RvLnN1YnRyYWN0ICAgICAgICAgID0gc3VidHJhY3Q7XG5wcm90by50b0FycmF5ICAgICAgICAgICA9IHRvQXJyYXk7XG5wcm90by50b09iamVjdCAgICAgICAgICA9IHRvT2JqZWN0O1xucHJvdG8udG9EYXRlICAgICAgICAgICAgPSB0b0RhdGU7XG5wcm90by50b0lTT1N0cmluZyAgICAgICA9IHRvSVNPU3RyaW5nO1xucHJvdG8uaW5zcGVjdCAgICAgICAgICAgPSBpbnNwZWN0O1xucHJvdG8udG9KU09OICAgICAgICAgICAgPSB0b0pTT047XG5wcm90by50b1N0cmluZyAgICAgICAgICA9IHRvU3RyaW5nO1xucHJvdG8udW5peCAgICAgICAgICAgICAgPSB1bml4O1xucHJvdG8udmFsdWVPZiAgICAgICAgICAgPSB2YWx1ZU9mO1xucHJvdG8uY3JlYXRpb25EYXRhICAgICAgPSBjcmVhdGlvbkRhdGE7XG5cbi8vIFllYXJcbnByb3RvLnllYXIgICAgICAgPSBnZXRTZXRZZWFyO1xucHJvdG8uaXNMZWFwWWVhciA9IGdldElzTGVhcFllYXI7XG5cbi8vIFdlZWsgWWVhclxucHJvdG8ud2Vla1llYXIgICAgPSBnZXRTZXRXZWVrWWVhcjtcbnByb3RvLmlzb1dlZWtZZWFyID0gZ2V0U2V0SVNPV2Vla1llYXI7XG5cbi8vIFF1YXJ0ZXJcbnByb3RvLnF1YXJ0ZXIgPSBwcm90by5xdWFydGVycyA9IGdldFNldFF1YXJ0ZXI7XG5cbi8vIE1vbnRoXG5wcm90by5tb250aCAgICAgICA9IGdldFNldE1vbnRoO1xucHJvdG8uZGF5c0luTW9udGggPSBnZXREYXlzSW5Nb250aDtcblxuLy8gV2Vla1xucHJvdG8ud2VlayAgICAgICAgICAgPSBwcm90by53ZWVrcyAgICAgICAgPSBnZXRTZXRXZWVrO1xucHJvdG8uaXNvV2VlayAgICAgICAgPSBwcm90by5pc29XZWVrcyAgICAgPSBnZXRTZXRJU09XZWVrO1xucHJvdG8ud2Vla3NJblllYXIgICAgPSBnZXRXZWVrc0luWWVhcjtcbnByb3RvLmlzb1dlZWtzSW5ZZWFyID0gZ2V0SVNPV2Vla3NJblllYXI7XG5cbi8vIERheVxucHJvdG8uZGF0ZSAgICAgICA9IGdldFNldERheU9mTW9udGg7XG5wcm90by5kYXkgICAgICAgID0gcHJvdG8uZGF5cyAgICAgICAgICAgICA9IGdldFNldERheU9mV2VlaztcbnByb3RvLndlZWtkYXkgICAgPSBnZXRTZXRMb2NhbGVEYXlPZldlZWs7XG5wcm90by5pc29XZWVrZGF5ID0gZ2V0U2V0SVNPRGF5T2ZXZWVrO1xucHJvdG8uZGF5T2ZZZWFyICA9IGdldFNldERheU9mWWVhcjtcblxuLy8gSG91clxucHJvdG8uaG91ciA9IHByb3RvLmhvdXJzID0gZ2V0U2V0SG91cjtcblxuLy8gTWludXRlXG5wcm90by5taW51dGUgPSBwcm90by5taW51dGVzID0gZ2V0U2V0TWludXRlO1xuXG4vLyBTZWNvbmRcbnByb3RvLnNlY29uZCA9IHByb3RvLnNlY29uZHMgPSBnZXRTZXRTZWNvbmQ7XG5cbi8vIE1pbGxpc2Vjb25kXG5wcm90by5taWxsaXNlY29uZCA9IHByb3RvLm1pbGxpc2Vjb25kcyA9IGdldFNldE1pbGxpc2Vjb25kO1xuXG4vLyBPZmZzZXRcbnByb3RvLnV0Y09mZnNldCAgICAgICAgICAgID0gZ2V0U2V0T2Zmc2V0O1xucHJvdG8udXRjICAgICAgICAgICAgICAgICAgPSBzZXRPZmZzZXRUb1VUQztcbnByb3RvLmxvY2FsICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9Mb2NhbDtcbnByb3RvLnBhcnNlWm9uZSAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQ7XG5wcm90by5oYXNBbGlnbmVkSG91ck9mZnNldCA9IGhhc0FsaWduZWRIb3VyT2Zmc2V0O1xucHJvdG8uaXNEU1QgICAgICAgICAgICAgICAgPSBpc0RheWxpZ2h0U2F2aW5nVGltZTtcbnByb3RvLmlzTG9jYWwgICAgICAgICAgICAgID0gaXNMb2NhbDtcbnByb3RvLmlzVXRjT2Zmc2V0ICAgICAgICAgID0gaXNVdGNPZmZzZXQ7XG5wcm90by5pc1V0YyAgICAgICAgICAgICAgICA9IGlzVXRjO1xucHJvdG8uaXNVVEMgICAgICAgICAgICAgICAgPSBpc1V0YztcblxuLy8gVGltZXpvbmVcbnByb3RvLnpvbmVBYmJyID0gZ2V0Wm9uZUFiYnI7XG5wcm90by56b25lTmFtZSA9IGdldFpvbmVOYW1lO1xuXG4vLyBEZXByZWNhdGlvbnNcbnByb3RvLmRhdGVzICA9IGRlcHJlY2F0ZSgnZGF0ZXMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIGRhdGUgaW5zdGVhZC4nLCBnZXRTZXREYXlPZk1vbnRoKTtcbnByb3RvLm1vbnRocyA9IGRlcHJlY2F0ZSgnbW9udGhzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb250aCBpbnN0ZWFkJywgZ2V0U2V0TW9udGgpO1xucHJvdG8ueWVhcnMgID0gZGVwcmVjYXRlKCd5ZWFycyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgeWVhciBpbnN0ZWFkJywgZ2V0U2V0WWVhcik7XG5wcm90by56b25lICAgPSBkZXByZWNhdGUoJ21vbWVudCgpLnpvbmUgaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudCgpLnV0Y09mZnNldCBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL3pvbmUvJywgZ2V0U2V0Wm9uZSk7XG5wcm90by5pc0RTVFNoaWZ0ZWQgPSBkZXByZWNhdGUoJ2lzRFNUU2hpZnRlZCBpcyBkZXByZWNhdGVkLiBTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kc3Qtc2hpZnRlZC8gZm9yIG1vcmUgaW5mb3JtYXRpb24nLCBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQpO1xuXG5mdW5jdGlvbiBjcmVhdGVVbml4IChpbnB1dCkge1xuICAgIHJldHVybiBjcmVhdGVMb2NhbChpbnB1dCAqIDEwMDApO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJblpvbmUgKCkge1xuICAgIHJldHVybiBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpLnBhcnNlWm9uZSgpO1xufVxuXG5mdW5jdGlvbiBwcmVQYXJzZVBvc3RGb3JtYXQgKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmc7XG59XG5cbnZhciBwcm90byQxID0gTG9jYWxlLnByb3RvdHlwZTtcblxucHJvdG8kMS5jYWxlbmRhciAgICAgICAgPSBjYWxlbmRhcjtcbnByb3RvJDEubG9uZ0RhdGVGb3JtYXQgID0gbG9uZ0RhdGVGb3JtYXQ7XG5wcm90byQxLmludmFsaWREYXRlICAgICA9IGludmFsaWREYXRlO1xucHJvdG8kMS5vcmRpbmFsICAgICAgICAgPSBvcmRpbmFsO1xucHJvdG8kMS5wcmVwYXJzZSAgICAgICAgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG5wcm90byQxLnBvc3Rmb3JtYXQgICAgICA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbnByb3RvJDEucmVsYXRpdmVUaW1lICAgID0gcmVsYXRpdmVUaW1lO1xucHJvdG8kMS5wYXN0RnV0dXJlICAgICAgPSBwYXN0RnV0dXJlO1xucHJvdG8kMS5zZXQgICAgICAgICAgICAgPSBzZXQ7XG5cbi8vIE1vbnRoXG5wcm90byQxLm1vbnRocyAgICAgICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRocztcbnByb3RvJDEubW9udGhzU2hvcnQgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzU2hvcnQ7XG5wcm90byQxLm1vbnRoc1BhcnNlICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRoc1BhcnNlO1xucHJvdG8kMS5tb250aHNSZWdleCAgICAgICA9IG1vbnRoc1JlZ2V4O1xucHJvdG8kMS5tb250aHNTaG9ydFJlZ2V4ICA9IG1vbnRoc1Nob3J0UmVnZXg7XG5cbi8vIFdlZWtcbnByb3RvJDEud2VlayA9IGxvY2FsZVdlZWs7XG5wcm90byQxLmZpcnN0RGF5T2ZZZWFyID0gbG9jYWxlRmlyc3REYXlPZlllYXI7XG5wcm90byQxLmZpcnN0RGF5T2ZXZWVrID0gbG9jYWxlRmlyc3REYXlPZldlZWs7XG5cbi8vIERheSBvZiBXZWVrXG5wcm90byQxLndlZWtkYXlzICAgICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzO1xucHJvdG8kMS53ZWVrZGF5c01pbiAgICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c01pbjtcbnByb3RvJDEud2Vla2RheXNTaG9ydCAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNTaG9ydDtcbnByb3RvJDEud2Vla2RheXNQYXJzZSAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNQYXJzZTtcblxucHJvdG8kMS53ZWVrZGF5c1JlZ2V4ICAgICAgID0gICAgICAgIHdlZWtkYXlzUmVnZXg7XG5wcm90byQxLndlZWtkYXlzU2hvcnRSZWdleCAgPSAgICAgICAgd2Vla2RheXNTaG9ydFJlZ2V4O1xucHJvdG8kMS53ZWVrZGF5c01pblJlZ2V4ICAgID0gICAgICAgIHdlZWtkYXlzTWluUmVnZXg7XG5cbi8vIEhvdXJzXG5wcm90byQxLmlzUE0gPSBsb2NhbGVJc1BNO1xucHJvdG8kMS5tZXJpZGllbSA9IGxvY2FsZU1lcmlkaWVtO1xuXG5mdW5jdGlvbiBnZXQkMSAoZm9ybWF0LCBpbmRleCwgZmllbGQsIHNldHRlcikge1xuICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKTtcbiAgICB2YXIgdXRjID0gY3JlYXRlVVRDKCkuc2V0KHNldHRlciwgaW5kZXgpO1xuICAgIHJldHVybiBsb2NhbGVbZmllbGRdKHV0YywgZm9ybWF0KTtcbn1cblxuZnVuY3Rpb24gbGlzdE1vbnRoc0ltcGwgKGZvcm1hdCwgaW5kZXgsIGZpZWxkKSB7XG4gICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG5cbiAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZ2V0JDEoZm9ybWF0LCBpbmRleCwgZmllbGQsICdtb250aCcpO1xuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICBvdXRbaV0gPSBnZXQkMShmb3JtYXQsIGksIGZpZWxkLCAnbW9udGgnKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLy8gKClcbi8vICg1KVxuLy8gKGZtdCwgNSlcbi8vIChmbXQpXG4vLyAodHJ1ZSlcbi8vICh0cnVlLCA1KVxuLy8gKHRydWUsIGZtdCwgNSlcbi8vICh0cnVlLCBmbXQpXG5mdW5jdGlvbiBsaXN0V2Vla2RheXNJbXBsIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsIGZpZWxkKSB7XG4gICAgaWYgKHR5cGVvZiBsb2NhbGVTb3J0ZWQgPT09ICdib29sZWFuJykge1xuICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9ybWF0ID0gbG9jYWxlU29ydGVkO1xuICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgbG9jYWxlU29ydGVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuICAgIH1cblxuICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKSxcbiAgICAgICAgc2hpZnQgPSBsb2NhbGVTb3J0ZWQgPyBsb2NhbGUuX3dlZWsuZG93IDogMDtcblxuICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXQkMShmb3JtYXQsIChpbmRleCArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgb3V0W2ldID0gZ2V0JDEoZm9ybWF0LCAoaSArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIGxpc3RNb250aHMgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICByZXR1cm4gbGlzdE1vbnRoc0ltcGwoZm9ybWF0LCBpbmRleCwgJ21vbnRocycpO1xufVxuXG5mdW5jdGlvbiBsaXN0TW9udGhzU2hvcnQgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICByZXR1cm4gbGlzdE1vbnRoc0ltcGwoZm9ybWF0LCBpbmRleCwgJ21vbnRoc1Nob3J0Jyk7XG59XG5cbmZ1bmN0aW9uIGxpc3RXZWVrZGF5cyAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXMnKTtcbn1cblxuZnVuY3Rpb24gbGlzdFdlZWtkYXlzU2hvcnQgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzU2hvcnQnKTtcbn1cblxuZnVuY3Rpb24gbGlzdFdlZWtkYXlzTWluIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c01pbicpO1xufVxuXG5nZXRTZXRHbG9iYWxMb2NhbGUoJ2VuJywge1xuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfSh0aHxzdHxuZHxyZCkvLFxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICBvdXRwdXQgPSAodG9JbnQobnVtYmVyICUgMTAwIC8gMTApID09PSAxKSA/ICd0aCcgOlxuICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XG4gICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcbiAgICAgICAgICAgIChiID09PSAzKSA/ICdyZCcgOiAndGgnO1xuICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xuICAgIH1cbn0pO1xuXG4vLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5ob29rcy5sYW5nID0gZGVwcmVjYXRlKCdtb21lbnQubGFuZyBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZSBpbnN0ZWFkLicsIGdldFNldEdsb2JhbExvY2FsZSk7XG5ob29rcy5sYW5nRGF0YSA9IGRlcHJlY2F0ZSgnbW9tZW50LmxhbmdEYXRhIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlRGF0YSBpbnN0ZWFkLicsIGdldExvY2FsZSk7XG5cbnZhciBtYXRoQWJzID0gTWF0aC5hYnM7XG5cbmZ1bmN0aW9uIGFicyAoKSB7XG4gICAgdmFyIGRhdGEgICAgICAgICAgID0gdGhpcy5fZGF0YTtcblxuICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9IG1hdGhBYnModGhpcy5fbWlsbGlzZWNvbmRzKTtcbiAgICB0aGlzLl9kYXlzICAgICAgICAgPSBtYXRoQWJzKHRoaXMuX2RheXMpO1xuICAgIHRoaXMuX21vbnRocyAgICAgICA9IG1hdGhBYnModGhpcy5fbW9udGhzKTtcblxuICAgIGRhdGEubWlsbGlzZWNvbmRzICA9IG1hdGhBYnMoZGF0YS5taWxsaXNlY29uZHMpO1xuICAgIGRhdGEuc2Vjb25kcyAgICAgICA9IG1hdGhBYnMoZGF0YS5zZWNvbmRzKTtcbiAgICBkYXRhLm1pbnV0ZXMgICAgICAgPSBtYXRoQWJzKGRhdGEubWludXRlcyk7XG4gICAgZGF0YS5ob3VycyAgICAgICAgID0gbWF0aEFicyhkYXRhLmhvdXJzKTtcbiAgICBkYXRhLm1vbnRocyAgICAgICAgPSBtYXRoQWJzKGRhdGEubW9udGhzKTtcbiAgICBkYXRhLnllYXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEueWVhcnMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGFkZFN1YnRyYWN0JDEgKGR1cmF0aW9uLCBpbnB1dCwgdmFsdWUsIGRpcmVjdGlvbikge1xuICAgIHZhciBvdGhlciA9IGNyZWF0ZUR1cmF0aW9uKGlucHV0LCB2YWx1ZSk7XG5cbiAgICBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9taWxsaXNlY29uZHM7XG4gICAgZHVyYXRpb24uX2RheXMgICAgICAgICArPSBkaXJlY3Rpb24gKiBvdGhlci5fZGF5cztcbiAgICBkdXJhdGlvbi5fbW9udGhzICAgICAgICs9IGRpcmVjdGlvbiAqIG90aGVyLl9tb250aHM7XG5cbiAgICByZXR1cm4gZHVyYXRpb24uX2J1YmJsZSgpO1xufVxuXG4vLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBhZGQoMSwgJ3MnKSBvciBhZGQoZHVyYXRpb24pXG5mdW5jdGlvbiBhZGQkMSAoaW5wdXQsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGFkZFN1YnRyYWN0JDEodGhpcywgaW5wdXQsIHZhbHVlLCAxKTtcbn1cblxuLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgc3VidHJhY3QoMSwgJ3MnKSBvciBzdWJ0cmFjdChkdXJhdGlvbilcbmZ1bmN0aW9uIHN1YnRyYWN0JDEgKGlucHV0LCB2YWx1ZSkge1xuICAgIHJldHVybiBhZGRTdWJ0cmFjdCQxKHRoaXMsIGlucHV0LCB2YWx1ZSwgLTEpO1xufVxuXG5mdW5jdGlvbiBhYnNDZWlsIChudW1iZXIpIHtcbiAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGJ1YmJsZSAoKSB7XG4gICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcbiAgICB2YXIgZGF5cyAgICAgICAgID0gdGhpcy5fZGF5cztcbiAgICB2YXIgbW9udGhzICAgICAgID0gdGhpcy5fbW9udGhzO1xuICAgIHZhciBkYXRhICAgICAgICAgPSB0aGlzLl9kYXRhO1xuICAgIHZhciBzZWNvbmRzLCBtaW51dGVzLCBob3VycywgeWVhcnMsIG1vbnRoc0Zyb21EYXlzO1xuXG4gICAgLy8gaWYgd2UgaGF2ZSBhIG1peCBvZiBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgdmFsdWVzLCBidWJibGUgZG93biBmaXJzdFxuICAgIC8vIGNoZWNrOiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjE2NlxuICAgIGlmICghKChtaWxsaXNlY29uZHMgPj0gMCAmJiBkYXlzID49IDAgJiYgbW9udGhzID49IDApIHx8XG4gICAgICAgICAgICAobWlsbGlzZWNvbmRzIDw9IDAgJiYgZGF5cyA8PSAwICYmIG1vbnRocyA8PSAwKSkpIHtcbiAgICAgICAgbWlsbGlzZWNvbmRzICs9IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRocykgKyBkYXlzKSAqIDg2NGU1O1xuICAgICAgICBkYXlzID0gMDtcbiAgICAgICAgbW9udGhzID0gMDtcbiAgICB9XG5cbiAgICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgYnViYmxlcyB1cCB2YWx1ZXMsIHNlZSB0aGUgdGVzdHMgZm9yXG4gICAgLy8gZXhhbXBsZXMgb2Ygd2hhdCB0aGF0IG1lYW5zLlxuICAgIGRhdGEubWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzICUgMTAwMDtcblxuICAgIHNlY29uZHMgICAgICAgICAgID0gYWJzRmxvb3IobWlsbGlzZWNvbmRzIC8gMTAwMCk7XG4gICAgZGF0YS5zZWNvbmRzICAgICAgPSBzZWNvbmRzICUgNjA7XG5cbiAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgZGF0YS5taW51dGVzICAgICAgPSBtaW51dGVzICUgNjA7XG5cbiAgICBob3VycyAgICAgICAgICAgICA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgZGF0YS5ob3VycyAgICAgICAgPSBob3VycyAlIDI0O1xuXG4gICAgZGF5cyArPSBhYnNGbG9vcihob3VycyAvIDI0KTtcblxuICAgIC8vIGNvbnZlcnQgZGF5cyB0byBtb250aHNcbiAgICBtb250aHNGcm9tRGF5cyA9IGFic0Zsb29yKGRheXNUb01vbnRocyhkYXlzKSk7XG4gICAgbW9udGhzICs9IG1vbnRoc0Zyb21EYXlzO1xuICAgIGRheXMgLT0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzRnJvbURheXMpKTtcblxuICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICB5ZWFycyA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICBtb250aHMgJT0gMTI7XG5cbiAgICBkYXRhLmRheXMgICA9IGRheXM7XG4gICAgZGF0YS5tb250aHMgPSBtb250aHM7XG4gICAgZGF0YS55ZWFycyAgPSB5ZWFycztcblxuICAgIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBkYXlzVG9Nb250aHMgKGRheXMpIHtcbiAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxNDYwOTcgZGF5cyAodGFraW5nIGludG8gYWNjb3VudCBsZWFwIHllYXIgcnVsZXMpXG4gICAgLy8gNDAwIHllYXJzIGhhdmUgMTIgbW9udGhzID09PSA0ODAwXG4gICAgcmV0dXJuIGRheXMgKiA0ODAwIC8gMTQ2MDk3O1xufVxuXG5mdW5jdGlvbiBtb250aHNUb0RheXMgKG1vbnRocykge1xuICAgIC8vIHRoZSByZXZlcnNlIG9mIGRheXNUb01vbnRoc1xuICAgIHJldHVybiBtb250aHMgKiAxNDYwOTcgLyA0ODAwO1xufVxuXG5mdW5jdGlvbiBhcyAodW5pdHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHZhciBkYXlzO1xuICAgIHZhciBtb250aHM7XG4gICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcblxuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgaWYgKHVuaXRzID09PSAnbW9udGgnIHx8IHVuaXRzID09PSAneWVhcicpIHtcbiAgICAgICAgZGF5cyAgID0gdGhpcy5fZGF5cyAgICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgIG1vbnRocyA9IHRoaXMuX21vbnRocyArIGRheXNUb01vbnRocyhkYXlzKTtcbiAgICAgICAgcmV0dXJuIHVuaXRzID09PSAnbW9udGgnID8gbW9udGhzIDogbW9udGhzIC8gMTI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaGFuZGxlIG1pbGxpc2Vjb25kcyBzZXBhcmF0ZWx5IGJlY2F1c2Ugb2YgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgKGlzc3VlICMxODY3KVxuICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyArIE1hdGgucm91bmQobW9udGhzVG9EYXlzKHRoaXMuX21vbnRocykpO1xuICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICBjYXNlICd3ZWVrJyAgIDogcmV0dXJuIGRheXMgLyA3ICAgICArIG1pbGxpc2Vjb25kcyAvIDYwNDhlNTtcbiAgICAgICAgICAgIGNhc2UgJ2RheScgICAgOiByZXR1cm4gZGF5cyAgICAgICAgICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICBjYXNlICdob3VyJyAgIDogcmV0dXJuIGRheXMgKiAyNCAgICArIG1pbGxpc2Vjb25kcyAvIDM2ZTU7XG4gICAgICAgICAgICBjYXNlICdtaW51dGUnIDogcmV0dXJuIGRheXMgKiAxNDQwICArIG1pbGxpc2Vjb25kcyAvIDZlNDtcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCcgOiByZXR1cm4gZGF5cyAqIDg2NDAwICsgbWlsbGlzZWNvbmRzIC8gMTAwMDtcbiAgICAgICAgICAgIC8vIE1hdGguZmxvb3IgcHJldmVudHMgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgaGVyZVxuICAgICAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOiByZXR1cm4gTWF0aC5mbG9vcihkYXlzICogODY0ZTUpICsgbWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHVuaXQgJyArIHVuaXRzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gVE9ETzogVXNlIHRoaXMuYXMoJ21zJyk/XG5mdW5jdGlvbiB2YWx1ZU9mJDEgKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzICtcbiAgICAgICAgdGhpcy5fZGF5cyAqIDg2NGU1ICtcbiAgICAgICAgKHRoaXMuX21vbnRocyAlIDEyKSAqIDI1OTJlNiArXG4gICAgICAgIHRvSW50KHRoaXMuX21vbnRocyAvIDEyKSAqIDMxNTM2ZTZcbiAgICApO1xufVxuXG5mdW5jdGlvbiBtYWtlQXMgKGFsaWFzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXMoYWxpYXMpO1xuICAgIH07XG59XG5cbnZhciBhc01pbGxpc2Vjb25kcyA9IG1ha2VBcygnbXMnKTtcbnZhciBhc1NlY29uZHMgICAgICA9IG1ha2VBcygncycpO1xudmFyIGFzTWludXRlcyAgICAgID0gbWFrZUFzKCdtJyk7XG52YXIgYXNIb3VycyAgICAgICAgPSBtYWtlQXMoJ2gnKTtcbnZhciBhc0RheXMgICAgICAgICA9IG1ha2VBcygnZCcpO1xudmFyIGFzV2Vla3MgICAgICAgID0gbWFrZUFzKCd3Jyk7XG52YXIgYXNNb250aHMgICAgICAgPSBtYWtlQXMoJ00nKTtcbnZhciBhc1llYXJzICAgICAgICA9IG1ha2VBcygneScpO1xuXG5mdW5jdGlvbiBjbG9uZSQxICgpIHtcbiAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24odGhpcyk7XG59XG5cbmZ1bmN0aW9uIGdldCQyICh1bml0cykge1xuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXNbdW5pdHMgKyAncyddKCkgOiBOYU47XG59XG5cbmZ1bmN0aW9uIG1ha2VHZXR0ZXIobmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2RhdGFbbmFtZV0gOiBOYU47XG4gICAgfTtcbn1cblxudmFyIG1pbGxpc2Vjb25kcyA9IG1ha2VHZXR0ZXIoJ21pbGxpc2Vjb25kcycpO1xudmFyIHNlY29uZHMgICAgICA9IG1ha2VHZXR0ZXIoJ3NlY29uZHMnKTtcbnZhciBtaW51dGVzICAgICAgPSBtYWtlR2V0dGVyKCdtaW51dGVzJyk7XG52YXIgaG91cnMgICAgICAgID0gbWFrZUdldHRlcignaG91cnMnKTtcbnZhciBkYXlzICAgICAgICAgPSBtYWtlR2V0dGVyKCdkYXlzJyk7XG52YXIgbW9udGhzICAgICAgID0gbWFrZUdldHRlcignbW9udGhzJyk7XG52YXIgeWVhcnMgICAgICAgID0gbWFrZUdldHRlcigneWVhcnMnKTtcblxuZnVuY3Rpb24gd2Vla3MgKCkge1xuICAgIHJldHVybiBhYnNGbG9vcih0aGlzLmRheXMoKSAvIDcpO1xufVxuXG52YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xudmFyIHRocmVzaG9sZHMgPSB7XG4gICAgc3M6IDQ0LCAgICAgICAgIC8vIGEgZmV3IHNlY29uZHMgdG8gc2Vjb25kc1xuICAgIHMgOiA0NSwgICAgICAgICAvLyBzZWNvbmRzIHRvIG1pbnV0ZVxuICAgIG0gOiA0NSwgICAgICAgICAvLyBtaW51dGVzIHRvIGhvdXJcbiAgICBoIDogMjIsICAgICAgICAgLy8gaG91cnMgdG8gZGF5XG4gICAgZCA6IDI2LCAgICAgICAgIC8vIGRheXMgdG8gbW9udGhcbiAgICBNIDogMTEgICAgICAgICAgLy8gbW9udGhzIHRvIHllYXJcbn07XG5cbi8vIGhlbHBlciBmdW5jdGlvbiBmb3IgbW9tZW50LmZuLmZyb20sIG1vbWVudC5mbi5mcm9tTm93LCBhbmQgbW9tZW50LmR1cmF0aW9uLmZuLmh1bWFuaXplXG5mdW5jdGlvbiBzdWJzdGl0dXRlVGltZUFnbyhzdHJpbmcsIG51bWJlciwgd2l0aG91dFN1ZmZpeCwgaXNGdXR1cmUsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUucmVsYXRpdmVUaW1lKG51bWJlciB8fCAxLCAhIXdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpO1xufVxuXG5mdW5jdGlvbiByZWxhdGl2ZVRpbWUkMSAocG9zTmVnRHVyYXRpb24sIHdpdGhvdXRTdWZmaXgsIGxvY2FsZSkge1xuICAgIHZhciBkdXJhdGlvbiA9IGNyZWF0ZUR1cmF0aW9uKHBvc05lZ0R1cmF0aW9uKS5hYnMoKTtcbiAgICB2YXIgc2Vjb25kcyAgPSByb3VuZChkdXJhdGlvbi5hcygncycpKTtcbiAgICB2YXIgbWludXRlcyAgPSByb3VuZChkdXJhdGlvbi5hcygnbScpKTtcbiAgICB2YXIgaG91cnMgICAgPSByb3VuZChkdXJhdGlvbi5hcygnaCcpKTtcbiAgICB2YXIgZGF5cyAgICAgPSByb3VuZChkdXJhdGlvbi5hcygnZCcpKTtcbiAgICB2YXIgbW9udGhzICAgPSByb3VuZChkdXJhdGlvbi5hcygnTScpKTtcbiAgICB2YXIgeWVhcnMgICAgPSByb3VuZChkdXJhdGlvbi5hcygneScpKTtcblxuICAgIHZhciBhID0gc2Vjb25kcyA8PSB0aHJlc2hvbGRzLnNzICYmIFsncycsIHNlY29uZHNdICB8fFxuICAgICAgICAgICAgc2Vjb25kcyA8IHRocmVzaG9sZHMucyAgICYmIFsnc3MnLCBzZWNvbmRzXSB8fFxuICAgICAgICAgICAgbWludXRlcyA8PSAxICAgICAgICAgICAgICYmIFsnbSddICAgICAgICAgICB8fFxuICAgICAgICAgICAgbWludXRlcyA8IHRocmVzaG9sZHMubSAgICYmIFsnbW0nLCBtaW51dGVzXSB8fFxuICAgICAgICAgICAgaG91cnMgICA8PSAxICAgICAgICAgICAgICYmIFsnaCddICAgICAgICAgICB8fFxuICAgICAgICAgICAgaG91cnMgICA8IHRocmVzaG9sZHMuaCAgICYmIFsnaGgnLCBob3Vyc10gICB8fFxuICAgICAgICAgICAgZGF5cyAgICA8PSAxICAgICAgICAgICAgICYmIFsnZCddICAgICAgICAgICB8fFxuICAgICAgICAgICAgZGF5cyAgICA8IHRocmVzaG9sZHMuZCAgICYmIFsnZGQnLCBkYXlzXSAgICB8fFxuICAgICAgICAgICAgbW9udGhzICA8PSAxICAgICAgICAgICAgICYmIFsnTSddICAgICAgICAgICB8fFxuICAgICAgICAgICAgbW9udGhzICA8IHRocmVzaG9sZHMuTSAgICYmIFsnTU0nLCBtb250aHNdICB8fFxuICAgICAgICAgICAgeWVhcnMgICA8PSAxICAgICAgICAgICAgICYmIFsneSddICAgICAgICAgICB8fCBbJ3l5JywgeWVhcnNdO1xuXG4gICAgYVsyXSA9IHdpdGhvdXRTdWZmaXg7XG4gICAgYVszXSA9ICtwb3NOZWdEdXJhdGlvbiA+IDA7XG4gICAgYVs0XSA9IGxvY2FsZTtcbiAgICByZXR1cm4gc3Vic3RpdHV0ZVRpbWVBZ28uYXBwbHkobnVsbCwgYSk7XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgdGhlIHJvdW5kaW5nIGZ1bmN0aW9uIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbmZ1bmN0aW9uIGdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nIChyb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgaWYgKHJvdW5kaW5nRnVuY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcm91bmQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2Yocm91bmRpbmdGdW5jdGlvbikgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcm91bmQgPSByb3VuZGluZ0Z1bmN0aW9uO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IGEgdGhyZXNob2xkIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbmZ1bmN0aW9uIGdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZCAodGhyZXNob2xkLCBsaW1pdCkge1xuICAgIGlmICh0aHJlc2hvbGRzW3RocmVzaG9sZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChsaW1pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aHJlc2hvbGRzW3RocmVzaG9sZF07XG4gICAgfVxuICAgIHRocmVzaG9sZHNbdGhyZXNob2xkXSA9IGxpbWl0O1xuICAgIGlmICh0aHJlc2hvbGQgPT09ICdzJykge1xuICAgICAgICB0aHJlc2hvbGRzLnNzID0gbGltaXQgLSAxO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaHVtYW5pemUgKHdpdGhTdWZmaXgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgIH1cblxuICAgIHZhciBsb2NhbGUgPSB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICB2YXIgb3V0cHV0ID0gcmVsYXRpdmVUaW1lJDEodGhpcywgIXdpdGhTdWZmaXgsIGxvY2FsZSk7XG5cbiAgICBpZiAod2l0aFN1ZmZpeCkge1xuICAgICAgICBvdXRwdXQgPSBsb2NhbGUucGFzdEZ1dHVyZSgrdGhpcywgb3V0cHV0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbG9jYWxlLnBvc3Rmb3JtYXQob3V0cHV0KTtcbn1cblxudmFyIGFicyQxID0gTWF0aC5hYnM7XG5cbmZ1bmN0aW9uIHNpZ24oeCkge1xuICAgIHJldHVybiAoKHggPiAwKSAtICh4IDwgMCkpIHx8ICt4O1xufVxuXG5mdW5jdGlvbiB0b0lTT1N0cmluZyQxKCkge1xuICAgIC8vIGZvciBJU08gc3RyaW5ncyB3ZSBkbyBub3QgdXNlIHRoZSBub3JtYWwgYnViYmxpbmcgcnVsZXM6XG4gICAgLy8gICogbWlsbGlzZWNvbmRzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSBob3Vyc1xuICAgIC8vICAqIGRheXMgZG8gbm90IGJ1YmJsZSBhdCBhbGxcbiAgICAvLyAgKiBtb250aHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIHllYXJzXG4gICAgLy8gVGhpcyBpcyBiZWNhdXNlIHRoZXJlIGlzIG5vIGNvbnRleHQtZnJlZSBjb252ZXJzaW9uIGJldHdlZW4gaG91cnMgYW5kIGRheXNcbiAgICAvLyAodGhpbmsgb2YgY2xvY2sgY2hhbmdlcylcbiAgICAvLyBhbmQgYWxzbyBub3QgYmV0d2VlbiBkYXlzIGFuZCBtb250aHMgKDI4LTMxIGRheXMgcGVyIG1vbnRoKVxuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgfVxuXG4gICAgdmFyIHNlY29uZHMgPSBhYnMkMSh0aGlzLl9taWxsaXNlY29uZHMpIC8gMTAwMDtcbiAgICB2YXIgZGF5cyAgICAgICAgID0gYWJzJDEodGhpcy5fZGF5cyk7XG4gICAgdmFyIG1vbnRocyAgICAgICA9IGFicyQxKHRoaXMuX21vbnRocyk7XG4gICAgdmFyIG1pbnV0ZXMsIGhvdXJzLCB5ZWFycztcblxuICAgIC8vIDM2MDAgc2Vjb25kcyAtPiA2MCBtaW51dGVzIC0+IDEgaG91clxuICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICBob3VycyAgICAgICAgICAgICA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgc2Vjb25kcyAlPSA2MDtcbiAgICBtaW51dGVzICU9IDYwO1xuXG4gICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgIHllYXJzICA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICBtb250aHMgJT0gMTI7XG5cblxuICAgIC8vIGluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9kb3JkaWxsZS9tb21lbnQtaXNvZHVyYXRpb24vYmxvYi9tYXN0ZXIvbW9tZW50Lmlzb2R1cmF0aW9uLmpzXG4gICAgdmFyIFkgPSB5ZWFycztcbiAgICB2YXIgTSA9IG1vbnRocztcbiAgICB2YXIgRCA9IGRheXM7XG4gICAgdmFyIGggPSBob3VycztcbiAgICB2YXIgbSA9IG1pbnV0ZXM7XG4gICAgdmFyIHMgPSBzZWNvbmRzID8gc2Vjb25kcy50b0ZpeGVkKDMpLnJlcGxhY2UoL1xcLj8wKyQvLCAnJykgOiAnJztcbiAgICB2YXIgdG90YWwgPSB0aGlzLmFzU2Vjb25kcygpO1xuXG4gICAgaWYgKCF0b3RhbCkge1xuICAgICAgICAvLyB0aGlzIGlzIHRoZSBzYW1lIGFzIEMjJ3MgKE5vZGEpIGFuZCBweXRob24gKGlzb2RhdGUpLi4uXG4gICAgICAgIC8vIGJ1dCBub3Qgb3RoZXIgSlMgKGdvb2cuZGF0ZSlcbiAgICAgICAgcmV0dXJuICdQMEQnO1xuICAgIH1cblxuICAgIHZhciB0b3RhbFNpZ24gPSB0b3RhbCA8IDAgPyAnLScgOiAnJztcbiAgICB2YXIgeW1TaWduID0gc2lnbih0aGlzLl9tb250aHMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuICAgIHZhciBkYXlzU2lnbiA9IHNpZ24odGhpcy5fZGF5cykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG4gICAgdmFyIGhtc1NpZ24gPSBzaWduKHRoaXMuX21pbGxpc2Vjb25kcykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG5cbiAgICByZXR1cm4gdG90YWxTaWduICsgJ1AnICtcbiAgICAgICAgKFkgPyB5bVNpZ24gKyBZICsgJ1knIDogJycpICtcbiAgICAgICAgKE0gPyB5bVNpZ24gKyBNICsgJ00nIDogJycpICtcbiAgICAgICAgKEQgPyBkYXlzU2lnbiArIEQgKyAnRCcgOiAnJykgK1xuICAgICAgICAoKGggfHwgbSB8fCBzKSA/ICdUJyA6ICcnKSArXG4gICAgICAgIChoID8gaG1zU2lnbiArIGggKyAnSCcgOiAnJykgK1xuICAgICAgICAobSA/IGhtc1NpZ24gKyBtICsgJ00nIDogJycpICtcbiAgICAgICAgKHMgPyBobXNTaWduICsgcyArICdTJyA6ICcnKTtcbn1cblxudmFyIHByb3RvJDIgPSBEdXJhdGlvbi5wcm90b3R5cGU7XG5cbnByb3RvJDIuaXNWYWxpZCAgICAgICAgPSBpc1ZhbGlkJDE7XG5wcm90byQyLmFicyAgICAgICAgICAgID0gYWJzO1xucHJvdG8kMi5hZGQgICAgICAgICAgICA9IGFkZCQxO1xucHJvdG8kMi5zdWJ0cmFjdCAgICAgICA9IHN1YnRyYWN0JDE7XG5wcm90byQyLmFzICAgICAgICAgICAgID0gYXM7XG5wcm90byQyLmFzTWlsbGlzZWNvbmRzID0gYXNNaWxsaXNlY29uZHM7XG5wcm90byQyLmFzU2Vjb25kcyAgICAgID0gYXNTZWNvbmRzO1xucHJvdG8kMi5hc01pbnV0ZXMgICAgICA9IGFzTWludXRlcztcbnByb3RvJDIuYXNIb3VycyAgICAgICAgPSBhc0hvdXJzO1xucHJvdG8kMi5hc0RheXMgICAgICAgICA9IGFzRGF5cztcbnByb3RvJDIuYXNXZWVrcyAgICAgICAgPSBhc1dlZWtzO1xucHJvdG8kMi5hc01vbnRocyAgICAgICA9IGFzTW9udGhzO1xucHJvdG8kMi5hc1llYXJzICAgICAgICA9IGFzWWVhcnM7XG5wcm90byQyLnZhbHVlT2YgICAgICAgID0gdmFsdWVPZiQxO1xucHJvdG8kMi5fYnViYmxlICAgICAgICA9IGJ1YmJsZTtcbnByb3RvJDIuY2xvbmUgICAgICAgICAgPSBjbG9uZSQxO1xucHJvdG8kMi5nZXQgICAgICAgICAgICA9IGdldCQyO1xucHJvdG8kMi5taWxsaXNlY29uZHMgICA9IG1pbGxpc2Vjb25kcztcbnByb3RvJDIuc2Vjb25kcyAgICAgICAgPSBzZWNvbmRzO1xucHJvdG8kMi5taW51dGVzICAgICAgICA9IG1pbnV0ZXM7XG5wcm90byQyLmhvdXJzICAgICAgICAgID0gaG91cnM7XG5wcm90byQyLmRheXMgICAgICAgICAgID0gZGF5cztcbnByb3RvJDIud2Vla3MgICAgICAgICAgPSB3ZWVrcztcbnByb3RvJDIubW9udGhzICAgICAgICAgPSBtb250aHM7XG5wcm90byQyLnllYXJzICAgICAgICAgID0geWVhcnM7XG5wcm90byQyLmh1bWFuaXplICAgICAgID0gaHVtYW5pemU7XG5wcm90byQyLnRvSVNPU3RyaW5nICAgID0gdG9JU09TdHJpbmckMTtcbnByb3RvJDIudG9TdHJpbmcgICAgICAgPSB0b0lTT1N0cmluZyQxO1xucHJvdG8kMi50b0pTT04gICAgICAgICA9IHRvSVNPU3RyaW5nJDE7XG5wcm90byQyLmxvY2FsZSAgICAgICAgID0gbG9jYWxlO1xucHJvdG8kMi5sb2NhbGVEYXRhICAgICA9IGxvY2FsZURhdGE7XG5cbi8vIERlcHJlY2F0aW9uc1xucHJvdG8kMi50b0lzb1N0cmluZyA9IGRlcHJlY2F0ZSgndG9Jc29TdHJpbmcoKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRvSVNPU3RyaW5nKCkgaW5zdGVhZCAobm90aWNlIHRoZSBjYXBpdGFscyknLCB0b0lTT1N0cmluZyQxKTtcbnByb3RvJDIubGFuZyA9IGxhbmc7XG5cbi8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignWCcsIDAsIDAsICd1bml4Jyk7XG5hZGRGb3JtYXRUb2tlbigneCcsIDAsIDAsICd2YWx1ZU9mJyk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbigneCcsIG1hdGNoU2lnbmVkKTtcbmFkZFJlZ2V4VG9rZW4oJ1gnLCBtYXRjaFRpbWVzdGFtcCk7XG5hZGRQYXJzZVRva2VuKCdYJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgY29uZmlnLl9kID0gbmV3IERhdGUocGFyc2VGbG9hdChpbnB1dCwgMTApICogMTAwMCk7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ3gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSh0b0ludChpbnB1dCkpO1xufSk7XG5cbi8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuXG5ob29rcy52ZXJzaW9uID0gJzIuMTkuMSc7XG5cbnNldEhvb2tDYWxsYmFjayhjcmVhdGVMb2NhbCk7XG5cbmhvb2tzLmZuICAgICAgICAgICAgICAgICAgICA9IHByb3RvO1xuaG9va3MubWluICAgICAgICAgICAgICAgICAgID0gbWluO1xuaG9va3MubWF4ICAgICAgICAgICAgICAgICAgID0gbWF4O1xuaG9va3Mubm93ICAgICAgICAgICAgICAgICAgID0gbm93O1xuaG9va3MudXRjICAgICAgICAgICAgICAgICAgID0gY3JlYXRlVVRDO1xuaG9va3MudW5peCAgICAgICAgICAgICAgICAgID0gY3JlYXRlVW5peDtcbmhvb2tzLm1vbnRocyAgICAgICAgICAgICAgICA9IGxpc3RNb250aHM7XG5ob29rcy5pc0RhdGUgICAgICAgICAgICAgICAgPSBpc0RhdGU7XG5ob29rcy5sb2NhbGUgICAgICAgICAgICAgICAgPSBnZXRTZXRHbG9iYWxMb2NhbGU7XG5ob29rcy5pbnZhbGlkICAgICAgICAgICAgICAgPSBjcmVhdGVJbnZhbGlkO1xuaG9va3MuZHVyYXRpb24gICAgICAgICAgICAgID0gY3JlYXRlRHVyYXRpb247XG5ob29rcy5pc01vbWVudCAgICAgICAgICAgICAgPSBpc01vbWVudDtcbmhvb2tzLndlZWtkYXlzICAgICAgICAgICAgICA9IGxpc3RXZWVrZGF5cztcbmhvb2tzLnBhcnNlWm9uZSAgICAgICAgICAgICA9IGNyZWF0ZUluWm9uZTtcbmhvb2tzLmxvY2FsZURhdGEgICAgICAgICAgICA9IGdldExvY2FsZTtcbmhvb2tzLmlzRHVyYXRpb24gICAgICAgICAgICA9IGlzRHVyYXRpb247XG5ob29rcy5tb250aHNTaG9ydCAgICAgICAgICAgPSBsaXN0TW9udGhzU2hvcnQ7XG5ob29rcy53ZWVrZGF5c01pbiAgICAgICAgICAgPSBsaXN0V2Vla2RheXNNaW47XG5ob29rcy5kZWZpbmVMb2NhbGUgICAgICAgICAgPSBkZWZpbmVMb2NhbGU7XG5ob29rcy51cGRhdGVMb2NhbGUgICAgICAgICAgPSB1cGRhdGVMb2NhbGU7XG5ob29rcy5sb2NhbGVzICAgICAgICAgICAgICAgPSBsaXN0TG9jYWxlcztcbmhvb2tzLndlZWtkYXlzU2hvcnQgICAgICAgICA9IGxpc3RXZWVrZGF5c1Nob3J0O1xuaG9va3Mubm9ybWFsaXplVW5pdHMgICAgICAgID0gbm9ybWFsaXplVW5pdHM7XG5ob29rcy5yZWxhdGl2ZVRpbWVSb3VuZGluZyAgPSBnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZztcbmhvb2tzLnJlbGF0aXZlVGltZVRocmVzaG9sZCA9IGdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZDtcbmhvb2tzLmNhbGVuZGFyRm9ybWF0ICAgICAgICA9IGdldENhbGVuZGFyRm9ybWF0O1xuaG9va3MucHJvdG90eXBlICAgICAgICAgICAgID0gcHJvdG87XG5cbnJldHVybiBob29rcztcblxufSkpKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gYm91bmRhcnlfdG9fZG90KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnNwbGl0KCddWycpLmpvaW4oJy4nKS5zcGxpdCgnWycpLmpvaW4oJy4nKTtcbn1cbmZ1bmN0aW9uIHN0cmlwX2JyYWNlcyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5zcGxpdCgnWycpLmpvaW4oJy4nKS5zcGxpdCgnXScpLmpvaW4oJycpO1xufVxuZnVuY3Rpb24gZXNjYXBlX2RvdHModmFsdWUpIHtcbiAgICB2YXIgdmFsID0gdmFsdWUuc3BsaXQoJ1xcJycpO1xuICAgIHJldHVybiAodmFsLmxlbmd0aCA8IDMpID8gdmFsLmpvaW4oJ1xcJycpIDogdmFsLm1hcChmdW5jdGlvbiAoc2VnKSB7XG4gICAgICAgIGlmIChzZWcubGVuZ3RoIDwgMylcbiAgICAgICAgICAgIHJldHVybiBzZWc7XG4gICAgICAgIGlmICgoc2VnWzBdID09PSAnLicpIHx8IChzZWdbc2VnLmxlbmd0aCAtIDFdID09PSAnLicpKVxuICAgICAgICAgICAgcmV0dXJuIHNlZztcbiAgICAgICAgcmV0dXJuIHNlZy5zcGxpdCgnLicpLmpvaW4oJyYmJyk7XG4gICAgfSkuam9pbignJyk7XG59XG5mdW5jdGlvbiB1bmVzY2FwZV9kb3RzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnNwbGl0KCcmJicpLmpvaW4oJy4nKTtcbn1cbmZ1bmN0aW9uIHBhcnRpZnkodmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlKVxuICAgICAgICByZXR1cm47XG4gICAgcmV0dXJuIGVzY2FwZV9kb3RzKHN0cmlwX2JyYWNlcyhib3VuZGFyeV90b19kb3QoJycgKyB2YWx1ZSkpKS5zcGxpdCgnLicpO1xufVxuZnVuY3Rpb24gY2FuQ2xvbmUobykge1xuICAgIHJldHVybiAodHlwZW9mIG8uX19DTE9ORV9fID09PSAnZnVuY3Rpb24nKTtcbn1cbmZ1bmN0aW9uIGNsb25lKG8pIHtcbiAgICBpZiAoKHR5cGVvZiBvICE9PSAnb2JqZWN0JykgfHwgKG8gPT09IG51bGwpKVxuICAgICAgICByZXR1cm4gbztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvKSlcbiAgICAgICAgcmV0dXJuIG8ubWFwKGNsb25lKTtcbiAgICByZXR1cm4gKGNhbkNsb25lKG8pKSA/XG4gICAgICAgIG8uX19DTE9ORV9fKGNsb25lKSA6IChvLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpID8gbyA6XG4gICAgICAgIE9iamVjdC5rZXlzKG8pLnJlZHVjZShmdW5jdGlvbiAocHJlLCBrKSB7XG4gICAgICAgICAgICBwcmVba10gPSAodHlwZW9mIG9ba10gPT09ICdvYmplY3QnKSA/XG4gICAgICAgICAgICAgICAgY2xvbmUob1trXSkgOiBvW2tdO1xuICAgICAgICAgICAgcmV0dXJuIHByZTtcbiAgICAgICAgfSwge30pO1xufVxuZnVuY3Rpb24gZ2V0KHBhdGgsIG8pIHtcbiAgICB2YXIgcGFydHMgPSBwYXJ0aWZ5KHBhdGgpO1xuICAgIHZhciBmaXJzdDtcbiAgICBpZiAodHlwZW9mIG8gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gb1t1bmVzY2FwZV9kb3RzKHBhcnRzWzBdKV07XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZpcnN0ID0gb1twYXJ0cy5zaGlmdCgpXTtcbiAgICAgICAgcmV0dXJuICgodHlwZW9mIG8gPT09ICdvYmplY3QnKSAmJiAobyAhPT0gbnVsbCkpID9cbiAgICAgICAgICAgIHBhcnRzLnJlZHVjZShmdW5jdGlvbiAodGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRbdW5lc2NhcGVfZG90cyhwcm9wKV07XG4gICAgICAgICAgICB9LCBmaXJzdCkgOiBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZ2V0KCk6IGV4cGVjdHMgYW4gb2JqZWN0IGdvdCAnICsgdHlwZW9mIG8pO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0ID0gZ2V0O1xuO1xuZnVuY3Rpb24gc2V0KHBhdGgsIHZhbHVlLCBvYmopIHtcbiAgICB2YXIgcGFydHMgPSBwYXJ0aWZ5KHBhdGgpO1xuICAgIGlmICgodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHx8IChvYmogPT0gbnVsbCkpIHtcbiAgICAgICAgcmV0dXJuIGNsb25lKG9iaik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gX3NldChvYmosIHZhbHVlLCBwYXJ0cyk7XG4gICAgfVxufVxuZXhwb3J0cy5zZXQgPSBzZXQ7XG47XG5mdW5jdGlvbiBfc2V0KG9iaiwgdmFsdWUsIHBhcnRzKSB7XG4gICAgdmFyIG87XG4gICAgdmFyIGs7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIG8gPSAoKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB8fCAob2JqID09PSBudWxsKSkgPyB7fSA6IGNsb25lKG9iaik7XG4gICAgayA9IHVuZXNjYXBlX2RvdHMocGFydHNbMF0pO1xuICAgIG9ba10gPSBfc2V0KG9ba10sIHZhbHVlLCBwYXJ0cy5zbGljZSgxKSk7XG4gICAgcmV0dXJuIG87XG59XG5mdW5jdGlvbiBkZWZhdWx0XzEoaywgdiwgbykge1xuICAgIGlmIChvID09IG51bGwpXG4gICAgICAgIHJldHVybiBnZXQoaywgdik7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gc2V0KGssIHYsIG8pO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZGVmYXVsdF8xO1xuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl19
